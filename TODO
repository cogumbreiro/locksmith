This file contains stuff to be done on the locksmith implementation
-------------------------------------------------------------------

BUGS:

- make sure we only treat semaphores initialized to 1 as locks.

- Context-sensitive, flow-sensitive sharing
  - When I run with --flow-compare to see where context-sensitive
    sharing is a win, it appears that there many places in aget that
    think &nthreads is not shared, when it seems to me it should be.
    Is this a bug?

FEATURES:

- Merge uniqueness analysis with liveness analysis to be able to
  remove 3 false alarms in knot.

- Dig further into scalability problems.
  - Apps to try: retawq, mt_daapd_nocodec, nsd_comb, clamd
  Ideas:
  - Can we try making things field insensitive for
    now?  That is, every struct have the same abstract location
    for a given field.
  - How can we make things client-driven?  That is, use the precision
    only where we discover we need it?  What would be the reward
    function for deciding we need more precision?  How would we
    implement improving precision on demand?  Can we estimate
    the value of doing this?

- Fix semi-unification infinite looping problem.
  - Add extended occurs check.
  - Look at drivers (e.g., wavelan) to understand this better.

- Improve the output.  
  - When printing of context-based results, if an instantiation path
    is a prefix of another path, just print the other path. (See
    test6.c)
  - When accessing a field of a struct, don't create an effect on the
    struct pointer itself, only the field's.  Will reduce the number
    of total alarms reported.

- Odds and ends
  - handle realloc properly.  This should be a malloc() function that
    derefs its first argument.
  - strdup is the source of some false alarms.  Make it a malloc
    function in the family of realloc.
  - have banshee functions return Caml arrays of labels rather than
    Caml lists. Should be faster and use less memory.

- Try making malloc() context-sensitive.  Would save a lot of hassle
  when dealing with malloc wrappers, which are reasonably common.

- forkloop2.c is imprecise
  - we should be able to get rid of this race, assuming
    we add liveness to the uniqueness results.
