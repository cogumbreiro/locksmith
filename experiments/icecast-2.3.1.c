/* Generated by CIL v. 1.3.4 */
/* print_CIL_Input is true */

#pragma __DSU_loop("LOOP_SLAVE_THREAD")
#pragma __DSU_loop("LOOP_START_RELAY_STREAM")
#pragma __DSU_loop("LOOP_HANDLE_CONNECTION")
#pragma __DSU_loop("LOOP_SOURCE_MAIN")
#pragma __DSU_loop("LOOP_SOURCE_FALLBACK_FILE")
#pragma __DSU_loop("LOOP_STATS_THREAD")
#pragma __DSU_loop("LOOP_STATS_CONNECTION")
#pragma __DSU_loop("LOOP_FSERV_THREAD_FUNCTION")
#pragma __DSU_loop("LOOP_AUTH_RUN_THREAD")
#pragma __DSU_loop("LOOP_YP_UPDATE_THREAD")

#pragma __DSU_FORCE_UPDATABLE("struct_source_tag")

extern void thread_check_in();
extern void thread_check_out();
extern void thread_register(const char * s);
extern void thread_deregister(const char * s);

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.0.0/include/stddef.h"
typedef unsigned int size_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_1 {
   __fd_mask fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_1 fd_set;
#line 243 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 42 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[(int )(128U - 2U * sizeof(__uint32_t ))] ;
};
#line 308 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 87
struct sockaddr_in6;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_1 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_1 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) -
                                  sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 59 "sock.h"
typedef int sock_t;
#line 48 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_1 {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   int __spins ;
};
#line 48 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_1 {
   struct __anonstruct___data_1 __data ;
   char __size[24] ;
   long __align ;
};
#line 48 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_1 pthread_mutex_t;
#line 47 "./../thread/thread.h"
struct __anonstruct_mutex_t_1 {
   pthread_mutex_t sys_mutex ;
};
#line 47 "./../thread/thread.h"
typedef struct __anonstruct_mutex_t_1 mutex_t;
#line 64 "resolver.c"
union __anonunion_addr_u_1 {
   struct in_addr v4addr ;
   struct in6_addr v6addr ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 109 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_3 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   unsigned int __flags ;
   int __writer ;
};
#line 109 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_1 {
   struct __anonstruct___data_3 __data ;
   char __size[32] ;
   long __align ;
};
#line 109 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_1 pthread_rwlock_t;
#line 76 "./../thread/thread.h"
struct __anonstruct_rwlock_t_1 {
   pthread_rwlock_t sys_rwlock ;
};
#line 76 "./../thread/thread.h"
typedef struct __anonstruct_rwlock_t_1 rwlock_t;
#line 24 "./../avl/avl.h"
struct avl_node_tag {
   void *key ;
   struct avl_node_tag *left ;
   struct avl_node_tag *right ;
   struct avl_node_tag *parent ;
   unsigned long rank_and_balance ;
   rwlock_t rwlock ;
};
#line 24 "./../avl/avl.h"
typedef struct avl_node_tag avl_node;
#line 52
struct _avl_tree;
#line 93 "./../avl/avl.h"
struct _avl_tree {
   avl_node *root ;
   unsigned long height ;
   unsigned long length ;
   int (*compare_fun)(void *compare_arg , void *a , void *b ) ;
   void *compare_arg ;
   rwlock_t rwlock ;
};
#line 93 "./../avl/avl.h"
typedef struct _avl_tree avl_tree;
#line 23 "httpp.h"
enum httpp_request_type_tag {
    httpp_req_none = 0,
    httpp_req_get = 1,
    httpp_req_post = 2,
    httpp_req_head = 3,
    httpp_req_source = 4,
    httpp_req_play = 5,
    httpp_req_stats = 6,
    httpp_req_unknown = 7
};
#line 23 "httpp.h"
typedef enum httpp_request_type_tag httpp_request_type_e;
#line 28 "httpp.h"
struct http_var_tag {
   char *name ;
   char *value ;
};
#line 28 "httpp.h"
typedef struct http_var_tag http_var_t;
#line 33 "httpp.h"
struct http_varlist_tag {
   http_var_t var ;
   struct http_varlist_tag *next ;
};
#line 33 "httpp.h"
typedef struct http_varlist_tag http_varlist_t;
#line 38 "httpp.h"
struct http_parser_tag {
   httpp_request_type_e req_type ;
   char *uri ;
   avl_tree *vars ;
   avl_tree *queryvars ;
};
#line 38 "httpp.h"
typedef struct http_parser_tag http_parser_t;
#line 59 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 56 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
#line 1057 "avl.c"
struct _link_node {
   struct _link_node *parent ;
   char direction ;
   int width ;
};
#line 1057 "avl.c"
typedef struct _link_node link_node;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 39 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_1 {
   char __size[36] ;
   long __align ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_1 pthread_attr_t;
#line 65 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_1 {
   char __size[4] ;
   long __align ;
};
#line 65 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_1 pthread_mutexattr_t;
#line 74 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_2 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 74 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_1 {
   struct __anonstruct___data_2 __data ;
   char __size[48] ;
   long long __align ;
};
#line 74 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_1 pthread_cond_t;
#line 91 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_1 {
   char __size[4] ;
   long __align ;
};
#line 91 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_1 pthread_condattr_t;
#line 128 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_1 {
   char __size[8] ;
   long __align ;
};
#line 128 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_1 pthread_rwlockattr_t;
#line 28 "./../thread/thread.h"
struct __anonstruct_thread_type_1 {
   long thread_id ;
   char *name ;
   time_t create_time ;
   char *file ;
   int line ;
   int detached ;
   pthread_t sys_thread ;
};
#line 28 "./../thread/thread.h"
typedef struct __anonstruct_thread_type_1 thread_type;
#line 66 "./../thread/thread.h"
struct __anonstruct_cond_t_1 {
   pthread_mutex_t cond_mutex ;
   pthread_cond_t sys_cond ;
};
#line 66 "./../thread/thread.h"
typedef struct __anonstruct_cond_t_1 cond_t;
#line 74 "thread.c"
struct thread_start_tag {
   void *(*start_routine)(void * ) ;
   void *arg ;
   thread_type *thread ;
   pthread_t sys_thread ;
};
#line 74 "thread.c"
typedef struct thread_start_tag thread_start_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 131 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 49 "log.c"
struct log_tag {
   int in_use ;
   unsigned int level ;
   char *filename ;
   FILE *logfile ;
   off_t size ;
   off_t trigger_level ;
   int archive_timestamp ;
   char *buffer ;
};
#line 49 "log.c"
typedef struct log_tag log_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 201 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 206 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 229 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 23 "cfgfile.h"
struct _mount_proxy;
#line 20 "auth.h"
struct source_tag;
#line 21
struct auth_tag;
#line 29 "/usr/include/libxml2/libxml/xmlstring.h"
typedef unsigned char xmlChar;
#line 82 "/usr/include/libxml2/libxml/tree.h"
enum __anonenum_xmlElementType_1 {
    XML_ELEMENT_NODE = 1,
    XML_ATTRIBUTE_NODE = 2,
    XML_TEXT_NODE = 3,
    XML_CDATA_SECTION_NODE = 4,
    XML_ENTITY_REF_NODE = 5,
    XML_ENTITY_NODE = 6,
    XML_PI_NODE = 7,
    XML_COMMENT_NODE = 8,
    XML_DOCUMENT_NODE = 9,
    XML_DOCUMENT_TYPE_NODE = 10,
    XML_DOCUMENT_FRAG_NODE = 11,
    XML_NOTATION_NODE = 12,
    XML_HTML_DOCUMENT_NODE = 13,
    XML_DTD_NODE = 14,
    XML_ELEMENT_DECL = 15,
    XML_ATTRIBUTE_DECL = 16,
    XML_ENTITY_DECL = 17,
    XML_NAMESPACE_DECL = 18,
    XML_XINCLUDE_START = 19,
    XML_XINCLUDE_END = 20,
    XML_DOCB_DOCUMENT_NODE = 21
};
#line 82 "/usr/include/libxml2/libxml/tree.h"
typedef enum __anonenum_xmlElementType_1 xmlElementType;
#line 129
enum __anonenum_xmlAttributeType_1 {
    XML_ATTRIBUTE_CDATA = 1,
    XML_ATTRIBUTE_ID = 2,
    XML_ATTRIBUTE_IDREF = 3,
    XML_ATTRIBUTE_IDREFS = 4,
    XML_ATTRIBUTE_ENTITY = 5,
    XML_ATTRIBUTE_ENTITIES = 6,
    XML_ATTRIBUTE_NMTOKEN = 7,
    XML_ATTRIBUTE_NMTOKENS = 8,
    XML_ATTRIBUTE_ENUMERATION = 9,
    XML_ATTRIBUTE_NOTATION = 10
};
#line 129 "/usr/include/libxml2/libxml/tree.h"
typedef enum __anonenum_xmlAttributeType_1 xmlAttributeType;
#line 176
struct _xmlNode;
#line 176
struct _xmlDtd;
#line 176
struct _xmlDoc;
#line 299 "/usr/include/libxml2/libxml/tree.h"
typedef xmlElementType xmlNsType;
#line 311
struct _xmlNs;
#line 311 "/usr/include/libxml2/libxml/tree.h"
typedef struct _xmlNs xmlNs;
#line 313 "/usr/include/libxml2/libxml/tree.h"
struct _xmlNs {
   struct _xmlNs *next ;
   xmlNsType type ;
   xmlChar const   *href ;
   xmlChar const   *prefix ;
   void *_private ;
};
#line 329 "/usr/include/libxml2/libxml/tree.h"
struct _xmlDtd {
   void *_private ;
   xmlElementType type ;
   xmlChar const   *name ;
   struct _xmlNode *children ;
   struct _xmlNode *last ;
   struct _xmlDoc *parent ;
   struct _xmlNode *next ;
   struct _xmlNode *prev ;
   struct _xmlDoc *doc ;
   void *notations ;
   void *elements ;
   void *attributes ;
   void *entities ;
   xmlChar const   *ExternalID ;
   xmlChar const   *SystemID ;
   void *pentities ;
};
#line 355
struct _xmlAttr;
#line 357 "/usr/include/libxml2/libxml/tree.h"
struct _xmlAttr {
   void *_private ;
   xmlElementType type ;
   xmlChar const   *name ;
   struct _xmlNode *children ;
   struct _xmlNode *last ;
   struct _xmlNode *parent ;
   struct _xmlAttr *next ;
   struct _xmlAttr *prev ;
   struct _xmlDoc *doc ;
   xmlNs *ns ;
   xmlAttributeType atype ;
   void *psvi ;
};
#line 437 "/usr/include/libxml2/libxml/tree.h"
typedef struct _xmlNode xmlNode;
#line 438 "/usr/include/libxml2/libxml/tree.h"
typedef xmlNode *xmlNodePtr;
#line 439 "/usr/include/libxml2/libxml/tree.h"
struct _xmlNode {
   void *_private ;
   xmlElementType type ;
   xmlChar const   *name ;
   struct _xmlNode *children ;
   struct _xmlNode *last ;
   struct _xmlNode *parent ;
   struct _xmlNode *next ;
   struct _xmlNode *prev ;
   struct _xmlDoc *doc ;
   xmlNs *ns ;
   xmlChar *content ;
   struct _xmlAttr *properties ;
   xmlNs *nsDef ;
   void *psvi ;
   unsigned short line ;
   unsigned short extra ;
};
#line 484
struct _xmlDict;
#line 484 "/usr/include/libxml2/libxml/tree.h"
struct _xmlDoc {
   void *_private ;
   xmlElementType type ;
   char *name ;
   struct _xmlNode *children ;
   struct _xmlNode *last ;
   struct _xmlNode *parent ;
   struct _xmlNode *next ;
   struct _xmlNode *prev ;
   struct _xmlDoc *doc ;
   int compression ;
   int standalone ;
   struct _xmlDtd *intSubset ;
   struct _xmlDtd *extSubset ;
   struct _xmlNs *oldNs ;
   xmlChar const   *version ;
   xmlChar const   *encoding ;
   void *ids ;
   void *refs ;
   xmlChar const   *URL ;
   int charset ;
   struct _xmlDict *dict ;
   void *psvi ;
};
#line 23 "connection.h"
struct _client_tag;
#line 26 "connection.h"
struct connection_tag {
   unsigned long id ;
   time_t con_time ;
   time_t discon_time ;
   uint64_t sent_bytes ;
   int sock ;
   int serversock ;
   int error ;
   char *ip ;
   char *host ;
};
#line 26 "connection.h"
typedef struct connection_tag connection_t;
#line 21 "refbuf.h"
struct _refbuf_tag {
   char *data ;
   unsigned long len ;
   int sync_point ;
   struct _refbuf_tag *associated ;
   struct _refbuf_tag *next ;
   unsigned long _count ;
};
#line 21 "refbuf.h"
typedef struct _refbuf_tag refbuf_t;
#line 25 "client.h"
struct _client_tag {
   connection_t *con ;
   http_parser_t *parser ;
   int respcode ;
   int authenticated ;
   long intro_offset ;
   refbuf_t *refbuf ;
   unsigned long pos ;
   struct auth_tag *auth ;
   char *username ;
   char *password ;
   void *format_data ;
   void (*free_client_data)(struct _client_tag *client ) ;
   int (*write_to_client)(struct _client_tag *client ) ;
   int (*check_buffer)(struct source_tag *source , struct _client_tag *client ) ;
};
#line 25 "client.h"
typedef struct _client_tag client_t;
#line 30 "auth.h"
enum __anonenum_auth_result_1 {
    AUTH_UNDEFINED = 0,
    AUTH_OK = 1,
    AUTH_FAILED = 2,
    AUTH_FORBIDDEN = 3,
    AUTH_USERADDED = 4,
    AUTH_USEREXISTS = 5,
    AUTH_USERDELETED = 6
};
#line 30 "auth.h"
typedef enum __anonenum_auth_result_1 auth_result;
#line 41 "auth.h"
struct auth_client_tag {
   char *mount ;
   client_t *client ;
   void (*process)(struct auth_client_tag *auth_user ) ;
   struct auth_client_tag *next ;
};
#line 41 "auth.h"
typedef struct auth_client_tag auth_client;
#line 50 "auth.h"
struct auth_tag {
   char *mount ;
   auth_result (*authenticate)(auth_client *aclient ) ;
   auth_result (*release_client)(auth_client *auth_user ) ;
   void (*stream_start)(auth_client *auth_user ) ;
   void (*stream_end)(auth_client *auth_user ) ;
   void (*free)(struct auth_tag *self ) ;
   auth_result (*adduser)(struct auth_tag *auth , char const   *username , char const   *password ) ;
   auth_result (*deleteuser)(struct auth_tag *auth , char const   *username ) ;
   auth_result (*listuser)(struct auth_tag *auth , xmlNodePtr srcnode ) ;
   mutex_t lock ;
   int refcount ;
   int allow_duplicate_users ;
   void *state ;
   char *type ;
};
#line 18 "slave.h"
struct _relay_server {
   char *server ;
   int port ;
   char *mount ;
   char *username ;
   char *password ;
   char *localmount ;
   struct source_tag *source ;
   int mp3metadata ;
   int on_demand ;
   int running ;
   int cleanup ;
   thread_type *thread ;
   struct _relay_server *next ;
};
#line 18 "slave.h"
typedef struct _relay_server relay_server;
#line 28 "global.h"
struct ice_global_tag {
   int serversock[20] ;
   int server_sockets ;
   int running ;
   int sources ;
   int clients ;
   int schedule_config_reread ;
   avl_tree *source_tree ;
   struct _relay_server *relays ;
   struct _relay_server *master_relays ;
   cond_t shutdown_cond ;
};
#line 28 "global.h"
typedef struct ice_global_tag ice_global_t;
#line 30 "cfgfile.h"
struct ice_config_dir_tag {
   char *host ;
   int touch_interval ;
   struct ice_config_dir_tag *next ;
};
#line 30 "cfgfile.h"
typedef struct ice_config_dir_tag ice_config_dir_t;
#line 37 "cfgfile.h"
struct _config_options {
   char *name ;
   char *value ;
   struct _config_options *next ;
};
#line 37 "cfgfile.h"
typedef struct _config_options config_options_t;
#line 43 "cfgfile.h"
struct _mount_proxy {
   char *mountname ;
   char *username ;
   char *password ;
   char *dumpfile ;
   char *intro_filename ;
   int fallback_when_full ;
   int max_listeners ;
   char *fallback_mount ;
   int fallback_override ;
   int no_mount ;
   int burst_size ;
   unsigned int queue_size_limit ;
   int hidden ;
   unsigned int source_timeout ;
   int mp3_meta_interval ;
   char *auth_type ;
   struct auth_tag *auth ;
   char *cluster_password ;
   config_options_t *auth_options ;
   char *on_connect ;
   char *on_disconnect ;
   unsigned int max_listener_duration ;
   char *stream_name ;
   char *stream_description ;
   char *stream_url ;
   char *stream_genre ;
   char *bitrate ;
   char *type ;
   char *subtype ;
   int yp_public ;
   struct _mount_proxy *next ;
};
#line 43 "cfgfile.h"
typedef struct _mount_proxy mount_proxy;
#line 89 "cfgfile.h"
struct _aliases {
   char *source ;
   char *destination ;
   int port ;
   char *bind_address ;
   struct _aliases *next ;
};
#line 89 "cfgfile.h"
typedef struct _aliases aliases;
#line 97 "cfgfile.h"
struct __anonstruct_listener_t_1 {
   int port ;
   char *bind_address ;
   int shoutcast_compat ;
};
#line 97 "cfgfile.h"
typedef struct __anonstruct_listener_t_1 listener_t;
#line 103 "cfgfile.h"
struct ice_config_tag {
   char *config_filename ;
   char *location ;
   char *admin ;
   int client_limit ;
   int source_limit ;
   unsigned int queue_size_limit ;
   int threadpool_size ;
   unsigned int burst_size ;
   int client_timeout ;
   int header_timeout ;
   int source_timeout ;
   int ice_login ;
   int fileserve ;
   int on_demand ;
   char *shoutcast_mount ;
   char *source_password ;
   char *admin_username ;
   char *admin_password ;
   char *relay_username ;
   char *relay_password ;
   int touch_interval ;
   ice_config_dir_t *dir_list ;
   char *hostname ;
   int port ;
   listener_t listeners[20] ;
   char *master_server ;
   int master_server_port ;
   int master_update_interval ;
   char *master_username ;
   char *master_password ;
   relay_server *relay ;
   mount_proxy *mounts ;
   char *base_dir ;
   char *log_dir ;
   char *pidfile ;
   char *webroot_dir ;
   char *adminroot_dir ;
   aliases *aliases ;
   char *access_log ;
   char *error_log ;
   char *playlist_log ;
   int loglevel ;
   int logsize ;
   int logarchive ;
   int chroot ;
   int chuid ;
   char *user ;
   char *group ;
   char *yp_url[25] ;
   int yp_url_timeout[25] ;
   int yp_touch_interval[25] ;
   int num_yp_directories ;
};
#line 103 "cfgfile.h"
typedef struct ice_config_tag ice_config_t;
#line 38 "util.h"
struct _util_dict {
   char *key ;
   char *val ;
   struct _util_dict *next ;
};
#line 38 "util.h"
typedef struct _util_dict util_dict;
#line 28 "format.h"
enum _format_type_tag {
    FORMAT_ERROR = 0,
    FORMAT_TYPE_OGG = 1,
    FORMAT_TYPE_GENERIC = 2
};
#line 28 "format.h"
typedef enum _format_type_tag format_type_t;
#line 35 "format.h"
struct _format_plugin_tag {
   format_type_t type ;
   char *mount ;
   char *contenttype ;
   uint64_t read_bytes ;
   uint64_t sent_bytes ;
   refbuf_t *(*get_buffer)(struct source_tag * ) ;
   int (*write_buf_to_client)(client_t *client ) ;
   void (*write_buf_to_file)(struct source_tag *source , refbuf_t *refbuf ) ;
   int (*create_client_data)(struct source_tag *source , client_t *client ) ;
   void (*set_tag)(struct _format_plugin_tag *plugin , char *tag , char *value ) ;
   void (*free_plugin)(struct _format_plugin_tag *self ) ;
   void (*apply_settings)(client_t *client , struct _format_plugin_tag *format , struct _mount_proxy *mount ) ;
   void *_state ;
};
#line 23 "source.h"
struct source_tag {
   client_t *client ;
   connection_t *con ;
   http_parser_t *parser ;
   time_t client_stats_update ;
   char *mount ;
   char *fallback_mount ;
   int running ;
   struct _format_plugin_tag *format ;
   avl_tree *client_tree ;
   avl_tree *pending_tree ;
   rwlock_t *shutdown_rwlock ;
   util_dict *audio_info ;
   FILE *intro_file ;
   char *dumpfilename ;
   FILE *dumpfile ;
   unsigned long peak_listeners ;
   unsigned long listeners ;
   long max_listeners ;
   int yp_public ;
   int fallback_override ;
   int fallback_when_full ;
   int shoutcast_compat ;
   unsigned int burst_size ;
   unsigned int burst_offset ;
   refbuf_t *burst_point ;
   unsigned int queue_size ;
   unsigned int queue_size_limit ;
   unsigned int timeout ;
   int on_demand ;
   int on_demand_req ;
   int hidden ;
   time_t last_read ;
   int short_delay ;
   refbuf_t *stream_data ;
   refbuf_t *stream_data_tail ;
};
#line 30 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 33 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 171 "cfgfile.h"
struct __anonstruct_ice_config_locks_1 {
   rwlock_t config_lock ;
   mutex_t relay_lock ;
};
#line 171 "cfgfile.h"
typedef struct __anonstruct_ice_config_locks_1 ice_config_locks;
#line 23 "source.h"
typedef struct source_tag source_t;
#line 482 "/usr/include/libxml2/libxml/tree.h"
typedef struct _xmlDoc xmlDoc;
#line 483 "/usr/include/libxml2/libxml/tree.h"
typedef xmlDoc *xmlDocPtr;
#line 50 "auth.h"
typedef struct auth_tag auth_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 83 "connection.c"
struct client_queue_tag {
   client_t *client ;
   int offset ;
   int stream_offset ;
   int shoutcast ;
   struct client_queue_tag *next ;
};
#line 83 "connection.c"
typedef struct client_queue_tag client_queue_t;
#line 312 "/usr/include/libxml2/libxml/tree.h"
typedef xmlNs *xmlNsPtr;
#line 355 "/usr/include/libxml2/libxml/tree.h"
typedef struct _xmlAttr xmlAttr;
#line 356 "/usr/include/libxml2/libxml/tree.h"
typedef xmlAttr *xmlAttrPtr;
#line 24 "stats.h"
struct _stats_node_tag {
   char *name ;
   char *value ;
   int hidden ;
};
#line 24 "stats.h"
typedef struct _stats_node_tag stats_node_t;
#line 31 "stats.h"
struct _stats_event_tag {
   char *source ;
   char *name ;
   char *value ;
   int hidden ;
   int action ;
   struct _stats_event_tag *next ;
};
#line 31 "stats.h"
typedef struct _stats_event_tag stats_event_t;
#line 42 "stats.h"
struct _stats_source_tag {
   char *source ;
   int hidden ;
   avl_tree *stats_tree ;
};
#line 42 "stats.h"
typedef struct _stats_source_tag stats_source_t;
#line 49 "stats.h"
struct _stats_tag {
   avl_tree *global_tree ;
   avl_tree *source_tree ;
};
#line 49 "stats.h"
typedef struct _stats_tag stats_t;
#line 54 "stats.c"
struct _event_queue_tag {
   stats_event_t volatile   *head ;
   stats_event_t volatile   **tail ;
};
#line 54 "stats.c"
typedef struct _event_queue_tag event_queue_t;
#line 62 "stats.c"
struct _event_listener_tag {
   event_queue_t queue ;
   mutex_t mutex ;
   struct _event_listener_tag *next ;
};
#line 62 "stats.c"
typedef struct _event_listener_tag event_listener_t;
#line 830 "stats.c"
struct _source_xml_tag {
   char *mount ;
   xmlNodePtr node ;
   struct _source_xml_tag *next ;
};
#line 830 "stats.c"
typedef struct _source_xml_tag source_xml_t;
#line 24 "/usr/include/libxml2/libxml/dict.h"
typedef struct _xmlDict xmlDict;
#line 25 "/usr/include/libxml2/libxml/dict.h"
typedef xmlDict *xmlDictPtr;
#line 21 "/usr/include/libxml2/libxml/hash.h"
struct _xmlHashTable;
#line 21 "/usr/include/libxml2/libxml/hash.h"
typedef struct _xmlHashTable xmlHashTable;
#line 22 "/usr/include/libxml2/libxml/hash.h"
typedef xmlHashTable *xmlHashTablePtr;
#line 24 "/usr/include/libxml2/libxml/xmlerror.h"
enum __anonenum_xmlErrorLevel_1 {
    XML_ERR_NONE = 0,
    XML_ERR_WARNING = 1,
    XML_ERR_ERROR = 2,
    XML_ERR_FATAL = 3
};
#line 24 "/usr/include/libxml2/libxml/xmlerror.h"
typedef enum __anonenum_xmlErrorLevel_1 xmlErrorLevel;
#line 72
struct _xmlError;
#line 72 "/usr/include/libxml2/libxml/xmlerror.h"
typedef struct _xmlError xmlError;
#line 73 "/usr/include/libxml2/libxml/xmlerror.h"
typedef xmlError *xmlErrorPtr;
#line 74 "/usr/include/libxml2/libxml/xmlerror.h"
struct _xmlError {
   int domain ;
   int code ;
   char *message ;
   xmlErrorLevel level ;
   char *file ;
   int line ;
   char *str1 ;
   char *str2 ;
   char *str3 ;
   int int1 ;
   int int2 ;
   void *ctxt ;
   void *node ;
};
#line 38 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlXPathContext;
#line 38 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlXPathContext xmlXPathContext;
#line 39 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlXPathContext *xmlXPathContextPtr;
#line 40
struct _xmlXPathParserContext;
#line 40 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlXPathParserContext xmlXPathParserContext;
#line 41 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlXPathParserContext *xmlXPathParserContextPtr;
#line 76
struct _xmlNodeSet;
#line 76 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlNodeSet xmlNodeSet;
#line 77 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlNodeSet *xmlNodeSetPtr;
#line 78 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlNodeSet {
   int nodeNr ;
   int nodeMax ;
   xmlNodePtr *nodeTab ;
};
#line 96
enum __anonenum_xmlXPathObjectType_1 {
    XPATH_UNDEFINED = 0,
    XPATH_NODESET = 1,
    XPATH_BOOLEAN = 2,
    XPATH_NUMBER = 3,
    XPATH_STRING = 4,
    XPATH_POINT = 5,
    XPATH_RANGE = 6,
    XPATH_LOCATIONSET = 7,
    XPATH_USERS = 8,
    XPATH_XSLT_TREE = 9
};
#line 96 "/usr/include/libxml2/libxml/xpath.h"
typedef enum __anonenum_xmlXPathObjectType_1 xmlXPathObjectType;
#line 109
struct _xmlXPathObject;
#line 109 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlXPathObject xmlXPathObject;
#line 110 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlXPathObject *xmlXPathObjectPtr;
#line 111 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlXPathObject {
   xmlXPathObjectType type ;
   xmlNodeSetPtr nodesetval ;
   int boolval ;
   double floatval ;
   xmlChar *stringval ;
   void *user ;
   int index ;
   void *user2 ;
   int index2 ;
};
#line 139
struct _xmlXPathType;
#line 139 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlXPathType xmlXPathType;
#line 140 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlXPathType *xmlXPathTypePtr;
#line 141 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlXPathType {
   xmlChar const   *name ;
   int (*func)(xmlXPathObjectPtr obj , int type ) ;
};
#line 198
struct _xmlXPathAxis;
#line 198 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlXPathAxis xmlXPathAxis;
#line 199 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlXPathAxis *xmlXPathAxisPtr;
#line 200 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlXPathAxis {
   xmlChar const   *name ;
   xmlXPathObjectPtr (*func)(xmlXPathParserContextPtr ctxt , xmlXPathObjectPtr cur ) ;
};
#line 215 "/usr/include/libxml2/libxml/xpath.h"
typedef void (*xmlXPathFunction)(xmlXPathParserContextPtr ctxt , int nargs );
#line 265 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlXPathContext {
   xmlDocPtr doc ;
   xmlNodePtr node ;
   int nb_variables_unused ;
   int max_variables_unused ;
   xmlHashTablePtr varHash ;
   int nb_types ;
   int max_types ;
   xmlXPathTypePtr types ;
   int nb_funcs_unused ;
   int max_funcs_unused ;
   xmlHashTablePtr funcHash ;
   int nb_axis ;
   int max_axis ;
   xmlXPathAxisPtr axis ;
   xmlNsPtr *namespaces ;
   int nsNr ;
   void *user ;
   int contextSize ;
   int proximityPosition ;
   int xptr ;
   xmlNodePtr here ;
   xmlNodePtr origin ;
   xmlHashTablePtr nsHash ;
   xmlXPathObjectPtr (*varLookupFunc)(void *ctxt , xmlChar const   *name , xmlChar const   *ns_uri ) ;
   void *varLookupData ;
   void *extra ;
   xmlChar const   *function ;
   xmlChar const   *functionURI ;
   xmlXPathFunction (*funcLookupFunc)(void *ctxt , xmlChar const   *name , xmlChar const   *ns_uri ) ;
   void *funcLookupData ;
   xmlNsPtr *tmpNsList ;
   int tmpNsNr ;
   void *userData ;
   void (*error)(void *userData , xmlErrorPtr error ) ;
   xmlError lastError ;
   xmlNodePtr debugNode ;
   xmlDictPtr dict ;
};
#line 333
struct _xmlXPathCompExpr;
#line 333 "/usr/include/libxml2/libxml/xpath.h"
typedef struct _xmlXPathCompExpr xmlXPathCompExpr;
#line 334 "/usr/include/libxml2/libxml/xpath.h"
typedef xmlXPathCompExpr *xmlXPathCompExprPtr;
#line 342 "/usr/include/libxml2/libxml/xpath.h"
struct _xmlXPathParserContext {
   xmlChar const   *cur ;
   xmlChar const   *base ;
   int error ;
   xmlXPathContextPtr context ;
   xmlXPathObjectPtr value ;
   int valueNr ;
   int valueMax ;
   xmlXPathObjectPtr *valueTab ;
   xmlXPathCompExprPtr comp ;
   int xptr ;
   xmlNodePtr ancestor ;
};
#line 25 "/usr/include/libxslt/numbersInternals.h"
struct _xsltNumberData;
#line 25 "/usr/include/libxslt/numbersInternals.h"
typedef struct _xsltNumberData xsltNumberData;
#line 28 "/usr/include/libxslt/numbersInternals.h"
struct _xsltNumberData {
   xmlChar const   *level ;
   xmlChar const   *count ;
   xmlChar const   *from ;
   xmlChar const   *value ;
   xmlChar const   *format ;
   int has_format ;
   int digitsPerGroup ;
   int groupingCharacter ;
   int groupingCharacterLen ;
   xmlDocPtr doc ;
   xmlNodePtr node ;
};
#line 48 "/usr/include/libxslt/xsltInternals.h"
struct _xsltRuntimeExtra;
#line 48 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltRuntimeExtra xsltRuntimeExtra;
#line 49 "/usr/include/libxslt/xsltInternals.h"
typedef xsltRuntimeExtra *xsltRuntimeExtraPtr;
#line 50 "/usr/include/libxslt/xsltInternals.h"
union __anonunion_val_1 {
   void *ptr ;
   int ival ;
};
#line 50 "/usr/include/libxslt/xsltInternals.h"
struct _xsltRuntimeExtra {
   void *info ;
   void (*deallocate)(void *mem ) ;
   union __anonunion_val_1 val ;
};
#line 89
struct _xsltTemplate;
#line 89 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltTemplate xsltTemplate;
#line 90 "/usr/include/libxslt/xsltInternals.h"
typedef xsltTemplate *xsltTemplatePtr;
#line 91
struct _xsltStylesheet;
#line 91 "/usr/include/libxslt/xsltInternals.h"
struct _xsltTemplate {
   struct _xsltTemplate *next ;
   struct _xsltStylesheet *style ;
   xmlChar *match ;
   float priority ;
   xmlChar *name ;
   xmlChar *nameURI ;
   xmlChar const   *mode ;
   xmlChar const   *modeURI ;
   xmlNodePtr content ;
   xmlNodePtr elem ;
   int inheritedNsNr ;
   xmlNsPtr *inheritedNs ;
   int nbCalls ;
   unsigned long time ;
};
#line 116
struct _xsltDecimalFormat;
#line 116 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltDecimalFormat xsltDecimalFormat;
#line 117 "/usr/include/libxslt/xsltInternals.h"
typedef xsltDecimalFormat *xsltDecimalFormatPtr;
#line 118 "/usr/include/libxslt/xsltInternals.h"
struct _xsltDecimalFormat {
   struct _xsltDecimalFormat *next ;
   xmlChar *name ;
   xmlChar *digit ;
   xmlChar *patternSeparator ;
   xmlChar *minusSign ;
   xmlChar *infinity ;
   xmlChar *noNumber ;
   xmlChar *decimalPoint ;
   xmlChar *grouping ;
   xmlChar *percent ;
   xmlChar *permille ;
   xmlChar *zeroDigit ;
};
#line 142
struct _xsltDocument;
#line 142 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltDocument xsltDocument;
#line 143 "/usr/include/libxslt/xsltInternals.h"
typedef xsltDocument *xsltDocumentPtr;
#line 144 "/usr/include/libxslt/xsltInternals.h"
struct _xsltDocument {
   struct _xsltDocument *next ;
   int main ;
   xmlDocPtr doc ;
   void *keys ;
   struct _xsltDocument *includes ;
   int preproc ;
};
#line 153
struct _xsltTransformContext;
#line 153 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltTransformContext xsltTransformContext;
#line 154 "/usr/include/libxslt/xsltInternals.h"
typedef xsltTransformContext *xsltTransformContextPtr;
#line 162
struct _xsltElemPreComp;
#line 162 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltElemPreComp xsltElemPreComp;
#line 163 "/usr/include/libxslt/xsltInternals.h"
typedef xsltElemPreComp *xsltElemPreCompPtr;
#line 191
enum __anonenum_xsltStyleType_1 {
    XSLT_FUNC_COPY = 1,
    XSLT_FUNC_SORT = 2,
    XSLT_FUNC_TEXT = 3,
    XSLT_FUNC_ELEMENT = 4,
    XSLT_FUNC_ATTRIBUTE = 5,
    XSLT_FUNC_COMMENT = 6,
    XSLT_FUNC_PI = 7,
    XSLT_FUNC_COPYOF = 8,
    XSLT_FUNC_VALUEOF = 9,
    XSLT_FUNC_NUMBER = 10,
    XSLT_FUNC_APPLYIMPORTS = 11,
    XSLT_FUNC_CALLTEMPLATE = 12,
    XSLT_FUNC_APPLYTEMPLATES = 13,
    XSLT_FUNC_CHOOSE = 14,
    XSLT_FUNC_IF = 15,
    XSLT_FUNC_FOREACH = 16,
    XSLT_FUNC_DOCUMENT = 17,
    XSLT_FUNC_WITHPARAM = 18,
    XSLT_FUNC_PARAM = 19,
    XSLT_FUNC_VARIABLE = 20,
    XSLT_FUNC_WHEN = 21,
    XSLT_FUNC_EXTENSION = 22
};
#line 191 "/usr/include/libxslt/xsltInternals.h"
typedef enum __anonenum_xsltStyleType_1 xsltStyleType;
#line 230 "/usr/include/libxslt/xsltInternals.h"
struct _xsltElemPreComp {
   xsltElemPreCompPtr next ;
   xsltStyleType type ;
   void (*func)(xsltTransformContextPtr ctxt , xmlNodePtr node , xmlNodePtr inst ,
                xsltElemPreCompPtr comp ) ;
   xmlNodePtr inst ;
   void (*free)(xsltElemPreCompPtr comp ) ;
};
#line 246
struct _xsltStylePreComp;
#line 246 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltStylePreComp xsltStylePreComp;
#line 248 "/usr/include/libxslt/xsltInternals.h"
typedef xsltStylePreComp *xsltStylePreCompPtr;
#line 250 "/usr/include/libxslt/xsltInternals.h"
struct _xsltStylePreComp {
   xsltElemPreCompPtr next ;
   xsltStyleType type ;
   void (*func)(xsltTransformContextPtr ctxt , xmlNodePtr node , xmlNodePtr inst ,
                xsltElemPreCompPtr comp ) ;
   xmlNodePtr inst ;
   xmlChar const   *stype ;
   int has_stype ;
   int number ;
   xmlChar const   *order ;
   int has_order ;
   int descending ;
   xmlChar const   *lang ;
   int has_lang ;
   xmlChar const   *case_order ;
   int lower_first ;
   xmlChar const   *use ;
   int has_use ;
   int noescape ;
   xmlChar const   *name ;
   int has_name ;
   xmlChar const   *ns ;
   int has_ns ;
   xmlChar const   *mode ;
   xmlChar const   *modeURI ;
   xmlChar const   *test ;
   xsltTemplatePtr templ ;
   xmlChar const   *select ;
   int ver11 ;
   xmlChar const   *filename ;
   int has_filename ;
   xsltNumberData numdata ;
   xmlXPathCompExprPtr comp ;
   xmlNsPtr *nsList ;
   int nsNr ;
};
#line 306
struct _xsltStackElem;
#line 306 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltStackElem xsltStackElem;
#line 307 "/usr/include/libxslt/xsltInternals.h"
typedef xsltStackElem *xsltStackElemPtr;
#line 308 "/usr/include/libxslt/xsltInternals.h"
struct _xsltStackElem {
   struct _xsltStackElem *next ;
   xsltStylePreCompPtr comp ;
   int computed ;
   xmlChar const   *name ;
   xmlChar const   *nameURI ;
   xmlChar const   *select ;
   xmlNodePtr tree ;
   xmlXPathObjectPtr value ;
};
#line 324 "/usr/include/libxslt/xsltInternals.h"
typedef struct _xsltStylesheet xsltStylesheet;
#line 325 "/usr/include/libxslt/xsltInternals.h"
typedef xsltStylesheet *xsltStylesheetPtr;
#line 326 "/usr/include/libxslt/xsltInternals.h"
struct _xsltStylesheet {
   struct _xsltStylesheet *parent ;
   struct _xsltStylesheet *next ;
   struct _xsltStylesheet *imports ;
   xsltDocumentPtr docList ;
   xmlDocPtr doc ;
   xmlHashTablePtr stripSpaces ;
   int stripAll ;
   xmlHashTablePtr cdataSection ;
   xsltStackElemPtr variables ;
   xsltTemplatePtr templates ;
   void *templatesHash ;
   void *rootMatch ;
   void *keyMatch ;
   void *elemMatch ;
   void *attrMatch ;
   void *parentMatch ;
   void *textMatch ;
   void *piMatch ;
   void *commentMatch ;
   xmlHashTablePtr nsAliases ;
   xmlHashTablePtr attributeSets ;
   xmlHashTablePtr nsHash ;
   void *nsDefs ;
   void *keys ;
   xmlChar *method ;
   xmlChar *methodURI ;
   xmlChar *version ;
   xmlChar *encoding ;
   int omitXmlDeclaration ;
   xsltDecimalFormatPtr decimalFormat ;
   int standalone ;
   xmlChar *doctypePublic ;
   xmlChar *doctypeSystem ;
   int indent ;
   xmlChar *mediaType ;
   xsltElemPreCompPtr preComps ;
   int warnings ;
   int errors ;
   xmlChar *exclPrefix ;
   xmlChar **exclPrefixTab ;
   int exclPrefixNr ;
   int exclPrefixMax ;
   void *_private ;
   xmlHashTablePtr extInfos ;
   int extrasNr ;
   xsltDocumentPtr includes ;
   xmlDictPtr dict ;
   void *attVTs ;
   xmlChar const   *defaultAlias ;
   int nopreproc ;
   int internalized ;
   int literal_result ;
};
#line 459
enum __anonenum_xsltOutputType_1 {
    XSLT_OUTPUT_XML = 0,
    XSLT_OUTPUT_HTML = 1,
    XSLT_OUTPUT_TEXT = 2
};
#line 459 "/usr/include/libxslt/xsltInternals.h"
typedef enum __anonenum_xsltOutputType_1 xsltOutputType;
#line 465
enum __anonenum_xsltTransformState_1 {
    XSLT_STATE_OK = 0,
    XSLT_STATE_ERROR = 1,
    XSLT_STATE_STOPPED = 2
};
#line 465 "/usr/include/libxslt/xsltInternals.h"
typedef enum __anonenum_xsltTransformState_1 xsltTransformState;
#line 471 "/usr/include/libxslt/xsltInternals.h"
struct _xsltTransformContext {
   xsltStylesheetPtr style ;
   xsltOutputType type ;
   xsltTemplatePtr templ ;
   int templNr ;
   int templMax ;
   xsltTemplatePtr *templTab ;
   xsltStackElemPtr vars ;
   int varsNr ;
   int varsMax ;
   xsltStackElemPtr *varsTab ;
   int varsBase ;
   xmlHashTablePtr extFunctions ;
   xmlHashTablePtr extElements ;
   xmlHashTablePtr extInfos ;
   xmlChar const   *mode ;
   xmlChar const   *modeURI ;
   xsltDocumentPtr docList ;
   xsltDocumentPtr document ;
   xmlNodePtr node ;
   xmlNodeSetPtr nodeList ;
   xmlDocPtr output ;
   xmlNodePtr insert ;
   xmlXPathContextPtr xpathCtxt ;
   xsltTransformState state ;
   xmlHashTablePtr globalVars ;
   xmlNodePtr inst ;
   int xinclude ;
   char const   *outputFile ;
   int profile ;
   long prof ;
   int profNr ;
   int profMax ;
   long *profTab ;
   void *_private ;
   int extrasNr ;
   int extrasMax ;
   xsltRuntimeExtraPtr extras ;
   xsltDocumentPtr styleList ;
   void *sec ;
   void (*error)(void *ctx , char const   *msg  , ...) ;
   void *errctx ;
   void (*sortfunc)(xsltTransformContextPtr ctxt , xmlNodePtr *sorts , int nbsorts ) ;
   xmlDocPtr tmpRVT ;
   xmlDocPtr persistRVT ;
   int ctxtflags ;
   xmlChar const   *lasttext ;
   unsigned int lasttsize ;
   unsigned int lasttuse ;
   int debugStatus ;
   unsigned long *traceCode ;
   int parserOptions ;
   xmlDictPtr dict ;
   xmlDocPtr tmpDoc ;
   int internalized ;
};
#line 58 "xslt.c"
struct __anonstruct_stylesheet_cache_t_1 {
   char *filename ;
   time_t last_modified ;
   time_t cache_age ;
   xsltStylesheetPtr stylesheet ;
};
#line 58 "xslt.c"
typedef struct __anonstruct_stylesheet_cache_t_1 stylesheet_cache_t;
#line 194 "/usr/include/sys/types.h"
typedef long long int64_t;
#line 20 "fserve.h"
struct _fserve_t {
   client_t *client ;
   FILE *file ;
   int ready ;
   void (*callback)(client_t * , void * ) ;
   void *arg ;
   struct _fserve_t *next ;
};
#line 20 "fserve.h"
typedef struct _fserve_t fserve_t;
#line 86 "fserve.c"
struct __anonstruct_mime_type_1 {
   char *ext ;
   char *type ;
};
#line 86 "fserve.c"
typedef struct __anonstruct_mime_type_1 mime_type;
#line 35 "format.h"
typedef struct _format_plugin_tag format_plugin_t;
#line 20 "md5.h"
struct MD5Context {
   uint32_t buf[4] ;
   uint32_t bits[2] ;
   unsigned char in[64] ;
};
#line 9 "/usr/include/ogg/config_types.h"
typedef int64_t ogg_int64_t;
#line 37 "/usr/include/ogg/ogg.h"
struct __anonstruct_ogg_page_1 {
   unsigned char *header ;
   long header_len ;
   unsigned char *body ;
   long body_len ;
};
#line 37 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_ogg_page_1 ogg_page;
#line 47 "/usr/include/ogg/ogg.h"
struct __anonstruct_ogg_stream_state_1 {
   unsigned char *body_data ;
   long body_storage ;
   long body_fill ;
   long body_returned ;
   int *lacing_vals ;
   ogg_int64_t *granule_vals ;
   long lacing_storage ;
   long lacing_fill ;
   long lacing_packet ;
   long lacing_returned ;
   unsigned char header[282] ;
   int header_fill ;
   int e_o_s ;
   int b_o_s ;
   long serialno ;
   long pageno ;
   ogg_int64_t packetno ;
   ogg_int64_t granulepos ;
};
#line 47 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_ogg_stream_state_1 ogg_stream_state;
#line 99 "/usr/include/ogg/ogg.h"
struct __anonstruct_ogg_sync_state_1 {
   unsigned char *data ;
   int storage ;
   int fill ;
   int returned ;
   int unsynced ;
   int headerbytes ;
   int bodybytes ;
};
#line 99 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_ogg_sync_state_1 ogg_sync_state;
#line 25 "format_ogg.h"
struct ogg_codec_tag;
#line 25 "format_ogg.h"
struct ogg_state_tag {
   char *mount ;
   ogg_sync_state oy ;
   int error ;
   int codec_count ;
   struct ogg_codec_tag *codecs ;
   char *artist ;
   char *title ;
   int log_metadata ;
   refbuf_t *file_headers ;
   refbuf_t *header_pages ;
   refbuf_t *header_pages_tail ;
   refbuf_t **bos_end ;
   int bos_completed ;
   long bitrate ;
   struct ogg_codec_tag *current ;
   struct ogg_codec_tag *codec_sync ;
};
#line 25 "format_ogg.h"
typedef struct ogg_state_tag ogg_state_t;
#line 48 "format_ogg.h"
struct ogg_codec_tag {
   struct ogg_codec_tag *next ;
   ogg_stream_state os ;
   unsigned int headers ;
   char const   *name ;
   void *specific ;
   refbuf_t *possible_start ;
   refbuf_t *page ;
   refbuf_t *(*process)(ogg_state_t *ogg_info , struct ogg_codec_tag *codec ) ;
   refbuf_t *(*process_page)(ogg_state_t *ogg_info , struct ogg_codec_tag *codec ,
                             ogg_page *page ) ;
   void (*codec_free)(ogg_state_t *ogg_info , struct ogg_codec_tag *codec ) ;
};
#line 48 "format_ogg.h"
typedef struct ogg_codec_tag ogg_codec_t;
#line 64 "format_ogg.c"
struct ogg_client {
   refbuf_t *headers ;
   refbuf_t *header_page ;
   unsigned int pos ;
   int headers_sent ;
};
#line 21 "format_mp3.h"
struct __anonstruct_mp3_state_1 {
   int inline_metadata_interval ;
   int offset ;
   int interval ;
   char *url_artist ;
   char *url_title ;
   int update_metadata ;
   refbuf_t *metadata ;
   refbuf_t *read_data ;
   unsigned int read_count ;
   mutex_t url_lock ;
   unsigned int build_metadata_len ;
   unsigned int build_metadata_offset ;
   char build_metadata[4081] ;
};
#line 21 "format_mp3.h"
typedef struct __anonstruct_mp3_state_1 mp3_state;
#line 68 "format_mp3.c"
struct __anonstruct_mp3_client_data_1 {
   unsigned int interval ;
   int metadata_offset ;
   unsigned int since_meta_block ;
   int in_metadata ;
   refbuf_t *associated ;
};
#line 68 "format_mp3.c"
typedef struct __anonstruct_mp3_client_data_1 mp3_client_data;
#line 84 "/usr/include/ogg/ogg.h"
struct __anonstruct_ogg_packet_1 {
   unsigned char *packet ;
   long bytes ;
   long b_o_s ;
   long e_o_s ;
   ogg_int64_t granulepos ;
   ogg_int64_t packetno ;
};
#line 84 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_ogg_packet_1 ogg_packet;
#line 47 "auth_htpasswd.c"
struct __anonstruct_htpasswd_user_1 {
   char *name ;
   char *pass ;
};
#line 47 "auth_htpasswd.c"
typedef struct __anonstruct_htpasswd_user_1 htpasswd_user;
#line 53 "auth_htpasswd.c"
struct __anonstruct_htpasswd_auth_state_1 {
   char *filename ;
   rwlock_t file_rwlock ;
   avl_tree *users ;
   time_t mtime ;
};
#line 53 "auth_htpasswd.c"
typedef struct __anonstruct_htpasswd_auth_state_1 htpasswd_auth_state;
#line 28 "/usr/include/vorbis/codec.h"
struct vorbis_info {
   int version ;
   int channels ;
   long rate ;
   long bitrate_upper ;
   long bitrate_nominal ;
   long bitrate_lower ;
   long bitrate_window ;
   void *codec_setup ;
};
#line 28 "/usr/include/vorbis/codec.h"
typedef struct vorbis_info vorbis_info;
#line 140 "/usr/include/vorbis/codec.h"
struct vorbis_comment {
   char **user_comments ;
   int *comment_lengths ;
   int comments ;
   char *vendor ;
};
#line 140 "/usr/include/vorbis/codec.h"
typedef struct vorbis_comment vorbis_comment;
#line 38 "format_vorbis.c"
struct vorbis_codec_tag {
   vorbis_info vi ;
   vorbis_comment vc ;
   int rebuild_comment ;
   int stream_notify ;
   int initial_audio_page ;
   ogg_stream_state new_os ;
   int page_samples_trigger ;
   ogg_int64_t prev_granulepos ;
   ogg_packet *prev_packet ;
   ogg_int64_t granulepos ;
   ogg_int64_t initial_page_granulepos ;
   ogg_int64_t samples_in_page ;
   int prev_window ;
   int initial_audio_packet ;
   ogg_page bos_page ;
   ogg_packet *header[3] ;
   ogg_int64_t prev_page_samples ;
   int (*process_packet)(ogg_state_t *ogg_info , ogg_codec_t *codec ) ;
   refbuf_t *(*get_buffer_page)(ogg_state_t *ogg_info , ogg_codec_t *codec ) ;
};
#line 38 "format_vorbis.c"
typedef struct vorbis_codec_tag vorbis_codec_t;
#line 44 "/usr/include/curl/curl.h"
typedef void CURL;
#line 238
enum __anonenum_CURLcode_1 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_URL_MALFORMAT_USER = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_FTP_WEIRD_SERVER_REPLY = 8,
    CURLE_FTP_ACCESS_DENIED = 9,
    CURLE_FTP_USER_PASSWORD_INCORRECT = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_WEIRD_USER_REPLY = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_FTP_CANT_RECONNECT = 16,
    CURLE_FTP_COULDNT_SET_BINARY = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_FTP_WRITE_ERROR = 20,
    CURLE_FTP_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_MALFORMAT_USER = 24,
    CURLE_FTP_COULDNT_STOR_FILE = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEOUTED = 28,
    CURLE_FTP_COULDNT_SET_ASCII = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_FTP_COULDNT_GET_SIZE = 32,
    CURLE_HTTP_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_LIBRARY_NOT_FOUND = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_BAD_CALLING_ORDER = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_BAD_PASSWORD_ENTERED = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_TELNET_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE = 50,
    CURLE_SSL_PEER_CERTIFICATE = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_SHARE_IN_USE = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_SSL_CACERT = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_FTP_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURL_LAST = 68
};
#line 238 "/usr/include/curl/curl.h"
typedef enum __anonenum_CURLcode_1 CURLcode;
#line 421
enum __anonenum_CURLoption_1 {
    CURLOPT_FILE = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_INFILE = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_SSLCERTPASSWD = 10026,
    CURLOPT_SSLKEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_WRITEHEADER = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_WRITEINFO = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_FTPLISTONLY = 48,
    CURLOPT_FTPAPPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRB4LEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_CLOSEPOLICY = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_FTP_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_SOURCE_USERPWD = 10123,
    CURLOPT_SOURCE_PREQUOTE = 10127,
    CURLOPT_SOURCE_POSTQUOTE = 10128,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_SOURCE_URL = 10132,
    CURLOPT_SOURCE_QUOTE = 10133,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_LASTENTRY = 10135
};
#line 421 "/usr/include/curl/curl.h"
typedef enum __anonenum_CURLoption_1 CURLoption;
#line 78 "auth_url.c"
struct __anonstruct_auth_url_1 {
   char *addurl ;
   char *removeurl ;
   char *stream_start ;
   char *stream_end ;
   char *username ;
   char *password ;
   char *auth_header ;
   int auth_header_len ;
   char *timelimit_header ;
   int timelimit_header_len ;
   char *userpwd ;
   CURL *handle ;
   char errormsg[256] ;
};
#line 78 "auth_url.c"
typedef struct __anonstruct_auth_url_1 auth_url;
#line 40 "yp.c"
struct ypdata_tag;
#line 40 "yp.c"
struct yp_server {
   char *url ;
   unsigned int url_timeout ;
   unsigned int touch_interval ;
   int remove ;
   CURL *curl ;
   struct ypdata_tag *mounts ;
   struct ypdata_tag *pending_mounts ;
   struct yp_server *next ;
   char curl_error[256] ;
};
#line 55 "yp.c"
struct ypdata_tag {
   int remove ;
   int release ;
   int cmd_ok ;
   char *sid ;
   char *mount ;
   char *url ;
   char *listen_url ;
   char *server_name ;
   char *server_desc ;
   char *server_genre ;
   char *cluster_password ;
   char *bitrate ;
   char *audio_info ;
   char *server_type ;
   char *current_song ;
   char *subtype ;
   struct yp_server *server ;
   time_t next_update ;
   unsigned int touch_interval ;
   char *error_msg ;
   unsigned int (*process)(struct ypdata_tag *yp , char *s , unsigned int len ) ;
   struct ypdata_tag *next ;
};
#line 55 "yp.c"
typedef struct ypdata_tag ypdata_t;
#line 1 "cil-xNMwF0LA.o"
#pragma merger(0,"/tmp/cil-r2LDDhZP.i","")
#line 1 "./src/net/libicenet_la-sock.lo_saved.c"
#pragma merger(0,"./sock.i","-pthread -g -O2")
#line 353 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 357
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 587 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 601
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 63 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 306 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 797
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 50 "/usr/include/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 136
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 143
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 59 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
#line 65
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 631 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 101 "sock.h"
void sock_initialize(void) ;
#line 102
void sock_shutdown(void) ;
#line 103
char *sock_get_localip(char *buff , int len ) ;
#line 104
int sock_error(void) ;
#line 105
int sock_recoverable(int error ) ;
#line 106
int sock_stalled(int error ) ;
#line 107
int sock_valid_socket(sock_t sock ) ;
#line 108
int sock_set_blocking(sock_t sock , int block ) ;
#line 109
int sock_set_nolinger(sock_t sock ) ;
#line 110
int sock_set_keepalive(sock_t sock ) ;
#line 111
int sock_set_nodelay(sock_t sock ) ;
#line 112
int sock_close(sock_t sock ) ;
#line 115
sock_t sock_connect_wto(char const   *hostname , int port , int timeout ) ;
#line 116
int sock_connect_non_blocking(char const   *hostname , unsigned int port ) ;
#line 117
int sock_connected(int sock , int timeout ) ;
#line 120
int sock_write_bytes(sock_t sock , void const   *buff , size_t len ) ;
#line 121
int sock_write(sock_t sock , char const   *fmt  , ...) ;
#line 122
int sock_write_fmt(sock_t sock , char const   *fmt , va_list ap ) ;
#line 123
int sock_write_string(sock_t sock , char const   *buff ) ;
#line 124
ssize_t sock_writev(int sock , struct iovec  const  *iov , size_t count ) ;
#line 128
int sock_read_bytes(sock_t sock , char *buff , int len ) ;
#line 129
int sock_read_line(sock_t sock , char *buff , int len ) ;
#line 132
sock_t sock_get_server_socket(int port , char *sinterface ) ;
#line 133
int sock_listen(sock_t serversock , int backlog ) ;
#line 134
int sock_accept(sock_t serversock , char *ip , int len ) ;
#line 30 "resolver.h"
void resolver_initialize(void) ;
#line 31
void resolver_shutdown(void) ;
#line 34
char *resolver_getip(char const   *name , char *buff , int len ) ;
#line 66 "sock.c"
void sock_initialize(void) 
{ 

  {
#line 73
  resolver_initialize();
#line 74
  return;
}
}
#line 81 "sock.c"
void sock_shutdown(void) 
{ 

  {
#line 87
  resolver_shutdown();
#line 88
  return;
}
}
#line 97 "sock.c"
char *sock_get_localip(char *buff , int len ) 
{ char temp[1024] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 101
  tmp = gethostname(temp, sizeof(temp));
#line 101
  if (tmp != 0) {
#line 102
    return ((char *)((void *)0));
  }
#line 104
  tmp___0 = resolver_getip((char const   *)(temp), buff, len);
#line 104
  if (tmp___0) {
#line 105
    return (buff);
  }
#line 107
  return ((char *)((void *)0));
}
}
#line 114 "sock.c"
int sock_error(void) 
{ int *tmp ;

  {
#line 119
  tmp = __errno_location();
#line 119
  return ((*tmp));
}
}
#line 123 "sock.c"
static void sock_set_error(int val ) 
{ int *tmp ;

  {
#line 128
  tmp = __errno_location();
#line 128
  (*tmp) = val;
#line 130
  return;
}
}
#line 137 "sock.c"
int sock_recoverable(int error ) 
{ 

  {
#line 139
  switch (error) {
  case 0: ;
  case 11: ;
  case 4: ;
  case 115: ;
  case 85: ;
#line 151
  return (1);
  default: ;
#line 153
  return (0);
  }
}
}
#line 157 "sock.c"
int sock_stalled(int error ) 
{ 

  {
#line 159
  switch (error) {
  case 11: ;
  case 115: ;
  case 114: ;
  case 85: ;
#line 170
  return (1);
  default: ;
#line 172
  return (0);
  }
}
}
#line 177 "sock.c"
static int sock_connect_pending(int error ) 
{ int tmp ;

  {
#line 179
  if (error == 115) {
#line 179
    tmp = 1;
  } else {
#line 179
    if (error == 114) {
#line 179
      tmp = 1;
    } else {
#line 179
      tmp = 0;
    }
  }
#line 179
  return (tmp);
}
}
#line 186 "sock.c"
int sock_valid_socket(sock_t sock ) 
{ int ret ;
  int optval ;
  socklen_t optlen ;

  {
#line 192
  optlen = sizeof(int );
#line 194
  ret = getsockopt(sock, 1, 3, (void * __restrict  )((void *)(& optval)), (socklen_t * __restrict  )(& optlen));
#line 196
  return (ret == 0);
}
}
#line 224 "sock.c"
int sock_set_blocking(sock_t sock , int block ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 234
  tmp = sock_valid_socket(sock);
#line 234
  if (tmp) {
#line 234
    if (block < 0) {
#line 235
      return (-1);
    } else {
#line 234
      if (block > 1) {
#line 235
        return (-1);
      }
    }
  } else {
#line 235
    return (-1);
  }
#line 240
  if (block == 0) {
#line 240
    tmp___0 = 0;
  } else {
#line 240
    tmp___0 = 2048;
  }
#line 240
  tmp___1 = fcntl(sock, 4, tmp___0);
#line 240
  return (tmp___1);
}
}
#line 244 "sock.c"
int sock_set_nolinger(sock_t sock ) 
{ struct linger lin ;
  int tmp ;

  {
#line 246
  lin.l_onoff = 0;
#line 246
  lin.l_linger = 0;
#line 247
  tmp = setsockopt(sock, 1, 13, (void const   *)((void *)(& lin)), sizeof(struct linger ));
#line 247
  return (tmp);
}
}
#line 251 "sock.c"
int sock_set_nodelay(sock_t sock ) 
{ int nodelay ;
  int tmp ;

  {
#line 253
  nodelay = 1;
#line 255
  tmp = setsockopt(sock, 6, 1, (void const   *)((void *)(& nodelay)), sizeof(int ));
#line 255
  return (tmp);
}
}
#line 259 "sock.c"
int sock_set_keepalive(sock_t sock ) 
{ int keepalive ;
  int tmp ;

  {
#line 261
  keepalive = 1;
#line 262
  tmp = setsockopt(sock, 1, 9, (void const   *)((void *)(& keepalive)), sizeof(int ));
#line 262
  return (tmp);
}
}
#line 270 "sock.c"
int sock_close(sock_t sock ) 
{ int tmp ;

  {
#line 275
  tmp = close(sock);
#line 275
  return (tmp);
}
}
#line 285 "sock.c"
ssize_t sock_writev(int sock , struct iovec  const  *iov , size_t count ) 
{ ssize_t tmp ;

  {
#line 287
  tmp = writev(sock, iov, (int )count);
#line 287
  return (tmp);
}
}
#line 323 "sock.c"
int sock_write_bytes(sock_t sock , void const   *buff , size_t len ) 
{ int tmp ;

  {
#line 326
  if (! buff) {
#line 327
    return (-1);
  } else {
#line 328
    if (len <= 0U) {
#line 329
      return (-1);
    }
  }
#line 334
  tmp = send(sock, buff, len, 0);
#line 334
  return (tmp);
}
}
#line 342 "sock.c"
int sock_write_string(sock_t sock , char const   *buff ) 
{ size_t tmp ;
  int tmp___0 ;

  {
#line 344
  tmp = strlen(buff);
#line 344
  tmp___0 = sock_write_bytes(sock, (void const   *)buff, tmp);
#line 344
  return (tmp___0 > 0);
}
}
#line 353 "sock.c"
int sock_write(sock_t sock , char const   *fmt  , ...) 
{ int rc ;
  va_list ap ;

  {
#line 358
  __builtin_va_start(ap, fmt);
#line 359
  rc = sock_write_fmt(sock, fmt, ap);
#line 360
  __builtin_va_end(ap);
#line 362
  return (rc);
}
}
#line 394 "sock.c"
int sock_write_fmt(sock_t sock , char const   *fmt , va_list ap ) 
{ char buffer[1024] ;
  char *buff ;
  int len ;
  int rc ;
  va_list ap_retry ;

  {
#line 396
  buff = buffer;
#line 398
  rc = -1;
#line 401
  __builtin_va_copy(ap_retry, ap);
#line 403
  len = vsnprintf((char * __restrict  )buff, sizeof(buffer), (char const   * __restrict  )fmt,
                  ap);
#line 405
  if (len > 0) {
#line 407
    if ((unsigned int )len < sizeof(buffer)) {
#line 408
      rc = sock_write_bytes(sock, (void const   *)buff, (unsigned int )len);
    } else {
#line 412
      len ++;
#line 412
      buff = (char *)malloc((unsigned int )len);
#line 413
      if (buff) {
#line 415
        len = vsnprintf((char * __restrict  )buff, (unsigned int )len, (char const   * __restrict  )fmt,
                        ap_retry);
#line 416
        if (len > 0) {
#line 417
          rc = sock_write_bytes(sock, (void const   *)buff, (unsigned int )len);
        }
#line 418
        free((void *)buff);
      }
    }
  }
#line 422
  __builtin_va_end(ap_retry);
#line 424
  return (rc);
}
}
#line 429 "sock.c"
int sock_read_bytes(sock_t sock , char *buff , int len ) 
{ int tmp ;

  {
#line 433
  if (! buff) {
#line 433
    return (0);
  }
#line 434
  if (len <= 0) {
#line 434
    return (0);
  }
#line 436
  tmp = recv(sock, (void *)buff, (unsigned int )len, 0);
#line 436
  return (tmp);
}
}
#line 447 "sock.c"
int sock_read_line(sock_t sock , char *buff , int len ) 
{ char c ;
  int read_bytes ;
  int pos ;
  int tmp ;

  {
#line 449
  c = (char )'\000';
#line 454
  if (! buff) {
#line 455
    return (0);
  } else {
#line 456
    if (len <= 0) {
#line 457
      return (0);
    }
  }
#line 460
  pos = 0;
#line 461
  read_bytes = recv(sock, (void *)(& c), 1U, 0);
#line 463
  if (read_bytes < 0) {
#line 464
    return (0);
  }
#line 467
  while (1) {
#line 467
    if ((int )c != 10) {
#line 467
      if (pos < len) {
#line 467
        if (! (read_bytes == 1)) {
#line 467
          break;
        }
      } else {
#line 467
        break;
      }
    } else {
#line 467
      break;
    }
#line 468
    if ((int )c != 13) {
#line 469
      tmp = pos;
#line 469
      pos ++;
#line 469
      (*(buff + tmp)) = c;
    }
#line 470
    read_bytes = recv(sock, (void *)(& c), 1U, 0);
  }
#line 473
  if (read_bytes == 1) {
#line 474
    (*(buff + pos)) = (char )'\000';
#line 475
    return (1);
  } else {
#line 477
    return (0);
  }
}
}
#line 488 "sock.c"
int sock_connected(int sock , int timeout ) 
{ fd_set wfds ;
  int val ;
  socklen_t size ;
  struct timeval tv ;
  struct timeval *timeval ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 491
  val = -1;
#line 492
  size = sizeof(val);
#line 493
  timeval = (struct timeval *)((void *)0);
#line 496
  if (timeout >= 0) {
#line 498
    tv.tv_sec = (long )timeout;
#line 499
    tv.tv_usec = 0L;
#line 500
    timeval = & tv;
  }
#line 503
  while (1) {
#line 503
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) /
                                                                                    sizeof(__fd_mask )),
                         "1" (& wfds.fds_bits[0]): "memory");
#line 503
    break;
  }
#line 504
  __asm__  volatile   ("btsl %1,%0": "=m" (wfds.fds_bits[(unsigned int )sock / (8U *
                                                                                sizeof(__fd_mask ))]): "r" ((unsigned int )sock %
                                                                                                            (8U *
                                                                                                             sizeof(__fd_mask ))): "cc",
                       "memory");
#line 506
  tmp = select(sock + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& wfds),
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )timeval);
#line 506
  switch (tmp) {
  case 0: ;
#line 509
  return (-2);
  default: 
#line 512
  tmp___0 = getsockopt(sock, 1, 4, (void * __restrict  )((void *)(& val)), (socklen_t * __restrict  )(& size));
#line 512
  if (tmp___0 == 0) {
#line 514
    if (val == 0) {
#line 515
      return (1);
    }
#line 516
    sock_set_error(val);
  }
  case -1: 
#line 520
  tmp___1 = sock_error();
#line 520
  tmp___2 = sock_recoverable(tmp___1);
#line 520
  if (tmp___2) {
#line 521
    return (0);
  }
#line 522
  return (-1);
  }
}
}
#line 528 "sock.c"
int sock_connect_non_blocking(char const   *hostname , unsigned int port ) 
{ int sock ;
  struct addrinfo *ai ;
  struct addrinfo *head ;
  struct addrinfo hints ;
  char service[8] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 530
  sock = -1;
#line 534
  memset((void *)(& hints), 0, sizeof(hints));
#line 535
  hints.ai_family = 0;
#line 536
  hints.ai_socktype = 1;
#line 538
  snprintf((char * __restrict  )(service), sizeof(service), (char const   * __restrict  )"%u",
           port);
#line 540
  tmp = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )(service),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& head));
#line 540
  if (tmp) {
#line 541
    return (-1);
  }
#line 543
  ai = head;
#line 544
  while (ai) {
#line 546
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 546
    if (sock > -1) {
#line 549
      sock_set_blocking(sock, 1);
#line 550
      tmp___0 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                        ai->ai_addrlen);
#line 550
      if (tmp___0 < 0) {
#line 550
        tmp___1 = sock_error();
#line 550
        tmp___2 = sock_connect_pending(tmp___1);
#line 550
        if (tmp___2) {
#line 557
          break;
        } else {
#line 553
          sock_close(sock);
#line 554
          sock = -1;
        }
      } else {
#line 557
        break;
      }
    }
#line 559
    ai = ai->ai_next;
  }
#line 561
  if (head) {
#line 561
    freeaddrinfo(head);
  }
#line 563
  return (sock);
}
}
#line 570 "sock.c"
sock_t sock_connect_wto(char const   *hostname , int port , int timeout ) 
{ int sock ;
  struct addrinfo *ai ;
  struct addrinfo *head ;
  struct addrinfo hints ;
  char service[8] ;
  int tmp ;
  int tmp___0 ;
  int connected ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 572
  sock = -1;
#line 576
  memset((void *)(& hints), 0, sizeof(hints));
#line 577
  hints.ai_family = 0;
#line 578
  hints.ai_socktype = 1;
#line 579
  snprintf((char * __restrict  )(service), sizeof(service), (char const   * __restrict  )"%u",
           port);
#line 581
  tmp = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )(service),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& head));
#line 581
  if (tmp) {
#line 582
    return (-1);
  }
#line 584
  ai = head;
#line 585
  while (ai) {
#line 587
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 587
    if (sock >= 0) {
#line 589
      if (timeout > 0) {
#line 590
        sock_set_blocking(sock, 1);
      }
#line 592
      tmp___0 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                        ai->ai_addrlen);
#line 592
      if (tmp___0 == 0) {
#line 593
        break;
      }
#line 596
      while (sock != -1) {
#line 598
        tmp___2 = sock_error();
#line 598
        tmp___3 = sock_recoverable(tmp___2);
#line 598
        if (tmp___3) {
#line 600
          tmp___1 = sock_connected(sock, timeout);
#line 600
          connected = tmp___1;
#line 601
          if (connected == 0) {
#line 602
            continue;
          }
#line 603
          if (connected == 1) {
#line 605
            if (timeout >= 0) {
#line 606
              sock_set_blocking(sock, 0);
            }
#line 607
            break;
          }
        }
#line 610
        sock_close(sock);
#line 611
        sock = -1;
      }
#line 613
      if (sock != -1) {
#line 614
        break;
      }
    }
#line 616
    ai = ai->ai_next;
  }
#line 618
  if (head) {
#line 619
    freeaddrinfo(head);
  }
#line 621
  return (sock);
}
}
#line 712 "sock.c"
sock_t sock_get_server_socket(int port , char *sinterface ) 
{ struct sockaddr_storage sa ;
  int family ;
  int len ;
  int error ;
  int opt ;
  sock_t sock ;
  char ip[46] ;
  char *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp___0 ;
  int tmp___1 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;

  {
#line 723
  if (port < 0) {
#line 724
    return (-1);
  }
#line 727
  memset((void *)(& sa), 0, sizeof(sa));
#line 728
  family = 2;
#line 729
  len = (int )sizeof(struct sockaddr_in );
#line 732
  if ((unsigned int )sinterface != (unsigned int )((void *)0)) {
#line 733
    tmp = resolver_getip((char const   *)sinterface, ip, (int )sizeof(ip));
#line 733
    if (! tmp) {
#line 734
      return (-1);
    }
#line 737
    tmp___1 = inet_pton(2, (char const   * __restrict  )(ip), (void * __restrict  )(& ((struct sockaddr_in *)(& sa))->sin_addr));
#line 737
    if (tmp___1 > 0) {
#line 738
      ((struct sockaddr_in *)(& sa))->sin_family = (unsigned short)2;
#line 739
      __x = (unsigned short )port;
#line 739
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 739
      ((struct sockaddr_in *)(& sa))->sin_port = __v;
    } else {
#line 740
      tmp___0 = inet_pton(10, (char const   * __restrict  )(ip), (void * __restrict  )(& ((struct sockaddr_in6 *)(& sa))->sin6_addr));
#line 740
      if (tmp___0 > 0) {
#line 742
        family = 10;
#line 743
        len = (int )sizeof(struct sockaddr_in6 );
#line 744
        ((struct sockaddr_in6 *)(& sa))->sin6_family = (unsigned short)10;
#line 745
        __x___0 = (unsigned short )port;
#line 745
        __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 745
        ((struct sockaddr_in6 *)(& sa))->sin6_port = __v___0;
      } else {
#line 747
        return (-1);
      }
    }
  } else {
#line 758
    ((struct sockaddr_in *)(& sa))->sin_addr.s_addr = 0U;
#line 759
    ((struct sockaddr_in *)(& sa))->sin_family = (unsigned short)2;
#line 760
    __x___1 = (unsigned short )port;
#line 760
    __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 760
    ((struct sockaddr_in *)(& sa))->sin_port = __v___1;
  }
#line 764
  sock = socket(family, 1, 0);
#line 765
  if (sock == -1) {
#line 766
    return (-1);
  }
#line 769
  opt = 1;
#line 770
  setsockopt(sock, 1, 2, (void const   *)(& opt), sizeof(int ));
#line 773
  error = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sa)),
               (unsigned int )len);
#line 774
  if (error == -1) {
#line 775
    return (-1);
  }
#line 777
  return (sock);
}
}
#line 780 "sock.c"
int sock_listen(sock_t serversock , int backlog ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 782
  tmp = sock_valid_socket(serversock);
#line 782
  if (! tmp) {
#line 783
    return (0);
  }
#line 785
  if (backlog <= 0) {
#line 786
    backlog = 10;
  }
#line 788
  tmp___0 = listen(serversock, backlog);
#line 788
  return (tmp___0 == 0);
}
}
#line 791 "sock.c"
int sock_accept(sock_t serversock , char *ip , int len ) 
{ struct sockaddr_storage sa ;
  int ret ;
  socklen_t slen ;
  int tmp ;

  {
#line 801
  tmp = sock_valid_socket(serversock);
#line 801
  if (! tmp) {
#line 802
    return (-1);
  }
#line 804
  slen = sizeof(sa);
#line 805
  ret = accept(serversock, (struct sockaddr * __restrict  )((struct sockaddr *)(& sa)),
               (socklen_t * __restrict  )(& slen));
#line 807
  if (ret >= 0) {
#line 807
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 809
      if ((int )((struct sockaddr_in *)(& sa))->sin_family == 2) {
#line 810
        inet_ntop(2, (void const   * __restrict  )(& ((struct sockaddr_in *)(& sa))->sin_addr),
                  (char * __restrict  )ip, (unsigned int )len);
      } else {
#line 812
        if ((int )((struct sockaddr_in6 *)(& sa))->sin6_family == 10) {
#line 813
          inet_ntop(10, (void const   * __restrict  )(& ((struct sockaddr_in6 *)(& sa))->sin6_addr),
                    (char * __restrict  )ip, (unsigned int )len);
        } else {
#line 816
          __builtin_strncpy(ip, "ERROR", (unsigned int )(len - 1));
#line 817
          (*(ip + (len - 1))) = (char)0;
        }
      }
#line 823
      sock_set_nolinger(ret);
#line 824
      sock_set_keepalive(ret);
    }
  }
#line 827
  return (ret);
}
}
#line 1 "cil-RGppLkl5.o"
#pragma merger(0,"/tmp/cil-rwZofAEC.i","")
#line 1 "./src/net/libicenet_la-resolver.lo_saved.c"
#pragma merger(0,"./resolver.i","-pthread -g -O2")
#line 111 "/usr/include/netdb.h"
extern void sethostent(int __stay_open ) ;
#line 117
extern void endhostent(void) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 150 "./../thread/thread.h"
void thread_mutex_create_c(mutex_t *mutex , int line , char *file ) ;
#line 153
void thread_mutex_destroy(mutex_t *mutex ) ;
#line 33 "resolver.h"
char *resolver_getname(char const   *ip , char *buff , int len ) ;
#line 52 "resolver.c"
static int _isip(char const   *what ) ;
#line 57 "resolver.c"
static mutex_t _resolver_mutex  ;
#line 59 "resolver.c"
static int _initialized  =    0;
#line 62 "resolver.c"
static int _isip(char const   *what ) 
{ union __anonunion_addr_u_1 addr_u ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 69
  tmp___2 = inet_pton(2, (char const   * __restrict  )what, (void * __restrict  )(& addr_u.v4addr));
#line 69
  if (tmp___2 <= 0) {
#line 70
    tmp___1 = inet_pton(10, (char const   * __restrict  )what, (void * __restrict  )(& addr_u.v6addr));
#line 70
    if (tmp___1 > 0) {
#line 70
      tmp___0 = 1;
    } else {
#line 70
      tmp___0 = 0;
    }
#line 70
    return (tmp___0);
  }
#line 72
  return (1);
}
}
#line 86 "resolver.c"
char *resolver_getname(char const   *ip , char *buff , int len ) 
{ struct addrinfo *head ;
  struct addrinfo hints ;
  char *ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 88
  head = (struct addrinfo *)((void *)0);
#line 89
  ret = (char *)((void *)0);
#line 91
  tmp = _isip(ip);
#line 91
  if (! tmp) {
#line 92
    __builtin_strncpy(buff, ip, (unsigned int )len);
#line 93
    (*(buff + (len - 1))) = (char )'\000';
#line 94
    return (buff);
  }
#line 97
  memset((void *)(& hints), 0, sizeof(hints));
#line 98
  hints.ai_family = 0;
#line 99
  hints.ai_socktype = 1;
#line 100
  hints.ai_flags = 2;
#line 101
  tmp___0 = getaddrinfo((char const   * __restrict  )ip, (char const   * __restrict  )((void *)0),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& head));
#line 101
  if (tmp___0) {
#line 102
    return ((char *)((void *)0));
  }
#line 104
  if (head) {
#line 106
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )head->ai_addr, head->ai_addrlen,
                          (char * __restrict  )buff, (unsigned int )len, (char * __restrict  )((void *)0),
                          0U, 8U);
#line 106
    if (tmp___1 == 0) {
#line 108
      ret = buff;
    }
#line 110
    freeaddrinfo(head);
  }
#line 113
  return (ret);
}
}
#line 117 "resolver.c"
char *resolver_getip(char const   *name , char *buff , int len ) 
{ struct addrinfo *head ;
  struct addrinfo hints ;
  char *ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 120
  ret = (char *)((void *)0);
#line 122
  tmp = _isip(name);
#line 122
  if (tmp) {
#line 123
    __builtin_strncpy(buff, name, (unsigned int )len);
#line 124
    (*(buff + (len - 1))) = (char )'\000';
#line 125
    return (buff);
  }
#line 128
  memset((void *)(& hints), 0, sizeof(hints));
#line 129
  hints.ai_family = 0;
#line 130
  hints.ai_socktype = 1;
#line 131
  tmp___0 = getaddrinfo((char const   * __restrict  )name, (char const   * __restrict  )((void *)0),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& head));
#line 131
  if (tmp___0) {
#line 132
    return ((char *)((void *)0));
  }
#line 134
  if (head) {
#line 136
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )head->ai_addr, head->ai_addrlen,
                          (char * __restrict  )buff, (unsigned int )len, (char * __restrict  )((void *)0),
                          0U, 1U);
#line 136
    if (tmp___1 == 0) {
#line 138
      ret = buff;
    }
#line 139
    freeaddrinfo(head);
  }
#line 142
  return (ret);
}
}
#line 199 "resolver.c"
void resolver_initialize(void) 
{ 

  {
#line 203
  if (! _initialized) {
#line 205
    _initialized = 1;
#line 206
    thread_mutex_create_c(& _resolver_mutex, 206, (char *)"resolver.c");
#line 210
    sethostent(1);
  }
#line 213
  return;
}
}
#line 215 "resolver.c"
void resolver_shutdown(void) 
{ 

  {
#line 217
  if (_initialized) {
#line 219
    thread_mutex_destroy(& _resolver_mutex);
#line 220
    _initialized = 0;
#line 222
    endhostent();
  }
#line 225
  return;
}
}
#line 1 "cil-PteaapPX.o"
#pragma merger(0,"/tmp/cil-TCRxIbPO.i","")
#line 1 "./src/httpp/libicehttpp_la-httpp.lo_saved.c"
#pragma merger(0,"./httpp.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 290 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 399
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 399 "/usr/include/stdlib.h"
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
#line 402
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
#line 402
  return (tmp);
}
}
#line 589
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 325
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower__extinline(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = (*((*tmp___1) + __c));
    } else {
#line 193
      tmp___0 = __c;
    }
  } else {
#line 193
    tmp___0 = __c;
  }
#line 193
  return (tmp___0);
}
}
#line 104 "./../avl/avl.h"
avl_tree *avl_tree_new(int (*compare_fun)(void *compare_arg , void *a , void *b ) ,
                       void *compare_arg ) ;
#line 107
void avl_tree_free(avl_tree *tree , int (*free_key_fun)(void *key ) ) ;
#line 112
int avl_insert(avl_tree *ob , void *key ) ;
#line 117
int avl_delete(avl_tree *tree , void *key , int (*free_key_fun)(void *key ) ) ;
#line 129
int avl_get_by_key(avl_tree *tree , void *key , void **value_address ) ;
#line 59 "httpp.h"
http_parser_t *httpp_create_parser(void) ;
#line 60
void httpp_initialize(http_parser_t *parser , http_varlist_t *defaults ) ;
#line 61
int httpp_parse(http_parser_t *parser , char *http_data , unsigned long len ) ;
#line 63
int httpp_parse_response(http_parser_t *parser , char *http_data , unsigned long len ,
                         char *uri ) ;
#line 64
void httpp_setvar(http_parser_t *parser , char const   *name , char const   *value ) ;
#line 65
char *httpp_getvar(http_parser_t *parser , char const   *name ) ;
#line 66
void httpp_set_query_param(http_parser_t *parser , char *name , char *value ) ;
#line 67
char *httpp_get_query_param(http_parser_t *parser , char *name ) ;
#line 68
void httpp_destroy(http_parser_t *parser ) ;
#line 69
void httpp_clear(http_parser_t *parser ) ;
#line 34 "httpp.c"
static char *_lowercase(char *str ) ;
#line 37
static int _compare_vars(void *compare_arg , void *a , void *b ) ;
#line 38
static int _free_vars(void *key ) ;
#line 40 "httpp.c"
http_parser_t *httpp_create_parser(void) 
{ http_parser_t *tmp ;

  {
#line 42
  tmp = (http_parser_t *)malloc(sizeof(http_parser_t ));
#line 42
  return (tmp);
}
}
#line 45 "httpp.c"
void httpp_initialize(http_parser_t *parser , http_varlist_t *defaults ) 
{ http_varlist_t *list ;

  {
#line 49
  parser->req_type = 0;
#line 50
  parser->uri = (char *)((void *)0);
#line 51
  parser->vars = avl_tree_new(& _compare_vars, (void *)0);
#line 52
  parser->queryvars = avl_tree_new(& _compare_vars, (void *)0);
#line 55
  list = defaults;
#line 56
  while ((unsigned int )list != (unsigned int )((void *)0)) {
#line 57
    httpp_setvar(parser, (char const   *)list->var.name, (char const   *)list->var.value);
#line 58
    list = list->next;
  }
#line 60
  return;
}
}
#line 62 "httpp.c"
static int split_headers(char *data , unsigned long len , char **line ) 
{ int lines ;
  unsigned long i ;

  {
#line 67
  lines = 0;
#line 69
  (*(line + lines)) = data;
#line 70
  i = 0UL;
#line 70
  while (1) {
#line 70
    if (i < len) {
#line 70
      if (! (lines < 32)) {
#line 70
        break;
      }
    } else {
#line 70
      break;
    }
#line 71
    if ((int )(*(data + i)) == 13) {
#line 72
      (*(data + i)) = (char )'\000';
    }
#line 73
    if ((int )(*(data + i)) == 10) {
#line 74
      lines ++;
#line 75
      (*(data + i)) = (char )'\000';
#line 76
      if (lines >= 32) {
#line 77
        return (32);
      }
#line 78
      if (i + 1UL < len) {
#line 79
        if ((int )(*(data + (i + 1UL))) == 10) {
#line 80
          break;
        } else {
#line 79
          if ((int )(*(data + (i + 1UL))) == 13) {
#line 80
            break;
          }
        }
#line 81
        (*(line + lines)) = data + (i + 1UL);
      }
    }
#line 70
    i ++;
  }
#line 86
  i ++;
#line 87
  while (1) {
#line 87
    if (i < len) {
#line 87
      if (! ((int )(*(data + i)) == 10)) {
#line 87
        break;
      }
    } else {
#line 87
      break;
    }
#line 87
    i ++;
  }
#line 89
  return (lines);
}
}
#line 92 "httpp.c"
static void parse_headers(http_parser_t *parser , char **line , int lines ) 
{ int i ;
  int l ;
  int whitespace ;
  int where ;
  int slen ;
  char *name ;
  char *value ;
  char *tmp ;

  {
#line 96
  name = (char *)((void *)0);
#line 97
  value = (char *)((void *)0);
#line 100
  l = 1;
#line 100
  while (l < lines) {
#line 101
    where = 0;
#line 102
    whitespace = 0;
#line 103
    name = (*(line + l));
#line 104
    value = (char *)((void *)0);
#line 105
    slen = (int )strlen((char const   *)(*(line + l)));
#line 106
    i = 0;
#line 106
    while (i < slen) {
#line 107
      if ((int )(*((*(line + l)) + i)) == 58) {
#line 108
        whitespace = 1;
#line 109
        (*((*(line + l)) + i)) = (char )'\000';
      } else {
#line 111
        if (whitespace) {
#line 112
          whitespace = 0;
#line 113
          while (1) {
#line 113
            if (i < slen) {
#line 113
              if (! ((int )(*((*(line + l)) + i)) == 32)) {
#line 113
                break;
              }
            } else {
#line 113
              break;
            }
#line 114
            i ++;
          }
#line 116
          if (i < slen) {
#line 117
            value = (*(line + l)) + i;
          }
#line 119
          break;
        }
      }
#line 106
      i ++;
    }
#line 124
    if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 124
      if ((unsigned int )value != (unsigned int )((void *)0)) {
#line 125
        tmp = _lowercase(name);
#line 125
        httpp_setvar(parser, (char const   *)tmp, (char const   *)value);
#line 126
        name = (char *)((void *)0);
#line 127
        value = (char *)((void *)0);
      }
    }
#line 100
    l ++;
  }
#line 130
  return;
}
}
#line 132 "httpp.c"
int httpp_parse_response(http_parser_t *parser , char *http_data , unsigned long len ,
                         char *uri ) 
{ char *data ;
  char *line[32] ;
  int lines ;
  int slen ;
  int i ;
  int whitespace ;
  int where ;
  int code ;
  char *version ;
  char *resp_code ;
  char *message ;

  {
#line 136
  whitespace = 0;
#line 136
  where = 0;
#line 137
  version = (char *)((void *)0);
#line 137
  resp_code = (char *)((void *)0);
#line 137
  message = (char *)((void *)0);
#line 139
  if ((unsigned int )http_data == (unsigned int )((void *)0)) {
#line 140
    return (0);
  }
#line 143
  data = (char *)malloc((unsigned int )(len + 1UL));
#line 144
  if ((unsigned int )data == (unsigned int )((void *)0)) {
#line 144
    return (0);
  }
#line 145
  memcpy((void * __restrict  )data, (void const   * __restrict  )http_data, (unsigned int )len);
#line 146
  (*(data + len)) = (char)0;
#line 148
  lines = split_headers(data, len, line);
#line 153
  slen = (int )strlen((char const   *)line[0]);
#line 154
  version = line[0];
#line 155
  i = 0;
#line 155
  while (i < slen) {
#line 156
    if ((int )(*(line[0] + i)) == 32) {
#line 157
      (*(line[0] + i)) = (char)0;
#line 158
      whitespace = 1;
    } else {
#line 159
      if (whitespace) {
#line 160
        whitespace = 0;
#line 161
        where ++;
#line 162
        if (where == 1) {
#line 163
          resp_code = line[0] + i;
        } else {
#line 165
          message = line[0] + i;
#line 166
          break;
        }
      }
    }
#line 155
    i ++;
  }
#line 171
  if ((unsigned int )version == (unsigned int )((void *)0)) {
#line 172
    free((void *)data);
#line 173
    return (0);
  } else {
#line 171
    if ((unsigned int )resp_code == (unsigned int )((void *)0)) {
#line 172
      free((void *)data);
#line 173
      return (0);
    } else {
#line 171
      if ((unsigned int )message == (unsigned int )((void *)0)) {
#line 172
        free((void *)data);
#line 173
        return (0);
      }
    }
  }
#line 176
  httpp_setvar(parser, "__errorcode", (char const   *)resp_code);
#line 177
  code = atoi__extinline((char const   *)resp_code);
#line 178
  if (code < 200) {
#line 179
    httpp_setvar(parser, "__errormessage", (char const   *)message);
  } else {
#line 178
    if (code >= 300) {
#line 179
      httpp_setvar(parser, "__errormessage", (char const   *)message);
    }
  }
#line 182
  httpp_setvar(parser, "__uri", (char const   *)uri);
#line 183
  httpp_setvar(parser, "__req_type", "NONE");
#line 185
  parse_headers(parser, line, lines);
#line 187
  free((void *)data);
#line 189
  return (1);
}
}
#line 192 "httpp.c"
static int hex(char c ) 
{ 

  {
#line 194
  if ((int )c >= 48) {
#line 194
    if ((int )c <= 57) {
#line 195
      return ((int )c - 48);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 196
    if ((int )c >= 65) {
#line 196
      if ((int )c <= 70) {
#line 197
        return (((int )c - 65) + 10);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 198
      if ((int )c >= 97) {
#line 198
        if ((int )c <= 102) {
#line 199
          return (((int )c - 97) + 10);
        } else {
#line 201
          return (-1);
        }
      } else {
#line 201
        return (-1);
      }
    }
  }
}
}
#line 204 "httpp.c"
static char *url_escape(char *src ) 
{ int len ;
  int tmp ;
  unsigned char *decoded ;
  int i ;
  char *dst ;
  int done ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 206
  tmp = (int )strlen((char const   *)src);
#line 206
  len = tmp;
#line 210
  done = 0;
#line 212
  decoded = (unsigned char *)calloc(1U, (unsigned int )(len + 1));
#line 214
  dst = (char *)decoded;
#line 216
  i = 0;
#line 216
  while (i < len) {
#line 217
    switch ((int )(*(src + i))) {
    case 37: ;
#line 219
    if (i + 2 >= len) {
#line 220
      free((void *)decoded);
#line 221
      return ((char *)((void *)0));
    }
#line 223
    tmp___0 = hex((*(src + (i + 1))));
#line 223
    if (tmp___0 == -1) {
#line 224
      free((void *)decoded);
#line 225
      return ((char *)((void *)0));
    } else {
#line 223
      tmp___1 = hex((*(src + (i + 2))));
#line 223
      if (tmp___1 == -1) {
#line 224
        free((void *)decoded);
#line 225
        return ((char *)((void *)0));
      }
    }
#line 228
    tmp___2 = dst;
#line 228
    dst ++;
#line 228
    tmp___3 = hex((*(src + (i + 1))));
#line 228
    tmp___4 = hex((*(src + (i + 2))));
#line 228
    (*tmp___2) = (char )(tmp___3 * 16 + tmp___4);
#line 229
    i += 2;
#line 230
    break;
    case 43: 
#line 232
    tmp___5 = dst;
#line 232
    dst ++;
#line 232
    (*tmp___5) = (char )' ';
#line 233
    break;
    case 35: 
#line 235
    done = 1;
#line 236
    break;
    case 0: 
#line 238
    free((void *)decoded);
#line 239
    return ((char *)((void *)0));
#line 240
    break;
    default: 
#line 242
    tmp___6 = dst;
#line 242
    dst ++;
#line 242
    (*tmp___6) = (*(src + i));
#line 243
    break;
    }
#line 245
    if (done) {
#line 246
      break;
    }
#line 216
    i ++;
  }
#line 249
  (*dst) = (char)0;
#line 251
  return ((char *)decoded);
}
}
#line 255 "httpp.c"
static void parse_query(http_parser_t *parser , char *query ) 
{ int len ;
  int i ;
  char *key ;
  char *val ;

  {
#line 258
  i = 0;
#line 259
  key = query;
#line 260
  val = (char *)((void *)0);
#line 262
  if (! query) {
#line 263
    return;
  } else {
#line 262
    if (! (*query)) {
#line 263
      return;
    }
  }
#line 265
  len = (int )strlen((char const   *)query);
#line 267
  while (i < len) {
#line 268
    switch ((int )(*(query + i))) {
    case 38: 
#line 270
    (*(query + i)) = (char)0;
#line 271
    if (val) {
#line 271
      if (key) {
#line 272
        httpp_set_query_param(parser, key, val);
      }
    }
#line 273
    key = (query + i) + 1;
#line 274
    break;
    case 61: 
#line 276
    (*(query + i)) = (char)0;
#line 277
    val = (query + i) + 1;
#line 278
    break;
    }
#line 280
    i ++;
  }
#line 283
  if (val) {
#line 283
    if (key) {
#line 284
      httpp_set_query_param(parser, key, val);
    }
  }
#line 286
  return;
}
}
#line 288 "httpp.c"
int httpp_parse(http_parser_t *parser , char *http_data , unsigned long len ) 
{ char *data ;
  char *tmp ;
  char *line[32] ;
  int i ;
  int lines ;
  char *req_type ;
  char *uri ;
  char *version ;
  int whitespace ;
  int where ;
  int slen ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *query ;
  char *tmp___8 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *tmp___23 ;

  {
#line 294
  req_type = (char *)((void *)0);
#line 295
  uri = (char *)((void *)0);
#line 296
  version = (char *)((void *)0);
#line 299
  if ((unsigned int )http_data == (unsigned int )((void *)0)) {
#line 300
    return (0);
  }
#line 303
  data = (char *)malloc((unsigned int )(len + 1UL));
#line 304
  if ((unsigned int )data == (unsigned int )((void *)0)) {
#line 304
    return (0);
  }
#line 305
  memcpy((void * __restrict  )data, (void const   * __restrict  )http_data, (unsigned int )len);
#line 306
  (*(data + len)) = (char)0;
#line 308
  lines = split_headers(data, len, line);
#line 316
  where = 0;
#line 317
  whitespace = 0;
#line 318
  slen = (int )strlen((char const   *)line[0]);
#line 319
  req_type = line[0];
#line 320
  i = 0;
#line 320
  while (i < slen) {
#line 321
    if ((int )(*(line[0] + i)) == 32) {
#line 322
      whitespace = 1;
#line 323
      (*(line[0] + i)) = (char )'\000';
    } else {
#line 326
      if (whitespace) {
#line 327
        whitespace = 0;
#line 328
        where ++;
#line 329
        switch (where) {
        case 1: 
#line 331
        uri = line[0] + i;
#line 332
        break;
        case 2: 
#line 334
        version = line[0] + i;
#line 335
        break;
        }
      }
    }
#line 320
    i ++;
  }
#line 341
  tmp___6 = strcasecmp("GET", (char const   *)req_type);
#line 341
  if (tmp___6 == 0) {
#line 342
    parser->req_type = 1;
  } else {
#line 343
    tmp___5 = strcasecmp("POST", (char const   *)req_type);
#line 343
    if (tmp___5 == 0) {
#line 344
      parser->req_type = 2;
    } else {
#line 345
      tmp___4 = strcasecmp("HEAD", (char const   *)req_type);
#line 345
      if (tmp___4 == 0) {
#line 346
        parser->req_type = 3;
      } else {
#line 347
        tmp___3 = strcasecmp("SOURCE", (char const   *)req_type);
#line 347
        if (tmp___3 == 0) {
#line 348
          parser->req_type = 4;
        } else {
#line 349
          tmp___2 = strcasecmp("PLAY", (char const   *)req_type);
#line 349
          if (tmp___2 == 0) {
#line 350
            parser->req_type = 5;
          } else {
#line 351
            tmp___1 = strcasecmp("STATS", (char const   *)req_type);
#line 351
            if (tmp___1 == 0) {
#line 352
              parser->req_type = 6;
            } else {
#line 354
              parser->req_type = 7;
            }
          }
        }
      }
    }
  }
#line 357
  if ((unsigned int )uri != (unsigned int )((void *)0)) {
#line 357
    tmp___19 = strlen((char const   *)uri);
#line 357
    if (tmp___19 > 0U) {
#line 359
      tmp___8 = __builtin_strchr(uri, (char )'?');
#line 359
      query = tmp___8;
#line 359
      if ((unsigned int )query != (unsigned int )((void *)0)) {
#line 360
        httpp_setvar(parser, "__rawuri", (char const   *)uri);
#line 361
        (*query) = (char)0;
#line 362
        query ++;
#line 363
        parse_query(parser, query);
      }
#line 366
      tmp___18 = __strdup((char const   *)uri);
#line 366
      parser->uri = tmp___18;
    } else {
#line 368
      free((void *)data);
#line 369
      return (0);
    }
  } else {
#line 368
    free((void *)data);
#line 369
    return (0);
  }
#line 372
  if ((unsigned int )version != (unsigned int )((void *)0)) {
#line 372
    tmp___23 = __builtin_strchr(version, (char )'/');
#line 372
    tmp = tmp___23;
#line 372
    if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 373
      (*(tmp + 0)) = (char )'\000';
#line 374
      tmp___20 = strlen((char const   *)version);
#line 374
      if (tmp___20 > 0U) {
#line 374
        tmp___21 = strlen((char const   *)(tmp + 1));
#line 374
        if (tmp___21 > 0U) {
#line 375
          httpp_setvar(parser, "__protocol", (char const   *)version);
#line 376
          httpp_setvar(parser, "__version", (char const   *)(tmp + 1));
        } else {
#line 378
          free((void *)data);
#line 379
          return (0);
        }
      } else {
#line 378
        free((void *)data);
#line 379
        return (0);
      }
    } else {
#line 382
      free((void *)data);
#line 383
      return (0);
    }
  } else {
#line 382
    free((void *)data);
#line 383
    return (0);
  }
#line 386
  if ((int )parser->req_type != 0) {
#line 386
    if ((int )parser->req_type != 7) {
#line 387
      switch ((int )parser->req_type) {
      case 1: 
#line 389
      httpp_setvar(parser, "__req_type", "GET");
#line 390
      break;
      case 2: 
#line 392
      httpp_setvar(parser, "__req_type", "POST");
#line 393
      break;
      case 3: 
#line 395
      httpp_setvar(parser, "__req_type", "HEAD");
#line 396
      break;
      case 4: 
#line 398
      httpp_setvar(parser, "__req_type", "SOURCE");
#line 399
      break;
      case 5: 
#line 401
      httpp_setvar(parser, "__req_type", "PLAY");
#line 402
      break;
      case 6: 
#line 404
      httpp_setvar(parser, "__req_type", "STATS");
#line 405
      break;
      default: ;
#line 407
      break;
      }
    } else {
#line 410
      free((void *)data);
#line 411
      return (0);
    }
  } else {
#line 410
    free((void *)data);
#line 411
    return (0);
  }
#line 414
  if ((unsigned int )parser->uri != (unsigned int )((void *)0)) {
#line 415
    httpp_setvar(parser, "__uri", (char const   *)parser->uri);
  } else {
#line 417
    free((void *)data);
#line 418
    return (0);
  }
#line 421
  parse_headers(parser, line, lines);
#line 423
  free((void *)data);
#line 425
  return (1);
}
}
#line 428 "httpp.c"
void httpp_setvar(http_parser_t *parser , char const   *name , char const   *value ) 
{ http_var_t *var ;
  char *tmp___9 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 432
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 433
    return;
  } else {
#line 432
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 433
      return;
    }
  }
#line 435
  var = (http_var_t *)malloc(sizeof(http_var_t ));
#line 436
  if ((unsigned int )var == (unsigned int )((void *)0)) {
#line 436
    return;
  }
#line 438
  tmp___9 = __strdup(name);
#line 438
  var->name = tmp___9;
#line 439
  tmp___19 = __strdup(value);
#line 439
  var->value = tmp___19;
#line 441
  tmp___20 = httpp_getvar(parser, name);
#line 441
  if ((unsigned int )tmp___20 == (unsigned int )((void *)0)) {
#line 442
    avl_insert(parser->vars, (void *)var);
  } else {
#line 444
    avl_delete(parser->vars, (void *)var, & _free_vars);
#line 445
    avl_insert(parser->vars, (void *)var);
  }
#line 447
  return;
}
}
#line 449 "httpp.c"
char *httpp_getvar(http_parser_t *parser , char const   *name ) 
{ http_var_t var ;
  http_var_t *found ;
  void *fp ;
  int tmp ;

  {
#line 455
  if ((unsigned int )parser == (unsigned int )((void *)0)) {
#line 456
    return ((char *)((void *)0));
  } else {
#line 455
    if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 456
      return ((char *)((void *)0));
    }
  }
#line 458
  fp = (void *)(& found);
#line 459
  var.name = (char *)name;
#line 460
  var.value = (char *)((void *)0);
#line 462
  tmp = avl_get_by_key(parser->vars, (void *)(& var), (void **)fp);
#line 462
  if (tmp == 0) {
#line 463
    return (found->value);
  } else {
#line 465
    return ((char *)((void *)0));
  }
}
}
#line 468 "httpp.c"
void httpp_set_query_param(http_parser_t *parser , char *name , char *value ) 
{ http_var_t *var ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 472
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 473
    return;
  } else {
#line 472
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 473
      return;
    }
  }
#line 475
  var = (http_var_t *)malloc(sizeof(http_var_t ));
#line 476
  if ((unsigned int )var == (unsigned int )((void *)0)) {
#line 476
    return;
  }
#line 478
  tmp___9 = __strdup((char const   *)name);
#line 478
  var->name = tmp___9;
#line 479
  var->value = url_escape(value);
#line 481
  tmp___10 = httpp_get_query_param(parser, name);
#line 481
  if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
#line 482
    avl_insert(parser->queryvars, (void *)var);
  } else {
#line 484
    avl_delete(parser->queryvars, (void *)var, & _free_vars);
#line 485
    avl_insert(parser->queryvars, (void *)var);
  }
#line 487
  return;
}
}
#line 489 "httpp.c"
char *httpp_get_query_param(http_parser_t *parser , char *name ) 
{ http_var_t var ;
  http_var_t *found ;
  void *fp ;
  int tmp ;

  {
#line 495
  fp = (void *)(& found);
#line 496
  var.name = name;
#line 497
  var.value = (char *)((void *)0);
#line 499
  tmp = avl_get_by_key(parser->queryvars, (void *)(& var), (void **)fp);
#line 499
  if (tmp == 0) {
#line 500
    return (found->value);
  } else {
#line 502
    return ((char *)((void *)0));
  }
}
}
#line 505 "httpp.c"
void httpp_clear(http_parser_t *parser ) 
{ 

  {
#line 507
  parser->req_type = 0;
#line 508
  if (parser->uri) {
#line 509
    free((void *)parser->uri);
  }
#line 510
  parser->uri = (char *)((void *)0);
#line 511
  avl_tree_free(parser->vars, & _free_vars);
#line 512
  avl_tree_free(parser->queryvars, & _free_vars);
#line 513
  parser->vars = (avl_tree *)((void *)0);
#line 514
  return;
}
}
#line 516 "httpp.c"
void httpp_destroy(http_parser_t *parser ) 
{ 

  {
#line 518
  httpp_clear(parser);
#line 519
  free((void *)parser);
#line 520
  return;
}
}
#line 522 "httpp.c"
static char *_lowercase(char *str ) 
{ char *p ;
  int __res ;
  __int32_t const   **tmp___1 ;

  {
#line 524
  p = str;
#line 525
  while ((int )(*p) != 0) {
#line 526
    if (sizeof((*p)) > 1U) {
#line 526
      __res = tolower__extinline((int )(*p));
    } else {
#line 526
      tmp___1 = __ctype_tolower_loc();
#line 526
      __res = (*((*tmp___1) + (int )(*p)));
    }
#line 526
    (*p) = (char )__res;
#line 525
    p ++;
  }
#line 528
  return (str);
}
}
#line 531 "httpp.c"
static int _compare_vars(void *compare_arg , void *a , void *b ) 
{ http_var_t *vara ;
  http_var_t *varb ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 535
  vara = (http_var_t *)a;
#line 536
  varb = (http_var_t *)b;
#line 538
  if (0) {
#line 538
    __s1_len = strlen((char const   *)vara->name);
#line 538
    __s2_len = strlen((char const   *)varb->name);
#line 538
    if (! ((unsigned int )((void const   *)(vara->name + 1)) - (unsigned int )((void const   *)vara->name) ==
           1U)) {
      goto _L___0;
    } else {
#line 538
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 538
        if (! ((unsigned int )((void const   *)(varb->name + 1)) - (unsigned int )((void const   *)varb->name) ==
               1U)) {
#line 538
          tmp___8 = 1;
        } else {
#line 538
          if (__s2_len >= 4U) {
#line 538
            tmp___8 = 1;
          } else {
#line 538
            tmp___8 = 0;
          }
        }
      } else {
#line 538
        tmp___8 = 0;
      }
    }
#line 538
    if (tmp___8) {
#line 538
      tmp___4 = __builtin_strcmp((char const   *)vara->name, (char const   *)varb->name);
    } else {
#line 538
      tmp___7 = __builtin_strcmp((char const   *)vara->name, (char const   *)varb->name);
#line 538
      tmp___4 = tmp___7;
    }
  } else {
#line 538
    tmp___7 = __builtin_strcmp((char const   *)vara->name, (char const   *)varb->name);
#line 538
    tmp___4 = tmp___7;
  }
#line 538
  return (tmp___4);
}
}
#line 541 "httpp.c"
static int _free_vars(void *key ) 
{ http_var_t *var ;

  {
#line 545
  var = (http_var_t *)key;
#line 547
  if (var->name) {
#line 548
    free((void *)var->name);
  }
#line 549
  if (var->value) {
#line 550
    free((void *)var->value);
  }
#line 551
  free((void *)var);
#line 553
  return (1);
}
}
#line 1 "cil-1y2lrvWM.o"
#pragma merger(0,"/tmp/cil-vkV28CSY.i","")
#line 1 "./src/timing/libicetiming_la-timing.lo_saved.c"
#pragma merger(0,"./timing.i","-pthread -g -O2")
#line 72 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
#line 27 "timing.h"
uint64_t timing_get_time(void) ;
#line 28
void timing_sleep(uint64_t sleeptime ) ;
#line 41 "timing.c"
uint64_t timing_get_time(void) 
{ struct timeval mtv ;

  {
#line 55
  gettimeofday((struct timeval * __restrict  )(& mtv), (struct timezone * __restrict  )((void *)0));
#line 57
  return ((unsigned long long )mtv.tv_sec * 1000ULL + (unsigned long long )mtv.tv_usec /
                                                      1000ULL);
}
}
#line 61 "timing.c"
void timing_sleep(uint64_t sleeptime ) 
{ struct timeval sleeper ;

  {
#line 65
  sleeper.tv_sec = (long )(sleeptime / 1000ULL);
#line 66
  sleeper.tv_usec = (long )((sleeptime % 1000ULL) * 1000ULL);
#line 76
  select(1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
         (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& sleeper));
#line 78
  return;
}
}
#line 1 "cil-yIfXzTDu.o"
#pragma merger(0,"/tmp/cil-B9wQ0vYY.i","")
#line 1 "./src/avl/libiceavl_la-avl.lo_saved.c"
#pragma merger(0,"./avl.i","-pthread -g -O2")
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 323
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 331
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 644 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 160 "./../thread/thread.h"
void thread_rwlock_create_c(rwlock_t *rwlock , int line , char *file ) ;
#line 161
void thread_rwlock_rlock_c(rwlock_t *rwlock , int line , char *file ) ;
#line 162
void thread_rwlock_wlock_c(rwlock_t *rwlock , int line , char *file ) ;
#line 163
void thread_rwlock_unlock_c(rwlock_t *rwlock , int line , char *file ) ;
#line 164
void thread_rwlock_destroy(rwlock_t *rwlock ) ;
#line 105 "avl.h"
avl_node *avl_node_new(void *key , avl_node *parent ) ;
#line 123
int avl_get_by_index(avl_tree *tree , unsigned long index , void **value_address ) ;
#line 135
int avl_iterate_inorder(avl_tree *tree , int (*iter_fun)(void *key , void *iter_arg ) ,
                        void *iter_arg ) ;
#line 141
int avl_iterate_index_range(avl_tree *tree , int (*iter_fun)(unsigned long index ,
                                                             void *key , void *iter_arg ) ,
                            unsigned long low , unsigned long high , void *iter_arg ) ;
#line 149
int avl_get_span_by_key(avl_tree *tree , void *key , unsigned long *low , unsigned long *high ) ;
#line 156
int avl_get_span_by_two_keys(avl_tree *tree , void *low_key , void *high_key , unsigned long *low ,
                             unsigned long *high ) ;
#line 164
int avl_verify(avl_tree *tree ) ;
#line 166
void avl_print_tree(avl_tree *tree , int (*key_printer)(char * , void * ) ) ;
#line 171
avl_node *avl_get_first(avl_tree *tree ) ;
#line 173
avl_node *avl_get_prev(avl_node *node ) ;
#line 175
avl_node *avl_get_next(avl_node *node ) ;
#line 179
int avl_get_item_by_key_most(avl_tree *tree , void *key , void **value_address ) ;
#line 185
int avl_get_item_by_key_least(avl_tree *tree , void *key , void **value_address ) ;
#line 192
void avl_tree_rlock(avl_tree *tree ) ;
#line 193
void avl_tree_wlock(avl_tree *tree ) ;
#line 194
void avl_tree_unlock(avl_tree *tree ) ;
#line 195
void avl_node_rlock(avl_node *node ) ;
#line 196
void avl_node_wlock(avl_node *node ) ;
#line 197
void avl_node_unlock(avl_node *node ) ;
#line 41 "avl.c"
avl_node *avl_node_new(void *key , avl_node *parent ) 
{ avl_node *node ;
  avl_node *tmp ;

  {
#line 45
  tmp = (avl_node *)malloc(sizeof(avl_node ));
#line 45
  node = tmp;
#line 47
  if (! node) {
#line 48
    return ((avl_node *)((void *)0));
  } else {
#line 50
    node->parent = parent;
#line 51
    node->key = key;
#line 52
    node->left = (struct avl_node_tag *)((void *)0);
#line 53
    node->right = (struct avl_node_tag *)((void *)0);
#line 54
    node->rank_and_balance = 0UL;
#line 55
    node->rank_and_balance = (node->rank_and_balance & 4294967292UL) | 1UL;
#line 56
    node->rank_and_balance = (node->rank_and_balance & 3UL) | 4UL;
#line 57
    thread_rwlock_create_c(& node->rwlock, 57, (char *)"avl.c");
#line 58
    return (node);
  }
}
}
#line 62 "avl.c"
avl_tree *avl_tree_new(int (*compare_fun)(void *compare_arg , void *a , void *b ) ,
                       void *compare_arg ) 
{ avl_tree *t ;
  avl_tree *tmp ;
  avl_node *root ;
  avl_node *tmp___0 ;

  {
#line 66
  tmp = (avl_tree *)malloc(sizeof(avl_tree ));
#line 66
  t = tmp;
#line 68
  if (! t) {
#line 69
    return ((avl_tree *)((void *)0));
  } else {
#line 71
    tmp___0 = avl_node_new((void *)0, (avl_node *)((void *)0));
#line 71
    root = tmp___0;
#line 72
    if (! root) {
#line 73
      return ((avl_tree *)((void *)0));
    } else {
#line 75
      t->root = root;
#line 76
      t->height = 0UL;
#line 77
      t->length = 0UL;
#line 78
      t->compare_fun = compare_fun;
#line 79
      t->compare_arg = compare_arg;
#line 80
      thread_rwlock_create_c(& t->rwlock, 80, (char *)"avl.c");
#line 81
      return (t);
    }
  }
}
}
#line 86 "avl.c"
static void avl_tree_free_helper(avl_node *node , int (*free_key_fun)(void *key ) ) 
{ 

  {
#line 89
  if (node->left) {
#line 90
    avl_tree_free_helper(node->left, free_key_fun);
  }
#line 92
  if (free_key_fun) {
#line 93
    ((*free_key_fun))(node->key);
  }
#line 94
  if (node->right) {
#line 95
    avl_tree_free_helper(node->right, free_key_fun);
  }
#line 97
  thread_rwlock_destroy(& node->rwlock);
#line 98
  free((void *)node);
#line 99
  return;
}
}
#line 101 "avl.c"
void avl_tree_free(avl_tree *tree , int (*free_key_fun)(void *key ) ) 
{ 

  {
#line 104
  if (tree->length) {
#line 105
    avl_tree_free_helper((tree->root)->right, free_key_fun);
  }
#line 107
  if (tree->root) {
#line 108
    thread_rwlock_destroy(& (tree->root)->rwlock);
#line 109
    free((void *)tree->root);
  }
#line 111
  thread_rwlock_destroy(& tree->rwlock);
#line 112
  free((void *)tree);
#line 113
  return;
}
}
#line 115 "avl.c"
int avl_insert(avl_tree *ob , void *key ) 
{ avl_node *node ;
  avl_node *tmp ;
  avl_node *t ;
  avl_node *p ;
  avl_node *s ;
  avl_node *q ;
  avl_node *r ;
  int a ;
  avl_node *q_node ;
  avl_node *tmp___0 ;
  avl_node *q_node___0 ;
  avl_node *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 119
  if (! (ob->root)->right) {
#line 120
    tmp = avl_node_new(key, ob->root);
#line 120
    node = tmp;
#line 121
    if (! node) {
#line 122
      return (-1);
    } else {
#line 124
      (ob->root)->right = node;
#line 125
      ob->length = ob->length + 1UL;
#line 126
      return (0);
    }
  } else {
#line 132
    t = ob->root;
#line 133
    p = t->right;
#line 133
    s = p;
#line 135
    while (1) {
#line 136
      tmp___2 = ((*(ob->compare_fun)))(ob->compare_arg, key, p->key);
#line 136
      if (tmp___2 < 1) {
#line 138
        p->rank_and_balance = (p->rank_and_balance & 3UL) | (((p->rank_and_balance >>
                                                               2) + 1UL) << 2);
#line 139
        q = p->left;
#line 140
        if (! q) {
#line 142
          tmp___0 = avl_node_new(key, p);
#line 142
          q_node = tmp___0;
#line 143
          if (! q_node) {
#line 144
            return (-1);
          } else {
#line 146
            q = q_node;
#line 147
            p->left = q;
#line 148
            break;
          }
        } else {
#line 150
          if ((int )((q->rank_and_balance & 3UL) - 1UL)) {
#line 151
            t = p;
#line 152
            s = q;
          }
        }
#line 154
        p = q;
      } else {
#line 157
        q = p->right;
#line 158
        if (! q) {
#line 160
          tmp___1 = avl_node_new(key, p);
#line 160
          q_node___0 = tmp___1;
#line 161
          if (! q_node___0) {
#line 162
            return (-1);
          } else {
#line 164
            q = q_node___0;
#line 165
            p->right = q;
#line 166
            break;
          }
        } else {
#line 168
          if ((int )((q->rank_and_balance & 3UL) - 1UL)) {
#line 169
            t = p;
#line 170
            s = q;
          }
        }
#line 172
        p = q;
      }
    }
#line 176
    ob->length = ob->length + 1UL;
#line 179
    tmp___3 = ((*(ob->compare_fun)))(ob->compare_arg, key, s->key);
#line 179
    if (tmp___3 < 1) {
#line 180
      p = s->left;
#line 180
      r = p;
    } else {
#line 182
      p = s->right;
#line 182
      r = p;
    }
#line 184
    while ((unsigned int )p != (unsigned int )q) {
#line 185
      tmp___4 = ((*(ob->compare_fun)))(ob->compare_arg, key, p->key);
#line 185
      if (tmp___4 < 1) {
#line 186
        p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 0UL;
#line 187
        p = p->left;
      } else {
#line 189
        p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 2UL;
#line 190
        p = p->right;
      }
    }
#line 196
    tmp___5 = ((*(ob->compare_fun)))(ob->compare_arg, key, s->key);
#line 196
    if (tmp___5 < 1) {
#line 197
      a = -1;
    } else {
#line 199
      a = 1;
    }
#line 202
    if ((int )((s->rank_and_balance & 3UL) - 1UL) == 0) {
#line 203
      s->rank_and_balance = (s->rank_and_balance & 4294967292UL) | (unsigned long )(a +
                                                                                    1);
#line 204
      ob->height = ob->height + 1UL;
#line 205
      return (0);
    } else {
#line 206
      if ((int )((s->rank_and_balance & 3UL) - 1UL) == - a) {
#line 207
        s->rank_and_balance = (s->rank_and_balance & 4294967292UL) | 1UL;
#line 208
        return (0);
      } else {
#line 209
        if ((int )((s->rank_and_balance & 3UL) - 1UL) == a) {
#line 210
          if ((int )((r->rank_and_balance & 3UL) - 1UL) == a) {
#line 212
            p = r;
#line 213
            if (a == -1) {
#line 214
              s->left = r->right;
#line 215
              if (r->right) {
#line 216
                (r->right)->parent = s;
              }
#line 218
              r->right = s;
#line 219
              s->parent = r;
#line 220
              s->rank_and_balance = (s->rank_and_balance & 3UL) | (((s->rank_and_balance >>
                                                                     2) - (r->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
            } else {
#line 222
              s->right = r->left;
#line 223
              if (r->left) {
#line 224
                (r->left)->parent = s;
              }
#line 226
              r->left = s;
#line 227
              s->parent = r;
#line 228
              r->rank_and_balance = (r->rank_and_balance & 3UL) | (((r->rank_and_balance >>
                                                                     2) + (s->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
            }
#line 230
            s->rank_and_balance = (s->rank_and_balance & 4294967292UL) | 1UL;
#line 231
            r->rank_and_balance = (r->rank_and_balance & 4294967292UL) | 1UL;
          } else {
#line 232
            if ((int )((r->rank_and_balance & 3UL) - 1UL) == - a) {
#line 234
              if (a == -1) {
#line 235
                p = r->right;
#line 236
                r->right = p->left;
#line 237
                if (p->left) {
#line 238
                  (p->left)->parent = r;
                }
#line 240
                p->left = r;
#line 241
                r->parent = p;
#line 242
                s->left = p->right;
#line 243
                if (p->right) {
#line 244
                  (p->right)->parent = s;
                }
#line 246
                p->right = s;
#line 247
                s->parent = p;
#line 248
                p->rank_and_balance = (p->rank_and_balance & 3UL) | (((p->rank_and_balance >>
                                                                       2) + (r->rank_and_balance >>
                                                                             2)) <<
                                                                     2);
#line 249
                s->rank_and_balance = (s->rank_and_balance & 3UL) | (((s->rank_and_balance >>
                                                                       2) - (p->rank_and_balance >>
                                                                             2)) <<
                                                                     2);
              } else {
#line 251
                p = r->left;
#line 252
                r->left = p->right;
#line 253
                if (p->right) {
#line 254
                  (p->right)->parent = r;
                }
#line 256
                p->right = r;
#line 257
                r->parent = p;
#line 258
                s->right = p->left;
#line 259
                if (p->left) {
#line 260
                  (p->left)->parent = s;
                }
#line 262
                p->left = s;
#line 263
                s->parent = p;
#line 264
                r->rank_and_balance = (r->rank_and_balance & 3UL) | (((r->rank_and_balance >>
                                                                       2) - (p->rank_and_balance >>
                                                                             2)) <<
                                                                     2);
#line 265
                p->rank_and_balance = (p->rank_and_balance & 3UL) | (((p->rank_and_balance >>
                                                                       2) + (s->rank_and_balance >>
                                                                             2)) <<
                                                                     2);
              }
#line 267
              if ((int )((p->rank_and_balance & 3UL) - 1UL) == a) {
#line 268
                s->rank_and_balance = (s->rank_and_balance & 4294967292UL) | (unsigned long )(- a +
                                                                                              1);
#line 269
                r->rank_and_balance = (r->rank_and_balance & 4294967292UL) | 1UL;
              } else {
#line 270
                if ((int )((p->rank_and_balance & 3UL) - 1UL) == - a) {
#line 271
                  s->rank_and_balance = (s->rank_and_balance & 4294967292UL) | 1UL;
#line 272
                  r->rank_and_balance = (r->rank_and_balance & 4294967292UL) | (unsigned long )(a +
                                                                                                1);
                } else {
#line 274
                  s->rank_and_balance = (s->rank_and_balance & 4294967292UL) | 1UL;
#line 275
                  r->rank_and_balance = (r->rank_and_balance & 4294967292UL) | 1UL;
                }
              }
#line 277
              p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 1UL;
            }
          }
#line 280
          if ((unsigned int )s == (unsigned int )t->right) {
#line 281
            t->right = p;
          } else {
#line 283
            t->left = p;
          }
#line 285
          p->parent = t;
        }
      }
    }
  }
#line 288
  return (0);
}
}
#line 291 "avl.c"
int avl_get_by_index(avl_tree *tree , unsigned long index , void **value_address ) 
{ avl_node *p ;
  unsigned long m ;

  {
#line 296
  p = (tree->root)->right;
#line 297
  m = index + 1UL;
#line 298
  while (1) {
#line 299
    if (! p) {
#line 300
      return (-1);
    }
#line 302
    if (m < p->rank_and_balance >> 2) {
#line 303
      p = p->left;
    } else {
#line 304
      if (m > p->rank_and_balance >> 2) {
#line 305
        m = m - (p->rank_and_balance >> 2);
#line 306
        p = p->right;
      } else {
#line 308
        (*value_address) = p->key;
#line 309
        return (0);
      }
    }
  }
}
}
#line 314 "avl.c"
int avl_get_by_key(avl_tree *tree , void *key , void **value_address ) 
{ avl_node *x ;
  int compare_result ;
  int tmp ;

  {
#line 319
  x = (tree->root)->right;
#line 320
  if (! x) {
#line 321
    return (-1);
  }
#line 323
  while (1) {
#line 324
    tmp = ((*(tree->compare_fun)))(tree->compare_arg, key, x->key);
#line 324
    compare_result = tmp;
#line 325
    if (compare_result < 0) {
#line 326
      if (x->left) {
#line 327
        x = x->left;
      } else {
#line 329
        return (-1);
      }
    } else {
#line 331
      if (compare_result > 0) {
#line 332
        if (x->right) {
#line 333
          x = x->right;
        } else {
#line 335
          return (-1);
        }
      } else {
#line 338
        (*value_address) = x->key;
#line 339
        return (0);
      }
    }
  }
}
}
#line 344 "avl.c"
int avl_delete(avl_tree *tree , void *key , int (*free_key_fun)(void *key ) ) 
{ avl_node *x ;
  avl_node *y ;
  avl_node *p ;
  avl_node *q ;
  avl_node *r ;
  avl_node *top ;
  avl_node *x_child ;
  int shortened_side ;
  int shorter ;
  int compare_result ;
  int tmp ;
  void *temp_key ;

  {
#line 349
  x = (tree->root)->right;
#line 350
  if (! x) {
#line 351
    return (-1);
  }
#line 353
  while (1) {
#line 354
    tmp = ((*(tree->compare_fun)))(tree->compare_arg, key, x->key);
#line 354
    compare_result = tmp;
#line 355
    if (compare_result < 0) {
#line 360
      x->rank_and_balance = (x->rank_and_balance & 3UL) | (((x->rank_and_balance >>
                                                             2) - 1UL) << 2);
#line 361
      if (x->left) {
#line 362
        x = x->left;
      } else {
#line 367
        x->rank_and_balance = (x->rank_and_balance & 3UL) | (((x->rank_and_balance >>
                                                               2) + 1UL) << 2);
#line 368
        while ((unsigned int )x != (unsigned int )(tree->root)->right) {
#line 369
          if ((unsigned int )(x->parent)->left == (unsigned int )x) {
#line 370
            (x->parent)->rank_and_balance = ((x->parent)->rank_and_balance & 3UL) |
                                            ((((x->parent)->rank_and_balance >> 2) +
                                              1UL) << 2);
          }
#line 372
          x = x->parent;
        }
#line 374
        return (-1);
      }
    } else {
#line 376
      if (compare_result > 0) {
#line 378
        if (x->right) {
#line 379
          x = x->right;
        } else {
#line 381
          x->rank_and_balance = (x->rank_and_balance & 3UL) | (((x->rank_and_balance >>
                                                                 2) + 1UL) << 2);
#line 382
          while ((unsigned int )x != (unsigned int )(tree->root)->right) {
#line 383
            if ((unsigned int )(x->parent)->left == (unsigned int )x) {
#line 384
              (x->parent)->rank_and_balance = ((x->parent)->rank_and_balance & 3UL) |
                                              ((((x->parent)->rank_and_balance >>
                                                 2) + 1UL) << 2);
            }
#line 386
            x = x->parent;
          }
#line 388
          return (-1);
        }
      } else {
#line 391
        break;
      }
    }
  }
#line 395
  if (x->left) {
#line 395
    if (x->right) {
#line 404
      y = x->left;
#line 405
      while (y->right) {
#line 406
        y = y->right;
      }
#line 409
      temp_key = x->key;
#line 410
      x->key = y->key;
#line 411
      y->key = temp_key;
#line 415
      x->rank_and_balance = (x->rank_and_balance & 3UL) | (((x->rank_and_balance >>
                                                             2) - 1UL) << 2);
#line 416
      x = y;
    }
  }
#line 421
  if (x->left) {
#line 422
    x_child = x->left;
#line 423
    x_child->parent = x->parent;
  } else {
#line 424
    if (x->right) {
#line 425
      x_child = x->right;
#line 426
      x_child->parent = x->parent;
    } else {
#line 428
      x_child = (avl_node *)((void *)0);
    }
  }
#line 432
  if ((unsigned int )x == (unsigned int )(x->parent)->left) {
#line 433
    (x->parent)->left = x_child;
#line 434
    shortened_side = -1;
  } else {
#line 436
    (x->parent)->right = x_child;
#line 437
    shortened_side = 1;
  }
#line 446
  shorter = 1;
#line 447
  p = x->parent;
#line 450
  if (free_key_fun) {
#line 451
    ((*free_key_fun))(x->key);
  }
#line 452
  thread_rwlock_destroy(& x->rwlock);
#line 453
  free((void *)x);
#line 455
  while (1) {
#line 455
    if (shorter) {
#line 455
      if (! p->parent) {
#line 455
        break;
      }
    } else {
#line 455
      break;
    }
#line 458
    if ((int )((p->rank_and_balance & 3UL) - 1UL) == 0) {
#line 459
      if (shortened_side == -1) {
#line 463
        p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 2UL;
      } else {
#line 468
        p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 0UL;
      }
#line 470
      shorter = 0;
    } else {
#line 472
      if ((int )((p->rank_and_balance & 3UL) - 1UL) == shortened_side) {
#line 474
        p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 1UL;
      } else {
#line 477
        top = p->parent;
#line 479
        if (shortened_side == 1) {
#line 480
          q = p->left;
        } else {
#line 482
          q = p->right;
        }
#line 484
        if ((int )((q->rank_and_balance & 3UL) - 1UL) == 0) {
#line 486
          if (shortened_side == -1) {
#line 488
            q->parent = p->parent;
#line 489
            p->right = q->left;
#line 490
            if (q->left) {
#line 491
              (q->left)->parent = p;
            }
#line 493
            q->left = p;
#line 494
            p->parent = q;
#line 495
            q->rank_and_balance = (q->rank_and_balance & 3UL) | (((q->rank_and_balance >>
                                                                   2) + (p->rank_and_balance >>
                                                                         2)) << 2);
          } else {
#line 498
            q->parent = p->parent;
#line 499
            p->left = q->right;
#line 500
            if (q->right) {
#line 501
              (q->right)->parent = p;
            }
#line 503
            q->right = p;
#line 504
            p->parent = q;
#line 505
            p->rank_and_balance = (p->rank_and_balance & 3UL) | (((p->rank_and_balance >>
                                                                   2) - (q->rank_and_balance >>
                                                                         2)) << 2);
          }
#line 507
          shorter = 0;
#line 508
          q->rank_and_balance = (q->rank_and_balance & 4294967292UL) | (unsigned long )(shortened_side +
                                                                                        1);
#line 509
          p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | (unsigned long )(- shortened_side +
                                                                                        1);
        } else {
#line 510
          if ((int )((q->rank_and_balance & 3UL) - 1UL) == (int )((p->rank_and_balance &
                                                                   3UL) - 1UL)) {
#line 512
            if (shortened_side == -1) {
#line 514
              q->parent = p->parent;
#line 515
              p->right = q->left;
#line 516
              if (q->left) {
#line 517
                (q->left)->parent = p;
              }
#line 519
              q->left = p;
#line 520
              p->parent = q;
#line 521
              q->rank_and_balance = (q->rank_and_balance & 3UL) | (((q->rank_and_balance >>
                                                                     2) + (p->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
            } else {
#line 524
              q->parent = p->parent;
#line 525
              p->left = q->right;
#line 526
              if (q->right) {
#line 527
                (q->right)->parent = p;
              }
#line 529
              q->right = p;
#line 530
              p->parent = q;
#line 531
              p->rank_and_balance = (p->rank_and_balance & 3UL) | (((p->rank_and_balance >>
                                                                     2) - (q->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
            }
#line 533
            shorter = 1;
#line 534
            q->rank_and_balance = (q->rank_and_balance & 4294967292UL) | 1UL;
#line 535
            p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 1UL;
          } else {
#line 538
            if (shortened_side == 1) {
#line 541
              r = q->right;
#line 542
              r->parent = p->parent;
#line 543
              q->right = r->left;
#line 544
              if (r->left) {
#line 545
                (r->left)->parent = q;
              }
#line 547
              r->left = q;
#line 548
              q->parent = r;
#line 550
              p->left = r->right;
#line 551
              if (r->right) {
#line 552
                (r->right)->parent = p;
              }
#line 554
              r->right = p;
#line 555
              p->parent = r;
#line 556
              r->rank_and_balance = (r->rank_and_balance & 3UL) | (((r->rank_and_balance >>
                                                                     2) + (q->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
#line 557
              p->rank_and_balance = (p->rank_and_balance & 3UL) | (((p->rank_and_balance >>
                                                                     2) - (r->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
            } else {
#line 561
              r = q->left;
#line 562
              r->parent = p->parent;
#line 563
              q->left = r->right;
#line 564
              if (r->right) {
#line 565
                (r->right)->parent = q;
              }
#line 567
              r->right = q;
#line 568
              q->parent = r;
#line 570
              p->right = r->left;
#line 571
              if (r->left) {
#line 572
                (r->left)->parent = p;
              }
#line 574
              r->left = p;
#line 575
              p->parent = r;
#line 576
              q->rank_and_balance = (q->rank_and_balance & 3UL) | (((q->rank_and_balance >>
                                                                     2) - (r->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
#line 577
              r->rank_and_balance = (r->rank_and_balance & 3UL) | (((r->rank_and_balance >>
                                                                     2) + (p->rank_and_balance >>
                                                                           2)) <<
                                                                   2);
            }
#line 579
            if ((int )((r->rank_and_balance & 3UL) - 1UL) == shortened_side) {
#line 580
              q->rank_and_balance = (q->rank_and_balance & 4294967292UL) | (unsigned long )(- shortened_side +
                                                                                            1);
#line 581
              p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 1UL;
            } else {
#line 582
              if ((int )((r->rank_and_balance & 3UL) - 1UL) == - shortened_side) {
#line 583
                q->rank_and_balance = (q->rank_and_balance & 4294967292UL) | 1UL;
#line 584
                p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | (unsigned long )(shortened_side +
                                                                                              1);
              } else {
#line 586
                q->rank_and_balance = (q->rank_and_balance & 4294967292UL) | 1UL;
#line 587
                p->rank_and_balance = (p->rank_and_balance & 4294967292UL) | 1UL;
              }
            }
#line 589
            r->rank_and_balance = (r->rank_and_balance & 4294967292UL) | 1UL;
#line 590
            q = r;
          }
        }
#line 595
        if ((unsigned int )top->left == (unsigned int )p) {
#line 596
          top->left = q;
        } else {
#line 598
          top->right = q;
        }
#line 601
        p = q;
      }
    }
#line 603
    x = p;
#line 604
    p = x->parent;
#line 606
    if ((unsigned int )x == (unsigned int )p->left) {
#line 607
      shortened_side = -1;
    } else {
#line 609
      shortened_side = 1;
    }
  }
#line 613
  tree->length = tree->length - 1UL;
#line 614
  return (0);
}
}
#line 617 "avl.c"
static int avl_iterate_inorder_helper(avl_node *node , int (*iter_fun)(void *key ,
                                                                       void *iter_arg ) ,
                                      void *iter_arg ) 
{ int result ;

  {
#line 623
  if (node->left) {
#line 624
    result = avl_iterate_inorder_helper(node->left, iter_fun, iter_arg);
#line 625
    if (result != 0) {
#line 626
      return (result);
    }
  }
#line 629
  result = ((*iter_fun))(node->key, iter_arg);
#line 630
  if (result != 0) {
#line 631
    return (result);
  }
#line 633
  if (node->right) {
#line 634
    result = avl_iterate_inorder_helper(node->right, iter_fun, iter_arg);
#line 635
    if (result != 0) {
#line 636
      return (result);
    }
  }
#line 639
  return (0);
}
}
#line 642 "avl.c"
int avl_iterate_inorder(avl_tree *tree , int (*iter_fun)(void *key , void *iter_arg ) ,
                        void *iter_arg ) 
{ int result ;

  {
#line 649
  if (tree->length) {
#line 650
    result = avl_iterate_inorder_helper((tree->root)->right, iter_fun, iter_arg);
#line 651
    return (result);
  } else {
#line 653
    return (0);
  }
}
}
#line 657 "avl.c"
avl_node *avl_get_first(avl_tree *tree ) 
{ avl_node *node ;

  {
#line 661
  node = (tree->root)->right;
#line 662
  if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 662
    return ((avl_node *)((void *)0));
  } else {
#line 662
    if ((unsigned int )node->key == (unsigned int )((void *)0)) {
#line 662
      return ((avl_node *)((void *)0));
    }
  }
#line 664
  while (node->left) {
#line 665
    node = node->left;
  }
#line 667
  return (node);
}
}
#line 670 "avl.c"
avl_node *avl_get_prev(avl_node *node ) 
{ avl_node *child ;

  {
#line 672
  if (node->left) {
#line 673
    node = node->left;
#line 674
    while (node->right) {
#line 675
      node = node->right;
    }
#line 678
    return (node);
  } else {
#line 680
    child = node;
#line 681
    while (1) {
#line 681
      if (node->parent) {
#line 681
        if (! (node->parent)->key) {
#line 681
          break;
        }
      } else {
#line 681
        break;
      }
#line 682
      node = node->parent;
#line 683
      if ((unsigned int )child == (unsigned int )node->right) {
#line 684
        return (node);
      }
#line 686
      child = node;
    }
#line 689
    return ((avl_node *)((void *)0));
  }
}
}
#line 693 "avl.c"
avl_node *avl_get_next(avl_node *node ) 
{ avl_node *child ;

  {
#line 695
  if (node->right) {
#line 696
    node = node->right;
#line 697
    while (node->left) {
#line 698
      node = node->left;
    }
#line 701
    return (node);
  } else {
#line 703
    child = node;
#line 704
    while (1) {
#line 704
      if (node->parent) {
#line 704
        if (! (node->parent)->key) {
#line 704
          break;
        }
      } else {
#line 704
        break;
      }
#line 705
      node = node->parent;
#line 706
      if ((unsigned int )child == (unsigned int )node->left) {
#line 707
        return (node);
      }
#line 709
      child = node;
    }
#line 712
    return ((avl_node *)((void *)0));
  }
}
}
#line 718 "avl.c"
int avl_iterate_index_range(avl_tree *tree , int (*iter_fun)(unsigned long index ,
                                                             void *key , void *iter_arg ) ,
                            unsigned long low , unsigned long high , void *iter_arg ) 
{ unsigned long m ;
  unsigned long num_left ;
  avl_node *node ;
  int tmp ;

  {
#line 729
  if (high > tree->length) {
#line 730
    return (-1);
  }
#line 732
  num_left = high - low;
#line 734
  m = high;
#line 735
  node = (tree->root)->right;
#line 736
  while (1) {
#line 737
    if (m < node->rank_and_balance >> 2) {
#line 738
      node = node->left;
    } else {
#line 739
      if (m > node->rank_and_balance >> 2) {
#line 740
        m = m - (node->rank_and_balance >> 2);
#line 741
        node = node->right;
      } else {
#line 743
        break;
      }
    }
  }
#line 747
  while (num_left) {
#line 748
    num_left = num_left - 1UL;
#line 749
    tmp = ((*iter_fun))(num_left, node->key, iter_arg);
#line 749
    if (tmp != 0) {
#line 750
      return (-1);
    }
#line 752
    node = avl_get_prev(node);
  }
#line 754
  return (0);
}
}
#line 762 "avl.c"
static avl_node *avl_get_index_by_key(avl_tree *tree , void *key , unsigned long *index ) 
{ avl_node *x ;
  unsigned long m ;
  int compare_result ;
  int tmp ;

  {
#line 767
  x = (tree->root)->right;
#line 770
  if (! x) {
#line 771
    return ((avl_node *)((void *)0));
  }
#line 773
  m = x->rank_and_balance >> 2;
#line 775
  while (1) {
#line 776
    tmp = ((*(tree->compare_fun)))(tree->compare_arg, key, x->key);
#line 776
    compare_result = tmp;
#line 777
    if (compare_result < 0) {
#line 778
      if (x->left) {
#line 779
        m = m - (x->rank_and_balance >> 2);
#line 780
        x = x->left;
#line 781
        m = m + (x->rank_and_balance >> 2);
      } else {
#line 783
        (*index) = m - 2UL;
#line 784
        return ((avl_node *)((void *)0));
      }
    } else {
#line 786
      if (compare_result > 0) {
#line 787
        if (x->right) {
#line 788
          x = x->right;
#line 789
          m = m + (x->rank_and_balance >> 2);
        } else {
#line 791
          (*index) = m - 1UL;
#line 792
          return ((avl_node *)((void *)0));
        }
      } else {
#line 795
        (*index) = m - 1UL;
#line 796
        return (x);
      }
    }
  }
}
}
#line 803 "avl.c"
int avl_get_span_by_key(avl_tree *tree , void *key , unsigned long *low , unsigned long *high ) 
{ unsigned long m ;
  unsigned long i ;
  unsigned long j ;
  avl_node *node ;
  avl_node *left ;
  avl_node *right ;
  int tmp ;
  int tmp___0 ;

  {
#line 812
  node = avl_get_index_by_key(tree, key, & m);
#line 819
  if (node) {
#line 822
    left = avl_get_prev(node);
#line 823
    i = m;
#line 824
    while (1) {
#line 824
      if (i > 0UL) {
#line 824
        tmp = ((*(tree->compare_fun)))(tree->compare_arg, key, left->key);
#line 824
        if (! (tmp == 0)) {
#line 824
          break;
        }
      } else {
#line 824
        break;
      }
#line 825
      left = avl_get_prev(left);
#line 826
      i = i - 1UL;
    }
#line 829
    right = avl_get_next(node);
#line 830
    j = m;
#line 831
    while (1) {
#line 831
      if (j <= tree->length) {
#line 831
        tmp___0 = ((*(tree->compare_fun)))(tree->compare_arg, key, right->key);
#line 831
        if (! (tmp___0 == 0)) {
#line 831
          break;
        }
      } else {
#line 831
        break;
      }
#line 832
      right = avl_get_next(right);
#line 833
      j = j + 1UL;
    }
#line 835
    (*low) = i;
#line 836
    (*high) = j + 1UL;
#line 837
    return (0);
  } else {
#line 839
    (*high) = m;
#line 839
    (*low) = (*high);
  }
#line 841
  return (0);
}
}
#line 846 "avl.c"
int avl_get_span_by_two_keys(avl_tree *tree , void *low_key , void *high_key , unsigned long *low ,
                             unsigned long *high ) 
{ unsigned long i ;
  unsigned long j ;
  avl_node *low_node ;
  avl_node *high_node ;
  int order ;
  void *temp ;
  avl_node *left ;
  int tmp ;
  avl_node *right ;
  int tmp___0 ;

  {
#line 858
  order = ((*(tree->compare_fun)))(tree->compare_arg, low_key, high_key);
#line 859
  if (order > 0) {
#line 860
    temp = low_key;
#line 861
    low_key = high_key;
#line 862
    high_key = temp;
  }
#line 865
  low_node = avl_get_index_by_key(tree, low_key, & i);
#line 866
  high_node = avl_get_index_by_key(tree, high_key, & j);
#line 868
  if (low_node) {
#line 871
    left = avl_get_prev(low_node);
#line 872
    while (1) {
#line 872
      if (i > 0UL) {
#line 872
        tmp = ((*(tree->compare_fun)))(tree->compare_arg, low_key, left->key);
#line 872
        if (! (tmp == 0)) {
#line 872
          break;
        }
      } else {
#line 872
        break;
      }
#line 873
      left = avl_get_prev(left);
#line 874
      i = i - 1UL;
    }
  } else {
#line 877
    i = i + 1UL;
  }
#line 879
  if (high_node) {
#line 882
    right = avl_get_next(high_node);
#line 883
    while (1) {
#line 883
      if (j <= tree->length) {
#line 883
        tmp___0 = ((*(tree->compare_fun)))(tree->compare_arg, high_key, right->key);
#line 883
        if (! (tmp___0 == 0)) {
#line 883
          break;
        }
      } else {
#line 883
        break;
      }
#line 884
      right = avl_get_next(right);
#line 885
      j = j + 1UL;
    }
  } else {
#line 888
    j = j + 1UL;
  }
#line 891
  (*low) = i;
#line 892
  (*high) = j;
#line 893
  return (0);
}
}
#line 897 "avl.c"
int avl_get_item_by_key_most(avl_tree *tree , void *key , void **value_address ) 
{ avl_node *x ;
  int compare_result ;
  int tmp ;

  {
#line 902
  x = (tree->root)->right;
#line 903
  (*value_address) = (void *)0;
#line 905
  if (! x) {
#line 906
    return (-1);
  }
#line 908
  while (1) {
#line 909
    tmp = ((*(tree->compare_fun)))(tree->compare_arg, key, x->key);
#line 909
    compare_result = tmp;
#line 911
    if (compare_result == 0) {
#line 912
      (*value_address) = x->key;
#line 913
      return (0);
    } else {
#line 914
      if (compare_result < 0) {
#line 916
        if (x->left) {
#line 917
          x = x->left;
        } else {
#line 919
          if ((*value_address)) {
#line 920
            return (0);
          } else {
#line 922
            return (-1);
          }
        }
      } else {
#line 927
        (*value_address) = x->key;
#line 928
        if (x->right) {
#line 930
          x = x->right;
        } else {
#line 932
          if ((*value_address)) {
#line 933
            return (0);
          } else {
#line 935
            return (-1);
          }
        }
      }
    }
  }
}
}
#line 941 "avl.c"
int avl_get_item_by_key_least(avl_tree *tree , void *key , void **value_address ) 
{ avl_node *x ;
  int compare_result ;
  int tmp ;

  {
#line 946
  x = (tree->root)->right;
#line 947
  (*value_address) = (void *)0;
#line 949
  if (! x) {
#line 950
    return (-1);
  }
#line 952
  while (1) {
#line 953
    tmp = ((*(tree->compare_fun)))(tree->compare_arg, key, x->key);
#line 953
    compare_result = tmp;
#line 954
    if (compare_result == 0) {
#line 955
      (*value_address) = x->key;
#line 956
      return (0);
    } else {
#line 957
      if (compare_result < 0) {
#line 960
        (*value_address) = x->key;
#line 961
        if (x->left) {
#line 962
          x = x->left;
        } else {
#line 964
          if ((*value_address)) {
#line 965
            return (0);
          } else {
#line 967
            return (-1);
          }
        }
      } else {
#line 970
        if (x->right) {
#line 972
          x = x->right;
        } else {
#line 974
          if ((*value_address)) {
#line 975
            return (0);
          } else {
#line 977
            return (-1);
          }
        }
      }
    }
  }
}
}
#line 985 "avl.c"
static long avl_verify_balance(avl_node *node ) 
{ long lh ;
  long tmp ;
  long rh ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 988
  if (! node) {
#line 989
    return (0L);
  } else {
#line 991
    tmp = avl_verify_balance(node->left);
#line 991
    lh = tmp;
#line 992
    tmp___0 = avl_verify_balance(node->right);
#line 992
    rh = tmp___0;
#line 993
    if (rh - lh != (long )((int )((node->rank_and_balance & 3UL) - 1UL))) {
#line 994
      return (0L);
    }
#line 996
    if (lh - rh > 1L) {
#line 997
      return (0L);
    } else {
#line 996
      if (lh - rh < -1L) {
#line 997
        return (0L);
      }
    }
#line 999
    if (lh > rh) {
#line 999
      tmp___1 = lh;
    } else {
#line 999
      tmp___1 = rh;
    }
#line 999
    return (1L + tmp___1);
  }
}
}
#line 1003 "avl.c"
static void avl_verify_parent(avl_node *node , avl_node *parent ) 
{ 

  {
#line 1006
  if ((unsigned int )node->parent != (unsigned int )parent) {
#line 1007
    return;
  }
#line 1009
  if (node->left) {
#line 1010
    avl_verify_parent(node->left, node);
  }
#line 1012
  if (node->right) {
#line 1013
    avl_verify_parent(node->right, node);
  }
#line 1015
  return;
}
}
#line 1017 "avl.c"
static long avl_verify_rank(avl_node *node ) 
{ unsigned long num_left ;
  unsigned long num_right ;

  {
#line 1020
  if (! node) {
#line 1021
    return (0L);
  } else {
#line 1023
    num_left = 0UL;
#line 1023
    num_right = 0UL;
#line 1024
    if (node->left) {
#line 1025
      num_left = (unsigned long )avl_verify_rank(node->left);
    }
#line 1027
    if (node->right) {
#line 1028
      num_right = (unsigned long )avl_verify_rank(node->right);
    }
#line 1030
    if (node->rank_and_balance >> 2 != num_left + 1UL) {
#line 1031
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid rank at node %ld\n",
              (long )node->key);
#line 1032
      exit(1);
    }
#line 1034
    return ((long )((num_left + num_right) + 1UL));
  }
}
}
#line 1040 "avl.c"
int avl_verify(avl_tree *tree ) 
{ 

  {
#line 1043
  if (tree->length) {
#line 1044
    avl_verify_balance((tree->root)->right);
#line 1045
    avl_verify_parent((tree->root)->right, tree->root);
#line 1046
    avl_verify_rank((tree->root)->right);
  }
#line 1048
  return (0);
}
}
#line 1063 "avl.c"
static char balance_chars[3]  = {      (char )'\\',      (char )'-',      (char )'/'};
#line 1065 "avl.c"
static int default_key_printer(char *buffer , void *key ) 
{ int tmp ;

  {
#line 1068
  tmp = sprintf((char * __restrict  )buffer, (char const   * __restrict  )"%p", key);
#line 1068
  return (tmp);
}
}
#line 1078 "avl.c"
static void print_connectors(link_node *link ) 
{ int i ;
  int i___0 ;

  {
#line 1081
  if (link->parent) {
#line 1082
    print_connectors(link->parent);
  }
#line 1084
  if (link->parent) {
#line 1084
    if ((int )(link->parent)->direction != (int )link->direction) {
#line 1084
      if ((link->parent)->parent) {
#line 1086
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"|");
#line 1087
        i = 0;
#line 1087
        while (i < link->width - 1) {
#line 1088
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" ");
#line 1087
          i ++;
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1092
    i___0 = 0;
#line 1092
    while (i___0 < link->width) {
#line 1093
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )" ");
#line 1092
      i___0 ++;
    }
  }
#line 1096
  return;
}
}
#line 1105 "avl.c"
static void print_node(int (*key_printer)(char * , void * ) , avl_node *node , link_node *link ) 
{ char buffer[256] ;
  unsigned int width ;
  link_node here ;
  link_node here___0 ;

  {
#line 1112
  width = (unsigned int )((*key_printer))(buffer, node->key);
#line 1114
  if (node->right) {
#line 1116
    here.parent = link;
#line 1117
    here.direction = (char)1;
#line 1118
    here.width = (int )(width + 11U);
#line 1119
    print_node(key_printer, node->right, & here);
  }
#line 1121
  print_connectors(link);
#line 1122
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"+-[%c %s %03d]",
          balance_chars[(int )((node->rank_and_balance & 3UL) - 1UL) + 1], buffer,
          (int )(node->rank_and_balance >> 2));
#line 1126
  if (node->left) {
#line 1127
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"-|\n");
  } else {
#line 1126
    if (node->right) {
#line 1127
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"-|\n");
    } else {
#line 1129
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
    }
  }
#line 1131
  if (node->left) {
#line 1133
    here___0.parent = link;
#line 1134
    here___0.direction = (char)-1;
#line 1135
    here___0.width = (int )(width + 11U);
#line 1136
    print_node(key_printer, node->left, & here___0);
  }
#line 1138
  return;
}
}
#line 1140 "avl.c"
void avl_print_tree(avl_tree *tree , int (*key_printer)(char * , void * ) ) 
{ link_node top ;

  {
#line 1143
  top.parent = (struct _link_node *)((void *)0);
#line 1143
  top.direction = (char)0;
#line 1143
  top.width = 0;
#line 1144
  if (! key_printer) {
#line 1145
    key_printer = & default_key_printer;
  }
#line 1147
  if (tree->length) {
#line 1148
    print_node(key_printer, (tree->root)->right, & top);
  } else {
#line 1150
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"<empty tree>\n");
  }
#line 1152
  return;
}
}
#line 1155 "avl.c"
void avl_tree_rlock(avl_tree *tree ) 
{ 

  {
#line 1157
  thread_rwlock_rlock_c(& tree->rwlock, 1157, (char *)"avl.c");
#line 1158
  return;
}
}
#line 1160 "avl.c"
void avl_tree_wlock(avl_tree *tree ) 
{ 

  {
#line 1162
  thread_rwlock_wlock_c(& tree->rwlock, 1162, (char *)"avl.c");
#line 1163
  return;
}
}
#line 1165 "avl.c"
void avl_tree_unlock(avl_tree *tree ) 
{ 

  {
#line 1167
  thread_rwlock_unlock_c(& tree->rwlock, 1167, (char *)"avl.c");
#line 1168
  return;
}
}
#line 1170 "avl.c"
void avl_node_rlock(avl_node *node ) 
{ 

  {
#line 1172
  thread_rwlock_rlock_c(& node->rwlock, 1172, (char *)"avl.c");
#line 1173
  return;
}
}
#line 1175 "avl.c"
void avl_node_wlock(avl_node *node ) 
{ 

  {
#line 1177
  thread_rwlock_wlock_c(& node->rwlock, 1177, (char *)"avl.c");
#line 1178
  return;
}
}
#line 1180 "avl.c"
void avl_node_unlock(avl_node *node ) 
{ 

  {
#line 1182
  thread_rwlock_unlock_c(& node->rwlock, 1182, (char *)"avl.c");
#line 1183
  return;
}
}
#line 1 "cil-zQ9h5Glg.o"
#pragma merger(0,"/tmp/cil-R2VdpYNr.i","")
#line 1 "./src/thread/libicethread_la-thread.lo_saved.c"
#pragma merger(0,"./thread.i","-pthread -g -O2")
#line 184 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 324
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 190 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg ) ;
#line 199
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 207
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 232
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
#line 235
extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) ;
#line 243
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 246
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 253
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 325
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 429
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 670
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr ) ;
#line 675
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 681
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 691
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t * __restrict  __rwlock ,
                                                             pthread_rwlockattr_t const   * __restrict  __attr ) ;
#line 735
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 751
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 764
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 799
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 804
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 807
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 810
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 817
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ) ;
#line 827
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 219
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 225
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 31 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
#line 143 "./../thread/thread.h"
void thread_initialize(void) ;
#line 145
void thread_shutdown(void) ;
#line 148
thread_type *thread_create_c(char *name , void *(*start_routine)(void * ) , void *arg ,
                             int detached , int line , char *file ) ;
#line 151
void thread_mutex_lock_c(mutex_t *mutex , int line , char *file ) ;
#line 152
void thread_mutex_unlock_c(mutex_t *mutex , int line , char *file ) ;
#line 154
void thread_cond_create_c(cond_t *cond , int line , char *file ) ;
#line 155
void thread_cond_signal_c(cond_t *cond , int line , char *file ) ;
#line 156
void thread_cond_broadcast_c(cond_t *cond , int line , char *file ) ;
#line 157
void thread_cond_wait_c(cond_t *cond , int line , char *file ) ;
#line 158
void thread_cond_timedwait_c(cond_t *cond , int millis , int line , char *file ) ;
#line 159
void thread_cond_destroy(cond_t *cond ) ;
#line 165
void thread_exit_c(long val , int line , char *file ) ;
#line 168
void thread_sleep(unsigned long len ) ;
#line 171
void thread_library_lock(void) ;
#line 172
void thread_library_unlock(void) ;
#line 176
thread_type *thread_self(void) ;
#line 179
void thread_rename(char const   *name ) ;
#line 182
void thread_join(thread_type *thread ) ;
#line 86 "thread.c"
static long _next_thread_id  =    0L;
#line 87 "thread.c"
static int _initialized___0  =    0;
#line 88 "thread.c"
static avl_tree *_threadtree  =    (avl_tree *)((void *)0);
#line 94 "thread.c"
static struct __anonstruct_mutex_t_1 _threadtree_mutex  =    {{.__data = {0, 0U, 0, 0, 0U, 0}}};
#line 112 "thread.c"
static struct __anonstruct_mutex_t_1 _library_mutex  =    {{.__data = {0, 0U, 0, 0, 0U, 0}}};
#line 123
static int _compare_threads(void *compare_arg , void *a , void *b ) ;
#line 124
static int _free_thread(void *key ) ;
#line 127
static void _mutex_create(mutex_t *mutex ) ;
#line 128
static void _mutex_lock(mutex_t *mutex ) ;
#line 129
static void _mutex_unlock(mutex_t *mutex ) ;
#line 132
static void *_start_routine(void *arg ) ;
#line 133
static void _catch_signals(void) ;
#line 134
static void _block_signals(void) ;
#line 138 "thread.c"
void thread_initialize(void) 
{ thread_type *thread ;
  long tmp___0 ;
  char *tmp___10 ;
  char *tmp___20 ;

  {
#line 164
  thread_mutex_create_c(& _threadtree_mutex, 164, (char *)"thread.c");
#line 165
  thread_mutex_create_c(& _library_mutex, 165, (char *)"thread.c");
#line 169
  _threadtree = avl_tree_new(& _compare_threads, (void *)0);
#line 171
  thread = (thread_type *)malloc(sizeof(thread_type ));
#line 173
  tmp___0 = _next_thread_id;
#line 173
  _next_thread_id ++;
#line 173
  thread->thread_id = tmp___0;
#line 174
  thread->line = 0;
#line 175
  tmp___10 = __strdup("main.c");
#line 175
  thread->file = tmp___10;
#line 176
  thread->sys_thread = pthread_self();
#line 177
  thread->create_time = time((time_t *)((void *)0));
#line 178
  tmp___20 = __strdup("Main Thread");
#line 178
  thread->name = tmp___20;
#line 180
  avl_insert(_threadtree, (void *)thread);
#line 182
  _catch_signals();
#line 184
  _initialized___0 = 1;
#line 185
  return;
}
}
#line 187 "thread.c"
void thread_shutdown(void) 
{ 

  {
#line 189
  if (_initialized___0 == 1) {
#line 190
    thread_mutex_destroy(& _library_mutex);
#line 191
    thread_mutex_destroy(& _threadtree_mutex);
#line 197
    avl_tree_free(_threadtree, & _free_thread);
  }
#line 205
  return;
}
}
#line 214 "thread.c"
static void _block_signals(void) 
{ sigset_t ss ;
  int tmp ;

  {
#line 219
  sigfillset(& ss);
#line 222
  sigdelset(& ss, 9);
#line 223
  sigdelset(& ss, 19);
#line 224
  sigdelset(& ss, 11);
#line 225
  sigdelset(& ss, 7);
#line 226
  tmp = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& ss), (__sigset_t * __restrict  )((void *)0));
#line 226
  if (tmp != 0) {

  }
#line 232
  return;
}
}
#line 239 "thread.c"
static void _catch_signals(void) 
{ sigset_t ss ;
  int tmp ;

  {
#line 244
  sigemptyset(& ss);
#line 247
  sigaddset(& ss, 1);
#line 248
  sigaddset(& ss, 17);
#line 249
  sigaddset(& ss, 2);
#line 250
  sigaddset(& ss, 13);
#line 251
  sigaddset(& ss, 15);
#line 253
  tmp = pthread_sigmask(1, (__sigset_t const   * __restrict  )(& ss), (__sigset_t * __restrict  )((void *)0));
#line 253
  if (tmp != 0) {

  }
#line 259
  return;
}
}
#line 262 "thread.c"
thread_type *thread_create_c(char *name , void *(*start_routine)(void * ) , void *arg ,
                             int detached , int line , char *file ) 
{ int ok ;
  thread_type *thread ;
  thread_start_t *start ;
  pthread_attr_t attr ;
  int tmp___1 ;
  char *tmp___11 ;
  long tmp___12 ;
  char *tmp___22 ;
  int tmp___23 ;

  {
#line 265
  ok = 1;
#line 266
  thread = (thread_type *)((void *)0);
#line 267
  start = (thread_start_t *)((void *)0);
#line 270
  thread = (thread_type *)calloc(1U, sizeof(thread_type ));
#line 271
  while (! ((unsigned int )thread == (unsigned int )((void *)0))) {
#line 274
    start = (thread_start_t *)calloc(1U, sizeof(thread_start_t ));
#line 275
    if ((unsigned int )start == (unsigned int )((void *)0)) {
#line 276
      break;
    }
#line 277
    tmp___1 = pthread_attr_init(& attr);
#line 277
    if (tmp___1 < 0) {
#line 278
      break;
    }
#line 280
    thread->line = line;
#line 281
    tmp___11 = __strdup((char const   *)file);
#line 281
    thread->file = tmp___11;
#line 283
    _mutex_lock(& _threadtree_mutex);
#line 284
    tmp___12 = _next_thread_id;
#line 284
    _next_thread_id ++;
#line 284
    thread->thread_id = tmp___12;
#line 285
    _mutex_unlock(& _threadtree_mutex);
#line 287
    tmp___22 = __strdup((char const   *)name);
#line 287
    thread->name = tmp___22;
#line 288
    thread->create_time = time((time_t *)((void *)0));
#line 290
    start->start_routine = start_routine;
#line 291
    start->arg = arg;
#line 292
    start->thread = thread;
#line 294
    pthread_attr_setstacksize(& attr, 524288U);
#line 295
    pthread_attr_setinheritsched(& attr, 0);
#line 296
    if (detached) {
#line 298
      pthread_attr_setdetachstate(& attr, 1);
#line 299
      thread->detached = 1;
    }
#line 302
    tmp___23 = pthread_create((pthread_t * __restrict  )(& thread->sys_thread), (pthread_attr_t const   * __restrict  )(& attr),
                              & _start_routine, (void * __restrict  )start);
#line 302
    if (tmp___23 == 0) {
#line 304
      pthread_attr_destroy(& attr);
#line 305
      return (thread);
    } else {
#line 308
      pthread_attr_destroy(& attr);
    }
#line 271
    break;
  }
#line 315
  if (start) {
#line 315
    free((void *)start);
  }
#line 316
  if (thread) {
#line 316
    free((void *)thread);
  }
#line 317
  return ((thread_type *)((void *)0));
}
}
#line 324 "thread.c"
static void _mutex_create(mutex_t *mutex ) 
{ 

  {
#line 331
  pthread_mutex_init(& mutex->sys_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 332
  return;
}
}
#line 334 "thread.c"
void thread_mutex_create_c(mutex_t *mutex , int line , char *file ) 
{ 

  {
#line 336
  _mutex_create(mutex);
#line 344
  return;
}
}
#line 346 "thread.c"
void thread_mutex_destroy(mutex_t *mutex ) 
{ 

  {
#line 348
  pthread_mutex_destroy(& mutex->sys_mutex);
#line 355
  return;
}
}
#line 357 "thread.c"
void thread_mutex_lock_c(mutex_t *mutex , int line , char *file ) 
{ 

  {
#line 425
  _mutex_lock(mutex);
#line 427
  return;
}
}
#line 429 "thread.c"
void thread_mutex_unlock_c(mutex_t *mutex , int line , char *file ) 
{ 

  {
#line 490
  _mutex_unlock(mutex);
#line 492
  return;
}
}
#line 494 "thread.c"
void thread_cond_create_c(cond_t *cond , int line , char *file ) 
{ 

  {
#line 496
  pthread_cond_init((pthread_cond_t * __restrict  )(& cond->sys_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 497
  pthread_mutex_init(& cond->cond_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 498
  return;
}
}
#line 500 "thread.c"
void thread_cond_destroy(cond_t *cond ) 
{ 

  {
#line 502
  pthread_mutex_destroy(& cond->cond_mutex);
#line 503
  pthread_cond_destroy(& cond->sys_cond);
#line 504
  return;
}
}
#line 506 "thread.c"
void thread_cond_signal_c(cond_t *cond , int line , char *file ) 
{ 

  {
#line 508
  pthread_cond_signal(& cond->sys_cond);
#line 509
  return;
}
}
#line 511 "thread.c"
void thread_cond_broadcast_c(cond_t *cond , int line , char *file ) 
{ 

  {
#line 513
  pthread_cond_broadcast(& cond->sys_cond);
#line 514
  return;
}
}
#line 516 "thread.c"
void thread_cond_timedwait_c(cond_t *cond , int millis , int line , char *file ) 
{ struct timespec time___0 ;

  {
#line 520
  time___0.tv_sec = (long )(millis / 1000);
#line 521
  time___0.tv_nsec = ((__time_t )millis - time___0.tv_sec * 1000L) * 1000000L;
#line 523
  pthread_mutex_lock(& cond->cond_mutex);
#line 524
  pthread_cond_timedwait((pthread_cond_t * __restrict  )(& cond->sys_cond), (pthread_mutex_t * __restrict  )(& cond->cond_mutex),
                         (struct timespec  const  * __restrict  )(& time___0));
#line 525
  pthread_mutex_unlock(& cond->cond_mutex);
#line 526
  return;
}
}
#line 528 "thread.c"
void thread_cond_wait_c(cond_t *cond , int line , char *file ) 
{ 

  {
#line 530
  pthread_mutex_lock(& cond->cond_mutex);
#line 531
  pthread_cond_wait((pthread_cond_t * __restrict  )(& cond->sys_cond), (pthread_mutex_t * __restrict  )(& cond->cond_mutex));
#line 532
  pthread_mutex_unlock(& cond->cond_mutex);
#line 533
  return;
}
}
#line 535 "thread.c"
void thread_rwlock_create_c(rwlock_t *rwlock , int line , char *file ) 
{ 

  {
#line 537
  pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& rwlock->sys_rwlock), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
#line 538
  return;
}
}
#line 540 "thread.c"
void thread_rwlock_destroy(rwlock_t *rwlock ) 
{ 

  {
#line 542
  pthread_rwlock_destroy(& rwlock->sys_rwlock);
#line 543
  return;
}
}
#line 545 "thread.c"
void thread_rwlock_rlock_c(rwlock_t *rwlock , int line , char *file ) 
{ 

  {
#line 547
  pthread_rwlock_rdlock(& rwlock->sys_rwlock);
#line 548
  return;
}
}
#line 550 "thread.c"
void thread_rwlock_wlock_c(rwlock_t *rwlock , int line , char *file ) 
{ 

  {
#line 552
  pthread_rwlock_wrlock(& rwlock->sys_rwlock);
#line 553
  return;
}
}
#line 555 "thread.c"
void thread_rwlock_unlock_c(rwlock_t *rwlock , int line , char *file ) 
{ 

  {
#line 557
  pthread_rwlock_unlock(& rwlock->sys_rwlock);
#line 558
  return;
}
}
#line 560 "thread.c"
void thread_exit_c(long val , int line , char *file ) 
{ thread_type *th ;
  thread_type *tmp ;

  {
#line 562
  tmp = thread_self();
#line 562
  th = tmp;
#line 587
  if (th) {
#line 587
    if (th->detached) {
#line 593
      _mutex_lock(& _threadtree_mutex);
#line 594
      avl_delete(_threadtree, (void *)th, & _free_thread);
#line 595
      _mutex_unlock(& _threadtree_mutex);
    }
  }
#line 598
  pthread_exit((void *)val);
}
}
#line 602 "thread.c"
void thread_sleep(unsigned long len ) 
{ struct timespec time_sleep ;
  struct timespec time_remaining ;
  int ret ;
  int *tmp ;

  {
#line 612
  time_sleep.tv_sec = (long )(len / 1000000UL);
#line 613
  time_sleep.tv_nsec = (long )((len % 1000000UL) * 1000UL);
#line 615
  ret = nanosleep((struct timespec  const  *)(& time_sleep), & time_remaining);
#line 616
  while (1) {
#line 616
    if (ret != 0) {
#line 616
      tmp = __errno_location();
#line 616
      if (! ((*tmp) == 4)) {
#line 616
        break;
      }
    } else {
#line 616
      break;
    }
#line 617
    time_sleep.tv_sec = time_remaining.tv_sec;
#line 618
    time_sleep.tv_nsec = time_remaining.tv_nsec;
#line 620
    ret = nanosleep((struct timespec  const  *)(& time_sleep), & time_remaining);
  }
#line 631
  return;
}
}
#line 633 "thread.c"
static void *_start_routine(void *arg ) 
{ thread_start_t *start ;
  void *(*start_routine)(void * ) ;
  void *real_arg ;
  thread_type *thread ;

  {
#line 635
  start = (thread_start_t *)arg;
#line 636
  start_routine = start->start_routine;
#line 637
  real_arg = start->arg;
#line 638
  thread = start->thread;
#line 640
  _block_signals();
#line 643
  _mutex_lock(& _threadtree_mutex);
#line 644
  thread->sys_thread = pthread_self();
#line 645
  avl_insert(_threadtree, (void *)thread);
#line 646
  _mutex_unlock(& _threadtree_mutex);
#line 652
  pthread_setcancelstate(0, (int *)((void *)0));
#line 653
  free((void *)start);
#line 655
  ((*start_routine))(real_arg);
#line 657
  if (thread->detached) {
#line 659
    _mutex_lock(& _threadtree_mutex);
#line 660
    avl_delete(_threadtree, (void *)thread, & _free_thread);
#line 661
    _mutex_unlock(& _threadtree_mutex);
  }
#line 664
  return ((void *)0);
}
}
#line 667 "thread.c"
thread_type *thread_self(void) 
{ avl_node *node ;
  thread_type *th ;
  pthread_t sys_thread ;
  pthread_t tmp ;
  int tmp___0 ;

  {
#line 671
  tmp = pthread_self();
#line 671
  sys_thread = tmp;
#line 673
  _mutex_lock(& _threadtree_mutex);
#line 675
  if ((unsigned int )_threadtree == (unsigned int )((void *)0)) {
#line 679
    _mutex_unlock(& _threadtree_mutex);
#line 680
    return ((thread_type *)((void *)0));
  }
#line 683
  node = avl_get_first(_threadtree);
#line 685
  while (node) {
#line 686
    th = (thread_type *)node->key;
#line 688
    if (th) {
#line 688
      tmp___0 = pthread_equal(sys_thread, th->sys_thread);
#line 688
      if (tmp___0) {
#line 689
        _mutex_unlock(& _threadtree_mutex);
#line 690
        return (th);
      }
    }
#line 693
    node = avl_get_next(node);
  }
#line 695
  _mutex_unlock(& _threadtree_mutex);
#line 702
  return ((thread_type *)((void *)0));
}
}
#line 705 "thread.c"
void thread_rename(char const   *name ) 
{ thread_type *th ;
  char *tmp___8 ;

  {
#line 709
  th = thread_self();
#line 710
  if (th->name) {
#line 710
    free((void *)th->name);
  }
#line 712
  tmp___8 = __strdup(name);
#line 712
  th->name = tmp___8;
#line 713
  return;
}
}
#line 715 "thread.c"
static void _mutex_lock(mutex_t *mutex ) 
{ 

  {
#line 717
  pthread_mutex_lock(& mutex->sys_mutex);
#line 718
  return;
}
}
#line 720 "thread.c"
static void _mutex_unlock(mutex_t *mutex ) 
{ 

  {
#line 722
  pthread_mutex_unlock(& mutex->sys_mutex);
#line 723
  return;
}
}
#line 726 "thread.c"
void thread_library_lock(void) 
{ 

  {
#line 728
  _mutex_lock(& _library_mutex);
#line 729
  return;
}
}
#line 731 "thread.c"
void thread_library_unlock(void) 
{ 

  {
#line 733
  _mutex_unlock(& _library_mutex);
#line 734
  return;
}
}
#line 736 "thread.c"
void thread_join(thread_type *thread ) 
{ void *ret ;
  int i ;

  {
#line 741
  i = pthread_join(thread->sys_thread, & ret);
#line 742
  _mutex_lock(& _threadtree_mutex);
#line 743
  avl_delete(_threadtree, (void *)thread, & _free_thread);
#line 744
  _mutex_unlock(& _threadtree_mutex);
#line 745
  return;
}
}
#line 765 "thread.c"
static int _compare_threads(void *compare_arg , void *a , void *b ) 
{ thread_type *t1 ;
  thread_type *t2 ;

  {
#line 769
  t1 = (thread_type *)a;
#line 770
  t2 = (thread_type *)b;
#line 772
  if (t1->thread_id > t2->thread_id) {
#line 773
    return (1);
  }
#line 774
  if (t1->thread_id < t2->thread_id) {
#line 775
    return (-1);
  }
#line 776
  return (0);
}
}
#line 797 "thread.c"
static int _free_thread(void *key ) 
{ thread_type *t ;

  {
#line 801
  t = (thread_type *)key;
#line 803
  if (t->file) {
#line 804
    free((void *)t->file);
  }
#line 805
  if (t->name) {
#line 806
    free((void *)t->name);
  }
#line 808
  free((void *)t);
#line 810
  return (1);
}
}
#line 1 "cil-E6NcdxNC.o"
#pragma merger(0,"/tmp/cil-SxP3ufb7.i","")
#line 1 "./src/log/log.lo_saved.c"
#pragma merger(0,"./log.i","-pthread -g -O2")
#line 156 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 208
extern int fclose(FILE *__stream ) ;
#line 213
extern int fflush(FILE *__stream ) ;
#line 243
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 303
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 197 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 233
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 326 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 363
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
#line 363 "/usr/include/sys/stat.h"
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 366
  tmp = __xstat(3, __path, __statbuf);
#line 366
  return (tmp);
}
}
#line 25 "log.h"
void log_initialize(void) ;
#line 26
int log_open_file(FILE *file ) ;
#line 27
int log_open(char const   *filename ) ;
#line 28
int log_open_with_buffer(char const   *filename , int size ) ;
#line 29
void log_set_level(int log_id , unsigned int level ) ;
#line 30
void log_set_trigger(int id , unsigned int trigger ) ;
#line 31
int log_set_filename(int id , char const   *filename ) ;
#line 32
int log_set_archive_timestamp(int id , int value ) ;
#line 33
void log_flush(int log_id ) ;
#line 34
void log_reopen(int log_id ) ;
#line 35
void log_close(int log_id ) ;
#line 36
void log_shutdown(void) ;
#line 38
void log_write(int log_id , unsigned int priority , char const   *cat , char const   *func ,
               char const   *fmt  , ...) ;
#line 40
void log_write_direct(int log_id , char const   *fmt  , ...) ;
#line 46 "log.c"
static pthread_mutex_t _logger_mutex  ;
#line 47 "log.c"
static int _initialized___1  =    0;
#line 64 "log.c"
static log_t loglist[25]  ;
#line 66
static int _get_log_id(void) ;
#line 68
static void _lock_logger(void) ;
#line 69
static void _unlock_logger(void) ;
#line 72 "log.c"
static int _log_open(int id , char const   *file_timestamp ) 
{ struct stat st ;
  char new_name[4096] ;
  int tmp ;

  {
#line 74
  if (loglist[id].in_use == 0) {
#line 75
    return (0);
  }
#line 78
  if ((unsigned int )loglist[id].logfile == (unsigned int )((void *)0)) {
    goto _L;
  } else {
#line 78
    if (loglist[id].trigger_level) {
#line 78
      if (loglist[id].size > loglist[id].trigger_level) {
        _L: /* CIL Label */ 
#line 81
        if (loglist[id].filename) {
#line 85
          if (loglist[id].logfile) {
#line 88
            fclose(loglist[id].logfile);
#line 89
            loglist[id].logfile = (FILE *)((void *)0);
#line 91
            if (loglist[id].archive_timestamp) {
#line 91
              if (file_timestamp) {
#line 92
                snprintf((char * __restrict  )(new_name), sizeof(new_name), (char const   * __restrict  )"%s.%s",
                         loglist[id].filename, file_timestamp);
              } else {
#line 95
                snprintf((char * __restrict  )(new_name), sizeof(new_name), (char const   * __restrict  )"%s.old",
                         loglist[id].filename);
              }
            } else {
#line 95
              snprintf((char * __restrict  )(new_name), sizeof(new_name), (char const   * __restrict  )"%s.old",
                       loglist[id].filename);
            }
#line 101
            rename((char const   *)loglist[id].filename, (char const   *)(new_name));
          }
#line 103
          loglist[id].logfile = fopen((char const   * __restrict  )loglist[id].filename,
                                      (char const   * __restrict  )"a");
#line 104
          if ((unsigned int )loglist[id].logfile == (unsigned int )((void *)0)) {
#line 105
            return (0);
          }
#line 106
          setvbuf((FILE * __restrict  )loglist[id].logfile, (char * __restrict  )((void *)0),
                  1, 0U);
#line 107
          tmp = stat__extinline((char const   *)loglist[id].filename, & st);
#line 107
          if (tmp < 0) {
#line 108
            loglist[id].size = 0L;
          } else {
#line 110
            loglist[id].size = st.st_size;
          }
        } else {
#line 113
          loglist[id].size = 0L;
        }
      }
    }
  }
#line 115
  return (1);
}
}
#line 118 "log.c"
void log_initialize(void) 
{ int i ;

  {
#line 122
  if (_initialized___1) {
#line 122
    return;
  }
#line 124
  i = 0;
#line 124
  while (i < 25) {
#line 125
    loglist[i].in_use = 0;
#line 126
    loglist[i].level = 2U;
#line 127
    loglist[i].size = 0L;
#line 128
    loglist[i].trigger_level = 1000000000L;
#line 129
    loglist[i].filename = (char *)((void *)0);
#line 130
    loglist[i].logfile = (FILE *)((void *)0);
#line 131
    loglist[i].buffer = (char *)((void *)0);
#line 124
    i ++;
  }
#line 136
  pthread_mutex_init(& _logger_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 141
  _initialized___1 = 1;
#line 142
  return;
}
}
#line 144 "log.c"
int log_open_file(FILE *file ) 
{ int log_id ;

  {
#line 148
  if ((unsigned int )file == (unsigned int )((void *)0)) {
#line 148
    return (-1);
  }
#line 150
  log_id = _get_log_id();
#line 151
  if (log_id < 0) {
#line 151
    return (-2);
  }
#line 153
  loglist[log_id].logfile = file;
#line 154
  loglist[log_id].filename = (char *)((void *)0);
#line 155
  loglist[log_id].size = 0L;
#line 157
  return (log_id);
}
}
#line 161 "log.c"
int log_open(char const   *filename ) 
{ int id ;
  FILE *file ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  struct stat st ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 166
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 166
    return (-1);
  }
#line 167
  if (0) {
#line 167
    __s1_len = strlen(filename);
#line 167
    __s2_len = strlen("");
#line 167
    if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
           1U)) {
      goto _L___0;
    } else {
#line 167
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 167
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
               1U)) {
#line 167
          tmp___8 = 1;
        } else {
#line 167
          if (__s2_len >= 4U) {
#line 167
            tmp___8 = 1;
          } else {
#line 167
            tmp___8 = 0;
          }
        }
      } else {
#line 167
        tmp___8 = 0;
      }
    }
#line 167
    if (tmp___8) {
#line 167
      tmp___4 = __builtin_strcmp(filename, "");
    } else {
#line 167
      tmp___7 = __builtin_strcmp(filename, "");
#line 167
      tmp___4 = tmp___7;
    }
  } else {
#line 167
    tmp___7 = __builtin_strcmp(filename, "");
#line 167
    tmp___4 = tmp___7;
  }
#line 167
  if (tmp___4 == 0) {
#line 167
    return (-1);
  }
#line 169
  file = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 171
  id = log_open_file(file);
#line 173
  if (id >= 0) {
#line 177
    setvbuf((FILE * __restrict  )loglist[id].logfile, (char * __restrict  )((void *)0),
            1, 0U);
#line 178
    tmp___18 = __strdup(filename);
#line 178
    loglist[id].filename = tmp___18;
#line 179
    tmp___19 = stat__extinline((char const   *)loglist[id].filename, & st);
#line 179
    if (tmp___19 == 0) {
#line 180
      loglist[id].size = st.st_size;
    }
  }
#line 183
  return (id);
}
}
#line 188 "log.c"
void log_set_trigger(int id , unsigned int trigger ) 
{ 

  {
#line 190
  if (id >= 0) {
#line 190
    if (id < 25) {
#line 190
      if (loglist[id].in_use) {
#line 192
        loglist[id].trigger_level = (long )(trigger * 1024U);
      }
    }
  }
#line 194
  return;
}
}
#line 197 "log.c"
int log_set_filename(int id , char const   *filename ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___18 ;

  {
#line 199
  if (id < 0) {
#line 200
    return (-1);
  } else {
#line 199
    if (id >= 25) {
#line 200
      return (-1);
    }
  }
#line 201
  if (0) {
#line 201
    __s1_len = strlen(filename);
#line 201
    __s2_len = strlen("");
#line 201
    if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
           1U)) {
      goto _L___0;
    } else {
#line 201
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 201
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
               1U)) {
#line 201
          tmp___8 = 1;
        } else {
#line 201
          if (__s2_len >= 4U) {
#line 201
            tmp___8 = 1;
          } else {
#line 201
            tmp___8 = 0;
          }
        }
      } else {
#line 201
        tmp___8 = 0;
      }
    }
#line 201
    if (tmp___8) {
#line 201
      tmp___4 = __builtin_strcmp(filename, "");
    } else {
#line 201
      tmp___7 = __builtin_strcmp(filename, "");
#line 201
      tmp___4 = tmp___7;
    }
  } else {
#line 201
    tmp___7 = __builtin_strcmp(filename, "");
#line 201
    tmp___4 = tmp___7;
  }
#line 201
  if (tmp___4) {
#line 201
    if (loglist[id].in_use == 0) {
#line 202
      return (-1);
    }
  } else {
#line 202
    return (-1);
  }
#line 203
  _lock_logger();
#line 204
  if (loglist[id].filename) {
#line 205
    free((void *)loglist[id].filename);
  }
#line 206
  if (filename) {
#line 207
    tmp___18 = __strdup(filename);
#line 207
    loglist[id].filename = tmp___18;
  } else {
#line 209
    loglist[id].filename = (char *)((void *)0);
  }
#line 210
  _unlock_logger();
#line 211
  return (id);
}
}
#line 214 "log.c"
int log_set_archive_timestamp(int id , int value ) 
{ 

  {
#line 216
  if (id < 0) {
#line 217
    return (-1);
  } else {
#line 216
    if (id >= 25) {
#line 217
      return (-1);
    }
  }
#line 218
  _lock_logger();
#line 219
  loglist[id].archive_timestamp = value;
#line 220
  _unlock_logger();
#line 221
  return (id);
}
}
#line 225 "log.c"
int log_open_with_buffer(char const   *filename , int size ) 
{ 

  {
#line 228
  return (-5);
}
}
#line 232 "log.c"
void log_set_level(int log_id , unsigned int level ) 
{ 

  {
#line 234
  if (log_id < 0) {
#line 234
    return;
  } else {
#line 234
    if (log_id >= 25) {
#line 234
      return;
    }
  }
#line 235
  if (loglist[log_id].in_use == 0) {
#line 235
    return;
  }
#line 237
  loglist[log_id].level = level;
#line 238
  return;
}
}
#line 240 "log.c"
void log_flush(int log_id ) 
{ 

  {
#line 242
  if (log_id < 0) {
#line 242
    return;
  } else {
#line 242
    if (log_id >= 25) {
#line 242
      return;
    }
  }
#line 243
  if (loglist[log_id].in_use == 0) {
#line 243
    return;
  }
#line 245
  _lock_logger();
#line 246
  if (loglist[log_id].logfile) {
#line 247
    fflush(loglist[log_id].logfile);
  }
#line 248
  _unlock_logger();
#line 249
  return;
}
}
#line 251 "log.c"
void log_reopen(int log_id ) 
{ 

  {
#line 253
  if (log_id < 0) {
#line 253
    if (log_id >= 25) {
#line 254
      return;
    }
  }
#line 255
  if (loglist[log_id].filename) {
#line 255
    if (loglist[log_id].logfile) {
#line 257
      _lock_logger();
#line 259
      fclose(loglist[log_id].logfile);
#line 260
      loglist[log_id].logfile = (FILE *)((void *)0);
#line 262
      _unlock_logger();
    }
  }
#line 264
  return;
}
}
#line 266 "log.c"
void log_close(int log_id ) 
{ 

  {
#line 268
  if (log_id < 0) {
#line 268
    return;
  } else {
#line 268
    if (log_id >= 25) {
#line 268
      return;
    }
  }
#line 270
  _lock_logger();
#line 272
  if (loglist[log_id].in_use == 0) {
#line 274
    _unlock_logger();
#line 275
    return;
  }
#line 278
  loglist[log_id].in_use = 0;
#line 279
  loglist[log_id].level = 2U;
#line 280
  if (loglist[log_id].filename) {
#line 280
    free((void *)loglist[log_id].filename);
  }
#line 281
  if (loglist[log_id].buffer) {
#line 281
    free((void *)loglist[log_id].buffer);
  }
#line 283
  if (loglist[log_id].logfile) {
#line 285
    fclose(loglist[log_id].logfile);
#line 286
    loglist[log_id].logfile = (FILE *)((void *)0);
  }
#line 288
  _unlock_logger();
#line 289
  return;
}
}
#line 291 "log.c"
void log_shutdown(void) 
{ 

  {
#line 295
  pthread_mutex_destroy(& _logger_mutex);
#line 300
  _initialized___1 = 0;
#line 301
  return;
}
}
#line 306 "log.c"
static char *prior[4]  = {      (char *)"EROR",      (char *)"WARN",      (char *)"INFO",      (char *)"DBUG"};
#line 303 "log.c"
void log_write(int log_id , unsigned int priority , char const   *cat , char const   *func ,
               char const   *fmt  , ...) 
{ char tyme[128] ;
  char filename_tyme[128] ;
  char pre[256] ;
  char line[1024] ;
  time_t now___0 ;
  va_list ap ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  int len ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 314
  if (log_id < 0) {
#line 314
    return;
  }
#line 315
  if (log_id > 25) {
#line 315
    return;
  }
#line 316
  if (loglist[log_id].level < priority) {
#line 316
    return;
  }
#line 317
  if (priority > sizeof(prior) / sizeof(prior[0])) {
#line 317
    return;
  }
#line 319
  __builtin_va_start(ap, fmt);
#line 320
  vsnprintf((char * __restrict  )(line), 1024U, (char const   * __restrict  )fmt,
            ap);
#line 322
  now___0 = time((time_t *)((void *)0));
#line 324
  _lock_logger();
#line 325
  tmp = localtime((time_t const   *)(& now___0));
#line 325
  strftime((char * __restrict  )(tyme), sizeof(tyme), (char const   * __restrict  )"[%Y-%m-%d  %H:%M:%S]",
           (struct tm  const  * __restrict  )tmp);
#line 326
  tmp___0 = localtime((time_t const   *)(& now___0));
#line 326
  strftime((char * __restrict  )(filename_tyme), sizeof(filename_tyme), (char const   * __restrict  )"%Y%m%d_%H%M%S",
           (struct tm  const  * __restrict  )tmp___0);
#line 328
  snprintf((char * __restrict  )(pre), sizeof(pre), (char const   * __restrict  )"%s %s%s",
           prior[priority - 1U], cat, func);
#line 330
  tmp___2 = _log_open(log_id, (char const   *)(filename_tyme));
#line 330
  if (tmp___2) {
#line 332
    tmp___1 = fprintf((FILE * __restrict  )loglist[log_id].logfile, (char const   * __restrict  )"%s %s %s\n",
                      tyme, pre, line);
#line 332
    len = tmp___1;
#line 333
    if (len > 0) {
#line 334
      loglist[log_id].size += (off_t )len;
    }
  }
#line 336
  _unlock_logger();
#line 338
  __builtin_va_end(ap);
#line 339
  return;
}
}
#line 341 "log.c"
void log_write_direct(int log_id , char const   *fmt  , ...) 
{ char line[1024] ;
  va_list ap ;
  char filename_tyme[128] ;
  time_t now___0 ;
  struct tm *tmp ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 348
  if (log_id < 0) {
#line 348
    return;
  }
#line 350
  __builtin_va_start(ap, fmt);
#line 352
  now___0 = time((time_t *)((void *)0));
#line 354
  _lock_logger();
#line 355
  vsnprintf((char * __restrict  )(line), 1024U, (char const   * __restrict  )fmt,
            ap);
#line 356
  tmp = localtime((time_t const   *)(& now___0));
#line 356
  strftime((char * __restrict  )(filename_tyme), sizeof(filename_tyme), (char const   * __restrict  )"%Y%m%d_%H%M%S",
           (struct tm  const  * __restrict  )tmp);
#line 357
  tmp___1 = _log_open(log_id, (char const   *)(filename_tyme));
#line 357
  if (tmp___1) {
#line 359
    tmp___0 = fprintf((FILE * __restrict  )loglist[log_id].logfile, (char const   * __restrict  )"%s\n",
                      line);
#line 359
    len = tmp___0;
#line 360
    if (len > 0) {
#line 361
      loglist[log_id].size += (off_t )len;
    }
  }
#line 363
  _unlock_logger();
#line 365
  __builtin_va_end(ap);
#line 367
  fflush(loglist[log_id].logfile);
#line 368
  return;
}
}
#line 370 "log.c"
static int _get_log_id(void) 
{ int i ;
  int id ;

  {
#line 373
  id = -1;
#line 376
  _lock_logger();
#line 378
  i = 0;
#line 378
  while (i < 25) {
#line 379
    if (loglist[i].in_use == 0) {
#line 380
      loglist[i].in_use = 1;
#line 381
      id = i;
#line 382
      break;
    }
#line 378
    i ++;
  }
#line 386
  _unlock_logger();
#line 388
  return (id);
}
}
#line 402 "log.c"
static void _lock_logger(void) 
{ 

  {
#line 405
  pthread_mutex_lock(& _logger_mutex);
#line 409
  return;
}
}
#line 411 "log.c"
static void _unlock_logger(void) 
{ 

  {
#line 414
  pthread_mutex_unlock(& _logger_mutex);
#line 418
  return;
}
}
#line 1 "cil-spDwBiCF.o"
#pragma merger(0,"/tmp/cil-gyo3qRqS.i","")
#line 1 "./src/main.o_saved.c"
#pragma merger(0,"./main.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 154
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 329
extern int printf(char const   * __restrict  __format  , ...) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 551 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 620
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 662
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 701
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 862
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 810 "/usr/include/libxml2/libxml/parser.h"
extern void xmlCleanupParser(void) ;
#line 43 "connection.h"
void connection_initialize(void) ;
#line 44
void connection_shutdown(void) ;
#line 45
void connection_accept_loop(void) ;
#line 32 "refbuf.h"
void refbuf_initialize(void) ;
#line 33
void refbuf_shutdown(void) ;
#line 80 "auth.h"
void auth_initialise(void) ;
#line 81
void auth_shutdown(void) ;
#line 35 "slave.h"
void slave_initialize(void) ;
#line 36
void slave_shutdown(void) ;
#line 48 "global.h"
ice_global_t global ;
#line 50
void global_initialize(void) ;
#line 51
void global_shutdown(void) ;
#line 176 "cfgfile.h"
void config_initialize(void) ;
#line 177
void config_shutdown(void) ;
#line 180
int config_initial_parse_file(char const   *filename ) ;
#line 181
int config_parse_cmdline(int arg , char **argv ) ;
#line 190
ice_config_t *config_get_config(void) ;
#line 192
void config_release_config(void) ;
#line 195
ice_config_t *config_get_config_unlocked(void) ;
#line 18 "sighandler.h"
void sighandler_initialize(void) ;
#line 73 "stats.h"
void stats_initialize(void) ;
#line 74
void stats_shutdown(void) ;
#line 21 "logging.h"
int errorlog ;
#line 22
int accesslog ;
#line 23
int playlistlog ;
#line 38 "xslt.h"
void xslt_initialize(void) ;
#line 39
void xslt_shutdown(void) ;
#line 31 "fserve.h"
void fserve_initialize(void) ;
#line 32
void fserve_shutdown(void) ;
#line 35 "yp.h"
void yp_initialize(void) ;
#line 36
void yp_shutdown(void) ;
#line 66 "main.c"
static int background  ;
#line 67 "main.c"
static char *pidfile  =    (char *)((void *)0);
#line 69 "main.c"
static void _fatal_error(char *perr ) 
{ 

  {
#line 74
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s\n", perr);
#line 76
  return;
}
}
#line 78 "main.c"
static void _print_usage(void) 
{ 

  {
#line 80
  printf((char const   * __restrict  )"Icecast 2.3.1\n\n");
#line 81
  printf((char const   * __restrict  )"usage: icecast [-b -v] -c <file>\n");
#line 82
  printf((char const   * __restrict  )"options:\n");
#line 83
  printf((char const   * __restrict  )"\t-c <file>\tSpecify configuration file\n");
#line 84
  printf((char const   * __restrict  )"\t-v\t\tDisplay version info\n");
#line 85
  printf((char const   * __restrict  )"\t-b\t\tRun icecast in the background\n");
#line 86
  printf((char const   * __restrict  )"\n");
#line 87
  return;
}
}
#line 89 "main.c"
static void _stop_logging(void) 
{ 

  {
#line 91
  log_close(errorlog);
#line 92
  log_close(accesslog);
#line 93
  log_close(playlistlog);
#line 94
  return;
}
}
#line 96 "main.c"
static void _initialize_subsystems(void) 
{ 

  {
#line 98
  log_initialize();
#line 99
  thread_initialize();
#line 100
  sock_initialize();
#line 101
  resolver_initialize();
#line 102
  config_initialize();
#line 103
  connection_initialize();
#line 104
  global_initialize();
#line 105
  refbuf_initialize();
#line 106
  xslt_initialize();
#line 107
  return;
}
}
#line 109 "main.c"
static void _shutdown_subsystems(void) 
{ 

  {
#line 111
  fserve_shutdown();
#line 112
  xslt_shutdown();
#line 113
  refbuf_shutdown();
#line 114
  slave_shutdown();
#line 115
  auth_shutdown();
#line 116
  yp_shutdown();
#line 117
  stats_shutdown();
#line 119
  global_shutdown();
#line 120
  connection_shutdown();
#line 121
  config_shutdown();
#line 122
  resolver_shutdown();
#line 123
  sock_shutdown();
#line 124
  thread_shutdown();
#line 127
  _stop_logging();
#line 128
  log_shutdown();
#line 130
  xmlCleanupParser();
#line 131
  return;
}
}
#line 133 "main.c"
static int _parse_config_opts(int argc , char **argv , char *filename , int size ) 
{ int i ;
  int config_ok ;
  pid_t pid ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 135
  i = 1;
#line 136
  config_ok = 0;
#line 138
  background = 0;
#line 139
  if (argc < 2) {
#line 139
    return (-1);
  }
#line 141
  while (i < argc) {
#line 142
    if (0) {
#line 142
      __s1_len = strlen((char const   *)(*(argv + i)));
#line 142
      __s2_len = strlen("-b");
#line 142
      if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       i))) ==
             1U)) {
        goto _L___0;
      } else {
#line 142
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 142
          if (! ((unsigned int )((void const   *)("-b" + 1)) - (unsigned int )((void const   *)"-b") ==
                 1U)) {
#line 142
            tmp___8 = 1;
          } else {
#line 142
            if (__s2_len >= 4U) {
#line 142
              tmp___8 = 1;
            } else {
#line 142
              tmp___8 = 0;
            }
          }
        } else {
#line 142
          tmp___8 = 0;
        }
      }
#line 142
      if (tmp___8) {
#line 142
        tmp___4 = __builtin_strcmp((char const   *)(*(argv + i)), "-b");
      } else {
#line 142
        tmp___7 = __builtin_strcmp((char const   *)(*(argv + i)), "-b");
#line 142
        tmp___4 = tmp___7;
      }
    } else {
#line 142
      tmp___7 = __builtin_strcmp((char const   *)(*(argv + i)), "-b");
#line 142
      tmp___4 = tmp___7;
    }
#line 142
    if (tmp___4 == 0) {
#line 145
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Starting icecast2\nDetaching from the console\n");
#line 147
      pid = fork();
#line 149
      if (pid > 0) {
#line 151
        exit(0);
      } else {
#line 153
        if (pid < 0) {
#line 154
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FATAL: Unable to fork child!");
#line 155
          exit(1);
        }
      }
#line 157
      background = 1;
    }
#line 160
    if (0) {
#line 160
      __s1_len___0 = strlen((char const   *)(*(argv + i)));
#line 160
      __s2_len___0 = strlen("-v");
#line 160
      if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       i))) ==
             1U)) {
        goto _L___2;
      } else {
#line 160
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 160
          if (! ((unsigned int )((void const   *)("-v" + 1)) - (unsigned int )((void const   *)"-v") ==
                 1U)) {
#line 160
            tmp___18 = 1;
          } else {
#line 160
            if (__s2_len___0 >= 4U) {
#line 160
              tmp___18 = 1;
            } else {
#line 160
              tmp___18 = 0;
            }
          }
        } else {
#line 160
          tmp___18 = 0;
        }
      }
#line 160
      if (tmp___18) {
#line 160
        tmp___14 = __builtin_strcmp((char const   *)(*(argv + i)), "-v");
      } else {
#line 160
        tmp___17 = __builtin_strcmp((char const   *)(*(argv + i)), "-v");
#line 160
        tmp___14 = tmp___17;
      }
    } else {
#line 160
      tmp___17 = __builtin_strcmp((char const   *)(*(argv + i)), "-v");
#line 160
      tmp___14 = tmp___17;
    }
#line 160
    if (tmp___14 == 0) {
#line 161
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s\n", "Icecast 2.3.1");
#line 162
      exit(0);
    }
#line 165
    if (0) {
#line 165
      __s1_len___1 = strlen((char const   *)(*(argv + i)));
#line 165
      __s2_len___1 = strlen("-c");
#line 165
      if (! ((unsigned int )((void const   *)((*(argv + i)) + 1)) - (unsigned int )((void const   *)(*(argv +
                                                                                                       i))) ==
             1U)) {
        goto _L___4;
      } else {
#line 165
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 165
          if (! ((unsigned int )((void const   *)("-c" + 1)) - (unsigned int )((void const   *)"-c") ==
                 1U)) {
#line 165
            tmp___28 = 1;
          } else {
#line 165
            if (__s2_len___1 >= 4U) {
#line 165
              tmp___28 = 1;
            } else {
#line 165
              tmp___28 = 0;
            }
          }
        } else {
#line 165
          tmp___28 = 0;
        }
      }
#line 165
      if (tmp___28) {
#line 165
        tmp___24 = __builtin_strcmp((char const   *)(*(argv + i)), "-c");
      } else {
#line 165
        tmp___27 = __builtin_strcmp((char const   *)(*(argv + i)), "-c");
#line 165
        tmp___24 = tmp___27;
      }
    } else {
#line 165
      tmp___27 = __builtin_strcmp((char const   *)(*(argv + i)), "-c");
#line 165
      tmp___24 = tmp___27;
    }
#line 165
    if (tmp___24 == 0) {
#line 166
      if (i + 1 < argc) {
#line 167
        __builtin_strncpy(filename, (char const   *)(*(argv + (i + 1))), (unsigned int )(size -
                                                                                         1));
#line 168
        (*(filename + (size - 1))) = (char)0;
#line 169
        config_ok = 1;
      } else {
#line 171
        return (-1);
      }
    }
#line 174
    i ++;
  }
#line 177
  if (config_ok) {
#line 178
    return (1);
  } else {
#line 180
    return (-1);
  }
}
}
#line 183 "main.c"
static int _start_logging(void) 
{ char fn_error[4096] ;
  char fn_access[4096] ;
  char fn_playlist[4096] ;
  char buf[1024] ;
  int log_to_stderr ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;

  {
#line 191
  tmp = config_get_config_unlocked();
#line 191
  config = tmp;
#line 193
  if (0) {
#line 193
    __s1_len = strlen((char const   *)config->error_log);
#line 193
    __s2_len = strlen("-");
#line 193
    if (! ((unsigned int )((void const   *)(config->error_log + 1)) - (unsigned int )((void const   *)config->error_log) ==
           1U)) {
      goto _L___0;
    } else {
#line 193
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 193
        if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
               1U)) {
#line 193
          tmp___9 = 1;
        } else {
#line 193
          if (__s2_len >= 4U) {
#line 193
            tmp___9 = 1;
          } else {
#line 193
            tmp___9 = 0;
          }
        }
      } else {
#line 193
        tmp___9 = 0;
      }
    }
#line 193
    if (tmp___9) {
#line 193
      tmp___5 = __builtin_strcmp((char const   *)config->error_log, "-");
    } else {
#line 193
      tmp___8 = __builtin_strcmp((char const   *)config->error_log, "-");
#line 193
      tmp___5 = tmp___8;
    }
  } else {
#line 193
    tmp___8 = __builtin_strcmp((char const   *)config->error_log, "-");
#line 193
    tmp___5 = tmp___8;
  }
#line 193
  if (tmp___5) {
#line 194
    snprintf((char * __restrict  )(fn_error), 4096U, (char const   * __restrict  )"%s%s%s",
             config->log_dir, "/", config->error_log);
#line 195
    errorlog = log_open((char const   *)(fn_error));
#line 196
    log_to_stderr = 0;
#line 197
    if (config->logsize) {
#line 198
      log_set_trigger(errorlog, (unsigned int )config->logsize);
    }
#line 199
    log_set_archive_timestamp(errorlog, config->logarchive);
  } else {
#line 201
    errorlog = log_open_file(stderr);
#line 202
    log_to_stderr = 1;
  }
#line 205
  if (errorlog < 0) {
#line 206
    buf[sizeof(buf) - 1U] = (char)0;
#line 207
    tmp___10 = __errno_location();
#line 207
    tmp___11 = strerror((*tmp___10));
#line 207
    if (log_to_stderr) {
#line 207
      tmp___12 = "standard error";
    } else {
#line 207
      tmp___12 = (char const   *)(fn_error);
    }
#line 207
    snprintf((char * __restrict  )(buf), sizeof(buf) - 1U, (char const   * __restrict  )"FATAL: could not open error logging (%s): %s",
             tmp___12, tmp___11);
#line 211
    _fatal_error(buf);
  }
#line 213
  log_set_level(errorlog, (unsigned int )config->loglevel);
#line 215
  if (0) {
#line 215
    __s1_len___0 = strlen((char const   *)config->access_log);
#line 215
    __s2_len___0 = strlen("-");
#line 215
    if (! ((unsigned int )((void const   *)(config->access_log + 1)) - (unsigned int )((void const   *)config->access_log) ==
           1U)) {
      goto _L___2;
    } else {
#line 215
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 215
        if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
               1U)) {
#line 215
          tmp___22 = 1;
        } else {
#line 215
          if (__s2_len___0 >= 4U) {
#line 215
            tmp___22 = 1;
          } else {
#line 215
            tmp___22 = 0;
          }
        }
      } else {
#line 215
        tmp___22 = 0;
      }
    }
#line 215
    if (tmp___22) {
#line 215
      tmp___18 = __builtin_strcmp((char const   *)config->access_log, "-");
    } else {
#line 215
      tmp___21 = __builtin_strcmp((char const   *)config->access_log, "-");
#line 215
      tmp___18 = tmp___21;
    }
  } else {
#line 215
    tmp___21 = __builtin_strcmp((char const   *)config->access_log, "-");
#line 215
    tmp___18 = tmp___21;
  }
#line 215
  if (tmp___18) {
#line 216
    snprintf((char * __restrict  )(fn_access), 4096U, (char const   * __restrict  )"%s%s%s",
             config->log_dir, "/", config->access_log);
#line 217
    accesslog = log_open((char const   *)(fn_access));
#line 218
    log_to_stderr = 0;
#line 219
    if (config->logsize) {
#line 220
      log_set_trigger(accesslog, (unsigned int )config->logsize);
    }
#line 221
    log_set_archive_timestamp(accesslog, config->logarchive);
  } else {
#line 223
    accesslog = log_open_file(stderr);
#line 224
    log_to_stderr = 1;
  }
#line 227
  if (accesslog < 0) {
#line 228
    buf[sizeof(buf) - 1U] = (char)0;
#line 229
    tmp___23 = __errno_location();
#line 229
    tmp___24 = strerror((*tmp___23));
#line 229
    if (log_to_stderr) {
#line 229
      tmp___25 = "standard error";
    } else {
#line 229
      tmp___25 = (char const   *)(fn_access);
    }
#line 229
    snprintf((char * __restrict  )(buf), sizeof(buf) - 1U, (char const   * __restrict  )"FATAL: could not open access logging (%s): %s",
             tmp___25, tmp___24);
#line 233
    _fatal_error(buf);
  }
#line 236
  if (config->playlist_log) {
#line 237
    snprintf((char * __restrict  )(fn_playlist), 4096U, (char const   * __restrict  )"%s%s%s",
             config->log_dir, "/", config->playlist_log);
#line 238
    playlistlog = log_open((char const   *)(fn_playlist));
#line 239
    if (playlistlog < 0) {
#line 240
      buf[sizeof(buf) - 1U] = (char)0;
#line 241
      tmp___26 = __errno_location();
#line 241
      tmp___27 = strerror((*tmp___26));
#line 241
      if (log_to_stderr) {
#line 241
        tmp___28 = "standard error";
      } else {
#line 241
        tmp___28 = (char const   *)(fn_playlist);
      }
#line 241
      snprintf((char * __restrict  )(buf), sizeof(buf) - 1U, (char const   * __restrict  )"FATAL: could not open playlist logging (%s): %s",
               tmp___28, tmp___27);
#line 245
      _fatal_error(buf);
    }
#line 247
    log_to_stderr = 0;
#line 248
    if (config->logsize) {
#line 249
      log_set_trigger(playlistlog, (unsigned int )config->logsize);
    }
#line 250
    log_set_archive_timestamp(playlistlog, config->logarchive);
  } else {
#line 252
    playlistlog = -1;
  }
#line 255
  log_set_level(errorlog, (unsigned int )config->loglevel);
#line 256
  log_set_level(accesslog, 4U);
#line 257
  log_set_level(playlistlog, 4U);
#line 259
  if (errorlog >= 0) {
#line 259
    if (accesslog >= 0) {
#line 259
      return (1);
    }
  }
#line 261
  return (0);
}
}
#line 264 "main.c"
static int _setup_sockets(void) 
{ ice_config_t *config ;
  int i ;
  int ret ;
  int successful ;
  char pbuf[1024] ;

  {
#line 267
  i = 0;
#line 268
  ret = 0;
#line 269
  successful = 0;
#line 272
  config = config_get_config_unlocked();
#line 274
  i = 0;
#line 274
  while (i < 20) {
#line 275
    if (config->listeners[i].port <= 0) {
#line 276
      break;
    }
#line 278
    global.serversock[i] = sock_get_server_socket(config->listeners[i].port, config->listeners[i].bind_address);
#line 281
    if (global.serversock[i] == -1) {
#line 282
      memset((void *)(pbuf), '\000', sizeof(pbuf));
#line 283
      snprintf((char * __restrict  )(pbuf), sizeof(pbuf) - 1U, (char const   * __restrict  )"Could not create listener socket on port %d",
               config->listeners[i].port);
#line 286
      _fatal_error(pbuf);
#line 287
      return (0);
    } else {
#line 290
      ret = 1;
#line 291
      successful ++;
    }
#line 274
    i ++;
  }
#line 295
  global.server_sockets = successful;
#line 297
  return (ret);
}
}
#line 300 "main.c"
static int _start_listening(void) 
{ int i ;
  int tmp ;

  {
#line 303
  i = 0;
#line 303
  while (i < global.server_sockets) {
#line 304
    tmp = sock_listen(global.serversock[i], 5);
#line 304
    if (tmp == -1) {
#line 305
      return (0);
    }
#line 307
    sock_set_blocking(global.serversock[i], 1);
#line 303
    i ++;
  }
#line 310
  return (1);
}
}
#line 314 "main.c"
static int _server_proc_init(void) 
{ ice_config_t *config ;
  int tmp ;
  int tmp___0 ;
  FILE *f ;
  char *tmp___10 ;
  __pid_t tmp___11 ;

  {
#line 318
  tmp = _setup_sockets();
#line 318
  if (! tmp) {
#line 319
    return (0);
  }
#line 321
  tmp___0 = _start_listening();
#line 321
  if (! tmp___0) {
#line 322
    _fatal_error((char *)"Failed trying to listen on server socket");
#line 323
    return (0);
  }
#line 326
  config = config_get_config_unlocked();
#line 328
  if (config->pidfile) {
#line 331
    tmp___10 = __strdup((char const   *)config->pidfile);
#line 331
    pidfile = tmp___10;
#line 332
    if (pidfile) {
#line 332
      f = fopen((char const   * __restrict  )config->pidfile, (char const   * __restrict  )"w");
#line 332
      if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 334
        tmp___11 = getpid();
#line 334
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%d\n", tmp___11);
#line 335
        fclose(f);
      }
    }
  }
#line 339
  return (1);
}
}
#line 343 "main.c"
static void _server_proc(void) 
{ int i ;

  {
#line 347
  if (background) {
#line 349
    fclose(stdin);
#line 350
    fclose(stdout);
#line 351
    fclose(stderr);
  }
#line 353
  connection_accept_loop();
#line 355
  i = 0;
#line 355
  while (i < 20) {
#line 356
    sock_close(global.serversock[i]);
#line 355
    i ++;
  }
#line 357
  return;
}
}
#line 362 "main.c"
static void _ch_root_uid_setup(void) 
{ ice_config_t *conf ;
  ice_config_t *tmp ;
  struct passwd *user ;
  struct group *group ;
  uid_t uid ;
  gid_t gid ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 364
  tmp = config_get_config_unlocked();
#line 364
  conf = tmp;
#line 368
  uid = (uid_t )-1;
#line 369
  gid = (gid_t )-1;
#line 371
  if (conf->chuid) {
#line 373
    if (conf->user) {
#line 374
      user = getpwnam((char const   *)conf->user);
#line 375
      if (user) {
#line 376
        uid = user->pw_uid;
      } else {
#line 378
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t find user \"%s\" in password file\n",
                conf->user);
      }
    }
#line 380
    if (conf->group) {
#line 381
      group = getgrnam((char const   *)conf->group);
#line 383
      if (group) {
#line 384
        gid = group->gr_gid;
      } else {
#line 386
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t find group \"%s\" in groups file\n",
                conf->group);
      }
    }
  }
#line 392
  if (conf->chroot) {
#line 394
    tmp___0 = getuid();
#line 394
    if (tmp___0) {
#line 396
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Cannot change server root unless running as root.\n");
#line 397
      return;
    }
#line 399
    tmp___3 = chroot((char const   *)conf->base_dir);
#line 399
    if (tmp___3) {
#line 401
      tmp___1 = __errno_location();
#line 401
      tmp___2 = strerror((*tmp___1));
#line 401
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Couldn\'t change server root: %s\n",
              tmp___2);
#line 402
      return;
    } else {
#line 405
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Changed root successfully to \"%s\".\n",
              conf->base_dir);
    }
  }
#line 411
  if (conf->chuid) {
#line 413
    tmp___4 = getuid();
#line 413
    if (tmp___4) {
#line 415
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Can\'t change user id unless you are root.\n");
#line 416
      return;
    }
#line 419
    if (gid != 4294967295U) {
#line 420
      tmp___7 = setgid(gid);
#line 420
      if (tmp___7) {
#line 423
        tmp___5 = __errno_location();
#line 423
        tmp___6 = strerror((*tmp___5));
#line 423
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Error changing groupid: %s.\n",
                tmp___6);
      } else {
#line 421
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Changed groupid to %i.\n",
                (int )gid);
      }
    }
#line 426
    if (uid != 4294967295U) {
#line 427
      tmp___10 = setuid(uid);
#line 427
      if (tmp___10) {
#line 430
        tmp___8 = __errno_location();
#line 430
        tmp___9 = strerror((*tmp___8));
#line 430
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Error changing userid: %s.\n",
                tmp___9);
      } else {
#line 428
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Changed userid to %i.\n",
                (int )uid);
      }
    }
  }
#line 434
  return;
}
}
#line 439 "main.c"
int main(int argc , char **argv ) 
{ int res ;
  int ret ;
  char filename[512] ;
  char pbuf[1024] ;
  int tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;

  {
#line 449
  res = _parse_config_opts(argc, argv, filename, 512);
#line 450
  if (res == 1) {
#line 452
    _initialize_subsystems();
#line 455
    config_get_config();
#line 456
    ret = config_initial_parse_file((char const   *)(filename));
#line 457
    config_release_config();
#line 458
    if (ret < 0) {
#line 459
      memset((void *)(pbuf), '\000', sizeof(pbuf));
#line 460
      snprintf((char * __restrict  )(pbuf), sizeof(pbuf) - 1U, (char const   * __restrict  )"FATAL: error parsing config file (%s)",
               filename);
#line 462
      _fatal_error(pbuf);
#line 463
      switch (ret) {
      case -1: 
#line 465
      _fatal_error((char *)"filename was null or blank");
#line 466
      break;
      case -2: 
#line 468
      _fatal_error((char *)"no root element found");
#line 469
      break;
      case -3: 
#line 471
      _fatal_error((char *)"root element is not <icecast>");
#line 472
      break;
      default: 
#line 474
      _fatal_error((char *)"XML config parsing error");
#line 475
      break;
      }
#line 477
      _shutdown_subsystems();
#line 478
      return (1);
    }
  } else {
#line 480
    if (res == -1) {
#line 481
      _print_usage();
#line 482
      return (1);
    }
  }
#line 486
  config_parse_cmdline(argc, argv);
#line 489
  tmp = _server_proc_init();
#line 489
  if (! tmp) {
#line 490
    _fatal_error((char *)"Server startup failed. Exiting");
#line 491
    _shutdown_subsystems();
#line 492
    return (1);
  }
#line 495
  _ch_root_uid_setup();
#line 497
  stats_initialize();
#line 498
  fserve_initialize();
#line 503
  tmp___0 = getuid();
#line 503
  if (! tmp___0) {
#line 505
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: You should not run icecast2 as root\n");
#line 506
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Use the changeowner directive in the config file\n");
#line 507
    _shutdown_subsystems();
#line 508
    return (1);
  }
#line 513
  sighandler_initialize();
#line 515
  tmp___1 = _start_logging();
#line 515
  if (! tmp___1) {
#line 516
    _fatal_error((char *)"FATAL: Could not start logging");
#line 517
    _shutdown_subsystems();
#line 518
    return (1);
  }
#line 521
  log_write(errorlog, 3U, "main/", "main", "Icecast 2.3.1 server started");
#line 526
  global.running = 1;
#line 529
  yp_initialize();
#line 532
  slave_initialize();
#line 533
  auth_initialise();
#line 535
  _server_proc();
#line 537
  log_write(errorlog, 3U, "main/", "main", "Shutting down");
#line 539
  _shutdown_subsystems();
#line 541
  if (pidfile) {
#line 543
    remove((char const   *)pidfile);
#line 544
    free((void *)pidfile);
  }
#line 547
  return (0);
}
}
#line 1 "cil-7qHwrZTV.o"
#pragma merger(0,"/tmp/cil-0RUkoSXZ.i","")
#line 1 "./src/global.o_saved.c"
#pragma merger(0,"./global.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 48 "global.h"
ice_global_t global  ;
#line 52
void global_lock(void) ;
#line 53
void global_unlock(void) ;
#line 88 "source.h"
int source_compare_sources(void *arg , void *a , void *b ) ;
#line 34 "global.c"
static mutex_t _global_mutex  ;
#line 36 "global.c"
void global_initialize(void) 
{ 

  {
#line 38
  memset((void *)(global.serversock), 0, sizeof(int ) * 20U);
#line 39
  global.server_sockets = 0;
#line 40
  global.relays = (struct _relay_server *)((void *)0);
#line 41
  global.master_relays = (struct _relay_server *)((void *)0);
#line 42
  global.running = 0;
#line 43
  global.clients = 0;
#line 44
  global.sources = 0;
#line 45
  global.source_tree = avl_tree_new(& source_compare_sources, (void *)0);
#line 46
  thread_mutex_create_c(& _global_mutex, 46, (char *)"global.c");
#line 47
  return;
}
}
#line 49 "global.c"
void global_shutdown(void) 
{ 

  {
#line 51
  thread_mutex_destroy(& _global_mutex);
#line 52
  avl_tree_free(global.source_tree, (int (*)(void *key ))((void *)0));
#line 53
  return;
}
}
#line 55 "global.c"
void global_lock(void) 
{ 

  {
#line 57
  thread_mutex_lock_c(& _global_mutex, 57, (char *)"global.c");
#line 58
  return;
}
}
#line 60 "global.c"
void global_unlock(void) 
{ 

  {
#line 62
  thread_mutex_unlock_c(& _global_mutex, 62, (char *)"global.c");
#line 63
  return;
}
}
#line 1 "cil-YDi1DrMm.o"
#pragma merger(0,"/tmp/cil-cwLpPebt.i","")
#line 1 "./src/util.o_saved.c"
#pragma merger(0,"./util.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 598 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 48 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 22 "util.h"
int util_timed_wait_for_fd(int fd , int timeout ) ;
#line 23
int util_read_header(int sock , char *buff , unsigned long len , int entire ) ;
#line 24
int util_check_valid_extension(char *uri ) ;
#line 25
char *util_get_extension(char const   *path ) ;
#line 26
char *util_get_path_from_uri(char *uri ) ;
#line 27
char *util_get_path_from_normalised_uri(char const   *uri ) ;
#line 28
char *util_normalise_uri(char *uri ) ;
#line 29
char *util_base64_encode(char *data ) ;
#line 30
char *util_base64_decode(unsigned char *input ) ;
#line 31
char *util_bin_to_hex(unsigned char *data , int len ) ;
#line 33
char *util_url_unescape(char *src ) ;
#line 34
char *util_url_escape(char *src ) ;
#line 44
util_dict *util_dict_new(void) ;
#line 45
void util_dict_free(util_dict *dict ) ;
#line 47
int util_dict_set(util_dict *dict , char const   *key , char const   *val ) ;
#line 48
char const   *util_dict_get(util_dict *dict , char const   *key ) ;
#line 49
char *util_dict_urlencode(util_dict *dict , char delim ) ;
#line 61 "util.c"
int util_timed_wait_for_fd(int fd , int timeout ) 
{ struct pollfd ufds___0 ;
  int tmp ;

  {
#line 66
  ufds___0.fd = fd;
#line 67
  ufds___0.events = (short)1;
#line 68
  ufds___0.revents = (short)0;
#line 70
  tmp = poll(& ufds___0, 1UL, timeout);
#line 70
  return (tmp);
}
}
#line 87 "util.c"
int util_read_header(int sock , char *buff , unsigned long len , int entire ) 
{ int read_bytes ;
  int ret ;
  unsigned long pos ;
  char c ;
  ice_config_t *config ;
  int header_timeout ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 95
  config = config_get_config();
#line 96
  header_timeout = config->header_timeout;
#line 97
  config_release_config();
#line 99
  read_bytes = 1;
#line 100
  pos = 0UL;
#line 101
  ret = 0;
#line 103
  while (1) {
#line 103
    if (read_bytes == 1) {
#line 103
      if (! (pos < len - 1UL)) {
#line 103
        break;
      }
    } else {
#line 103
      break;
    }
#line 104
    read_bytes = 0;
#line 106
    tmp___0 = util_timed_wait_for_fd(sock, header_timeout * 1000);
#line 106
    if (tmp___0 > 0) {
#line 108
      read_bytes = recv(sock, (void *)(& c), 1U, 0);
#line 108
      if (read_bytes) {
#line 109
        if ((int )c != 13) {
#line 109
          tmp = pos;
#line 109
          pos ++;
#line 109
          (*(buff + tmp)) = c;
        }
#line 110
        if (entire) {
#line 111
          if (pos > 1UL) {
#line 111
            if ((int )(*(buff + (pos - 1UL))) == 10) {
#line 111
              if ((int )(*(buff + (pos - 2UL))) == 10) {
#line 113
                ret = 1;
#line 114
                break;
              }
            }
          }
        } else {
#line 118
          if (pos > 1UL) {
#line 118
            if ((int )(*(buff + (pos - 1UL))) == 10) {
#line 119
              ret = 1;
#line 120
              break;
            }
          }
        }
      }
    } else {
#line 125
      break;
    }
  }
#line 129
  if (ret) {
#line 129
    (*(buff + pos)) = (char )'\000';
  }
#line 131
  return (ret);
}
}
#line 134 "util.c"
char *util_get_extension(char const   *path ) 
{ char *ext ;
  char *tmp ;

  {
#line 135
  tmp = strrchr(path, '.');
#line 135
  ext = tmp;
#line 137
  if ((unsigned int )ext == (unsigned int )((void *)0)) {
#line 138
    return ((char *)"");
  } else {
#line 140
    return (ext + 1);
  }
}
}
#line 143 "util.c"
int util_check_valid_extension(char *uri ) 
{ int ret ;
  char *p2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___50 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  size_t tmp___61 ;
  int tmp___84 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___90 ;
  int tmp___93 ;
  int tmp___94 ;
  size_t tmp___95 ;

  {
#line 144
  ret = 0;
#line 147
  if (uri) {
#line 148
    p2 = strrchr((char const   *)uri, '.');
#line 149
    if (p2) {
#line 150
      p2 ++;
#line 151
      if (0) {
#line 151
        if (0) {
#line 151
          __s1_len___0 = strlen((char const   *)p2);
#line 151
          __s2_len___0 = strlen("xsl");
#line 151
          if (! ((unsigned int )((void const   *)(p2 + 1)) - (unsigned int )((void const   *)p2) ==
                 1U)) {
            goto _L___2;
          } else {
#line 151
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 151
              if (! ((unsigned int )((void const   *)("xsl" + 1)) - (unsigned int )((void const   *)"xsl") ==
                     1U)) {
#line 151
                tmp___26 = 1;
              } else {
#line 151
                if (__s2_len___0 >= 4U) {
#line 151
                  tmp___26 = 1;
                } else {
#line 151
                  tmp___26 = 0;
                }
              }
            } else {
#line 151
              tmp___26 = 0;
            }
          }
#line 151
          if (tmp___26) {
#line 151
            tmp___22 = __builtin_strcmp((char const   *)p2, "xsl");
          } else {
#line 151
            tmp___25 = __builtin_strcmp((char const   *)p2, "xsl");
#line 151
            tmp___22 = tmp___25;
          }
        } else {
#line 151
          tmp___25 = __builtin_strcmp((char const   *)p2, "xsl");
#line 151
          tmp___22 = tmp___25;
        }
#line 151
        tmp___16 = tmp___22;
      } else {
#line 151
        tmp___27 = strlen("xsl");
#line 151
        tmp___16 = strncmp((char const   *)p2, "xsl", tmp___27);
      }
#line 151
      if (tmp___16 == 0) {
#line 155
        ret = 1;
      }
#line 157
      if (0) {
#line 157
        if (0) {
#line 157
          __s1_len___2 = strlen((char const   *)p2);
#line 157
          __s2_len___2 = strlen("htm");
#line 157
          if (! ((unsigned int )((void const   *)(p2 + 1)) - (unsigned int )((void const   *)p2) ==
                 1U)) {
            goto _L___6;
          } else {
#line 157
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 157
              if (! ((unsigned int )((void const   *)("htm" + 1)) - (unsigned int )((void const   *)"htm") ==
                     1U)) {
#line 157
                tmp___60 = 1;
              } else {
#line 157
                if (__s2_len___2 >= 4U) {
#line 157
                  tmp___60 = 1;
                } else {
#line 157
                  tmp___60 = 0;
                }
              }
            } else {
#line 157
              tmp___60 = 0;
            }
          }
#line 157
          if (tmp___60) {
#line 157
            tmp___56 = __builtin_strcmp((char const   *)p2, "htm");
          } else {
#line 157
            tmp___59 = __builtin_strcmp((char const   *)p2, "htm");
#line 157
            tmp___56 = tmp___59;
          }
        } else {
#line 157
          tmp___59 = __builtin_strcmp((char const   *)p2, "htm");
#line 157
          tmp___56 = tmp___59;
        }
#line 157
        tmp___50 = tmp___56;
      } else {
#line 157
        tmp___61 = strlen("htm");
#line 157
        tmp___50 = strncmp((char const   *)p2, "htm", tmp___61);
      }
#line 157
      if (tmp___50 == 0) {
#line 161
        ret = 2;
      }
#line 163
      if (0) {
#line 163
        if (0) {
#line 163
          __s1_len___4 = strlen((char const   *)p2);
#line 163
          __s2_len___4 = strlen("html");
#line 163
          if (! ((unsigned int )((void const   *)(p2 + 1)) - (unsigned int )((void const   *)p2) ==
                 1U)) {
            goto _L___10;
          } else {
#line 163
            if (__s1_len___4 >= 4U) {
              _L___10: /* CIL Label */ 
#line 163
              if (! ((unsigned int )((void const   *)("html" + 1)) - (unsigned int )((void const   *)"html") ==
                     1U)) {
#line 163
                tmp___94 = 1;
              } else {
#line 163
                if (__s2_len___4 >= 4U) {
#line 163
                  tmp___94 = 1;
                } else {
#line 163
                  tmp___94 = 0;
                }
              }
            } else {
#line 163
              tmp___94 = 0;
            }
          }
#line 163
          if (tmp___94) {
#line 163
            tmp___90 = __builtin_strcmp((char const   *)p2, "html");
          } else {
#line 163
            tmp___93 = __builtin_strcmp((char const   *)p2, "html");
#line 163
            tmp___90 = tmp___93;
          }
        } else {
#line 163
          tmp___93 = __builtin_strcmp((char const   *)p2, "html");
#line 163
          tmp___90 = tmp___93;
        }
#line 163
        tmp___84 = tmp___90;
      } else {
#line 163
        tmp___95 = strlen("html");
#line 163
        tmp___84 = strncmp((char const   *)p2, "html", tmp___95);
      }
#line 163
      if (tmp___84 == 0) {
#line 167
        ret = 2;
      }
    }
  }
#line 172
  return (ret);
}
}
#line 175 "util.c"
static int hex___0(char c ) 
{ 

  {
#line 177
  if ((int )c >= 48) {
#line 177
    if ((int )c <= 57) {
#line 178
      return ((int )c - 48);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 179
    if ((int )c >= 65) {
#line 179
      if ((int )c <= 70) {
#line 180
        return (((int )c - 65) + 10);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 181
      if ((int )c >= 97) {
#line 181
        if ((int )c <= 102) {
#line 182
          return (((int )c - 97) + 10);
        } else {
#line 184
          return (-1);
        }
      } else {
#line 184
        return (-1);
      }
    }
  }
}
}
#line 187 "util.c"
static int verify_path(char *path ) 
{ int dir ;
  int indotseq ;

  {
#line 188
  dir = 0;
#line 188
  indotseq = 0;
#line 190
  while ((*path)) {
#line 191
    if ((int )(*path) == 47) {
      goto _L;
    } else {
#line 191
      if ((int )(*path) == 92) {
        _L: /* CIL Label */ 
#line 192
        if (indotseq) {
#line 193
          return (0);
        }
#line 194
        if (dir) {
#line 195
          return (0);
        }
#line 196
        dir = 1;
#line 197
        path ++;
#line 198
        continue;
      }
    }
#line 201
    if (dir) {
      goto _L___0;
    } else {
#line 201
      if (indotseq) {
        _L___0: /* CIL Label */ 
#line 202
        if ((int )(*path) == 46) {
#line 203
          indotseq = 1;
        } else {
#line 205
          indotseq = 0;
        }
      }
    }
#line 208
    dir = 0;
#line 209
    path ++;
  }
#line 212
  return (1);
}
}
#line 215 "util.c"
char *util_get_path_from_uri(char *uri ) 
{ char *path ;
  char *tmp ;
  char *fullpath ;

  {
#line 216
  tmp = util_normalise_uri(uri);
#line 216
  path = tmp;
#line 219
  if (! path) {
#line 220
    return ((char *)((void *)0));
  } else {
#line 222
    fullpath = util_get_path_from_normalised_uri((char const   *)path);
#line 223
    free((void *)path);
#line 224
    return (fullpath);
  }
}
}
#line 228 "util.c"
char *util_get_path_from_normalised_uri(char const   *uri ) 
{ char *fullpath ;
  char *webroot ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 231
  tmp = config_get_config();
#line 231
  config = tmp;
#line 233
  webroot = config->webroot_dir;
#line 235
  tmp___0 = strlen(uri);
#line 235
  tmp___1 = strlen((char const   *)webroot);
#line 235
  fullpath = (char *)malloc((tmp___0 + tmp___1) + 1U);
#line 236
  if (fullpath) {
#line 237
    sprintf((char * __restrict  )fullpath, (char const   * __restrict  )"%s%s", webroot,
            uri);
  }
#line 238
  config_release_config();
#line 240
  return (fullpath);
}
}
#line 243 "util.c"
static char hexchars[16]  = 
#line 243
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f'};
#line 247 "util.c"
static char safechars[256]  = 
#line 247
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
#line 266 "util.c"
char *util_url_escape(char *src ) 
{ int len ;
  int tmp ;
  char *dst ;
  char *tmp___0 ;
  unsigned char *source ;
  int i ;
  int j ;
  int tmp___1 ;

  {
#line 268
  tmp = (int )strlen((char const   *)src);
#line 268
  len = tmp;
#line 270
  tmp___0 = (char *)calloc(1U, (unsigned int )(len * 3 + 1));
#line 270
  dst = tmp___0;
#line 271
  source = (unsigned char *)src;
#line 272
  j = 0;
#line 274
  i = 0;
#line 274
  while (i < len) {
#line 275
    if (safechars[(*(source + i))]) {
#line 276
      tmp___1 = j;
#line 276
      j ++;
#line 276
      (*(dst + tmp___1)) = (char )(*(source + i));
    } else {
#line 279
      (*(dst + j)) = (char )'%';
#line 280
      (*(dst + (j + 1))) = hexchars[((int )(*(source + i)) >> 4) & 15];
#line 281
      (*(dst + (j + 2))) = hexchars[(int )(*(source + i)) & 15];
#line 282
      j += 3;
    }
#line 274
    i ++;
  }
#line 286
  (*(dst + j)) = (char)0;
#line 287
  return (dst);
}
}
#line 290 "util.c"
char *util_url_unescape(char *src ) 
{ int len ;
  int tmp ;
  unsigned char *decoded ;
  int i ;
  char *dst ;
  int done ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 292
  tmp = (int )strlen((char const   *)src);
#line 292
  len = tmp;
#line 296
  done = 0;
#line 298
  decoded = (unsigned char *)calloc(1U, (unsigned int )(len + 1));
#line 300
  dst = (char *)decoded;
#line 302
  i = 0;
#line 302
  while (i < len) {
#line 303
    switch ((int )(*(src + i))) {
    case 37: ;
#line 305
    if (i + 2 >= len) {
#line 306
      free((void *)decoded);
#line 307
      return ((char *)((void *)0));
    }
#line 309
    tmp___0 = hex___0((*(src + (i + 1))));
#line 309
    if (tmp___0 == -1) {
#line 310
      free((void *)decoded);
#line 311
      return ((char *)((void *)0));
    } else {
#line 309
      tmp___1 = hex___0((*(src + (i + 2))));
#line 309
      if (tmp___1 == -1) {
#line 310
        free((void *)decoded);
#line 311
        return ((char *)((void *)0));
      }
    }
#line 314
    tmp___2 = dst;
#line 314
    dst ++;
#line 314
    tmp___3 = hex___0((*(src + (i + 1))));
#line 314
    tmp___4 = hex___0((*(src + (i + 2))));
#line 314
    (*tmp___2) = (char )(tmp___3 * 16 + tmp___4);
#line 315
    i += 2;
#line 316
    break;
    case 35: 
#line 318
    done = 1;
#line 319
    break;
    case 0: 
#line 321
    log_write(errorlog, 1U, "util/", "util_url_unescape", "Fatal internal logic error in util_url_unescape()");
#line 322
    free((void *)decoded);
#line 323
    return ((char *)((void *)0));
#line 324
    break;
    default: 
#line 326
    tmp___5 = dst;
#line 326
    dst ++;
#line 326
    (*tmp___5) = (*(src + i));
#line 327
    break;
    }
#line 329
    if (done) {
#line 330
      break;
    }
#line 302
    i ++;
  }
#line 333
  (*dst) = (char)0;
#line 335
  return ((char *)decoded);
}
}
#line 343 "util.c"
char *util_normalise_uri(char *uri ) 
{ char *path ;
  int tmp ;

  {
#line 346
  if ((int )(*(uri + 0)) != 47) {
#line 347
    return ((char *)((void *)0));
  }
#line 349
  path = util_url_unescape(uri);
#line 351
  if ((unsigned int )path == (unsigned int )((void *)0)) {
#line 352
    log_write(errorlog, 2U, "util/", "util_normalise_uri", "Error decoding URI: %s\n",
              uri);
#line 353
    return ((char *)((void *)0));
  }
#line 357
  tmp = verify_path(path);
#line 357
  if (tmp) {
#line 358
    return (path);
  } else {
#line 360
    log_write(errorlog, 2U, "util/", "util_normalise_uri", "Rejecting invalid path \"%s\"",
              path);
#line 361
    free((void *)path);
#line 362
    return ((char *)((void *)0));
  }
}
}
#line 366 "util.c"
static char base64table[64]  = 
#line 366
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/'};
#line 373 "util.c"
static signed char base64decode[256]  = 
#line 373
  {      (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)62, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)63, 
        (signed char)52,      (signed char)53,      (signed char)54,      (signed char)55, 
        (signed char)56,      (signed char)57,      (signed char)58,      (signed char)59, 
        (signed char)60,      (signed char)61,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-1,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)0,      (signed char)1,      (signed char)2, 
        (signed char)3,      (signed char)4,      (signed char)5,      (signed char)6, 
        (signed char)7,      (signed char)8,      (signed char)9,      (signed char)10, 
        (signed char)11,      (signed char)12,      (signed char)13,      (signed char)14, 
        (signed char)15,      (signed char)16,      (signed char)17,      (signed char)18, 
        (signed char)19,      (signed char)20,      (signed char)21,      (signed char)22, 
        (signed char)23,      (signed char)24,      (signed char)25,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)26,      (signed char)27,      (signed char)28, 
        (signed char)29,      (signed char)30,      (signed char)31,      (signed char)32, 
        (signed char)33,      (signed char)34,      (signed char)35,      (signed char)36, 
        (signed char)37,      (signed char)38,      (signed char)39,      (signed char)40, 
        (signed char)41,      (signed char)42,      (signed char)43,      (signed char)44, 
        (signed char)45,      (signed char)46,      (signed char)47,      (signed char)48, 
        (signed char)49,      (signed char)50,      (signed char)51,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2, 
        (signed char)-2,      (signed char)-2,      (signed char)-2,      (signed char)-2};
#line 392 "util.c"
char *util_bin_to_hex(unsigned char *data , int len ) 
{ char *hex___1 ;
  char *tmp ;
  int i ;

  {
#line 394
  tmp = (char *)malloc((unsigned int )(len * 2 + 1));
#line 394
  hex___1 = tmp;
#line 397
  i = 0;
#line 397
  while (i < len) {
#line 398
    (*(hex___1 + i * 2)) = hexchars[((int )(*(data + i)) & 240) >> 4];
#line 399
    (*(hex___1 + (i * 2 + 1))) = hexchars[(int )(*(data + i)) & 15];
#line 397
    i ++;
  }
#line 402
  (*(hex___1 + len * 2)) = (char)0;
#line 404
  return (hex___1);
}
}
#line 408 "util.c"
char *util_base64_encode(char *data ) 
{ int len ;
  int tmp ;
  char *out ;
  char *tmp___0 ;
  char *result ;
  int chunk ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 410
  tmp = (int )strlen((char const   *)data);
#line 410
  len = tmp;
#line 411
  tmp___0 = (char *)malloc((unsigned int )((len * 4) / 3 + 4));
#line 411
  out = tmp___0;
#line 412
  result = out;
#line 415
  while (len > 0) {
#line 416
    if (len > 3) {
#line 416
      chunk = 3;
    } else {
#line 416
      chunk = len;
    }
#line 417
    tmp___1 = out;
#line 417
    out ++;
#line 417
    (*tmp___1) = base64table[((int )(*data) & 252) >> 2];
#line 418
    tmp___2 = out;
#line 418
    out ++;
#line 418
    (*tmp___2) = base64table[(((int )(*data) & 3) << 4) | (((int )(*(data + 1)) &
                                                            240) >> 4)];
#line 419
    switch (chunk) {
    case 3: 
#line 421
    tmp___3 = out;
#line 421
    out ++;
#line 421
    (*tmp___3) = base64table[(((int )(*(data + 1)) & 15) << 2) | (((int )(*(data +
                                                                            2)) &
                                                                   192) >> 6)];
#line 422
    tmp___4 = out;
#line 422
    out ++;
#line 422
    (*tmp___4) = base64table[(int )(*(data + 2)) & 63];
#line 423
    break;
    case 2: 
#line 425
    tmp___5 = out;
#line 425
    out ++;
#line 425
    (*tmp___5) = base64table[((int )(*(data + 1)) & 15) << 2];
#line 426
    tmp___6 = out;
#line 426
    out ++;
#line 426
    (*tmp___6) = (char )'=';
#line 427
    break;
    case 1: 
#line 429
    tmp___7 = out;
#line 429
    out ++;
#line 429
    (*tmp___7) = (char )'=';
#line 430
    tmp___8 = out;
#line 430
    out ++;
#line 430
    (*tmp___8) = (char )'=';
#line 431
    break;
    }
#line 433
    data += chunk;
#line 434
    len -= chunk;
  }
#line 436
  (*out) = (char)0;
#line 438
  return (result);
}
}
#line 441 "util.c"
char *util_base64_decode(unsigned char *input ) 
{ int len ;
  int tmp ;
  char *out ;
  char *tmp___0 ;
  char *result ;
  signed char vals[4] ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 443
  tmp = (int )strlen((char const   *)input);
#line 443
  len = tmp;
#line 444
  tmp___0 = (char *)malloc((unsigned int )((len * 3) / 4 + 5));
#line 444
  out = tmp___0;
#line 445
  result = out;
#line 448
  while (len > 0) {
#line 449
    if (len < 4) {
#line 451
      free((void *)result);
#line 452
      return ((char *)((void *)0));
    }
#line 455
    tmp___1 = input;
#line 455
    input ++;
#line 455
    vals[0] = base64decode[(*tmp___1)];
#line 456
    tmp___2 = input;
#line 456
    input ++;
#line 456
    vals[1] = base64decode[(*tmp___2)];
#line 457
    tmp___3 = input;
#line 457
    input ++;
#line 457
    vals[2] = base64decode[(*tmp___3)];
#line 458
    tmp___4 = input;
#line 458
    input ++;
#line 458
    vals[3] = base64decode[(*tmp___4)];
#line 460
    if ((int )vals[0] < 0) {
#line 461
      len -= 4;
#line 462
      continue;
    } else {
#line 460
      if ((int )vals[1] < 0) {
#line 461
        len -= 4;
#line 462
        continue;
      } else {
#line 460
        if ((int )vals[2] < -1) {
#line 461
          len -= 4;
#line 462
          continue;
        } else {
#line 460
          if ((int )vals[3] < -1) {
#line 461
            len -= 4;
#line 462
            continue;
          }
        }
      }
    }
#line 465
    tmp___5 = out;
#line 465
    out ++;
#line 465
    (*tmp___5) = (char )(((int )vals[0] << 2) | ((int )vals[1] >> 4));
#line 470
    if ((int )vals[2] >= 0) {
#line 471
      tmp___6 = out;
#line 471
      out ++;
#line 471
      (*tmp___6) = (char )((((int )vals[1] & 15) << 4) | ((int )vals[2] >> 2));
    } else {
#line 473
      tmp___7 = out;
#line 473
      out ++;
#line 473
      (*tmp___7) = (char)0;
    }
#line 475
    if ((int )vals[3] >= 0) {
#line 476
      tmp___8 = out;
#line 476
      out ++;
#line 476
      (*tmp___8) = (char )((((int )vals[2] & 3) << 6) | (int )vals[3]);
    } else {
#line 478
      tmp___9 = out;
#line 478
      out ++;
#line 478
      (*tmp___9) = (char)0;
    }
#line 480
    len -= 4;
  }
#line 482
  (*out) = (char)0;
#line 484
  return (result);
}
}
#line 487 "util.c"
util_dict *util_dict_new(void) 
{ util_dict *tmp ;

  {
#line 489
  tmp = (util_dict *)calloc(1U, sizeof(util_dict ));
#line 489
  return (tmp);
}
}
#line 492 "util.c"
void util_dict_free(util_dict *dict ) 
{ util_dict *next ;

  {
#line 496
  while (dict) {
#line 497
    next = dict->next;
#line 499
    if (dict->key) {
#line 500
      free((void *)dict->key);
    }
#line 501
    if (dict->val) {
#line 502
      free((void *)dict->val);
    }
#line 503
    free((void *)dict);
#line 505
    dict = next;
  }
#line 507
  return;
}
}
#line 509 "util.c"
char const   *util_dict_get(util_dict *dict , char const   *key ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 511
  while (dict) {
#line 512
    if (0) {
#line 512
      __s1_len = strlen(key);
#line 512
      __s2_len = strlen((char const   *)dict->key);
#line 512
      if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) ==
             1U)) {
        goto _L___0;
      } else {
#line 512
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 512
          if (! ((unsigned int )((void const   *)(dict->key + 1)) - (unsigned int )((void const   *)dict->key) ==
                 1U)) {
#line 512
            tmp___8 = 1;
          } else {
#line 512
            if (__s2_len >= 4U) {
#line 512
              tmp___8 = 1;
            } else {
#line 512
              tmp___8 = 0;
            }
          }
        } else {
#line 512
          tmp___8 = 0;
        }
      }
#line 512
      if (tmp___8) {
#line 512
        tmp___4 = __builtin_strcmp(key, (char const   *)dict->key);
      } else {
#line 512
        tmp___7 = __builtin_strcmp(key, (char const   *)dict->key);
#line 512
        tmp___4 = tmp___7;
      }
    } else {
#line 512
      tmp___7 = __builtin_strcmp(key, (char const   *)dict->key);
#line 512
      tmp___4 = tmp___7;
    }
#line 512
    if (! tmp___4) {
#line 513
      return ((char const   *)dict->val);
    }
#line 514
    dict = dict->next;
  }
#line 516
  return ((char const   *)((void *)0));
}
}
#line 519 "util.c"
int util_dict_set(util_dict *dict , char const   *key , char const   *val ) 
{ util_dict *prev ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___18 ;
  char *tmp___28 ;

  {
#line 523
  if (! dict) {
#line 524
    log_write(errorlog, 1U, "util/", "util_dict_set", "NULL values passed to util_dict_set()");
#line 525
    return (0);
  } else {
#line 523
    if (! key) {
#line 524
      log_write(errorlog, 1U, "util/", "util_dict_set", "NULL values passed to util_dict_set()");
#line 525
      return (0);
    }
  }
#line 528
  prev = (util_dict *)((void *)0);
#line 529
  while (dict) {
#line 530
    if (! dict->key) {
#line 531
      break;
    } else {
#line 530
      if (0) {
#line 530
        __s1_len = strlen((char const   *)dict->key);
#line 530
        __s2_len = strlen(key);
#line 530
        if (! ((unsigned int )((void const   *)(dict->key + 1)) - (unsigned int )((void const   *)dict->key) ==
               1U)) {
          goto _L___0;
        } else {
#line 530
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 530
            if (! ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) ==
                   1U)) {
#line 530
              tmp___8 = 1;
            } else {
#line 530
              if (__s2_len >= 4U) {
#line 530
                tmp___8 = 1;
              } else {
#line 530
                tmp___8 = 0;
              }
            }
          } else {
#line 530
            tmp___8 = 0;
          }
        }
#line 530
        if (tmp___8) {
#line 530
          tmp___4 = __builtin_strcmp((char const   *)dict->key, key);
        } else {
#line 530
          tmp___7 = __builtin_strcmp((char const   *)dict->key, key);
#line 530
          tmp___4 = tmp___7;
        }
      } else {
#line 530
        tmp___7 = __builtin_strcmp((char const   *)dict->key, key);
#line 530
        tmp___4 = tmp___7;
      }
#line 530
      if (! tmp___4) {
#line 531
        break;
      }
    }
#line 532
    prev = dict;
#line 533
    dict = dict->next;
  }
#line 536
  if (! dict) {
#line 537
    dict = util_dict_new();
#line 538
    if (! dict) {
#line 539
      log_write(errorlog, 1U, "util/", "util_dict_set", "unable to allocate new dictionary");
#line 540
      return (0);
    }
#line 542
    if (prev) {
#line 543
      prev->next = dict;
    }
  }
#line 546
  if (dict->key) {
#line 547
    free((void *)dict->val);
  } else {
#line 548
    tmp___18 = __strdup(key);
#line 548
    dict->key = tmp___18;
#line 548
    if (! dict->key) {
#line 549
      if (prev) {
#line 550
        prev->next = (struct _util_dict *)((void *)0);
      }
#line 551
      util_dict_free(dict);
#line 553
      log_write(errorlog, 1U, "util/", "util_dict_set", "unable to allocate new dictionary key");
#line 554
      return (0);
    }
  }
#line 557
  tmp___28 = __strdup(val);
#line 557
  dict->val = tmp___28;
#line 558
  if (! dict->val) {
#line 559
    log_write(errorlog, 1U, "util/", "util_dict_set", "unable to allocate new dictionary value");
#line 560
    return (0);
  }
#line 563
  return (1);
}
}
#line 570 "util.c"
char *util_dict_urlencode(util_dict *dict , char delim ) 
{ char *res ;
  char *tmp ;
  char *enc ;
  int start ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 574
  start = 1;
#line 576
  res = (char *)((void *)0);
#line 576
  while (dict) {
#line 578
    if (! dict->key) {
      goto __Cont;
    }
#line 580
    if (start) {
#line 581
      tmp___0 = strlen((char const   *)dict->key);
#line 581
      res = (char *)malloc(tmp___0 + 1U);
#line 581
      if (! res) {
#line 582
        return ((char *)((void *)0));
      }
#line 584
      sprintf((char * __restrict  )res, (char const   * __restrict  )"%s", dict->key);
#line 585
      start = 0;
    } else {
#line 587
      tmp___1 = strlen((char const   *)res);
#line 587
      tmp___2 = strlen((char const   *)dict->key);
#line 587
      tmp = (char *)realloc((void *)res, (tmp___1 + tmp___2) + 2U);
#line 587
      if (tmp) {
#line 591
        res = tmp;
      } else {
#line 588
        free((void *)res);
#line 589
        return ((char *)((void *)0));
      }
#line 592
      tmp___3 = strlen((char const   *)res);
#line 592
      sprintf((char * __restrict  )(res + tmp___3), (char const   * __restrict  )"%c%s",
              delim, dict->key);
    }
#line 596
    if (! dict->val) {
      goto __Cont;
    }
#line 598
    enc = util_url_escape(dict->val);
#line 598
    if (! enc) {
#line 599
      free((void *)res);
#line 600
      return ((char *)((void *)0));
    }
#line 603
    tmp___4 = strlen((char const   *)res);
#line 603
    tmp___5 = strlen((char const   *)enc);
#line 603
    tmp = (char *)realloc((void *)res, (tmp___4 + tmp___5) + 2U);
#line 603
    if (tmp) {
#line 608
      res = tmp;
    } else {
#line 604
      free((void *)enc);
#line 605
      free((void *)res);
#line 606
      return ((char *)((void *)0));
    }
#line 609
    tmp___6 = strlen((char const   *)res);
#line 609
    sprintf((char * __restrict  )(res + tmp___6), (char const   * __restrict  )"=%s",
            enc);
#line 610
    free((void *)enc);
    __Cont: /* CIL Label */ 
#line 576
    dict = dict->next;
  }
#line 613
  return (res);
}
}
#line 1 "cil-e46vEHat.o"
#pragma merger(0,"/tmp/cil-PGCHVNEA.i","")
#line 1 "./src/slave.o_saved.c"
#pragma merger(0,"./slave.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 41 "/usr/include/libxml2/libxml/xmlstring.h"
extern xmlChar *xmlStrdup(xmlChar const   *cur ) ;
#line 207 "/usr/include/libxml2/libxml/globals.h"
extern void (*xmlFree)(void *mem ) ;
#line 46 "connection.h"
void connection_close(connection_t *con ) ;
#line 47
connection_t *connection_create(sock_t sock , sock_t serversock , char *ip ) ;
#line 48
int connection_complete_source(struct source_tag *source , int response ) ;
#line 70 "client.h"
int client_create(client_t **c_ptr , connection_t *con , http_parser_t *parser ) ;
#line 79
void client_set_queue(client_t *client , refbuf_t *refbuf ) ;
#line 37 "slave.h"
void slave_recheck_mounts(void) ;
#line 38
void slave_rebuild_mounts(void) ;
#line 39
void slave_rescan(void) ;
#line 40
relay_server *relay_free(relay_server *relay ) ;
#line 184 "cfgfile.h"
mount_proxy *config_find_mount(ice_config_t *config , char const   *mount ) ;
#line 188
ice_config_locks *config_locks(void) ;
#line 78 "stats.h"
void stats_event(char const   *source , char const   *name , char const   *value ) ;
#line 80
void stats_event_inc(char const   *source , char const   *name ) ;
#line 32 "yp.h"
void yp_remove(char const   *mount ) ;
#line 80 "source.h"
source_t *source_reserve(char const   *mount ) ;
#line 83
void source_update_settings(ice_config_t *config , source_t *source , mount_proxy *mountinfo ) ;
#line 84
void source_clear_source(source_t *source ) ;
#line 85
source_t *source_find_mount(char const   *mount ) ;
#line 89
void source_free_source(source_t *source ) ;
#line 90
void source_move_clients(source_t *source , source_t *dest ) ;
#line 92
void source_main(source_t *source ) ;
#line 93
void source_recheck_mounts(void) ;
#line 19 "event.h"
void event_config_read(void *arg ) ;
#line 63 "slave.c"
static void *_slave_thread(void *arg ) ;
#line 64 "slave.c"
static thread_type *_slave_thread_id  ;
#line 65 "slave.c"
static int slave_running  =    0;
#line 66 "slave.c"
static int update_settings  =    0;
#line 67 "slave.c"
static unsigned int volatile   max_interval  =    (unsigned int volatile   )0;
#line 68 "slave.c"
static int volatile   rescan_relays  =    (int volatile   )0;
#line 70 "slave.c"
relay_server *relay_free(relay_server *relay ) 
{ relay_server *next ;

  {
#line 72
  next = relay->next;
#line 73
  log_write(errorlog, 4U, "slave/", "relay_free", "freeing relay %s", relay->localmount);
#line 74
  if (relay->source) {
#line 75
    source_free_source(relay->source);
  }
#line 76
  ((*xmlFree))((void *)relay->server);
#line 77
  ((*xmlFree))((void *)relay->mount);
#line 78
  ((*xmlFree))((void *)relay->localmount);
#line 79
  if (relay->username) {
#line 80
    ((*xmlFree))((void *)relay->username);
  }
#line 81
  if (relay->password) {
#line 82
    ((*xmlFree))((void *)relay->password);
  }
#line 83
  free((void *)relay);
#line 84
  return (next);
}
}
#line 88 "slave.c"
relay_server *relay_copy(relay_server *r ) 
{ relay_server *copy ;
  relay_server *tmp ;

  {
#line 90
  tmp = (relay_server *)calloc(1U, sizeof(relay_server ));
#line 90
  copy = tmp;
#line 92
  if (copy) {
#line 94
    copy->server = (char *)xmlStrdup((xmlChar const   *)r->server);
#line 95
    copy->mount = (char *)xmlStrdup((xmlChar const   *)r->mount);
#line 96
    copy->localmount = (char *)xmlStrdup((xmlChar const   *)r->localmount);
#line 97
    if (r->username) {
#line 98
      copy->username = (char *)xmlStrdup((xmlChar const   *)r->username);
    }
#line 99
    if (r->password) {
#line 100
      copy->password = (char *)xmlStrdup((xmlChar const   *)r->password);
    }
#line 101
    copy->port = r->port;
#line 102
    copy->mp3metadata = r->mp3metadata;
#line 103
    copy->on_demand = r->on_demand;
  }
#line 105
  return (copy);
}
}
#line 112 "slave.c"
void slave_recheck_mounts(void) 
{ 

  {
#line 114
  max_interval = (unsigned int volatile   )0;
#line 115
  update_settings = 1;
#line 116
  return;
}
}
#line 122 "slave.c"
void slave_rescan(void) 
{ 

  {
#line 124
  rescan_relays = (int volatile   )1;
#line 125
  return;
}
}
#line 131 "slave.c"
void slave_rebuild_mounts(void) 
{ 

  {
#line 133
  update_settings = 1;
#line 134
  rescan_relays = (int volatile   )1;
#line 135
  return;
}
}
#line 138 "slave.c"
void slave_initialize(void) 
{ 

  {
#line 140
  if (slave_running) {
#line 141
    return;
  }
#line 143
  slave_running = 1;
#line 144
  max_interval = (unsigned int volatile   )0;
#line 145
  _slave_thread_id = thread_create_c((char *)"Slave Thread", & _slave_thread, (void *)0,
                                     0, 145, (char *)"slave.c");
#line 146
  return;
}
}
#line 149 "slave.c"
void slave_shutdown(void) 
{ 

  {
#line 151
  if (! slave_running) {
#line 152
    return;
  }
#line 153
  slave_running = 0;
#line 154
  log_write(errorlog, 4U, "slave/", "slave_shutdown", "waiting for slave thread");
#line 155
  thread_join(_slave_thread_id);
#line 156
  return;
}
}
#line 162 "slave.c"
static void *start_relay_stream(void *arg ) 
{ relay_server *relay ;
  sock_t streamsock ;
  source_t *src ;
  http_parser_t *parser ;
  connection_t *con ;
  char header[4096] ;
  char *auth_header ;
  char *esc_authorisation ;
  unsigned int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  source_t *fallback_source ;

  {
#line 164
  relay = (relay_server *)arg;
#line 165
  streamsock = -1;
#line 166
  src = relay->source;
#line 167
  parser = (http_parser_t *)((void *)0);
#line 168
  con = (connection_t *)((void *)0);
#line 171
  relay->running = 1;
#line 172
  log_write(errorlog, 3U, "slave/", "start_relay_stream", "Starting relayed source at mountpoint \"%s\"",
            relay->localmount);

  ///thread_register("start_relay_stream");
  ///thread_check_in();

#line 173
  LOOP_START_RELAY_STREAM:while (1) {
#line 177
    streamsock = sock_connect_wto((char const   *)relay->server, relay->port, 30);
#line 178
    if (streamsock == -1) {
#line 180
      log_write(errorlog, 2U, "slave/", "start_relay_stream", "Failed to relay stream from master server, couldn\'t connect to http://%s:%d%s",
                relay->server, relay->port, relay->mount);
#line 182
      break;
    }
#line 184
    con = connection_create(streamsock, -1, (char *)((void *)0));
#line 186
    if (relay->username) {
#line 186
      if (relay->password) {
#line 189
        tmp = strlen((char const   *)relay->username);
#line 189
        tmp___0 = strlen((char const   *)relay->password);
#line 189
        len = (tmp + tmp___0) + 2U;
#line 191
        auth_header = (char *)malloc(len);
#line 192
        snprintf((char * __restrict  )auth_header, len, (char const   * __restrict  )"%s:%s",
                 relay->username, relay->password);
#line 193
        esc_authorisation = util_base64_encode(auth_header);
#line 194
        free((void *)auth_header);
#line 195
        tmp___1 = strlen((char const   *)esc_authorisation);
#line 195
        len = tmp___1 + 24U;
#line 196
        auth_header = (char *)malloc(len);
#line 197
        snprintf((char * __restrict  )auth_header, len, (char const   * __restrict  )"Authorization: Basic %s\r\n",
                 esc_authorisation);
#line 199
        free((void *)esc_authorisation);
      } else {
#line 203
        tmp___11 = __strdup("");
#line 203
        auth_header = tmp___11;
      }
    } else {
#line 203
      tmp___11 = __strdup("");
#line 203
      auth_header = tmp___11;
    }
#line 211
    if (relay->mp3metadata) {
#line 211
      tmp___12 = "Icy-MetaData: 1\r\n";
    } else {
#line 211
      tmp___12 = "";
    }
#line 211
    sock_write(streamsock, "GET %s HTTP/1.0\r\nUser-Agent: Icecast 2.3.1\r\n%s%s\r\n",
               relay->mount, tmp___12, auth_header);
#line 219
    free((void *)auth_header);
#line 220
    memset((void *)(header), 0, sizeof(header));
#line 221
    tmp___13 = util_read_header(con->sock, header, 4096UL, 1);
#line 221
    if (tmp___13 == 0) {
#line 223
      log_write(errorlog, 2U, "slave/", "start_relay_stream", "Header read failed");
#line 224
      break;
    }
#line 226
    parser = httpp_create_parser();
#line 227
    httpp_initialize(parser, (http_varlist_t *)((void *)0));
#line 228
    tmp___14 = strlen((char const   *)(header));
#line 228
    tmp___15 = httpp_parse_response(parser, header, (unsigned long )tmp___14, relay->localmount);
#line 228
    if (! tmp___15) {
#line 230
      log_write(errorlog, 1U, "slave/", "start_relay_stream", "Error parsing relay request");
#line 231
      break;
    }
#line 233
    tmp___17 = httpp_getvar(parser, "__errormessage");
#line 233
    if (tmp___17) {
#line 235
      tmp___16 = httpp_getvar(parser, "__errormessage");
#line 235
      log_write(errorlog, 1U, "slave/", "start_relay_stream", "Error from relay request: %s",
                tmp___16);
#line 236
      break;
    }
#line 238
    src->parser = parser;
#line 239
    src->con = con;
#line 241
    global_lock();
#line 242
    tmp___18 = client_create(& src->client, con, parser);
#line 242
    if (tmp___18 < 0) {
#line 244
      global_unlock();
#line 246
      con = (connection_t *)((void *)0);
#line 247
      parser = (http_parser_t *)((void *)0);
#line 248
      break;
    }
#line 250
    global_unlock();
#line 251
    con = (connection_t *)((void *)0);
#line 252
    parser = (http_parser_t *)((void *)0);
#line 253
    client_set_queue(src->client, (refbuf_t *)((void *)0));
#line 255
    tmp___19 = connection_complete_source(src, 0);
#line 255
    if (tmp___19 < 0) {
#line 257
      log_write(errorlog, 4U, "slave/", "start_relay_stream", "Failed to complete source initialisation");
#line 258
      break;
    }
#line 260
    stats_event_inc((char const   *)((void *)0), "source_relay_connections");
#line 261
    stats_event((char const   *)relay->localmount, "source_ip", (char const   *)relay->server);
#line 263
    source_main(relay->source);
#line 265
    if (relay->on_demand == 0) {
#line 268
      yp_remove((char const   *)relay->localmount);
#line 269
      (relay->source)->yp_public = -1;
    }
#line 273
    relay->cleanup = 1;
#line 274
    rescan_relays = (int volatile   )1;
#line 276
    return ((void *)0);
#line 173
    break;
  }

  ///thread_deregister("start_relay_stream");
#line 279
  if ((relay->source)->fallback_mount) {
#line 283
    log_write(errorlog, 4U, "slave/", "start_relay_stream", "failed relay, fallback to %s",
              (relay->source)->fallback_mount);
#line 284
    avl_tree_rlock(global.source_tree);
#line 285
    fallback_source = source_find_mount((char const   *)(relay->source)->fallback_mount);
#line 287
    if ((unsigned int )fallback_source != (unsigned int )((void *)0)) {
#line 288
      source_move_clients(relay->source, fallback_source);
    }
#line 290
    avl_tree_unlock(global.source_tree);
  }
#line 293
  if (con) {
#line 294
    connection_close(con);
  }
#line 295
  src->con = (connection_t *)((void *)0);
#line 296
  if (parser) {
#line 297
    httpp_destroy(parser);
  }
#line 298
  src->parser = (http_parser_t *)((void *)0);
#line 299
  source_clear_source(relay->source);
#line 302
  relay->cleanup = 1;
#line 303
  rescan_relays = (int volatile   )1;
#line 305
  return ((void *)0);
}
}
#line 310 "slave.c"
static void check_relay_stream(relay_server *relay ) 
{ source_t *source ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;
  source_t *fallback ;
  ice_config_t *config___0 ;
  ice_config_t *tmp___1 ;
  mount_proxy *mountinfo___0 ;
  mount_proxy *tmp___2 ;

  {
#line 312
  if ((unsigned int )relay->source == (unsigned int )((void *)0)) {
#line 314
    if ((int )(*(relay->localmount + 0)) != 47) {
#line 316
      log_write(errorlog, 2U, "slave/", "check_relay_stream", "relay mountpoint \"%s\" does not start with /, skipping",
                relay->localmount);
#line 318
      return;
    }
#line 321
    relay->source = source_reserve((char const   *)relay->localmount);
#line 322
    if (relay->source) {
#line 323
      log_write(errorlog, 4U, "slave/", "check_relay_stream", "Adding relay source at mountpoint \"%s\"",
                relay->localmount);
    } else {
#line 325
      log_write(errorlog, 2U, "slave/", "check_relay_stream", "new relay but source \"%s\" already exists",
                relay->localmount);
    }
  }
#line 327
  while (1) {
#line 329
    source = relay->source;
#line 330
    if ((unsigned int )relay->source == (unsigned int )((void *)0)) {
#line 331
      break;
    } else {
#line 330
      if (relay->running) {
#line 331
        break;
      }
    }
#line 332
    if (relay->on_demand) {
#line 334
      tmp = config_get_config();
#line 334
      config = tmp;
#line 335
      tmp___0 = config_find_mount(config, (char const   *)relay->localmount);
#line 335
      mountinfo = tmp___0;
#line 337
      if ((unsigned int )mountinfo == (unsigned int )((void *)0)) {
#line 338
        source_update_settings(config, relay->source, mountinfo);
      }
#line 339
      config_release_config();
#line 340
      slave_rebuild_mounts();
#line 341
      stats_event((char const   *)relay->localmount, "listeners", "0");
#line 342
      (relay->source)->on_demand = relay->on_demand;
#line 344
      if (source->fallback_mount) {
#line 344
        if (source->fallback_override) {
#line 347
          log_write(errorlog, 4U, "slave/", "check_relay_stream", "checking %s for fallback override",
                    source->fallback_mount);
#line 348
          avl_tree_rlock(global.source_tree);
#line 349
          fallback = source_find_mount((char const   *)source->fallback_mount);
#line 350
          if (fallback) {
#line 350
            if (fallback->running) {
#line 350
              if (fallback->listeners) {
#line 352
                log_write(errorlog, 4U, "slave/", "check_relay_stream", "fallback running %d with %lu listeners",
                          fallback->running, fallback->listeners);
#line 353
                source->on_demand_req = 1;
              }
            }
          }
#line 355
          avl_tree_unlock(global.source_tree);
        }
      }
#line 357
      if (source->on_demand_req == 0) {
#line 358
        break;
      }
    }
#line 361
    relay->thread = thread_create_c((char *)"Relay Thread", & start_relay_stream,
                                    (void *)relay, 0, 362, (char *)"slave.c");
#line 363
    return;
#line 327
    break;
  }
#line 367
  if (relay->cleanup) {
#line 367
    if (relay->thread) {
#line 369
      log_write(errorlog, 4U, "slave/", "check_relay_stream", "waiting for relay thread for \"%s\"",
                relay->localmount);
#line 370
      thread_join(relay->thread);
#line 371
      relay->thread = (thread_type *)((void *)0);
#line 372
      relay->cleanup = 0;
#line 373
      relay->running = 0;
#line 375
      if (relay->on_demand) {
#line 377
        tmp___1 = config_get_config();
#line 377
        config___0 = tmp___1;
#line 378
        tmp___2 = config_find_mount(config___0, (char const   *)relay->localmount);
#line 378
        mountinfo___0 = tmp___2;
#line 379
        source_update_settings(config___0, relay->source, mountinfo___0);
#line 380
        config_release_config();
#line 381
        stats_event((char const   *)relay->localmount, "listeners", "0");
      }
    }
  }
#line 384
  return;
}
}
#line 390 "slave.c"
static int relay_has_changed(relay_server *new , relay_server *old ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 392
  while (1) {
#line 394
    if (0) {
#line 394
      __s1_len = strlen((char const   *)new->mount);
#line 394
      __s2_len = strlen((char const   *)old->mount);
#line 394
      if (! ((unsigned int )((void const   *)(new->mount + 1)) - (unsigned int )((void const   *)new->mount) ==
             1U)) {
        goto _L___0;
      } else {
#line 394
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 394
          if (! ((unsigned int )((void const   *)(old->mount + 1)) - (unsigned int )((void const   *)old->mount) ==
                 1U)) {
#line 394
            tmp___8 = 1;
          } else {
#line 394
            if (__s2_len >= 4U) {
#line 394
              tmp___8 = 1;
            } else {
#line 394
              tmp___8 = 0;
            }
          }
        } else {
#line 394
          tmp___8 = 0;
        }
      }
#line 394
      if (tmp___8) {
#line 394
        tmp___4 = __builtin_strcmp((char const   *)new->mount, (char const   *)old->mount);
      } else {
#line 394
        tmp___7 = __builtin_strcmp((char const   *)new->mount, (char const   *)old->mount);
#line 394
        tmp___4 = tmp___7;
      }
    } else {
#line 394
      tmp___7 = __builtin_strcmp((char const   *)new->mount, (char const   *)old->mount);
#line 394
      tmp___4 = tmp___7;
    }
#line 394
    if (tmp___4 != 0) {
#line 395
      break;
    }
#line 396
    if (0) {
#line 396
      __s1_len___0 = strlen((char const   *)new->server);
#line 396
      __s2_len___0 = strlen((char const   *)old->server);
#line 396
      if (! ((unsigned int )((void const   *)(new->server + 1)) - (unsigned int )((void const   *)new->server) ==
             1U)) {
        goto _L___2;
      } else {
#line 396
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 396
          if (! ((unsigned int )((void const   *)(old->server + 1)) - (unsigned int )((void const   *)old->server) ==
                 1U)) {
#line 396
            tmp___18 = 1;
          } else {
#line 396
            if (__s2_len___0 >= 4U) {
#line 396
              tmp___18 = 1;
            } else {
#line 396
              tmp___18 = 0;
            }
          }
        } else {
#line 396
          tmp___18 = 0;
        }
      }
#line 396
      if (tmp___18) {
#line 396
        tmp___14 = __builtin_strcmp((char const   *)new->server, (char const   *)old->server);
      } else {
#line 396
        tmp___17 = __builtin_strcmp((char const   *)new->server, (char const   *)old->server);
#line 396
        tmp___14 = tmp___17;
      }
    } else {
#line 396
      tmp___17 = __builtin_strcmp((char const   *)new->server, (char const   *)old->server);
#line 396
      tmp___14 = tmp___17;
    }
#line 396
    if (tmp___14 != 0) {
#line 397
      break;
    }
#line 398
    if (new->port != old->port) {
#line 399
      break;
    }
#line 400
    if (new->mp3metadata != old->mp3metadata) {
#line 401
      break;
    }
#line 402
    if (new->on_demand != old->on_demand) {
#line 403
      old->on_demand = new->on_demand;
    }
#line 404
    return (0);
#line 392
    break;
  }
#line 406
  return (1);
}
}
#line 414 "slave.c"
static relay_server *update_relay_set(relay_server **current , relay_server *updated ) 
{ relay_server *relay ;
  relay_server *existing_relay ;
  relay_server **existing_p ;
  relay_server *new_list ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 417
  relay = updated;
#line 419
  new_list = (relay_server *)((void *)0);
#line 421
  while (relay) {
#line 423
    existing_relay = (*current);
#line 424
    existing_p = current;
#line 426
    while (existing_relay) {
#line 429
      if (0) {
#line 429
        __s1_len = strlen((char const   *)relay->localmount);
#line 429
        __s2_len = strlen((char const   *)existing_relay->localmount);
#line 429
        if (! ((unsigned int )((void const   *)(relay->localmount + 1)) - (unsigned int )((void const   *)relay->localmount) ==
               1U)) {
          goto _L___0;
        } else {
#line 429
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 429
            if (! ((unsigned int )((void const   *)(existing_relay->localmount + 1)) -
                   (unsigned int )((void const   *)existing_relay->localmount) ==
                   1U)) {
#line 429
              tmp___9 = 1;
            } else {
#line 429
              if (__s2_len >= 4U) {
#line 429
                tmp___9 = 1;
              } else {
#line 429
                tmp___9 = 0;
              }
            }
          } else {
#line 429
            tmp___9 = 0;
          }
        }
#line 429
        if (tmp___9) {
#line 429
          tmp___5 = __builtin_strcmp((char const   *)relay->localmount, (char const   *)existing_relay->localmount);
        } else {
#line 429
          tmp___8 = __builtin_strcmp((char const   *)relay->localmount, (char const   *)existing_relay->localmount);
#line 429
          tmp___5 = tmp___8;
        }
      } else {
#line 429
        tmp___8 = __builtin_strcmp((char const   *)relay->localmount, (char const   *)existing_relay->localmount);
#line 429
        tmp___5 = tmp___8;
      }
#line 429
      if (tmp___5 == 0) {
#line 430
        tmp = relay_has_changed(relay, existing_relay);
#line 430
        if (tmp == 0) {
#line 431
          break;
        }
      }
#line 432
      existing_p = & existing_relay->next;
#line 433
      existing_relay = existing_relay->next;
    }
#line 435
    if ((unsigned int )existing_relay == (unsigned int )((void *)0)) {
#line 438
      existing_relay = relay_copy(relay);
    } else {
#line 442
      (*existing_p) = existing_relay->next;
    }
#line 444
    existing_relay->next = new_list;
#line 445
    new_list = existing_relay;
#line 446
    relay = relay->next;
  }
#line 448
  return (new_list);
}
}
#line 456 "slave.c"
static relay_server *update_relays(relay_server **relay_list , relay_server *new_relay_list ) 
{ relay_server *active_relays ;
  relay_server *cleanup_relays ;

  {
#line 461
  active_relays = update_relay_set(relay_list, new_relay_list);
#line 463
  cleanup_relays = (*relay_list);
#line 465
  (*relay_list) = active_relays;
#line 467
  return (cleanup_relays);
}
}
#line 471 "slave.c"
static void relay_check_streams(relay_server *to_start , relay_server *to_free ) 
{ relay_server *relay ;

  {
#line 475
  while (to_free) {
#line 477
    if (to_free->source) {
#line 479
      if (to_free->running) {
#line 482
        log_write(errorlog, 4U, "slave/", "relay_check_streams", "source shutdown request on \"%s\"",
                  to_free->localmount);
#line 483
        (to_free->source)->running = 0;
#line 484
        thread_join(to_free->thread);
#line 485
        slave_rebuild_mounts();
      } else {
#line 488
        stats_event((char const   *)to_free->localmount, (char const   *)((void *)0),
                    (char const   *)((void *)0));
      }
    }
#line 490
    to_free = relay_free(to_free);
  }
#line 493
  relay = to_start;
#line 494
  while (relay) {
#line 496
    check_relay_stream(relay);
#line 497
    relay = relay->next;
  }
#line 499
  return;
}
}
#line 502 "slave.c"
static int update_from_master(ice_config_t *config ) 
{ char *master ;
  char *password ;
  char *username ;
  int port ;
  sock_t mastersock ;
  int ret ;
  char buf[256] ;
  char *authheader ;
  char *data ;
  relay_server *new_relays ;
  relay_server *cleanup_relays ;
  int len ;
  int count ;
  int on_demand ;
  char *tmp___8 ;
  char *tmp___18 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  int tmp___45 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t tmp___58 ;
  int tmp___59 ;
  relay_server *r ;
  size_t tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  ice_config_locks *tmp___63 ;
  ice_config_locks *tmp___64 ;

  {
#line 504
  master = (char *)((void *)0);
#line 504
  password = (char *)((void *)0);
#line 504
  username = (char *)((void *)0);
#line 507
  ret = 0;
#line 509
  while (1) {
#line 512
    new_relays = (relay_server *)((void *)0);
#line 513
    count = 1;
#line 516
    tmp___8 = __strdup((char const   *)config->master_username);
#line 516
    username = tmp___8;
#line 517
    if (config->master_password) {
#line 518
      tmp___18 = __strdup((char const   *)config->master_password);
#line 518
      password = tmp___18;
    }
#line 520
    if (config->master_server) {
#line 521
      tmp___28 = __strdup((char const   *)config->master_server);
#line 521
      master = tmp___28;
    }
#line 523
    port = config->master_server_port;
#line 525
    if ((unsigned int )password == (unsigned int )((void *)0)) {
#line 526
      break;
    } else {
#line 525
      if ((unsigned int )master == (unsigned int )((void *)0)) {
#line 526
        break;
      } else {
#line 525
        if (port == 0) {
#line 526
          break;
        }
      }
    }
#line 527
    on_demand = config->on_demand;
#line 528
    ret = 1;
#line 529
    config_release_config();
#line 530
    mastersock = sock_connect_wto((char const   *)master, port, 0);
#line 532
    if (mastersock == -1) {
#line 534
      log_write(errorlog, 2U, "slave/", "update_from_master", "Relay slave failed to contact master server to fetch stream list");
#line 535
      break;
    }
#line 538
    tmp___29 = strlen((char const   *)username);
#line 538
    tmp___30 = strlen((char const   *)password);
#line 538
    len = (int )((tmp___29 + tmp___30) + 2U);
#line 539
    authheader = (char *)malloc((unsigned int )len);
#line 540
    snprintf((char * __restrict  )authheader, (unsigned int )len, (char const   * __restrict  )"%s:%s",
             username, password);
#line 541
    data = util_base64_encode(authheader);
#line 542
    sock_write(mastersock, "GET /admin/streamlist.txt HTTP/1.0\r\nAuthorization: Basic %s\r\n\r\n",
               data);
#line 546
    free((void *)authheader);
#line 547
    free((void *)data);
#line 549
    tmp___31 = sock_read_line(mastersock, buf, (int )sizeof(buf));
#line 550
    if (tmp___31 == 0) {
#line 552
      sock_close(mastersock);
#line 553
      log_write(errorlog, 2U, "slave/", "update_from_master", "Master rejected streamlist request");
#line 554
      break;
    } else {
#line 550
      if (0) {
#line 550
        if (0) {
#line 550
          __s1_len___0 = strlen((char const   *)(buf));
#line 550
          __s2_len___0 = strlen("HTTP/1.0 200");
#line 550
          if (! ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)(buf)) ==
                 1U)) {
            goto _L___2;
          } else {
#line 550
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 550
              if (! ((unsigned int )((void const   *)("HTTP/1.0 200" + 1)) - (unsigned int )((void const   *)"HTTP/1.0 200") ==
                     1U)) {
#line 550
                tmp___55 = 1;
              } else {
#line 550
                if (__s2_len___0 >= 4U) {
#line 550
                  tmp___55 = 1;
                } else {
#line 550
                  tmp___55 = 0;
                }
              }
            } else {
#line 550
              tmp___55 = 0;
            }
          }
#line 550
          if (tmp___55) {
#line 550
            tmp___51 = __builtin_strcmp((char const   *)(buf), "HTTP/1.0 200");
          } else {
#line 550
            tmp___54 = __builtin_strcmp((char const   *)(buf), "HTTP/1.0 200");
#line 550
            tmp___51 = tmp___54;
          }
        } else {
#line 550
          tmp___54 = __builtin_strcmp((char const   *)(buf), "HTTP/1.0 200");
#line 550
          tmp___51 = tmp___54;
        }
#line 550
        tmp___45 = tmp___51;
      } else {
#line 550
        tmp___45 = strncmp((char const   *)(buf), "HTTP/1.0 200", 12U);
      }
#line 550
      if (tmp___45 != 0) {
#line 552
        sock_close(mastersock);
#line 553
        log_write(errorlog, 2U, "slave/", "update_from_master", "Master rejected streamlist request");
#line 554
        break;
      }
    }
#line 557
    while (1) {
#line 557
      tmp___59 = sock_read_line(mastersock, buf, (int )sizeof(buf));
#line 557
      if (! tmp___59) {
#line 557
        break;
      }
#line 559
      tmp___58 = strlen((char const   *)(buf));
#line 559
      if (! tmp___58) {
#line 560
        break;
      }
    }
#line 562
    while (1) {
#line 562
      tmp___62 = sock_read_line(mastersock, buf, (int )sizeof(buf));
#line 562
      if (! tmp___62) {
#line 562
        break;
      }
#line 565
      tmp___60 = strlen((char const   *)(buf));
#line 565
      if (! tmp___60) {
#line 566
        continue;
      }
#line 567
      tmp___61 = count;
#line 567
      count ++;
#line 567
      log_write(errorlog, 4U, "slave/", "update_from_master", "read %d from master \"%s\"",
                tmp___61, buf);
#line 568
      r = (relay_server *)calloc(1U, sizeof(relay_server ));
#line 569
      if (r) {
#line 571
        r->server = (char *)xmlStrdup((xmlChar const   *)master);
#line 572
        r->port = port;
#line 573
        r->mount = (char *)xmlStrdup((xmlChar const   *)(buf));
#line 574
        r->localmount = (char *)xmlStrdup((xmlChar const   *)(buf));
#line 575
        r->mp3metadata = 1;
#line 576
        r->on_demand = on_demand;
#line 577
        r->next = new_relays;
#line 578
        new_relays = r;
      }
    }
#line 581
    sock_close(mastersock);
#line 583
    tmp___63 = config_locks();
#line 583
    thread_mutex_lock_c(& tmp___63->relay_lock, 583, (char *)"slave.c");
#line 584
    cleanup_relays = update_relays(& global.master_relays, new_relays);
#line 586
    relay_check_streams(global.master_relays, cleanup_relays);
#line 587
    relay_check_streams((relay_server *)((void *)0), new_relays);
#line 589
    tmp___64 = config_locks();
#line 589
    thread_mutex_unlock_c(& tmp___64->relay_lock, 589, (char *)"slave.c");
#line 509
    break;
  }
#line 593
  if (master) {
#line 594
    free((void *)master);
  }
#line 595
  if (username) {
#line 596
    free((void *)username);
  }
#line 597
  if (password) {
#line 598
    free((void *)password);
  }
#line 600
  return (ret);
}
}
#line 604 "slave.c"
static void *_slave_thread(void *arg ) 
{ ice_config_t *config ;
  unsigned int interval ;
  relay_server *cleanup_relays ;
  int tmp ;
  ice_config_locks *tmp___0 ;
  ice_config_locks *tmp___1 ;
  ice_config_locks *tmp___2 ;
  ice_config_locks *tmp___3 ;

  {
#line 607
  interval = 0U;
#line 609
  source_recheck_mounts();

  thread_register("slave_thread");
  thread_check_in();

#line 611
  LOOP_SLAVE_THREAD:while (1) {
#line 616
    if (global.schedule_config_reread) {
#line 618
      event_config_read((void *)0);
#line 619
      global.schedule_config_reread = 0;
    }
#line 622
    thread_sleep(1000000UL);
#line 623
    if (slave_running == 0) {
#line 624
      break;
    }
#line 625
    if (rescan_relays == 0) {
#line 625
      interval ++;
#line 625
      if (max_interval > (unsigned int volatile   )interval) {
#line 626
        continue;
      }
    }

    thread_check_out();

#line 629
    if (max_interval <= (unsigned int volatile   )interval) {
#line 631
      log_write(errorlog, 4U, "slave/", "_slave_thread", "checking master stream list");
#line 632
      config = config_get_config();
#line 634
      interval = 0U;
#line 635
      max_interval = (unsigned int volatile   )config->master_update_interval;
#line 638
      tmp = update_from_master(config);
#line 638
      if (tmp) {
#line 639
        config = config_get_config();
      }
#line 641
      tmp___0 = config_locks();
#line 641
      thread_mutex_lock_c(& tmp___0->relay_lock, 641, (char *)"slave.c");
#line 643
      cleanup_relays = update_relays(& global.relays, config->relay);
#line 645
      config_release_config();
#line 647
      relay_check_streams(global.relays, cleanup_relays);
#line 648
      tmp___1 = config_locks();
#line 648
      thread_mutex_unlock_c(& tmp___1->relay_lock, 648, (char *)"slave.c");
    } else {
#line 652
      log_write(errorlog, 4U, "slave/", "_slave_thread", "rescanning relay lists");
#line 653
      tmp___2 = config_locks();
#line 653
      thread_mutex_lock_c(& tmp___2->relay_lock, 653, (char *)"slave.c");
#line 654
      relay_check_streams(global.master_relays, (relay_server *)((void *)0));
#line 655
      relay_check_streams(global.relays, (relay_server *)((void *)0));
#line 656
      tmp___3 = config_locks();
#line 656
      thread_mutex_unlock_c(& tmp___3->relay_lock, 656, (char *)"slave.c");
    }
#line 658

    thread_check_in();
    __DSU_update("");

    rescan_relays = (int volatile   )0;
#line 659
    if (update_settings) {
#line 661
      update_settings = 0;
#line 662
      source_recheck_mounts();
    }
  }

  thread_deregister("slave_thread");

#line 665
  log_write(errorlog, 4U, "slave/", "_slave_thread", "shutting down current relays");
#line 666
  relay_check_streams((relay_server *)((void *)0), global.relays);
#line 667
  relay_check_streams((relay_server *)((void *)0), global.master_relays);
#line 669
  log_write(errorlog, 3U, "slave/", "_slave_thread", "Slave thread shutdown complete");
#line 671
  return ((void *)0);
}
}
#line 1 "cil-bsDGK87a.o"
#pragma merger(0,"/tmp/cil-mfReYs0i.i","")
#line 1 "./src/cfgfile.o_saved.c"
#pragma merger(0,"./cfgfile.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 656 "/usr/include/libxml2/libxml/tree.h"
extern void xmlFreeDoc(xmlDocPtr cur ) ;
#line 794
extern xmlNodePtr xmlDocGetRootElement(xmlDocPtr doc ) ;
#line 800
extern int xmlIsBlankNode(xmlNodePtr node ) ;
#line 900
extern xmlChar *xmlGetProp(xmlNodePtr node , xmlChar const   *name ) ;
#line 921
extern xmlChar *xmlNodeListGetString(xmlDocPtr doc , xmlNodePtr list , int inLine ) ;
#line 808 "/usr/include/libxml2/libxml/parser.h"
extern void xmlInitParser(void) ;
#line 829
extern xmlDocPtr xmlParseFile(char const   *filename ) ;
#line 83 "auth.h"
auth_t *auth_get_authenticator(xmlNodePtr node ) ;
#line 84
void auth_release(auth_t *authenticator ) ;
#line 179 "cfgfile.h"
int config_parse_file(char const   *filename , ice_config_t *configuration ) ;
#line 182
void config_set_config(ice_config_t *config ) ;
#line 183
void config_clear(ice_config_t *c ) ;
#line 191
ice_config_t *config_grab_config(void) ;
#line 30 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_LOCATION  =    (unsigned char *)"Earth";
#line 31 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_ADMIN  =    (unsigned char *)"icemaster@localhost";
#line 32 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_SOURCE_PASSWORD  =    (unsigned char *)"changeme";
#line 34 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_MASTER_USERNAME  =    (unsigned char *)"relay";
#line 35 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_SHOUTCAST_MOUNT  =    (unsigned char *)"/stream";
#line 36 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_HOSTNAME  =    (unsigned char *)"localhost";
#line 37 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_ACCESS_LOG  =    (unsigned char *)"access.log";
#line 38 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_ERROR_LOG  =    (unsigned char *)"error.log";
#line 60 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_BASE_DIR  =    (unsigned char *)"/usr/local/icecast";
#line 61 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_LOG_DIR  =    (unsigned char *)"/usr/local/icecast/logs";
#line 62 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_WEBROOT_DIR  =    (unsigned char *)"/usr/local/icecast/webroot";
#line 63 "cfgfile.c"
static unsigned char *CONFIG_DEFAULT_ADMINROOT_DIR  =    (unsigned char *)"/usr/local/icecast/admin";
#line 71 "cfgfile.c"
static ice_config_t _current_configuration  ;
#line 72 "cfgfile.c"
static ice_config_locks _locks  ;
#line 74
static void _set_defaults(ice_config_t *configuration ) ;
#line 75
static void _parse_root(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 76
static void _parse_limits(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 77
static void _parse_directory(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 78
static void _parse_paths(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 79
static void _parse_logging(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 80
static void _parse_security(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 81
static void _parse_authentication(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 83
static void _parse_relay(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 84
static void _parse_mount(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 85
static void _parse_listen_socket(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 87
static void _add_server(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) ;
#line 89 "cfgfile.c"
static void create_locks(void) 
{ 

  {
#line 90
  thread_mutex_create_c(& _locks.relay_lock, 90, (char *)"cfgfile.c");
#line 91
  thread_rwlock_create_c(& _locks.config_lock, 91, (char *)"cfgfile.c");
#line 92
  return;
}
}
#line 94 "cfgfile.c"
static void release_locks(void) 
{ 

  {
#line 95
  thread_mutex_destroy(& _locks.relay_lock);
#line 96
  thread_rwlock_destroy(& _locks.config_lock);
#line 97
  return;
}
}
#line 99 "cfgfile.c"
void config_initialize(void) 
{ 

  {
#line 100
  create_locks();
#line 101
  return;
}
}
#line 103 "cfgfile.c"
void config_shutdown(void) 
{ 

  {
#line 104
  config_get_config();
#line 105
  config_clear(& _current_configuration);
#line 106
  config_release_config();
#line 107
  release_locks();
#line 108
  return;
}
}
#line 110 "cfgfile.c"
void config_init_configuration(ice_config_t *configuration ) 
{ 

  {
#line 112
  memset((void *)configuration, 0, sizeof(ice_config_t ));
#line 113
  _set_defaults(configuration);
#line 114
  return;
}
}
#line 116 "cfgfile.c"
static void config_clear_mount(mount_proxy *mount ) 
{ config_options_t *option ;
  config_options_t *nextopt ;

  {
#line 120
  ((*xmlFree))((void *)mount->mountname);
#line 121
  ((*xmlFree))((void *)mount->username);
#line 122
  ((*xmlFree))((void *)mount->password);
#line 123
  ((*xmlFree))((void *)mount->dumpfile);
#line 124
  ((*xmlFree))((void *)mount->intro_filename);
#line 125
  ((*xmlFree))((void *)mount->on_connect);
#line 126
  ((*xmlFree))((void *)mount->on_disconnect);
#line 127
  ((*xmlFree))((void *)mount->fallback_mount);
#line 128
  ((*xmlFree))((void *)mount->stream_name);
#line 129
  ((*xmlFree))((void *)mount->stream_description);
#line 130
  ((*xmlFree))((void *)mount->stream_url);
#line 131
  ((*xmlFree))((void *)mount->stream_genre);
#line 132
  ((*xmlFree))((void *)mount->bitrate);
#line 133
  ((*xmlFree))((void *)mount->type);
#line 134
  ((*xmlFree))((void *)mount->cluster_password);
#line 136
  ((*xmlFree))((void *)mount->auth_type);
#line 137
  option = mount->auth_options;
#line 138
  while (option) {
#line 140
    nextopt = option->next;
#line 141
    ((*xmlFree))((void *)option->name);
#line 142
    ((*xmlFree))((void *)option->value);
#line 143
    free((void *)option);
#line 144
    option = nextopt;
  }
#line 146
  auth_release(mount->auth);
#line 147
  free((void *)mount);
#line 148
  return;
}
}
#line 151 "cfgfile.c"
void config_clear(ice_config_t *c ) 
{ ice_config_dir_t *dirnode ;
  ice_config_dir_t *nextdirnode ;
  relay_server *relay ;
  relay_server *nextrelay ;
  mount_proxy *mount ;
  mount_proxy *nextmount ;
  aliases *alias ;
  aliases *nextalias ;
  int i ;

  {
#line 159
  if (c->config_filename) {
#line 160
    free((void *)c->config_filename);
  }
#line 162
  if (c->location) {
#line 162
    if ((unsigned int )c->location != (unsigned int )CONFIG_DEFAULT_LOCATION) {
#line 163
      ((*xmlFree))((void *)c->location);
    }
  }
#line 164
  if (c->admin) {
#line 164
    if ((unsigned int )c->admin != (unsigned int )CONFIG_DEFAULT_ADMIN) {
#line 165
      ((*xmlFree))((void *)c->admin);
    }
  }
#line 166
  if (c->source_password) {
#line 166
    if ((unsigned int )c->source_password != (unsigned int )CONFIG_DEFAULT_SOURCE_PASSWORD) {
#line 167
      ((*xmlFree))((void *)c->source_password);
    }
  }
#line 168
  if (c->admin_username) {
#line 169
    ((*xmlFree))((void *)c->admin_username);
  }
#line 170
  if (c->admin_password) {
#line 171
    ((*xmlFree))((void *)c->admin_password);
  }
#line 172
  if (c->relay_username) {
#line 173
    ((*xmlFree))((void *)c->relay_username);
  }
#line 174
  if (c->relay_password) {
#line 175
    ((*xmlFree))((void *)c->relay_password);
  }
#line 176
  if (c->hostname) {
#line 176
    if ((unsigned int )c->hostname != (unsigned int )CONFIG_DEFAULT_HOSTNAME) {
#line 177
      ((*xmlFree))((void *)c->hostname);
    }
  }
#line 178
  if (c->base_dir) {
#line 178
    if ((unsigned int )c->base_dir != (unsigned int )CONFIG_DEFAULT_BASE_DIR) {
#line 179
      ((*xmlFree))((void *)c->base_dir);
    }
  }
#line 180
  if (c->log_dir) {
#line 180
    if ((unsigned int )c->log_dir != (unsigned int )CONFIG_DEFAULT_LOG_DIR) {
#line 181
      ((*xmlFree))((void *)c->log_dir);
    }
  }
#line 182
  if (c->webroot_dir) {
#line 182
    if ((unsigned int )c->webroot_dir != (unsigned int )CONFIG_DEFAULT_WEBROOT_DIR) {
#line 183
      ((*xmlFree))((void *)c->webroot_dir);
    }
  }
#line 184
  if (c->adminroot_dir) {
#line 184
    if ((unsigned int )c->adminroot_dir != (unsigned int )CONFIG_DEFAULT_ADMINROOT_DIR) {
#line 185
      ((*xmlFree))((void *)c->adminroot_dir);
    }
  }
#line 186
  if (c->pidfile) {
#line 187
    ((*xmlFree))((void *)c->pidfile);
  }
#line 188
  if (c->playlist_log) {
#line 188
    if ((unsigned int )c->playlist_log != (unsigned int )((void *)0)) {
#line 189
      ((*xmlFree))((void *)c->playlist_log);
    }
  }
#line 190
  if (c->access_log) {
#line 190
    if ((unsigned int )c->access_log != (unsigned int )CONFIG_DEFAULT_ACCESS_LOG) {
#line 191
      ((*xmlFree))((void *)c->access_log);
    }
  }
#line 192
  if (c->error_log) {
#line 192
    if ((unsigned int )c->error_log != (unsigned int )CONFIG_DEFAULT_ERROR_LOG) {
#line 193
      ((*xmlFree))((void *)c->error_log);
    }
  }
#line 194
  if (c->shoutcast_mount) {
#line 194
    if ((unsigned int )c->shoutcast_mount != (unsigned int )CONFIG_DEFAULT_SHOUTCAST_MOUNT) {
#line 195
      ((*xmlFree))((void *)c->shoutcast_mount);
    }
  }
#line 196
  i = 0;
#line 196
  while (i < 20) {
#line 197
    if (c->listeners[i].bind_address) {
#line 197
      ((*xmlFree))((void *)c->listeners[i].bind_address);
    }
#line 196
    i ++;
  }
#line 199
  if (c->master_server) {
#line 199
    ((*xmlFree))((void *)c->master_server);
  }
#line 200
  if (c->master_username) {
#line 200
    ((*xmlFree))((void *)c->master_username);
  }
#line 201
  if (c->master_password) {
#line 201
    ((*xmlFree))((void *)c->master_password);
  }
#line 202
  if (c->user) {
#line 202
    ((*xmlFree))((void *)c->user);
  }
#line 203
  if (c->group) {
#line 203
    ((*xmlFree))((void *)c->group);
  }
#line 205
  thread_mutex_lock_c(& _locks.relay_lock, 205, (char *)"cfgfile.c");
#line 206
  relay = c->relay;
#line 207
  while (relay) {
#line 208
    nextrelay = relay->next;
#line 209
    ((*xmlFree))((void *)relay->server);
#line 210
    ((*xmlFree))((void *)relay->mount);
#line 211
    ((*xmlFree))((void *)relay->localmount);
#line 212
    free((void *)relay);
#line 213
    relay = nextrelay;
  }
#line 215
  thread_mutex_unlock_c(& _locks.relay_lock, 215, (char *)"cfgfile.c");
#line 217
  mount = c->mounts;
#line 218
  while (mount) {
#line 219
    nextmount = mount->next;
#line 220
    config_clear_mount(mount);
#line 221
    mount = nextmount;
  }
#line 224
  alias = c->aliases;
#line 225
  while (alias) {
#line 226
    nextalias = alias->next;
#line 227
    ((*xmlFree))((void *)alias->source);
#line 228
    ((*xmlFree))((void *)alias->destination);
#line 229
    ((*xmlFree))((void *)alias->bind_address);
#line 230
    free((void *)alias);
#line 231
    alias = nextalias;
  }
#line 234
  dirnode = c->dir_list;
#line 235
  while (dirnode) {
#line 236
    nextdirnode = dirnode->next;
#line 237
    ((*xmlFree))((void *)dirnode->host);
#line 238
    free((void *)dirnode);
#line 239
    dirnode = nextdirnode;
  }
#line 242
  i = 0;
#line 243
  while (i < c->num_yp_directories) {
#line 245
    ((*xmlFree))((void *)c->yp_url[i]);
#line 246
    i ++;
  }
#line 250
  memset((void *)c, 0, sizeof(ice_config_t ));
#line 251
  return;
}
}
#line 253 "cfgfile.c"
int config_initial_parse_file(char const   *filename ) 
{ int tmp ;

  {
#line 256
  tmp = config_parse_file(filename, & _current_configuration);
#line 256
  return (tmp);
}
}
#line 259 "cfgfile.c"
int config_parse_file(char const   *filename , ice_config_t *configuration ) 
{ xmlDocPtr doc ;
  xmlNodePtr node ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___28 ;

  {
#line 264
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 264
    return (-1);
  } else {
#line 264
    if (0) {
#line 264
      __s1_len = strlen(filename);
#line 264
      __s2_len = strlen("");
#line 264
      if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
             1U)) {
        goto _L___0;
      } else {
#line 264
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 264
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
                 1U)) {
#line 264
            tmp___8 = 1;
          } else {
#line 264
            if (__s2_len >= 4U) {
#line 264
              tmp___8 = 1;
            } else {
#line 264
              tmp___8 = 0;
            }
          }
        } else {
#line 264
          tmp___8 = 0;
        }
      }
#line 264
      if (tmp___8) {
#line 264
        tmp___4 = __builtin_strcmp(filename, "");
      } else {
#line 264
        tmp___7 = __builtin_strcmp(filename, "");
#line 264
        tmp___4 = tmp___7;
      }
    } else {
#line 264
      tmp___7 = __builtin_strcmp(filename, "");
#line 264
      tmp___4 = tmp___7;
    }
#line 264
    if (tmp___4 == 0) {
#line 264
      return (-1);
    }
  }
#line 266
  xmlInitParser();
#line 267
  doc = xmlParseFile(filename);
#line 268
  if ((unsigned int )doc == (unsigned int )((void *)0)) {
#line 269
    return (-4);
  }
#line 272
  node = xmlDocGetRootElement(doc);
#line 273
  if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 274
    xmlFreeDoc(doc);
#line 275
    xmlCleanupParser();
#line 276
    return (-2);
  }
#line 279
  if (0) {
#line 279
    __s1_len___0 = strlen((char const   *)node->name);
#line 279
    __s2_len___0 = strlen("icecast");
#line 279
    if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
           1U)) {
      goto _L___2;
    } else {
#line 279
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 279
        if (! ((unsigned int )((void const   *)("icecast" + 1)) - (unsigned int )((void const   *)"icecast") ==
               1U)) {
#line 279
          tmp___18 = 1;
        } else {
#line 279
          if (__s2_len___0 >= 4U) {
#line 279
            tmp___18 = 1;
          } else {
#line 279
            tmp___18 = 0;
          }
        }
      } else {
#line 279
        tmp___18 = 0;
      }
    }
#line 279
    if (tmp___18) {
#line 279
      tmp___14 = __builtin_strcmp((char const   *)node->name, "icecast");
    } else {
#line 279
      tmp___17 = __builtin_strcmp((char const   *)node->name, "icecast");
#line 279
      tmp___14 = tmp___17;
    }
  } else {
#line 279
    tmp___17 = __builtin_strcmp((char const   *)node->name, "icecast");
#line 279
    tmp___14 = tmp___17;
  }
#line 279
  if (tmp___14 != 0) {
#line 280
    xmlFreeDoc(doc);
#line 281
    xmlCleanupParser();
#line 282
    return (-3);
  }
#line 285
  config_init_configuration(configuration);
#line 287
  tmp___28 = __strdup(filename);
#line 287
  configuration->config_filename = tmp___28;
#line 289
  _parse_root(doc, node->children, configuration);
#line 291
  xmlFreeDoc(doc);
#line 293
  return (0);
}
}
#line 296 "cfgfile.c"
int config_parse_cmdline(int arg , char **argv ) 
{ 

  {
#line 298
  return (0);
}
}
#line 301 "cfgfile.c"
ice_config_locks *config_locks(void) 
{ 

  {
#line 303
  return (& _locks);
}
}
#line 306 "cfgfile.c"
void config_release_config(void) 
{ 

  {
#line 308
  thread_rwlock_unlock_c(& _locks.config_lock, 308, (char *)"cfgfile.c");
#line 309
  return;
}
}
#line 311 "cfgfile.c"
ice_config_t *config_get_config(void) 
{ 

  {
#line 313
  thread_rwlock_rlock_c(& _locks.config_lock, 313, (char *)"cfgfile.c");
#line 314
  return (& _current_configuration);
}
}
#line 317 "cfgfile.c"
ice_config_t *config_grab_config(void) 
{ 

  {
#line 319
  thread_rwlock_wlock_c(& _locks.config_lock, 319, (char *)"cfgfile.c");
#line 320
  return (& _current_configuration);
}
}
#line 324 "cfgfile.c"
void config_set_config(ice_config_t *config ) 
{ 

  {
#line 325
  memcpy((void * __restrict  )(& _current_configuration), (void const   * __restrict  )config,
         sizeof(ice_config_t ));
#line 326
  return;
}
}
#line 328 "cfgfile.c"
ice_config_t *config_get_config_unlocked(void) 
{ 

  {
#line 330
  return (& _current_configuration);
}
}
#line 333 "cfgfile.c"
static void _set_defaults(ice_config_t *configuration ) 
{ 

  {
#line 335
  configuration->location = (char *)CONFIG_DEFAULT_LOCATION;
#line 336
  configuration->admin = (char *)CONFIG_DEFAULT_ADMIN;
#line 337
  configuration->client_limit = 256;
#line 338
  configuration->source_limit = 16;
#line 339
  configuration->queue_size_limit = 512000U;
#line 340
  configuration->threadpool_size = 4;
#line 341
  configuration->client_timeout = 30;
#line 342
  configuration->header_timeout = 15;
#line 343
  configuration->source_timeout = 10;
#line 344
  configuration->source_password = (char *)CONFIG_DEFAULT_SOURCE_PASSWORD;
#line 345
  configuration->shoutcast_mount = (char *)CONFIG_DEFAULT_SHOUTCAST_MOUNT;
#line 346
  configuration->ice_login = 0;
#line 347
  configuration->fileserve = 1;
#line 348
  configuration->touch_interval = 5;
#line 349
  configuration->on_demand = 0;
#line 350
  configuration->dir_list = (ice_config_dir_t *)((void *)0);
#line 351
  configuration->hostname = (char *)CONFIG_DEFAULT_HOSTNAME;
#line 352
  configuration->port = 0;
#line 353
  configuration->listeners[0].port = 0;
#line 354
  configuration->listeners[0].bind_address = (char *)((void *)0);
#line 355
  configuration->listeners[0].shoutcast_compat = 0;
#line 356
  configuration->master_server = (char *)((void *)0);
#line 357
  configuration->master_server_port = 0;
#line 358
  configuration->master_update_interval = 120;
#line 359
  configuration->master_username = (char *)xmlStrdup((xmlChar const   *)CONFIG_DEFAULT_MASTER_USERNAME);
#line 360
  configuration->master_password = (char *)((void *)0);
#line 361
  configuration->base_dir = (char *)CONFIG_DEFAULT_BASE_DIR;
#line 362
  configuration->log_dir = (char *)CONFIG_DEFAULT_LOG_DIR;
#line 363
  configuration->webroot_dir = (char *)CONFIG_DEFAULT_WEBROOT_DIR;
#line 364
  configuration->adminroot_dir = (char *)CONFIG_DEFAULT_ADMINROOT_DIR;
#line 365
  configuration->playlist_log = (char *)((void *)0);
#line 366
  configuration->access_log = (char *)CONFIG_DEFAULT_ACCESS_LOG;
#line 367
  configuration->error_log = (char *)CONFIG_DEFAULT_ERROR_LOG;
#line 368
  configuration->loglevel = 4;
#line 369
  configuration->chroot = 0;
#line 370
  configuration->chuid = 0;
#line 371
  configuration->user = (char *)((void *)0);
#line 372
  configuration->group = (char *)((void *)0);
#line 373
  configuration->num_yp_directories = 0;
#line 374
  configuration->relay_username = (char *)xmlStrdup((xmlChar const   *)CONFIG_DEFAULT_MASTER_USERNAME);
#line 375
  configuration->relay_password = (char *)((void *)0);
#line 377
  configuration->burst_size = 65536U;
#line 378
  return;
}
}
#line 380 "cfgfile.c"
static void _parse_root(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *tmp ;
  int tmp___0 ;
  char *mount ;
  char *pass ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___53 ;
  int tmp___56 ;
  int tmp___57 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___63 ;
  int tmp___66 ;
  int tmp___67 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___73 ;
  int tmp___76 ;
  int tmp___77 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___83 ;
  int tmp___86 ;
  int tmp___87 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___93 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___103 ;
  int tmp___106 ;
  int tmp___107 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___113 ;
  int tmp___116 ;
  int tmp___117 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___123 ;
  int tmp___126 ;
  int tmp___127 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___133 ;
  int tmp___136 ;
  int tmp___137 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___143 ;
  int tmp___146 ;
  int tmp___147 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___153 ;
  int tmp___156 ;
  int tmp___157 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___163 ;
  int tmp___166 ;
  int tmp___167 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___173 ;
  int tmp___176 ;
  int tmp___177 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___183 ;
  int tmp___186 ;
  int tmp___187 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___193 ;
  int tmp___196 ;
  int tmp___197 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___203 ;
  int tmp___206 ;
  int tmp___207 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___213 ;
  int tmp___216 ;
  int tmp___217 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___223 ;
  int tmp___226 ;
  int tmp___227 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___233 ;
  int tmp___236 ;
  int tmp___237 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___243 ;
  int tmp___246 ;
  int tmp___247 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___253 ;
  int tmp___256 ;
  int tmp___257 ;

  {
#line 385
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 387
    tmp___0 = xmlIsBlankNode(node);
#line 387
    if (tmp___0) {
      goto __Cont;
    }
#line 389
    if (0) {
#line 389
      __s1_len___22 = strlen((char const   *)node->name);
#line 389
      __s2_len___22 = strlen("location");
#line 389
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___46;
      } else {
#line 389
        if (__s1_len___22 >= 4U) {
          _L___46: /* CIL Label */ 
#line 389
          if (! ((unsigned int )((void const   *)("location" + 1)) - (unsigned int )((void const   *)"location") ==
                 1U)) {
#line 389
            tmp___257 = 1;
          } else {
#line 389
            if (__s2_len___22 >= 4U) {
#line 389
              tmp___257 = 1;
            } else {
#line 389
              tmp___257 = 0;
            }
          }
        } else {
#line 389
          tmp___257 = 0;
        }
      }
#line 389
      if (tmp___257) {
#line 389
        tmp___253 = __builtin_strcmp((char const   *)node->name, "location");
      } else {
#line 389
        tmp___256 = __builtin_strcmp((char const   *)node->name, "location");
#line 389
        tmp___253 = tmp___256;
      }
    } else {
#line 389
      tmp___256 = __builtin_strcmp((char const   *)node->name, "location");
#line 389
      tmp___253 = tmp___256;
    }
#line 389
    if (tmp___253 == 0) {
#line 390
      if (configuration->location) {
#line 390
        if ((unsigned int )configuration->location != (unsigned int )CONFIG_DEFAULT_LOCATION) {
#line 390
          ((*xmlFree))((void *)configuration->location);
        }
      }
#line 391
      configuration->location = (char *)xmlNodeListGetString(doc, node->children,
                                                             1);
    } else {
#line 392
      if (0) {
#line 392
        __s1_len___21 = strlen((char const   *)node->name);
#line 392
        __s2_len___21 = strlen("admin");
#line 392
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___44;
        } else {
#line 392
          if (__s1_len___21 >= 4U) {
            _L___44: /* CIL Label */ 
#line 392
            if (! ((unsigned int )((void const   *)("admin" + 1)) - (unsigned int )((void const   *)"admin") ==
                   1U)) {
#line 392
              tmp___247 = 1;
            } else {
#line 392
              if (__s2_len___21 >= 4U) {
#line 392
                tmp___247 = 1;
              } else {
#line 392
                tmp___247 = 0;
              }
            }
          } else {
#line 392
            tmp___247 = 0;
          }
        }
#line 392
        if (tmp___247) {
#line 392
          tmp___243 = __builtin_strcmp((char const   *)node->name, "admin");
        } else {
#line 392
          tmp___246 = __builtin_strcmp((char const   *)node->name, "admin");
#line 392
          tmp___243 = tmp___246;
        }
      } else {
#line 392
        tmp___246 = __builtin_strcmp((char const   *)node->name, "admin");
#line 392
        tmp___243 = tmp___246;
      }
#line 392
      if (tmp___243 == 0) {
#line 393
        if (configuration->admin) {
#line 393
          if ((unsigned int )configuration->admin != (unsigned int )CONFIG_DEFAULT_ADMIN) {
#line 393
            ((*xmlFree))((void *)configuration->admin);
          }
        }
#line 394
        configuration->admin = (char *)xmlNodeListGetString(doc, node->children, 1);
      } else {
#line 395
        if (0) {
#line 395
          __s1_len___20 = strlen((char const   *)node->name);
#line 395
          __s2_len___20 = strlen("authentication");
#line 395
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___42;
          } else {
#line 395
            if (__s1_len___20 >= 4U) {
              _L___42: /* CIL Label */ 
#line 395
              if (! ((unsigned int )((void const   *)("authentication" + 1)) - (unsigned int )((void const   *)"authentication") ==
                     1U)) {
#line 395
                tmp___237 = 1;
              } else {
#line 395
                if (__s2_len___20 >= 4U) {
#line 395
                  tmp___237 = 1;
                } else {
#line 395
                  tmp___237 = 0;
                }
              }
            } else {
#line 395
              tmp___237 = 0;
            }
          }
#line 395
          if (tmp___237) {
#line 395
            tmp___233 = __builtin_strcmp((char const   *)node->name, "authentication");
          } else {
#line 395
            tmp___236 = __builtin_strcmp((char const   *)node->name, "authentication");
#line 395
            tmp___233 = tmp___236;
          }
        } else {
#line 395
          tmp___236 = __builtin_strcmp((char const   *)node->name, "authentication");
#line 395
          tmp___233 = tmp___236;
        }
#line 395
        if (tmp___233 == 0) {
#line 396
          _parse_authentication(doc, node->children, configuration);
        } else {
#line 397
          if (0) {
#line 397
            __s1_len___19 = strlen((char const   *)node->name);
#line 397
            __s2_len___19 = strlen("source-password");
#line 397
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___40;
            } else {
#line 397
              if (__s1_len___19 >= 4U) {
                _L___40: /* CIL Label */ 
#line 397
                if (! ((unsigned int )((void const   *)("source-password" + 1)) -
                       (unsigned int )((void const   *)"source-password") == 1U)) {
#line 397
                  tmp___227 = 1;
                } else {
#line 397
                  if (__s2_len___19 >= 4U) {
#line 397
                    tmp___227 = 1;
                  } else {
#line 397
                    tmp___227 = 0;
                  }
                }
              } else {
#line 397
                tmp___227 = 0;
              }
            }
#line 397
            if (tmp___227) {
#line 397
              tmp___223 = __builtin_strcmp((char const   *)node->name, "source-password");
            } else {
#line 397
              tmp___226 = __builtin_strcmp((char const   *)node->name, "source-password");
#line 397
              tmp___223 = tmp___226;
            }
          } else {
#line 397
            tmp___226 = __builtin_strcmp((char const   *)node->name, "source-password");
#line 397
            tmp___223 = tmp___226;
          }
#line 397
          if (tmp___223 == 0) {
#line 400
            mount = (char *)xmlGetProp(node, (xmlChar const   *)"mount");
#line 400
            if ((unsigned int )mount != (unsigned int )((void *)0)) {
#line 401
              pass = (char *)xmlNodeListGetString(doc, node->children, 1);
            } else {
#line 405
              if (configuration->source_password) {
#line 405
                if ((unsigned int )configuration->source_password != (unsigned int )CONFIG_DEFAULT_SOURCE_PASSWORD) {
#line 405
                  ((*xmlFree))((void *)configuration->source_password);
                }
              }
#line 406
              configuration->source_password = (char *)xmlNodeListGetString(doc, node->children,
                                                                            1);
            }
          } else {
#line 408
            if (0) {
#line 408
              __s1_len___18 = strlen((char const   *)node->name);
#line 408
              __s2_len___18 = strlen("icelogin");
#line 408
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___38;
              } else {
#line 408
                if (__s1_len___18 >= 4U) {
                  _L___38: /* CIL Label */ 
#line 408
                  if (! ((unsigned int )((void const   *)("icelogin" + 1)) - (unsigned int )((void const   *)"icelogin") ==
                         1U)) {
#line 408
                    tmp___217 = 1;
                  } else {
#line 408
                    if (__s2_len___18 >= 4U) {
#line 408
                      tmp___217 = 1;
                    } else {
#line 408
                      tmp___217 = 0;
                    }
                  }
                } else {
#line 408
                  tmp___217 = 0;
                }
              }
#line 408
              if (tmp___217) {
#line 408
                tmp___213 = __builtin_strcmp((char const   *)node->name, "icelogin");
              } else {
#line 408
                tmp___216 = __builtin_strcmp((char const   *)node->name, "icelogin");
#line 408
                tmp___213 = tmp___216;
              }
            } else {
#line 408
              tmp___216 = __builtin_strcmp((char const   *)node->name, "icelogin");
#line 408
              tmp___213 = tmp___216;
            }
#line 408
            if (tmp___213 == 0) {
#line 409
              tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 410
              configuration->ice_login = atoi__extinline((char const   *)tmp);
#line 411
              if (tmp) {
#line 411
                ((*xmlFree))((void *)tmp);
              }
            } else {
#line 412
              if (0) {
#line 412
                __s1_len___17 = strlen((char const   *)node->name);
#line 412
                __s2_len___17 = strlen("fileserve");
#line 412
                if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                       1U)) {
                  goto _L___36;
                } else {
#line 412
                  if (__s1_len___17 >= 4U) {
                    _L___36: /* CIL Label */ 
#line 412
                    if (! ((unsigned int )((void const   *)("fileserve" + 1)) - (unsigned int )((void const   *)"fileserve") ==
                           1U)) {
#line 412
                      tmp___207 = 1;
                    } else {
#line 412
                      if (__s2_len___17 >= 4U) {
#line 412
                        tmp___207 = 1;
                      } else {
#line 412
                        tmp___207 = 0;
                      }
                    }
                  } else {
#line 412
                    tmp___207 = 0;
                  }
                }
#line 412
                if (tmp___207) {
#line 412
                  tmp___203 = __builtin_strcmp((char const   *)node->name, "fileserve");
                } else {
#line 412
                  tmp___206 = __builtin_strcmp((char const   *)node->name, "fileserve");
#line 412
                  tmp___203 = tmp___206;
                }
              } else {
#line 412
                tmp___206 = __builtin_strcmp((char const   *)node->name, "fileserve");
#line 412
                tmp___203 = tmp___206;
              }
#line 412
              if (tmp___203 == 0) {
#line 413
                tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 414
                configuration->fileserve = atoi__extinline((char const   *)tmp);
#line 415
                if (tmp) {
#line 415
                  ((*xmlFree))((void *)tmp);
                }
              } else {
#line 416
                if (0) {
#line 416
                  __s1_len___16 = strlen((char const   *)node->name);
#line 416
                  __s2_len___16 = strlen("relays-on-demand");
#line 416
                  if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                         1U)) {
                    goto _L___34;
                  } else {
#line 416
                    if (__s1_len___16 >= 4U) {
                      _L___34: /* CIL Label */ 
#line 416
                      if (! ((unsigned int )((void const   *)("relays-on-demand" +
                                                              1)) - (unsigned int )((void const   *)"relays-on-demand") ==
                             1U)) {
#line 416
                        tmp___197 = 1;
                      } else {
#line 416
                        if (__s2_len___16 >= 4U) {
#line 416
                          tmp___197 = 1;
                        } else {
#line 416
                          tmp___197 = 0;
                        }
                      }
                    } else {
#line 416
                      tmp___197 = 0;
                    }
                  }
#line 416
                  if (tmp___197) {
#line 416
                    tmp___193 = __builtin_strcmp((char const   *)node->name, "relays-on-demand");
                  } else {
#line 416
                    tmp___196 = __builtin_strcmp((char const   *)node->name, "relays-on-demand");
#line 416
                    tmp___193 = tmp___196;
                  }
                } else {
#line 416
                  tmp___196 = __builtin_strcmp((char const   *)node->name, "relays-on-demand");
#line 416
                  tmp___193 = tmp___196;
                }
#line 416
                if (tmp___193 == 0) {
#line 417
                  tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 418
                  configuration->on_demand = atoi__extinline((char const   *)tmp);
#line 419
                  if (tmp) {
#line 419
                    ((*xmlFree))((void *)tmp);
                  }
                } else {
#line 420
                  if (0) {
#line 420
                    __s1_len___15 = strlen((char const   *)node->name);
#line 420
                    __s2_len___15 = strlen("hostname");
#line 420
                    if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                           1U)) {
                      goto _L___32;
                    } else {
#line 420
                      if (__s1_len___15 >= 4U) {
                        _L___32: /* CIL Label */ 
#line 420
                        if (! ((unsigned int )((void const   *)("hostname" + 1)) -
                               (unsigned int )((void const   *)"hostname") == 1U)) {
#line 420
                          tmp___187 = 1;
                        } else {
#line 420
                          if (__s2_len___15 >= 4U) {
#line 420
                            tmp___187 = 1;
                          } else {
#line 420
                            tmp___187 = 0;
                          }
                        }
                      } else {
#line 420
                        tmp___187 = 0;
                      }
                    }
#line 420
                    if (tmp___187) {
#line 420
                      tmp___183 = __builtin_strcmp((char const   *)node->name, "hostname");
                    } else {
#line 420
                      tmp___186 = __builtin_strcmp((char const   *)node->name, "hostname");
#line 420
                      tmp___183 = tmp___186;
                    }
                  } else {
#line 420
                    tmp___186 = __builtin_strcmp((char const   *)node->name, "hostname");
#line 420
                    tmp___183 = tmp___186;
                  }
#line 420
                  if (tmp___183 == 0) {
#line 421
                    if (configuration->hostname) {
#line 421
                      if ((unsigned int )configuration->hostname != (unsigned int )CONFIG_DEFAULT_HOSTNAME) {
#line 421
                        ((*xmlFree))((void *)configuration->hostname);
                      }
                    }
#line 422
                    configuration->hostname = (char *)xmlNodeListGetString(doc, node->children,
                                                                           1);
                  } else {
#line 423
                    if (0) {
#line 423
                      __s1_len___14 = strlen((char const   *)node->name);
#line 423
                      __s2_len___14 = strlen("listen-socket");
#line 423
                      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                             1U)) {
                        goto _L___30;
                      } else {
#line 423
                        if (__s1_len___14 >= 4U) {
                          _L___30: /* CIL Label */ 
#line 423
                          if (! ((unsigned int )((void const   *)("listen-socket" +
                                                                  1)) - (unsigned int )((void const   *)"listen-socket") ==
                                 1U)) {
#line 423
                            tmp___177 = 1;
                          } else {
#line 423
                            if (__s2_len___14 >= 4U) {
#line 423
                              tmp___177 = 1;
                            } else {
#line 423
                              tmp___177 = 0;
                            }
                          }
                        } else {
#line 423
                          tmp___177 = 0;
                        }
                      }
#line 423
                      if (tmp___177) {
#line 423
                        tmp___173 = __builtin_strcmp((char const   *)node->name, "listen-socket");
                      } else {
#line 423
                        tmp___176 = __builtin_strcmp((char const   *)node->name, "listen-socket");
#line 423
                        tmp___173 = tmp___176;
                      }
                    } else {
#line 423
                      tmp___176 = __builtin_strcmp((char const   *)node->name, "listen-socket");
#line 423
                      tmp___173 = tmp___176;
                    }
#line 423
                    if (tmp___173 == 0) {
#line 424
                      _parse_listen_socket(doc, node->children, configuration);
                    } else {
#line 425
                      if (0) {
#line 425
                        __s1_len___13 = strlen((char const   *)node->name);
#line 425
                        __s2_len___13 = strlen("port");
#line 425
                        if (! ((unsigned int )((void const   *)(node->name + 1)) -
                               (unsigned int )((void const   *)node->name) == 1U)) {
                          goto _L___28;
                        } else {
#line 425
                          if (__s1_len___13 >= 4U) {
                            _L___28: /* CIL Label */ 
#line 425
                            if (! ((unsigned int )((void const   *)("port" + 1)) -
                                   (unsigned int )((void const   *)"port") == 1U)) {
#line 425
                              tmp___167 = 1;
                            } else {
#line 425
                              if (__s2_len___13 >= 4U) {
#line 425
                                tmp___167 = 1;
                              } else {
#line 425
                                tmp___167 = 0;
                              }
                            }
                          } else {
#line 425
                            tmp___167 = 0;
                          }
                        }
#line 425
                        if (tmp___167) {
#line 425
                          tmp___163 = __builtin_strcmp((char const   *)node->name,
                                                       "port");
                        } else {
#line 425
                          tmp___166 = __builtin_strcmp((char const   *)node->name,
                                                       "port");
#line 425
                          tmp___163 = tmp___166;
                        }
                      } else {
#line 425
                        tmp___166 = __builtin_strcmp((char const   *)node->name, "port");
#line 425
                        tmp___163 = tmp___166;
                      }
#line 425
                      if (tmp___163 == 0) {
#line 426
                        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 427
                        configuration->port = atoi__extinline((char const   *)tmp);
#line 428
                        configuration->listeners[0].port = atoi__extinline((char const   *)tmp);
#line 429
                        if (tmp) {
#line 429
                          ((*xmlFree))((void *)tmp);
                        }
                      } else {
#line 430
                        if (0) {
#line 430
                          __s1_len___12 = strlen((char const   *)node->name);
#line 430
                          __s2_len___12 = strlen("bind-address");
#line 430
                          if (! ((unsigned int )((void const   *)(node->name + 1)) -
                                 (unsigned int )((void const   *)node->name) == 1U)) {
                            goto _L___26;
                          } else {
#line 430
                            if (__s1_len___12 >= 4U) {
                              _L___26: /* CIL Label */ 
#line 430
                              if (! ((unsigned int )((void const   *)("bind-address" +
                                                                      1)) - (unsigned int )((void const   *)"bind-address") ==
                                     1U)) {
#line 430
                                tmp___157 = 1;
                              } else {
#line 430
                                if (__s2_len___12 >= 4U) {
#line 430
                                  tmp___157 = 1;
                                } else {
#line 430
                                  tmp___157 = 0;
                                }
                              }
                            } else {
#line 430
                              tmp___157 = 0;
                            }
                          }
#line 430
                          if (tmp___157) {
#line 430
                            tmp___153 = __builtin_strcmp((char const   *)node->name,
                                                         "bind-address");
                          } else {
#line 430
                            tmp___156 = __builtin_strcmp((char const   *)node->name,
                                                         "bind-address");
#line 430
                            tmp___153 = tmp___156;
                          }
                        } else {
#line 430
                          tmp___156 = __builtin_strcmp((char const   *)node->name,
                                                       "bind-address");
#line 430
                          tmp___153 = tmp___156;
                        }
#line 430
                        if (tmp___153 == 0) {
#line 431
                          if (configuration->listeners[0].bind_address) {
#line 432
                            ((*xmlFree))((void *)configuration->listeners[0].bind_address);
                          }
#line 433
                          configuration->listeners[0].bind_address = (char *)xmlNodeListGetString(doc,
                                                                                                  node->children,
                                                                                                  1);
                        } else {
#line 434
                          if (0) {
#line 434
                            __s1_len___11 = strlen((char const   *)node->name);
#line 434
                            __s2_len___11 = strlen("master-server");
#line 434
                            if (! ((unsigned int )((void const   *)(node->name + 1)) -
                                   (unsigned int )((void const   *)node->name) ==
                                   1U)) {
                              goto _L___24;
                            } else {
#line 434
                              if (__s1_len___11 >= 4U) {
                                _L___24: /* CIL Label */ 
#line 434
                                if (! ((unsigned int )((void const   *)("master-server" +
                                                                        1)) - (unsigned int )((void const   *)"master-server") ==
                                       1U)) {
#line 434
                                  tmp___147 = 1;
                                } else {
#line 434
                                  if (__s2_len___11 >= 4U) {
#line 434
                                    tmp___147 = 1;
                                  } else {
#line 434
                                    tmp___147 = 0;
                                  }
                                }
                              } else {
#line 434
                                tmp___147 = 0;
                              }
                            }
#line 434
                            if (tmp___147) {
#line 434
                              tmp___143 = __builtin_strcmp((char const   *)node->name,
                                                           "master-server");
                            } else {
#line 434
                              tmp___146 = __builtin_strcmp((char const   *)node->name,
                                                           "master-server");
#line 434
                              tmp___143 = tmp___146;
                            }
                          } else {
#line 434
                            tmp___146 = __builtin_strcmp((char const   *)node->name,
                                                         "master-server");
#line 434
                            tmp___143 = tmp___146;
                          }
#line 434
                          if (tmp___143 == 0) {
#line 435
                            if (configuration->master_server) {
#line 435
                              ((*xmlFree))((void *)configuration->master_server);
                            }
#line 436
                            configuration->master_server = (char *)xmlNodeListGetString(doc,
                                                                                        node->children,
                                                                                        1);
                          } else {
#line 437
                            if (0) {
#line 437
                              __s1_len___10 = strlen((char const   *)node->name);
#line 437
                              __s2_len___10 = strlen("master-username");
#line 437
                              if (! ((unsigned int )((void const   *)(node->name +
                                                                      1)) - (unsigned int )((void const   *)node->name) ==
                                     1U)) {
                                goto _L___22;
                              } else {
#line 437
                                if (__s1_len___10 >= 4U) {
                                  _L___22: /* CIL Label */ 
#line 437
                                  if (! ((unsigned int )((void const   *)("master-username" +
                                                                          1)) - (unsigned int )((void const   *)"master-username") ==
                                         1U)) {
#line 437
                                    tmp___137 = 1;
                                  } else {
#line 437
                                    if (__s2_len___10 >= 4U) {
#line 437
                                      tmp___137 = 1;
                                    } else {
#line 437
                                      tmp___137 = 0;
                                    }
                                  }
                                } else {
#line 437
                                  tmp___137 = 0;
                                }
                              }
#line 437
                              if (tmp___137) {
#line 437
                                tmp___133 = __builtin_strcmp((char const   *)node->name,
                                                             "master-username");
                              } else {
#line 437
                                tmp___136 = __builtin_strcmp((char const   *)node->name,
                                                             "master-username");
#line 437
                                tmp___133 = tmp___136;
                              }
                            } else {
#line 437
                              tmp___136 = __builtin_strcmp((char const   *)node->name,
                                                           "master-username");
#line 437
                              tmp___133 = tmp___136;
                            }
#line 437
                            if (tmp___133 == 0) {
#line 438
                              if (configuration->master_username) {
#line 438
                                ((*xmlFree))((void *)configuration->master_username);
                              }
#line 439
                              configuration->master_username = (char *)xmlNodeListGetString(doc,
                                                                                            node->children,
                                                                                            1);
                            } else {
#line 440
                              if (0) {
#line 440
                                __s1_len___9 = strlen((char const   *)node->name);
#line 440
                                __s2_len___9 = strlen("master-password");
#line 440
                                if (! ((unsigned int )((void const   *)(node->name +
                                                                        1)) - (unsigned int )((void const   *)node->name) ==
                                       1U)) {
                                  goto _L___20;
                                } else {
#line 440
                                  if (__s1_len___9 >= 4U) {
                                    _L___20: /* CIL Label */ 
#line 440
                                    if (! ((unsigned int )((void const   *)("master-password" +
                                                                            1)) -
                                           (unsigned int )((void const   *)"master-password") ==
                                           1U)) {
#line 440
                                      tmp___127 = 1;
                                    } else {
#line 440
                                      if (__s2_len___9 >= 4U) {
#line 440
                                        tmp___127 = 1;
                                      } else {
#line 440
                                        tmp___127 = 0;
                                      }
                                    }
                                  } else {
#line 440
                                    tmp___127 = 0;
                                  }
                                }
#line 440
                                if (tmp___127) {
#line 440
                                  tmp___123 = __builtin_strcmp((char const   *)node->name,
                                                               "master-password");
                                } else {
#line 440
                                  tmp___126 = __builtin_strcmp((char const   *)node->name,
                                                               "master-password");
#line 440
                                  tmp___123 = tmp___126;
                                }
                              } else {
#line 440
                                tmp___126 = __builtin_strcmp((char const   *)node->name,
                                                             "master-password");
#line 440
                                tmp___123 = tmp___126;
                              }
#line 440
                              if (tmp___123 == 0) {
#line 441
                                if (configuration->master_password) {
#line 441
                                  ((*xmlFree))((void *)configuration->master_password);
                                }
#line 442
                                configuration->master_password = (char *)xmlNodeListGetString(doc,
                                                                                              node->children,
                                                                                              1);
                              } else {
#line 443
                                if (0) {
#line 443
                                  __s1_len___8 = strlen((char const   *)node->name);
#line 443
                                  __s2_len___8 = strlen("master-server-port");
#line 443
                                  if (! ((unsigned int )((void const   *)(node->name +
                                                                          1)) - (unsigned int )((void const   *)node->name) ==
                                         1U)) {
                                    goto _L___18;
                                  } else {
#line 443
                                    if (__s1_len___8 >= 4U) {
                                      _L___18: /* CIL Label */ 
#line 443
                                      if (! ((unsigned int )((void const   *)("master-server-port" +
                                                                              1)) -
                                             (unsigned int )((void const   *)"master-server-port") ==
                                             1U)) {
#line 443
                                        tmp___117 = 1;
                                      } else {
#line 443
                                        if (__s2_len___8 >= 4U) {
#line 443
                                          tmp___117 = 1;
                                        } else {
#line 443
                                          tmp___117 = 0;
                                        }
                                      }
                                    } else {
#line 443
                                      tmp___117 = 0;
                                    }
                                  }
#line 443
                                  if (tmp___117) {
#line 443
                                    tmp___113 = __builtin_strcmp((char const   *)node->name,
                                                                 "master-server-port");
                                  } else {
#line 443
                                    tmp___116 = __builtin_strcmp((char const   *)node->name,
                                                                 "master-server-port");
#line 443
                                    tmp___113 = tmp___116;
                                  }
                                } else {
#line 443
                                  tmp___116 = __builtin_strcmp((char const   *)node->name,
                                                               "master-server-port");
#line 443
                                  tmp___113 = tmp___116;
                                }
#line 443
                                if (tmp___113 == 0) {
#line 444
                                  tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                                     1);
#line 445
                                  configuration->master_server_port = atoi__extinline((char const   *)tmp);
#line 446
                                  ((*xmlFree))((void *)tmp);
                                } else {
#line 447
                                  if (0) {
#line 447
                                    __s1_len___7 = strlen((char const   *)node->name);
#line 447
                                    __s2_len___7 = strlen("master-update-interval");
#line 447
                                    if (! ((unsigned int )((void const   *)(node->name +
                                                                            1)) -
                                           (unsigned int )((void const   *)node->name) ==
                                           1U)) {
                                      goto _L___16;
                                    } else {
#line 447
                                      if (__s1_len___7 >= 4U) {
                                        _L___16: /* CIL Label */ 
#line 447
                                        if (! ((unsigned int )((void const   *)("master-update-interval" +
                                                                                1)) -
                                               (unsigned int )((void const   *)"master-update-interval") ==
                                               1U)) {
#line 447
                                          tmp___107 = 1;
                                        } else {
#line 447
                                          if (__s2_len___7 >= 4U) {
#line 447
                                            tmp___107 = 1;
                                          } else {
#line 447
                                            tmp___107 = 0;
                                          }
                                        }
                                      } else {
#line 447
                                        tmp___107 = 0;
                                      }
                                    }
#line 447
                                    if (tmp___107) {
#line 447
                                      tmp___103 = __builtin_strcmp((char const   *)node->name,
                                                                   "master-update-interval");
                                    } else {
#line 447
                                      tmp___106 = __builtin_strcmp((char const   *)node->name,
                                                                   "master-update-interval");
#line 447
                                      tmp___103 = tmp___106;
                                    }
                                  } else {
#line 447
                                    tmp___106 = __builtin_strcmp((char const   *)node->name,
                                                                 "master-update-interval");
#line 447
                                    tmp___103 = tmp___106;
                                  }
#line 447
                                  if (tmp___103 == 0) {
#line 448
                                    tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                                       1);
#line 449
                                    configuration->master_update_interval = atoi__extinline((char const   *)tmp);
#line 450
                                    ((*xmlFree))((void *)tmp);
                                  } else {
#line 451
                                    if (0) {
#line 451
                                      __s1_len___6 = strlen((char const   *)node->name);
#line 451
                                      __s2_len___6 = strlen("shoutcast-mount");
#line 451
                                      if (! ((unsigned int )((void const   *)(node->name +
                                                                              1)) -
                                             (unsigned int )((void const   *)node->name) ==
                                             1U)) {
                                        goto _L___14;
                                      } else {
#line 451
                                        if (__s1_len___6 >= 4U) {
                                          _L___14: /* CIL Label */ 
#line 451
                                          if (! ((unsigned int )((void const   *)("shoutcast-mount" +
                                                                                  1)) -
                                                 (unsigned int )((void const   *)"shoutcast-mount") ==
                                                 1U)) {
#line 451
                                            tmp___97 = 1;
                                          } else {
#line 451
                                            if (__s2_len___6 >= 4U) {
#line 451
                                              tmp___97 = 1;
                                            } else {
#line 451
                                              tmp___97 = 0;
                                            }
                                          }
                                        } else {
#line 451
                                          tmp___97 = 0;
                                        }
                                      }
#line 451
                                      if (tmp___97) {
#line 451
                                        tmp___93 = __builtin_strcmp((char const   *)node->name,
                                                                    "shoutcast-mount");
                                      } else {
#line 451
                                        tmp___96 = __builtin_strcmp((char const   *)node->name,
                                                                    "shoutcast-mount");
#line 451
                                        tmp___93 = tmp___96;
                                      }
                                    } else {
#line 451
                                      tmp___96 = __builtin_strcmp((char const   *)node->name,
                                                                  "shoutcast-mount");
#line 451
                                      tmp___93 = tmp___96;
                                    }
#line 451
                                    if (tmp___93 == 0) {
#line 452
                                      if (configuration->shoutcast_mount) {
#line 452
                                        if ((unsigned int )configuration->shoutcast_mount !=
                                            (unsigned int )CONFIG_DEFAULT_SHOUTCAST_MOUNT) {
#line 454
                                          ((*xmlFree))((void *)configuration->shoutcast_mount);
                                        }
                                      }
#line 455
                                      configuration->shoutcast_mount = (char *)xmlNodeListGetString(doc,
                                                                                                    node->children,
                                                                                                    1);
                                    } else {
#line 456
                                      if (0) {
#line 456
                                        __s1_len___5 = strlen((char const   *)node->name);
#line 456
                                        __s2_len___5 = strlen("limits");
#line 456
                                        if (! ((unsigned int )((void const   *)(node->name +
                                                                                1)) -
                                               (unsigned int )((void const   *)node->name) ==
                                               1U)) {
                                          goto _L___12;
                                        } else {
#line 456
                                          if (__s1_len___5 >= 4U) {
                                            _L___12: /* CIL Label */ 
#line 456
                                            if (! ((unsigned int )((void const   *)("limits" +
                                                                                    1)) -
                                                   (unsigned int )((void const   *)"limits") ==
                                                   1U)) {
#line 456
                                              tmp___87 = 1;
                                            } else {
#line 456
                                              if (__s2_len___5 >= 4U) {
#line 456
                                                tmp___87 = 1;
                                              } else {
#line 456
                                                tmp___87 = 0;
                                              }
                                            }
                                          } else {
#line 456
                                            tmp___87 = 0;
                                          }
                                        }
#line 456
                                        if (tmp___87) {
#line 456
                                          tmp___83 = __builtin_strcmp((char const   *)node->name,
                                                                      "limits");
                                        } else {
#line 456
                                          tmp___86 = __builtin_strcmp((char const   *)node->name,
                                                                      "limits");
#line 456
                                          tmp___83 = tmp___86;
                                        }
                                      } else {
#line 456
                                        tmp___86 = __builtin_strcmp((char const   *)node->name,
                                                                    "limits");
#line 456
                                        tmp___83 = tmp___86;
                                      }
#line 456
                                      if (tmp___83 == 0) {
#line 457
                                        _parse_limits(doc, node->children, configuration);
                                      } else {
#line 458
                                        if (0) {
#line 458
                                          __s1_len___4 = strlen((char const   *)node->name);
#line 458
                                          __s2_len___4 = strlen("relay");
#line 458
                                          if (! ((unsigned int )((void const   *)(node->name +
                                                                                  1)) -
                                                 (unsigned int )((void const   *)node->name) ==
                                                 1U)) {
                                            goto _L___10;
                                          } else {
#line 458
                                            if (__s1_len___4 >= 4U) {
                                              _L___10: /* CIL Label */ 
#line 458
                                              if (! ((unsigned int )((void const   *)("relay" +
                                                                                      1)) -
                                                     (unsigned int )((void const   *)"relay") ==
                                                     1U)) {
#line 458
                                                tmp___77 = 1;
                                              } else {
#line 458
                                                if (__s2_len___4 >= 4U) {
#line 458
                                                  tmp___77 = 1;
                                                } else {
#line 458
                                                  tmp___77 = 0;
                                                }
                                              }
                                            } else {
#line 458
                                              tmp___77 = 0;
                                            }
                                          }
#line 458
                                          if (tmp___77) {
#line 458
                                            tmp___73 = __builtin_strcmp((char const   *)node->name,
                                                                        "relay");
                                          } else {
#line 458
                                            tmp___76 = __builtin_strcmp((char const   *)node->name,
                                                                        "relay");
#line 458
                                            tmp___73 = tmp___76;
                                          }
                                        } else {
#line 458
                                          tmp___76 = __builtin_strcmp((char const   *)node->name,
                                                                      "relay");
#line 458
                                          tmp___73 = tmp___76;
                                        }
#line 458
                                        if (tmp___73 == 0) {
#line 459
                                          _parse_relay(doc, node->children, configuration);
                                        } else {
#line 460
                                          if (0) {
#line 460
                                            __s1_len___3 = strlen((char const   *)node->name);
#line 460
                                            __s2_len___3 = strlen("mount");
#line 460
                                            if (! ((unsigned int )((void const   *)(node->name +
                                                                                    1)) -
                                                   (unsigned int )((void const   *)node->name) ==
                                                   1U)) {
                                              goto _L___8;
                                            } else {
#line 460
                                              if (__s1_len___3 >= 4U) {
                                                _L___8: /* CIL Label */ 
#line 460
                                                if (! ((unsigned int )((void const   *)("mount" +
                                                                                        1)) -
                                                       (unsigned int )((void const   *)"mount") ==
                                                       1U)) {
#line 460
                                                  tmp___67 = 1;
                                                } else {
#line 460
                                                  if (__s2_len___3 >= 4U) {
#line 460
                                                    tmp___67 = 1;
                                                  } else {
#line 460
                                                    tmp___67 = 0;
                                                  }
                                                }
                                              } else {
#line 460
                                                tmp___67 = 0;
                                              }
                                            }
#line 460
                                            if (tmp___67) {
#line 460
                                              tmp___63 = __builtin_strcmp((char const   *)node->name,
                                                                          "mount");
                                            } else {
#line 460
                                              tmp___66 = __builtin_strcmp((char const   *)node->name,
                                                                          "mount");
#line 460
                                              tmp___63 = tmp___66;
                                            }
                                          } else {
#line 460
                                            tmp___66 = __builtin_strcmp((char const   *)node->name,
                                                                        "mount");
#line 460
                                            tmp___63 = tmp___66;
                                          }
#line 460
                                          if (tmp___63 == 0) {
#line 461
                                            _parse_mount(doc, node->children, configuration);
                                          } else {
#line 462
                                            if (0) {
#line 462
                                              __s1_len___2 = strlen((char const   *)node->name);
#line 462
                                              __s2_len___2 = strlen("directory");
#line 462
                                              if (! ((unsigned int )((void const   *)(node->name +
                                                                                      1)) -
                                                     (unsigned int )((void const   *)node->name) ==
                                                     1U)) {
                                                goto _L___6;
                                              } else {
#line 462
                                                if (__s1_len___2 >= 4U) {
                                                  _L___6: /* CIL Label */ 
#line 462
                                                  if (! ((unsigned int )((void const   *)("directory" +
                                                                                          1)) -
                                                         (unsigned int )((void const   *)"directory") ==
                                                         1U)) {
#line 462
                                                    tmp___57 = 1;
                                                  } else {
#line 462
                                                    if (__s2_len___2 >= 4U) {
#line 462
                                                      tmp___57 = 1;
                                                    } else {
#line 462
                                                      tmp___57 = 0;
                                                    }
                                                  }
                                                } else {
#line 462
                                                  tmp___57 = 0;
                                                }
                                              }
#line 462
                                              if (tmp___57) {
#line 462
                                                tmp___53 = __builtin_strcmp((char const   *)node->name,
                                                                            "directory");
                                              } else {
#line 462
                                                tmp___56 = __builtin_strcmp((char const   *)node->name,
                                                                            "directory");
#line 462
                                                tmp___53 = tmp___56;
                                              }
                                            } else {
#line 462
                                              tmp___56 = __builtin_strcmp((char const   *)node->name,
                                                                          "directory");
#line 462
                                              tmp___53 = tmp___56;
                                            }
#line 462
                                            if (tmp___53 == 0) {
#line 463
                                              _parse_directory(doc, node->children,
                                                               configuration);
                                            } else {
#line 464
                                              if (0) {
#line 464
                                                __s1_len___1 = strlen((char const   *)node->name);
#line 464
                                                __s2_len___1 = strlen("paths");
#line 464
                                                if (! ((unsigned int )((void const   *)(node->name +
                                                                                        1)) -
                                                       (unsigned int )((void const   *)node->name) ==
                                                       1U)) {
                                                  goto _L___4;
                                                } else {
#line 464
                                                  if (__s1_len___1 >= 4U) {
                                                    _L___4: /* CIL Label */ 
#line 464
                                                    if (! ((unsigned int )((void const   *)("paths" +
                                                                                            1)) -
                                                           (unsigned int )((void const   *)"paths") ==
                                                           1U)) {
#line 464
                                                      tmp___47 = 1;
                                                    } else {
#line 464
                                                      if (__s2_len___1 >= 4U) {
#line 464
                                                        tmp___47 = 1;
                                                      } else {
#line 464
                                                        tmp___47 = 0;
                                                      }
                                                    }
                                                  } else {
#line 464
                                                    tmp___47 = 0;
                                                  }
                                                }
#line 464
                                                if (tmp___47) {
#line 464
                                                  tmp___43 = __builtin_strcmp((char const   *)node->name,
                                                                              "paths");
                                                } else {
#line 464
                                                  tmp___46 = __builtin_strcmp((char const   *)node->name,
                                                                              "paths");
#line 464
                                                  tmp___43 = tmp___46;
                                                }
                                              } else {
#line 464
                                                tmp___46 = __builtin_strcmp((char const   *)node->name,
                                                                            "paths");
#line 464
                                                tmp___43 = tmp___46;
                                              }
#line 464
                                              if (tmp___43 == 0) {
#line 465
                                                _parse_paths(doc, node->children,
                                                             configuration);
                                              } else {
#line 466
                                                if (0) {
#line 466
                                                  __s1_len___0 = strlen((char const   *)node->name);
#line 466
                                                  __s2_len___0 = strlen("logging");
#line 466
                                                  if (! ((unsigned int )((void const   *)(node->name +
                                                                                          1)) -
                                                         (unsigned int )((void const   *)node->name) ==
                                                         1U)) {
                                                    goto _L___2;
                                                  } else {
#line 466
                                                    if (__s1_len___0 >= 4U) {
                                                      _L___2: /* CIL Label */ 
#line 466
                                                      if (! ((unsigned int )((void const   *)("logging" +
                                                                                              1)) -
                                                             (unsigned int )((void const   *)"logging") ==
                                                             1U)) {
#line 466
                                                        tmp___37 = 1;
                                                      } else {
#line 466
                                                        if (__s2_len___0 >= 4U) {
#line 466
                                                          tmp___37 = 1;
                                                        } else {
#line 466
                                                          tmp___37 = 0;
                                                        }
                                                      }
                                                    } else {
#line 466
                                                      tmp___37 = 0;
                                                    }
                                                  }
#line 466
                                                  if (tmp___37) {
#line 466
                                                    tmp___33 = __builtin_strcmp((char const   *)node->name,
                                                                                "logging");
                                                  } else {
#line 466
                                                    tmp___36 = __builtin_strcmp((char const   *)node->name,
                                                                                "logging");
#line 466
                                                    tmp___33 = tmp___36;
                                                  }
                                                } else {
#line 466
                                                  tmp___36 = __builtin_strcmp((char const   *)node->name,
                                                                              "logging");
#line 466
                                                  tmp___33 = tmp___36;
                                                }
#line 466
                                                if (tmp___33 == 0) {
#line 467
                                                  _parse_logging(doc, node->children,
                                                                 configuration);
                                                } else {
#line 468
                                                  if (0) {
#line 468
                                                    __s1_len = strlen((char const   *)node->name);
#line 468
                                                    __s2_len = strlen("security");
#line 468
                                                    if (! ((unsigned int )((void const   *)(node->name +
                                                                                            1)) -
                                                           (unsigned int )((void const   *)node->name) ==
                                                           1U)) {
                                                      goto _L___0;
                                                    } else {
#line 468
                                                      if (__s1_len >= 4U) {
                                                        _L___0: /* CIL Label */ 
#line 468
                                                        if (! ((unsigned int )((void const   *)("security" +
                                                                                                1)) -
                                                               (unsigned int )((void const   *)"security") ==
                                                               1U)) {
#line 468
                                                          tmp___27 = 1;
                                                        } else {
#line 468
                                                          if (__s2_len >= 4U) {
#line 468
                                                            tmp___27 = 1;
                                                          } else {
#line 468
                                                            tmp___27 = 0;
                                                          }
                                                        }
                                                      } else {
#line 468
                                                        tmp___27 = 0;
                                                      }
                                                    }
#line 468
                                                    if (tmp___27) {
#line 468
                                                      tmp___23 = __builtin_strcmp((char const   *)node->name,
                                                                                  "security");
                                                    } else {
#line 468
                                                      tmp___26 = __builtin_strcmp((char const   *)node->name,
                                                                                  "security");
#line 468
                                                      tmp___23 = tmp___26;
                                                    }
                                                  } else {
#line 468
                                                    tmp___26 = __builtin_strcmp((char const   *)node->name,
                                                                                "security");
#line 468
                                                    tmp___23 = tmp___26;
                                                  }
#line 468
                                                  if (tmp___23 == 0) {
#line 469
                                                    _parse_security(doc, node->children,
                                                                    configuration);
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 385
    node = node->next;
#line 385
    if (! node) {
#line 385
      break;
    }
  }
#line 472
  return;
}
}
#line 474 "cfgfile.c"
static void _parse_limits(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *tmp ;
  int tmp___0 ;
  int tmp___9 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___66 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___76 ;
  int tmp___79 ;
  int tmp___80 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___86 ;
  int tmp___89 ;
  int tmp___90 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___96 ;
  int tmp___99 ;
  int tmp___100 ;

  {
#line 479
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 481
    tmp___0 = xmlIsBlankNode(node);
#line 481
    if (tmp___0) {
      goto __Cont;
    }
#line 483
    if (0) {
#line 483
      __s1_len___7 = strlen((char const   *)node->name);
#line 483
      __s2_len___7 = strlen("clients");
#line 483
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___16;
      } else {
#line 483
        if (__s1_len___7 >= 4U) {
          _L___16: /* CIL Label */ 
#line 483
          if (! ((unsigned int )((void const   *)("clients" + 1)) - (unsigned int )((void const   *)"clients") ==
                 1U)) {
#line 483
            tmp___100 = 1;
          } else {
#line 483
            if (__s2_len___7 >= 4U) {
#line 483
              tmp___100 = 1;
            } else {
#line 483
              tmp___100 = 0;
            }
          }
        } else {
#line 483
          tmp___100 = 0;
        }
      }
#line 483
      if (tmp___100) {
#line 483
        tmp___96 = __builtin_strcmp((char const   *)node->name, "clients");
      } else {
#line 483
        tmp___99 = __builtin_strcmp((char const   *)node->name, "clients");
#line 483
        tmp___96 = tmp___99;
      }
    } else {
#line 483
      tmp___99 = __builtin_strcmp((char const   *)node->name, "clients");
#line 483
      tmp___96 = tmp___99;
    }
#line 483
    if (tmp___96 == 0) {
#line 484
      tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 485
      configuration->client_limit = atoi__extinline((char const   *)tmp);
#line 486
      if (tmp) {
#line 486
        ((*xmlFree))((void *)tmp);
      }
    } else {
#line 487
      if (0) {
#line 487
        __s1_len___6 = strlen((char const   *)node->name);
#line 487
        __s2_len___6 = strlen("sources");
#line 487
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___14;
        } else {
#line 487
          if (__s1_len___6 >= 4U) {
            _L___14: /* CIL Label */ 
#line 487
            if (! ((unsigned int )((void const   *)("sources" + 1)) - (unsigned int )((void const   *)"sources") ==
                   1U)) {
#line 487
              tmp___90 = 1;
            } else {
#line 487
              if (__s2_len___6 >= 4U) {
#line 487
                tmp___90 = 1;
              } else {
#line 487
                tmp___90 = 0;
              }
            }
          } else {
#line 487
            tmp___90 = 0;
          }
        }
#line 487
        if (tmp___90) {
#line 487
          tmp___86 = __builtin_strcmp((char const   *)node->name, "sources");
        } else {
#line 487
          tmp___89 = __builtin_strcmp((char const   *)node->name, "sources");
#line 487
          tmp___86 = tmp___89;
        }
      } else {
#line 487
        tmp___89 = __builtin_strcmp((char const   *)node->name, "sources");
#line 487
        tmp___86 = tmp___89;
      }
#line 487
      if (tmp___86 == 0) {
#line 488
        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 489
        configuration->source_limit = atoi__extinline((char const   *)tmp);
#line 490
        if (tmp) {
#line 490
          ((*xmlFree))((void *)tmp);
        }
      } else {
#line 491
        if (0) {
#line 491
          __s1_len___5 = strlen((char const   *)node->name);
#line 491
          __s2_len___5 = strlen("queue-size");
#line 491
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___12;
          } else {
#line 491
            if (__s1_len___5 >= 4U) {
              _L___12: /* CIL Label */ 
#line 491
              if (! ((unsigned int )((void const   *)("queue-size" + 1)) - (unsigned int )((void const   *)"queue-size") ==
                     1U)) {
#line 491
                tmp___80 = 1;
              } else {
#line 491
                if (__s2_len___5 >= 4U) {
#line 491
                  tmp___80 = 1;
                } else {
#line 491
                  tmp___80 = 0;
                }
              }
            } else {
#line 491
              tmp___80 = 0;
            }
          }
#line 491
          if (tmp___80) {
#line 491
            tmp___76 = __builtin_strcmp((char const   *)node->name, "queue-size");
          } else {
#line 491
            tmp___79 = __builtin_strcmp((char const   *)node->name, "queue-size");
#line 491
            tmp___76 = tmp___79;
          }
        } else {
#line 491
          tmp___79 = __builtin_strcmp((char const   *)node->name, "queue-size");
#line 491
          tmp___76 = tmp___79;
        }
#line 491
        if (tmp___76 == 0) {
#line 492
          tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 493
          configuration->queue_size_limit = (unsigned int )atoi__extinline((char const   *)tmp);
#line 494
          if (tmp) {
#line 494
            ((*xmlFree))((void *)tmp);
          }
        } else {
#line 495
          if (0) {
#line 495
            __s1_len___4 = strlen((char const   *)node->name);
#line 495
            __s2_len___4 = strlen("threadpool");
#line 495
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___10;
            } else {
#line 495
              if (__s1_len___4 >= 4U) {
                _L___10: /* CIL Label */ 
#line 495
                if (! ((unsigned int )((void const   *)("threadpool" + 1)) - (unsigned int )((void const   *)"threadpool") ==
                       1U)) {
#line 495
                  tmp___70 = 1;
                } else {
#line 495
                  if (__s2_len___4 >= 4U) {
#line 495
                    tmp___70 = 1;
                  } else {
#line 495
                    tmp___70 = 0;
                  }
                }
              } else {
#line 495
                tmp___70 = 0;
              }
            }
#line 495
            if (tmp___70) {
#line 495
              tmp___66 = __builtin_strcmp((char const   *)node->name, "threadpool");
            } else {
#line 495
              tmp___69 = __builtin_strcmp((char const   *)node->name, "threadpool");
#line 495
              tmp___66 = tmp___69;
            }
          } else {
#line 495
            tmp___69 = __builtin_strcmp((char const   *)node->name, "threadpool");
#line 495
            tmp___66 = tmp___69;
          }
#line 495
          if (tmp___66 == 0) {
#line 496
            tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 497
            configuration->threadpool_size = atoi__extinline((char const   *)tmp);
#line 498
            if (tmp) {
#line 498
              ((*xmlFree))((void *)tmp);
            }
          } else {
#line 499
            if (0) {
#line 499
              __s1_len___3 = strlen((char const   *)node->name);
#line 499
              __s2_len___3 = strlen("client-timeout");
#line 499
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___8;
              } else {
#line 499
                if (__s1_len___3 >= 4U) {
                  _L___8: /* CIL Label */ 
#line 499
                  if (! ((unsigned int )((void const   *)("client-timeout" + 1)) -
                         (unsigned int )((void const   *)"client-timeout") == 1U)) {
#line 499
                    tmp___60 = 1;
                  } else {
#line 499
                    if (__s2_len___3 >= 4U) {
#line 499
                      tmp___60 = 1;
                    } else {
#line 499
                      tmp___60 = 0;
                    }
                  }
                } else {
#line 499
                  tmp___60 = 0;
                }
              }
#line 499
              if (tmp___60) {
#line 499
                tmp___56 = __builtin_strcmp((char const   *)node->name, "client-timeout");
              } else {
#line 499
                tmp___59 = __builtin_strcmp((char const   *)node->name, "client-timeout");
#line 499
                tmp___56 = tmp___59;
              }
            } else {
#line 499
              tmp___59 = __builtin_strcmp((char const   *)node->name, "client-timeout");
#line 499
              tmp___56 = tmp___59;
            }
#line 499
            if (tmp___56 == 0) {
#line 500
              tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 501
              configuration->client_timeout = atoi__extinline((char const   *)tmp);
#line 502
              if (tmp) {
#line 502
                ((*xmlFree))((void *)tmp);
              }
            } else {
#line 503
              if (0) {
#line 503
                __s1_len___2 = strlen((char const   *)node->name);
#line 503
                __s2_len___2 = strlen("header-timeout");
#line 503
                if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                       1U)) {
                  goto _L___6;
                } else {
#line 503
                  if (__s1_len___2 >= 4U) {
                    _L___6: /* CIL Label */ 
#line 503
                    if (! ((unsigned int )((void const   *)("header-timeout" + 1)) -
                           (unsigned int )((void const   *)"header-timeout") == 1U)) {
#line 503
                      tmp___50 = 1;
                    } else {
#line 503
                      if (__s2_len___2 >= 4U) {
#line 503
                        tmp___50 = 1;
                      } else {
#line 503
                        tmp___50 = 0;
                      }
                    }
                  } else {
#line 503
                    tmp___50 = 0;
                  }
                }
#line 503
                if (tmp___50) {
#line 503
                  tmp___46 = __builtin_strcmp((char const   *)node->name, "header-timeout");
                } else {
#line 503
                  tmp___49 = __builtin_strcmp((char const   *)node->name, "header-timeout");
#line 503
                  tmp___46 = tmp___49;
                }
              } else {
#line 503
                tmp___49 = __builtin_strcmp((char const   *)node->name, "header-timeout");
#line 503
                tmp___46 = tmp___49;
              }
#line 503
              if (tmp___46 == 0) {
#line 504
                tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 505
                configuration->header_timeout = atoi__extinline((char const   *)tmp);
#line 506
                if (tmp) {
#line 506
                  ((*xmlFree))((void *)tmp);
                }
              } else {
#line 507
                if (0) {
#line 507
                  __s1_len___1 = strlen((char const   *)node->name);
#line 507
                  __s2_len___1 = strlen("source-timeout");
#line 507
                  if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                         1U)) {
                    goto _L___4;
                  } else {
#line 507
                    if (__s1_len___1 >= 4U) {
                      _L___4: /* CIL Label */ 
#line 507
                      if (! ((unsigned int )((void const   *)("source-timeout" + 1)) -
                             (unsigned int )((void const   *)"source-timeout") ==
                             1U)) {
#line 507
                        tmp___40 = 1;
                      } else {
#line 507
                        if (__s2_len___1 >= 4U) {
#line 507
                          tmp___40 = 1;
                        } else {
#line 507
                          tmp___40 = 0;
                        }
                      }
                    } else {
#line 507
                      tmp___40 = 0;
                    }
                  }
#line 507
                  if (tmp___40) {
#line 507
                    tmp___36 = __builtin_strcmp((char const   *)node->name, "source-timeout");
                  } else {
#line 507
                    tmp___39 = __builtin_strcmp((char const   *)node->name, "source-timeout");
#line 507
                    tmp___36 = tmp___39;
                  }
                } else {
#line 507
                  tmp___39 = __builtin_strcmp((char const   *)node->name, "source-timeout");
#line 507
                  tmp___36 = tmp___39;
                }
#line 507
                if (tmp___36 == 0) {
#line 508
                  tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 509
                  configuration->source_timeout = atoi__extinline((char const   *)tmp);
#line 510
                  if (tmp) {
#line 510
                    ((*xmlFree))((void *)tmp);
                  }
                } else {
#line 511
                  if (0) {
#line 511
                    __s1_len___0 = strlen((char const   *)node->name);
#line 511
                    __s2_len___0 = strlen("burst-on-connect");
#line 511
                    if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                           1U)) {
                      goto _L___2;
                    } else {
#line 511
                      if (__s1_len___0 >= 4U) {
                        _L___2: /* CIL Label */ 
#line 511
                        if (! ((unsigned int )((void const   *)("burst-on-connect" +
                                                                1)) - (unsigned int )((void const   *)"burst-on-connect") ==
                               1U)) {
#line 511
                          tmp___30 = 1;
                        } else {
#line 511
                          if (__s2_len___0 >= 4U) {
#line 511
                            tmp___30 = 1;
                          } else {
#line 511
                            tmp___30 = 0;
                          }
                        }
                      } else {
#line 511
                        tmp___30 = 0;
                      }
                    }
#line 511
                    if (tmp___30) {
#line 511
                      tmp___26 = __builtin_strcmp((char const   *)node->name, "burst-on-connect");
                    } else {
#line 511
                      tmp___29 = __builtin_strcmp((char const   *)node->name, "burst-on-connect");
#line 511
                      tmp___26 = tmp___29;
                    }
                  } else {
#line 511
                    tmp___29 = __builtin_strcmp((char const   *)node->name, "burst-on-connect");
#line 511
                    tmp___26 = tmp___29;
                  }
#line 511
                  if (tmp___26 == 0) {
#line 512
                    tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 513
                    tmp___9 = atoi__extinline((char const   *)tmp);
#line 513
                    if (tmp___9 == 0) {
#line 514
                      configuration->burst_size = 0U;
                    }
#line 515
                    if (tmp) {
#line 515
                      ((*xmlFree))((void *)tmp);
                    }
                  } else {
#line 516
                    if (0) {
#line 516
                      __s1_len = strlen((char const   *)node->name);
#line 516
                      __s2_len = strlen("burst-size");
#line 516
                      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                             1U)) {
                        goto _L___0;
                      } else {
#line 516
                        if (__s1_len >= 4U) {
                          _L___0: /* CIL Label */ 
#line 516
                          if (! ((unsigned int )((void const   *)("burst-size" + 1)) -
                                 (unsigned int )((void const   *)"burst-size") ==
                                 1U)) {
#line 516
                            tmp___20 = 1;
                          } else {
#line 516
                            if (__s2_len >= 4U) {
#line 516
                              tmp___20 = 1;
                            } else {
#line 516
                              tmp___20 = 0;
                            }
                          }
                        } else {
#line 516
                          tmp___20 = 0;
                        }
                      }
#line 516
                      if (tmp___20) {
#line 516
                        tmp___16 = __builtin_strcmp((char const   *)node->name, "burst-size");
                      } else {
#line 516
                        tmp___19 = __builtin_strcmp((char const   *)node->name, "burst-size");
#line 516
                        tmp___16 = tmp___19;
                      }
                    } else {
#line 516
                      tmp___19 = __builtin_strcmp((char const   *)node->name, "burst-size");
#line 516
                      tmp___16 = tmp___19;
                    }
#line 516
                    if (tmp___16 == 0) {
#line 517
                      tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 518
                      configuration->burst_size = (unsigned int )atoi__extinline((char const   *)tmp);
#line 519
                      if (tmp) {
#line 519
                        ((*xmlFree))((void *)tmp);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 479
    node = node->next;
#line 479
    if (! node) {
#line 479
      break;
    }
  }
#line 522
  return;
}
}
#line 524 "cfgfile.c"
static void _parse_mount(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *tmp ;
  mount_proxy *mount ;
  mount_proxy *tmp___0 ;
  mount_proxy *current ;
  mount_proxy *last ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___77 ;
  int tmp___80 ;
  int tmp___81 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___87 ;
  int tmp___90 ;
  int tmp___91 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___97 ;
  int tmp___100 ;
  int tmp___101 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___107 ;
  int tmp___110 ;
  int tmp___111 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___117 ;
  int tmp___120 ;
  int tmp___121 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___127 ;
  int tmp___130 ;
  int tmp___131 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___137 ;
  int tmp___140 ;
  int tmp___141 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___147 ;
  int tmp___150 ;
  int tmp___151 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___157 ;
  int tmp___160 ;
  int tmp___161 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___167 ;
  int tmp___170 ;
  int tmp___171 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___187 ;
  int tmp___190 ;
  int tmp___191 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___197 ;
  int tmp___200 ;
  int tmp___201 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___207 ;
  int tmp___210 ;
  int tmp___211 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___217 ;
  int tmp___220 ;
  int tmp___221 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___227 ;
  int tmp___230 ;
  int tmp___231 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___237 ;
  int tmp___240 ;
  int tmp___241 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___247 ;
  int tmp___250 ;
  int tmp___251 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___257 ;
  int tmp___260 ;
  int tmp___261 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___267 ;
  int tmp___270 ;
  int tmp___271 ;
  size_t __s1_len___23 ;
  size_t __s2_len___23 ;
  int tmp___277 ;
  int tmp___280 ;
  int tmp___281 ;
  size_t __s1_len___24 ;
  size_t __s2_len___24 ;
  int tmp___287 ;
  int tmp___290 ;
  int tmp___291 ;
  size_t __s1_len___25 ;
  size_t __s2_len___25 ;
  int tmp___297 ;
  int tmp___300 ;
  int tmp___301 ;
  size_t __s1_len___26 ;
  size_t __s2_len___26 ;
  int tmp___307 ;
  int tmp___310 ;
  int tmp___311 ;
  size_t __s1_len___27 ;
  size_t __s2_len___27 ;
  int tmp___317 ;
  int tmp___320 ;
  int tmp___321 ;

  {
#line 528
  tmp___0 = (mount_proxy *)calloc(1U, sizeof(mount_proxy ));
#line 528
  mount = tmp___0;
#line 529
  current = configuration->mounts;
#line 530
  last = (mount_proxy *)((void *)0);
#line 533
  mount->max_listeners = -1;
#line 534
  mount->burst_size = -1;
#line 535
  mount->mp3_meta_interval = -1;
#line 536
  mount->yp_public = -1;
#line 537
  mount->next = (struct _mount_proxy *)((void *)0);
#line 539
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 541
    tmp___1 = xmlIsBlankNode(node);
#line 541
    if (tmp___1) {
      goto __Cont;
    }
#line 543
    if (0) {
#line 543
      __s1_len___27 = strlen((char const   *)node->name);
#line 543
      __s2_len___27 = strlen("mount-name");
#line 543
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___56;
      } else {
#line 543
        if (__s1_len___27 >= 4U) {
          _L___56: /* CIL Label */ 
#line 543
          if (! ((unsigned int )((void const   *)("mount-name" + 1)) - (unsigned int )((void const   *)"mount-name") ==
                 1U)) {
#line 543
            tmp___321 = 1;
          } else {
#line 543
            if (__s2_len___27 >= 4U) {
#line 543
              tmp___321 = 1;
            } else {
#line 543
              tmp___321 = 0;
            }
          }
        } else {
#line 543
          tmp___321 = 0;
        }
      }
#line 543
      if (tmp___321) {
#line 543
        tmp___317 = __builtin_strcmp((char const   *)node->name, "mount-name");
      } else {
#line 543
        tmp___320 = __builtin_strcmp((char const   *)node->name, "mount-name");
#line 543
        tmp___317 = tmp___320;
      }
    } else {
#line 543
      tmp___320 = __builtin_strcmp((char const   *)node->name, "mount-name");
#line 543
      tmp___317 = tmp___320;
    }
#line 543
    if (tmp___317 == 0) {
#line 544
      mount->mountname = (char *)xmlNodeListGetString(doc, node->children, 1);
    } else {
#line 547
      if (0) {
#line 547
        __s1_len___26 = strlen((char const   *)node->name);
#line 547
        __s2_len___26 = strlen("username");
#line 547
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___54;
        } else {
#line 547
          if (__s1_len___26 >= 4U) {
            _L___54: /* CIL Label */ 
#line 547
            if (! ((unsigned int )((void const   *)("username" + 1)) - (unsigned int )((void const   *)"username") ==
                   1U)) {
#line 547
              tmp___311 = 1;
            } else {
#line 547
              if (__s2_len___26 >= 4U) {
#line 547
                tmp___311 = 1;
              } else {
#line 547
                tmp___311 = 0;
              }
            }
          } else {
#line 547
            tmp___311 = 0;
          }
        }
#line 547
        if (tmp___311) {
#line 547
          tmp___307 = __builtin_strcmp((char const   *)node->name, "username");
        } else {
#line 547
          tmp___310 = __builtin_strcmp((char const   *)node->name, "username");
#line 547
          tmp___307 = tmp___310;
        }
      } else {
#line 547
        tmp___310 = __builtin_strcmp((char const   *)node->name, "username");
#line 547
        tmp___307 = tmp___310;
      }
#line 547
      if (tmp___307 == 0) {
#line 548
        mount->username = (char *)xmlNodeListGetString(doc, node->children, 1);
      } else {
#line 551
        if (0) {
#line 551
          __s1_len___25 = strlen((char const   *)node->name);
#line 551
          __s2_len___25 = strlen("password");
#line 551
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___52;
          } else {
#line 551
            if (__s1_len___25 >= 4U) {
              _L___52: /* CIL Label */ 
#line 551
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") ==
                     1U)) {
#line 551
                tmp___301 = 1;
              } else {
#line 551
                if (__s2_len___25 >= 4U) {
#line 551
                  tmp___301 = 1;
                } else {
#line 551
                  tmp___301 = 0;
                }
              }
            } else {
#line 551
              tmp___301 = 0;
            }
          }
#line 551
          if (tmp___301) {
#line 551
            tmp___297 = __builtin_strcmp((char const   *)node->name, "password");
          } else {
#line 551
            tmp___300 = __builtin_strcmp((char const   *)node->name, "password");
#line 551
            tmp___297 = tmp___300;
          }
        } else {
#line 551
          tmp___300 = __builtin_strcmp((char const   *)node->name, "password");
#line 551
          tmp___297 = tmp___300;
        }
#line 551
        if (tmp___297 == 0) {
#line 552
          mount->password = (char *)xmlNodeListGetString(doc, node->children, 1);
        } else {
#line 555
          if (0) {
#line 555
            __s1_len___24 = strlen((char const   *)node->name);
#line 555
            __s2_len___24 = strlen("dump-file");
#line 555
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___50;
            } else {
#line 555
              if (__s1_len___24 >= 4U) {
                _L___50: /* CIL Label */ 
#line 555
                if (! ((unsigned int )((void const   *)("dump-file" + 1)) - (unsigned int )((void const   *)"dump-file") ==
                       1U)) {
#line 555
                  tmp___291 = 1;
                } else {
#line 555
                  if (__s2_len___24 >= 4U) {
#line 555
                    tmp___291 = 1;
                  } else {
#line 555
                    tmp___291 = 0;
                  }
                }
              } else {
#line 555
                tmp___291 = 0;
              }
            }
#line 555
            if (tmp___291) {
#line 555
              tmp___287 = __builtin_strcmp((char const   *)node->name, "dump-file");
            } else {
#line 555
              tmp___290 = __builtin_strcmp((char const   *)node->name, "dump-file");
#line 555
              tmp___287 = tmp___290;
            }
          } else {
#line 555
            tmp___290 = __builtin_strcmp((char const   *)node->name, "dump-file");
#line 555
            tmp___287 = tmp___290;
          }
#line 555
          if (tmp___287 == 0) {
#line 556
            mount->dumpfile = (char *)xmlNodeListGetString(doc, node->children, 1);
          } else {
#line 559
            if (0) {
#line 559
              __s1_len___23 = strlen((char const   *)node->name);
#line 559
              __s2_len___23 = strlen("intro");
#line 559
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___48;
              } else {
#line 559
                if (__s1_len___23 >= 4U) {
                  _L___48: /* CIL Label */ 
#line 559
                  if (! ((unsigned int )((void const   *)("intro" + 1)) - (unsigned int )((void const   *)"intro") ==
                         1U)) {
#line 559
                    tmp___281 = 1;
                  } else {
#line 559
                    if (__s2_len___23 >= 4U) {
#line 559
                      tmp___281 = 1;
                    } else {
#line 559
                      tmp___281 = 0;
                    }
                  }
                } else {
#line 559
                  tmp___281 = 0;
                }
              }
#line 559
              if (tmp___281) {
#line 559
                tmp___277 = __builtin_strcmp((char const   *)node->name, "intro");
              } else {
#line 559
                tmp___280 = __builtin_strcmp((char const   *)node->name, "intro");
#line 559
                tmp___277 = tmp___280;
              }
            } else {
#line 559
              tmp___280 = __builtin_strcmp((char const   *)node->name, "intro");
#line 559
              tmp___277 = tmp___280;
            }
#line 559
            if (tmp___277 == 0) {
#line 560
              mount->intro_filename = (char *)xmlNodeListGetString(doc, node->children,
                                                                   1);
            } else {
#line 563
              if (0) {
#line 563
                __s1_len___22 = strlen((char const   *)node->name);
#line 563
                __s2_len___22 = strlen("fallback-mount");
#line 563
                if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                       1U)) {
                  goto _L___46;
                } else {
#line 563
                  if (__s1_len___22 >= 4U) {
                    _L___46: /* CIL Label */ 
#line 563
                    if (! ((unsigned int )((void const   *)("fallback-mount" + 1)) -
                           (unsigned int )((void const   *)"fallback-mount") == 1U)) {
#line 563
                      tmp___271 = 1;
                    } else {
#line 563
                      if (__s2_len___22 >= 4U) {
#line 563
                        tmp___271 = 1;
                      } else {
#line 563
                        tmp___271 = 0;
                      }
                    }
                  } else {
#line 563
                    tmp___271 = 0;
                  }
                }
#line 563
                if (tmp___271) {
#line 563
                  tmp___267 = __builtin_strcmp((char const   *)node->name, "fallback-mount");
                } else {
#line 563
                  tmp___270 = __builtin_strcmp((char const   *)node->name, "fallback-mount");
#line 563
                  tmp___267 = tmp___270;
                }
              } else {
#line 563
                tmp___270 = __builtin_strcmp((char const   *)node->name, "fallback-mount");
#line 563
                tmp___267 = tmp___270;
              }
#line 563
              if (tmp___267 == 0) {
#line 564
                mount->fallback_mount = (char *)xmlNodeListGetString(doc, node->children,
                                                                     1);
              } else {
#line 567
                if (0) {
#line 567
                  __s1_len___21 = strlen((char const   *)node->name);
#line 567
                  __s2_len___21 = strlen("fallback-when-full");
#line 567
                  if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                         1U)) {
                    goto _L___44;
                  } else {
#line 567
                    if (__s1_len___21 >= 4U) {
                      _L___44: /* CIL Label */ 
#line 567
                      if (! ((unsigned int )((void const   *)("fallback-when-full" +
                                                              1)) - (unsigned int )((void const   *)"fallback-when-full") ==
                             1U)) {
#line 567
                        tmp___261 = 1;
                      } else {
#line 567
                        if (__s2_len___21 >= 4U) {
#line 567
                          tmp___261 = 1;
                        } else {
#line 567
                          tmp___261 = 0;
                        }
                      }
                    } else {
#line 567
                      tmp___261 = 0;
                    }
                  }
#line 567
                  if (tmp___261) {
#line 567
                    tmp___257 = __builtin_strcmp((char const   *)node->name, "fallback-when-full");
                  } else {
#line 567
                    tmp___260 = __builtin_strcmp((char const   *)node->name, "fallback-when-full");
#line 567
                    tmp___257 = tmp___260;
                  }
                } else {
#line 567
                  tmp___260 = __builtin_strcmp((char const   *)node->name, "fallback-when-full");
#line 567
                  tmp___257 = tmp___260;
                }
#line 567
                if (tmp___257 == 0) {
#line 568
                  tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 569
                  mount->fallback_when_full = atoi__extinline((char const   *)tmp);
#line 570
                  if (tmp) {
#line 570
                    ((*xmlFree))((void *)tmp);
                  }
                } else {
#line 572
                  if (0) {
#line 572
                    __s1_len___20 = strlen((char const   *)node->name);
#line 572
                    __s2_len___20 = strlen("max-listeners");
#line 572
                    if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                           1U)) {
                      goto _L___42;
                    } else {
#line 572
                      if (__s1_len___20 >= 4U) {
                        _L___42: /* CIL Label */ 
#line 572
                        if (! ((unsigned int )((void const   *)("max-listeners" +
                                                                1)) - (unsigned int )((void const   *)"max-listeners") ==
                               1U)) {
#line 572
                          tmp___251 = 1;
                        } else {
#line 572
                          if (__s2_len___20 >= 4U) {
#line 572
                            tmp___251 = 1;
                          } else {
#line 572
                            tmp___251 = 0;
                          }
                        }
                      } else {
#line 572
                        tmp___251 = 0;
                      }
                    }
#line 572
                    if (tmp___251) {
#line 572
                      tmp___247 = __builtin_strcmp((char const   *)node->name, "max-listeners");
                    } else {
#line 572
                      tmp___250 = __builtin_strcmp((char const   *)node->name, "max-listeners");
#line 572
                      tmp___247 = tmp___250;
                    }
                  } else {
#line 572
                    tmp___250 = __builtin_strcmp((char const   *)node->name, "max-listeners");
#line 572
                    tmp___247 = tmp___250;
                  }
#line 572
                  if (tmp___247 == 0) {
#line 573
                    tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 574
                    mount->max_listeners = atoi__extinline((char const   *)tmp);
#line 575
                    if (tmp) {
#line 575
                      ((*xmlFree))((void *)tmp);
                    }
                  } else {
#line 577
                    if (0) {
#line 577
                      __s1_len___19 = strlen((char const   *)node->name);
#line 577
                      __s2_len___19 = strlen("mp3-metadata-interval");
#line 577
                      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                             1U)) {
                        goto _L___40;
                      } else {
#line 577
                        if (__s1_len___19 >= 4U) {
                          _L___40: /* CIL Label */ 
#line 577
                          if (! ((unsigned int )((void const   *)("mp3-metadata-interval" +
                                                                  1)) - (unsigned int )((void const   *)"mp3-metadata-interval") ==
                                 1U)) {
#line 577
                            tmp___241 = 1;
                          } else {
#line 577
                            if (__s2_len___19 >= 4U) {
#line 577
                              tmp___241 = 1;
                            } else {
#line 577
                              tmp___241 = 0;
                            }
                          }
                        } else {
#line 577
                          tmp___241 = 0;
                        }
                      }
#line 577
                      if (tmp___241) {
#line 577
                        tmp___237 = __builtin_strcmp((char const   *)node->name, "mp3-metadata-interval");
                      } else {
#line 577
                        tmp___240 = __builtin_strcmp((char const   *)node->name, "mp3-metadata-interval");
#line 577
                        tmp___237 = tmp___240;
                      }
                    } else {
#line 577
                      tmp___240 = __builtin_strcmp((char const   *)node->name, "mp3-metadata-interval");
#line 577
                      tmp___237 = tmp___240;
                    }
#line 577
                    if (tmp___237 == 0) {
#line 578
                      tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 579
                      mount->mp3_meta_interval = atoi__extinline((char const   *)tmp);
#line 580
                      if (tmp) {
#line 580
                        ((*xmlFree))((void *)tmp);
                      }
                    } else {
#line 582
                      if (0) {
#line 582
                        __s1_len___18 = strlen((char const   *)node->name);
#line 582
                        __s2_len___18 = strlen("fallback-override");
#line 582
                        if (! ((unsigned int )((void const   *)(node->name + 1)) -
                               (unsigned int )((void const   *)node->name) == 1U)) {
                          goto _L___38;
                        } else {
#line 582
                          if (__s1_len___18 >= 4U) {
                            _L___38: /* CIL Label */ 
#line 582
                            if (! ((unsigned int )((void const   *)("fallback-override" +
                                                                    1)) - (unsigned int )((void const   *)"fallback-override") ==
                                   1U)) {
#line 582
                              tmp___231 = 1;
                            } else {
#line 582
                              if (__s2_len___18 >= 4U) {
#line 582
                                tmp___231 = 1;
                              } else {
#line 582
                                tmp___231 = 0;
                              }
                            }
                          } else {
#line 582
                            tmp___231 = 0;
                          }
                        }
#line 582
                        if (tmp___231) {
#line 582
                          tmp___227 = __builtin_strcmp((char const   *)node->name,
                                                       "fallback-override");
                        } else {
#line 582
                          tmp___230 = __builtin_strcmp((char const   *)node->name,
                                                       "fallback-override");
#line 582
                          tmp___227 = tmp___230;
                        }
                      } else {
#line 582
                        tmp___230 = __builtin_strcmp((char const   *)node->name, "fallback-override");
#line 582
                        tmp___227 = tmp___230;
                      }
#line 582
                      if (tmp___227 == 0) {
#line 583
                        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 584
                        mount->fallback_override = atoi__extinline((char const   *)tmp);
#line 585
                        if (tmp) {
#line 585
                          ((*xmlFree))((void *)tmp);
                        }
                      } else {
#line 587
                        if (0) {
#line 587
                          __s1_len___17 = strlen((char const   *)node->name);
#line 587
                          __s2_len___17 = strlen("no-mount");
#line 587
                          if (! ((unsigned int )((void const   *)(node->name + 1)) -
                                 (unsigned int )((void const   *)node->name) == 1U)) {
                            goto _L___36;
                          } else {
#line 587
                            if (__s1_len___17 >= 4U) {
                              _L___36: /* CIL Label */ 
#line 587
                              if (! ((unsigned int )((void const   *)("no-mount" +
                                                                      1)) - (unsigned int )((void const   *)"no-mount") ==
                                     1U)) {
#line 587
                                tmp___221 = 1;
                              } else {
#line 587
                                if (__s2_len___17 >= 4U) {
#line 587
                                  tmp___221 = 1;
                                } else {
#line 587
                                  tmp___221 = 0;
                                }
                              }
                            } else {
#line 587
                              tmp___221 = 0;
                            }
                          }
#line 587
                          if (tmp___221) {
#line 587
                            tmp___217 = __builtin_strcmp((char const   *)node->name,
                                                         "no-mount");
                          } else {
#line 587
                            tmp___220 = __builtin_strcmp((char const   *)node->name,
                                                         "no-mount");
#line 587
                            tmp___217 = tmp___220;
                          }
                        } else {
#line 587
                          tmp___220 = __builtin_strcmp((char const   *)node->name,
                                                       "no-mount");
#line 587
                          tmp___217 = tmp___220;
                        }
#line 587
                        if (tmp___217 == 0) {
#line 588
                          tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                             1);
#line 589
                          mount->no_mount = atoi__extinline((char const   *)tmp);
#line 590
                          if (tmp) {
#line 590
                            ((*xmlFree))((void *)tmp);
                          }
                        } else {
#line 592
                          if (0) {
#line 592
                            __s1_len___16 = strlen((char const   *)node->name);
#line 592
                            __s2_len___16 = strlen("no-yp");
#line 592
                            if (! ((unsigned int )((void const   *)(node->name + 1)) -
                                   (unsigned int )((void const   *)node->name) ==
                                   1U)) {
                              goto _L___34;
                            } else {
#line 592
                              if (__s1_len___16 >= 4U) {
                                _L___34: /* CIL Label */ 
#line 592
                                if (! ((unsigned int )((void const   *)("no-yp" +
                                                                        1)) - (unsigned int )((void const   *)"no-yp") ==
                                       1U)) {
#line 592
                                  tmp___211 = 1;
                                } else {
#line 592
                                  if (__s2_len___16 >= 4U) {
#line 592
                                    tmp___211 = 1;
                                  } else {
#line 592
                                    tmp___211 = 0;
                                  }
                                }
                              } else {
#line 592
                                tmp___211 = 0;
                              }
                            }
#line 592
                            if (tmp___211) {
#line 592
                              tmp___207 = __builtin_strcmp((char const   *)node->name,
                                                           "no-yp");
                            } else {
#line 592
                              tmp___210 = __builtin_strcmp((char const   *)node->name,
                                                           "no-yp");
#line 592
                              tmp___207 = tmp___210;
                            }
                          } else {
#line 592
                            tmp___210 = __builtin_strcmp((char const   *)node->name,
                                                         "no-yp");
#line 592
                            tmp___207 = tmp___210;
                          }
#line 592
                          if (tmp___207 == 0) {
#line 593
                            tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                               1);
#line 594
                            tmp___15 = atoi__extinline((char const   *)tmp);
#line 594
                            if (tmp___15 == 0) {
#line 594
                              mount->yp_public = -1;
                            } else {
#line 594
                              mount->yp_public = 0;
                            }
#line 595
                            if (tmp) {
#line 595
                              ((*xmlFree))((void *)tmp);
                            }
                          } else {
#line 597
                            if (0) {
#line 597
                              __s1_len___15 = strlen((char const   *)node->name);
#line 597
                              __s2_len___15 = strlen("hidden");
#line 597
                              if (! ((unsigned int )((void const   *)(node->name +
                                                                      1)) - (unsigned int )((void const   *)node->name) ==
                                     1U)) {
                                goto _L___32;
                              } else {
#line 597
                                if (__s1_len___15 >= 4U) {
                                  _L___32: /* CIL Label */ 
#line 597
                                  if (! ((unsigned int )((void const   *)("hidden" +
                                                                          1)) - (unsigned int )((void const   *)"hidden") ==
                                         1U)) {
#line 597
                                    tmp___201 = 1;
                                  } else {
#line 597
                                    if (__s2_len___15 >= 4U) {
#line 597
                                      tmp___201 = 1;
                                    } else {
#line 597
                                      tmp___201 = 0;
                                    }
                                  }
                                } else {
#line 597
                                  tmp___201 = 0;
                                }
                              }
#line 597
                              if (tmp___201) {
#line 597
                                tmp___197 = __builtin_strcmp((char const   *)node->name,
                                                             "hidden");
                              } else {
#line 597
                                tmp___200 = __builtin_strcmp((char const   *)node->name,
                                                             "hidden");
#line 597
                                tmp___197 = tmp___200;
                              }
                            } else {
#line 597
                              tmp___200 = __builtin_strcmp((char const   *)node->name,
                                                           "hidden");
#line 597
                              tmp___197 = tmp___200;
                            }
#line 597
                            if (tmp___197 == 0) {
#line 598
                              tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                                 1);
#line 599
                              mount->hidden = atoi__extinline((char const   *)tmp);
#line 600
                              if (tmp) {
#line 600
                                ((*xmlFree))((void *)tmp);
                              }
                            } else {
#line 602
                              if (0) {
#line 602
                                __s1_len___14 = strlen((char const   *)node->name);
#line 602
                                __s2_len___14 = strlen("authentication");
#line 602
                                if (! ((unsigned int )((void const   *)(node->name +
                                                                        1)) - (unsigned int )((void const   *)node->name) ==
                                       1U)) {
                                  goto _L___30;
                                } else {
#line 602
                                  if (__s1_len___14 >= 4U) {
                                    _L___30: /* CIL Label */ 
#line 602
                                    if (! ((unsigned int )((void const   *)("authentication" +
                                                                            1)) -
                                           (unsigned int )((void const   *)"authentication") ==
                                           1U)) {
#line 602
                                      tmp___191 = 1;
                                    } else {
#line 602
                                      if (__s2_len___14 >= 4U) {
#line 602
                                        tmp___191 = 1;
                                      } else {
#line 602
                                        tmp___191 = 0;
                                      }
                                    }
                                  } else {
#line 602
                                    tmp___191 = 0;
                                  }
                                }
#line 602
                                if (tmp___191) {
#line 602
                                  tmp___187 = __builtin_strcmp((char const   *)node->name,
                                                               "authentication");
                                } else {
#line 602
                                  tmp___190 = __builtin_strcmp((char const   *)node->name,
                                                               "authentication");
#line 602
                                  tmp___187 = tmp___190;
                                }
                              } else {
#line 602
                                tmp___190 = __builtin_strcmp((char const   *)node->name,
                                                             "authentication");
#line 602
                                tmp___187 = tmp___190;
                              }
#line 602
                              if (tmp___187 == 0) {
#line 603
                                mount->auth = auth_get_authenticator(node);
                              } else {
#line 605
                                if (0) {
#line 605
                                  __s1_len___13 = strlen((char const   *)node->name);
#line 605
                                  __s2_len___13 = strlen("on-connect");
#line 605
                                  if (! ((unsigned int )((void const   *)(node->name +
                                                                          1)) - (unsigned int )((void const   *)node->name) ==
                                         1U)) {
                                    goto _L___28;
                                  } else {
#line 605
                                    if (__s1_len___13 >= 4U) {
                                      _L___28: /* CIL Label */ 
#line 605
                                      if (! ((unsigned int )((void const   *)("on-connect" +
                                                                              1)) -
                                             (unsigned int )((void const   *)"on-connect") ==
                                             1U)) {
#line 605
                                        tmp___181 = 1;
                                      } else {
#line 605
                                        if (__s2_len___13 >= 4U) {
#line 605
                                          tmp___181 = 1;
                                        } else {
#line 605
                                          tmp___181 = 0;
                                        }
                                      }
                                    } else {
#line 605
                                      tmp___181 = 0;
                                    }
                                  }
#line 605
                                  if (tmp___181) {
#line 605
                                    tmp___177 = __builtin_strcmp((char const   *)node->name,
                                                                 "on-connect");
                                  } else {
#line 605
                                    tmp___180 = __builtin_strcmp((char const   *)node->name,
                                                                 "on-connect");
#line 605
                                    tmp___177 = tmp___180;
                                  }
                                } else {
#line 605
                                  tmp___180 = __builtin_strcmp((char const   *)node->name,
                                                               "on-connect");
#line 605
                                  tmp___177 = tmp___180;
                                }
#line 605
                                if (tmp___177 == 0) {
#line 606
                                  mount->on_connect = (char *)xmlNodeListGetString(doc,
                                                                                   node->children,
                                                                                   1);
                                } else {
#line 609
                                  if (0) {
#line 609
                                    __s1_len___12 = strlen((char const   *)node->name);
#line 609
                                    __s2_len___12 = strlen("on-disconnect");
#line 609
                                    if (! ((unsigned int )((void const   *)(node->name +
                                                                            1)) -
                                           (unsigned int )((void const   *)node->name) ==
                                           1U)) {
                                      goto _L___26;
                                    } else {
#line 609
                                      if (__s1_len___12 >= 4U) {
                                        _L___26: /* CIL Label */ 
#line 609
                                        if (! ((unsigned int )((void const   *)("on-disconnect" +
                                                                                1)) -
                                               (unsigned int )((void const   *)"on-disconnect") ==
                                               1U)) {
#line 609
                                          tmp___171 = 1;
                                        } else {
#line 609
                                          if (__s2_len___12 >= 4U) {
#line 609
                                            tmp___171 = 1;
                                          } else {
#line 609
                                            tmp___171 = 0;
                                          }
                                        }
                                      } else {
#line 609
                                        tmp___171 = 0;
                                      }
                                    }
#line 609
                                    if (tmp___171) {
#line 609
                                      tmp___167 = __builtin_strcmp((char const   *)node->name,
                                                                   "on-disconnect");
                                    } else {
#line 609
                                      tmp___170 = __builtin_strcmp((char const   *)node->name,
                                                                   "on-disconnect");
#line 609
                                      tmp___167 = tmp___170;
                                    }
                                  } else {
#line 609
                                    tmp___170 = __builtin_strcmp((char const   *)node->name,
                                                                 "on-disconnect");
#line 609
                                    tmp___167 = tmp___170;
                                  }
#line 609
                                  if (tmp___167 == 0) {
#line 610
                                    mount->on_disconnect = (char *)xmlNodeListGetString(doc,
                                                                                        node->children,
                                                                                        1);
                                  } else {
#line 613
                                    if (0) {
#line 613
                                      __s1_len___11 = strlen((char const   *)node->name);
#line 613
                                      __s2_len___11 = strlen("max-listener-duration");
#line 613
                                      if (! ((unsigned int )((void const   *)(node->name +
                                                                              1)) -
                                             (unsigned int )((void const   *)node->name) ==
                                             1U)) {
                                        goto _L___24;
                                      } else {
#line 613
                                        if (__s1_len___11 >= 4U) {
                                          _L___24: /* CIL Label */ 
#line 613
                                          if (! ((unsigned int )((void const   *)("max-listener-duration" +
                                                                                  1)) -
                                                 (unsigned int )((void const   *)"max-listener-duration") ==
                                                 1U)) {
#line 613
                                            tmp___161 = 1;
                                          } else {
#line 613
                                            if (__s2_len___11 >= 4U) {
#line 613
                                              tmp___161 = 1;
                                            } else {
#line 613
                                              tmp___161 = 0;
                                            }
                                          }
                                        } else {
#line 613
                                          tmp___161 = 0;
                                        }
                                      }
#line 613
                                      if (tmp___161) {
#line 613
                                        tmp___157 = __builtin_strcmp((char const   *)node->name,
                                                                     "max-listener-duration");
                                      } else {
#line 613
                                        tmp___160 = __builtin_strcmp((char const   *)node->name,
                                                                     "max-listener-duration");
#line 613
                                        tmp___157 = tmp___160;
                                      }
                                    } else {
#line 613
                                      tmp___160 = __builtin_strcmp((char const   *)node->name,
                                                                   "max-listener-duration");
#line 613
                                      tmp___157 = tmp___160;
                                    }
#line 613
                                    if (tmp___157 == 0) {
#line 614
                                      tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                                         1);
#line 615
                                      mount->max_listener_duration = (unsigned int )atoi__extinline((char const   *)tmp);
#line 616
                                      if (tmp) {
#line 616
                                        ((*xmlFree))((void *)tmp);
                                      }
                                    } else {
#line 618
                                      if (0) {
#line 618
                                        __s1_len___10 = strlen((char const   *)node->name);
#line 618
                                        __s2_len___10 = strlen("queue-size");
#line 618
                                        if (! ((unsigned int )((void const   *)(node->name +
                                                                                1)) -
                                               (unsigned int )((void const   *)node->name) ==
                                               1U)) {
                                          goto _L___22;
                                        } else {
#line 618
                                          if (__s1_len___10 >= 4U) {
                                            _L___22: /* CIL Label */ 
#line 618
                                            if (! ((unsigned int )((void const   *)("queue-size" +
                                                                                    1)) -
                                                   (unsigned int )((void const   *)"queue-size") ==
                                                   1U)) {
#line 618
                                              tmp___151 = 1;
                                            } else {
#line 618
                                              if (__s2_len___10 >= 4U) {
#line 618
                                                tmp___151 = 1;
                                              } else {
#line 618
                                                tmp___151 = 0;
                                              }
                                            }
                                          } else {
#line 618
                                            tmp___151 = 0;
                                          }
                                        }
#line 618
                                        if (tmp___151) {
#line 618
                                          tmp___147 = __builtin_strcmp((char const   *)node->name,
                                                                       "queue-size");
                                        } else {
#line 618
                                          tmp___150 = __builtin_strcmp((char const   *)node->name,
                                                                       "queue-size");
#line 618
                                          tmp___147 = tmp___150;
                                        }
                                      } else {
#line 618
                                        tmp___150 = __builtin_strcmp((char const   *)node->name,
                                                                     "queue-size");
#line 618
                                        tmp___147 = tmp___150;
                                      }
#line 618
                                      if (tmp___147 == 0) {
#line 619
                                        tmp = (char *)xmlNodeListGetString(doc, node->children,
                                                                           1);
#line 620
                                        mount->queue_size_limit = (unsigned int )atoi__extinline((char const   *)tmp);
#line 621
                                        if (tmp) {
#line 621
                                          ((*xmlFree))((void *)tmp);
                                        }
                                      } else {
#line 623
                                        if (0) {
#line 623
                                          __s1_len___9 = strlen((char const   *)node->name);
#line 623
                                          __s2_len___9 = strlen("source-timeout");
#line 623
                                          if (! ((unsigned int )((void const   *)(node->name +
                                                                                  1)) -
                                                 (unsigned int )((void const   *)node->name) ==
                                                 1U)) {
                                            goto _L___20;
                                          } else {
#line 623
                                            if (__s1_len___9 >= 4U) {
                                              _L___20: /* CIL Label */ 
#line 623
                                              if (! ((unsigned int )((void const   *)("source-timeout" +
                                                                                      1)) -
                                                     (unsigned int )((void const   *)"source-timeout") ==
                                                     1U)) {
#line 623
                                                tmp___141 = 1;
                                              } else {
#line 623
                                                if (__s2_len___9 >= 4U) {
#line 623
                                                  tmp___141 = 1;
                                                } else {
#line 623
                                                  tmp___141 = 0;
                                                }
                                              }
                                            } else {
#line 623
                                              tmp___141 = 0;
                                            }
                                          }
#line 623
                                          if (tmp___141) {
#line 623
                                            tmp___137 = __builtin_strcmp((char const   *)node->name,
                                                                         "source-timeout");
                                          } else {
#line 623
                                            tmp___140 = __builtin_strcmp((char const   *)node->name,
                                                                         "source-timeout");
#line 623
                                            tmp___137 = tmp___140;
                                          }
                                        } else {
#line 623
                                          tmp___140 = __builtin_strcmp((char const   *)node->name,
                                                                       "source-timeout");
#line 623
                                          tmp___137 = tmp___140;
                                        }
#line 623
                                        if (tmp___137 == 0) {
#line 624
                                          tmp = (char *)xmlNodeListGetString(doc,
                                                                             node->children,
                                                                             1);
#line 625
                                          if (tmp) {
#line 627
                                            mount->source_timeout = (unsigned int )atoi__extinline((char const   *)tmp);
#line 628
                                            ((*xmlFree))((void *)tmp);
                                          }
                                        } else {
#line 630
                                          if (0) {
#line 630
                                            __s1_len___8 = strlen((char const   *)node->name);
#line 630
                                            __s2_len___8 = strlen("burst-size");
#line 630
                                            if (! ((unsigned int )((void const   *)(node->name +
                                                                                    1)) -
                                                   (unsigned int )((void const   *)node->name) ==
                                                   1U)) {
                                              goto _L___18;
                                            } else {
#line 630
                                              if (__s1_len___8 >= 4U) {
                                                _L___18: /* CIL Label */ 
#line 630
                                                if (! ((unsigned int )((void const   *)("burst-size" +
                                                                                        1)) -
                                                       (unsigned int )((void const   *)"burst-size") ==
                                                       1U)) {
#line 630
                                                  tmp___131 = 1;
                                                } else {
#line 630
                                                  if (__s2_len___8 >= 4U) {
#line 630
                                                    tmp___131 = 1;
                                                  } else {
#line 630
                                                    tmp___131 = 0;
                                                  }
                                                }
                                              } else {
#line 630
                                                tmp___131 = 0;
                                              }
                                            }
#line 630
                                            if (tmp___131) {
#line 630
                                              tmp___127 = __builtin_strcmp((char const   *)node->name,
                                                                           "burst-size");
                                            } else {
#line 630
                                              tmp___130 = __builtin_strcmp((char const   *)node->name,
                                                                           "burst-size");
#line 630
                                              tmp___127 = tmp___130;
                                            }
                                          } else {
#line 630
                                            tmp___130 = __builtin_strcmp((char const   *)node->name,
                                                                         "burst-size");
#line 630
                                            tmp___127 = tmp___130;
                                          }
#line 630
                                          if (tmp___127 == 0) {
#line 631
                                            tmp = (char *)xmlNodeListGetString(doc,
                                                                               node->children,
                                                                               1);
#line 632
                                            mount->burst_size = atoi__extinline((char const   *)tmp);
#line 633
                                            if (tmp) {
#line 633
                                              ((*xmlFree))((void *)tmp);
                                            }
                                          } else {
#line 634
                                            if (0) {
#line 634
                                              __s1_len___7 = strlen((char const   *)node->name);
#line 634
                                              __s2_len___7 = strlen("cluster-password");
#line 634
                                              if (! ((unsigned int )((void const   *)(node->name +
                                                                                      1)) -
                                                     (unsigned int )((void const   *)node->name) ==
                                                     1U)) {
                                                goto _L___16;
                                              } else {
#line 634
                                                if (__s1_len___7 >= 4U) {
                                                  _L___16: /* CIL Label */ 
#line 634
                                                  if (! ((unsigned int )((void const   *)("cluster-password" +
                                                                                          1)) -
                                                         (unsigned int )((void const   *)"cluster-password") ==
                                                         1U)) {
#line 634
                                                    tmp___121 = 1;
                                                  } else {
#line 634
                                                    if (__s2_len___7 >= 4U) {
#line 634
                                                      tmp___121 = 1;
                                                    } else {
#line 634
                                                      tmp___121 = 0;
                                                    }
                                                  }
                                                } else {
#line 634
                                                  tmp___121 = 0;
                                                }
                                              }
#line 634
                                              if (tmp___121) {
#line 634
                                                tmp___117 = __builtin_strcmp((char const   *)node->name,
                                                                             "cluster-password");
                                              } else {
#line 634
                                                tmp___120 = __builtin_strcmp((char const   *)node->name,
                                                                             "cluster-password");
#line 634
                                                tmp___117 = tmp___120;
                                              }
                                            } else {
#line 634
                                              tmp___120 = __builtin_strcmp((char const   *)node->name,
                                                                           "cluster-password");
#line 634
                                              tmp___117 = tmp___120;
                                            }
#line 634
                                            if (tmp___117 == 0) {
#line 635
                                              mount->cluster_password = (char *)xmlNodeListGetString(doc,
                                                                                                     node->children,
                                                                                                     1);
                                            } else {
#line 637
                                              if (0) {
#line 637
                                                __s1_len___6 = strlen((char const   *)node->name);
#line 637
                                                __s2_len___6 = strlen("stream-name");
#line 637
                                                if (! ((unsigned int )((void const   *)(node->name +
                                                                                        1)) -
                                                       (unsigned int )((void const   *)node->name) ==
                                                       1U)) {
                                                  goto _L___14;
                                                } else {
#line 637
                                                  if (__s1_len___6 >= 4U) {
                                                    _L___14: /* CIL Label */ 
#line 637
                                                    if (! ((unsigned int )((void const   *)("stream-name" +
                                                                                            1)) -
                                                           (unsigned int )((void const   *)"stream-name") ==
                                                           1U)) {
#line 637
                                                      tmp___111 = 1;
                                                    } else {
#line 637
                                                      if (__s2_len___6 >= 4U) {
#line 637
                                                        tmp___111 = 1;
                                                      } else {
#line 637
                                                        tmp___111 = 0;
                                                      }
                                                    }
                                                  } else {
#line 637
                                                    tmp___111 = 0;
                                                  }
                                                }
#line 637
                                                if (tmp___111) {
#line 637
                                                  tmp___107 = __builtin_strcmp((char const   *)node->name,
                                                                               "stream-name");
                                                } else {
#line 637
                                                  tmp___110 = __builtin_strcmp((char const   *)node->name,
                                                                               "stream-name");
#line 637
                                                  tmp___107 = tmp___110;
                                                }
                                              } else {
#line 637
                                                tmp___110 = __builtin_strcmp((char const   *)node->name,
                                                                             "stream-name");
#line 637
                                                tmp___107 = tmp___110;
                                              }
#line 637
                                              if (tmp___107 == 0) {
#line 638
                                                mount->stream_name = (char *)xmlNodeListGetString(doc,
                                                                                                  node->children,
                                                                                                  1);
                                              } else {
#line 640
                                                if (0) {
#line 640
                                                  __s1_len___5 = strlen((char const   *)node->name);
#line 640
                                                  __s2_len___5 = strlen("stream-description");
#line 640
                                                  if (! ((unsigned int )((void const   *)(node->name +
                                                                                          1)) -
                                                         (unsigned int )((void const   *)node->name) ==
                                                         1U)) {
                                                    goto _L___12;
                                                  } else {
#line 640
                                                    if (__s1_len___5 >= 4U) {
                                                      _L___12: /* CIL Label */ 
#line 640
                                                      if (! ((unsigned int )((void const   *)("stream-description" +
                                                                                              1)) -
                                                             (unsigned int )((void const   *)"stream-description") ==
                                                             1U)) {
#line 640
                                                        tmp___101 = 1;
                                                      } else {
#line 640
                                                        if (__s2_len___5 >= 4U) {
#line 640
                                                          tmp___101 = 1;
                                                        } else {
#line 640
                                                          tmp___101 = 0;
                                                        }
                                                      }
                                                    } else {
#line 640
                                                      tmp___101 = 0;
                                                    }
                                                  }
#line 640
                                                  if (tmp___101) {
#line 640
                                                    tmp___97 = __builtin_strcmp((char const   *)node->name,
                                                                                "stream-description");
                                                  } else {
#line 640
                                                    tmp___100 = __builtin_strcmp((char const   *)node->name,
                                                                                 "stream-description");
#line 640
                                                    tmp___97 = tmp___100;
                                                  }
                                                } else {
#line 640
                                                  tmp___100 = __builtin_strcmp((char const   *)node->name,
                                                                               "stream-description");
#line 640
                                                  tmp___97 = tmp___100;
                                                }
#line 640
                                                if (tmp___97 == 0) {
#line 641
                                                  mount->stream_description = (char *)xmlNodeListGetString(doc,
                                                                                                           node->children,
                                                                                                           1);
                                                } else {
#line 643
                                                  if (0) {
#line 643
                                                    __s1_len___4 = strlen((char const   *)node->name);
#line 643
                                                    __s2_len___4 = strlen("stream-url");
#line 643
                                                    if (! ((unsigned int )((void const   *)(node->name +
                                                                                            1)) -
                                                           (unsigned int )((void const   *)node->name) ==
                                                           1U)) {
                                                      goto _L___10;
                                                    } else {
#line 643
                                                      if (__s1_len___4 >= 4U) {
                                                        _L___10: /* CIL Label */ 
#line 643
                                                        if (! ((unsigned int )((void const   *)("stream-url" +
                                                                                                1)) -
                                                               (unsigned int )((void const   *)"stream-url") ==
                                                               1U)) {
#line 643
                                                          tmp___91 = 1;
                                                        } else {
#line 643
                                                          if (__s2_len___4 >= 4U) {
#line 643
                                                            tmp___91 = 1;
                                                          } else {
#line 643
                                                            tmp___91 = 0;
                                                          }
                                                        }
                                                      } else {
#line 643
                                                        tmp___91 = 0;
                                                      }
                                                    }
#line 643
                                                    if (tmp___91) {
#line 643
                                                      tmp___87 = __builtin_strcmp((char const   *)node->name,
                                                                                  "stream-url");
                                                    } else {
#line 643
                                                      tmp___90 = __builtin_strcmp((char const   *)node->name,
                                                                                  "stream-url");
#line 643
                                                      tmp___87 = tmp___90;
                                                    }
                                                  } else {
#line 643
                                                    tmp___90 = __builtin_strcmp((char const   *)node->name,
                                                                                "stream-url");
#line 643
                                                    tmp___87 = tmp___90;
                                                  }
#line 643
                                                  if (tmp___87 == 0) {
#line 644
                                                    mount->stream_url = (char *)xmlNodeListGetString(doc,
                                                                                                     node->children,
                                                                                                     1);
                                                  } else {
#line 646
                                                    if (0) {
#line 646
                                                      __s1_len___3 = strlen((char const   *)node->name);
#line 646
                                                      __s2_len___3 = strlen("genre");
#line 646
                                                      if (! ((unsigned int )((void const   *)(node->name +
                                                                                              1)) -
                                                             (unsigned int )((void const   *)node->name) ==
                                                             1U)) {
                                                        goto _L___8;
                                                      } else {
#line 646
                                                        if (__s1_len___3 >= 4U) {
                                                          _L___8: /* CIL Label */ 
#line 646
                                                          if (! ((unsigned int )((void const   *)("genre" +
                                                                                                  1)) -
                                                                 (unsigned int )((void const   *)"genre") ==
                                                                 1U)) {
#line 646
                                                            tmp___81 = 1;
                                                          } else {
#line 646
                                                            if (__s2_len___3 >= 4U) {
#line 646
                                                              tmp___81 = 1;
                                                            } else {
#line 646
                                                              tmp___81 = 0;
                                                            }
                                                          }
                                                        } else {
#line 646
                                                          tmp___81 = 0;
                                                        }
                                                      }
#line 646
                                                      if (tmp___81) {
#line 646
                                                        tmp___77 = __builtin_strcmp((char const   *)node->name,
                                                                                    "genre");
                                                      } else {
#line 646
                                                        tmp___80 = __builtin_strcmp((char const   *)node->name,
                                                                                    "genre");
#line 646
                                                        tmp___77 = tmp___80;
                                                      }
                                                    } else {
#line 646
                                                      tmp___80 = __builtin_strcmp((char const   *)node->name,
                                                                                  "genre");
#line 646
                                                      tmp___77 = tmp___80;
                                                    }
#line 646
                                                    if (tmp___77 == 0) {
#line 647
                                                      mount->stream_genre = (char *)xmlNodeListGetString(doc,
                                                                                                         node->children,
                                                                                                         1);
                                                    } else {
#line 649
                                                      if (0) {
#line 649
                                                        __s1_len___2 = strlen((char const   *)node->name);
#line 649
                                                        __s2_len___2 = strlen("bitrate");
#line 649
                                                        if (! ((unsigned int )((void const   *)(node->name +
                                                                                                1)) -
                                                               (unsigned int )((void const   *)node->name) ==
                                                               1U)) {
                                                          goto _L___6;
                                                        } else {
#line 649
                                                          if (__s1_len___2 >= 4U) {
                                                            _L___6: /* CIL Label */ 
#line 649
                                                            if (! ((unsigned int )((void const   *)("bitrate" +
                                                                                                    1)) -
                                                                   (unsigned int )((void const   *)"bitrate") ==
                                                                   1U)) {
#line 649
                                                              tmp___71 = 1;
                                                            } else {
#line 649
                                                              if (__s2_len___2 >=
                                                                  4U) {
#line 649
                                                                tmp___71 = 1;
                                                              } else {
#line 649
                                                                tmp___71 = 0;
                                                              }
                                                            }
                                                          } else {
#line 649
                                                            tmp___71 = 0;
                                                          }
                                                        }
#line 649
                                                        if (tmp___71) {
#line 649
                                                          tmp___67 = __builtin_strcmp((char const   *)node->name,
                                                                                      "bitrate");
                                                        } else {
#line 649
                                                          tmp___70 = __builtin_strcmp((char const   *)node->name,
                                                                                      "bitrate");
#line 649
                                                          tmp___67 = tmp___70;
                                                        }
                                                      } else {
#line 649
                                                        tmp___70 = __builtin_strcmp((char const   *)node->name,
                                                                                    "bitrate");
#line 649
                                                        tmp___67 = tmp___70;
                                                      }
#line 649
                                                      if (tmp___67 == 0) {
#line 650
                                                        mount->bitrate = (char *)xmlNodeListGetString(doc,
                                                                                                      node->children,
                                                                                                      1);
                                                      } else {
#line 652
                                                        if (0) {
#line 652
                                                          __s1_len___1 = strlen((char const   *)node->name);
#line 652
                                                          __s2_len___1 = strlen("public");
#line 652
                                                          if (! ((unsigned int )((void const   *)(node->name +
                                                                                                  1)) -
                                                                 (unsigned int )((void const   *)node->name) ==
                                                                 1U)) {
                                                            goto _L___4;
                                                          } else {
#line 652
                                                            if (__s1_len___1 >= 4U) {
                                                              _L___4: /* CIL Label */ 
#line 652
                                                              if (! ((unsigned int )((void const   *)("public" +
                                                                                                      1)) -
                                                                     (unsigned int )((void const   *)"public") ==
                                                                     1U)) {
#line 652
                                                                tmp___61 = 1;
                                                              } else {
#line 652
                                                                if (__s2_len___1 >=
                                                                    4U) {
#line 652
                                                                  tmp___61 = 1;
                                                                } else {
#line 652
                                                                  tmp___61 = 0;
                                                                }
                                                              }
                                                            } else {
#line 652
                                                              tmp___61 = 0;
                                                            }
                                                          }
#line 652
                                                          if (tmp___61) {
#line 652
                                                            tmp___57 = __builtin_strcmp((char const   *)node->name,
                                                                                        "public");
                                                          } else {
#line 652
                                                            tmp___60 = __builtin_strcmp((char const   *)node->name,
                                                                                        "public");
#line 652
                                                            tmp___57 = tmp___60;
                                                          }
                                                        } else {
#line 652
                                                          tmp___60 = __builtin_strcmp((char const   *)node->name,
                                                                                      "public");
#line 652
                                                          tmp___57 = tmp___60;
                                                        }
#line 652
                                                        if (tmp___57 == 0) {
#line 653
                                                          tmp = (char *)xmlNodeListGetString(doc,
                                                                                             node->children,
                                                                                             1);
#line 654
                                                          mount->yp_public = atoi__extinline((char const   *)tmp);
#line 655
                                                          if (tmp) {
#line 655
                                                            ((*xmlFree))((void *)tmp);
                                                          }
                                                        } else {
#line 656
                                                          if (0) {
#line 656
                                                            __s1_len___0 = strlen((char const   *)node->name);
#line 656
                                                            __s2_len___0 = strlen("type");
#line 656
                                                            if (! ((unsigned int )((void const   *)(node->name +
                                                                                                    1)) -
                                                                   (unsigned int )((void const   *)node->name) ==
                                                                   1U)) {
                                                              goto _L___2;
                                                            } else {
#line 656
                                                              if (__s1_len___0 >=
                                                                  4U) {
                                                                _L___2: /* CIL Label */ 
#line 656
                                                                if (! ((unsigned int )((void const   *)("type" +
                                                                                                        1)) -
                                                                       (unsigned int )((void const   *)"type") ==
                                                                       1U)) {
#line 656
                                                                  tmp___51 = 1;
                                                                } else {
#line 656
                                                                  if (__s2_len___0 >=
                                                                      4U) {
#line 656
                                                                    tmp___51 = 1;
                                                                  } else {
#line 656
                                                                    tmp___51 = 0;
                                                                  }
                                                                }
                                                              } else {
#line 656
                                                                tmp___51 = 0;
                                                              }
                                                            }
#line 656
                                                            if (tmp___51) {
#line 656
                                                              tmp___47 = __builtin_strcmp((char const   *)node->name,
                                                                                          "type");
                                                            } else {
#line 656
                                                              tmp___50 = __builtin_strcmp((char const   *)node->name,
                                                                                          "type");
#line 656
                                                              tmp___47 = tmp___50;
                                                            }
                                                          } else {
#line 656
                                                            tmp___50 = __builtin_strcmp((char const   *)node->name,
                                                                                        "type");
#line 656
                                                            tmp___47 = tmp___50;
                                                          }
#line 656
                                                          if (tmp___47 == 0) {
#line 657
                                                            mount->type = (char *)xmlNodeListGetString(doc,
                                                                                                       node->children,
                                                                                                       1);
                                                          } else {
#line 659
                                                            if (0) {
#line 659
                                                              __s1_len = strlen((char const   *)node->name);
#line 659
                                                              __s2_len = strlen("subtype");
#line 659
                                                              if (! ((unsigned int )((void const   *)(node->name +
                                                                                                      1)) -
                                                                     (unsigned int )((void const   *)node->name) ==
                                                                     1U)) {
                                                                goto _L___0;
                                                              } else {
#line 659
                                                                if (__s1_len >= 4U) {
                                                                  _L___0: /* CIL Label */ 
#line 659
                                                                  if (! ((unsigned int )((void const   *)("subtype" +
                                                                                                          1)) -
                                                                         (unsigned int )((void const   *)"subtype") ==
                                                                         1U)) {
#line 659
                                                                    tmp___41 = 1;
                                                                  } else {
#line 659
                                                                    if (__s2_len >=
                                                                        4U) {
#line 659
                                                                      tmp___41 = 1;
                                                                    } else {
#line 659
                                                                      tmp___41 = 0;
                                                                    }
                                                                  }
                                                                } else {
#line 659
                                                                  tmp___41 = 0;
                                                                }
                                                              }
#line 659
                                                              if (tmp___41) {
#line 659
                                                                tmp___37 = __builtin_strcmp((char const   *)node->name,
                                                                                            "subtype");
                                                              } else {
#line 659
                                                                tmp___40 = __builtin_strcmp((char const   *)node->name,
                                                                                            "subtype");
#line 659
                                                                tmp___37 = tmp___40;
                                                              }
                                                            } else {
#line 659
                                                              tmp___40 = __builtin_strcmp((char const   *)node->name,
                                                                                          "subtype");
#line 659
                                                              tmp___37 = tmp___40;
                                                            }
#line 659
                                                            if (tmp___37 == 0) {
#line 660
                                                              mount->subtype = (char *)xmlNodeListGetString(doc,
                                                                                                            node->children,
                                                                                                            1);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 539
    node = node->next;
#line 539
    if (! node) {
#line 539
      break;
    }
  }
#line 666
  if ((unsigned int )mount->mountname == (unsigned int )((void *)0)) {
#line 668
    config_clear_mount(mount);
#line 669
    return;
  }
#line 671
  while (current) {
#line 672
    last = current;
#line 673
    current = current->next;
  }
#line 676
  if (last) {
#line 677
    last->next = mount;
  } else {
#line 679
    configuration->mounts = mount;
  }
#line 680
  return;
}
}
#line 683 "cfgfile.c"
static void _parse_relay(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *tmp ;
  relay_server *relay ;
  relay_server *tmp___0 ;
  relay_server *current ;
  relay_server *last ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___75 ;
  int tmp___78 ;
  int tmp___79 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___85 ;
  int tmp___88 ;
  int tmp___89 ;

  {
#line 687
  tmp___0 = (relay_server *)calloc(1U, sizeof(relay_server ));
#line 687
  relay = tmp___0;
#line 688
  current = configuration->relay;
#line 689
  last = (relay_server *)((void *)0);
#line 691
  while (current) {
#line 692
    last = current;
#line 693
    current = current->next;
  }
#line 696
  if (last) {
#line 697
    last->next = relay;
  } else {
#line 699
    configuration->relay = relay;
  }
#line 701
  relay->next = (struct _relay_server *)((void *)0);
#line 702
  relay->mp3metadata = 1;
#line 703
  relay->on_demand = configuration->on_demand;
#line 705
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 707
    tmp___1 = xmlIsBlankNode(node);
#line 707
    if (tmp___1) {
      goto __Cont;
    }
#line 709
    if (0) {
#line 709
      __s1_len___6 = strlen((char const   *)node->name);
#line 709
      __s2_len___6 = strlen("server");
#line 709
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___14;
      } else {
#line 709
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 709
          if (! ((unsigned int )((void const   *)("server" + 1)) - (unsigned int )((void const   *)"server") ==
                 1U)) {
#line 709
            tmp___89 = 1;
          } else {
#line 709
            if (__s2_len___6 >= 4U) {
#line 709
              tmp___89 = 1;
            } else {
#line 709
              tmp___89 = 0;
            }
          }
        } else {
#line 709
          tmp___89 = 0;
        }
      }
#line 709
      if (tmp___89) {
#line 709
        tmp___85 = __builtin_strcmp((char const   *)node->name, "server");
      } else {
#line 709
        tmp___88 = __builtin_strcmp((char const   *)node->name, "server");
#line 709
        tmp___85 = tmp___88;
      }
    } else {
#line 709
      tmp___88 = __builtin_strcmp((char const   *)node->name, "server");
#line 709
      tmp___85 = tmp___88;
    }
#line 709
    if (tmp___85 == 0) {
#line 710
      relay->server = (char *)xmlNodeListGetString(doc, node->children, 1);
    } else {
#line 713
      if (0) {
#line 713
        __s1_len___5 = strlen((char const   *)node->name);
#line 713
        __s2_len___5 = strlen("port");
#line 713
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___12;
        } else {
#line 713
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 713
            if (! ((unsigned int )((void const   *)("port" + 1)) - (unsigned int )((void const   *)"port") ==
                   1U)) {
#line 713
              tmp___79 = 1;
            } else {
#line 713
              if (__s2_len___5 >= 4U) {
#line 713
                tmp___79 = 1;
              } else {
#line 713
                tmp___79 = 0;
              }
            }
          } else {
#line 713
            tmp___79 = 0;
          }
        }
#line 713
        if (tmp___79) {
#line 713
          tmp___75 = __builtin_strcmp((char const   *)node->name, "port");
        } else {
#line 713
          tmp___78 = __builtin_strcmp((char const   *)node->name, "port");
#line 713
          tmp___75 = tmp___78;
        }
      } else {
#line 713
        tmp___78 = __builtin_strcmp((char const   *)node->name, "port");
#line 713
        tmp___75 = tmp___78;
      }
#line 713
      if (tmp___75 == 0) {
#line 714
        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 715
        relay->port = atoi__extinline((char const   *)tmp);
#line 716
        if (tmp) {
#line 716
          ((*xmlFree))((void *)tmp);
        }
      } else {
#line 718
        if (0) {
#line 718
          __s1_len___4 = strlen((char const   *)node->name);
#line 718
          __s2_len___4 = strlen("mount");
#line 718
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___10;
          } else {
#line 718
            if (__s1_len___4 >= 4U) {
              _L___10: /* CIL Label */ 
#line 718
              if (! ((unsigned int )((void const   *)("mount" + 1)) - (unsigned int )((void const   *)"mount") ==
                     1U)) {
#line 718
                tmp___69 = 1;
              } else {
#line 718
                if (__s2_len___4 >= 4U) {
#line 718
                  tmp___69 = 1;
                } else {
#line 718
                  tmp___69 = 0;
                }
              }
            } else {
#line 718
              tmp___69 = 0;
            }
          }
#line 718
          if (tmp___69) {
#line 718
            tmp___65 = __builtin_strcmp((char const   *)node->name, "mount");
          } else {
#line 718
            tmp___68 = __builtin_strcmp((char const   *)node->name, "mount");
#line 718
            tmp___65 = tmp___68;
          }
        } else {
#line 718
          tmp___68 = __builtin_strcmp((char const   *)node->name, "mount");
#line 718
          tmp___65 = tmp___68;
        }
#line 718
        if (tmp___65 == 0) {
#line 719
          relay->mount = (char *)xmlNodeListGetString(doc, node->children, 1);
        } else {
#line 722
          if (0) {
#line 722
            __s1_len___3 = strlen((char const   *)node->name);
#line 722
            __s2_len___3 = strlen("local-mount");
#line 722
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___8;
            } else {
#line 722
              if (__s1_len___3 >= 4U) {
                _L___8: /* CIL Label */ 
#line 722
                if (! ((unsigned int )((void const   *)("local-mount" + 1)) - (unsigned int )((void const   *)"local-mount") ==
                       1U)) {
#line 722
                  tmp___59 = 1;
                } else {
#line 722
                  if (__s2_len___3 >= 4U) {
#line 722
                    tmp___59 = 1;
                  } else {
#line 722
                    tmp___59 = 0;
                  }
                }
              } else {
#line 722
                tmp___59 = 0;
              }
            }
#line 722
            if (tmp___59) {
#line 722
              tmp___55 = __builtin_strcmp((char const   *)node->name, "local-mount");
            } else {
#line 722
              tmp___58 = __builtin_strcmp((char const   *)node->name, "local-mount");
#line 722
              tmp___55 = tmp___58;
            }
          } else {
#line 722
            tmp___58 = __builtin_strcmp((char const   *)node->name, "local-mount");
#line 722
            tmp___55 = tmp___58;
          }
#line 722
          if (tmp___55 == 0) {
#line 723
            relay->localmount = (char *)xmlNodeListGetString(doc, node->children,
                                                             1);
          } else {
#line 726
            if (0) {
#line 726
              __s1_len___2 = strlen((char const   *)node->name);
#line 726
              __s2_len___2 = strlen("relay-shoutcast-metadata");
#line 726
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___6;
              } else {
#line 726
                if (__s1_len___2 >= 4U) {
                  _L___6: /* CIL Label */ 
#line 726
                  if (! ((unsigned int )((void const   *)("relay-shoutcast-metadata" +
                                                          1)) - (unsigned int )((void const   *)"relay-shoutcast-metadata") ==
                         1U)) {
#line 726
                    tmp___49 = 1;
                  } else {
#line 726
                    if (__s2_len___2 >= 4U) {
#line 726
                      tmp___49 = 1;
                    } else {
#line 726
                      tmp___49 = 0;
                    }
                  }
                } else {
#line 726
                  tmp___49 = 0;
                }
              }
#line 726
              if (tmp___49) {
#line 726
                tmp___45 = __builtin_strcmp((char const   *)node->name, "relay-shoutcast-metadata");
              } else {
#line 726
                tmp___48 = __builtin_strcmp((char const   *)node->name, "relay-shoutcast-metadata");
#line 726
                tmp___45 = tmp___48;
              }
            } else {
#line 726
              tmp___48 = __builtin_strcmp((char const   *)node->name, "relay-shoutcast-metadata");
#line 726
              tmp___45 = tmp___48;
            }
#line 726
            if (tmp___45 == 0) {
#line 727
              tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 728
              relay->mp3metadata = atoi__extinline((char const   *)tmp);
#line 729
              if (tmp) {
#line 729
                ((*xmlFree))((void *)tmp);
              }
            } else {
#line 731
              if (0) {
#line 731
                __s1_len___1 = strlen((char const   *)node->name);
#line 731
                __s2_len___1 = strlen("username");
#line 731
                if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                       1U)) {
                  goto _L___4;
                } else {
#line 731
                  if (__s1_len___1 >= 4U) {
                    _L___4: /* CIL Label */ 
#line 731
                    if (! ((unsigned int )((void const   *)("username" + 1)) - (unsigned int )((void const   *)"username") ==
                           1U)) {
#line 731
                      tmp___39 = 1;
                    } else {
#line 731
                      if (__s2_len___1 >= 4U) {
#line 731
                        tmp___39 = 1;
                      } else {
#line 731
                        tmp___39 = 0;
                      }
                    }
                  } else {
#line 731
                    tmp___39 = 0;
                  }
                }
#line 731
                if (tmp___39) {
#line 731
                  tmp___35 = __builtin_strcmp((char const   *)node->name, "username");
                } else {
#line 731
                  tmp___38 = __builtin_strcmp((char const   *)node->name, "username");
#line 731
                  tmp___35 = tmp___38;
                }
              } else {
#line 731
                tmp___38 = __builtin_strcmp((char const   *)node->name, "username");
#line 731
                tmp___35 = tmp___38;
              }
#line 731
              if (tmp___35 == 0) {
#line 732
                relay->username = (char *)xmlNodeListGetString(doc, node->children,
                                                               1);
              } else {
#line 735
                if (0) {
#line 735
                  __s1_len___0 = strlen((char const   *)node->name);
#line 735
                  __s2_len___0 = strlen("password");
#line 735
                  if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                         1U)) {
                    goto _L___2;
                  } else {
#line 735
                    if (__s1_len___0 >= 4U) {
                      _L___2: /* CIL Label */ 
#line 735
                      if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") ==
                             1U)) {
#line 735
                        tmp___29 = 1;
                      } else {
#line 735
                        if (__s2_len___0 >= 4U) {
#line 735
                          tmp___29 = 1;
                        } else {
#line 735
                          tmp___29 = 0;
                        }
                      }
                    } else {
#line 735
                      tmp___29 = 0;
                    }
                  }
#line 735
                  if (tmp___29) {
#line 735
                    tmp___25 = __builtin_strcmp((char const   *)node->name, "password");
                  } else {
#line 735
                    tmp___28 = __builtin_strcmp((char const   *)node->name, "password");
#line 735
                    tmp___25 = tmp___28;
                  }
                } else {
#line 735
                  tmp___28 = __builtin_strcmp((char const   *)node->name, "password");
#line 735
                  tmp___25 = tmp___28;
                }
#line 735
                if (tmp___25 == 0) {
#line 736
                  relay->password = (char *)xmlNodeListGetString(doc, node->children,
                                                                 1);
                } else {
#line 739
                  if (0) {
#line 739
                    __s1_len = strlen((char const   *)node->name);
#line 739
                    __s2_len = strlen("on-demand");
#line 739
                    if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                           1U)) {
                      goto _L___0;
                    } else {
#line 739
                      if (__s1_len >= 4U) {
                        _L___0: /* CIL Label */ 
#line 739
                        if (! ((unsigned int )((void const   *)("on-demand" + 1)) -
                               (unsigned int )((void const   *)"on-demand") == 1U)) {
#line 739
                          tmp___19 = 1;
                        } else {
#line 739
                          if (__s2_len >= 4U) {
#line 739
                            tmp___19 = 1;
                          } else {
#line 739
                            tmp___19 = 0;
                          }
                        }
                      } else {
#line 739
                        tmp___19 = 0;
                      }
                    }
#line 739
                    if (tmp___19) {
#line 739
                      tmp___15 = __builtin_strcmp((char const   *)node->name, "on-demand");
                    } else {
#line 739
                      tmp___18 = __builtin_strcmp((char const   *)node->name, "on-demand");
#line 739
                      tmp___15 = tmp___18;
                    }
                  } else {
#line 739
                    tmp___18 = __builtin_strcmp((char const   *)node->name, "on-demand");
#line 739
                    tmp___15 = tmp___18;
                  }
#line 739
                  if (tmp___15 == 0) {
#line 740
                    tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 741
                    relay->on_demand = atoi__extinline((char const   *)tmp);
#line 742
                    if (tmp) {
#line 742
                      ((*xmlFree))((void *)tmp);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 705
    node = node->next;
#line 705
    if (! node) {
#line 705
      break;
    }
  }
#line 745
  if ((unsigned int )relay->localmount == (unsigned int )((void *)0)) {
#line 746
    relay->localmount = (char *)xmlStrdup((xmlChar const   *)relay->mount);
  }
#line 747
  return;
}
}
#line 749 "cfgfile.c"
static void _parse_listen_socket(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ listener_t *listener ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 752
  listener = (listener_t *)((void *)0);
#line 756
  i = 0;
#line 756
  while (i < 20) {
#line 757
    if (configuration->listeners[i].port <= 0) {
#line 758
      listener = & configuration->listeners[i];
#line 759
      break;
    }
#line 756
    i ++;
  }
#line 763
  if ((unsigned int )listener == (unsigned int )((void *)0)) {
#line 764
    return;
  }
#line 765
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 767
    tmp___0 = xmlIsBlankNode(node);
#line 767
    if (tmp___0) {
      goto __Cont;
    }
#line 769
    if (0) {
#line 769
      __s1_len___1 = strlen((char const   *)node->name);
#line 769
      __s2_len___1 = strlen("port");
#line 769
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___4;
      } else {
#line 769
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 769
          if (! ((unsigned int )((void const   *)("port" + 1)) - (unsigned int )((void const   *)"port") ==
                 1U)) {
#line 769
            tmp___33 = 1;
          } else {
#line 769
            if (__s2_len___1 >= 4U) {
#line 769
              tmp___33 = 1;
            } else {
#line 769
              tmp___33 = 0;
            }
          }
        } else {
#line 769
          tmp___33 = 0;
        }
      }
#line 769
      if (tmp___33) {
#line 769
        tmp___29 = __builtin_strcmp((char const   *)node->name, "port");
      } else {
#line 769
        tmp___32 = __builtin_strcmp((char const   *)node->name, "port");
#line 769
        tmp___29 = tmp___32;
      }
    } else {
#line 769
      tmp___32 = __builtin_strcmp((char const   *)node->name, "port");
#line 769
      tmp___29 = tmp___32;
    }
#line 769
    if (tmp___29 == 0) {
#line 770
      tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 771
      if (configuration->port == 0) {
#line 772
        configuration->port = atoi__extinline((char const   *)tmp);
      }
#line 773
      listener->port = atoi__extinline((char const   *)tmp);
#line 774
      if (tmp) {
#line 774
        ((*xmlFree))((void *)tmp);
      }
    } else {
#line 776
      if (0) {
#line 776
        __s1_len___0 = strlen((char const   *)node->name);
#line 776
        __s2_len___0 = strlen("shoutcast-compat");
#line 776
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___2;
        } else {
#line 776
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 776
            if (! ((unsigned int )((void const   *)("shoutcast-compat" + 1)) - (unsigned int )((void const   *)"shoutcast-compat") ==
                   1U)) {
#line 776
              tmp___23 = 1;
            } else {
#line 776
              if (__s2_len___0 >= 4U) {
#line 776
                tmp___23 = 1;
              } else {
#line 776
                tmp___23 = 0;
              }
            }
          } else {
#line 776
            tmp___23 = 0;
          }
        }
#line 776
        if (tmp___23) {
#line 776
          tmp___19 = __builtin_strcmp((char const   *)node->name, "shoutcast-compat");
        } else {
#line 776
          tmp___22 = __builtin_strcmp((char const   *)node->name, "shoutcast-compat");
#line 776
          tmp___19 = tmp___22;
        }
      } else {
#line 776
        tmp___22 = __builtin_strcmp((char const   *)node->name, "shoutcast-compat");
#line 776
        tmp___19 = tmp___22;
      }
#line 776
      if (tmp___19 == 0) {
#line 777
        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 778
        listener->shoutcast_compat = atoi__extinline((char const   *)tmp);
#line 779
        if (tmp) {
#line 779
          ((*xmlFree))((void *)tmp);
        }
      } else {
#line 781
        if (0) {
#line 781
          __s1_len = strlen((char const   *)node->name);
#line 781
          __s2_len = strlen("bind-address");
#line 781
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___0;
          } else {
#line 781
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 781
              if (! ((unsigned int )((void const   *)("bind-address" + 1)) - (unsigned int )((void const   *)"bind-address") ==
                     1U)) {
#line 781
                tmp___13 = 1;
              } else {
#line 781
                if (__s2_len >= 4U) {
#line 781
                  tmp___13 = 1;
                } else {
#line 781
                  tmp___13 = 0;
                }
              }
            } else {
#line 781
              tmp___13 = 0;
            }
          }
#line 781
          if (tmp___13) {
#line 781
            tmp___9 = __builtin_strcmp((char const   *)node->name, "bind-address");
          } else {
#line 781
            tmp___12 = __builtin_strcmp((char const   *)node->name, "bind-address");
#line 781
            tmp___9 = tmp___12;
          }
        } else {
#line 781
          tmp___12 = __builtin_strcmp((char const   *)node->name, "bind-address");
#line 781
          tmp___9 = tmp___12;
        }
#line 781
        if (tmp___9 == 0) {
#line 782
          listener->bind_address = (char *)xmlNodeListGetString(doc, node->children,
                                                                1);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 765
    node = node->next;
#line 765
    if (! node) {
#line 765
      break;
    }
  }
#line 786
  return;
}
}
#line 788 "cfgfile.c"
static void _parse_authentication(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ int tmp ;
  char *mount ;
  char *pass ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___52 ;
  int tmp___55 ;
  int tmp___56 ;

  {
#line 791
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 793
    tmp = xmlIsBlankNode(node);
#line 793
    if (tmp) {
      goto __Cont;
    }
#line 795
    if (0) {
#line 795
      __s1_len___3 = strlen((char const   *)node->name);
#line 795
      __s2_len___3 = strlen("source-password");
#line 795
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___8;
      } else {
#line 795
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 795
          if (! ((unsigned int )((void const   *)("source-password" + 1)) - (unsigned int )((void const   *)"source-password") ==
                 1U)) {
#line 795
            tmp___56 = 1;
          } else {
#line 795
            if (__s2_len___3 >= 4U) {
#line 795
              tmp___56 = 1;
            } else {
#line 795
              tmp___56 = 0;
            }
          }
        } else {
#line 795
          tmp___56 = 0;
        }
      }
#line 795
      if (tmp___56) {
#line 795
        tmp___52 = __builtin_strcmp((char const   *)node->name, "source-password");
      } else {
#line 795
        tmp___55 = __builtin_strcmp((char const   *)node->name, "source-password");
#line 795
        tmp___52 = tmp___55;
      }
    } else {
#line 795
      tmp___55 = __builtin_strcmp((char const   *)node->name, "source-password");
#line 795
      tmp___52 = tmp___55;
    }
#line 795
    if (tmp___52 == 0) {
#line 797
      mount = (char *)xmlGetProp(node, (xmlChar const   *)"mount");
#line 797
      if ((unsigned int )mount != (unsigned int )((void *)0)) {
#line 798
        pass = (char *)xmlNodeListGetString(doc, node->children, 1);
      } else {
#line 802
        if (configuration->source_password) {
#line 802
          if ((unsigned int )configuration->source_password != (unsigned int )CONFIG_DEFAULT_SOURCE_PASSWORD) {
#line 805
            ((*xmlFree))((void *)configuration->source_password);
          }
        }
#line 806
        configuration->source_password = (char *)xmlNodeListGetString(doc, node->children,
                                                                      1);
      }
    } else {
#line 809
      if (0) {
#line 809
        __s1_len___2 = strlen((char const   *)node->name);
#line 809
        __s2_len___2 = strlen("admin-password");
#line 809
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___6;
        } else {
#line 809
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 809
            if (! ((unsigned int )((void const   *)("admin-password" + 1)) - (unsigned int )((void const   *)"admin-password") ==
                   1U)) {
#line 809
              tmp___46 = 1;
            } else {
#line 809
              if (__s2_len___2 >= 4U) {
#line 809
                tmp___46 = 1;
              } else {
#line 809
                tmp___46 = 0;
              }
            }
          } else {
#line 809
            tmp___46 = 0;
          }
        }
#line 809
        if (tmp___46) {
#line 809
          tmp___42 = __builtin_strcmp((char const   *)node->name, "admin-password");
        } else {
#line 809
          tmp___45 = __builtin_strcmp((char const   *)node->name, "admin-password");
#line 809
          tmp___42 = tmp___45;
        }
      } else {
#line 809
        tmp___45 = __builtin_strcmp((char const   *)node->name, "admin-password");
#line 809
        tmp___42 = tmp___45;
      }
#line 809
      if (tmp___42 == 0) {
#line 810
        if (configuration->admin_password) {
#line 811
          ((*xmlFree))((void *)configuration->admin_password);
        }
#line 812
        configuration->admin_password = (char *)xmlNodeListGetString(doc, node->children,
                                                                     1);
      } else {
#line 814
        if (0) {
#line 814
          __s1_len___1 = strlen((char const   *)node->name);
#line 814
          __s2_len___1 = strlen("admin-user");
#line 814
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___4;
          } else {
#line 814
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 814
              if (! ((unsigned int )((void const   *)("admin-user" + 1)) - (unsigned int )((void const   *)"admin-user") ==
                     1U)) {
#line 814
                tmp___36 = 1;
              } else {
#line 814
                if (__s2_len___1 >= 4U) {
#line 814
                  tmp___36 = 1;
                } else {
#line 814
                  tmp___36 = 0;
                }
              }
            } else {
#line 814
              tmp___36 = 0;
            }
          }
#line 814
          if (tmp___36) {
#line 814
            tmp___32 = __builtin_strcmp((char const   *)node->name, "admin-user");
          } else {
#line 814
            tmp___35 = __builtin_strcmp((char const   *)node->name, "admin-user");
#line 814
            tmp___32 = tmp___35;
          }
        } else {
#line 814
          tmp___35 = __builtin_strcmp((char const   *)node->name, "admin-user");
#line 814
          tmp___32 = tmp___35;
        }
#line 814
        if (tmp___32 == 0) {
#line 815
          if (configuration->admin_username) {
#line 816
            ((*xmlFree))((void *)configuration->admin_username);
          }
#line 817
          configuration->admin_username = (char *)xmlNodeListGetString(doc, node->children,
                                                                       1);
        } else {
#line 819
          if (0) {
#line 819
            __s1_len___0 = strlen((char const   *)node->name);
#line 819
            __s2_len___0 = strlen("relay-password");
#line 819
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___2;
            } else {
#line 819
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 819
                if (! ((unsigned int )((void const   *)("relay-password" + 1)) - (unsigned int )((void const   *)"relay-password") ==
                       1U)) {
#line 819
                  tmp___26 = 1;
                } else {
#line 819
                  if (__s2_len___0 >= 4U) {
#line 819
                    tmp___26 = 1;
                  } else {
#line 819
                    tmp___26 = 0;
                  }
                }
              } else {
#line 819
                tmp___26 = 0;
              }
            }
#line 819
            if (tmp___26) {
#line 819
              tmp___22 = __builtin_strcmp((char const   *)node->name, "relay-password");
            } else {
#line 819
              tmp___25 = __builtin_strcmp((char const   *)node->name, "relay-password");
#line 819
              tmp___22 = tmp___25;
            }
          } else {
#line 819
            tmp___25 = __builtin_strcmp((char const   *)node->name, "relay-password");
#line 819
            tmp___22 = tmp___25;
          }
#line 819
          if (tmp___22 == 0) {
#line 820
            if (configuration->relay_password) {
#line 821
              ((*xmlFree))((void *)configuration->relay_password);
            }
#line 822
            configuration->relay_password = (char *)xmlNodeListGetString(doc, node->children,
                                                                         1);
          } else {
#line 824
            if (0) {
#line 824
              __s1_len = strlen((char const   *)node->name);
#line 824
              __s2_len = strlen("relay-user");
#line 824
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___0;
              } else {
#line 824
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 824
                  if (! ((unsigned int )((void const   *)("relay-user" + 1)) - (unsigned int )((void const   *)"relay-user") ==
                         1U)) {
#line 824
                    tmp___16 = 1;
                  } else {
#line 824
                    if (__s2_len >= 4U) {
#line 824
                      tmp___16 = 1;
                    } else {
#line 824
                      tmp___16 = 0;
                    }
                  }
                } else {
#line 824
                  tmp___16 = 0;
                }
              }
#line 824
              if (tmp___16) {
#line 824
                tmp___12 = __builtin_strcmp((char const   *)node->name, "relay-user");
              } else {
#line 824
                tmp___15 = __builtin_strcmp((char const   *)node->name, "relay-user");
#line 824
                tmp___12 = tmp___15;
              }
            } else {
#line 824
              tmp___15 = __builtin_strcmp((char const   *)node->name, "relay-user");
#line 824
              tmp___12 = tmp___15;
            }
#line 824
            if (tmp___12 == 0) {
#line 825
              if (configuration->relay_username) {
#line 826
                ((*xmlFree))((void *)configuration->relay_username);
              }
#line 827
              configuration->relay_username = (char *)xmlNodeListGetString(doc, node->children,
                                                                           1);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 791
    node = node->next;
#line 791
    if (! node) {
#line 791
      break;
    }
  }
#line 831
  return;
}
}
#line 833 "cfgfile.c"
static void _parse_directory(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 838
  if (configuration->num_yp_directories >= 25) {
#line 839
    log_write(errorlog, 1U, "CONFIG/", "_parse_directory", "Maximum number of yp directories exceeded!");
#line 840
    return;
  }
#line 842
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 844
    tmp___0 = xmlIsBlankNode(node);
#line 844
    if (tmp___0) {
      goto __Cont;
    }
#line 846
    if (0) {
#line 846
      __s1_len___2 = strlen((char const   *)node->name);
#line 846
      __s2_len___2 = strlen("yp-url");
#line 846
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___6;
      } else {
#line 846
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 846
          if (! ((unsigned int )((void const   *)("yp-url" + 1)) - (unsigned int )((void const   *)"yp-url") ==
                 1U)) {
#line 846
            tmp___43 = 1;
          } else {
#line 846
            if (__s2_len___2 >= 4U) {
#line 846
              tmp___43 = 1;
            } else {
#line 846
              tmp___43 = 0;
            }
          }
        } else {
#line 846
          tmp___43 = 0;
        }
      }
#line 846
      if (tmp___43) {
#line 846
        tmp___39 = __builtin_strcmp((char const   *)node->name, "yp-url");
      } else {
#line 846
        tmp___42 = __builtin_strcmp((char const   *)node->name, "yp-url");
#line 846
        tmp___39 = tmp___42;
      }
    } else {
#line 846
      tmp___42 = __builtin_strcmp((char const   *)node->name, "yp-url");
#line 846
      tmp___39 = tmp___42;
    }
#line 846
    if (tmp___39 == 0) {
#line 847
      if (configuration->yp_url[configuration->num_yp_directories]) {
#line 848
        ((*xmlFree))((void *)configuration->yp_url[configuration->num_yp_directories]);
      }
#line 849
      configuration->yp_url[configuration->num_yp_directories] = (char *)xmlNodeListGetString(doc,
                                                                                              node->children,
                                                                                              1);
    } else {
#line 851
      if (0) {
#line 851
        __s1_len___1 = strlen((char const   *)node->name);
#line 851
        __s2_len___1 = strlen("yp-url-timeout");
#line 851
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___4;
        } else {
#line 851
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 851
            if (! ((unsigned int )((void const   *)("yp-url-timeout" + 1)) - (unsigned int )((void const   *)"yp-url-timeout") ==
                   1U)) {
#line 851
              tmp___33 = 1;
            } else {
#line 851
              if (__s2_len___1 >= 4U) {
#line 851
                tmp___33 = 1;
              } else {
#line 851
                tmp___33 = 0;
              }
            }
          } else {
#line 851
            tmp___33 = 0;
          }
        }
#line 851
        if (tmp___33) {
#line 851
          tmp___29 = __builtin_strcmp((char const   *)node->name, "yp-url-timeout");
        } else {
#line 851
          tmp___32 = __builtin_strcmp((char const   *)node->name, "yp-url-timeout");
#line 851
          tmp___29 = tmp___32;
        }
      } else {
#line 851
        tmp___32 = __builtin_strcmp((char const   *)node->name, "yp-url-timeout");
#line 851
        tmp___29 = tmp___32;
      }
#line 851
      if (tmp___29 == 0) {
#line 852
        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 853
        configuration->yp_url_timeout[configuration->num_yp_directories] = atoi__extinline((char const   *)tmp);
#line 855
        if (tmp) {
#line 855
          ((*xmlFree))((void *)tmp);
        }
      } else {
#line 856
        if (0) {
#line 856
          __s1_len___0 = strlen((char const   *)node->name);
#line 856
          __s2_len___0 = strlen("server");
#line 856
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___2;
          } else {
#line 856
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 856
              if (! ((unsigned int )((void const   *)("server" + 1)) - (unsigned int )((void const   *)"server") ==
                     1U)) {
#line 856
                tmp___23 = 1;
              } else {
#line 856
                if (__s2_len___0 >= 4U) {
#line 856
                  tmp___23 = 1;
                } else {
#line 856
                  tmp___23 = 0;
                }
              }
            } else {
#line 856
              tmp___23 = 0;
            }
          }
#line 856
          if (tmp___23) {
#line 856
            tmp___19 = __builtin_strcmp((char const   *)node->name, "server");
          } else {
#line 856
            tmp___22 = __builtin_strcmp((char const   *)node->name, "server");
#line 856
            tmp___19 = tmp___22;
          }
        } else {
#line 856
          tmp___22 = __builtin_strcmp((char const   *)node->name, "server");
#line 856
          tmp___19 = tmp___22;
        }
#line 856
        if (tmp___19 == 0) {
#line 857
          _add_server(doc, node->children, configuration);
        } else {
#line 858
          if (0) {
#line 858
            __s1_len = strlen((char const   *)node->name);
#line 858
            __s2_len = strlen("touch-interval");
#line 858
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___0;
            } else {
#line 858
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 858
                if (! ((unsigned int )((void const   *)("touch-interval" + 1)) - (unsigned int )((void const   *)"touch-interval") ==
                       1U)) {
#line 858
                  tmp___13 = 1;
                } else {
#line 858
                  if (__s2_len >= 4U) {
#line 858
                    tmp___13 = 1;
                  } else {
#line 858
                    tmp___13 = 0;
                  }
                }
              } else {
#line 858
                tmp___13 = 0;
              }
            }
#line 858
            if (tmp___13) {
#line 858
              tmp___9 = __builtin_strcmp((char const   *)node->name, "touch-interval");
            } else {
#line 858
              tmp___12 = __builtin_strcmp((char const   *)node->name, "touch-interval");
#line 858
              tmp___9 = tmp___12;
            }
          } else {
#line 858
            tmp___12 = __builtin_strcmp((char const   *)node->name, "touch-interval");
#line 858
            tmp___9 = tmp___12;
          }
#line 858
          if (tmp___9 == 0) {
#line 859
            tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 860
            configuration->yp_touch_interval[configuration->num_yp_directories] = atoi__extinline((char const   *)tmp);
#line 862
            if (tmp) {
#line 862
              ((*xmlFree))((void *)tmp);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 842
    node = node->next;
#line 842
    if (! node) {
#line 842
      break;
    }
  }
#line 865
  configuration->num_yp_directories = configuration->num_yp_directories + 1;
#line 866
  return;
}
}
#line 868 "cfgfile.c"
static void _parse_paths(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *temp ;
  aliases *alias ;
  aliases *current ;
  aliases *last ;
  int tmp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;

  {
#line 874
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 876
    tmp = xmlIsBlankNode(node);
#line 876
    if (tmp) {
      goto __Cont;
    }
#line 878
    if (0) {
#line 878
      __s1_len___4 = strlen((char const   *)node->name);
#line 878
      __s2_len___4 = strlen("basedir");
#line 878
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___10;
      } else {
#line 878
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 878
          if (! ((unsigned int )((void const   *)("basedir" + 1)) - (unsigned int )((void const   *)"basedir") ==
                 1U)) {
#line 878
            tmp___68 = 1;
          } else {
#line 878
            if (__s2_len___4 >= 4U) {
#line 878
              tmp___68 = 1;
            } else {
#line 878
              tmp___68 = 0;
            }
          }
        } else {
#line 878
          tmp___68 = 0;
        }
      }
#line 878
      if (tmp___68) {
#line 878
        tmp___64 = __builtin_strcmp((char const   *)node->name, "basedir");
      } else {
#line 878
        tmp___67 = __builtin_strcmp((char const   *)node->name, "basedir");
#line 878
        tmp___64 = tmp___67;
      }
    } else {
#line 878
      tmp___67 = __builtin_strcmp((char const   *)node->name, "basedir");
#line 878
      tmp___64 = tmp___67;
    }
#line 878
    if (tmp___64 == 0) {
#line 879
      if (configuration->base_dir) {
#line 879
        if ((unsigned int )configuration->base_dir != (unsigned int )CONFIG_DEFAULT_BASE_DIR) {
#line 879
          ((*xmlFree))((void *)configuration->base_dir);
        }
      }
#line 880
      configuration->base_dir = (char *)xmlNodeListGetString(doc, node->children,
                                                             1);
    } else {
#line 881
      if (0) {
#line 881
        __s1_len___3 = strlen((char const   *)node->name);
#line 881
        __s2_len___3 = strlen("logdir");
#line 881
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___8;
        } else {
#line 881
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 881
            if (! ((unsigned int )((void const   *)("logdir" + 1)) - (unsigned int )((void const   *)"logdir") ==
                   1U)) {
#line 881
              tmp___58 = 1;
            } else {
#line 881
              if (__s2_len___3 >= 4U) {
#line 881
                tmp___58 = 1;
              } else {
#line 881
                tmp___58 = 0;
              }
            }
          } else {
#line 881
            tmp___58 = 0;
          }
        }
#line 881
        if (tmp___58) {
#line 881
          tmp___54 = __builtin_strcmp((char const   *)node->name, "logdir");
        } else {
#line 881
          tmp___57 = __builtin_strcmp((char const   *)node->name, "logdir");
#line 881
          tmp___54 = tmp___57;
        }
      } else {
#line 881
        tmp___57 = __builtin_strcmp((char const   *)node->name, "logdir");
#line 881
        tmp___54 = tmp___57;
      }
#line 881
      if (tmp___54 == 0) {
#line 882
        if (configuration->log_dir) {
#line 882
          if ((unsigned int )configuration->log_dir != (unsigned int )CONFIG_DEFAULT_LOG_DIR) {
#line 882
            ((*xmlFree))((void *)configuration->log_dir);
          }
        }
#line 883
        configuration->log_dir = (char *)xmlNodeListGetString(doc, node->children,
                                                              1);
      } else {
#line 884
        if (0) {
#line 884
          __s1_len___2 = strlen((char const   *)node->name);
#line 884
          __s2_len___2 = strlen("pidfile");
#line 884
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___6;
          } else {
#line 884
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 884
              if (! ((unsigned int )((void const   *)("pidfile" + 1)) - (unsigned int )((void const   *)"pidfile") ==
                     1U)) {
#line 884
                tmp___48 = 1;
              } else {
#line 884
                if (__s2_len___2 >= 4U) {
#line 884
                  tmp___48 = 1;
                } else {
#line 884
                  tmp___48 = 0;
                }
              }
            } else {
#line 884
              tmp___48 = 0;
            }
          }
#line 884
          if (tmp___48) {
#line 884
            tmp___44 = __builtin_strcmp((char const   *)node->name, "pidfile");
          } else {
#line 884
            tmp___47 = __builtin_strcmp((char const   *)node->name, "pidfile");
#line 884
            tmp___44 = tmp___47;
          }
        } else {
#line 884
          tmp___47 = __builtin_strcmp((char const   *)node->name, "pidfile");
#line 884
          tmp___44 = tmp___47;
        }
#line 884
        if (tmp___44 == 0) {
#line 885
          if (configuration->pidfile) {
#line 885
            ((*xmlFree))((void *)configuration->pidfile);
          }
#line 886
          configuration->pidfile = (char *)xmlNodeListGetString(doc, node->children,
                                                                1);
        } else {
#line 887
          if (0) {
#line 887
            __s1_len___1 = strlen((char const   *)node->name);
#line 887
            __s2_len___1 = strlen("webroot");
#line 887
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___4;
            } else {
#line 887
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 887
                if (! ((unsigned int )((void const   *)("webroot" + 1)) - (unsigned int )((void const   *)"webroot") ==
                       1U)) {
#line 887
                  tmp___38 = 1;
                } else {
#line 887
                  if (__s2_len___1 >= 4U) {
#line 887
                    tmp___38 = 1;
                  } else {
#line 887
                    tmp___38 = 0;
                  }
                }
              } else {
#line 887
                tmp___38 = 0;
              }
            }
#line 887
            if (tmp___38) {
#line 887
              tmp___34 = __builtin_strcmp((char const   *)node->name, "webroot");
            } else {
#line 887
              tmp___37 = __builtin_strcmp((char const   *)node->name, "webroot");
#line 887
              tmp___34 = tmp___37;
            }
          } else {
#line 887
            tmp___37 = __builtin_strcmp((char const   *)node->name, "webroot");
#line 887
            tmp___34 = tmp___37;
          }
#line 887
          if (tmp___34 == 0) {
#line 888
            if (configuration->webroot_dir) {
#line 888
              if ((unsigned int )configuration->webroot_dir != (unsigned int )CONFIG_DEFAULT_WEBROOT_DIR) {
#line 888
                ((*xmlFree))((void *)configuration->webroot_dir);
              }
            }
#line 889
            configuration->webroot_dir = (char *)xmlNodeListGetString(doc, node->children,
                                                                      1);
#line 890
            tmp___5 = strlen((char const   *)configuration->webroot_dir);
#line 890
            if ((int )(*(configuration->webroot_dir + (tmp___5 - 1U))) == 47) {
#line 891
              tmp___4 = strlen((char const   *)configuration->webroot_dir);
#line 891
              (*(configuration->webroot_dir + (tmp___4 - 1U))) = (char)0;
            }
          } else {
#line 892
            if (0) {
#line 892
              __s1_len___0 = strlen((char const   *)node->name);
#line 892
              __s2_len___0 = strlen("adminroot");
#line 892
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___2;
              } else {
#line 892
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 892
                  if (! ((unsigned int )((void const   *)("adminroot" + 1)) - (unsigned int )((void const   *)"adminroot") ==
                         1U)) {
#line 892
                    tmp___28 = 1;
                  } else {
#line 892
                    if (__s2_len___0 >= 4U) {
#line 892
                      tmp___28 = 1;
                    } else {
#line 892
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 892
                  tmp___28 = 0;
                }
              }
#line 892
              if (tmp___28) {
#line 892
                tmp___24 = __builtin_strcmp((char const   *)node->name, "adminroot");
              } else {
#line 892
                tmp___27 = __builtin_strcmp((char const   *)node->name, "adminroot");
#line 892
                tmp___24 = tmp___27;
              }
            } else {
#line 892
              tmp___27 = __builtin_strcmp((char const   *)node->name, "adminroot");
#line 892
              tmp___24 = tmp___27;
            }
#line 892
            if (tmp___24 == 0) {
#line 893
              if (configuration->adminroot_dir) {
#line 893
                if ((unsigned int )configuration->adminroot_dir != (unsigned int )CONFIG_DEFAULT_ADMINROOT_DIR) {
#line 894
                  ((*xmlFree))((void *)configuration->adminroot_dir);
                }
              }
#line 895
              configuration->adminroot_dir = (char *)xmlNodeListGetString(doc, node->children,
                                                                          1);
#line 896
              tmp___8 = strlen((char const   *)configuration->adminroot_dir);
#line 896
              if ((int )(*(configuration->adminroot_dir + (tmp___8 - 1U))) == 47) {
#line 897
                tmp___7 = strlen((char const   *)configuration->adminroot_dir);
#line 897
                (*(configuration->adminroot_dir + (tmp___7 - 1U))) = (char)0;
              }
            } else {
#line 898
              if (0) {
#line 898
                __s1_len = strlen((char const   *)node->name);
#line 898
                __s2_len = strlen("alias");
#line 898
                if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                       1U)) {
                  goto _L___0;
                } else {
#line 898
                  if (__s1_len >= 4U) {
                    _L___0: /* CIL Label */ 
#line 898
                    if (! ((unsigned int )((void const   *)("alias" + 1)) - (unsigned int )((void const   *)"alias") ==
                           1U)) {
#line 898
                      tmp___18 = 1;
                    } else {
#line 898
                      if (__s2_len >= 4U) {
#line 898
                        tmp___18 = 1;
                      } else {
#line 898
                        tmp___18 = 0;
                      }
                    }
                  } else {
#line 898
                    tmp___18 = 0;
                  }
                }
#line 898
                if (tmp___18) {
#line 898
                  tmp___14 = __builtin_strcmp((char const   *)node->name, "alias");
                } else {
#line 898
                  tmp___17 = __builtin_strcmp((char const   *)node->name, "alias");
#line 898
                  tmp___14 = tmp___17;
                }
              } else {
#line 898
                tmp___17 = __builtin_strcmp((char const   *)node->name, "alias");
#line 898
                tmp___14 = tmp___17;
              }
#line 898
              if (tmp___14 == 0) {
#line 899
                alias = (aliases *)malloc(sizeof(aliases ));
#line 900
                alias->next = (struct _aliases *)((void *)0);
#line 901
                alias->source = (char *)xmlGetProp(node, (xmlChar const   *)"source");
#line 902
                if ((unsigned int )alias->source == (unsigned int )((void *)0)) {
#line 903
                  free((void *)alias);
                  goto __Cont;
                }
#line 906
                alias->destination = (char *)xmlGetProp(node, (xmlChar const   *)"dest");
#line 907
                if ((unsigned int )alias->destination == (unsigned int )((void *)0)) {
#line 908
                  ((*xmlFree))((void *)alias->source);
#line 909
                  free((void *)alias);
                  goto __Cont;
                }
#line 912
                temp = (char *)((void *)0);
#line 913
                temp = (char *)xmlGetProp(node, (xmlChar const   *)"port");
#line 914
                if ((unsigned int )temp != (unsigned int )((void *)0)) {
#line 915
                  alias->port = atoi__extinline((char const   *)temp);
#line 916
                  ((*xmlFree))((void *)temp);
                } else {
#line 919
                  alias->port = -1;
                }
#line 920
                alias->bind_address = (char *)xmlGetProp(node, (xmlChar const   *)"bind-address");
#line 921
                current = configuration->aliases;
#line 922
                last = (aliases *)((void *)0);
#line 923
                while (current) {
#line 924
                  last = current;
#line 925
                  current = current->next;
                }
#line 927
                if (last) {
#line 928
                  last->next = alias;
                } else {
#line 930
                  configuration->aliases = alias;
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 874
    node = node->next;
#line 874
    if (! node) {
#line 874
      break;
    }
  }
#line 933
  return;
}
}
#line 935 "cfgfile.c"
static void _parse_logging(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ int tmp ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;

  {
#line 938
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 940
    tmp = xmlIsBlankNode(node);
#line 940
    if (tmp) {
      goto __Cont;
    }
#line 942
    if (0) {
#line 942
      __s1_len___4 = strlen((char const   *)node->name);
#line 942
      __s2_len___4 = strlen("accesslog");
#line 942
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___10;
      } else {
#line 942
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 942
          if (! ((unsigned int )((void const   *)("accesslog" + 1)) - (unsigned int )((void const   *)"accesslog") ==
                 1U)) {
#line 942
            tmp___68 = 1;
          } else {
#line 942
            if (__s2_len___4 >= 4U) {
#line 942
              tmp___68 = 1;
            } else {
#line 942
              tmp___68 = 0;
            }
          }
        } else {
#line 942
          tmp___68 = 0;
        }
      }
#line 942
      if (tmp___68) {
#line 942
        tmp___64 = __builtin_strcmp((char const   *)node->name, "accesslog");
      } else {
#line 942
        tmp___67 = __builtin_strcmp((char const   *)node->name, "accesslog");
#line 942
        tmp___64 = tmp___67;
      }
    } else {
#line 942
      tmp___67 = __builtin_strcmp((char const   *)node->name, "accesslog");
#line 942
      tmp___64 = tmp___67;
    }
#line 942
    if (tmp___64 == 0) {
#line 943
      if (configuration->access_log) {
#line 943
        if ((unsigned int )configuration->access_log != (unsigned int )CONFIG_DEFAULT_ACCESS_LOG) {
#line 943
          ((*xmlFree))((void *)configuration->access_log);
        }
      }
#line 944
      configuration->access_log = (char *)xmlNodeListGetString(doc, node->children,
                                                               1);
    } else {
#line 945
      if (0) {
#line 945
        __s1_len___3 = strlen((char const   *)node->name);
#line 945
        __s2_len___3 = strlen("errorlog");
#line 945
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___8;
        } else {
#line 945
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 945
            if (! ((unsigned int )((void const   *)("errorlog" + 1)) - (unsigned int )((void const   *)"errorlog") ==
                   1U)) {
#line 945
              tmp___58 = 1;
            } else {
#line 945
              if (__s2_len___3 >= 4U) {
#line 945
                tmp___58 = 1;
              } else {
#line 945
                tmp___58 = 0;
              }
            }
          } else {
#line 945
            tmp___58 = 0;
          }
        }
#line 945
        if (tmp___58) {
#line 945
          tmp___54 = __builtin_strcmp((char const   *)node->name, "errorlog");
        } else {
#line 945
          tmp___57 = __builtin_strcmp((char const   *)node->name, "errorlog");
#line 945
          tmp___54 = tmp___57;
        }
      } else {
#line 945
        tmp___57 = __builtin_strcmp((char const   *)node->name, "errorlog");
#line 945
        tmp___54 = tmp___57;
      }
#line 945
      if (tmp___54 == 0) {
#line 946
        if (configuration->error_log) {
#line 946
          if ((unsigned int )configuration->error_log != (unsigned int )CONFIG_DEFAULT_ERROR_LOG) {
#line 946
            ((*xmlFree))((void *)configuration->error_log);
          }
        }
#line 947
        configuration->error_log = (char *)xmlNodeListGetString(doc, node->children,
                                                                1);
      } else {
#line 948
        if (0) {
#line 948
          __s1_len___2 = strlen((char const   *)node->name);
#line 948
          __s2_len___2 = strlen("playlistlog");
#line 948
          if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                 1U)) {
            goto _L___6;
          } else {
#line 948
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 948
              if (! ((unsigned int )((void const   *)("playlistlog" + 1)) - (unsigned int )((void const   *)"playlistlog") ==
                     1U)) {
#line 948
                tmp___48 = 1;
              } else {
#line 948
                if (__s2_len___2 >= 4U) {
#line 948
                  tmp___48 = 1;
                } else {
#line 948
                  tmp___48 = 0;
                }
              }
            } else {
#line 948
              tmp___48 = 0;
            }
          }
#line 948
          if (tmp___48) {
#line 948
            tmp___44 = __builtin_strcmp((char const   *)node->name, "playlistlog");
          } else {
#line 948
            tmp___47 = __builtin_strcmp((char const   *)node->name, "playlistlog");
#line 948
            tmp___44 = tmp___47;
          }
        } else {
#line 948
          tmp___47 = __builtin_strcmp((char const   *)node->name, "playlistlog");
#line 948
          tmp___44 = tmp___47;
        }
#line 948
        if (tmp___44 == 0) {
#line 949
          if (configuration->playlist_log) {
#line 949
            if ((unsigned int )configuration->playlist_log != (unsigned int )((void *)0)) {
#line 949
              ((*xmlFree))((void *)configuration->playlist_log);
            }
          }
#line 950
          configuration->playlist_log = (char *)xmlNodeListGetString(doc, node->children,
                                                                     1);
        } else {
#line 951
          if (0) {
#line 951
            __s1_len___1 = strlen((char const   *)node->name);
#line 951
            __s2_len___1 = strlen("logsize");
#line 951
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___4;
            } else {
#line 951
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 951
                if (! ((unsigned int )((void const   *)("logsize" + 1)) - (unsigned int )((void const   *)"logsize") ==
                       1U)) {
#line 951
                  tmp___38 = 1;
                } else {
#line 951
                  if (__s2_len___1 >= 4U) {
#line 951
                    tmp___38 = 1;
                  } else {
#line 951
                    tmp___38 = 0;
                  }
                }
              } else {
#line 951
                tmp___38 = 0;
              }
            }
#line 951
            if (tmp___38) {
#line 951
              tmp___34 = __builtin_strcmp((char const   *)node->name, "logsize");
            } else {
#line 951
              tmp___37 = __builtin_strcmp((char const   *)node->name, "logsize");
#line 951
              tmp___34 = tmp___37;
            }
          } else {
#line 951
            tmp___37 = __builtin_strcmp((char const   *)node->name, "logsize");
#line 951
            tmp___34 = tmp___37;
          }
#line 951
          if (tmp___34 == 0) {
#line 952
            tmp___4 = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 952
            tmp___3 = tmp___4;
#line 953
            configuration->logsize = atoi__extinline((char const   *)tmp___3);
#line 954
            if (tmp___3) {
#line 954
              ((*xmlFree))((void *)tmp___3);
            }
          } else {
#line 955
            if (0) {
#line 955
              __s1_len___0 = strlen((char const   *)node->name);
#line 955
              __s2_len___0 = strlen("loglevel");
#line 955
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___2;
              } else {
#line 955
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 955
                  if (! ((unsigned int )((void const   *)("loglevel" + 1)) - (unsigned int )((void const   *)"loglevel") ==
                         1U)) {
#line 955
                    tmp___28 = 1;
                  } else {
#line 955
                    if (__s2_len___0 >= 4U) {
#line 955
                      tmp___28 = 1;
                    } else {
#line 955
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 955
                  tmp___28 = 0;
                }
              }
#line 955
              if (tmp___28) {
#line 955
                tmp___24 = __builtin_strcmp((char const   *)node->name, "loglevel");
              } else {
#line 955
                tmp___27 = __builtin_strcmp((char const   *)node->name, "loglevel");
#line 955
                tmp___24 = tmp___27;
              }
            } else {
#line 955
              tmp___27 = __builtin_strcmp((char const   *)node->name, "loglevel");
#line 955
              tmp___24 = tmp___27;
            }
#line 955
            if (tmp___24 == 0) {
#line 956
              tmp___6 = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 956
              tmp___5 = tmp___6;
#line 957
              configuration->loglevel = atoi__extinline((char const   *)tmp___5);
#line 958
              if (tmp___5) {
#line 958
                ((*xmlFree))((void *)tmp___5);
              }
            } else {
#line 959
              if (0) {
#line 959
                __s1_len = strlen((char const   *)node->name);
#line 959
                __s2_len = strlen("logarchive");
#line 959
                if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                       1U)) {
                  goto _L___0;
                } else {
#line 959
                  if (__s1_len >= 4U) {
                    _L___0: /* CIL Label */ 
#line 959
                    if (! ((unsigned int )((void const   *)("logarchive" + 1)) - (unsigned int )((void const   *)"logarchive") ==
                           1U)) {
#line 959
                      tmp___18 = 1;
                    } else {
#line 959
                      if (__s2_len >= 4U) {
#line 959
                        tmp___18 = 1;
                      } else {
#line 959
                        tmp___18 = 0;
                      }
                    }
                  } else {
#line 959
                    tmp___18 = 0;
                  }
                }
#line 959
                if (tmp___18) {
#line 959
                  tmp___14 = __builtin_strcmp((char const   *)node->name, "logarchive");
                } else {
#line 959
                  tmp___17 = __builtin_strcmp((char const   *)node->name, "logarchive");
#line 959
                  tmp___14 = tmp___17;
                }
              } else {
#line 959
                tmp___17 = __builtin_strcmp((char const   *)node->name, "logarchive");
#line 959
                tmp___14 = tmp___17;
              }
#line 959
              if (tmp___14 == 0) {
#line 960
                tmp___8 = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 960
                tmp___7 = tmp___8;
#line 961
                configuration->logarchive = atoi__extinline((char const   *)tmp___7);
#line 962
                if (tmp___7) {
#line 962
                  ((*xmlFree))((void *)tmp___7);
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 938
    node = node->next;
#line 938
    if (! node) {
#line 938
      break;
    }
  }
#line 965
  return;
}
}
#line 967 "cfgfile.c"
static void _parse_security(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ char *tmp ;
  xmlNodePtr oldnode ;
  int tmp___0 ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;

  {
#line 973
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 975
    tmp___0 = xmlIsBlankNode(node);
#line 975
    if (tmp___0) {
      goto __Cont;
    }
#line 977
    if (0) {
#line 977
      __s1_len___2 = strlen((char const   *)node->name);
#line 977
      __s2_len___2 = strlen("chroot");
#line 977
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___6;
      } else {
#line 977
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 977
          if (! ((unsigned int )((void const   *)("chroot" + 1)) - (unsigned int )((void const   *)"chroot") ==
                 1U)) {
#line 977
            tmp___44 = 1;
          } else {
#line 977
            if (__s2_len___2 >= 4U) {
#line 977
              tmp___44 = 1;
            } else {
#line 977
              tmp___44 = 0;
            }
          }
        } else {
#line 977
          tmp___44 = 0;
        }
      }
#line 977
      if (tmp___44) {
#line 977
        tmp___40 = __builtin_strcmp((char const   *)node->name, "chroot");
      } else {
#line 977
        tmp___43 = __builtin_strcmp((char const   *)node->name, "chroot");
#line 977
        tmp___40 = tmp___43;
      }
    } else {
#line 977
      tmp___43 = __builtin_strcmp((char const   *)node->name, "chroot");
#line 977
      tmp___40 = tmp___43;
    }
#line 977
    if (tmp___40 == 0) {
#line 978
      tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 979
      configuration->chroot = atoi__extinline((char const   *)tmp);
#line 980
      if (tmp) {
#line 980
        ((*xmlFree))((void *)tmp);
      }
    } else {
#line 981
      if (0) {
#line 981
        __s1_len___1 = strlen((char const   *)node->name);
#line 981
        __s2_len___1 = strlen("changeowner");
#line 981
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___4;
        } else {
#line 981
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 981
            if (! ((unsigned int )((void const   *)("changeowner" + 1)) - (unsigned int )((void const   *)"changeowner") ==
                   1U)) {
#line 981
              tmp___34 = 1;
            } else {
#line 981
              if (__s2_len___1 >= 4U) {
#line 981
                tmp___34 = 1;
              } else {
#line 981
                tmp___34 = 0;
              }
            }
          } else {
#line 981
            tmp___34 = 0;
          }
        }
#line 981
        if (tmp___34) {
#line 981
          tmp___30 = __builtin_strcmp((char const   *)node->name, "changeowner");
        } else {
#line 981
          tmp___33 = __builtin_strcmp((char const   *)node->name, "changeowner");
#line 981
          tmp___30 = tmp___33;
        }
      } else {
#line 981
        tmp___33 = __builtin_strcmp((char const   *)node->name, "changeowner");
#line 981
        tmp___30 = tmp___33;
      }
#line 981
      if (tmp___30 == 0) {
#line 982
        configuration->chuid = 1;
#line 983
        oldnode = node;
#line 984
        node = node->children;
#line 985
        while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 987
          tmp___2 = xmlIsBlankNode(node);
#line 987
          if (tmp___2) {
            goto __Cont___0;
          }
#line 988
          if (0) {
#line 988
            __s1_len___0 = strlen((char const   *)node->name);
#line 988
            __s2_len___0 = strlen("user");
#line 988
            if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                   1U)) {
              goto _L___2;
            } else {
#line 988
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 988
                if (! ((unsigned int )((void const   *)("user" + 1)) - (unsigned int )((void const   *)"user") ==
                       1U)) {
#line 988
                  tmp___24 = 1;
                } else {
#line 988
                  if (__s2_len___0 >= 4U) {
#line 988
                    tmp___24 = 1;
                  } else {
#line 988
                    tmp___24 = 0;
                  }
                }
              } else {
#line 988
                tmp___24 = 0;
              }
            }
#line 988
            if (tmp___24) {
#line 988
              tmp___20 = __builtin_strcmp((char const   *)node->name, "user");
            } else {
#line 988
              tmp___23 = __builtin_strcmp((char const   *)node->name, "user");
#line 988
              tmp___20 = tmp___23;
            }
          } else {
#line 988
            tmp___23 = __builtin_strcmp((char const   *)node->name, "user");
#line 988
            tmp___20 = tmp___23;
          }
#line 988
          if (tmp___20 == 0) {
#line 989
            if (configuration->user) {
#line 989
              ((*xmlFree))((void *)configuration->user);
            }
#line 990
            configuration->user = (char *)xmlNodeListGetString(doc, node->children,
                                                               1);
          } else {
#line 991
            if (0) {
#line 991
              __s1_len = strlen((char const   *)node->name);
#line 991
              __s2_len = strlen("group");
#line 991
              if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
                     1U)) {
                goto _L___0;
              } else {
#line 991
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 991
                  if (! ((unsigned int )((void const   *)("group" + 1)) - (unsigned int )((void const   *)"group") ==
                         1U)) {
#line 991
                    tmp___14 = 1;
                  } else {
#line 991
                    if (__s2_len >= 4U) {
#line 991
                      tmp___14 = 1;
                    } else {
#line 991
                      tmp___14 = 0;
                    }
                  }
                } else {
#line 991
                  tmp___14 = 0;
                }
              }
#line 991
              if (tmp___14) {
#line 991
                tmp___10 = __builtin_strcmp((char const   *)node->name, "group");
              } else {
#line 991
                tmp___13 = __builtin_strcmp((char const   *)node->name, "group");
#line 991
                tmp___10 = tmp___13;
              }
            } else {
#line 991
              tmp___13 = __builtin_strcmp((char const   *)node->name, "group");
#line 991
              tmp___10 = tmp___13;
            }
#line 991
            if (tmp___10 == 0) {
#line 992
              if (configuration->group) {
#line 992
                ((*xmlFree))((void *)configuration->group);
              }
#line 993
              configuration->group = (char *)xmlNodeListGetString(doc, node->children,
                                                                  1);
            }
          }
          __Cont___0: /* CIL Label */ 
#line 985
          node = node->next;
#line 985
          if (! node) {
#line 985
            break;
          }
        }
#line 996
        node = oldnode;
      }
    }
    __Cont: /* CIL Label */ 
#line 973
    node = node->next;
#line 973
    if (! node) {
#line 973
      break;
    }
  }
#line 999
  return;
}
}
#line 1001 "cfgfile.c"
static void _add_server(xmlDocPtr doc , xmlNodePtr node , ice_config_t *configuration ) 
{ ice_config_dir_t *dirnode ;
  ice_config_dir_t *server ;
  int addnode ;
  char *tmp ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 1008
  server = (ice_config_dir_t *)malloc(sizeof(ice_config_dir_t ));
#line 1009
  server->touch_interval = configuration->touch_interval;
#line 1010
  server->host = (char *)((void *)0);
#line 1011
  addnode = 0;
#line 1013
  while (! ((unsigned int )node == (unsigned int )((void *)0))) {
#line 1015
    tmp___1 = xmlIsBlankNode(node);
#line 1015
    if (tmp___1) {
      goto __Cont;
    }
#line 1017
    if (0) {
#line 1017
      __s1_len___0 = strlen((char const   *)node->name);
#line 1017
      __s2_len___0 = strlen("host");
#line 1017
      if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
             1U)) {
        goto _L___2;
      } else {
#line 1017
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1017
          if (! ((unsigned int )((void const   *)("host" + 1)) - (unsigned int )((void const   *)"host") ==
                 1U)) {
#line 1017
            tmp___23 = 1;
          } else {
#line 1017
            if (__s2_len___0 >= 4U) {
#line 1017
              tmp___23 = 1;
            } else {
#line 1017
              tmp___23 = 0;
            }
          }
        } else {
#line 1017
          tmp___23 = 0;
        }
      }
#line 1017
      if (tmp___23) {
#line 1017
        tmp___19 = __builtin_strcmp((char const   *)node->name, "host");
      } else {
#line 1017
        tmp___22 = __builtin_strcmp((char const   *)node->name, "host");
#line 1017
        tmp___19 = tmp___22;
      }
    } else {
#line 1017
      tmp___22 = __builtin_strcmp((char const   *)node->name, "host");
#line 1017
      tmp___19 = tmp___22;
    }
#line 1017
    if (tmp___19 == 0) {
#line 1018
      server->host = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 1020
      addnode = 1;
    } else {
#line 1021
      if (0) {
#line 1021
        __s1_len = strlen((char const   *)node->name);
#line 1021
        __s2_len = strlen("touch-interval");
#line 1021
        if (! ((unsigned int )((void const   *)(node->name + 1)) - (unsigned int )((void const   *)node->name) ==
               1U)) {
          goto _L___0;
        } else {
#line 1021
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1021
            if (! ((unsigned int )((void const   *)("touch-interval" + 1)) - (unsigned int )((void const   *)"touch-interval") ==
                   1U)) {
#line 1021
              tmp___13 = 1;
            } else {
#line 1021
              if (__s2_len >= 4U) {
#line 1021
                tmp___13 = 1;
              } else {
#line 1021
                tmp___13 = 0;
              }
            }
          } else {
#line 1021
            tmp___13 = 0;
          }
        }
#line 1021
        if (tmp___13) {
#line 1021
          tmp___9 = __builtin_strcmp((char const   *)node->name, "touch-interval");
        } else {
#line 1021
          tmp___12 = __builtin_strcmp((char const   *)node->name, "touch-interval");
#line 1021
          tmp___9 = tmp___12;
        }
      } else {
#line 1021
        tmp___12 = __builtin_strcmp((char const   *)node->name, "touch-interval");
#line 1021
        tmp___9 = tmp___12;
      }
#line 1021
      if (tmp___9 == 0) {
#line 1022
        tmp = (char *)xmlNodeListGetString(doc, node->children, 1);
#line 1023
        server->touch_interval = atoi__extinline((char const   *)tmp);
#line 1024
        if (tmp) {
#line 1024
          ((*xmlFree))((void *)tmp);
        }
      }
    }
#line 1026
    server->next = (struct ice_config_dir_tag *)((void *)0);
    __Cont: /* CIL Label */ 
#line 1013
    node = node->next;
#line 1013
    if (! node) {
#line 1013
      break;
    }
  }
#line 1029
  if (addnode) {
#line 1030
    dirnode = configuration->dir_list;
#line 1031
    if ((unsigned int )dirnode == (unsigned int )((void *)0)) {
#line 1032
      configuration->dir_list = server;
    } else {
#line 1034
      while (dirnode->next) {
#line 1034
        dirnode = dirnode->next;
      }
#line 1036
      dirnode->next = server;
    }
#line 1039
    server = (ice_config_dir_t *)((void *)0);
#line 1040
    addnode = 0;
  }
#line 1043
  return;
}
}
#line 1047 "cfgfile.c"
mount_proxy *config_find_mount(ice_config_t *config , char const   *mount ) 
{ mount_proxy *mountinfo ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1049
  mountinfo = config->mounts;
#line 1051
  while (mountinfo) {
#line 1053
    if (0) {
#line 1053
      __s1_len = strlen((char const   *)mountinfo->mountname);
#line 1053
      __s2_len = strlen(mount);
#line 1053
      if (! ((unsigned int )((void const   *)(mountinfo->mountname + 1)) - (unsigned int )((void const   *)mountinfo->mountname) ==
             1U)) {
        goto _L___0;
      } else {
#line 1053
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1053
          if (! ((unsigned int )((void const   *)(mount + 1)) - (unsigned int )((void const   *)mount) ==
                 1U)) {
#line 1053
            tmp___8 = 1;
          } else {
#line 1053
            if (__s2_len >= 4U) {
#line 1053
              tmp___8 = 1;
            } else {
#line 1053
              tmp___8 = 0;
            }
          }
        } else {
#line 1053
          tmp___8 = 0;
        }
      }
#line 1053
      if (tmp___8) {
#line 1053
        tmp___4 = __builtin_strcmp((char const   *)mountinfo->mountname, mount);
      } else {
#line 1053
        tmp___7 = __builtin_strcmp((char const   *)mountinfo->mountname, mount);
#line 1053
        tmp___4 = tmp___7;
      }
    } else {
#line 1053
      tmp___7 = __builtin_strcmp((char const   *)mountinfo->mountname, mount);
#line 1053
      tmp___4 = tmp___7;
    }
#line 1053
    if (tmp___4 == 0) {
#line 1054
      break;
    }
#line 1055
    mountinfo = mountinfo->next;
  }
#line 1057
  return (mountinfo);
}
}
#line 1 "cil-oS1hkwS1.o"
#pragma merger(0,"/tmp/cil-uCZMIw4J.i","")
#line 1 "./src/logging.o_saved.c"
#pragma merger(0,"./logging.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 244 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 95 "logging.h"
void logging_access(client_t *client ) ;
#line 96
void logging_playlist(char const   *mount , char const   *metadata , long listeners ) ;
#line 97
void restart_logging(ice_config_t *config ) ;
#line 98
void log_parse_failure(void *ctx , char const   *fmt  , ...) ;
#line 39 "logging.c"
int errorlog  =    0;
#line 40 "logging.c"
int accesslog  =    0;
#line 41 "logging.c"
int playlistlog  =    0;
#line 111 "logging.c"
void logging_access(client_t *client ) 
{ char datebuf[128] ;
  char reqbuf[1024] ;
  struct tm thetime ;
  time_t now___0 ;
  time_t stayed ;
  char *referrer ;
  char *user_agent ;
  char *username ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 120
  now___0 = time((time_t *)((void *)0));
#line 122
  localtime_r((time_t const   * __restrict  )(& now___0), (struct tm * __restrict  )(& thetime));
#line 128
  strftime((char * __restrict  )(datebuf), sizeof(datebuf), (char const   * __restrict  )"%d/%b/%Y:%H:%M:%S %z",
           (struct tm  const  * __restrict  )(& thetime));
#line 131
  tmp = httpp_getvar(client->parser, "__version");
#line 131
  tmp___0 = httpp_getvar(client->parser, "__protocol");
#line 131
  tmp___1 = httpp_getvar(client->parser, "__uri");
#line 131
  tmp___2 = httpp_getvar(client->parser, "__req_type");
#line 131
  snprintf((char * __restrict  )(reqbuf), sizeof(reqbuf), (char const   * __restrict  )"%s %s %s/%s",
           tmp___2, tmp___1, tmp___0, tmp);
#line 137
  stayed = now___0 - (client->con)->con_time;
#line 139
  if ((unsigned int )client->username == (unsigned int )((void *)0)) {
#line 140
    username = (char *)"-";
  } else {
#line 142
    username = client->username;
  }
#line 144
  referrer = httpp_getvar(client->parser, "referer");
#line 145
  if ((unsigned int )referrer == (unsigned int )((void *)0)) {
#line 146
    referrer = (char *)"-";
  }
#line 148
  user_agent = httpp_getvar(client->parser, "user-agent");
#line 149
  if ((unsigned int )user_agent == (unsigned int )((void *)0)) {
#line 150
    user_agent = (char *)"-";
  }
#line 152
  log_write_direct(accesslog, "%s - %s [%s] \"%s\" %d %llu \"%s\" \"%s\" %lu", (client->con)->ip,
                   username, datebuf, reqbuf, client->respcode, (client->con)->sent_bytes,
                   referrer, user_agent, (unsigned long )stayed);
#line 163
  return;
}
}
#line 167 "logging.c"
void logging_playlist(char const   *mount , char const   *metadata , long listeners ) 
{ char datebuf[128] ;
  struct tm thetime ;
  time_t now___0 ;

  {
#line 173
  if (playlistlog == -1) {
#line 174
    return;
  }
#line 177
  now___0 = time((time_t *)((void *)0));
#line 179
  localtime_r((time_t const   * __restrict  )(& now___0), (struct tm * __restrict  )(& thetime));
#line 185
  strftime((char * __restrict  )(datebuf), sizeof(datebuf), (char const   * __restrict  )"%d/%b/%Y:%H:%M:%S %z",
           (struct tm  const  * __restrict  )(& thetime));
#line 189
  log_write_direct(playlistlog, "%s|%s|%d|%s", datebuf, mount, listeners, metadata);
#line 194
  return;
}
}
#line 197 "logging.c"
void log_parse_failure(void *ctx , char const   *fmt  , ...) 
{ char line[200] ;
  va_list ap ;
  char *eol ;

  {
#line 203
  __builtin_va_start(ap, fmt);
#line 204
  vsnprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )fmt,
            ap);
#line 205
  eol = strrchr((char const   *)(line), '\n');
#line 206
  if (eol) {
#line 206
    (*eol) = (char )'\000';
  }
#line 207
  __builtin_va_end(ap);
#line 208
  log_write(errorlog, 2U, (char const   *)((char *)ctx), "", "%s", line);
#line 209
  return;
}
}
#line 212 "logging.c"
void restart_logging(ice_config_t *config ) 
{ char fn_error[4096] ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char fn_error___0[4096] ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  char fn_error___1[4096] ;

  {
#line 214
  if (0) {
#line 214
    __s1_len = strlen((char const   *)config->error_log);
#line 214
    __s2_len = strlen("-");
#line 214
    if (! ((unsigned int )((void const   *)(config->error_log + 1)) - (unsigned int )((void const   *)config->error_log) ==
           1U)) {
      goto _L___0;
    } else {
#line 214
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 214
        if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
               1U)) {
#line 214
          tmp___8 = 1;
        } else {
#line 214
          if (__s2_len >= 4U) {
#line 214
            tmp___8 = 1;
          } else {
#line 214
            tmp___8 = 0;
          }
        }
      } else {
#line 214
        tmp___8 = 0;
      }
    }
#line 214
    if (tmp___8) {
#line 214
      tmp___4 = __builtin_strcmp((char const   *)config->error_log, "-");
    } else {
#line 214
      tmp___7 = __builtin_strcmp((char const   *)config->error_log, "-");
#line 214
      tmp___4 = tmp___7;
    }
  } else {
#line 214
    tmp___7 = __builtin_strcmp((char const   *)config->error_log, "-");
#line 214
    tmp___4 = tmp___7;
  }
#line 214
  if (tmp___4) {
#line 217
    snprintf((char * __restrict  )(fn_error), 4096U, (char const   * __restrict  )"%s%s%s",
             config->log_dir, "/", config->error_log);
#line 218
    log_set_filename(errorlog, (char const   *)(fn_error));
#line 219
    log_set_level(errorlog, (unsigned int )config->loglevel);
#line 220
    log_set_trigger(errorlog, (unsigned int )config->logsize);
#line 221
    log_set_archive_timestamp(errorlog, config->logarchive);
#line 222
    log_reopen(errorlog);
  }
#line 225
  if (0) {
#line 225
    __s1_len___0 = strlen((char const   *)config->access_log);
#line 225
    __s2_len___0 = strlen("-");
#line 225
    if (! ((unsigned int )((void const   *)(config->access_log + 1)) - (unsigned int )((void const   *)config->access_log) ==
           1U)) {
      goto _L___2;
    } else {
#line 225
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 225
        if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
               1U)) {
#line 225
          tmp___18 = 1;
        } else {
#line 225
          if (__s2_len___0 >= 4U) {
#line 225
            tmp___18 = 1;
          } else {
#line 225
            tmp___18 = 0;
          }
        }
      } else {
#line 225
        tmp___18 = 0;
      }
    }
#line 225
    if (tmp___18) {
#line 225
      tmp___14 = __builtin_strcmp((char const   *)config->access_log, "-");
    } else {
#line 225
      tmp___17 = __builtin_strcmp((char const   *)config->access_log, "-");
#line 225
      tmp___14 = tmp___17;
    }
  } else {
#line 225
    tmp___17 = __builtin_strcmp((char const   *)config->access_log, "-");
#line 225
    tmp___14 = tmp___17;
  }
#line 225
  if (tmp___14) {
#line 228
    snprintf((char * __restrict  )(fn_error___0), 4096U, (char const   * __restrict  )"%s%s%s",
             config->log_dir, "/", config->access_log);
#line 229
    log_set_filename(accesslog, (char const   *)(fn_error___0));
#line 230
    log_set_trigger(errorlog, (unsigned int )config->logsize);
#line 231
    log_set_archive_timestamp(errorlog, config->logarchive);
#line 232
    log_reopen(accesslog);
  }
#line 235
  if (config->playlist_log) {
#line 238
    snprintf((char * __restrict  )(fn_error___1), 4096U, (char const   * __restrict  )"%s%s%s",
             config->log_dir, "/", config->playlist_log);
#line 239
    log_set_filename(playlistlog, (char const   *)(fn_error___1));
#line 240
    log_set_trigger(errorlog, (unsigned int )config->logsize);
#line 241
    log_set_archive_timestamp(errorlog, config->logarchive);
#line 242
    log_reopen(playlistlog);
  }
#line 244
  return;
}
}
#line 1 "cil-x95wcJ8v.o"
#pragma merger(0,"/tmp/cil-maCH0OKe.i","")
#line 1 "./src/sighandler.o_saved.c"
#pragma merger(0,"./sighandler.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 33 "sighandler.c"
void _sig_hup(int signo ) ;
#line 34
void _sig_die(int signo ) ;
#line 35
void _sig_ignore(int signo ) ;
#line 38 "sighandler.c"
void sighandler_initialize(void) 
{ 

  {
#line 41
  signal(1, & _sig_hup);
#line 42
  signal(2, & _sig_die);
#line 43
  signal(15, & _sig_die);
#line 44
  signal(13, (void (*)(int  ))1);
#line 45
  signal(17, & _sig_ignore);
#line 47
  return;
}
}
#line 50 "sighandler.c"
void _sig_ignore(int signo ) 
{ 

  {
#line 52
  signal(signo, & _sig_ignore);
#line 53
  return;
}
}
#line 55 "sighandler.c"
void _sig_hup(int signo ) 
{ 

  {
#line 57
  global.schedule_config_reread = 1;
#line 59
  signal(1, & _sig_hup);
#line 60
  return;
}
}
#line 62 "sighandler.c"
void _sig_die(int signo ) 
{ 

  {
#line 64
  log_write(errorlog, 3U, "sighandler/", "_sig_die", "Caught signal %d, shutting down...",
            signo);
#line 67
  global.running = 2;
#line 68
  return;
}
}
#line 1 "cil-NEU5f2k9.o"
#pragma merger(0,"/tmp/cil-LqSQcdVU.i","")
#line 1 "./src/connection.o_saved.c"
#pragma merger(0,"./connection.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 50 "connection.h"
int connection_check_source_pass(http_parser_t *parser , char const   *mount ) ;
#line 51
int connection_check_relay_pass(http_parser_t *parser ) ;
#line 52
int connection_check_admin_pass(http_parser_t *parser ) ;
#line 54 "connection.h"
rwlock_t _source_shutdown_rwlock  ;
#line 35 "refbuf.h"
refbuf_t *refbuf_new(unsigned long size ) ;
#line 71 "client.h"
void client_destroy(client_t *client ) ;
#line 74
void client_send_401(client_t *client ) ;
#line 75
void client_send_403(client_t *client , char const   *reason ) ;
#line 76
void client_send_400(client_t *client , char *message ) ;
#line 78
int client_read_bytes(client_t *client , void *buf , unsigned int len ) ;
#line 77 "auth.h"
void add_client(char const   *mount , client_t *client ) ;
#line 79 "stats.h"
void stats_event_args(char const   *source , char *name , char *format  , ...) ;
#line 87
void stats_callback(client_t *client , void *notused ) ;
#line 89
void stats_transform_xslt(client_t *client , char const   *uri ) ;
#line 35 "fserve.h"
void fserve_add_client_callback(client_t *client , void (*callback)(client_t * , void * ) ,
                                void *arg ) ;
#line 58 "format.h"
format_type_t format_get_type(char *contenttype ) ;
#line 60
int format_get_plugin(format_type_t type , struct source_tag *source ) ;
#line 82 "source.h"
void source_client_callback(client_t *client , void *arg ) ;
#line 95
mutex_t move_clients_mutex ;
#line 19 "admin.h"
void admin_handle_request(client_t *client , char *uri ) ;
#line 96 "connection.c"
static mutex_t _connection_mutex  ;
#line 97 "connection.c"
static unsigned long volatile   _current_id  =    (unsigned long volatile   )0;
#line 98 "connection.c"
static int _initialized___2  =    0;
#line 99 "connection.c"
static thread_type *tid  ;
#line 101 "connection.c"
static client_queue_t volatile   *_req_queue  =    (client_queue_t volatile   *)((void *)0);
#line 101 "connection.c"
static client_queue_t volatile   **_req_queue_tail  =    & _req_queue;
#line 102 "connection.c"
static client_queue_t volatile   *_con_queue  =    (client_queue_t volatile   *)((void *)0);
#line 102 "connection.c"
static client_queue_t volatile   **_con_queue_tail  =    & _con_queue;
#line 103 "connection.c"
static mutex_t _con_queue_mutex  ;
#line 104 "connection.c"
static mutex_t _req_queue_mutex  ;
#line 108
static void *_handle_connection(void *arg ) ;
#line 110 "connection.c"
void connection_initialize(void) 
{ 

  {
#line 112
  if (_initialized___2) {
#line 112
    return;
  }
#line 114
  thread_mutex_create_c(& _connection_mutex, 114, (char *)"connection.c");
#line 115
  thread_mutex_create_c(& _con_queue_mutex, 115, (char *)"connection.c");
#line 116
  thread_mutex_create_c(& _req_queue_mutex, 116, (char *)"connection.c");
#line 117
  thread_mutex_create_c(& move_clients_mutex, 117, (char *)"connection.c");
#line 118
  thread_rwlock_create_c(& _source_shutdown_rwlock, 118, (char *)"connection.c");
#line 119
  thread_cond_create_c(& global.shutdown_cond, 119, (char *)"connection.c");
#line 121
  _initialized___2 = 1;
#line 122
  return;
}
}
#line 124 "connection.c"
void connection_shutdown(void) 
{ 

  {
#line 126
  if (! _initialized___2) {
#line 126
    return;
  }
#line 128
  thread_cond_destroy(& global.shutdown_cond);
#line 129
  thread_rwlock_destroy(& _source_shutdown_rwlock);
#line 130
  thread_mutex_destroy(& _con_queue_mutex);
#line 131
  thread_mutex_destroy(& _req_queue_mutex);
#line 132
  thread_mutex_destroy(& _connection_mutex);
#line 133
  thread_mutex_destroy(& move_clients_mutex);
#line 135
  _initialized___2 = 0;
#line 136
  return;
}
}
#line 138 "connection.c"
static unsigned long _next_connection_id(void) 
{ unsigned long id ;
  unsigned long volatile   tmp ;

  {
#line 142
  thread_mutex_lock_c(& _connection_mutex, 142, (char *)"connection.c");
#line 143
  tmp = _current_id;
#line 143
  _current_id ++;
#line 143
  id = (unsigned long )tmp;
#line 144
  thread_mutex_unlock_c(& _connection_mutex, 144, (char *)"connection.c");
#line 146
  return (id);
}
}
#line 149 "connection.c"
connection_t *connection_create(sock_t sock , sock_t serversock , char *ip ) 
{ connection_t *con ;

  {
#line 152
  con = (connection_t *)calloc(1U, sizeof(connection_t ));
#line 153
  if (con) {
#line 155
    con->sock = sock;
#line 156
    con->serversock = serversock;
#line 157
    con->con_time = time((time_t *)((void *)0));
#line 158
    con->id = _next_connection_id();
#line 159
    con->ip = ip;
  }
#line 162
  return (con);
}
}
#line 165 "connection.c"
static int wait_for_serversock(int timeout ) 
{ struct pollfd ufds___0[20] ;
  int i ;
  int ret ;
  int dst ;

  {
#line 171
  i = 0;
#line 171
  while (i < global.server_sockets) {
#line 172
    ufds___0[i].fd = global.serversock[i];
#line 173
    ufds___0[i].events = (short)1;
#line 174
    ufds___0[i].revents = (short)0;
#line 171
    i ++;
  }
#line 177
  ret = poll(ufds___0, (unsigned long )global.server_sockets, timeout);
#line 178
  if (ret < 0) {
#line 179
    return (-2);
  } else {
#line 181
    if (ret == 0) {
#line 182
      return (-1);
    } else {
#line 186
      i = 0;
#line 186
      while (i < global.server_sockets) {
#line 187
        if ((int )ufds___0[i].revents & 1) {
#line 188
          return (ufds___0[i].fd);
        }
#line 189
        if ((int )ufds___0[i].revents & 56) {
#line 191
          if ((int )ufds___0[i].revents & 24) {
#line 193
            close(global.serversock[i]);
#line 194
            log_write(errorlog, 2U, "connection/", "wait_for_serversock", "Had to close a listening socket");
          }
#line 196
          global.serversock[i] = -1;
        }
#line 186
        i ++;
      }
#line 200
      i = 0;
#line 200
      dst = 0;
#line 200
      while (i < global.server_sockets) {
#line 202
        if (global.serversock[i] == -1) {
          goto __Cont;
        }
#line 204
        if (i != dst) {
#line 205
          global.serversock[dst] = global.serversock[i];
        }
#line 206
        dst ++;
        __Cont: /* CIL Label */ 
#line 200
        i ++;
      }
#line 208
      global.server_sockets = dst;
#line 209
      return (-1);
    }
  }
}
}
#line 248 "connection.c"
static connection_t *_accept_connection(void) 
{ int sock ;
  connection_t *con ;
  char *ip ;
  int serversock ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 255
  serversock = wait_for_serversock(100);
#line 256
  if (serversock < 0) {
#line 257
    return ((connection_t *)((void *)0));
  }
#line 260
  ip = (char *)malloc(46U);
#line 262
  sock = sock_accept(serversock, ip, 46);
#line 263
  if (sock >= 0) {
#line 265
    con = connection_create(sock, serversock, ip);
#line 266
    if ((unsigned int )con == (unsigned int )((void *)0)) {
#line 267
      free((void *)ip);
    }
#line 269
    return (con);
  }
#line 272
  tmp___3 = sock_error();
#line 272
  tmp___4 = sock_recoverable(tmp___3);
#line 272
  if (! tmp___4) {
#line 273
    tmp___0 = sock_error();
#line 273
    tmp___1 = strerror(tmp___0);
#line 273
    tmp___2 = sock_error();
#line 273
    log_write(errorlog, 2U, "connection/", "_accept_connection", "accept() failed with error %d: %s",
              tmp___2, tmp___1);
  }
#line 275
  free((void *)ip);
#line 277
  return ((connection_t *)((void *)0));
}
}
#line 285 "connection.c"
static void _add_connection(client_queue_t *node ) 
{ 

  {
#line 287
  thread_mutex_lock_c(& _con_queue_mutex, 287, (char *)"connection.c");
#line 288
  (*_con_queue_tail) = (client_queue_t volatile   *)node;
#line 289
  _con_queue_tail = (client_queue_t volatile   **)(& node->next);
#line 290
  thread_mutex_unlock_c(& _con_queue_mutex, 290, (char *)"connection.c");
#line 291
  return;
}
}
#line 297 "connection.c"
static client_queue_t *_get_connection(void) 
{ client_queue_t *node ;

  {
#line 299
  node = (client_queue_t *)((void *)0);
#line 302
  if (_con_queue) {
#line 304
    thread_mutex_lock_c(& _con_queue_mutex, 304, (char *)"connection.c");
#line 305
    node = (client_queue_t *)_con_queue;
#line 306
    _con_queue = (client_queue_t volatile   *)node->next;
#line 307
    if ((unsigned int )_con_queue == (unsigned int )((void *)0)) {
#line 308
      _con_queue_tail = & _con_queue;
    }
#line 309
    thread_mutex_unlock_c(& _con_queue_mutex, 309, (char *)"connection.c");
  }
#line 311
  return (node);
}
}
#line 316 "connection.c"
static void process_request_queue(void) 
{ client_queue_t **node_ref ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  int timeout ;
  client_queue_t *node ;
  client_t *client ;
  int len ;
  char *buf ;
  time_t tmp___0 ;
  int pass_it ;
  char *ptr ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 318
  node_ref = (client_queue_t **)(& _req_queue);
#line 319
  tmp = config_get_config();
#line 319
  config = tmp;
#line 320
  timeout = config->header_timeout;
#line 321
  config_release_config();
#line 323
  while ((*node_ref)) {
#line 325
    node = (*node_ref);
#line 326
    client = node->client;
#line 327
    len = 4095 - node->offset;
#line 328
    buf = (client->refbuf)->data + node->offset;
#line 330
    if (len > 0) {
#line 332
      tmp___0 = time((time_t *)((void *)0));
#line 332
      if ((client->con)->con_time + (time_t )timeout <= tmp___0) {
#line 333
        len = 0;
      } else {
#line 335
        len = client_read_bytes(client, (void *)buf, (unsigned int )len);
      }
    }
#line 338
    if (len > 0) {
#line 340
      pass_it = 1;
#line 345
      node->offset += len;
#line 346
      (*((client->refbuf)->data + node->offset)) = (char )'\000';
#line 347
      while (1) {
#line 349
        if (node->shoutcast == 1) {
#line 352
          tmp___1 = strstr((char const   *)(client->refbuf)->data, "\r\r\n");
#line 352
          if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
#line 353
            break;
          }
#line 354
          tmp___2 = strstr((char const   *)(client->refbuf)->data, "\r\n");
#line 354
          if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 355
            break;
          }
#line 356
          tmp___3 = strstr((char const   *)(client->refbuf)->data, "\n");
#line 356
          if ((unsigned int )tmp___3 != (unsigned int )((void *)0)) {
#line 357
            break;
          }
        }
#line 361
        ptr = strstr((char const   *)(client->refbuf)->data, "\r\r\n\r\r\n");
#line 362
        if (ptr) {
#line 364
          node->stream_offset = (ptr + 6) - (client->refbuf)->data;
#line 365
          break;
        }
#line 367
        ptr = strstr((char const   *)(client->refbuf)->data, "\r\n\r\n");
#line 368
        if (ptr) {
#line 370
          node->stream_offset = (ptr + 4) - (client->refbuf)->data;
#line 371
          break;
        }
#line 373
        ptr = strstr((char const   *)(client->refbuf)->data, "\n\n");
#line 374
        if (ptr) {
#line 376
          node->stream_offset = (ptr + 2) - (client->refbuf)->data;
#line 377
          break;
        }
#line 379
        pass_it = 0;
#line 347
        break;
      }
#line 382
      if (pass_it) {
#line 384
        if ((unsigned int )((client_queue_t **)_req_queue_tail) == (unsigned int )(& node->next)) {
#line 385
          _req_queue_tail = (client_queue_t volatile   **)node_ref;
        }
#line 386
        (*node_ref) = node->next;
#line 387
        node->next = (struct client_queue_tag *)((void *)0);
#line 388
        _add_connection(node);
      }
    } else {
#line 393
      if (len == 0) {
        goto _L;
      } else {
#line 393
        if ((client->con)->error) {
          _L: /* CIL Label */ 
#line 395
          if ((unsigned int )((client_queue_t **)_req_queue_tail) == (unsigned int )(& node->next)) {
#line 396
            _req_queue_tail = (client_queue_t volatile   **)node_ref;
          }
#line 397
          (*node_ref) = node->next;
#line 398
          client_destroy(client);
#line 399
          free((void *)node);
#line 400
          continue;
        }
      }
    }
#line 403
    node_ref = & node->next;
  }
#line 405
  return;
}
}
#line 411 "connection.c"
static void _add_request_queue(client_queue_t *node ) 
{ 

  {
#line 413
  thread_mutex_lock_c(& _req_queue_mutex, 413, (char *)"connection.c");
#line 414
  (*_req_queue_tail) = (client_queue_t volatile   *)node;
#line 415
  _req_queue_tail = (client_queue_t volatile   **)(& node->next);
#line 416
  thread_mutex_unlock_c(& _req_queue_mutex, 416, (char *)"connection.c");
#line 417
  return;
}
}
#line 420 "connection.c"
void connection_accept_loop(void) 
{ connection_t *con ;
  client_queue_t *node ;
  ice_config_t *config ;
  int i ;
  client_t *client ;
  int tmp ;

  {
#line 424
  tid = thread_create_c((char *)"connection thread", & _handle_connection, (void *)0,
                        0, 424, (char *)"connection.c");
#line 426
  while (global.running == 1) {
#line 428
    con = _accept_connection();
#line 430
    if (con) {
#line 435
      client = (client_t *)((void *)0);
#line 437
      global_lock();
#line 438
      tmp = client_create(& client, con, (http_parser_t *)((void *)0));
#line 438
      if (tmp < 0) {
#line 440
        global_unlock();
#line 441
        client_send_403(client, "Icecast connection limit reached");
#line 442
        continue;
      }
#line 444
      global_unlock();
#line 447
      (*((client->refbuf)->data + 4095)) = (char )'\000';
#line 449
      node = (client_queue_t *)calloc(1U, sizeof(client_queue_t ));
#line 450
      if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 452
        client_destroy(client);
#line 453
        continue;
      }
#line 455
      node->client = client;
#line 458
      config = config_get_config();
#line 459
      i = 0;
#line 459
      while (i < global.server_sockets) {
#line 461
        if (global.serversock[i] == con->serversock) {
#line 463
          if (config->listeners[i].shoutcast_compat) {
#line 464
            node->shoutcast = 1;
          }
        }
#line 459
        i ++;
      }
#line 467
      config_release_config();
#line 469
      sock_set_blocking((client->con)->sock, 1);
#line 470
      sock_set_nodelay((client->con)->sock);
#line 472
      _add_request_queue(node);
#line 473
      stats_event_inc((char const   *)((void *)0), "connections");
    }
#line 475
    process_request_queue();
  }
#line 479
  thread_cond_broadcast_c(& global.shutdown_cond, 479, (char *)"connection.c");
#line 481
  if (tid) {
#line 482
    thread_join(tid);
  }
#line 485
  thread_rwlock_wlock_c(& _source_shutdown_rwlock, 485, (char *)"connection.c");
#line 486
  thread_rwlock_unlock_c(& _source_shutdown_rwlock, 486, (char *)"connection.c");
#line 487
  return;
}
}
#line 493 "connection.c"
int connection_complete_source(struct source_tag *source , int response ) 
{ ice_config_t *config ;
  ice_config_t *tmp ;
  char *contenttype ;
  mount_proxy *mountinfo ;
  format_type_t format_type ;
  int tmp___0 ;

  {
#line 495
  tmp = config_get_config();
#line 495
  config = tmp;
#line 497
  global_lock();
#line 498
  log_write(errorlog, 4U, "connection/", "connection_complete_source", "sources count is %d",
            global.sources);
#line 500
  if (global.sources < config->source_limit) {
#line 507
    contenttype = httpp_getvar(source->parser, "content-type");
#line 508
    if ((unsigned int )contenttype != (unsigned int )((void *)0)) {
#line 510
      format_type = format_get_type(contenttype);
#line 512
      if ((int )format_type == 0) {
#line 514
        global_unlock();
#line 515
        config_release_config();
#line 516
        if (response) {
#line 518
          client_send_403(source->client, "Content-type not supported");
#line 519
          source->client = (client_t *)((void *)0);
        }
#line 521
        log_write(errorlog, 2U, "connection/", "connection_complete_source", "Content-type \"%s\" not supported, dropping source",
                  contenttype);
#line 522
        return (-1);
      }
    } else {
#line 527
      log_write(errorlog, 2U, "connection/", "connection_complete_source", "No content-type header, falling back to backwards compatibility mode for icecast 1.x relays. Assuming content is mp3.");
#line 529
      format_type = 2;
    }
#line 532
    tmp___0 = format_get_plugin(format_type, source);
#line 532
    if (tmp___0 < 0) {
#line 534
      global_unlock();
#line 535
      config_release_config();
#line 536
      if (response) {
#line 538
        client_send_403(source->client, "internal format allocation problem");
#line 539
        source->client = (client_t *)((void *)0);
      }
#line 541
      log_write(errorlog, 2U, "connection/", "connection_complete_source", "plugin format failed for \"%s\"",
                source->mount);
#line 542
      return (-1);
    }
#line 545
    global.sources = global.sources + 1;
#line 546
    stats_event_args((char const   *)((void *)0), (char *)"sources", (char *)"%d",
                     global.sources);
#line 547
    global_unlock();
#line 549
    source->running = 1;
#line 550
    mountinfo = config_find_mount(config, (char const   *)source->mount);
#line 551
    if ((unsigned int )mountinfo == (unsigned int )((void *)0)) {
#line 552
      source_update_settings(config, source, mountinfo);
    }
#line 553
    source_recheck_mounts();
#line 554
    config_release_config();
#line 556
    source->shutdown_rwlock = & _source_shutdown_rwlock;
#line 557
    log_write(errorlog, 4U, "connection/", "connection_complete_source", "source is ready to start");
#line 559
    return (0);
  }
#line 561
  log_write(errorlog, 2U, "connection/", "connection_complete_source", "Request to add source when maximum source limit reached %d",
            global.sources);
#line 564
  global_unlock();
#line 565
  config_release_config();
#line 567
  if (response) {
#line 569
    client_send_403(source->client, "too many sources connected");
#line 570
    source->client = (client_t *)((void *)0);
  }
#line 573
  return (-1);
}
}
#line 577 "connection.c"
static int _check_pass_http(http_parser_t *parser , char *correctuser , char *correctpass ) 
{ char *header ;
  char *tmp ;
  char *userpass ;
  char *tmp___0 ;
  char *username ;
  char *password ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 581
  tmp = httpp_getvar(parser, "authorization");
#line 581
  header = tmp;
#line 585
  if ((unsigned int )header == (unsigned int )((void *)0)) {
#line 586
    return (0);
  }
#line 588
  if (0) {
#line 588
    if (0) {
#line 588
      __s1_len___0 = strlen((char const   *)header);
#line 588
      __s2_len___0 = strlen("Basic ");
#line 588
      if (! ((unsigned int )((void const   *)(header + 1)) - (unsigned int )((void const   *)header) ==
             1U)) {
        goto _L___2;
      } else {
#line 588
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 588
          if (! ((unsigned int )((void const   *)("Basic " + 1)) - (unsigned int )((void const   *)"Basic ") ==
                 1U)) {
#line 588
            tmp___24 = 1;
          } else {
#line 588
            if (__s2_len___0 >= 4U) {
#line 588
              tmp___24 = 1;
            } else {
#line 588
              tmp___24 = 0;
            }
          }
        } else {
#line 588
          tmp___24 = 0;
        }
      }
#line 588
      if (tmp___24) {
#line 588
        tmp___20 = __builtin_strcmp((char const   *)header, "Basic ");
      } else {
#line 588
        tmp___23 = __builtin_strcmp((char const   *)header, "Basic ");
#line 588
        tmp___20 = tmp___23;
      }
    } else {
#line 588
      tmp___23 = __builtin_strcmp((char const   *)header, "Basic ");
#line 588
      tmp___20 = tmp___23;
    }
#line 588
    tmp___14 = tmp___20;
  } else {
#line 588
    tmp___14 = strncmp((char const   *)header, "Basic ", 6U);
  }
#line 588
  if (tmp___14) {
#line 589
    return (0);
  }
#line 591
  userpass = util_base64_decode((unsigned char *)(header + 6));
#line 592
  if ((unsigned int )userpass == (unsigned int )((void *)0)) {
#line 593
    log_write(errorlog, 2U, "connection/", "_check_pass_http", "Base64 decode of Authorization header \"%s\" failed",
              header + 6);
#line 595
    return (0);
  }
#line 598
  tmp___28 = __builtin_strchr(userpass, (char )':');
#line 598
  tmp___0 = tmp___28;
#line 599
  if (! tmp___0) {
#line 600
    free((void *)userpass);
#line 601
    return (0);
  }
#line 603
  (*tmp___0) = (char)0;
#line 604
  username = userpass;
#line 605
  password = tmp___0 + 1;
#line 607
  if (0) {
#line 607
    __s1_len___1 = strlen((char const   *)username);
#line 607
    __s2_len___1 = strlen((char const   *)correctuser);
#line 607
    if (! ((unsigned int )((void const   *)(username + 1)) - (unsigned int )((void const   *)username) ==
           1U)) {
      goto _L___4;
    } else {
#line 607
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 607
        if (! ((unsigned int )((void const   *)(correctuser + 1)) - (unsigned int )((void const   *)correctuser) ==
               1U)) {
#line 607
          tmp___38 = 1;
        } else {
#line 607
          if (__s2_len___1 >= 4U) {
#line 607
            tmp___38 = 1;
          } else {
#line 607
            tmp___38 = 0;
          }
        }
      } else {
#line 607
        tmp___38 = 0;
      }
    }
#line 607
    if (tmp___38) {
#line 607
      tmp___34 = __builtin_strcmp((char const   *)username, (char const   *)correctuser);
    } else {
#line 607
      tmp___37 = __builtin_strcmp((char const   *)username, (char const   *)correctuser);
#line 607
      tmp___34 = tmp___37;
    }
  } else {
#line 607
    tmp___37 = __builtin_strcmp((char const   *)username, (char const   *)correctuser);
#line 607
    tmp___34 = tmp___37;
  }
#line 607
  if (tmp___34) {
#line 608
    free((void *)userpass);
#line 609
    return (0);
  } else {
#line 607
    if (0) {
#line 607
      __s1_len___2 = strlen((char const   *)password);
#line 607
      __s2_len___2 = strlen((char const   *)correctpass);
#line 607
      if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) ==
             1U)) {
        goto _L___6;
      } else {
#line 607
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 607
          if (! ((unsigned int )((void const   *)(correctpass + 1)) - (unsigned int )((void const   *)correctpass) ==
                 1U)) {
#line 607
            tmp___48 = 1;
          } else {
#line 607
            if (__s2_len___2 >= 4U) {
#line 607
              tmp___48 = 1;
            } else {
#line 607
              tmp___48 = 0;
            }
          }
        } else {
#line 607
          tmp___48 = 0;
        }
      }
#line 607
      if (tmp___48) {
#line 607
        tmp___44 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
      } else {
#line 607
        tmp___47 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
#line 607
        tmp___44 = tmp___47;
      }
    } else {
#line 607
      tmp___47 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
#line 607
      tmp___44 = tmp___47;
    }
#line 607
    if (tmp___44) {
#line 608
      free((void *)userpass);
#line 609
      return (0);
    }
  }
#line 611
  free((void *)userpass);
#line 613
  return (1);
}
}
#line 616 "connection.c"
static int _check_pass_icy(http_parser_t *parser , char *correctpass ) 
{ char *password ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 620
  password = httpp_getvar(parser, "__icy_password");
#line 621
  if (! password) {
#line 622
    return (0);
  }
#line 624
  if (0) {
#line 624
    __s1_len = strlen((char const   *)password);
#line 624
    __s2_len = strlen((char const   *)correctpass);
#line 624
    if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) ==
           1U)) {
      goto _L___0;
    } else {
#line 624
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 624
        if (! ((unsigned int )((void const   *)(correctpass + 1)) - (unsigned int )((void const   *)correctpass) ==
               1U)) {
#line 624
          tmp___8 = 1;
        } else {
#line 624
          if (__s2_len >= 4U) {
#line 624
            tmp___8 = 1;
          } else {
#line 624
            tmp___8 = 0;
          }
        }
      } else {
#line 624
        tmp___8 = 0;
      }
    }
#line 624
    if (tmp___8) {
#line 624
      tmp___4 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
    } else {
#line 624
      tmp___7 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
#line 624
      tmp___4 = tmp___7;
    }
  } else {
#line 624
    tmp___7 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
#line 624
    tmp___4 = tmp___7;
  }
#line 624
  if (tmp___4) {
#line 625
    return (0);
  } else {
#line 627
    return (1);
  }
}
}
#line 630 "connection.c"
static int _check_pass_ice(http_parser_t *parser , char *correctpass ) 
{ char *password ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 634
  password = httpp_getvar(parser, "ice-password");
#line 635
  if (! password) {
#line 636
    password = (char *)"";
  }
#line 638
  if (0) {
#line 638
    __s1_len = strlen((char const   *)password);
#line 638
    __s2_len = strlen((char const   *)correctpass);
#line 638
    if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) ==
           1U)) {
      goto _L___0;
    } else {
#line 638
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 638
        if (! ((unsigned int )((void const   *)(correctpass + 1)) - (unsigned int )((void const   *)correctpass) ==
               1U)) {
#line 638
          tmp___8 = 1;
        } else {
#line 638
          if (__s2_len >= 4U) {
#line 638
            tmp___8 = 1;
          } else {
#line 638
            tmp___8 = 0;
          }
        }
      } else {
#line 638
        tmp___8 = 0;
      }
    }
#line 638
    if (tmp___8) {
#line 638
      tmp___4 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
    } else {
#line 638
      tmp___7 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
#line 638
      tmp___4 = tmp___7;
    }
  } else {
#line 638
    tmp___7 = __builtin_strcmp((char const   *)password, (char const   *)correctpass);
#line 638
    tmp___4 = tmp___7;
  }
#line 638
  if (tmp___4) {
#line 639
    return (0);
  } else {
#line 641
    return (1);
  }
}
}
#line 644 "connection.c"
int connection_check_admin_pass(http_parser_t *parser ) 
{ int ret ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  char *pass ;
  char *user ;
  char *protocol ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 647
  tmp = config_get_config();
#line 647
  config = tmp;
#line 648
  pass = config->admin_password;
#line 649
  user = config->admin_username;
#line 652
  if (! pass) {
#line 653
    config_release_config();
#line 654
    return (0);
  } else {
#line 652
    if (! user) {
#line 653
      config_release_config();
#line 654
      return (0);
    }
  }
#line 657
  protocol = httpp_getvar(parser, "__protocol");
#line 658
  if (protocol) {
#line 658
    if (0) {
#line 658
      __s1_len = strlen((char const   *)protocol);
#line 658
      __s2_len = strlen("ICY");
#line 658
      if (! ((unsigned int )((void const   *)(protocol + 1)) - (unsigned int )((void const   *)protocol) ==
             1U)) {
        goto _L___0;
      } else {
#line 658
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 658
          if (! ((unsigned int )((void const   *)("ICY" + 1)) - (unsigned int )((void const   *)"ICY") ==
                 1U)) {
#line 658
            tmp___9 = 1;
          } else {
#line 658
            if (__s2_len >= 4U) {
#line 658
              tmp___9 = 1;
            } else {
#line 658
              tmp___9 = 0;
            }
          }
        } else {
#line 658
          tmp___9 = 0;
        }
      }
#line 658
      if (tmp___9) {
#line 658
        tmp___5 = __builtin_strcmp((char const   *)protocol, "ICY");
      } else {
#line 658
        tmp___8 = __builtin_strcmp((char const   *)protocol, "ICY");
#line 658
        tmp___5 = tmp___8;
      }
    } else {
#line 658
      tmp___8 = __builtin_strcmp((char const   *)protocol, "ICY");
#line 658
      tmp___5 = tmp___8;
    }
#line 658
    if (tmp___5 == 0) {
#line 659
      ret = _check_pass_icy(parser, pass);
    } else {
#line 661
      ret = _check_pass_http(parser, user, pass);
    }
  } else {
#line 661
    ret = _check_pass_http(parser, user, pass);
  }
#line 662
  config_release_config();
#line 663
  return (ret);
}
}
#line 666 "connection.c"
int connection_check_relay_pass(http_parser_t *parser ) 
{ int ret ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  char *pass ;
  char *user ;

  {
#line 669
  tmp = config_get_config();
#line 669
  config = tmp;
#line 670
  pass = config->relay_password;
#line 671
  user = config->relay_username;
#line 673
  if (! pass) {
#line 674
    config_release_config();
#line 675
    return (0);
  } else {
#line 673
    if (! user) {
#line 674
      config_release_config();
#line 675
      return (0);
    }
  }
#line 678
  ret = _check_pass_http(parser, user, pass);
#line 679
  config_release_config();
#line 680
  return (ret);
}
}
#line 683 "connection.c"
int connection_check_source_pass(http_parser_t *parser , char const   *mount ) 
{ ice_config_t *config ;
  ice_config_t *tmp ;
  char *pass ;
  char *user ;
  int ret ;
  int ice_login ;
  char *protocol ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 685
  tmp = config_get_config();
#line 685
  config = tmp;
#line 686
  pass = config->source_password;
#line 687
  user = (char *)"source";
#line 689
  ice_login = config->ice_login;
#line 692
  tmp___0 = config_find_mount(config, mount);
#line 692
  mountinfo = tmp___0;
#line 694
  if (mountinfo) {
#line 696
    if (mountinfo->password) {
#line 697
      pass = mountinfo->password;
    }
#line 698
    if (mountinfo->username) {
#line 699
      user = mountinfo->username;
    }
  }
#line 702
  if (! pass) {
#line 703
    log_write(errorlog, 2U, "connection/", "connection_check_source_pass", "No source password set, rejecting source");
#line 704
    config_release_config();
#line 705
    return (0);
  }
#line 708
  protocol = httpp_getvar(parser, "__protocol");
#line 709
  if ((unsigned int )protocol != (unsigned int )((void *)0)) {
#line 709
    if (0) {
#line 709
      __s1_len = strlen((char const   *)protocol);
#line 709
      __s2_len = strlen("ICY");
#line 709
      if (! ((unsigned int )((void const   *)(protocol + 1)) - (unsigned int )((void const   *)protocol) ==
             1U)) {
        goto _L___0;
      } else {
#line 709
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 709
          if (! ((unsigned int )((void const   *)("ICY" + 1)) - (unsigned int )((void const   *)"ICY") ==
                 1U)) {
#line 709
            tmp___10 = 1;
          } else {
#line 709
            if (__s2_len >= 4U) {
#line 709
              tmp___10 = 1;
            } else {
#line 709
              tmp___10 = 0;
            }
          }
        } else {
#line 709
          tmp___10 = 0;
        }
      }
#line 709
      if (tmp___10) {
#line 709
        tmp___6 = __builtin_strcmp((char const   *)protocol, "ICY");
      } else {
#line 709
        tmp___9 = __builtin_strcmp((char const   *)protocol, "ICY");
#line 709
        tmp___6 = tmp___9;
      }
    } else {
#line 709
      tmp___9 = __builtin_strcmp((char const   *)protocol, "ICY");
#line 709
      tmp___6 = tmp___9;
    }
#line 709
    if (tmp___6) {
      goto _L___1;
    } else {
#line 710
      ret = _check_pass_icy(parser, pass);
    }
  } else {
    _L___1: /* CIL Label */ 
#line 713
    ret = _check_pass_http(parser, user, pass);
#line 714
    if (! ret) {
#line 714
      if (ice_login) {
#line 716
        ret = _check_pass_ice(parser, pass);
#line 717
        if (ret) {
#line 718
          log_write(errorlog, 2U, "connection/", "connection_check_source_pass", "Source is using deprecated icecast login");
        }
      }
    }
  }
#line 721
  config_release_config();
#line 722
  return (ret);
}
}
#line 726 "connection.c"
static void _handle_source_request(client_t *client , char *uri , int auth_style ) 
{ source_t *source ;
  int tmp ;
  refbuf_t *ok ;
  refbuf_t *tmp___0 ;
  int tmp___1 ;

  {
#line 730
  log_write(errorlog, 3U, "connection/", "_handle_source_request", "Source logging in at mountpoint \"%s\"",
            uri);
#line 732
  if ((int )(*(uri + 0)) != 47) {
#line 734
    log_write(errorlog, 2U, "connection/", "_handle_source_request", "source mountpoint not starting with /");
#line 735
    client_send_401(client);
#line 736
    return;
  }
#line 738
  if (auth_style == 0) {
#line 739
    tmp = connection_check_source_pass(client->parser, (char const   *)uri);
#line 739
    if (tmp == 0) {
#line 745
      log_write(errorlog, 3U, "connection/", "_handle_source_request", "Source (%s) attempted to login with invalid or missing password",
                uri);
#line 746
      client_send_401(client);
#line 747
      return;
    }
  }
#line 750
  source = source_reserve((char const   *)uri);
#line 751
  if (source) {
#line 753
    if (auth_style == 1) {
#line 754
      source->shoutcast_compat = 1;
    }
#line 756
    source->client = client;
#line 757
    source->parser = client->parser;
#line 758
    source->con = client->con;
#line 759
    tmp___1 = connection_complete_source(source, 1);
#line 759
    if (tmp___1 < 0) {
#line 761
      source_clear_source(source);
#line 762
      source_free_source(source);
    } else {
#line 766
      tmp___0 = refbuf_new(4096UL);
#line 766
      ok = tmp___0;
#line 767
      client->respcode = 200;
#line 768
      snprintf((char * __restrict  )ok->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\n\r\n");
#line 770
      ok->len = (unsigned long )strlen((char const   *)ok->data);
#line 772
      ok->associated = client->refbuf;
#line 773
      client->refbuf = ok;
#line 774
      fserve_add_client_callback(client, & source_client_callback, (void *)source);
    }
  } else {
#line 779
    client_send_403(client, "Mountpoint in use");
#line 780
    log_write(errorlog, 2U, "connection/", "_handle_source_request", "Mountpoint %s in use",
              uri);
  }
#line 782
  return;
}
}
#line 785 "connection.c"
static void _handle_stats_request(client_t *client , char *uri ) 
{ int tmp ;

  {
#line 787
  stats_event_inc((char const   *)((void *)0), "stats_connections");
#line 789
  tmp = connection_check_admin_pass(client->parser);
#line 789
  if (tmp == 0) {
#line 791
    client_send_401(client);
#line 792
    log_write(errorlog, 1U, "connection/", "_handle_stats_request", "Bad password for stats connection");
#line 793
    return;
  }
#line 796
  client->respcode = 200;
#line 797
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\n\r\n");
#line 799
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 800
  fserve_add_client_callback(client, & stats_callback, (void *)0);
#line 801
  return;
}
}
#line 803 "connection.c"
static void _handle_get_request(client_t *client , char *passed_uri ) 
{ int fileserve ;
  int port ;
  int i ;
  char *serverhost ;
  int serverport ;
  aliases *alias ;
  ice_config_t *config ;
  char *uri ;
  char *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___52 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___65 ;

  {
#line 808
  serverhost = (char *)((void *)0);
#line 809
  serverport = 0;
#line 812
  uri = passed_uri;
#line 814
  config = config_get_config();
#line 815
  fileserve = config->fileserve;
#line 816
  port = config->port;
#line 817
  i = 0;
#line 817
  while (i < global.server_sockets) {
#line 818
    if (global.serversock[i] == (client->con)->serversock) {
#line 819
      serverhost = config->listeners[i].bind_address;
#line 820
      serverport = config->listeners[i].port;
#line 821
      break;
    }
#line 817
    i ++;
  }
#line 824
  alias = config->aliases;
#line 837
  while (alias) {
#line 838
    if (0) {
#line 838
      __s1_len = strlen((char const   *)uri);
#line 838
      __s2_len = strlen((char const   *)alias->source);
#line 838
      if (! ((unsigned int )((void const   *)(uri + 1)) - (unsigned int )((void const   *)uri) ==
             1U)) {
        goto _L___0;
      } else {
#line 838
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 838
          if (! ((unsigned int )((void const   *)(alias->source + 1)) - (unsigned int )((void const   *)alias->source) ==
                 1U)) {
#line 838
            tmp___18 = 1;
          } else {
#line 838
            if (__s2_len >= 4U) {
#line 838
              tmp___18 = 1;
            } else {
#line 838
              tmp___18 = 0;
            }
          }
        } else {
#line 838
          tmp___18 = 0;
        }
      }
#line 838
      if (tmp___18) {
#line 838
        tmp___14 = __builtin_strcmp((char const   *)uri, (char const   *)alias->source);
      } else {
#line 838
        tmp___17 = __builtin_strcmp((char const   *)uri, (char const   *)alias->source);
#line 838
        tmp___14 = tmp___17;
      }
    } else {
#line 838
      tmp___17 = __builtin_strcmp((char const   *)uri, (char const   *)alias->source);
#line 838
      tmp___14 = tmp___17;
    }
#line 838
    if (tmp___14 == 0) {
#line 838
      if (alias->port == -1) {
        goto _L___3;
      } else {
#line 838
        if (alias->port == serverport) {
          _L___3: /* CIL Label */ 
#line 838
          if ((unsigned int )alias->bind_address == (unsigned int )((void *)0)) {
#line 839
            tmp___8 = __strdup((char const   *)alias->destination);
#line 839
            uri = tmp___8;
#line 840
            log_write(errorlog, 4U, "connection/", "_handle_get_request", "alias has made %s into %s",
                      passed_uri, uri);
#line 841
            break;
          } else {
#line 838
            if ((unsigned int )serverhost != (unsigned int )((void *)0)) {
#line 838
              if (0) {
#line 838
                __s1_len___0 = strlen((char const   *)alias->bind_address);
#line 838
                __s2_len___0 = strlen((char const   *)serverhost);
#line 838
                if (! ((unsigned int )((void const   *)(alias->bind_address + 1)) -
                       (unsigned int )((void const   *)alias->bind_address) == 1U)) {
                  goto _L___2;
                } else {
#line 838
                  if (__s1_len___0 >= 4U) {
                    _L___2: /* CIL Label */ 
#line 838
                    if (! ((unsigned int )((void const   *)(serverhost + 1)) - (unsigned int )((void const   *)serverhost) ==
                           1U)) {
#line 838
                      tmp___28 = 1;
                    } else {
#line 838
                      if (__s2_len___0 >= 4U) {
#line 838
                        tmp___28 = 1;
                      } else {
#line 838
                        tmp___28 = 0;
                      }
                    }
                  } else {
#line 838
                    tmp___28 = 0;
                  }
                }
#line 838
                if (tmp___28) {
#line 838
                  tmp___24 = __builtin_strcmp((char const   *)alias->bind_address,
                                              (char const   *)serverhost);
                } else {
#line 838
                  tmp___27 = __builtin_strcmp((char const   *)alias->bind_address,
                                              (char const   *)serverhost);
#line 838
                  tmp___24 = tmp___27;
                }
              } else {
#line 838
                tmp___27 = __builtin_strcmp((char const   *)alias->bind_address, (char const   *)serverhost);
#line 838
                tmp___24 = tmp___27;
              }
#line 838
              if (tmp___24 == 0) {
#line 839
                tmp___8 = __strdup((char const   *)alias->destination);
#line 839
                uri = tmp___8;
#line 840
                log_write(errorlog, 4U, "connection/", "_handle_get_request", "alias has made %s into %s",
                          passed_uri, uri);
#line 841
                break;
              }
            }
          }
        }
      }
    }
#line 843
    alias = alias->next;
  }
#line 845
  config_release_config();
#line 847
  stats_event_inc((char const   *)((void *)0), "client_connections");
#line 850
  if (0) {
#line 850
    __s1_len___1 = strlen((char const   *)uri);
#line 850
    __s2_len___1 = strlen("/admin.cgi");
#line 850
    if (! ((unsigned int )((void const   *)(uri + 1)) - (unsigned int )((void const   *)uri) ==
           1U)) {
      goto _L___5;
    } else {
#line 850
      if (__s1_len___1 >= 4U) {
        _L___5: /* CIL Label */ 
#line 850
        if (! ((unsigned int )((void const   *)("/admin.cgi" + 1)) - (unsigned int )((void const   *)"/admin.cgi") ==
               1U)) {
#line 850
          tmp___38 = 1;
        } else {
#line 850
          if (__s2_len___1 >= 4U) {
#line 850
            tmp___38 = 1;
          } else {
#line 850
            tmp___38 = 0;
          }
        }
      } else {
#line 850
        tmp___38 = 0;
      }
    }
#line 850
    if (tmp___38) {
#line 850
      tmp___34 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
    } else {
#line 850
      tmp___37 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
#line 850
      tmp___34 = tmp___37;
    }
  } else {
#line 850
    tmp___37 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
#line 850
    tmp___34 = tmp___37;
  }
#line 851
  if (tmp___34 == 0) {
    goto _L___10;
  } else {
#line 851
    if (0) {
#line 851
      if (0) {
#line 851
        __s1_len___3 = strlen((char const   *)uri);
#line 851
        __s2_len___3 = strlen("/admin/");
#line 851
        if (! ((unsigned int )((void const   *)(uri + 1)) - (unsigned int )((void const   *)uri) ==
               1U)) {
          goto _L___9;
        } else {
#line 851
          if (__s1_len___3 >= 4U) {
            _L___9: /* CIL Label */ 
#line 851
            if (! ((unsigned int )((void const   *)("/admin/" + 1)) - (unsigned int )((void const   *)"/admin/") ==
                   1U)) {
#line 851
              tmp___62 = 1;
            } else {
#line 851
              if (__s2_len___3 >= 4U) {
#line 851
                tmp___62 = 1;
              } else {
#line 851
                tmp___62 = 0;
              }
            }
          } else {
#line 851
            tmp___62 = 0;
          }
        }
#line 851
        if (tmp___62) {
#line 851
          tmp___58 = __builtin_strcmp((char const   *)uri, "/admin/");
        } else {
#line 851
          tmp___61 = __builtin_strcmp((char const   *)uri, "/admin/");
#line 851
          tmp___58 = tmp___61;
        }
      } else {
#line 851
        tmp___61 = __builtin_strcmp((char const   *)uri, "/admin/");
#line 851
        tmp___58 = tmp___61;
      }
#line 851
      tmp___52 = tmp___58;
    } else {
#line 851
      tmp___52 = strncmp((char const   *)uri, "/admin/", 7U);
    }
#line 851
    if (tmp___52 == 0) {
      _L___10: /* CIL Label */ 
#line 852
      admin_handle_request(client, uri);
#line 853
      if ((unsigned int )uri != (unsigned int )passed_uri) {
#line 853
        free((void *)uri);
      }
#line 854
      return;
    }
  }
#line 861
  tmp___65 = util_check_valid_extension(uri);
#line 861
  if (tmp___65 == 1) {
#line 864
    log_write(errorlog, 4U, "connection/", "_handle_get_request", "Stats request, sending XSL transformed stats");
#line 865
    stats_transform_xslt(client, (char const   *)uri);
#line 866
    if ((unsigned int )uri != (unsigned int )passed_uri) {
#line 866
      free((void *)uri);
    }
#line 867
    return;
  }
#line 870
  add_client((char const   *)uri, client);
#line 871
  if ((unsigned int )uri != (unsigned int )passed_uri) {
#line 871
    free((void *)uri);
  }
#line 872
  return;
}
}
#line 874 "connection.c"
static void _handle_shoutcast_compatible(client_queue_t *node ) 
{ char *http_compliant ;
  int http_compliant_len ;
  http_parser_t *parser ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  char *shoutcast_mount ;
  client_t *client ;
  char *source_password ;
  char *ptr ;
  char *headers ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;
  char *tmp___10 ;
  char *tmp___20 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___40 ;
  size_t tmp___41 ;
  char *ptr___0 ;
  size_t tmp___43 ;
  int tmp___44 ;

  {
#line 877
  http_compliant_len = 0;
#line 879
  tmp = config_get_config();
#line 879
  config = tmp;
#line 881
  client = node->client;
#line 883
  if (node->shoutcast == 1) {
#line 886
    tmp___0 = config_find_mount(config, (char const   *)config->shoutcast_mount);
#line 886
    mountinfo = tmp___0;
#line 888
    if (mountinfo) {
#line 888
      if (mountinfo->password) {
#line 889
        tmp___10 = __strdup((char const   *)mountinfo->password);
#line 889
        source_password = tmp___10;
      } else {
#line 891
        tmp___20 = __strdup((char const   *)config->source_password);
#line 891
        source_password = tmp___20;
      }
    } else {
#line 891
      tmp___20 = __strdup((char const   *)config->source_password);
#line 891
      source_password = tmp___20;
    }
#line 892
    config_release_config();
#line 895
    ptr = strstr((char const   *)(client->refbuf)->data, "\r\r\n");
#line 896
    if (ptr) {
#line 897
      headers = ptr + 3;
    } else {
#line 900
      ptr = strstr((char const   *)(client->refbuf)->data, "\r\n");
#line 901
      if (ptr) {
#line 902
        headers = ptr + 2;
      } else {
#line 905
        ptr = strstr((char const   *)(client->refbuf)->data, "\n");
#line 906
        if (ptr) {
#line 907
          headers = ptr + 1;
        }
      }
    }
#line 911
    if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 913
      client_destroy(client);
#line 914
      free((void *)source_password);
#line 915
      free((void *)node);
#line 916
      return;
    }
#line 918
    (*ptr) = (char )'\000';
#line 920
    if (0) {
#line 920
      __s1_len = strlen((char const   *)(client->refbuf)->data);
#line 920
      __s2_len = strlen((char const   *)source_password);
#line 920
      if (! ((unsigned int )((void const   *)((client->refbuf)->data + 1)) - (unsigned int )((void const   *)(client->refbuf)->data) ==
             1U)) {
        goto _L___0;
      } else {
#line 920
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 920
          if (! ((unsigned int )((void const   *)(source_password + 1)) - (unsigned int )((void const   *)source_password) ==
                 1U)) {
#line 920
            tmp___30 = 1;
          } else {
#line 920
            if (__s2_len >= 4U) {
#line 920
              tmp___30 = 1;
            } else {
#line 920
              tmp___30 = 0;
            }
          }
        } else {
#line 920
          tmp___30 = 0;
        }
      }
#line 920
      if (tmp___30) {
#line 920
        tmp___26 = __builtin_strcmp((char const   *)(client->refbuf)->data, (char const   *)source_password);
      } else {
#line 920
        tmp___29 = __builtin_strcmp((char const   *)(client->refbuf)->data, (char const   *)source_password);
#line 920
        tmp___26 = tmp___29;
      }
    } else {
#line 920
      tmp___29 = __builtin_strcmp((char const   *)(client->refbuf)->data, (char const   *)source_password);
#line 920
      tmp___26 = tmp___29;
    }
#line 920
    if (tmp___26 == 0) {
#line 922
      client->respcode = 200;
#line 925
      sock_write((client->con)->sock, "OK2\r\n");
#line 926
      node->offset -= headers - (client->refbuf)->data;
#line 927
      memmove((void *)(client->refbuf)->data, (void const   *)headers, (unsigned int )(node->offset +
                                                                                       1));
#line 928
      node->shoutcast = 2;
#line 930
      _add_request_queue(node);
#line 931
      free((void *)source_password);
#line 932
      return;
    } else {
#line 935
      log_write(errorlog, 3U, "connection/", "_handle_shoutcast_compatible", "password does not match \"%s\"",
                (client->refbuf)->data);
    }
#line 936
    client_destroy(client);
#line 937
    free((void *)node);
#line 938
    return;
  }
#line 940
  tmp___40 = __strdup((char const   *)config->shoutcast_mount);
#line 940
  shoutcast_mount = tmp___40;
#line 941
  config_release_config();
#line 945
  tmp___41 = strlen((char const   *)shoutcast_mount);
#line 945
  http_compliant_len = (int )((20U + tmp___41) + (size_t )node->offset);
#line 946
  http_compliant = (char *)calloc(1U, (unsigned int )http_compliant_len);
#line 947
  snprintf((char * __restrict  )http_compliant, (unsigned int )http_compliant_len,
           (char const   * __restrict  )"SOURCE %s HTTP/1.0\r\n%s", shoutcast_mount,
           (client->refbuf)->data);
#line 949
  parser = httpp_create_parser();
#line 950
  httpp_initialize(parser, (http_varlist_t *)((void *)0));
#line 951
  tmp___43 = strlen((char const   *)http_compliant);
#line 951
  tmp___44 = httpp_parse(parser, http_compliant, (unsigned long )tmp___43);
#line 951
  if (tmp___44) {
#line 954
    if (node->stream_offset == node->offset) {
#line 955
      (client->refbuf)->len = 0UL;
    } else {
#line 958
      ptr___0 = (client->refbuf)->data;
#line 959
      (client->refbuf)->len = (unsigned long )(node->offset - node->stream_offset);
#line 960
      memmove((void *)ptr___0, (void const   *)(ptr___0 + node->stream_offset), (unsigned int )(client->refbuf)->len);
    }
#line 962
    client->parser = parser;
#line 963
    _handle_source_request(client, shoutcast_mount, 1);
  } else {
#line 966
    client_destroy(client);
  }
#line 967
  free((void *)http_compliant);
#line 968
  free((void *)shoutcast_mount);
#line 969
  free((void *)node);
#line 970
  return;
}
}
#line 978 "connection.c"
static void *_handle_connection(void *arg ) 
{ http_parser_t *parser ;
  char *rawuri ;
  char *uri ;
  client_queue_t *node ;
  client_queue_t *tmp ;
  client_t *client ;
  char *ptr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___75 ;
  char *tmp___76 ;
  char *tmp___93 ;
  int tmp___94 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;

  {
    ///thread_register("handle_connection");
    ///thread_check_in();

#line 983
  LOOP_HANDLE_CONNECTION:while (global.running == 1) {
#line 985
    tmp = _get_connection();
#line 985
    node = tmp;
#line 987
    if (node) {
#line 989
      client = node->client;
#line 992
      if (node->shoutcast) {
#line 994
        _handle_shoutcast_compatible(node);
#line 995
        continue;
      }
#line 999
      parser = httpp_create_parser();
#line 1000
      httpp_initialize(parser, (http_varlist_t *)((void *)0));
#line 1001
      client->parser = parser;
#line 1002
      tmp___100 = httpp_parse(parser, (client->refbuf)->data, (unsigned long )node->offset);
#line 1002
      if (tmp___100) {
#line 1005
        if (node->stream_offset == node->offset) {
#line 1006
          (client->refbuf)->len = 0UL;
        } else {
#line 1009
          ptr = (client->refbuf)->data;
#line 1010
          (client->refbuf)->len = (unsigned long )(node->offset - node->stream_offset);
#line 1011
          memmove((void *)ptr, (void const   *)(ptr + node->stream_offset), (unsigned int )(client->refbuf)->len);
        }
#line 1013
        free((void *)node);
#line 1015
        if (0) {
#line 1015
          __s1_len = strlen("ICE");
#line 1015
          tmp___46 = httpp_getvar(parser, "__protocol");
#line 1015
          __s2_len = strlen((char const   *)tmp___46);
#line 1015
          if (! ((unsigned int )((void const   *)("ICE" + 1)) - (unsigned int )((void const   *)"ICE") ==
                 1U)) {
            goto _L___0;
          } else {
#line 1015
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1015
              tmp___47 = httpp_getvar(parser, "__protocol");
#line 1015
              tmp___48 = httpp_getvar(parser, "__protocol");
#line 1015
              if ((unsigned int )((void const   *)(tmp___47 + 1)) - (unsigned int )((void const   *)tmp___48) ==
                  1U) {
#line 1015
                if (__s2_len >= 4U) {
#line 1015
                  tmp___49 = 1;
                } else {
#line 1015
                  tmp___49 = 0;
                }
              } else {
#line 1015
                tmp___49 = 1;
              }
            } else {
#line 1015
              tmp___49 = 0;
            }
          }
#line 1015
          if (tmp___49) {
#line 1015
            tmp___26 = httpp_getvar(parser, "__protocol");
#line 1015
            tmp___25 = __builtin_strcmp("ICE", (char const   *)tmp___26);
          } else {
#line 1015
            tmp___43 = httpp_getvar(parser, "__protocol");
#line 1015
            tmp___44 = __builtin_strcmp("ICE", (char const   *)tmp___43);
#line 1015
            tmp___25 = tmp___44;
          }
        } else {
#line 1015
          tmp___43 = httpp_getvar(parser, "__protocol");
#line 1015
          tmp___44 = __builtin_strcmp("ICE", (char const   *)tmp___43);
#line 1015
          tmp___25 = tmp___44;
        }
#line 1016
        if (tmp___25) {
#line 1016
          if (0) {
#line 1016
            __s1_len___0 = strlen("HTTP");
#line 1016
            tmp___96 = httpp_getvar(parser, "__protocol");
#line 1016
            __s2_len___0 = strlen((char const   *)tmp___96);
#line 1016
            if (! ((unsigned int )((void const   *)("HTTP" + 1)) - (unsigned int )((void const   *)"HTTP") ==
                   1U)) {
              goto _L___2;
            } else {
#line 1016
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 1016
                tmp___97 = httpp_getvar(parser, "__protocol");
#line 1016
                tmp___98 = httpp_getvar(parser, "__protocol");
#line 1016
                if ((unsigned int )((void const   *)(tmp___97 + 1)) - (unsigned int )((void const   *)tmp___98) ==
                    1U) {
#line 1016
                  if (__s2_len___0 >= 4U) {
#line 1016
                    tmp___99 = 1;
                  } else {
#line 1016
                    tmp___99 = 0;
                  }
                } else {
#line 1016
                  tmp___99 = 1;
                }
              } else {
#line 1016
                tmp___99 = 0;
              }
            }
#line 1016
            if (tmp___99) {
#line 1016
              tmp___76 = httpp_getvar(parser, "__protocol");
#line 1016
              tmp___75 = __builtin_strcmp("HTTP", (char const   *)tmp___76);
            } else {
#line 1016
              tmp___93 = httpp_getvar(parser, "__protocol");
#line 1016
              tmp___94 = __builtin_strcmp("HTTP", (char const   *)tmp___93);
#line 1016
              tmp___75 = tmp___94;
            }
          } else {
#line 1016
            tmp___93 = httpp_getvar(parser, "__protocol");
#line 1016
            tmp___94 = __builtin_strcmp("HTTP", (char const   *)tmp___93);
#line 1016
            tmp___75 = tmp___94;
          }
#line 1016
          if (tmp___75) {
#line 1017
            log_write(errorlog, 1U, "connection/", "_handle_connection", "Bad HTTP protocol detected");
#line 1018
            client_destroy(client);
#line 1019
            continue;
          }
        }
#line 1022
        rawuri = httpp_getvar(parser, "__uri");
#line 1023
        uri = util_normalise_uri(rawuri);
#line 1025
        if ((unsigned int )uri == (unsigned int )((void *)0)) {
#line 1027
          client_destroy(client);
#line 1028
          continue;
        }
#line 1031
        if ((int )parser->req_type == 4) {
#line 1032
          _handle_source_request(client, uri, 0);
        } else {
#line 1034
          if ((int )parser->req_type == 6) {
#line 1035
            _handle_stats_request(client, uri);
          } else {
#line 1037
            if ((int )parser->req_type == 1) {
#line 1038
              _handle_get_request(client, uri);
            } else {
#line 1041
              log_write(errorlog, 1U, "connection/", "_handle_connection", "Wrong request type from client");
#line 1042
              client_send_400(client, (char *)"unknown request");
            }
          }
        }
#line 1045
        free((void *)uri);
      } else {
#line 1049
        free((void *)node);
#line 1050
        log_write(errorlog, 1U, "connection/", "_handle_connection", "HTTP request parsing failed");
#line 1051
        client_destroy(client);
      }
#line 1053
      continue;
    }
#line 1055
    thread_sleep(50000UL);
  }

    ///thread_deregister("handle_connection");

#line 1057
  log_write(errorlog, 4U, "connection/", "_handle_connection", "Connection thread done");
#line 1059
  return ((void *)0);
}
}
#line 1062 "connection.c"
void connection_close(connection_t *con ) 
{ 

  {
#line 1064
  sock_close(con->sock);
#line 1065
  if (con->ip) {
#line 1065
    free((void *)con->ip);
  }
#line 1066
  if (con->host) {
#line 1066
    free((void *)con->host);
  }
#line 1067
  free((void *)con);
#line 1068
  return;
}
}
#line 1 "cil-tcnNRZVh.o"
#pragma merger(0,"/tmp/cil-2zyWJZzL.i","")
#line 1 "./src/source.o_saved.c"
#pragma merger(0,"./source.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 403 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 138 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 36 "refbuf.h"
void refbuf_addref(refbuf_t *self ) ;
#line 37
void refbuf_release(refbuf_t *self ) ;
#line 73 "client.h"
void client_send_404(client_t *client , char *message ) ;
#line 83 "stats.h"
void stats_event_hidden(char const   *source , char const   *name , int hidden ) ;
#line 84
void stats_event_time(char const   *mount , char const   *name ) ;
#line 87 "auth.h"
void auth_stream_start(struct _mount_proxy *mountinfo , char const   *mount ) ;
#line 90
void auth_stream_end(struct _mount_proxy *mountinfo , char const   *mount ) ;
#line 31 "yp.h"
void yp_add(char const   *mount ) ;
#line 64 "format.h"
int format_check_http_buffer(struct source_tag *source , client_t *client ) ;
#line 65
int format_check_file_buffer(struct source_tag *source , client_t *client ) ;
#line 81 "source.h"
void *source_client_thread(void *arg ) ;
#line 86
source_t *source_find_mount_raw(char const   *mount ) ;
#line 87
client_t *source_find_client(source_t *source , int id ) ;
#line 91
int source_remove_client(void *key ) ;
#line 95 "source.h"
mutex_t move_clients_mutex  ;
#line 36 "fserve.h"
char *fserve_content_type(char const   *path ) ;
#line 63 "source.c"
static int _compare_clients(void *compare_arg , void *a , void *b ) ;
#line 64
static int _free_client(void *key ) ;
#line 65
static void _parse_audio_info(source_t *source , char const   *s ) ;
#line 66
static void source_shutdown(source_t *source ) ;
#line 70
static void source_run_script(char *command , char *mountpoint ) ;
#line 77 "source.c"
source_t *source_reserve(char const   *mount ) 
{ source_t *src ;
  char *tmp___8 ;

  {
#line 79
  src = (source_t *)((void *)0);
#line 81
  if ((int const   )(*(mount + 0)) != 47) {
#line 82
    log_write(errorlog, 2U, "source/", "source_reserve", "Source at \"%s\" does not start with \'/\', clients will be unable to connect",
              mount);
  }
#line 85
  while (1) {
#line 87
    avl_tree_wlock(global.source_tree);
#line 88
    src = source_find_mount_raw(mount);
#line 89
    if (src) {
#line 91
      src = (source_t *)((void *)0);
#line 92
      break;
    }
#line 95
    src = (source_t *)calloc(1U, sizeof(source_t ));
#line 96
    if ((unsigned int )src == (unsigned int )((void *)0)) {
#line 97
      break;
    }
#line 99
    src->client_tree = avl_tree_new(& _compare_clients, (void *)0);
#line 100
    src->pending_tree = avl_tree_new(& _compare_clients, (void *)0);
#line 103
    tmp___8 = __strdup(mount);
#line 103
    src->mount = tmp___8;
#line 104
    src->max_listeners = -1L;
#line 106
    avl_insert(global.source_tree, (void *)src);
#line 85
    break;
  }
#line 110
  avl_tree_unlock(global.source_tree);
#line 111
  return (src);
}
}
#line 118 "source.c"
source_t *source_find_mount_raw(char const   *mount ) 
{ source_t *source ;
  avl_node *node ;
  int cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 124
  if (! mount) {
#line 125
    return ((source_t *)((void *)0));
  }
#line 128
  node = ((global.source_tree)->root)->right;
#line 130
  while (node) {
#line 131
    source = (source_t *)node->key;
#line 132
    if (0) {
#line 132
      __s1_len = strlen(mount);
#line 132
      __s2_len = strlen((char const   *)source->mount);
#line 132
      if (! ((unsigned int )((void const   *)(mount + 1)) - (unsigned int )((void const   *)mount) ==
             1U)) {
        goto _L___0;
      } else {
#line 132
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 132
          if (! ((unsigned int )((void const   *)(source->mount + 1)) - (unsigned int )((void const   *)source->mount) ==
                 1U)) {
#line 132
            tmp___8 = 1;
          } else {
#line 132
            if (__s2_len >= 4U) {
#line 132
              tmp___8 = 1;
            } else {
#line 132
              tmp___8 = 0;
            }
          }
        } else {
#line 132
          tmp___8 = 0;
        }
      }
#line 132
      if (tmp___8) {
#line 132
        tmp___4 = __builtin_strcmp(mount, (char const   *)source->mount);
      } else {
#line 132
        tmp___7 = __builtin_strcmp(mount, (char const   *)source->mount);
#line 132
        tmp___4 = tmp___7;
      }
    } else {
#line 132
      tmp___7 = __builtin_strcmp(mount, (char const   *)source->mount);
#line 132
      tmp___4 = tmp___7;
    }
#line 132
    cmp = tmp___4;
#line 133
    if (cmp < 0) {
#line 134
      node = node->left;
    } else {
#line 135
      if (cmp > 0) {
#line 136
        node = node->right;
      } else {
#line 138
        return (source);
      }
    }
  }
#line 142
  return ((source_t *)((void *)0));
}
}
#line 150 "source.c"
source_t *source_find_mount(char const   *mount ) 
{ source_t *source ;
  ice_config_t *config ;
  mount_proxy *mountinfo ;
  int depth ;

  {
#line 152
  source = (source_t *)((void *)0);
#line 155
  depth = 0;
#line 157
  config = config_get_config();
#line 158
  while (1) {
#line 158
    if (mount) {
#line 158
      if (! (depth < 10)) {
#line 158
        break;
      }
    } else {
#line 158
      break;
    }
#line 160
    source = source_find_mount_raw(mount);
#line 162
    if (source) {
#line 164
      if (source->running) {
#line 165
        break;
      } else {
#line 164
        if (source->on_demand) {
#line 165
          break;
        }
      }
    }
#line 171
    mountinfo = config_find_mount(config, mount);
#line 172
    source = (source_t *)((void *)0);
#line 174
    if ((unsigned int )mountinfo == (unsigned int )((void *)0)) {
#line 175
      break;
    }
#line 176
    mount = (char const   *)mountinfo->fallback_mount;
#line 177
    depth ++;
  }
#line 180
  config_release_config();
#line 181
  return (source);
}
}
#line 185 "source.c"
int source_compare_sources(void *arg , void *a , void *b ) 
{ source_t *srca ;
  source_t *srcb ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 187
  srca = (source_t *)a;
#line 188
  srcb = (source_t *)b;
#line 190
  if (0) {
#line 190
    __s1_len = strlen((char const   *)srca->mount);
#line 190
    __s2_len = strlen((char const   *)srcb->mount);
#line 190
    if (! ((unsigned int )((void const   *)(srca->mount + 1)) - (unsigned int )((void const   *)srca->mount) ==
           1U)) {
      goto _L___0;
    } else {
#line 190
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 190
        if (! ((unsigned int )((void const   *)(srcb->mount + 1)) - (unsigned int )((void const   *)srcb->mount) ==
               1U)) {
#line 190
          tmp___8 = 1;
        } else {
#line 190
          if (__s2_len >= 4U) {
#line 190
            tmp___8 = 1;
          } else {
#line 190
            tmp___8 = 0;
          }
        }
      } else {
#line 190
        tmp___8 = 0;
      }
    }
#line 190
    if (tmp___8) {
#line 190
      tmp___4 = __builtin_strcmp((char const   *)srca->mount, (char const   *)srcb->mount);
    } else {
#line 190
      tmp___7 = __builtin_strcmp((char const   *)srca->mount, (char const   *)srcb->mount);
#line 190
      tmp___4 = tmp___7;
    }
  } else {
#line 190
    tmp___7 = __builtin_strcmp((char const   *)srca->mount, (char const   *)srcb->mount);
#line 190
    tmp___4 = tmp___7;
  }
#line 190
  return (tmp___4);
}
}
#line 194 "source.c"
void source_clear_source(source_t *source ) 
{ avl_node *tmp ;
  avl_node *tmp___0 ;
  avl_node *tmp___1 ;
  avl_node *tmp___2 ;
  refbuf_t *p ;

  {
#line 196
  log_write(errorlog, 4U, "source/", "source_clear_source", "clearing source \"%s\"",
            source->mount);
#line 197
  client_destroy(source->client);
#line 198
  source->client = (client_t *)((void *)0);
#line 199
  source->parser = (http_parser_t *)((void *)0);
#line 200
  source->con = (connection_t *)((void *)0);
#line 202
  if (source->dumpfile) {
#line 204
    log_write(errorlog, 3U, "source/", "source_clear_source", "Closing dumpfile for %s",
              source->mount);
#line 205
    fclose(source->dumpfile);
#line 206
    source->dumpfile = (FILE *)((void *)0);
  }
#line 210
  avl_tree_rlock(source->client_tree);
#line 211
  while (1) {
#line 211
    tmp___0 = avl_get_first(source->client_tree);
#line 211
    if (! tmp___0) {
#line 211
      break;
    }
#line 213
    tmp = avl_get_first(source->client_tree);
#line 213
    avl_delete(source->client_tree, tmp->key, & _free_client);
  }
#line 216
  avl_tree_unlock(source->client_tree);
#line 218
  avl_tree_rlock(source->pending_tree);
#line 219
  while (1) {
#line 219
    tmp___2 = avl_get_first(source->pending_tree);
#line 219
    if (! tmp___2) {
#line 219
      break;
    }
#line 221
    tmp___1 = avl_get_first(source->pending_tree);
#line 221
    avl_delete(source->pending_tree, tmp___1->key, & _free_client);
  }
#line 224
  avl_tree_unlock(source->pending_tree);
#line 226
  if (source->format) {
#line 226
    if ((source->format)->free_plugin) {
#line 227
      ((*((source->format)->free_plugin)))(source->format);
    }
  }
#line 228
  source->format = (struct _format_plugin_tag *)((void *)0);
#line 231
  while (source->stream_data) {
#line 233
    p = source->stream_data;
#line 234
    source->stream_data = p->next;
#line 236
    while (p->_count > 1UL) {
#line 237
      refbuf_release(p);
    }
#line 238
    refbuf_release(p);
  }
#line 240
  source->stream_data_tail = (refbuf_t *)((void *)0);
#line 242
  source->burst_point = (refbuf_t *)((void *)0);
#line 243
  source->burst_size = 0U;
#line 244
  source->burst_offset = 0U;
#line 245
  source->queue_size = 0U;
#line 246
  source->queue_size_limit = 0U;
#line 247
  source->listeners = 0UL;
#line 248
  source->shoutcast_compat = 0;
#line 249
  source->max_listeners = -1L;
#line 250
  source->hidden = 0;
#line 251
  source->client_stats_update = 0L;
#line 252
  util_dict_free(source->audio_info);
#line 253
  source->audio_info = (util_dict *)((void *)0);
#line 255
  free((void *)source->fallback_mount);
#line 256
  source->fallback_mount = (char *)((void *)0);
#line 258
  free((void *)source->dumpfilename);
#line 259
  source->dumpfilename = (char *)((void *)0);
#line 261
  if (source->intro_file) {
#line 263
    fclose(source->intro_file);
#line 264
    source->intro_file = (FILE *)((void *)0);
  }
#line 267
  source->on_demand_req = 0;
#line 268
  return;
}
}
#line 272 "source.c"
void source_free_source(source_t *source ) 
{ 

  {
#line 274
  log_write(errorlog, 4U, "source/", "source_free_source", "freeing source \"%s\"",
            source->mount);
#line 275
  avl_tree_wlock(global.source_tree);
#line 276
  avl_delete(global.source_tree, (void *)source, (int (*)(void *key ))((void *)0));
#line 277
  avl_tree_unlock(global.source_tree);
#line 279
  avl_tree_free(source->pending_tree, & _free_client);
#line 280
  avl_tree_free(source->client_tree, & _free_client);
#line 283
  yp_remove((char const   *)source->mount);
#line 285
  free((void *)source->mount);
#line 286
  free((void *)source);
#line 288
  return;
}
}
#line 292 "source.c"
client_t *source_find_client(source_t *source , int id ) 
{ client_t fakeclient ;
  void *result ;
  connection_t fakecon ;
  int tmp ;

  {
#line 298
  fakeclient.con = & fakecon;
#line 299
  (fakeclient.con)->id = (unsigned long )id;
#line 301
  avl_tree_rlock(source->client_tree);
#line 302
  tmp = avl_get_by_key(source->client_tree, (void *)(& fakeclient), & result);
#line 302
  if (tmp == 0) {
#line 304
    avl_tree_unlock(source->client_tree);
#line 305
    return ((client_t *)result);
  }
#line 308
  avl_tree_unlock(source->client_tree);
#line 309
  return ((client_t *)((void *)0));
}
}
#line 318 "source.c"
void source_move_clients(source_t *source , source_t *dest ) 
{ unsigned long count ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  client_t *client ;
  avl_node *node ;
  avl_node *tmp___9 ;
  avl_node *node___0 ;
  avl_node *tmp___10 ;

  {
#line 320
  count = 0UL;
#line 321
  if (0) {
#line 321
    __s1_len = strlen((char const   *)source->mount);
#line 321
    __s2_len = strlen((char const   *)dest->mount);
#line 321
    if (! ((unsigned int )((void const   *)(source->mount + 1)) - (unsigned int )((void const   *)source->mount) ==
           1U)) {
      goto _L___0;
    } else {
#line 321
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 321
        if (! ((unsigned int )((void const   *)(dest->mount + 1)) - (unsigned int )((void const   *)dest->mount) ==
               1U)) {
#line 321
          tmp___8 = 1;
        } else {
#line 321
          if (__s2_len >= 4U) {
#line 321
            tmp___8 = 1;
          } else {
#line 321
            tmp___8 = 0;
          }
        }
      } else {
#line 321
        tmp___8 = 0;
      }
    }
#line 321
    if (tmp___8) {
#line 321
      tmp___4 = __builtin_strcmp((char const   *)source->mount, (char const   *)dest->mount);
    } else {
#line 321
      tmp___7 = __builtin_strcmp((char const   *)source->mount, (char const   *)dest->mount);
#line 321
      tmp___4 = tmp___7;
    }
  } else {
#line 321
    tmp___7 = __builtin_strcmp((char const   *)source->mount, (char const   *)dest->mount);
#line 321
    tmp___4 = tmp___7;
  }
#line 321
  if (tmp___4 == 0) {
#line 323
    log_write(errorlog, 2U, "source/", "source_move_clients", "src and dst are the same \"%s\", skipping",
              source->mount);
#line 324
    return;
  }
#line 327
  thread_mutex_lock_c(& move_clients_mutex, 327, (char *)"source.c");
#line 331
  if (dest->running == 0) {
#line 331
    if (dest->on_demand == 0) {
#line 333
      log_write(errorlog, 2U, "source/", "source_move_clients", "destination mount %s not running, unable to move clients ",
                dest->mount);
#line 334
      thread_mutex_unlock_c(& move_clients_mutex, 334, (char *)"source.c");
#line 335
      return;
    }
  }
#line 338
  avl_tree_wlock(dest->pending_tree);
#line 339
  while (1) {
#line 345
    avl_tree_wlock(source->client_tree);
#line 346
    avl_tree_wlock(source->pending_tree);
#line 348
    if (source->on_demand == 0) {
#line 348
      if ((unsigned int )source->format == (unsigned int )((void *)0)) {
#line 350
        log_write(errorlog, 3U, "source/", "source_move_clients", "source mount %s is not available",
                  source->mount);
#line 351
        break;
      }
    }
#line 353
    if (source->format) {
#line 353
      if (dest->format) {
#line 355
        if ((int )(source->format)->type != (int )(dest->format)->type) {
#line 357
          log_write(errorlog, 2U, "source/", "source_move_clients", "stream %s and %s are of different types, ignored",
                    source->mount, dest->mount);
#line 358
          break;
        }
      }
    }
#line 362
    while (1) {
#line 364
      tmp___9 = avl_get_first(source->pending_tree);
#line 364
      node = tmp___9;
#line 365
      if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 366
        break;
      }
#line 367
      client = (client_t *)node->key;
#line 368
      avl_delete(source->pending_tree, (void *)client, (int (*)(void *key ))((void *)0));
#line 374
      if ((unsigned int )client->check_buffer != (unsigned int )(& format_check_http_buffer)) {
#line 376
        client_set_queue(client, (refbuf_t *)((void *)0));
#line 377
        client->check_buffer = & format_check_file_buffer;
#line 378
        if ((unsigned int )source->con == (unsigned int )((void *)0)) {
#line 379
          client->intro_offset = -1L;
        }
      }
#line 382
      avl_insert(dest->pending_tree, (void *)client);
#line 383
      count ++;
    }
#line 386
    while (1) {
#line 388
      tmp___10 = avl_get_first(source->client_tree);
#line 388
      node___0 = tmp___10;
#line 389
      if ((unsigned int )node___0 == (unsigned int )((void *)0)) {
#line 390
        break;
      }
#line 392
      client = (client_t *)node___0->key;
#line 393
      avl_delete(source->client_tree, (void *)client, (int (*)(void *key ))((void *)0));
#line 399
      if ((unsigned int )client->check_buffer != (unsigned int )(& format_check_http_buffer)) {
#line 401
        client_set_queue(client, (refbuf_t *)((void *)0));
#line 402
        client->check_buffer = & format_check_file_buffer;
#line 403
        if ((unsigned int )source->con == (unsigned int )((void *)0)) {
#line 404
          client->intro_offset = -1L;
        }
      }
#line 406
      avl_insert(dest->pending_tree, (void *)client);
#line 407
      count ++;
    }
#line 409
    log_write(errorlog, 3U, "source/", "source_move_clients", "passing %lu listeners to \"%s\"",
              count, dest->mount);
#line 411
    source->listeners = 0UL;
#line 412
    stats_event((char const   *)source->mount, "listeners", "0");
#line 339
    break;
  }
#line 416
  avl_tree_unlock(source->pending_tree);
#line 417
  avl_tree_unlock(source->client_tree);
#line 420
  if (dest->running == 0) {
#line 420
    if (dest->on_demand) {
#line 420
      if (count) {
#line 422
        dest->on_demand_req = 1;
#line 423
        slave_rebuild_mounts();
      }
    }
  }
#line 426
  avl_tree_unlock(dest->pending_tree);
#line 427
  thread_mutex_unlock_c(& move_clients_mutex, 427, (char *)"source.c");
#line 428
  return;
}
}
#line 435 "source.c"
static refbuf_t *get_next_buffer(source_t *source ) 
{ refbuf_t *refbuf ;
  int delay ;
  int fds ;
  time_t current ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 437
  refbuf = (refbuf_t *)((void *)0);
#line 438
  delay = 250;
#line 440
  if (source->short_delay) {
#line 441
    delay = 0;
  }
#line 442
  while (1) {
#line 442
    if (global.running == 1) {
#line 442
      if (! source->running) {
#line 442
        break;
      }
    } else {
#line 442
      break;
    }
#line 444
    fds = 0;
#line 445
    tmp = time((time_t *)((void *)0));
#line 445
    current = tmp;
#line 447
    if (source->client) {
#line 448
      fds = util_timed_wait_for_fd((source->con)->sock, delay);
    } else {
#line 451
      thread_sleep((unsigned long )(delay * 1000));
#line 452
      source->last_read = current;
    }
#line 455
    if (current >= source->client_stats_update) {
#line 457
      stats_event_args((char const   *)source->mount, (char *)"total_bytes_read",
                       (char *)"%llu", (source->format)->read_bytes);
#line 459
      stats_event_args((char const   *)source->mount, (char *)"total_bytes_sent",
                       (char *)"%llu", (source->format)->sent_bytes);
#line 461
      source->client_stats_update = current + 5L;
    }
#line 463
    if (fds < 0) {
#line 465
      tmp___0 = sock_error();
#line 465
      tmp___1 = sock_recoverable(tmp___0);
#line 465
      if (! tmp___1) {
#line 467
        log_write(errorlog, 2U, "source/", "get_next_buffer", "Error while waiting on socket, Disconnecting source");
#line 468
        source->running = 0;
      }
#line 470
      break;
    }
#line 472
    if (fds == 0) {
#line 474
      if (source->last_read + (long )source->timeout < current) {
#line 476
        log_write(errorlog, 4U, "source/", "get_next_buffer", "last %ld, timeout %d, now %ld",
                  source->last_read, source->timeout, current);
#line 478
        log_write(errorlog, 2U, "source/", "get_next_buffer", "Disconnecting source due to socket timeout");
#line 479
        source->running = 0;
      }
#line 481
      break;
    }
#line 483
    source->last_read = current;
#line 484
    refbuf = ((*((source->format)->get_buffer)))(source);
#line 485
    if ((source->client)->con) {
#line 485
      if (((source->client)->con)->error) {
#line 487
        log_write(errorlog, 3U, "source/", "get_next_buffer", "End of Stream %s",
                  source->mount);
#line 488
        source->running = 0;
#line 489
        continue;
      }
    }
#line 491
    if (refbuf) {
#line 492
      break;
    }
  }
#line 495
  return (refbuf);
}
}
#line 504 "source.c"
static void send_to_listener(source_t *source , client_t *client , int deletion_expected ) 
{ int bytes ;
  int loop ;
  int total_written ;
  time_t tmp ;
  int tmp___0 ;

  {
#line 507
  loop = 10;
#line 508
  total_written = 0;
#line 510
  while (1) {
#line 513
    if ((client->con)->discon_time) {
#line 514
      tmp = time((time_t *)((void *)0));
#line 514
      if (tmp >= (client->con)->discon_time) {
#line 516
        log_write(errorlog, 3U, "source/", "send_to_listener", "time limit reached for client #%lu",
                  (client->con)->id);
#line 517
        (client->con)->error = 1;
      }
    }
#line 521
    if ((client->con)->error) {
#line 522
      break;
    }
#line 526
    if (total_written > 20000) {
      goto _L;
    } else {
#line 526
      if (loop == 0) {
        _L: /* CIL Label */ 
#line 528
        if ((unsigned int )client->check_buffer != (unsigned int )(& format_check_file_buffer)) {
#line 529
          source->short_delay = 1;
        }
#line 530
        break;
      }
    }
#line 533
    loop --;
#line 535
    tmp___0 = ((*(client->check_buffer)))(source, client);
#line 535
    if (tmp___0 < 0) {
#line 536
      break;
    }
#line 538
    bytes = ((*(client->write_to_client)))(client);
#line 539
    if (bytes <= 0) {
#line 540
      break;
    }
#line 542
    total_written += bytes;
  }
#line 544
  (source->format)->sent_bytes = (source->format)->sent_bytes + (uint64_t )total_written;
#line 548
  if (deletion_expected) {
#line 548
    if (client->refbuf) {
#line 548
      if ((unsigned int )client->refbuf == (unsigned int )source->stream_data) {
#line 550
        log_write(errorlog, 3U, "source/", "send_to_listener", "Client %lu (%s) has fallen too far behind, removing",
                  (client->con)->id, (client->con)->ip);
#line 552
        stats_event_inc((char const   *)source->mount, "slow_listeners");
#line 553
        (client->con)->error = 1;
      }
    }
  }
#line 555
  return;
}
}
#line 561 "source.c"
static void source_init(source_t *source ) 
{ ice_config_t *config ;
  ice_config_t *tmp ;
  char *listenurl ;
  char *str ;
  int listen_url_size ;
  mount_proxy *mountinfo ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ice_config_t *tmp___6 ;
  source_t *fallback_source ;

  {
#line 563
  tmp = config_get_config();
#line 563
  config = tmp;
#line 569
  tmp___0 = strlen("http://");
#line 569
  tmp___1 = strlen((char const   *)config->hostname);
#line 569
  tmp___2 = strlen(":");
#line 569
  tmp___3 = strlen((char const   *)source->mount);
#line 569
  listen_url_size = (int )(((((tmp___0 + tmp___1) + tmp___2) + 6U) + tmp___3) + 1U);
#line 572
  listenurl = (char *)malloc((unsigned int )listen_url_size);
#line 573
  memset((void *)listenurl, '\000', (unsigned int )listen_url_size);
#line 574
  snprintf((char * __restrict  )listenurl, (unsigned int )listen_url_size, (char const   * __restrict  )"http://%s:%d%s",
           config->hostname, config->port, source->mount);
#line 576
  config_release_config();
#line 578
  str = httpp_getvar(source->parser, "ice-audio-info");
#line 579
  source->audio_info = util_dict_new();
#line 580
  if (str) {
#line 582
    _parse_audio_info(source, (char const   *)str);
#line 583
    stats_event((char const   *)source->mount, "audio_info", (char const   *)str);
  }
#line 586
  stats_event((char const   *)source->mount, "listenurl", (char const   *)listenurl);
#line 588
  if (listenurl) {
#line 589
    free((void *)listenurl);
  }
#line 592
  if ((unsigned int )source->dumpfilename != (unsigned int )((void *)0)) {
#line 594
    source->dumpfile = fopen((char const   * __restrict  )source->dumpfilename, (char const   * __restrict  )"ab");
#line 595
    if ((unsigned int )source->dumpfile == (unsigned int )((void *)0)) {
#line 597
      tmp___4 = __errno_location();
#line 597
      tmp___5 = strerror((*tmp___4));
#line 597
      log_write(errorlog, 2U, "source/", "source_init", "Cannot open dump file \"%s\" for appending: %s, disabling.",
                source->dumpfilename, tmp___5);
    }
  }
#line 603
  thread_rwlock_rlock_c(source->shutdown_rwlock, 603, (char *)"source.c");
#line 606
  source->listeners = 0UL;
#line 607
  stats_event_inc((char const   *)((void *)0), "source_total_connections");
#line 608
  stats_event((char const   *)source->mount, "slow_listeners", "0");
#line 609
  stats_event_args((char const   *)source->mount, (char *)"listeners", (char *)"%lu",
                   source->listeners);
#line 610
  stats_event_args((char const   *)source->mount, (char *)"listener_peak", (char *)"%lu",
                   source->peak_listeners);
#line 611
  stats_event_time((char const   *)source->mount, "stream_start");
#line 613
  log_write(errorlog, 4U, "source/", "source_init", "Source creation complete");
#line 614
  source->last_read = time((time_t *)((void *)0));
#line 615
  source->running = 1;
#line 617
  tmp___6 = config_get_config();
#line 617
  mountinfo = config_find_mount(tmp___6, (char const   *)source->mount);
#line 618
  if (mountinfo) {
#line 620
    if (mountinfo->on_connect) {
#line 621
      source_run_script(mountinfo->on_connect, source->mount);
    }
#line 622
    auth_stream_start(mountinfo, (char const   *)source->mount);
  }
#line 624
  config_release_config();
#line 633
  if (source->fallback_override) {
#line 633
    if (source->fallback_mount) {
#line 637
      avl_tree_rlock(global.source_tree);
#line 638
      fallback_source = source_find_mount((char const   *)source->fallback_mount);
#line 640
      if (fallback_source) {
#line 641
        source_move_clients(fallback_source, source);
      }
#line 643
      avl_tree_unlock(global.source_tree);
    }
  }
#line 645
  return;
}
}
#line 648 "source.c"
void source_main(source_t *source ) 
{ unsigned int listeners ;
  refbuf_t *refbuf ;
  client_t *client ;
  avl_node *client_node ;
  int remove_from_q ;
  refbuf_t *to_release ;
  avl_node *tmp ;
  avl_node *tmp___0 ;
  refbuf_t *to_go ;

  {
#line 655
  source_init(source);

  thread_register("source_main");
  thread_check_in();

#line 657
  LOOP_SOURCE_MAIN:while (1) {
#line 657
    if (global.running == 1) {
#line 657
      if (! source->running) {
#line 657
        break;
      }
    } else {
#line 657
      break;
    }
#line 660

    thread_check_out();

    refbuf = get_next_buffer(source);
#line 662
    remove_from_q = 0;
#line 663
    source->short_delay = 0;
#line 665
    if (refbuf) {
#line 668
      if ((unsigned int )source->stream_data == (unsigned int )((void *)0)) {
#line 670
        source->stream_data = refbuf;
#line 671
        source->burst_point = refbuf;
      }
#line 673
      if (source->stream_data_tail) {
#line 674
        (source->stream_data_tail)->next = refbuf;
      }
#line 675
      source->stream_data_tail = refbuf;
#line 676
      source->queue_size = (unsigned int )((unsigned long )source->queue_size + refbuf->len);
#line 678
      refbuf_addref(refbuf);
#line 681
      source->burst_offset = (unsigned int )((unsigned long )source->burst_offset +
                                             refbuf->len);
#line 682
      while (source->burst_offset > source->burst_size) {
#line 684
        to_release = source->burst_point;
#line 686
        if (to_release->next) {
#line 688
          source->burst_point = to_release->next;
#line 689
          source->burst_offset = (unsigned int )((unsigned long )source->burst_offset -
                                                 to_release->len);
#line 690
          refbuf_release(to_release);
#line 691
          continue;
        }
#line 693
        break;
      }
#line 697
      if (source->dumpfile) {
#line 697
        if ((source->format)->write_buf_to_file) {
#line 698
          ((*((source->format)->write_buf_to_file)))(source, refbuf);
        }
      }
    }

    thread_check_in();
    __DSU_update("");
    thread_check_out();


#line 701
    if (source->queue_size > source->queue_size_limit) {
#line 702
      remove_from_q = 1;
    }
#line 705
    avl_tree_wlock(source->client_tree);
#line 707
    listeners = (unsigned int )source->listeners;
#line 708
    client_node = avl_get_first(source->client_tree);
#line 709
    while (client_node) {
#line 710
      client = (client_t *)client_node->key;
#line 712
      send_to_listener(source, client, remove_from_q);
#line 714
      if ((client->con)->error) {
#line 715
        client_node = avl_get_next(client_node);
#line 716
        avl_delete(source->client_tree, (void *)client, & _free_client);
#line 717
        source->listeners = source->listeners - 1UL;
#line 718
        log_write(errorlog, 4U, "source/", "source_main", "Client removed");
#line 719
        continue;
      }
#line 721
      client_node = avl_get_next(client_node);
    }
#line 725
    avl_tree_wlock(source->pending_tree);
#line 728
    client_node = avl_get_first(source->pending_tree);
#line 729
    while (client_node) {
#line 731
      if (source->max_listeners != -1L) {
#line 731
        if (source->listeners >= (unsigned long )source->max_listeners) {
#line 739
          client = (client_t *)client_node->key;
#line 740
          client_node = avl_get_next(client_node);
#line 741
          avl_delete(source->pending_tree, (void *)client, & _free_client);
#line 743
          log_write(errorlog, 3U, "source/", "source_main", "Client deleted, exceeding maximum listeners for this mountpoint.");
#line 745
          continue;
        }
      }
#line 749
      avl_insert(source->client_tree, client_node->key);
#line 751
      source->listeners = source->listeners + 1UL;
#line 752
      log_write(errorlog, 4U, "source/", "source_main", "Client added");
#line 753
      stats_event_inc((char const   *)source->mount, "connections");
#line 755
      client_node = avl_get_next(client_node);
    }
#line 759
    while (1) {
#line 759
      tmp___0 = avl_get_first(source->pending_tree);
#line 759
      if (! tmp___0) {
#line 759
        break;
      }
#line 760
      tmp = avl_get_first(source->pending_tree);
#line 760
      avl_delete(source->pending_tree, tmp->key, & source_remove_client);
    }
#line 766
    avl_tree_unlock(source->pending_tree);
#line 769
    if (source->listeners != (unsigned long )listeners) {
#line 771
      log_write(errorlog, 3U, "source/", "source_main", "listener count on %s now %lu",
                source->mount, source->listeners);
#line 772
      if (source->listeners > source->peak_listeners) {
#line 774
        source->peak_listeners = source->listeners;
#line 775
        stats_event_args((char const   *)source->mount, (char *)"listener_peak", (char *)"%lu",
                         source->peak_listeners);
      }
#line 777
      stats_event_args((char const   *)source->mount, (char *)"listeners", (char *)"%lu",
                       source->listeners);
#line 778
      if (source->listeners == 0UL) {
#line 778
        if (source->on_demand) {
#line 779
          source->running = 0;
        }
      }
    }
#line 785
    if (source->stream_data) {
#line 790
      while ((source->stream_data)->_count == 1UL) {
#line 792
        to_go = source->stream_data;
#line 794
        if ((unsigned int )to_go->next == (unsigned int )((void *)0)) {
#line 797
          log_write(errorlog, 1U, "source/", "source_main", "queue state is unexpected");
#line 798
          source->running = 0;
#line 799
          break;
        } else {
#line 794
          if ((unsigned int )source->burst_point == (unsigned int )to_go) {
#line 797
            log_write(errorlog, 1U, "source/", "source_main", "queue state is unexpected");
#line 798
            source->running = 0;
#line 799
            break;
          }
        }
#line 801
        source->stream_data = to_go->next;
#line 802
        source->queue_size = (unsigned int )((unsigned long )source->queue_size -
                                             to_go->len);
#line 803
        refbuf_release(to_go);
      }
    }
#line 808
    avl_tree_unlock(source->client_tree);

    thread_check_in();
    __DSU_update("");

  }
  thread_deregister("source_main");

#line 810
  source_shutdown(source);
#line 811
  return;
}
}
#line 814 "source.c"
static void source_shutdown(source_t *source ) 
{ mount_proxy *mountinfo ;
  ice_config_t *tmp ;
  source_t *fallback_source ;

  {
#line 818
  source->running = 0;
#line 819
  log_write(errorlog, 3U, "source/", "source_shutdown", "Source \"%s\" exiting", source->mount);
#line 821
  tmp = config_get_config();
#line 821
  mountinfo = config_find_mount(tmp, (char const   *)source->mount);
#line 822
  if (mountinfo) {
#line 824
    if (mountinfo->on_disconnect) {
#line 825
      source_run_script(mountinfo->on_disconnect, source->mount);
    }
#line 826
    auth_stream_end(mountinfo, (char const   *)source->mount);
  }
#line 828
  config_release_config();
#line 833
  if (source->fallback_mount) {
#line 837
    avl_tree_rlock(global.source_tree);
#line 838
    fallback_source = source_find_mount((char const   *)source->fallback_mount);
#line 840
    if ((unsigned int )fallback_source != (unsigned int )((void *)0)) {
#line 841
      source_move_clients(source, fallback_source);
    }
#line 843
    avl_tree_unlock(global.source_tree);
  }
#line 847
  stats_event((char const   *)source->mount, (char const   *)((void *)0), (char const   *)((void *)0));
#line 851
  source_clear_source(source);
#line 853
  global_lock();
#line 854
  global.sources = global.sources - 1;
#line 855
  stats_event_args((char const   *)((void *)0), (char *)"sources", (char *)"%d", global.sources);
#line 856
  global_unlock();
#line 859
  thread_rwlock_unlock_c(source->shutdown_rwlock, 859, (char *)"source.c");
#line 860
  return;
}
}
#line 863 "source.c"
static int _compare_clients(void *compare_arg , void *a , void *b ) 
{ client_t *clienta ;
  client_t *clientb ;
  connection_t *cona ;
  connection_t *conb ;

  {
#line 865
  clienta = (client_t *)a;
#line 866
  clientb = (client_t *)b;
#line 868
  cona = clienta->con;
#line 869
  conb = clientb->con;
#line 871
  if (cona->id < conb->id) {
#line 871
    return (-1);
  }
#line 872
  if (cona->id > conb->id) {
#line 872
    return (1);
  }
#line 874
  return (0);
}
}
#line 877 "source.c"
int source_remove_client(void *key ) 
{ 

  {
#line 879
  return (1);
}
}
#line 882 "source.c"
static int _free_client(void *key ) 
{ client_t *client ;

  {
#line 884
  client = (client_t *)key;
#line 887
  if (client->respcode == 0) {
#line 888
    client_send_404(client, (char *)"Mount unavailable");
  } else {
#line 890
    client_destroy(client);
  }
#line 892
  return (1);
}
}
#line 895 "source.c"
static void _parse_audio_info(source_t *source , char const   *s ) 
{ char const   *start ;
  unsigned int len ;
  char name[100] ;
  char value[200] ;
  char *esc ;

  {
#line 897
  start = s;
#line 900
  while (1) {
#line 900
    if ((unsigned int )start != (unsigned int )((void *)0)) {
#line 900
      if (! ((int const   )(*start) != 0)) {
#line 900
        break;
      }
    } else {
#line 900
      break;
    }
#line 902
    s = (char const   *)__builtin_strchr((char *)start, (char )';');
#line 902
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 903
      len = strlen(start);
    } else {
#line 906
      len = (unsigned int )(s - start);
#line 907
      s ++;
    }
#line 909
    if (len) {
#line 914
      sscanf((char const   * __restrict  )start, (char const   * __restrict  )"%99[^=]=%199[^;\r\n]",
             name, value);
#line 915
      esc = util_url_unescape(value);
#line 916
      if (esc) {
#line 918
        util_dict_set(source->audio_info, (char const   *)(name), (char const   *)esc);
#line 919
        stats_event((char const   *)source->mount, (char const   *)(name), (char const   *)esc);
#line 920
        free((void *)esc);
      }
    }
#line 923
    start = s;
  }
#line 925
  return;
}
}
#line 929 "source.c"
static void source_apply_mount(source_t *source , mount_proxy *mountinfo ) 
{ char *str ;
  int val ;
  http_parser_t *parser ;
  char *mount ;
  char *tmp___8 ;
  char *filename ;
  char *tmp___18 ;
  ice_config_t *config ;
  ice_config_t *tmp___19 ;
  unsigned int len ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *path ;
  char *tmp___22 ;
  FILE *f ;
  int *tmp___23 ;
  char *tmp___24 ;

  {
#line 933
  parser = (http_parser_t *)((void *)0);
#line 935
  log_write(errorlog, 4U, "source/", "source_apply_mount", "Applying mount information for \"%s\"",
            source->mount);
#line 936
  if (mountinfo) {
#line 938
    source->max_listeners = (long )mountinfo->max_listeners;
#line 939
    source->fallback_override = mountinfo->fallback_override;
#line 940
    source->hidden = mountinfo->hidden;
  }
#line 946
  if (source->client) {
#line 947
    parser = (source->client)->parser;
  }
#line 950
  if (mountinfo) {
#line 950
    if (mountinfo->yp_public >= 0) {
#line 951
      val = mountinfo->yp_public;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 954
    while (1) {
#line 955
      str = httpp_getvar(parser, "ice-public");
#line 956
      if (str) {
#line 956
        break;
      }
#line 957
      str = httpp_getvar(parser, "icy-pub");
#line 958
      if (str) {
#line 958
        break;
      }
#line 959
      str = httpp_getvar(parser, "x-audiocast-public");
#line 960
      if (str) {
#line 960
        break;
      }
#line 962
      str = httpp_getvar(parser, "icy-public");
#line 963
      if (str) {
#line 963
        break;
      }
#line 964
      str = (char *)"0";
#line 954
      break;
    }
#line 966
    val = atoi__extinline((char const   *)str);
  }
#line 968
  stats_event_args((char const   *)source->mount, (char *)"public", (char *)"%d",
                   val);
#line 969
  if (source->yp_public != val) {
#line 971
    log_write(errorlog, 4U, "source/", "source_apply_mount", "YP changed to %d", val);
#line 972
    if (val) {
#line 973
      yp_add((char const   *)source->mount);
    } else {
#line 975
      yp_remove((char const   *)source->mount);
    }
#line 976
    source->yp_public = val;
  }
#line 980
  if (mountinfo) {
#line 980
    if (mountinfo->stream_name) {
#line 981
      str = mountinfo->stream_name;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 984
    while (1) {
#line 985
      str = httpp_getvar(parser, "ice-name");
#line 986
      if (str) {
#line 986
        break;
      }
#line 987
      str = httpp_getvar(parser, "icy-name");
#line 988
      if (str) {
#line 988
        break;
      }
#line 989
      str = httpp_getvar(parser, "x-audiocast-name");
#line 990
      if (str) {
#line 990
        break;
      }
#line 991
      str = (char *)"Unspecified name";
#line 984
      break;
    }
  }
#line 994
  stats_event((char const   *)source->mount, "server_name", (char const   *)str);
#line 997
  if (mountinfo) {
#line 997
    if (mountinfo->stream_description) {
#line 998
      str = mountinfo->stream_description;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1001
    while (1) {
#line 1002
      str = httpp_getvar(parser, "ice-description");
#line 1003
      if (str) {
#line 1003
        break;
      }
#line 1004
      str = httpp_getvar(parser, "icy-description");
#line 1005
      if (str) {
#line 1005
        break;
      }
#line 1006
      str = httpp_getvar(parser, "x-audiocast-description");
#line 1007
      if (str) {
#line 1007
        break;
      }
#line 1008
      str = (char *)"Unspecified description";
#line 1001
      break;
    }
  }
#line 1011
  stats_event((char const   *)source->mount, "server_description", (char const   *)str);
#line 1014
  if (mountinfo) {
#line 1014
    if (mountinfo->stream_url) {
#line 1015
      str = mountinfo->stream_url;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1018
    while (1) {
#line 1019
      str = httpp_getvar(parser, "ice-url");
#line 1020
      if (str) {
#line 1020
        break;
      }
#line 1021
      str = httpp_getvar(parser, "icy-url");
#line 1022
      if (str) {
#line 1022
        break;
      }
#line 1023
      str = httpp_getvar(parser, "x-audiocast-url");
#line 1024
      if (str) {
#line 1024
        break;
      }
#line 1018
      break;
    }
  }
#line 1027
  stats_event((char const   *)source->mount, "server_url", (char const   *)str);
#line 1030
  if (mountinfo) {
#line 1030
    if (mountinfo->stream_genre) {
#line 1031
      str = mountinfo->stream_genre;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 1034
    while (1) {
#line 1035
      str = httpp_getvar(parser, "ice-genre");
#line 1036
      if (str) {
#line 1036
        break;
      }
#line 1037
      str = httpp_getvar(parser, "icy-genre");
#line 1038
      if (str) {
#line 1038
        break;
      }
#line 1039
      str = httpp_getvar(parser, "x-audiocast-genre");
#line 1040
      if (str) {
#line 1040
        break;
      }
#line 1041
      str = (char *)"various";
#line 1034
      break;
    }
  }
#line 1044
  stats_event((char const   *)source->mount, "genre", (char const   *)str);
#line 1047
  if (mountinfo) {
#line 1047
    if (mountinfo->bitrate) {
#line 1048
      str = mountinfo->bitrate;
    } else {
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
#line 1051
    while (1) {
#line 1052
      str = httpp_getvar(parser, "ice-bitrate");
#line 1053
      if (str) {
#line 1053
        break;
      }
#line 1054
      str = httpp_getvar(parser, "icy-br");
#line 1055
      if (str) {
#line 1055
        break;
      }
#line 1056
      str = httpp_getvar(parser, "x-audiocast-bitrate");
#line 1051
      break;
    }
  }
#line 1059
  stats_event((char const   *)source->mount, "bitrate", (char const   *)str);
#line 1062
  if (mountinfo) {
#line 1062
    if (mountinfo->type) {
#line 1063
      stats_event((char const   *)source->mount, "server_type", (char const   *)mountinfo->type);
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 1065
    if (source->format) {
#line 1066
      stats_event((char const   *)source->mount, "server_type", (char const   *)(source->format)->contenttype);
    }
  }
#line 1068
  if (mountinfo) {
#line 1068
    if (mountinfo->subtype) {
#line 1069
      stats_event((char const   *)source->mount, "subtype", (char const   *)mountinfo->subtype);
    }
  }
#line 1071
  if (mountinfo) {
#line 1071
    if (mountinfo->auth) {
#line 1072
      stats_event((char const   *)source->mount, "authenticator", (char const   *)(mountinfo->auth)->type);
    } else {
#line 1074
      stats_event((char const   *)source->mount, "authenticator", (char const   *)((void *)0));
    }
  } else {
#line 1074
    stats_event((char const   *)source->mount, "authenticator", (char const   *)((void *)0));
  }
#line 1076
  if (mountinfo) {
#line 1076
    if (mountinfo->fallback_mount) {
#line 1078
      mount = source->fallback_mount;
#line 1079
      tmp___8 = __strdup((char const   *)mountinfo->fallback_mount);
#line 1079
      source->fallback_mount = tmp___8;
#line 1080
      free((void *)mount);
    } else {
#line 1083
      source->fallback_mount = (char *)((void *)0);
    }
  } else {
#line 1083
    source->fallback_mount = (char *)((void *)0);
  }
#line 1085
  if (mountinfo) {
#line 1085
    if (mountinfo->dumpfile) {
#line 1087
      filename = source->dumpfilename;
#line 1088
      tmp___18 = __strdup((char const   *)mountinfo->dumpfile);
#line 1088
      source->dumpfilename = tmp___18;
#line 1089
      free((void *)filename);
    } else {
#line 1092
      source->dumpfilename = (char *)((void *)0);
    }
  } else {
#line 1092
    source->dumpfilename = (char *)((void *)0);
  }
#line 1094
  if (source->intro_file) {
#line 1096
    fclose(source->intro_file);
#line 1097
    source->intro_file = (FILE *)((void *)0);
  }
#line 1099
  if (mountinfo) {
#line 1099
    if (mountinfo->intro_filename) {
#line 1101
      tmp___19 = config_get_config_unlocked();
#line 1101
      config = tmp___19;
#line 1102
      tmp___20 = strlen((char const   *)config->webroot_dir);
#line 1102
      tmp___21 = strlen((char const   *)mountinfo->intro_filename);
#line 1102
      len = (tmp___20 + tmp___21) + 2U;
#line 1104
      tmp___22 = (char *)malloc(len);
#line 1104
      path = tmp___22;
#line 1105
      if (path) {
#line 1108
        snprintf((char * __restrict  )path, len, (char const   * __restrict  )"%s/%s",
                 config->webroot_dir, mountinfo->intro_filename);
#line 1111
        f = fopen((char const   * __restrict  )path, (char const   * __restrict  )"rb");
#line 1112
        if (f) {
#line 1113
          source->intro_file = f;
        } else {
#line 1115
          tmp___23 = __errno_location();
#line 1115
          tmp___24 = strerror((*tmp___23));
#line 1115
          log_write(errorlog, 2U, "source/", "source_apply_mount", "Cannot open intro file \"%s\": %s",
                    path, tmp___24);
        }
#line 1116
        free((void *)path);
      }
    }
  }
#line 1120
  if (mountinfo) {
#line 1120
    if (mountinfo->queue_size_limit) {
#line 1121
      source->queue_size_limit = mountinfo->queue_size_limit;
    }
  }
#line 1123
  if (mountinfo) {
#line 1123
    if (mountinfo->source_timeout) {
#line 1124
      source->timeout = mountinfo->source_timeout;
    }
  }
#line 1126
  if (mountinfo) {
#line 1126
    if (mountinfo->burst_size >= 0) {
#line 1127
      source->burst_size = (unsigned int )mountinfo->burst_size;
    }
  }
#line 1129
  if (mountinfo) {
#line 1129
    if (mountinfo->fallback_when_full) {
#line 1130
      source->fallback_when_full = mountinfo->fallback_when_full;
    }
  }
#line 1132
  if (source->format) {
#line 1132
    if ((source->format)->apply_settings) {
#line 1133
      ((*((source->format)->apply_settings)))(source->client, source->format, mountinfo);
    }
  }
#line 1134
  return;
}
}
#line 1140 "source.c"
void source_update_settings(ice_config_t *config , source_t *source , mount_proxy *mountinfo ) 
{ char buf[10] ;

  {
#line 1143
  if (source->running) {
#line 1143
    if ((unsigned int )source->client == (unsigned int )((void *)0)) {
#line 1145
      stats_event_hidden((char const   *)source->mount, (char const   *)((void *)0),
                         1);
#line 1146
      return;
    }
  }
#line 1149
  source->queue_size_limit = config->queue_size_limit;
#line 1150
  source->timeout = (unsigned int )config->source_timeout;
#line 1151
  source->burst_size = config->burst_size;
#line 1153
  source_apply_mount(source, mountinfo);
#line 1155
  if (source->fallback_mount) {
#line 1156
    log_write(errorlog, 4U, "source/", "source_update_settings", "fallback %s", source->fallback_mount);
  }
#line 1157
  if (mountinfo) {
#line 1157
    if (mountinfo->intro_filename) {
#line 1158
      log_write(errorlog, 4U, "source/", "source_update_settings", "intro file is %s",
                mountinfo->intro_filename);
    }
  }
#line 1159
  if (source->dumpfilename) {
#line 1160
    log_write(errorlog, 4U, "source/", "source_update_settings", "Dumping stream to %s",
              source->dumpfilename);
  }
#line 1161
  if (mountinfo) {
#line 1161
    if (mountinfo->on_connect) {
#line 1162
      log_write(errorlog, 4U, "source/", "source_update_settings", "connect script \"%s\"",
                mountinfo->on_connect);
    }
  }
#line 1163
  if (mountinfo) {
#line 1163
    if (mountinfo->on_disconnect) {
#line 1164
      log_write(errorlog, 4U, "source/", "source_update_settings", "disconnect script \"%s\"",
                mountinfo->on_disconnect);
    }
  }
#line 1165
  if (source->on_demand) {
#line 1167
    log_write(errorlog, 4U, "source/", "source_update_settings", "on_demand set");
#line 1168
    stats_event((char const   *)source->mount, "on_demand", "1");
  } else {
#line 1171
    stats_event((char const   *)source->mount, "on_demand", (char const   *)((void *)0));
  }
#line 1173
  if (source->hidden) {
#line 1175
    stats_event_hidden((char const   *)source->mount, (char const   *)((void *)0),
                       1);
#line 1176
    log_write(errorlog, 4U, "source/", "source_update_settings", "hidden from xsl");
  } else {
#line 1179
    stats_event_hidden((char const   *)source->mount, (char const   *)((void *)0),
                       0);
  }
#line 1181
  if (source->max_listeners == -1L) {
#line 1182
    stats_event((char const   *)source->mount, "max_listeners", "unlimited");
  } else {
#line 1186
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%ld",
             source->max_listeners);
#line 1187
    stats_event((char const   *)source->mount, "max_listeners", (char const   *)(buf));
  }
#line 1189
  log_write(errorlog, 4U, "source/", "source_update_settings", "public set to %d",
            source->yp_public);
#line 1190
  log_write(errorlog, 4U, "source/", "source_update_settings", "max listeners to %ld",
            source->max_listeners);
#line 1191
  log_write(errorlog, 4U, "source/", "source_update_settings", "queue size to %u",
            source->queue_size_limit);
#line 1192
  log_write(errorlog, 4U, "source/", "source_update_settings", "burst size to %u",
            source->burst_size);
#line 1193
  log_write(errorlog, 4U, "source/", "source_update_settings", "source timeout to %u",
            source->timeout);
#line 1194
  log_write(errorlog, 4U, "source/", "source_update_settings", "fallback_when_full to %u",
            source->fallback_when_full);
#line 1195
  return;
}
}
#line 1198 "source.c"
void *source_client_thread(void *arg ) 
{ source_t *source ;

  {
#line 1200
  source = (source_t *)arg;
#line 1202
  stats_event_inc((char const   *)((void *)0), "source_client_connections");
#line 1203
  stats_event((char const   *)source->mount, "listeners", "0");
#line 1205
  source_main(source);
#line 1207
  source_free_source(source);
#line 1208
  source_recheck_mounts();
#line 1210
  return ((void *)0);
}
}
#line 1214 "source.c"
void source_client_callback(client_t *client , void *arg ) 
{ char const   *agent ;
  source_t *source ;
  refbuf_t *old_data ;

  {
#line 1217
  source = (source_t *)arg;
#line 1218
  old_data = client->refbuf;
#line 1220
  if ((client->con)->error) {
#line 1222
    global_lock();
#line 1223
    global.sources = global.sources - 1;
#line 1224
    global_unlock();
#line 1225
    source_clear_source(source);
#line 1226
    source_free_source(source);
#line 1227
    return;
  }
#line 1229
  client->refbuf = old_data->associated;
#line 1230
  old_data->associated = (struct _refbuf_tag *)((void *)0);
#line 1231
  refbuf_release(old_data);
#line 1232
  stats_event((char const   *)source->mount, "source_ip", (char const   *)((source->client)->con)->ip);
#line 1233
  agent = (char const   *)httpp_getvar((source->client)->parser, "user-agent");
#line 1234
  if (agent) {
#line 1235
    stats_event((char const   *)source->mount, "user_agent", agent);
  }
#line 1237
  thread_create_c((char *)"Source Thread", & source_client_thread, (void *)source,
                  1, 1238, (char *)"source.c");
#line 1239
  return;
}
}
#line 1243 "source.c"
static void source_run_script(char *command , char *mountpoint ) 
{ pid_t pid ;
  pid_t external_pid ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 1248
  external_pid = fork();
#line 1249
  switch (external_pid) {
  case 0: 
#line 1252
  pid = fork();
#line 1252
  switch (pid) {
  case -1: 
#line 1255
  tmp = __errno_location();
#line 1255
  tmp___0 = strerror((*tmp));
#line 1255
  log_write(errorlog, 1U, "source/", "source_run_script", "Unable to fork %s (%s)",
            command, tmp___0);
#line 1256
  break;
  case 0: 
#line 1258
  log_write(errorlog, 4U, "source/", "source_run_script", "Starting command %s", command);
#line 1259
  execl((char const   *)command, (char const   *)command, mountpoint, (char *)((void *)0));
#line 1260
  tmp___1 = __errno_location();
#line 1260
  tmp___2 = strerror((*tmp___1));
#line 1260
  log_write(errorlog, 1U, "source/", "source_run_script", "Unable to run command %s (%s)",
            command, tmp___2);
#line 1261
  exit(0);
  default: ;
#line 1263
  break;
  }
#line 1265
  exit(0);
  case -1: 
#line 1267
  tmp___3 = __errno_location();
#line 1267
  tmp___4 = strerror((*tmp___3));
#line 1267
  log_write(errorlog, 1U, "source/", "source_run_script", "Unable to fork %s", tmp___4);
#line 1268
  break;
  default: 
#line 1270
  waitpid(external_pid, (int *)((void *)0), 0);
#line 1271
  break;
  }
#line 1273
  return;
}
}
#line 1277 "source.c"
static void *source_fallback_file(void *arg ) 
{ char *mount ;
  char *type ;
  char *path ;
  unsigned int len ;
  FILE *file ;
  source_t *source ;
  ice_config_t *config ;
  http_parser_t *parser ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 1279
  mount = (char *)arg;
#line 1283
  file = (FILE *)((void *)0);
#line 1284
  source = (source_t *)((void *)0);

  ///thread_register("source_fallback_file");
  ///thread_check_in();

#line 1288
  LOOP_SOURCE_FALLBACK_FILE:while (1) {
#line 1290
    if ((unsigned int )mount == (unsigned int )((void *)0)) {
#line 1291
      break;
    } else {
#line 1290
      if ((int )(*(mount + 0)) != 47) {
#line 1291
        break;
      }
    }
#line 1292
    config = config_get_config();
#line 1293
    tmp = strlen((char const   *)config->webroot_dir);
#line 1293
    tmp___0 = strlen((char const   *)mount);
#line 1293
    len = (tmp + tmp___0) + 1U;
#line 1294
    path = (char *)malloc(len);
#line 1295
    if (path) {
#line 1296
      snprintf((char * __restrict  )path, len, (char const   * __restrict  )"%s%s",
               config->webroot_dir, mount);
    }
#line 1298
    config_release_config();
#line 1299
    if ((unsigned int )path == (unsigned int )((void *)0)) {
#line 1300
      break;
    }
#line 1302
    file = fopen((char const   * __restrict  )path, (char const   * __restrict  )"rb");
#line 1303
    if ((unsigned int )file == (unsigned int )((void *)0)) {
#line 1305
      log_write(errorlog, 4U, "source/", "source_fallback_file", "unable to open file \"%s\"",
                path);
#line 1306
      free((void *)path);
#line 1307
      break;
    }
#line 1309
    free((void *)path);
#line 1310
    source = source_reserve((char const   *)mount);
#line 1311
    if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 1313
      log_write(errorlog, 4U, "source/", "source_fallback_file", "mountpoint \"%s\" already reserved",
                mount);
#line 1314
      break;
    }
#line 1316
    type = fserve_content_type((char const   *)mount);
#line 1317
    parser = httpp_create_parser();
#line 1318
    httpp_initialize(parser, (http_varlist_t *)((void *)0));
#line 1319
    httpp_setvar(parser, "content-type", (char const   *)type);
#line 1321
    source->hidden = 1;
#line 1322
    source->yp_public = 0;
#line 1323
    source->intro_file = file;
#line 1324
    source->parser = parser;
#line 1325
    file = (FILE *)((void *)0);
#line 1327
    tmp___1 = connection_complete_source(source, 0);
#line 1327
    if (tmp___1 < 0) {
#line 1328
      break;
    }
#line 1329
    source_client_thread((void *)source);
#line 1330
    httpp_destroy(parser);
#line 1288
    break;
  }

  ///thread_deregister("source_fallback_file");
#line 1332
  if (file) {
#line 1333
    fclose(file);
  }
#line 1334
  free((void *)mount);
#line 1335
  return ((void *)0);
}
}
#line 1342 "source.c"
void source_recheck_mounts(void) 
{ ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mount ;
  source_t *source ;
  source_t *tmp___0 ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___1 ;
  source_t *fallback ;
  source_t *tmp___2 ;
  char *tmp___12 ;

  {
#line 1344
  tmp = config_get_config();
#line 1344
  config = tmp;
#line 1345
  mount = config->mounts;
#line 1347
  avl_tree_rlock(global.source_tree);
#line 1349
  while (mount) {
#line 1351
    tmp___0 = source_find_mount((char const   *)mount->mountname);
#line 1351
    source = tmp___0;
#line 1353
    if (source) {
#line 1355
      source = source_find_mount_raw((char const   *)mount->mountname);
#line 1356
      if (source) {
#line 1358
        tmp___1 = config_find_mount(config, (char const   *)source->mount);
#line 1358
        mountinfo = tmp___1;
#line 1359
        source_update_settings(config, source, mountinfo);
      } else {
#line 1363
        stats_event_hidden((char const   *)mount->mountname, (char const   *)((void *)0),
                           mount->hidden);
#line 1364
        stats_event((char const   *)mount->mountname, "listeners", "0");
#line 1365
        if (mount->max_listeners < 0) {
#line 1366
          stats_event((char const   *)mount->mountname, "max_listeners", "unlimited");
        } else {
#line 1368
          stats_event_args((char const   *)mount->mountname, (char *)"max_listeners",
                           (char *)"%d", mount->max_listeners);
        }
      }
    } else {
#line 1372
      stats_event((char const   *)mount->mountname, (char const   *)((void *)0), (char const   *)((void *)0));
    }
#line 1375
    if (global.running == 1) {
#line 1375
      if (mount->fallback_mount) {
#line 1377
        tmp___2 = source_find_mount((char const   *)mount->fallback_mount);
#line 1377
        fallback = tmp___2;
#line 1378
        if ((unsigned int )fallback == (unsigned int )((void *)0)) {
#line 1380
          tmp___12 = __strdup((char const   *)mount->fallback_mount);
#line 1380
          thread_create_c((char *)"Fallback file thread", & source_fallback_file,
                          (void *)tmp___12, 1, 1381, (char *)"source.c");
        }
      }
    }
#line 1385
    mount = mount->next;
  }
#line 1387
  avl_tree_unlock(global.source_tree);
#line 1388
  config_release_config();
#line 1389
  return;
}
}
#line 1 "cil-kMf1FKxs.o"
#pragma merger(0,"/tmp/cil-DFRtUTZ1.i","")
#line 1 "./src/stats.o_saved.c"
#pragma merger(0,"./stats.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 654 "/usr/include/libxml2/libxml/tree.h"
extern xmlDocPtr xmlNewDoc(xmlChar const   *version ) ;
#line 701
extern xmlNodePtr xmlNewDocNode(xmlDocPtr doc , xmlNsPtr ns , xmlChar const   *name ,
                                xmlChar const   *content ) ;
#line 718
extern xmlNodePtr xmlNewChild(xmlNodePtr parent , xmlNsPtr ns , xmlChar const   *name ,
                              xmlChar const   *content ) ;
#line 807
extern xmlNodePtr xmlDocSetRootElement(xmlDocPtr doc , xmlNodePtr root ) ;
#line 887
extern xmlAttrPtr xmlSetProp(xmlNodePtr node , xmlChar const   *name , xmlChar const   *value ) ;
#line 1028
extern void xmlDocDumpMemory(xmlDocPtr cur , xmlChar **mem , int *size ) ;
#line 107 "/usr/include/libxml2/libxml/entities.h"
extern xmlChar *xmlEncodeEntitiesReentrant(xmlDocPtr doc , xmlChar const   *input ) ;
#line 77 "client.h"
int client_send_bytes(client_t *client , void const   *buf , unsigned int len ) ;
#line 76 "stats.h"
stats_t *stats_get_stats(void) ;
#line 81
void stats_event_add(char const   *source , char const   *name , unsigned long value ) ;
#line 82
void stats_event_dec(char const   *source , char const   *name ) ;
#line 86
void *stats_connection(void *arg ) ;
#line 90
void stats_sendxml(client_t *client ) ;
#line 91
void stats_get_xml(xmlDocPtr *doc , int show_hidden ) ;
#line 92
char *stats_get_value(char *source , char *name ) ;
#line 37 "xslt.h"
void xslt_transform(xmlDocPtr doc , char const   *xslfilename , client_t *client ) ;
#line 70 "stats.c"
static int volatile   _stats_running  =    (int volatile   )0;
#line 71 "stats.c"
static thread_type *_stats_thread_id  ;
#line 72 "stats.c"
static int volatile   _stats_threads  =    (int volatile   )0;
#line 74 "stats.c"
static stats_t _stats  ;
#line 75 "stats.c"
static mutex_t _stats_mutex  ;
#line 77 "stats.c"
static event_queue_t _global_event_queue  ;
#line 78 "stats.c"
mutex_t _global_event_mutex  ;
#line 80 "stats.c"
static event_listener_t volatile   *_event_listeners  ;
#line 83
static void *_stats_thread(void *arg ) ;
#line 84
static int _compare_stats(void *arg , void *a , void *b ) ;
#line 85
static int _compare_source_stats(void *arg , void *a , void *b ) ;
#line 86
static int _free_stats(void *key ) ;
#line 87
static int _free_source_stats(void *key ) ;
#line 88
static void _add_event_to_queue(stats_event_t *event , event_queue_t *queue ) ;
#line 89
static stats_node_t *_find_node(avl_tree *stats_tree , char *name ) ;
#line 90
static stats_source_t *_find_source(avl_tree *source_tree , char *source ) ;
#line 91
static void _free_event(stats_event_t *event ) ;
#line 92
static stats_event_t *_get_event_from_queue(event_queue_t *queue ) ;
#line 96 "stats.c"
static stats_event_t *build_event(char const   *source , char const   *name , char const   *value ) 
{ stats_event_t *event ;
  char *tmp___9 ;
  char *tmp___19 ;
  char *tmp___29 ;

  {
#line 100
  event = (stats_event_t *)calloc(1U, sizeof(stats_event_t ));
#line 101
  if (event) {
#line 103
    if (source) {
#line 104
      tmp___9 = __strdup(source);
#line 104
      event->source = tmp___9;
    }
#line 105
    if (name) {
#line 106
      tmp___19 = __strdup(name);
#line 106
      event->name = tmp___19;
    }
#line 107
    if (value) {
#line 108
      tmp___29 = __strdup(value);
#line 108
      event->value = tmp___29;
    } else {
#line 110
      event->action = 4;
    }
  }
#line 112
  return (event);
}
}
#line 115 "stats.c"
static void queue_global_event(stats_event_t *event ) 
{ 

  {
#line 117
  thread_mutex_lock_c(& _global_event_mutex, 117, (char *)"stats.c");
#line 118
  _add_event_to_queue(event, & _global_event_queue);
#line 119
  thread_mutex_unlock_c(& _global_event_mutex, 119, (char *)"stats.c");
#line 120
  return;
}
}
#line 122 "stats.c"
void stats_initialize(void) 
{ 

  {
#line 124
  _event_listeners = (event_listener_t volatile   *)((void *)0);
#line 127
  _stats.global_tree = avl_tree_new(& _compare_stats, (void *)0);
#line 128
  _stats.source_tree = avl_tree_new(& _compare_source_stats, (void *)0);
#line 131
  thread_mutex_create_c(& _stats_mutex, 131, (char *)"stats.c");
#line 134
  _global_event_queue.head = (stats_event_t volatile   *)((void *)0);
#line 134
  _global_event_queue.tail = & _global_event_queue.head;
#line 135
  thread_mutex_create_c(& _global_event_mutex, 135, (char *)"stats.c");
#line 138
  _stats_running = (int volatile   )1;
#line 139
  _stats_thread_id = thread_create_c((char *)"Stats Thread", & _stats_thread, (void *)0,
                                     0, 139, (char *)"stats.c");
#line 140
  return;
}
}
#line 142 "stats.c"
void stats_shutdown(void) 
{ int n ;
  stats_event_t *event ;
  stats_event_t *tmp ;

  {
#line 146
  if (! _stats_running) {
#line 147
    return;
  }
#line 150
  _stats_running = (int volatile   )0;
#line 151
  thread_join(_stats_thread_id);
#line 154
  while (1) {
#line 155
    thread_sleep(300000UL);
#line 156
    thread_mutex_lock_c(& _stats_mutex, 156, (char *)"stats.c");
#line 157
    n = (int )_stats_threads;
#line 158
    thread_mutex_unlock_c(& _stats_mutex, 158, (char *)"stats.c");
#line 154
    if (! (n > 0)) {
#line 154
      break;
    }
  }
#line 160
  log_write(errorlog, 3U, "stats/", "stats_shutdown", "stats thread finished");
#line 165
  thread_mutex_destroy(& _global_event_mutex);
#line 167
  thread_mutex_destroy(& _stats_mutex);
#line 168
  avl_tree_free(_stats.source_tree, & _free_source_stats);
#line 169
  avl_tree_free(_stats.global_tree, & _free_stats);
#line 171
  while (1) {
#line 173
    tmp = _get_event_from_queue(& _global_event_queue);
#line 173
    event = tmp;
#line 174
    if ((unsigned int )event == (unsigned int )((void *)0)) {
#line 174
      break;
    }
#line 175
    if (event->source) {
#line 176
      free((void *)event->source);
    }
#line 177
    if (event->value) {
#line 178
      free((void *)event->value);
    }
#line 179
    if (event->name) {
#line 180
      free((void *)event->name);
    }
#line 181
    free((void *)event);
  }
#line 183
  return;
}
}
#line 185 "stats.c"
stats_t *stats_get_stats(void) 
{ 

  {
#line 195
  return ((stats_t *)((void *)0));
}
}
#line 199 "stats.c"
void stats_event(char const   *source , char const   *name , char const   *value ) 
{ stats_event_t *event ;

  {
#line 203
  event = build_event(source, name, value);
#line 204
  if (event) {
#line 205
    queue_global_event(event);
  }
#line 206
  return;
}
}
#line 210 "stats.c"
void stats_event_hidden(char const   *source , char const   *name , int hidden ) 
{ stats_event_t *event ;
  char const   *str ;

  {
#line 213
  str = (char const   *)((void *)0);
#line 215
  if (hidden) {
#line 216
    str = "";
  }
#line 217
  event = build_event(source, name, str);
#line 218
  if (event) {
#line 220
    event->action = 5;
#line 221
    queue_global_event(event);
  }
#line 223
  return;
}
}
#line 226 "stats.c"
void stats_event_args(char const   *source , char *name , char *format  , ...) 
{ char buf[1024] ;
  va_list val ;
  int ret ;
  char const   *tmp ;

  {
#line 232
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 233
    return;
  }
#line 234
  __builtin_va_start(val, format);
#line 235
  ret = vsnprintf((char * __restrict  )(buf), 1024U, (char const   * __restrict  )format,
                  val);
#line 236
  __builtin_va_end(val);
#line 238
  if (ret < 0) {
    goto _L;
  } else {
#line 238
    if ((unsigned int )ret >= sizeof(buf)) {
      _L: /* CIL Label */ 
#line 240
      if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 240
        tmp = "global";
      } else {
#line 240
        tmp = source;
      }
#line 240
      log_write(errorlog, 2U, "stats/", "stats_event_args", "problem with formatting %s stat %s",
                tmp, name);
#line 242
      return;
    }
  }
#line 244
  stats_event(source, (char const   *)name, (char const   *)(buf));
#line 245
  return;
}
}
#line 247 "stats.c"
static char *_get_stats(char *source , char *name ) 
{ stats_node_t *stats ;
  stats_source_t *src ;
  char *value ;
  char *tmp___8 ;

  {
#line 249
  stats = (stats_node_t *)((void *)0);
#line 250
  src = (stats_source_t *)((void *)0);
#line 251
  value = (char *)((void *)0);
#line 253
  thread_mutex_lock_c(& _stats_mutex, 253, (char *)"stats.c");
#line 255
  if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 256
    stats = _find_node(_stats.global_tree, name);
  } else {
#line 258
    src = _find_source(_stats.source_tree, source);
#line 259
    if (src) {
#line 260
      stats = _find_node(src->stats_tree, name);
    }
  }
#line 264
  if (stats) {
#line 264
    tmp___8 = __strdup((char const   *)stats->value);
#line 264
    value = tmp___8;
  }
#line 266
  thread_mutex_unlock_c(& _stats_mutex, 266, (char *)"stats.c");
#line 268
  return (value);
}
}
#line 271 "stats.c"
char *stats_get_value(char *source , char *name ) 
{ char *tmp ;

  {
#line 273
  tmp = _get_stats(source, name);
#line 273
  return (tmp);
}
}
#line 277 "stats.c"
void stats_event_inc(char const   *source , char const   *name ) 
{ stats_event_t *event ;
  stats_event_t *tmp ;

  {
#line 279
  tmp = build_event(source, name, (char const   *)((void *)0));
#line 279
  event = tmp;
#line 281
  if (event) {
#line 283
    event->action = 1;
#line 284
    queue_global_event(event);
  }
#line 286
  return;
}
}
#line 288 "stats.c"
void stats_event_add(char const   *source , char const   *name , unsigned long value ) 
{ stats_event_t *event ;
  stats_event_t *tmp ;

  {
#line 290
  tmp = build_event(source, name, (char const   *)((void *)0));
#line 290
  event = tmp;
#line 292
  if (event) {
#line 294
    event->value = (char *)malloc(16U);
#line 295
    snprintf((char * __restrict  )event->value, 16U, (char const   * __restrict  )"%ld",
             value);
#line 296
    event->action = 3;
#line 297
    queue_global_event(event);
  }
#line 299
  return;
}
}
#line 302 "stats.c"
void stats_event_dec(char const   *source , char const   *name ) 
{ stats_event_t *event ;
  stats_event_t *tmp ;

  {
#line 305
  tmp = build_event(source, name, (char const   *)((void *)0));
#line 305
  event = tmp;
#line 306
  if (event) {
#line 308
    event->action = 2;
#line 309
    queue_global_event(event);
  }
#line 311
  return;
}
}
#line 316 "stats.c"
static stats_node_t *_find_node(avl_tree *stats_tree , char *name ) 
{ stats_node_t *stats ;
  avl_node *node ;
  int cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 323
  node = (stats_tree->root)->right;
#line 325
  while (node) {
#line 326
    stats = (stats_node_t *)node->key;
#line 327
    if (0) {
#line 327
      __s1_len = strlen((char const   *)name);
#line 327
      __s2_len = strlen((char const   *)stats->name);
#line 327
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
             1U)) {
        goto _L___0;
      } else {
#line 327
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 327
          if (! ((unsigned int )((void const   *)(stats->name + 1)) - (unsigned int )((void const   *)stats->name) ==
                 1U)) {
#line 327
            tmp___8 = 1;
          } else {
#line 327
            if (__s2_len >= 4U) {
#line 327
              tmp___8 = 1;
            } else {
#line 327
              tmp___8 = 0;
            }
          }
        } else {
#line 327
          tmp___8 = 0;
        }
      }
#line 327
      if (tmp___8) {
#line 327
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)stats->name);
      } else {
#line 327
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)stats->name);
#line 327
        tmp___4 = tmp___7;
      }
    } else {
#line 327
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)stats->name);
#line 327
      tmp___4 = tmp___7;
    }
#line 327
    cmp = tmp___4;
#line 328
    if (cmp < 0) {
#line 329
      node = node->left;
    } else {
#line 330
      if (cmp > 0) {
#line 331
        node = node->right;
      } else {
#line 333
        return (stats);
      }
    }
  }
#line 337
  return ((stats_node_t *)((void *)0));
}
}
#line 343 "stats.c"
static stats_source_t *_find_source(avl_tree *source_tree , char *source ) 
{ stats_source_t *stats ;
  avl_node *node ;
  int cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 350
  node = (source_tree->root)->right;
#line 351
  while (node) {
#line 352
    stats = (stats_source_t *)node->key;
#line 353
    if (0) {
#line 353
      __s1_len = strlen((char const   *)source);
#line 353
      __s2_len = strlen((char const   *)stats->source);
#line 353
      if (! ((unsigned int )((void const   *)(source + 1)) - (unsigned int )((void const   *)source) ==
             1U)) {
        goto _L___0;
      } else {
#line 353
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 353
          if (! ((unsigned int )((void const   *)(stats->source + 1)) - (unsigned int )((void const   *)stats->source) ==
                 1U)) {
#line 353
            tmp___8 = 1;
          } else {
#line 353
            if (__s2_len >= 4U) {
#line 353
              tmp___8 = 1;
            } else {
#line 353
              tmp___8 = 0;
            }
          }
        } else {
#line 353
          tmp___8 = 0;
        }
      }
#line 353
      if (tmp___8) {
#line 353
        tmp___4 = __builtin_strcmp((char const   *)source, (char const   *)stats->source);
      } else {
#line 353
        tmp___7 = __builtin_strcmp((char const   *)source, (char const   *)stats->source);
#line 353
        tmp___4 = tmp___7;
      }
    } else {
#line 353
      tmp___7 = __builtin_strcmp((char const   *)source, (char const   *)stats->source);
#line 353
      tmp___4 = tmp___7;
    }
#line 353
    cmp = tmp___4;
#line 354
    if (cmp < 0) {
#line 355
      node = node->left;
    } else {
#line 356
      if (cmp > 0) {
#line 357
        node = node->right;
      } else {
#line 359
        return (stats);
      }
    }
  }
#line 363
  return ((stats_source_t *)((void *)0));
}
}
#line 366 "stats.c"
static stats_event_t *_copy_event(stats_event_t *event ) 
{ stats_event_t *copy ;
  stats_event_t *tmp ;
  char *tmp___9 ;
  char *tmp___19 ;
  char *tmp___29 ;

  {
#line 368
  tmp = (stats_event_t *)calloc(1U, sizeof(stats_event_t ));
#line 368
  copy = tmp;
#line 369
  if (event->source) {
#line 370
    tmp___9 = __strdup((char const   *)event->source);
#line 370
    copy->source = tmp___9;
  } else {
#line 372
    copy->source = (char *)((void *)0);
  }
#line 373
  if (event->name) {
#line 374
    tmp___19 = __strdup((char const   *)event->name);
#line 374
    copy->name = tmp___19;
  }
#line 375
  if (event->value) {
#line 376
    tmp___29 = __strdup((char const   *)event->value);
#line 376
    copy->value = tmp___29;
  } else {
#line 378
    copy->value = (char *)((void *)0);
  }
#line 379
  copy->hidden = event->hidden;
#line 380
  copy->next = (struct _stats_event_tag *)((void *)0);
#line 382
  return (copy);
}
}
#line 387 "stats.c"
static void modify_node_event(stats_node_t *node , stats_event_t *event ) 
{ char *str ;
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___12 ;
  char *tmp___22 ;

  {
#line 391
  if (event->action == 5) {
#line 393
    if (event->value) {
#line 394
      node->hidden = 1;
    } else {
#line 396
      node->hidden = 0;
    }
#line 397
    return;
  }
#line 399
  if (event->action != 0) {
#line 401
    value = 0;
#line 403
    switch (event->action) {
    case 1: 
#line 406
    tmp = atoi__extinline((char const   *)node->value);
#line 406
    value = tmp + 1;
#line 407
    break;
    case 2: 
#line 409
    tmp___0 = atoi__extinline((char const   *)node->value);
#line 409
    value = tmp___0 - 1;
#line 410
    break;
    case 3: 
#line 412
    tmp___1 = atoi__extinline((char const   *)node->value);
#line 412
    tmp___2 = atoi__extinline((char const   *)event->value);
#line 412
    value = tmp___1 + tmp___2;
#line 413
    break;
    default: ;
#line 415
    break;
    }
#line 417
    str = (char *)malloc(16U);
#line 418
    snprintf((char * __restrict  )str, 16U, (char const   * __restrict  )"%d", value);
#line 419
    if ((unsigned int )event->value == (unsigned int )((void *)0)) {
#line 420
      tmp___12 = __strdup((char const   *)str);
#line 420
      event->value = tmp___12;
    }
  } else {
#line 423
    tmp___22 = __strdup((char const   *)event->value);
#line 423
    str = tmp___22;
  }
#line 424
  free((void *)node->value);
#line 425
  node->value = str;
#line 426
  log_write(errorlog, 4U, "stats/", "modify_node_event", "update node %s (%s)", node->name,
            node->value);
#line 427
  return;
}
}
#line 430 "stats.c"
static void process_global_event(stats_event_t *event ) 
{ stats_node_t *node ;
  char *tmp___9 ;
  char *tmp___19 ;

  {
#line 435
  if (event->action == 4) {
#line 438
    node = _find_node(_stats.global_tree, event->name);
#line 439
    if ((unsigned int )node != (unsigned int )((void *)0)) {
#line 440
      avl_delete(_stats.global_tree, (void *)node, & _free_stats);
    }
#line 441
    return;
  }
#line 443
  node = _find_node(_stats.global_tree, event->name);
#line 444
  if (node) {
#line 446
    modify_node_event(node, event);
  } else {
#line 451
    node = (stats_node_t *)calloc(1U, sizeof(stats_node_t ));
#line 452
    tmp___9 = __strdup((char const   *)event->name);
#line 452
    node->name = tmp___9;
#line 453
    tmp___19 = __strdup((char const   *)event->value);
#line 453
    node->value = tmp___19;
#line 455
    avl_insert(_stats.global_tree, (void *)node);
  }
#line 457
  return;
}
}
#line 460 "stats.c"
static void process_source_event(stats_event_t *event ) 
{ stats_source_t *snode ;
  stats_source_t *tmp ;
  char *tmp___10 ;
  stats_node_t *node ;
  stats_node_t *tmp___11 ;
  char *tmp___22 ;
  char *tmp___32 ;
  avl_node *node___0 ;
  avl_node *tmp___33 ;
  stats_node_t *stats ;

  {
#line 462
  tmp = _find_source(_stats.source_tree, event->source);
#line 462
  snode = tmp;
#line 463
  if ((unsigned int )snode == (unsigned int )((void *)0)) {
#line 465
    if (event->action == 4) {
#line 466
      return;
    }
#line 467
    snode = (stats_source_t *)calloc(1U, sizeof(stats_source_t ));
#line 468
    if ((unsigned int )snode == (unsigned int )((void *)0)) {
#line 469
      return;
    }
#line 470
    log_write(errorlog, 4U, "stats/", "process_source_event", "new source stat %s",
              event->source);
#line 471
    tmp___10 = __strdup((char const   *)event->source);
#line 471
    snode->source = tmp___10;
#line 472
    snode->stats_tree = avl_tree_new(& _compare_stats, (void *)0);
#line 473
    if (event->action == 5) {
#line 474
      snode->hidden = 1;
    } else {
#line 476
      snode->hidden = 0;
    }
#line 478
    avl_insert(_stats.source_tree, (void *)snode);
  }
#line 480
  if (event->name) {
#line 482
    tmp___11 = _find_node(snode->stats_tree, event->name);
#line 482
    node = tmp___11;
#line 483
    if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 485
      if (event->action == 4) {
#line 486
        return;
      }
#line 488
      if (event->value) {
#line 490
        log_write(errorlog, 4U, "stats/", "process_source_event", "new node %s (%s)",
                  event->name, event->value);
#line 491
        node = (stats_node_t *)calloc(1U, sizeof(stats_node_t ));
#line 492
        tmp___22 = __strdup((char const   *)event->name);
#line 492
        node->name = tmp___22;
#line 493
        tmp___32 = __strdup((char const   *)event->value);
#line 493
        node->value = tmp___32;
#line 494
        node->hidden = snode->hidden;
#line 496
        avl_insert(snode->stats_tree, (void *)node);
      }
#line 498
      return;
    }
#line 500
    if (event->action == 4) {
#line 502
      log_write(errorlog, 4U, "stats/", "process_source_event", "delete node %s",
                event->name);
#line 503
      avl_delete(snode->stats_tree, (void *)node, & _free_stats);
#line 504
      return;
    }
#line 506
    modify_node_event(node, event);
#line 507
    return;
  }
#line 509
  if (event->action == 5) {
#line 511
    tmp___33 = avl_get_first(snode->stats_tree);
#line 511
    node___0 = tmp___33;
#line 513
    if (event->value) {
#line 514
      snode->hidden = 1;
    } else {
#line 516
      snode->hidden = 0;
    }
#line 517
    while (node___0) {
#line 519
      stats = (stats_node_t *)node___0->key;
#line 520
      stats->hidden = snode->hidden;
#line 521
      node___0 = avl_get_next(node___0);
    }
#line 523
    return;
  }
#line 525
  if (event->action == 4) {
#line 527
    log_write(errorlog, 4U, "stats/", "process_source_event", "delete source node %s",
              event->source);
#line 528
    avl_delete(_stats.source_tree, (void *)snode, & _free_source_stats);
  }
#line 530
  return;
}
}
#line 533 "stats.c"
void stats_event_time(char const   *mount , char const   *name ) 
{ time_t now___0 ;
  time_t tmp ;
  struct tm local ;
  char buffer[100] ;

  {
#line 535
  tmp = time((time_t *)((void *)0));
#line 535
  now___0 = tmp;
#line 539
  localtime_r((time_t const   * __restrict  )(& now___0), (struct tm * __restrict  )(& local));
#line 540
  strftime((char * __restrict  )(buffer), sizeof(buffer), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S %z",
           (struct tm  const  * __restrict  )(& local));
#line 541
  stats_event(mount, name, (char const   *)(buffer));
#line 542
  return;
}
}
#line 545 "stats.c"
static void *_stats_thread(void *arg ) 
{ stats_event_t *event ;
  stats_event_t *copy ;
  event_listener_t *listener ;

  {
#line 551
  stats_event((char const   *)((void *)0), "server", "Icecast 2.3.1");
#line 552
  stats_event_time((char const   *)((void *)0), "server_start");
#line 555
  stats_event((char const   *)((void *)0), "clients", "0");
#line 556
  stats_event((char const   *)((void *)0), "connections", "0");
#line 557
  stats_event((char const   *)((void *)0), "sources", "0");
#line 558
  stats_event((char const   *)((void *)0), "stats", "0");
#line 561
  stats_event((char const   *)((void *)0), "client_connections", "0");
#line 562
  stats_event((char const   *)((void *)0), "source_client_connections", "0");
#line 563
  stats_event((char const   *)((void *)0), "source_relay_connections", "0");
#line 564
  stats_event((char const   *)((void *)0), "source_total_connections", "0");
#line 565
  stats_event((char const   *)((void *)0), "stats_connections", "0");
#line 566
  stats_event((char const   *)((void *)0), "listener_connections", "0");
#line 568
  log_write(errorlog, 3U, "stats/", "_stats_thread", "stats thread started");

  thread_register("stats_thread");
  thread_check_in();

#line 569
  LOOP_STATS_THREAD:while (_stats_running) {
#line 570
    if ((unsigned int )_global_event_queue.head != (unsigned int )((void *)0)) {
#line 572

      thread_check_out();

      thread_mutex_lock_c(& _global_event_mutex, 572, (char *)"stats.c");
#line 573
      event = _get_event_from_queue(& _global_event_queue);
#line 574
      thread_mutex_unlock_c(& _global_event_mutex, 574, (char *)"stats.c");

      thread_check_in();

#line 576
      event->next = (struct _stats_event_tag *)((void *)0);
#line 578
      thread_mutex_lock_c(& _stats_mutex, 578, (char *)"stats.c");
#line 581
      if ((unsigned int )event->source == (unsigned int )((void *)0)) {
#line 582
        process_global_event(event);
      } else {
#line 584
        process_source_event(event);
      }
#line 588
      listener = (event_listener_t *)_event_listeners;
#line 589
      while (listener) {
#line 590
        copy = _copy_event(event);
#line 591
        thread_mutex_lock_c(& listener->mutex, 591, (char *)"stats.c");
#line 592
        _add_event_to_queue(copy, & listener->queue);
#line 593
        thread_mutex_unlock_c(& listener->mutex, 593, (char *)"stats.c");
#line 595
        listener = listener->next;
      }
#line 599
      _free_event(event);
#line 601
      thread_mutex_unlock_c(& _stats_mutex, 601, (char *)"stats.c");
#line 602
      continue;
    }
#line 605
    thread_sleep(300000UL);

    __DSU_update("");
  }

  thread_deregister("stats_thread");

#line 608
  return ((void *)0);
}
}
#line 612 "stats.c"
static void _unregister_listener(event_listener_t *listener ) 
{ event_listener_t **prev ;
  event_listener_t *current ;

  {
#line 614
  prev = (event_listener_t **)(& _event_listeners);
#line 614
  current = (*prev);
#line 616
  while (current) {
#line 618
    if ((unsigned int )current == (unsigned int )listener) {
#line 620
      (*prev) = current->next;
#line 621
      break;
    }
#line 623
    prev = & current->next;
#line 624
    current = (*prev);
  }
#line 626
  return;
}
}
#line 629 "stats.c"
static stats_event_t *_make_event_from_node(stats_node_t *node , char *source ) 
{ stats_event_t *event ;
  stats_event_t *tmp ;
  char *tmp___9 ;
  char *tmp___19 ;
  char *tmp___29 ;

  {
#line 631
  tmp = (stats_event_t *)malloc(sizeof(stats_event_t ));
#line 631
  event = tmp;
#line 633
  if ((unsigned int )source != (unsigned int )((void *)0)) {
#line 634
    tmp___9 = __strdup((char const   *)source);
#line 634
    event->source = tmp___9;
  } else {
#line 636
    event->source = (char *)((void *)0);
  }
#line 637
  tmp___19 = __strdup((char const   *)node->name);
#line 637
  event->name = tmp___19;
#line 638
  tmp___29 = __strdup((char const   *)node->value);
#line 638
  event->value = tmp___29;
#line 639
  event->hidden = node->hidden;
#line 640
  event->action = 0;
#line 641
  event->next = (struct _stats_event_tag *)((void *)0);
#line 643
  return (event);
}
}
#line 647 "stats.c"
static void _add_event_to_queue(stats_event_t *event , event_queue_t *queue ) 
{ 

  {
#line 649
  (*(queue->tail)) = (stats_event_t volatile   *)event;
#line 650
  queue->tail = (stats_event_t volatile   **)(& event->next);
#line 651
  return;
}
}
#line 654 "stats.c"
static stats_event_t *_get_event_from_queue(event_queue_t *queue ) 
{ stats_event_t *event ;

  {
#line 656
  event = (stats_event_t *)((void *)0);
#line 658
  if (queue) {
#line 658
    if (queue->head) {
#line 660
      event = (stats_event_t *)queue->head;
#line 661
      queue->head = (stats_event_t volatile   *)event->next;
#line 662
      if ((unsigned int )queue->head == (unsigned int )((void *)0)) {
#line 663
        queue->tail = & queue->head;
      }
    }
  }
#line 666
  return (event);
}
}
#line 669 "stats.c"
static int _send_event_to_client(stats_event_t *event , client_t *client ) 
{ int len ;
  char buf[200] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 675
  if (event->value) {
#line 675
    tmp = (char const   *)event->value;
  } else {
#line 675
    tmp = "null";
  }
#line 675
  if (event->name) {
#line 675
    tmp___0 = (char const   *)event->name;
  } else {
#line 675
    tmp___0 = "null";
  }
#line 675
  if ((unsigned int )event->source != (unsigned int )((void *)0)) {
#line 675
    tmp___1 = (char const   *)event->source;
  } else {
#line 675
    tmp___1 = "global";
  }
#line 675
  len = snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"EVENT %s %s %s\n",
                 tmp___1, tmp___0, tmp);
#line 679
  if (len > 0) {
#line 679
    if (len < (int )sizeof(buf)) {
#line 681
      client_send_bytes(client, (void const   *)(buf), (unsigned int )len);
#line 682
      if ((client->con)->error) {
#line 683
        return (-1);
      }
    }
  }
#line 685
  return (0);
}
}
#line 688 "stats.c"
void _dump_stats_to_queue(event_queue_t *queue ) 
{ avl_node *node ;
  avl_node *node2 ;
  stats_event_t *event ;
  stats_source_t *source ;

  {
#line 695
  thread_mutex_lock_c(& _stats_mutex, 695, (char *)"stats.c");
#line 698
  node = avl_get_first(_stats.global_tree);
#line 699
  while (node) {
#line 700
    event = _make_event_from_node((stats_node_t *)node->key, (char *)((void *)0));
#line 701
    _add_event_to_queue(event, queue);
#line 703
    node = avl_get_next(node);
  }
#line 707
  node = avl_get_first(_stats.source_tree);
#line 708
  while (node) {
#line 709
    source = (stats_source_t *)node->key;
#line 710
    node2 = avl_get_first(source->stats_tree);
#line 711
    while (node2) {
#line 712
      event = _make_event_from_node((stats_node_t *)node2->key, source->source);
#line 713
      _add_event_to_queue(event, queue);
#line 715
      node2 = avl_get_next(node2);
    }
#line 718
    node = avl_get_next(node);
  }
#line 720
  thread_mutex_unlock_c(& _stats_mutex, 720, (char *)"stats.c");
#line 721
  return;
}
}
#line 728 "stats.c"
static void _register_listener(event_listener_t *listener ) 
{ avl_node *node ;
  avl_node *node2 ;
  stats_event_t *event ;
  stats_source_t *source ;

  {
#line 735
  thread_mutex_lock_c(& _stats_mutex, 735, (char *)"stats.c");
#line 740
  node = avl_get_first(_stats.global_tree);
#line 741
  while (node) {
#line 742
    event = _make_event_from_node((stats_node_t *)node->key, (char *)((void *)0));
#line 743
    _add_event_to_queue(event, & listener->queue);
#line 745
    node = avl_get_next(node);
  }
#line 749
  node = avl_get_first(_stats.source_tree);
#line 750
  while (node) {
#line 751
    source = (stats_source_t *)node->key;
#line 752
    node2 = avl_get_first(source->stats_tree);
#line 753
    while (node2) {
#line 754
      event = _make_event_from_node((stats_node_t *)node2->key, source->source);
#line 755
      _add_event_to_queue(event, & listener->queue);
#line 757
      node2 = avl_get_next(node2);
    }
#line 760
    node = avl_get_next(node);
  }
#line 764
  listener->next = (event_listener_t *)_event_listeners;
#line 765
  _event_listeners = (event_listener_t volatile   *)listener;
#line 767
  thread_mutex_unlock_c(& _stats_mutex, 767, (char *)"stats.c");
#line 768
  return;
}
}
#line 770 "stats.c"
void *stats_connection(void *arg ) 
{ client_t *client ;
  stats_event_t *event ;
  event_listener_t listener ;
  int tmp ;

  {
#line 772
  client = (client_t *)arg;
#line 776
  log_write(errorlog, 3U, "stats/", "stats_connection", "stats client starting");
#line 778
  listener.queue.head = (stats_event_t volatile   *)((void *)0);
#line 778
  listener.queue.tail = & listener.queue.head;
#line 780
  thread_mutex_lock_c(& _stats_mutex, 780, (char *)"stats.c");
#line 781
  _stats_threads ++;
#line 782
  stats_event_args((char const   *)((void *)0), (char *)"stats", (char *)"%d", _stats_threads);
#line 783
  thread_mutex_unlock_c(& _stats_mutex, 783, (char *)"stats.c");
#line 785
  thread_mutex_create_c(& listener.mutex, 785, (char *)"stats.c");
#line 787
  _register_listener(& listener);
#line 789

  thread_register("stats_connection");
  thread_check_in();

  LOOP_STATS_CONNECTION:while (_stats_running) {

    __DSU_update("");
    thread_check_out();

#line 790
    thread_mutex_lock_c(& listener.mutex, 790, (char *)"stats.c");
#line 791
    event = _get_event_from_queue(& listener.queue);
#line 792
    thread_mutex_unlock_c(& listener.mutex, 792, (char *)"stats.c");
#line 793
    if ((unsigned int )event != (unsigned int )((void *)0)) {
#line 794
      tmp = _send_event_to_client(event, client);
#line 794
      if (tmp < 0) {
#line 795
        _free_event(event);

        thread_check_in();

#line 796
        break;
      }
#line 798
      _free_event(event);

      thread_check_in();
#line 799
      continue;
    }
#line 801

    thread_check_in();

    thread_sleep(500000UL);
  }

  thread_deregister("stats_connection");

#line 804
  thread_mutex_lock_c(& _stats_mutex, 804, (char *)"stats.c");
#line 805
  _unregister_listener(& listener);
#line 806
  _stats_threads --;
#line 807
  stats_event_args((char const   *)((void *)0), (char *)"stats", (char *)"%d", _stats_threads);
#line 808
  thread_mutex_unlock_c(& _stats_mutex, 808, (char *)"stats.c");
#line 810
  thread_mutex_destroy(& listener.mutex);
#line 811
  client_destroy(client);
#line 812
  log_write(errorlog, 3U, "stats/", "stats_connection", "stats client finished");
#line 814
  return ((void *)0);
}
}
#line 818 "stats.c"
void stats_callback(client_t *client , void *notused ) 
{ 

  {
#line 820
  if ((client->con)->error) {
#line 822
    client_destroy(client);
#line 823
    return;
  }
#line 825
  client_set_queue(client, (refbuf_t *)((void *)0));
#line 826
  thread_create_c((char *)"Stats Connection", & stats_connection, (void *)client,
                  1, 826, (char *)"stats.c");
#line 827
  return;
}
}
#line 837 "stats.c"
static xmlNodePtr _find_xml_node(char *mount , source_xml_t **list , xmlNodePtr root ) 
{ source_xml_t *node ;
  source_xml_t *node2 ;
  int found ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___19 ;

  {
#line 840
  found = 0;
#line 843
  node = (*list);
#line 844
  while (node) {
#line 845
    if (0) {
#line 845
      __s1_len = strlen((char const   *)node->mount);
#line 845
      __s2_len = strlen((char const   *)mount);
#line 845
      if (! ((unsigned int )((void const   *)(node->mount + 1)) - (unsigned int )((void const   *)node->mount) ==
             1U)) {
        goto _L___0;
      } else {
#line 845
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 845
          if (! ((unsigned int )((void const   *)(mount + 1)) - (unsigned int )((void const   *)mount) ==
                 1U)) {
#line 845
            tmp___8 = 1;
          } else {
#line 845
            if (__s2_len >= 4U) {
#line 845
              tmp___8 = 1;
            } else {
#line 845
              tmp___8 = 0;
            }
          }
        } else {
#line 845
          tmp___8 = 0;
        }
      }
#line 845
      if (tmp___8) {
#line 845
        tmp___4 = __builtin_strcmp((char const   *)node->mount, (char const   *)mount);
      } else {
#line 845
        tmp___7 = __builtin_strcmp((char const   *)node->mount, (char const   *)mount);
#line 845
        tmp___4 = tmp___7;
      }
    } else {
#line 845
      tmp___7 = __builtin_strcmp((char const   *)node->mount, (char const   *)mount);
#line 845
      tmp___4 = tmp___7;
    }
#line 845
    if (tmp___4 == 0) {
#line 846
      found = 1;
#line 847
      break;
    }
#line 849
    node = node->next;
  }
#line 852
  if (found) {
#line 852
    return (node->node);
  }
#line 857
  node = (source_xml_t *)malloc(sizeof(source_xml_t ));
#line 858
  tmp___19 = __strdup((char const   *)mount);
#line 858
  node->mount = tmp___19;
#line 859
  node->node = xmlNewChild(root, (xmlNs *)((void *)0), (xmlChar const   *)"source",
                           (xmlChar const   *)((void *)0));
#line 860
  xmlSetProp(node->node, (xmlChar const   *)"mount", (xmlChar const   *)mount);
#line 861
  node->next = (struct _source_xml_tag *)((void *)0);
#line 864
  if ((unsigned int )(*list) == (unsigned int )((void *)0)) {
#line 865
    (*list) = node;
  } else {
#line 867
    node2 = (*list);
#line 868
    while (node2->next) {
#line 868
      node2 = node2->next;
    }
#line 869
    node2->next = node;
  }
#line 872
  return (node->node);
}
}
#line 875 "stats.c"
void stats_transform_xslt(client_t *client , char const   *uri ) 
{ xmlDocPtr doc ;
  char *xslpath ;
  char *tmp ;

  {
#line 878
  tmp = util_get_path_from_normalised_uri(uri);
#line 878
  xslpath = tmp;
#line 880
  stats_get_xml(& doc, 0);
#line 882
  xslt_transform(doc, (char const   *)xslpath, client);
#line 884
  xmlFreeDoc(doc);
#line 885
  free((void *)xslpath);
#line 886
  return;
}
}
#line 888 "stats.c"
void stats_get_xml(xmlDocPtr *doc , int show_hidden ) 
{ stats_event_t *event ;
  event_queue_t queue ;
  xmlNodePtr node ;
  xmlNodePtr srcnode ;
  source_xml_t *src_nodes ;
  source_xml_t *next ;
  xmlChar *name ;
  xmlChar *value ;

  {
#line 893
  src_nodes = (source_xml_t *)((void *)0);
#line 896
  queue.head = (stats_event_t volatile   *)((void *)0);
#line 896
  queue.tail = & queue.head;
#line 897
  _dump_stats_to_queue(& queue);
#line 899
  (*doc) = xmlNewDoc((xmlChar const   *)"1.0");
#line 900
  node = xmlNewDocNode((*doc), (xmlNs *)((void *)0), (xmlChar const   *)"icestats",
                       (xmlChar const   *)((void *)0));
#line 901
  xmlDocSetRootElement((*doc), node);
#line 903
  event = _get_event_from_queue(& queue);
#line 904
  while (event) {
#line 906
    if (event->hidden <= show_hidden) {
#line 909
      name = xmlEncodeEntitiesReentrant((*doc), (xmlChar const   *)event->name);
#line 910
      value = xmlEncodeEntitiesReentrant((*doc), (xmlChar const   *)event->value);
#line 911
      srcnode = node;
#line 912
      if (event->source) {
#line 913
        srcnode = _find_xml_node(event->source, & src_nodes, node);
      }
#line 915
      xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)name, (xmlChar const   *)value);
#line 916
      ((*xmlFree))((void *)value);
#line 917
      ((*xmlFree))((void *)name);
    }
#line 920
    _free_event(event);
#line 921
    event = _get_event_from_queue(& queue);
  }
#line 924
  while (src_nodes) {
#line 925
    next = src_nodes->next;
#line 926
    free((void *)src_nodes->mount);
#line 927
    free((void *)src_nodes);
#line 928
    src_nodes = next;
  }
#line 930
  return;
}
}
#line 931 "stats.c"
void stats_sendxml(client_t *client ) 
{ int bytes ;
  stats_event_t *event ;
  event_queue_t queue ;
  xmlDocPtr doc ;
  xmlNodePtr node ;
  xmlNodePtr srcnode ;
  int len ;
  xmlChar *buff ;
  source_xml_t *snd ;
  source_xml_t *src_nodes ;

  {
#line 939
  buff = (xmlChar *)((void *)0);
#line 941
  src_nodes = (source_xml_t *)((void *)0);
#line 943
  queue.head = (stats_event_t volatile   *)((void *)0);
#line 943
  queue.tail = & queue.head;
#line 944
  _dump_stats_to_queue(& queue);
#line 946
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 947
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"icestats", (xmlChar const   *)((void *)0));
#line 948
  xmlDocSetRootElement(doc, node);
#line 951
  event = _get_event_from_queue(& queue);
#line 952
  while (event) {
#line 953
    if ((unsigned int )event->source == (unsigned int )((void *)0)) {
#line 954
      xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)event->name, (xmlChar const   *)event->value);
    } else {
#line 956
      srcnode = _find_xml_node(event->source, & src_nodes, node);
#line 957
      xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)event->name, (xmlChar const   *)event->value);
    }
#line 960
    _free_event(event);
#line 961
    event = _get_event_from_queue(& queue);
  }
#line 964
  xmlDocDumpMemory(doc, & buff, & len);
#line 965
  xmlFreeDoc(doc);
#line 967
  client->respcode = 200;
#line 968
  bytes = sock_write((client->con)->sock, "HTTP/1.0 200 OK\r\nContent-Length: %d\r\nContent-Type: text/xml\r\n\r\n",
                     len);
#line 972
  if (bytes > 0) {
#line 972
    (client->con)->sent_bytes = (client->con)->sent_bytes + (uint64_t )bytes;
  } else {
    goto send_error;
  }
#line 975
  bytes = client_send_bytes(client, (void const   *)buff, (unsigned int )len);
  send_error: 
#line 978
  while (src_nodes) {
#line 979
    snd = src_nodes->next;
#line 980
    free((void *)src_nodes->mount);
#line 981
    free((void *)src_nodes);
#line 982
    src_nodes = snd;
  }
#line 984
  if (buff) {
#line 984
    ((*xmlFree))((void *)buff);
  }
#line 985
  return;
}
}
#line 987 "stats.c"
static int _compare_stats(void *arg , void *a , void *b ) 
{ stats_node_t *nodea ;
  stats_node_t *nodeb ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 989
  nodea = (stats_node_t *)a;
#line 990
  nodeb = (stats_node_t *)b;
#line 992
  if (0) {
#line 992
    __s1_len = strlen((char const   *)nodea->name);
#line 992
    __s2_len = strlen((char const   *)nodeb->name);
#line 992
    if (! ((unsigned int )((void const   *)(nodea->name + 1)) - (unsigned int )((void const   *)nodea->name) ==
           1U)) {
      goto _L___0;
    } else {
#line 992
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 992
        if (! ((unsigned int )((void const   *)(nodeb->name + 1)) - (unsigned int )((void const   *)nodeb->name) ==
               1U)) {
#line 992
          tmp___8 = 1;
        } else {
#line 992
          if (__s2_len >= 4U) {
#line 992
            tmp___8 = 1;
          } else {
#line 992
            tmp___8 = 0;
          }
        }
      } else {
#line 992
        tmp___8 = 0;
      }
    }
#line 992
    if (tmp___8) {
#line 992
      tmp___4 = __builtin_strcmp((char const   *)nodea->name, (char const   *)nodeb->name);
    } else {
#line 992
      tmp___7 = __builtin_strcmp((char const   *)nodea->name, (char const   *)nodeb->name);
#line 992
      tmp___4 = tmp___7;
    }
  } else {
#line 992
    tmp___7 = __builtin_strcmp((char const   *)nodea->name, (char const   *)nodeb->name);
#line 992
    tmp___4 = tmp___7;
  }
#line 992
  return (tmp___4);
}
}
#line 995 "stats.c"
static int _compare_source_stats(void *arg , void *a , void *b ) 
{ stats_source_t *nodea ;
  stats_source_t *nodeb ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 997
  nodea = (stats_source_t *)a;
#line 998
  nodeb = (stats_source_t *)b;
#line 1000
  if (0) {
#line 1000
    __s1_len = strlen((char const   *)nodea->source);
#line 1000
    __s2_len = strlen((char const   *)nodeb->source);
#line 1000
    if (! ((unsigned int )((void const   *)(nodea->source + 1)) - (unsigned int )((void const   *)nodea->source) ==
           1U)) {
      goto _L___0;
    } else {
#line 1000
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1000
        if (! ((unsigned int )((void const   *)(nodeb->source + 1)) - (unsigned int )((void const   *)nodeb->source) ==
               1U)) {
#line 1000
          tmp___8 = 1;
        } else {
#line 1000
          if (__s2_len >= 4U) {
#line 1000
            tmp___8 = 1;
          } else {
#line 1000
            tmp___8 = 0;
          }
        }
      } else {
#line 1000
        tmp___8 = 0;
      }
    }
#line 1000
    if (tmp___8) {
#line 1000
      tmp___4 = __builtin_strcmp((char const   *)nodea->source, (char const   *)nodeb->source);
    } else {
#line 1000
      tmp___7 = __builtin_strcmp((char const   *)nodea->source, (char const   *)nodeb->source);
#line 1000
      tmp___4 = tmp___7;
    }
  } else {
#line 1000
    tmp___7 = __builtin_strcmp((char const   *)nodea->source, (char const   *)nodeb->source);
#line 1000
    tmp___4 = tmp___7;
  }
#line 1000
  return (tmp___4);
}
}
#line 1003 "stats.c"
static int _free_stats(void *key ) 
{ stats_node_t *node ;

  {
#line 1005
  node = (stats_node_t *)key;
#line 1006
  free((void *)node->value);
#line 1007
  free((void *)node->name);
#line 1008
  free((void *)node);
#line 1010
  return (1);
}
}
#line 1013 "stats.c"
static int _free_source_stats(void *key ) 
{ stats_source_t *node ;

  {
#line 1015
  node = (stats_source_t *)key;
#line 1016
  avl_tree_free(node->stats_tree, & _free_stats);
#line 1017
  free((void *)node->source);
#line 1018
  free((void *)node);
#line 1020
  return (1);
}
}
#line 1023 "stats.c"
static void _free_event(stats_event_t *event ) 
{ 

  {
#line 1025
  if (event->source) {
#line 1025
    free((void *)event->source);
  }
#line 1026
  if (event->name) {
#line 1026
    free((void *)event->name);
  }
#line 1027
  if (event->value) {
#line 1027
    free((void *)event->value);
  }
#line 1028
  free((void *)event);
#line 1029
  return;
}
}
#line 1 "cil-3WClOnYU.o"
#pragma merger(0,"/tmp/cil-7Ugs7fIQ.i","")
#line 1 "./src/refbuf.o_saved.c"
#pragma merger(0,"./refbuf.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 28 "refbuf.c"
void refbuf_initialize(void) 
{ 

  {
#line 30
  return;
}
}
#line 32 "refbuf.c"
void refbuf_shutdown(void) 
{ 

  {
#line 34
  return;
}
}
#line 36 "refbuf.c"
refbuf_t *refbuf_new(unsigned long size ) 
{ refbuf_t *refbuf ;

  {
#line 40
  refbuf = (refbuf_t *)malloc(sizeof(refbuf_t ));
#line 41
  if ((unsigned int )refbuf == (unsigned int )((void *)0)) {
#line 42
    return ((refbuf_t *)((void *)0));
  }
#line 43
  refbuf->data = (char *)((void *)0);
#line 44
  if (size) {
#line 46
    refbuf->data = (char *)malloc((unsigned int )size);
#line 47
    if ((unsigned int )refbuf->data == (unsigned int )((void *)0)) {
#line 49
      free((void *)refbuf);
#line 50
      return ((refbuf_t *)((void *)0));
    }
  }
#line 53
  refbuf->len = size;
#line 54
  refbuf->sync_point = 0;
#line 55
  refbuf->_count = 1UL;
#line 56
  refbuf->next = (struct _refbuf_tag *)((void *)0);
#line 57
  refbuf->associated = (struct _refbuf_tag *)((void *)0);
#line 59
  return (refbuf);
}
}
#line 62 "refbuf.c"
void refbuf_addref(refbuf_t *self ) 
{ 

  {
#line 64
  self->_count = self->_count + 1UL;
#line 65
  return;
}
}
#line 67 "refbuf.c"
void refbuf_release(refbuf_t *self ) 
{ refbuf_t *ref ;

  {
#line 69
  if ((unsigned int )self == (unsigned int )((void *)0)) {
#line 70
    return;
  }
#line 71
  self->_count = self->_count - 1UL;
#line 72
  if (self->_count == 0UL) {
#line 73
    while (self->associated) {
#line 75
      ref = self->associated;
#line 76
      self->associated = ref->next;
#line 77
      refbuf_release(ref);
    }
#line 79
    free((void *)self->data);
#line 80
    free((void *)self);
  }
#line 82
  return;
}
}
#line 1 "cil-uJ8gKuMK.o"
#pragma merger(0,"/tmp/cil-rDuS49TV.i","")
#line 1 "./src/client.o_saved.c"
#pragma merger(0,"./client.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 626 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 78 "auth.h"
int release_client(client_t *client ) ;
#line 62 "format.h"
int format_generic_write_to_client(client_t *client ) ;
#line 34 "fserve.h"
int fserve_add_client(client_t *client , FILE *file ) ;
#line 52 "client.c"
int client_create(client_t **c_ptr , connection_t *con , http_parser_t *parser ) 
{ ice_config_t *config ;
  client_t *client ;
  client_t *tmp ;
  int ret ;

  {
#line 55
  tmp = (client_t *)calloc(1U, sizeof(client_t ));
#line 55
  client = tmp;
#line 56
  ret = -1;
#line 58
  if ((unsigned int )client == (unsigned int )((void *)0)) {
#line 59
    abort();
  }
#line 61
  config = config_get_config();
#line 63
  global.clients = global.clients + 1;
#line 64
  if (config->client_limit < global.clients) {
#line 65
    log_write(errorlog, 2U, "client/", "client_create", "server client limit reached (%d/%d)",
              config->client_limit, global.clients);
  } else {
#line 67
    ret = 0;
  }
#line 69
  config_release_config();
#line 71
  stats_event_args((char const   *)((void *)0), (char *)"clients", (char *)"%d", global.clients);
#line 72
  client->con = con;
#line 73
  client->parser = parser;
#line 74
  client->refbuf = refbuf_new(4096UL);
#line 75
  (client->refbuf)->len = 0UL;
#line 76
  client->pos = 0UL;
#line 77
  client->write_to_client = & format_generic_write_to_client;
#line 78
  (*c_ptr) = client;
#line 80
  return (ret);
}
}
#line 83 "client.c"
void client_destroy(client_t *client ) 
{ int tmp ;

  {
#line 85
  if ((unsigned int )client == (unsigned int )((void *)0)) {
#line 86
    return;
  }
#line 90
  if (client->refbuf) {
#line 92
    refbuf_release(client->refbuf);
#line 93
    client->refbuf = (refbuf_t *)((void *)0);
  }
#line 96
  tmp = release_client(client);
#line 96
  if (tmp) {
#line 97
    return;
  }
#line 102
  if (client->respcode) {
#line 102
    if (client->parser) {
#line 103
      logging_access(client);
    }
  }
#line 105
  if (client->con) {
#line 106
    connection_close(client->con);
  }
#line 107
  if (client->parser) {
#line 108
    httpp_destroy(client->parser);
  }
#line 110
  global_lock();
#line 111
  global.clients = global.clients - 1;
#line 112
  stats_event_args((char const   *)((void *)0), (char *)"clients", (char *)"%d", global.clients);
#line 113
  global_unlock();
#line 116
  if (client->free_client_data) {
#line 117
    ((*(client->free_client_data)))(client);
  }
#line 119
  free((void *)client->username);
#line 120
  free((void *)client->password);
#line 122
  free((void *)client);
#line 123
  return;
}
}
#line 127 "client.c"
int client_read_bytes(client_t *client , void *buf , unsigned int len ) 
{ int bytes ;
  char *ptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 131
  if (client->refbuf) {
#line 131
    if ((client->refbuf)->len) {
#line 134
      if ((client->refbuf)->len < (unsigned long )len) {
#line 135
        len = (unsigned int )(client->refbuf)->len;
      }
#line 136
      memcpy((void * __restrict  )buf, (void const   * __restrict  )(client->refbuf)->data,
             len);
#line 137
      if ((unsigned long )len < (client->refbuf)->len) {
#line 139
        ptr = (client->refbuf)->data;
#line 140
        memmove((void *)ptr, (void const   *)(ptr + len), (unsigned int )((client->refbuf)->len -
                                                                          (unsigned long )len));
      }
#line 142
      (client->refbuf)->len = (client->refbuf)->len - (unsigned long )len;
#line 143
      return ((int )len);
    }
  }
#line 145
  bytes = sock_read_bytes((client->con)->sock, (char *)buf, (int )len);
#line 146
  if (bytes > 0) {
#line 147
    return (bytes);
  }
#line 149
  if (bytes < 0) {
#line 151
    tmp = sock_error();
#line 151
    tmp___0 = sock_recoverable(tmp);
#line 151
    if (tmp___0) {
#line 152
      return (-1);
    }
#line 153
    log_write(errorlog, 2U, "client/", "client_read_bytes", "source connection has died");
  }
#line 155
  (client->con)->error = 1;
#line 156
  return (-1);
}
}
#line 160 "client.c"
void client_send_400(client_t *client , char *message ) 
{ 

  {
#line 161
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 400 Bad Request\r\nContent-Type: text/html\r\n\r\n<b>%s</b>\r\n",
           message);
#line 165
  client->respcode = 400;
#line 166
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 167
  fserve_add_client(client, (FILE *)((void *)0));
#line 168
  return;
}
}
#line 170 "client.c"
void client_send_404(client_t *client , char *message ) 
{ 

  {
#line 172
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 404 File Not Found\r\nContent-Type: text/html\r\n\r\n<b>%s</b>\r\n",
           message);
#line 176
  client->respcode = 404;
#line 177
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 178
  fserve_add_client(client, (FILE *)((void *)0));
#line 179
  return;
}
}
#line 182 "client.c"
void client_send_401(client_t *client ) 
{ 

  {
#line 183
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 401 Authentication Required\r\nWWW-Authenticate: Basic realm=\"Icecast2 Server\"\r\n\r\nYou need to authenticate\r\n");
#line 188
  client->respcode = 401;
#line 189
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 190
  fserve_add_client(client, (FILE *)((void *)0));
#line 191
  return;
}
}
#line 193 "client.c"
void client_send_403(client_t *client , char const   *reason ) 
{ 

  {
#line 195
  if ((unsigned int )reason == (unsigned int )((void *)0)) {
#line 196
    reason = "Forbidden";
  }
#line 197
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 403 %s\r\n\r\n",
           reason);
#line 199
  client->respcode = 403;
#line 200
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 201
  fserve_add_client(client, (FILE *)((void *)0));
#line 202
  return;
}
}
#line 206 "client.c"
int client_send_bytes(client_t *client , void const   *buf , unsigned int len ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 208
  tmp = sock_write_bytes((client->con)->sock, buf, len);
#line 208
  ret = tmp;
#line 209
  if (ret < 0) {
#line 209
    tmp___0 = sock_error();
#line 209
    tmp___1 = sock_recoverable(tmp___0);
#line 209
    if (! tmp___1) {
#line 211
      log_write(errorlog, 4U, "client/", "client_send_bytes", "Client connection died");
#line 212
      (client->con)->error = 1;
    }
  }
#line 214
  if (ret > 0) {
#line 215
    (client->con)->sent_bytes = (client->con)->sent_bytes + (uint64_t )ret;
  }
#line 216
  return (ret);
}
}
#line 219 "client.c"
void client_set_queue(client_t *client , refbuf_t *refbuf ) 
{ refbuf_t *to_release ;

  {
#line 221
  to_release = client->refbuf;
#line 223
  client->refbuf = refbuf;
#line 224
  if (refbuf) {
#line 225
    refbuf_addref(client->refbuf);
  }
#line 226
  client->pos = 0UL;
#line 227
  if (to_release) {
#line 228
    refbuf_release(to_release);
  }
#line 229
  return;
}
}
#line 1 "cil-8pOnucg1.o"
#pragma merger(0,"/tmp/cil-A2APjTAF.i","")
#line 1 "./src/xslt.o_saved.c"
#pragma merger(0,"./xslt.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 827 "/usr/include/libxml2/libxml/xmlerror.h"
extern void xmlSetGenericErrorFunc(void *ctx , void (*handler)(void *ctx , char const   *msg 
                                                               , ...) ) ;
#line 835 "/usr/include/libxml2/libxml/parser.h"
extern int xmlSubstituteEntitiesDefault(int val ) ;
#line 366 "/usr/include/libxml2/libxml/globals.h"
extern int *__xmlLoadExtDtdDefaultValue(void) ;
#line 88 "/usr/include/libxslt/xslt.h"
extern void xsltCleanupGlobals(void) ;
#line 629 "/usr/include/libxslt/xsltInternals.h"
extern xsltStylesheetPtr xsltParseStylesheetFile(xmlChar const   *filename ) ;
#line 631
extern void xsltFreeStylesheet(xsltStylesheetPtr sheet ) ;
#line 55 "/usr/include/libxslt/transform.h"
extern xmlDocPtr xsltApplyStylesheet(xsltStylesheetPtr style , xmlDocPtr doc , char const   **params ) ;
#line 155 "/usr/include/libxslt/xsltutils.h"
extern void xsltSetGenericErrorFunc(void *ctx , void (*handler)(void *ctx , char const   *msg 
                                                                , ...) ) ;
#line 235
extern int xsltSaveResultToString(xmlChar **doc_txt_ptr , int *doc_txt_len , xmlDocPtr result ,
                                  xsltStylesheetPtr style ) ;
#line 94 "xslt.c"
static stylesheet_cache_t cache[3]  ;
#line 95 "xslt.c"
static mutex_t xsltlock  ;
#line 97 "xslt.c"
void xslt_initialize(void) 
{ int *tmp ;
  int *tmp___0 ;

  {
#line 99
  xmlSubstituteEntitiesDefault(1);
#line 100
  tmp = __xmlLoadExtDtdDefaultValue();
#line 100
  (*tmp) = 1;
#line 102
  memset((void *)(cache), 0, sizeof(stylesheet_cache_t ) * 3U);
#line 103
  thread_mutex_create_c(& xsltlock, 103, (char *)"xslt.c");
#line 104
  xmlSubstituteEntitiesDefault(1);
#line 105
  tmp___0 = __xmlLoadExtDtdDefaultValue();
#line 105
  (*tmp___0) = 1;
#line 106
  return;
}
}
#line 108 "xslt.c"
void xslt_shutdown(void) 
{ int i ;

  {
#line 111
  i = 0;
#line 111
  while (i < 3) {
#line 112
    if (cache[i].filename) {
#line 113
      free((void *)cache[i].filename);
    }
#line 114
    if (cache[i].stylesheet) {
#line 115
      xsltFreeStylesheet(cache[i].stylesheet);
    }
#line 111
    i ++;
  }
#line 118
  thread_mutex_destroy(& xsltlock);
#line 119
  xsltCleanupGlobals();
#line 120
  return;
}
}
#line 122 "xslt.c"
static int evict_cache_entry(void) 
{ int i ;
  int age ;
  int oldest ;

  {
#line 123
  age = 0;
#line 123
  oldest = 0;
#line 125
  i = 0;
#line 125
  while (i < 3) {
#line 126
    if (cache[i].cache_age > (time_t )age) {
#line 127
      age = (int )cache[i].cache_age;
#line 128
      oldest = i;
    }
#line 125
    i ++;
  }
#line 132
  xsltFreeStylesheet(cache[oldest].stylesheet);
#line 133
  free((void *)cache[oldest].filename);
#line 135
  return (oldest);
}
}
#line 138 "xslt.c"
static xsltStylesheetPtr xslt_get_stylesheet(char const   *fn ) 
{ int i ;
  int empty ;
  struct stat file ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___21 ;

  {
#line 140
  empty = -1;
#line 143
  tmp___1 = stat__extinline(fn, & file);
#line 143
  if (tmp___1) {
#line 144
    tmp = __errno_location();
#line 144
    tmp___0 = strerror((*tmp));
#line 144
    log_write(errorlog, 2U, "xslt/", "xslt_get_stylesheet", "Error checking for stylesheet file \"%s\": %s",
              fn, tmp___0);
#line 146
    return ((xsltStylesheet *)((void *)0));
  }
#line 149
  i = 0;
#line 149
  while (i < 3) {
#line 150
    if (cache[i].filename) {
#line 155
      if (0) {
#line 155
        __s1_len = strlen(fn);
#line 155
        __s2_len = strlen((char const   *)cache[i].filename);
#line 155
        if (! ((unsigned int )((void const   *)(fn + 1)) - (unsigned int )((void const   *)fn) ==
               1U)) {
          goto _L___0;
        } else {
#line 155
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 155
            if (! ((unsigned int )((void const   *)(cache[i].filename + 1)) - (unsigned int )((void const   *)cache[i].filename) ==
                   1U)) {
#line 155
              tmp___11 = 1;
            } else {
#line 155
              if (__s2_len >= 4U) {
#line 155
                tmp___11 = 1;
              } else {
#line 155
                tmp___11 = 0;
              }
            }
          } else {
#line 155
            tmp___11 = 0;
          }
        }
#line 155
        if (tmp___11) {
#line 155
          tmp___7 = __builtin_strcmp(fn, (char const   *)cache[i].filename);
        } else {
#line 155
          tmp___10 = __builtin_strcmp(fn, (char const   *)cache[i].filename);
#line 155
          tmp___7 = tmp___10;
        }
      } else {
#line 155
        tmp___10 = __builtin_strcmp(fn, (char const   *)cache[i].filename);
#line 155
        tmp___7 = tmp___10;
      }
#line 155
      if (! tmp___7) {
#line 158
        if (file.st_mtim.tv_sec > cache[i].last_modified) {
#line 160
          xsltFreeStylesheet(cache[i].stylesheet);
#line 162
          cache[i].last_modified = file.st_mtim.tv_sec;
#line 163
          cache[i].stylesheet = xsltParseStylesheetFile((xmlChar const   *)fn);
#line 164
          cache[i].cache_age = time((time_t *)((void *)0));
        }
#line 166
        log_write(errorlog, 4U, "xslt/", "xslt_get_stylesheet", "Using cached sheet %i",
                  i);
#line 167
        return (cache[i].stylesheet);
      }
    } else {
#line 171
      empty = i;
    }
#line 149
    i ++;
  }
#line 174
  if (empty >= 0) {
#line 175
    i = empty;
  } else {
#line 177
    i = evict_cache_entry();
  }
#line 179
  cache[i].last_modified = file.st_mtim.tv_sec;
#line 180
  tmp___21 = __strdup(fn);
#line 180
  cache[i].filename = tmp___21;
#line 181
  cache[i].stylesheet = xsltParseStylesheetFile((xmlChar const   *)fn);
#line 182
  cache[i].cache_age = time((time_t *)((void *)0));
#line 183
  return (cache[i].stylesheet);
}
}
#line 186 "xslt.c"
void xslt_transform(xmlDocPtr doc , char const   *xslfilename , client_t *client ) 
{ xmlDocPtr res ;
  xsltStylesheetPtr cur ;
  xmlChar *string ;
  int len ;
  int problem ;
  int tmp ;
  char const   *http ;
  int buf_len ;
  size_t tmp___0 ;

  {
#line 191
  problem = 0;
#line 193
  xmlSetGenericErrorFunc((void *)"", & log_parse_failure);
#line 194
  xsltSetGenericErrorFunc((void *)"", & log_parse_failure);
#line 196
  thread_mutex_lock_c(& xsltlock, 196, (char *)"xslt.c");
#line 197
  cur = xslt_get_stylesheet(xslfilename);
#line 199
  if ((unsigned int )cur == (unsigned int )((void *)0)) {
#line 201
    thread_mutex_unlock_c(& xsltlock, 201, (char *)"xslt.c");
#line 202
    log_write(errorlog, 1U, "xslt/", "xslt_transform", "problem reading stylesheet \"%s\"",
              xslfilename);
#line 203
    client_send_404(client, (char *)"Could not parse XSLT file");
#line 204
    return;
  }
#line 207
  res = xsltApplyStylesheet(cur, doc, (char const   **)((void *)0));
#line 209
  tmp = xsltSaveResultToString(& string, & len, res, cur);
#line 209
  if (tmp < 0) {
#line 210
    problem = 1;
  }
#line 211
  thread_mutex_unlock_c(& xsltlock, 211, (char *)"xslt.c");
#line 212
  if (problem == 0) {
#line 214
    http = "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nContent-Length: ";
#line 215
    tmp___0 = strlen(http);
#line 215
    buf_len = (int )((tmp___0 + 20U) + (size_t )len);
#line 217
    if ((unsigned int )string == (unsigned int )((void *)0)) {
#line 218
      string = xmlStrdup((xmlChar const   *)"");
    }
#line 219
    client->respcode = 200;
#line 220
    client_set_queue(client, (refbuf_t *)((void *)0));
#line 221
    client->refbuf = refbuf_new((unsigned long )buf_len);
#line 222
    len = snprintf((char * __restrict  )(client->refbuf)->data, (unsigned int )buf_len,
                   (char const   * __restrict  )"%s%d\r\n\r\n%s", http, len, string);
#line 223
    (client->refbuf)->len = (unsigned long )len;
#line 224
    fserve_add_client(client, (FILE *)((void *)0));
#line 225
    ((*xmlFree))((void *)string);
  } else {
#line 229
    log_write(errorlog, 2U, "xslt/", "xslt_transform", "problem applying stylesheet \"%s\"",
              xslfilename);
#line 230
    client_send_404(client, (char *)"XSLT problem");
  }
#line 232
  xmlFreeDoc(res);
#line 233
  return;
}
}
#line 1 "cil-GYayiIgF.o"
#pragma merger(0,"/tmp/cil-vSVY0K53.i","")
#line 1 "./src/fserve.o_saved.c"
#pragma merger(0,"./fserve.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 528 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 606
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 646
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
#line 33 "fserve.h"
int fserve_client_create(client_t *httpclient , char const   *path ) ;
#line 68 "fserve.c"
static fserve_t *active_list  =    (fserve_t *)((void *)0);
#line 69 "fserve.c"
static fserve_t volatile   *pending_list  =    (fserve_t volatile   *)((void *)0);
#line 71 "fserve.c"
static mutex_t pending_lock  ;
#line 72 "fserve.c"
static avl_tree *mimetypes  =    (avl_tree *)((void *)0);
#line 74 "fserve.c"
static thread_type *fserv_thread  ;
#line 75 "fserve.c"
static int run_fserv  =    0;
#line 76 "fserve.c"
static unsigned int fserve_clients  ;
#line 77 "fserve.c"
static int client_tree_changed  =    0;
#line 80 "fserve.c"
static struct pollfd *ufds  =    (struct pollfd *)((void *)0);
#line 91
static void fserve_client_destroy(fserve_t *fclient ) ;
#line 92
static int _delete_mapping(void *mapping ) ;
#line 93
static void *fserv_thread_function(void *arg ) ;
#line 94
static void create_mime_mappings(char const   *fn ) ;
#line 96 "fserve.c"
void fserve_initialize(void) 
{ 

  {
#line 98
  create_mime_mappings("/etc/mime.types");
#line 100
  thread_mutex_create_c(& pending_lock, 100, (char *)"fserve.c");
#line 102
  run_fserv = 1;
#line 103
  stats_event((char const   *)((void *)0), "file_connections", "0");
#line 105
  fserv_thread = thread_create_c((char *)"File Serving Thread", & fserv_thread_function,
                                 (void *)0, 0, 106, (char *)"fserve.c");
#line 107
  return;
}
}
#line 109 "fserve.c"
void fserve_shutdown(void) 
{ 

  {
#line 111
  if (! run_fserv) {
#line 112
    return;
  }
#line 114
  run_fserv = 0;
#line 115
  thread_join(fserv_thread);
#line 116
  log_write(errorlog, 3U, "fserve/", "fserve_shutdown", "file serving thread stopped");
#line 117
  avl_tree_free(mimetypes, & _delete_mapping);
#line 118
  return;
}
}
#line 121 "fserve.c"
int fserve_client_waiting(void) 
{ fserve_t *fclient ;
  unsigned int i ;
  int tmp ;

  {
#line 124
  i = 0U;
#line 127
  if (client_tree_changed) {
#line 129
    client_tree_changed = 0;
#line 130
    ufds = (struct pollfd *)realloc((void *)ufds, fserve_clients * sizeof(struct pollfd ));
#line 131
    fclient = active_list;
#line 132
    while (fclient) {
#line 134
      (ufds + i)->fd = ((fclient->client)->con)->sock;
#line 135
      (ufds + i)->events = (short)4;
#line 136
      (ufds + i)->revents = (short)0;
#line 137
      fclient = fclient->next;
#line 138
      i ++;
    }
  }
#line 141
  if (! ufds) {
#line 142
    thread_sleep(200000UL);
  } else {
#line 143
    tmp = poll(ufds, (unsigned long )fserve_clients, 200);
#line 143
    if (tmp > 0) {
#line 146
      fclient = active_list;
#line 147
      i = 0U;
#line 147
      while (i < fserve_clients) {
#line 149
        if ((int )(ufds + i)->revents & 28) {
#line 150
          fclient->ready = 1;
        }
#line 151
        fclient = fclient->next;
#line 147
        i ++;
      }
#line 153
      return (1);
    }
  }
#line 155
  return (0);
}
}
#line 204 "fserve.c"
static void wait_for_fds(void) 
{ fserve_t *fclient ;
  fserve_t *to_move ;
  int tmp ;

  {
#line 207
  while (run_fserv) {
#line 210
    if (pending_list) {
#line 212
      thread_mutex_lock_c(& pending_lock, 212, (char *)"fserve.c");
#line 214
      fclient = (fserve_t *)pending_list;
#line 215
      while (fclient) {
#line 217
        to_move = fclient;
#line 218
        fclient = fclient->next;
#line 219
        to_move->next = active_list;
#line 220
        active_list = to_move;
#line 221
        client_tree_changed = 1;
#line 222
        fserve_clients ++;
      }
#line 224
      pending_list = (fserve_t volatile   *)((void *)0);
#line 225
      thread_mutex_unlock_c(& pending_lock, 225, (char *)"fserve.c");
    }
#line 228
    tmp = fserve_client_waiting();
#line 228
    if (tmp) {
#line 229
      break;
    }
  }
#line 231
  return;
}
}
#line 233 "fserve.c"
static void *fserv_thread_function(void *arg ) 
{ fserve_t *fclient ;
  fserve_t **trail ;
  int bytes ;
  client_t *client ;
  refbuf_t *refbuf ;
  fserve_t *to_go ;
  fserve_t *to_go___0 ;
  fserve_t *to_go___1 ;
  fserve_t *to_go___2 ;

  {
#line 238
  log_write(errorlog, 3U, "fserve/", "fserv_thread_function", "file serving thread started");

  thread_register("fserv_thread");

#line 239
  LOOP_FSERV_THREAD_FUNCTION:while (run_fserv) {
#line 240

    thread_check_in();
    __DSU_update("");

    wait_for_fds();

    thread_check_out();
#line 242
    fclient = active_list;
#line 243
    trail = & active_list;
#line 245
    while (fclient) {
#line 248
      if (fclient->ready) {
#line 250
        client = fclient->client;
#line 251
        refbuf = client->refbuf;
#line 252
        fclient->ready = 0;
#line 253
        if (client->pos == refbuf->len) {
#line 256
          if (fclient->file) {
#line 257
            bytes = (int )fread((void * __restrict  )refbuf->data, 1U, 4096U, (FILE * __restrict  )fclient->file);
          } else {
#line 259
            bytes = 0;
          }
#line 260
          if (bytes == 0) {
#line 262
            to_go = fclient;
#line 263
            fclient = fclient->next;
#line 264
            (*trail) = fclient;
#line 265
            fserve_client_destroy(to_go);
#line 266
            fserve_clients --;
#line 267
            client_tree_changed = 1;
#line 268
            continue;
          }
#line 270
          refbuf->len = (unsigned long )bytes;
#line 271
          client->pos = 0UL;
        }
#line 275
        format_generic_write_to_client(client);
#line 277
        if ((client->con)->error) {
#line 279
          to_go___0 = fclient;
#line 280
          fclient = fclient->next;
#line 281
          (*trail) = fclient;
#line 282
          fserve_clients --;
#line 283
          fserve_client_destroy(to_go___0);
#line 284
          client_tree_changed = 1;
#line 285
          continue;
        }
      }
#line 288
      trail = & fclient->next;
#line 289
      fclient = fclient->next;
    }
  }

  thread_deregister("fserv_thread");

#line 294
  thread_mutex_lock_c(& pending_lock, 294, (char *)"fserve.c");
#line 295
  while (pending_list) {
#line 297
    to_go___1 = (fserve_t *)pending_list;
#line 298
    pending_list = (fserve_t volatile   *)to_go___1->next;
#line 300
    fserve_client_destroy(to_go___1);
  }
#line 302
  thread_mutex_unlock_c(& pending_lock, 302, (char *)"fserve.c");
#line 304
  while (active_list) {
#line 306
    to_go___2 = active_list;
#line 307
    active_list = to_go___2->next;
#line 308
    fserve_client_destroy(to_go___2);
  }
#line 311
  return ((void *)0);
}
}
#line 314 "fserve.c"
char *fserve_content_type(char const   *path ) 
{ char *ext ;
  char *tmp ;
  mime_type exttype ;
  void *result ;
  mime_type *mime ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___75 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;

  {
#line 316
  tmp = util_get_extension(path);
#line 316
  ext = tmp;
#line 317
  exttype.ext = ext;
#line 317
  exttype.type = (char *)((void *)0);
#line 320
  tmp___80 = avl_get_by_key(mimetypes, (void *)(& exttype), & result);
#line 320
  if (tmp___80) {
#line 327
    if (0) {
#line 327
      __s1_len___6 = strlen((char const   *)ext);
#line 327
      __s2_len___6 = strlen("ogg");
#line 327
      if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
             1U)) {
        goto _L___14;
      } else {
#line 327
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 327
          if (! ((unsigned int )((void const   *)("ogg" + 1)) - (unsigned int )((void const   *)"ogg") ==
                 1U)) {
#line 327
            tmp___79 = 1;
          } else {
#line 327
            if (__s2_len___6 >= 4U) {
#line 327
              tmp___79 = 1;
            } else {
#line 327
              tmp___79 = 0;
            }
          }
        } else {
#line 327
          tmp___79 = 0;
        }
      }
#line 327
      if (tmp___79) {
#line 327
        tmp___75 = __builtin_strcmp((char const   *)ext, "ogg");
      } else {
#line 327
        tmp___78 = __builtin_strcmp((char const   *)ext, "ogg");
#line 327
        tmp___75 = tmp___78;
      }
    } else {
#line 327
      tmp___78 = __builtin_strcmp((char const   *)ext, "ogg");
#line 327
      tmp___75 = tmp___78;
    }
#line 327
    if (tmp___75) {
#line 329
      if (0) {
#line 329
        __s1_len___5 = strlen((char const   *)ext);
#line 329
        __s2_len___5 = strlen("mp3");
#line 329
        if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
               1U)) {
          goto _L___12;
        } else {
#line 329
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 329
            if (! ((unsigned int )((void const   *)("mp3" + 1)) - (unsigned int )((void const   *)"mp3") ==
                   1U)) {
#line 329
              tmp___69 = 1;
            } else {
#line 329
              if (__s2_len___5 >= 4U) {
#line 329
                tmp___69 = 1;
              } else {
#line 329
                tmp___69 = 0;
              }
            }
          } else {
#line 329
            tmp___69 = 0;
          }
        }
#line 329
        if (tmp___69) {
#line 329
          tmp___65 = __builtin_strcmp((char const   *)ext, "mp3");
        } else {
#line 329
          tmp___68 = __builtin_strcmp((char const   *)ext, "mp3");
#line 329
          tmp___65 = tmp___68;
        }
      } else {
#line 329
        tmp___68 = __builtin_strcmp((char const   *)ext, "mp3");
#line 329
        tmp___65 = tmp___68;
      }
#line 329
      if (tmp___65) {
#line 331
        if (0) {
#line 331
          __s1_len___4 = strlen((char const   *)ext);
#line 331
          __s2_len___4 = strlen("html");
#line 331
          if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
                 1U)) {
            goto _L___10;
          } else {
#line 331
            if (__s1_len___4 >= 4U) {
              _L___10: /* CIL Label */ 
#line 331
              if (! ((unsigned int )((void const   *)("html" + 1)) - (unsigned int )((void const   *)"html") ==
                     1U)) {
#line 331
                tmp___59 = 1;
              } else {
#line 331
                if (__s2_len___4 >= 4U) {
#line 331
                  tmp___59 = 1;
                } else {
#line 331
                  tmp___59 = 0;
                }
              }
            } else {
#line 331
              tmp___59 = 0;
            }
          }
#line 331
          if (tmp___59) {
#line 331
            tmp___55 = __builtin_strcmp((char const   *)ext, "html");
          } else {
#line 331
            tmp___58 = __builtin_strcmp((char const   *)ext, "html");
#line 331
            tmp___55 = tmp___58;
          }
        } else {
#line 331
          tmp___58 = __builtin_strcmp((char const   *)ext, "html");
#line 331
          tmp___55 = tmp___58;
        }
#line 331
        if (tmp___55) {
#line 333
          if (0) {
#line 333
            __s1_len___3 = strlen((char const   *)ext);
#line 333
            __s2_len___3 = strlen("css");
#line 333
            if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
                   1U)) {
              goto _L___8;
            } else {
#line 333
              if (__s1_len___3 >= 4U) {
                _L___8: /* CIL Label */ 
#line 333
                if (! ((unsigned int )((void const   *)("css" + 1)) - (unsigned int )((void const   *)"css") ==
                       1U)) {
#line 333
                  tmp___49 = 1;
                } else {
#line 333
                  if (__s2_len___3 >= 4U) {
#line 333
                    tmp___49 = 1;
                  } else {
#line 333
                    tmp___49 = 0;
                  }
                }
              } else {
#line 333
                tmp___49 = 0;
              }
            }
#line 333
            if (tmp___49) {
#line 333
              tmp___45 = __builtin_strcmp((char const   *)ext, "css");
            } else {
#line 333
              tmp___48 = __builtin_strcmp((char const   *)ext, "css");
#line 333
              tmp___45 = tmp___48;
            }
          } else {
#line 333
            tmp___48 = __builtin_strcmp((char const   *)ext, "css");
#line 333
            tmp___45 = tmp___48;
          }
#line 333
          if (tmp___45) {
#line 335
            if (0) {
#line 335
              __s1_len___2 = strlen((char const   *)ext);
#line 335
              __s2_len___2 = strlen("txt");
#line 335
              if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
                     1U)) {
                goto _L___6;
              } else {
#line 335
                if (__s1_len___2 >= 4U) {
                  _L___6: /* CIL Label */ 
#line 335
                  if (! ((unsigned int )((void const   *)("txt" + 1)) - (unsigned int )((void const   *)"txt") ==
                         1U)) {
#line 335
                    tmp___39 = 1;
                  } else {
#line 335
                    if (__s2_len___2 >= 4U) {
#line 335
                      tmp___39 = 1;
                    } else {
#line 335
                      tmp___39 = 0;
                    }
                  }
                } else {
#line 335
                  tmp___39 = 0;
                }
              }
#line 335
              if (tmp___39) {
#line 335
                tmp___35 = __builtin_strcmp((char const   *)ext, "txt");
              } else {
#line 335
                tmp___38 = __builtin_strcmp((char const   *)ext, "txt");
#line 335
                tmp___35 = tmp___38;
              }
            } else {
#line 335
              tmp___38 = __builtin_strcmp((char const   *)ext, "txt");
#line 335
              tmp___35 = tmp___38;
            }
#line 335
            if (tmp___35) {
#line 337
              if (0) {
#line 337
                __s1_len___1 = strlen((char const   *)ext);
#line 337
                __s2_len___1 = strlen("jpg");
#line 337
                if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
                       1U)) {
                  goto _L___4;
                } else {
#line 337
                  if (__s1_len___1 >= 4U) {
                    _L___4: /* CIL Label */ 
#line 337
                    if (! ((unsigned int )((void const   *)("jpg" + 1)) - (unsigned int )((void const   *)"jpg") ==
                           1U)) {
#line 337
                      tmp___29 = 1;
                    } else {
#line 337
                      if (__s2_len___1 >= 4U) {
#line 337
                        tmp___29 = 1;
                      } else {
#line 337
                        tmp___29 = 0;
                      }
                    }
                  } else {
#line 337
                    tmp___29 = 0;
                  }
                }
#line 337
                if (tmp___29) {
#line 337
                  tmp___25 = __builtin_strcmp((char const   *)ext, "jpg");
                } else {
#line 337
                  tmp___28 = __builtin_strcmp((char const   *)ext, "jpg");
#line 337
                  tmp___25 = tmp___28;
                }
              } else {
#line 337
                tmp___28 = __builtin_strcmp((char const   *)ext, "jpg");
#line 337
                tmp___25 = tmp___28;
              }
#line 337
              if (tmp___25) {
#line 339
                if (0) {
#line 339
                  __s1_len___0 = strlen((char const   *)ext);
#line 339
                  __s2_len___0 = strlen("png");
#line 339
                  if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
                         1U)) {
                    goto _L___2;
                  } else {
#line 339
                    if (__s1_len___0 >= 4U) {
                      _L___2: /* CIL Label */ 
#line 339
                      if (! ((unsigned int )((void const   *)("png" + 1)) - (unsigned int )((void const   *)"png") ==
                             1U)) {
#line 339
                        tmp___19 = 1;
                      } else {
#line 339
                        if (__s2_len___0 >= 4U) {
#line 339
                          tmp___19 = 1;
                        } else {
#line 339
                          tmp___19 = 0;
                        }
                      }
                    } else {
#line 339
                      tmp___19 = 0;
                    }
                  }
#line 339
                  if (tmp___19) {
#line 339
                    tmp___15 = __builtin_strcmp((char const   *)ext, "png");
                  } else {
#line 339
                    tmp___18 = __builtin_strcmp((char const   *)ext, "png");
#line 339
                    tmp___15 = tmp___18;
                  }
                } else {
#line 339
                  tmp___18 = __builtin_strcmp((char const   *)ext, "png");
#line 339
                  tmp___15 = tmp___18;
                }
#line 339
                if (tmp___15) {
#line 341
                  if (0) {
#line 341
                    __s1_len = strlen((char const   *)ext);
#line 341
                    __s2_len = strlen("m3u");
#line 341
                    if (! ((unsigned int )((void const   *)(ext + 1)) - (unsigned int )((void const   *)ext) ==
                           1U)) {
                      goto _L___0;
                    } else {
#line 341
                      if (__s1_len >= 4U) {
                        _L___0: /* CIL Label */ 
#line 341
                        if (! ((unsigned int )((void const   *)("m3u" + 1)) - (unsigned int )((void const   *)"m3u") ==
                               1U)) {
#line 341
                          tmp___9 = 1;
                        } else {
#line 341
                          if (__s2_len >= 4U) {
#line 341
                            tmp___9 = 1;
                          } else {
#line 341
                            tmp___9 = 0;
                          }
                        }
                      } else {
#line 341
                        tmp___9 = 0;
                      }
                    }
#line 341
                    if (tmp___9) {
#line 341
                      tmp___5 = __builtin_strcmp((char const   *)ext, "m3u");
                    } else {
#line 341
                      tmp___8 = __builtin_strcmp((char const   *)ext, "m3u");
#line 341
                      tmp___5 = tmp___8;
                    }
                  } else {
#line 341
                    tmp___8 = __builtin_strcmp((char const   *)ext, "m3u");
#line 341
                    tmp___5 = tmp___8;
                  }
#line 341
                  if (tmp___5) {
#line 344
                    return ((char *)"application/octet-stream");
                  } else {
#line 342
                    return ((char *)"audio/x-mpegurl");
                  }
                } else {
#line 340
                  return ((char *)"image/png");
                }
              } else {
#line 338
                return ((char *)"image/jpeg");
              }
            } else {
#line 336
              return ((char *)"text/plain");
            }
          } else {
#line 334
            return ((char *)"text/css");
          }
        } else {
#line 332
          return ((char *)"text/html");
        }
      } else {
#line 330
        return ((char *)"audio/mpeg");
      }
    } else {
#line 328
      return ((char *)"application/ogg");
    }
  } else {
#line 322
    mime = (mime_type *)result;
#line 323
    return (mime->type);
  }
}
}
#line 348 "fserve.c"
static void fserve_client_destroy(fserve_t *fclient ) 
{ 

  {
#line 350
  if (fclient) {
#line 352
    if (fclient->file) {
#line 353
      fclose(fclient->file);
    }
#line 355
    if (fclient->callback) {
#line 356
      ((*(fclient->callback)))(fclient->client, fclient->arg);
    } else {
#line 358
      if (fclient->client) {
#line 359
        client_destroy(fclient->client);
      }
    }
#line 360
    free((void *)fclient);
  }
#line 362
  return;
}
}
#line 368 "fserve.c"
int fserve_client_create(client_t *httpclient , char const   *path ) 
{ int bytes ;
  struct stat file_buf ;
  char *range ;
  int64_t new_content_len ;
  int64_t rangenumber ;
  int64_t content_length ;
  int rangeproblem ;
  int ret ;
  char *fullpath ;
  int m3u_requested ;
  int m3u_file_available ;
  ice_config_t *config ;
  FILE *file ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___42 ;
  int tmp___43 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  int *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *host ;
  char *tmp___52 ;
  char *sourceuri ;
  char *tmp___62 ;
  char *dot ;
  char *tmp___63 ;
  char *tmp___65 ;
  char currenttime[50] ;
  time_t now___0 ;
  int strflen ;
  struct tm result ;
  int64_t endpos ;
  struct tm *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;

  {
#line 372
  range = (char *)((void *)0);
#line 373
  new_content_len = (int64_t )0;
#line 374
  rangenumber = (int64_t )0;
#line 375
  rangeproblem = 0;
#line 376
  ret = 0;
#line 378
  m3u_requested = 0;
#line 378
  m3u_file_available = 1;
#line 382
  fullpath = util_get_path_from_normalised_uri(path);
#line 383
  log_write(errorlog, 3U, "fserve/", "fserve_client_create", "checking for file %s (%s)",
            path, fullpath);
#line 385
  if (0) {
#line 385
    tmp___45 = util_get_extension((char const   *)fullpath);
#line 385
    __s1_len = strlen((char const   *)tmp___45);
#line 385
    __s2_len = strlen("m3u");
#line 385
    tmp___46 = util_get_extension((char const   *)fullpath);
#line 385
    tmp___47 = util_get_extension((char const   *)fullpath);
#line 385
    if ((unsigned int )((void const   *)(tmp___46 + 1)) - (unsigned int )((void const   *)tmp___47) ==
        1U) {
#line 385
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 385
        if (! ((unsigned int )((void const   *)("m3u" + 1)) - (unsigned int )((void const   *)"m3u") ==
               1U)) {
#line 385
          tmp___48 = 1;
        } else {
#line 385
          if (__s2_len >= 4U) {
#line 385
            tmp___48 = 1;
          } else {
#line 385
            tmp___48 = 0;
          }
        }
      } else {
#line 385
        tmp___48 = 0;
      }
    } else {
      goto _L___0;
    }
#line 385
    if (tmp___48) {
#line 385
      tmp___25 = util_get_extension((char const   *)fullpath);
#line 385
      tmp___24 = __builtin_strcmp((char const   *)tmp___25, "m3u");
    } else {
#line 385
      tmp___42 = util_get_extension((char const   *)fullpath);
#line 385
      tmp___43 = __builtin_strcmp((char const   *)tmp___42, "m3u");
#line 385
      tmp___24 = tmp___43;
    }
  } else {
#line 385
    tmp___42 = util_get_extension((char const   *)fullpath);
#line 385
    tmp___43 = __builtin_strcmp((char const   *)tmp___42, "m3u");
#line 385
    tmp___24 = tmp___43;
  }
#line 385
  if (tmp___24 == 0) {
#line 386
    m3u_requested = 1;
  }
#line 389
  tmp___51 = stat__extinline((char const   *)fullpath, & file_buf);
#line 389
  if (tmp___51 != 0) {
#line 392
    if (m3u_requested == 0) {
#line 394
      tmp___49 = __errno_location();
#line 394
      tmp___50 = strerror((*tmp___49));
#line 394
      log_write(errorlog, 2U, "fserve/", "fserve_client_create", "req for file \"%s\" %s",
                fullpath, tmp___50);
#line 395
      client_send_404(httpclient, (char *)"The file you requested could not be found");
#line 396
      free((void *)fullpath);
#line 397
      return (-1);
    }
#line 399
    m3u_file_available = 0;
  }
#line 402
  (httpclient->refbuf)->len = 4096UL;
#line 404
  if (m3u_requested) {
#line 404
    if (m3u_file_available == 0) {
#line 406
      tmp___52 = httpp_getvar(httpclient->parser, "host");
#line 406
      host = tmp___52;
#line 407
      tmp___62 = __strdup(path);
#line 407
      sourceuri = tmp___62;
#line 408
      tmp___63 = strrchr((char const   *)sourceuri, '.');
#line 408
      dot = tmp___63;
#line 413
      if (host) {
#line 413
        tmp___65 = __builtin_strchr(host, (char )':');
#line 413
        if ((unsigned int )tmp___65 == (unsigned int )((void *)0)) {
#line 414
          host = (char *)((void *)0);
        }
      }
#line 416
      (*dot) = (char)0;
#line 417
      httpclient->respcode = 200;
#line 418
      if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 420
        config = config_get_config();
#line 421
        snprintf((char * __restrict  )(httpclient->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Type: audio/x-mpegurl\r\n\r\nhttp://%s:%d%s\r\n",
                 config->hostname, config->port, sourceuri);
#line 428
        config_release_config();
      } else {
#line 432
        snprintf((char * __restrict  )(httpclient->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Type: audio/x-mpegurl\r\n\r\nhttp://%s%s\r\n",
                 host, sourceuri);
      }
#line 440
      (httpclient->refbuf)->len = (unsigned long )strlen((char const   *)(httpclient->refbuf)->data);
#line 441
      fserve_add_client(httpclient, (FILE *)((void *)0));
#line 442
      free((void *)sourceuri);
#line 443
      free((void *)fullpath);
#line 444
      return (0);
    }
  }
#line 448
  config = config_get_config();
#line 449
  if (config->fileserve == 0) {
#line 451
    log_write(errorlog, 4U, "fserve/", "fserve_client_create", "on demand file \"%s\" refused",
              fullpath);
#line 452
    client_send_404(httpclient, (char *)"The file you requested could not be found");
#line 453
    config_release_config();
#line 454
    free((void *)fullpath);
#line 455
    return (-1);
  }
#line 457
  config_release_config();
#line 459
  if (((file_buf.st_mode & 61440U) == 32768U) == 0) {
#line 461
    client_send_404(httpclient, (char *)"The file you requested could not be found");
#line 462
    log_write(errorlog, 2U, "fserve/", "fserve_client_create", "found requested file but there is no handler for it: %s",
              fullpath);
#line 463
    free((void *)fullpath);
#line 464
    return (-1);
  }
#line 467
  file = fopen((char const   * __restrict  )fullpath, (char const   * __restrict  )"rb");
#line 468
  free((void *)fullpath);
#line 469
  if ((unsigned int )file == (unsigned int )((void *)0)) {
#line 471
    log_write(errorlog, 2U, "fserve/", "fserve_client_create", "Problem accessing file \"%s\"",
              fullpath);
#line 472
    client_send_404(httpclient, (char *)"File not readable");
#line 473
    return (-1);
  }
#line 476
  content_length = (long long )file_buf.st_size;
#line 477
  range = httpp_getvar(httpclient->parser, "range");
#line 479
  if ((unsigned int )range != (unsigned int )((void *)0)) {
#line 480
    ret = sscanf((char const   * __restrict  )range, (char const   * __restrict  )"bytes=%lld-",
                 & rangenumber);
#line 481
    if (ret != 1) {
#line 484
      rangeproblem = 1;
    }
#line 486
    if (rangenumber < 0LL) {
#line 487
      rangeproblem = 1;
    }
#line 489
    if (! rangeproblem) {
#line 490
      ret = fseek(file, (long )rangenumber, 0);
#line 491
      if (ret != -1) {
#line 492
        new_content_len = content_length - rangenumber;
#line 493
        if (new_content_len < 0LL) {
#line 494
          rangeproblem = 1;
        }
      } else {
#line 498
        rangeproblem = 1;
      }
#line 500
      if (! rangeproblem) {
#line 506
        endpos = (rangenumber + new_content_len) - 1LL;
#line 507
        if (endpos < 0LL) {
#line 508
          endpos = 0LL;
        }
#line 510
        time(& now___0);
#line 511
        tmp___66 = gmtime_r((time_t const   * __restrict  )(& now___0), (struct tm * __restrict  )(& result));
#line 511
        strflen = (int )strftime((char * __restrict  )(currenttime), 50U, (char const   * __restrict  )"%a, %d-%b-%Y %X GMT",
                                 (struct tm  const  * __restrict  )tmp___66);
#line 513
        httpclient->respcode = 206;
#line 514
        tmp___67 = fserve_content_type(path);
#line 514
        bytes = snprintf((char * __restrict  )(httpclient->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.1 206 Partial Content\r\nDate: %s\r\nContent-Length: %lld\r\nContent-Range: bytes %lld-%lld/%lld\r\nContent-Type: %s\r\n\r\n",
                         currenttime, new_content_len, rangenumber, endpos, content_length,
                         tmp___67);
      } else {
#line 529
        httpclient->respcode = 416;
#line 530
        sock_write((httpclient->con)->sock, "HTTP/1.0 416 Request Range Not Satisfiable\r\n\r\n");
#line 532
        client_destroy(httpclient);
#line 533
        return (-1);
      }
    } else {
#line 539
      httpclient->respcode = 416;
#line 540
      sock_write((httpclient->con)->sock, "HTTP/1.0 416 Request Range Not Satisfiable\r\n\r\n");
#line 542
      client_destroy(httpclient);
#line 543
      return (-1);
    }
  } else {
#line 548
    httpclient->respcode = 200;
#line 549
    tmp___68 = fserve_content_type(path);
#line 549
    bytes = snprintf((char * __restrict  )(httpclient->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Length: %lld\r\nContent-Type: %s\r\n\r\n",
                     content_length, tmp___68);
  }
#line 556
  (httpclient->refbuf)->len = (unsigned long )bytes;
#line 557
  httpclient->pos = 0UL;
#line 559
  stats_event_inc((char const   *)((void *)0), "file_connections");
#line 560
  fserve_add_client(httpclient, file);
#line 562
  return (0);
}
}
#line 569 "fserve.c"
int fserve_add_client(client_t *client , FILE *file ) 
{ fserve_t *fclient ;
  fserve_t *tmp ;

  {
#line 571
  tmp = (fserve_t *)calloc(1U, sizeof(fserve_t ));
#line 571
  fclient = tmp;
#line 573
  log_write(errorlog, 4U, "fserve/", "fserve_add_client", "Adding client to file serving engine");
#line 574
  if ((unsigned int )fclient == (unsigned int )((void *)0)) {
#line 576
    client_send_404(client, (char *)"memory exhausted");
#line 577
    return (-1);
  }
#line 579
  fclient->file = file;
#line 580
  fclient->client = client;
#line 581
  fclient->ready = 0;
#line 583
  thread_mutex_lock_c(& pending_lock, 583, (char *)"fserve.c");
#line 584
  fclient->next = (fserve_t *)pending_list;
#line 585
  pending_list = (fserve_t volatile   *)fclient;
#line 586
  thread_mutex_unlock_c(& pending_lock, 586, (char *)"fserve.c");
#line 588
  return (0);
}
}
#line 595 "fserve.c"
void fserve_add_client_callback(client_t *client , void (*callback)(client_t * , void * ) ,
                                void *arg ) 
{ fserve_t *fclient ;
  fserve_t *tmp ;

  {
#line 597
  tmp = (fserve_t *)calloc(1U, sizeof(fserve_t ));
#line 597
  fclient = tmp;
#line 599
  log_write(errorlog, 4U, "fserve/", "fserve_add_client_callback", "Adding client to file serving engine");
#line 600
  if ((unsigned int )fclient == (unsigned int )((void *)0)) {
#line 602
    client_send_404(client, (char *)"memory exhausted");
#line 603
    return;
  }
#line 605
  fclient->file = (FILE *)((void *)0);
#line 606
  fclient->client = client;
#line 607
  fclient->ready = 0;
#line 608
  fclient->callback = callback;
#line 609
  fclient->arg = arg;
#line 611
  thread_mutex_lock_c(& pending_lock, 611, (char *)"fserve.c");
#line 612
  fclient->next = (fserve_t *)pending_list;
#line 613
  pending_list = (fserve_t volatile   *)fclient;
#line 614
  thread_mutex_unlock_c(& pending_lock, 614, (char *)"fserve.c");
#line 615
  return;
}
}
#line 618 "fserve.c"
static int _delete_mapping(void *mapping ) 
{ mime_type *map ;

  {
#line 619
  map = (mime_type *)mapping;
#line 620
  free((void *)map->ext);
#line 621
  free((void *)map->type);
#line 622
  free((void *)map);
#line 624
  return (1);
}
}
#line 627 "fserve.c"
static int _compare_mappings(void *arg , void *a , void *b ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 629
  if (0) {
#line 629
    __s1_len = strlen((char const   *)((mime_type *)a)->ext);
#line 629
    __s2_len = strlen((char const   *)((mime_type *)b)->ext);
#line 629
    if (! ((unsigned int )((void const   *)(((mime_type *)a)->ext + 1)) - (unsigned int )((void const   *)((mime_type *)a)->ext) ==
           1U)) {
      goto _L___0;
    } else {
#line 629
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 629
        if (! ((unsigned int )((void const   *)(((mime_type *)b)->ext + 1)) - (unsigned int )((void const   *)((mime_type *)b)->ext) ==
               1U)) {
#line 629
          tmp___8 = 1;
        } else {
#line 629
          if (__s2_len >= 4U) {
#line 629
            tmp___8 = 1;
          } else {
#line 629
            tmp___8 = 0;
          }
        }
      } else {
#line 629
        tmp___8 = 0;
      }
    }
#line 629
    if (tmp___8) {
#line 629
      tmp___4 = __builtin_strcmp((char const   *)((mime_type *)a)->ext, (char const   *)((mime_type *)b)->ext);
    } else {
#line 629
      tmp___7 = __builtin_strcmp((char const   *)((mime_type *)a)->ext, (char const   *)((mime_type *)b)->ext);
#line 629
      tmp___4 = tmp___7;
    }
  } else {
#line 629
    tmp___7 = __builtin_strcmp((char const   *)((mime_type *)a)->ext, (char const   *)((mime_type *)b)->ext);
#line 629
    tmp___4 = tmp___7;
  }
#line 629
  return (tmp___4);
}
}
#line 634 "fserve.c"
static void create_mime_mappings(char const   *fn ) 
{ FILE *mimefile ;
  FILE *tmp ;
  char line[4096] ;
  char *type ;
  char *ext ;
  char *cur ;
  mime_type *mapping ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___12 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;

  {
#line 635
  tmp = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"r");
#line 635
  mimefile = tmp;
#line 640
  mimetypes = avl_tree_new(& _compare_mappings, (void *)0);
#line 642
  if ((unsigned int )mimefile == (unsigned int )((void *)0)) {
#line 644
    log_write(errorlog, 2U, "fserve/", "create_mime_mappings", "Cannot open mime type file %s",
              fn);
#line 645
    return;
  }
#line 648
  while (1) {
#line 648
    tmp___24 = fgets((char * __restrict  )(line), 4096, (FILE * __restrict  )mimefile);
#line 648
    if (! tmp___24) {
#line 648
      break;
    }
#line 650
    line[4095] = (char)0;
#line 652
    if ((int )line[0] == 0) {
#line 653
      continue;
    } else {
#line 652
      if ((int )line[0] == 35) {
#line 653
        continue;
      }
    }
#line 655
    type = line;
#line 657
    cur = line;
#line 659
    while (1) {
#line 659
      if ((int )(*cur) != 32) {
#line 659
        if ((int )(*cur) != 9) {
#line 659
          if (! (*cur)) {
#line 659
            break;
          }
        } else {
#line 659
          break;
        }
      } else {
#line 659
        break;
      }
#line 660
      cur ++;
    }
#line 661
    if ((int )(*cur) == 0) {
#line 662
      continue;
    }
#line 664
    tmp___0 = cur;
#line 664
    cur ++;
#line 664
    (*tmp___0) = (char)0;
#line 666
    while (1) {
#line 667
      while (1) {
#line 667
        if (! ((int )(*cur) == 32)) {
#line 667
          if (! ((int )(*cur) == 9)) {
#line 667
            break;
          }
        }
#line 668
        cur ++;
      }
#line 669
      if ((int )(*cur) == 0) {
#line 670
        break;
      }
#line 672
      ext = cur;
#line 673
      while (1) {
#line 673
        if ((int )(*cur) != 32) {
#line 673
          if ((int )(*cur) != 9) {
#line 673
            if ((int )(*cur) != 10) {
#line 673
              if (! (*cur)) {
#line 673
                break;
              }
            } else {
#line 673
              break;
            }
          } else {
#line 673
            break;
          }
        } else {
#line 673
          break;
        }
#line 674
        cur ++;
      }
#line 675
      tmp___1 = cur;
#line 675
      cur ++;
#line 675
      (*tmp___1) = (char)0;
#line 676
      if ((*ext)) {
#line 680
        mapping = (mime_type *)malloc(sizeof(mime_type ));
#line 681
        tmp___12 = __strdup((char const   *)ext);
#line 681
        mapping->ext = tmp___12;
#line 682
        tmp___22 = __strdup((char const   *)type);
#line 682
        mapping->type = tmp___22;
#line 683
        tmp___23 = avl_get_by_key(mimetypes, (void *)mapping, & tmp___2);
#line 683
        if (! tmp___23) {
#line 684
          avl_delete(mimetypes, (void *)mapping, & _delete_mapping);
        }
#line 685
        avl_insert(mimetypes, (void *)mapping);
      }
    }
  }
#line 690
  fclose(mimefile);
#line 691
  return;
}
}
#line 1 "cil-MQgzFaHq.o"
#pragma merger(0,"/tmp/cil-2TGBkBIs.i","")
#line 1 "./src/event.o_saved.c"
#pragma merger(0,"./event.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 34 "yp.h"
void yp_recheck_config(ice_config_t *config ) ;
#line 29 "event.c"
void event_config_read(void *arg ) 
{ int ret ;
  ice_config_t *config ;
  ice_config_t new_config ;
  ice_config_t *tmp ;
  ice_config_t *tmp___0 ;

  {
#line 36
  config = config_grab_config();
#line 38
  xmlSetGenericErrorFunc((void *)"config", & log_parse_failure);
#line 39
  ret = config_parse_file((char const   *)config->config_filename, & new_config);
#line 40
  if (ret < 0) {
#line 41
    log_write(errorlog, 1U, "event/", "event_config_read", "Error parsing config, not replacing existing config");
#line 42
    switch (ret) {
    case -1: 
#line 44
    log_write(errorlog, 1U, "event/", "event_config_read", "Config filename null or blank");
#line 45
    break;
    case -2: 
#line 47
    log_write(errorlog, 1U, "event/", "event_config_read", "Root element not found in %s",
              config->config_filename);
#line 48
    break;
    case -3: 
#line 50
    log_write(errorlog, 1U, "event/", "event_config_read", "Not an icecast2 config file: %s",
              config->config_filename);
#line 52
    break;
    default: 
#line 54
    log_write(errorlog, 1U, "event/", "event_config_read", "Parse error in reading %s",
              config->config_filename);
#line 55
    break;
    }
#line 57
    config_release_config();
  } else {
#line 60
    config_clear(config);
#line 61
    config_set_config(& new_config);
#line 62
    tmp = config_get_config_unlocked();
#line 62
    restart_logging(tmp);
#line 63
    tmp___0 = config_get_config_unlocked();
#line 63
    yp_recheck_config(tmp___0);
#line 65
    config_release_config();
#line 66
    slave_recheck_mounts();
  }
#line 68
  return;
}
}
#line 1 "cil-bSejOqkG.o"
#pragma merger(0,"/tmp/cil-jLQttIR5.i","")
#line 1 "./src/admin.o_saved.c"
#pragma merger(0,"./admin.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 116 "admin.c"
int admin_get_command(char *command ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___94 ;
  int tmp___97 ;
  int tmp___98 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___104 ;
  int tmp___107 ;
  int tmp___108 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___114 ;
  int tmp___117 ;
  int tmp___118 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___124 ;
  int tmp___127 ;
  int tmp___128 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___134 ;
  int tmp___137 ;
  int tmp___138 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___144 ;
  int tmp___147 ;
  int tmp___148 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___154 ;
  int tmp___157 ;
  int tmp___158 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___164 ;
  int tmp___167 ;
  int tmp___168 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___174 ;
  int tmp___177 ;
  int tmp___178 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___184 ;
  int tmp___187 ;
  int tmp___188 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___194 ;
  int tmp___197 ;
  int tmp___198 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___204 ;
  int tmp___207 ;
  int tmp___208 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___214 ;
  int tmp___217 ;
  int tmp___218 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___224 ;
  int tmp___227 ;
  int tmp___228 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___234 ;
  int tmp___237 ;
  int tmp___238 ;
  size_t __s1_len___23 ;
  size_t __s2_len___23 ;
  int tmp___244 ;
  int tmp___247 ;
  int tmp___248 ;
  size_t __s1_len___24 ;
  size_t __s2_len___24 ;
  int tmp___254 ;
  int tmp___257 ;
  int tmp___258 ;
  size_t __s1_len___25 ;
  size_t __s2_len___25 ;
  int tmp___264 ;
  int tmp___267 ;
  int tmp___268 ;

  {
#line 118
  if (0) {
#line 118
    __s1_len___25 = strlen((char const   *)command);
#line 118
    __s2_len___25 = strlen("fallbacks");
#line 118
    if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
           1U)) {
      goto _L___52;
    } else {
#line 118
      if (__s1_len___25 >= 4U) {
        _L___52: /* CIL Label */ 
#line 118
        if (! ((unsigned int )((void const   *)("fallbacks" + 1)) - (unsigned int )((void const   *)"fallbacks") ==
               1U)) {
#line 118
          tmp___268 = 1;
        } else {
#line 118
          if (__s2_len___25 >= 4U) {
#line 118
            tmp___268 = 1;
          } else {
#line 118
            tmp___268 = 0;
          }
        }
      } else {
#line 118
        tmp___268 = 0;
      }
    }
#line 118
    if (tmp___268) {
#line 118
      tmp___264 = __builtin_strcmp((char const   *)command, "fallbacks");
    } else {
#line 118
      tmp___267 = __builtin_strcmp((char const   *)command, "fallbacks");
#line 118
      tmp___264 = tmp___267;
    }
  } else {
#line 118
    tmp___267 = __builtin_strcmp((char const   *)command, "fallbacks");
#line 118
    tmp___264 = tmp___267;
  }
#line 118
  if (tmp___264) {
#line 120
    if (0) {
#line 120
      __s1_len___24 = strlen((char const   *)command);
#line 120
      __s2_len___24 = strlen("fallbacks.xsl");
#line 120
      if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
             1U)) {
        goto _L___50;
      } else {
#line 120
        if (__s1_len___24 >= 4U) {
          _L___50: /* CIL Label */ 
#line 120
          if (! ((unsigned int )((void const   *)("fallbacks.xsl" + 1)) - (unsigned int )((void const   *)"fallbacks.xsl") ==
                 1U)) {
#line 120
            tmp___258 = 1;
          } else {
#line 120
            if (__s2_len___24 >= 4U) {
#line 120
              tmp___258 = 1;
            } else {
#line 120
              tmp___258 = 0;
            }
          }
        } else {
#line 120
          tmp___258 = 0;
        }
      }
#line 120
      if (tmp___258) {
#line 120
        tmp___254 = __builtin_strcmp((char const   *)command, "fallbacks.xsl");
      } else {
#line 120
        tmp___257 = __builtin_strcmp((char const   *)command, "fallbacks.xsl");
#line 120
        tmp___254 = tmp___257;
      }
    } else {
#line 120
      tmp___257 = __builtin_strcmp((char const   *)command, "fallbacks.xsl");
#line 120
      tmp___254 = tmp___257;
    }
#line 120
    if (tmp___254) {
#line 122
      if (0) {
#line 122
        __s1_len___23 = strlen((char const   *)command);
#line 122
        __s2_len___23 = strlen("metadata");
#line 122
        if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
               1U)) {
          goto _L___48;
        } else {
#line 122
          if (__s1_len___23 >= 4U) {
            _L___48: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)("metadata" + 1)) - (unsigned int )((void const   *)"metadata") ==
                   1U)) {
#line 122
              tmp___248 = 1;
            } else {
#line 122
              if (__s2_len___23 >= 4U) {
#line 122
                tmp___248 = 1;
              } else {
#line 122
                tmp___248 = 0;
              }
            }
          } else {
#line 122
            tmp___248 = 0;
          }
        }
#line 122
        if (tmp___248) {
#line 122
          tmp___244 = __builtin_strcmp((char const   *)command, "metadata");
        } else {
#line 122
          tmp___247 = __builtin_strcmp((char const   *)command, "metadata");
#line 122
          tmp___244 = tmp___247;
        }
      } else {
#line 122
        tmp___247 = __builtin_strcmp((char const   *)command, "metadata");
#line 122
        tmp___244 = tmp___247;
      }
#line 122
      if (tmp___244) {
#line 124
        if (0) {
#line 124
          __s1_len___22 = strlen((char const   *)command);
#line 124
          __s2_len___22 = strlen("metadata.xsl");
#line 124
          if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                 1U)) {
            goto _L___46;
          } else {
#line 124
            if (__s1_len___22 >= 4U) {
              _L___46: /* CIL Label */ 
#line 124
              if (! ((unsigned int )((void const   *)("metadata.xsl" + 1)) - (unsigned int )((void const   *)"metadata.xsl") ==
                     1U)) {
#line 124
                tmp___238 = 1;
              } else {
#line 124
                if (__s2_len___22 >= 4U) {
#line 124
                  tmp___238 = 1;
                } else {
#line 124
                  tmp___238 = 0;
                }
              }
            } else {
#line 124
              tmp___238 = 0;
            }
          }
#line 124
          if (tmp___238) {
#line 124
            tmp___234 = __builtin_strcmp((char const   *)command, "metadata.xsl");
          } else {
#line 124
            tmp___237 = __builtin_strcmp((char const   *)command, "metadata.xsl");
#line 124
            tmp___234 = tmp___237;
          }
        } else {
#line 124
          tmp___237 = __builtin_strcmp((char const   *)command, "metadata.xsl");
#line 124
          tmp___234 = tmp___237;
        }
#line 124
        if (tmp___234) {
#line 126
          if (0) {
#line 126
            __s1_len___21 = strlen((char const   *)command);
#line 126
            __s2_len___21 = strlen("admin.cgi");
#line 126
            if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                   1U)) {
              goto _L___44;
            } else {
#line 126
              if (__s1_len___21 >= 4U) {
                _L___44: /* CIL Label */ 
#line 126
                if (! ((unsigned int )((void const   *)("admin.cgi" + 1)) - (unsigned int )((void const   *)"admin.cgi") ==
                       1U)) {
#line 126
                  tmp___228 = 1;
                } else {
#line 126
                  if (__s2_len___21 >= 4U) {
#line 126
                    tmp___228 = 1;
                  } else {
#line 126
                    tmp___228 = 0;
                  }
                }
              } else {
#line 126
                tmp___228 = 0;
              }
            }
#line 126
            if (tmp___228) {
#line 126
              tmp___224 = __builtin_strcmp((char const   *)command, "admin.cgi");
            } else {
#line 126
              tmp___227 = __builtin_strcmp((char const   *)command, "admin.cgi");
#line 126
              tmp___224 = tmp___227;
            }
          } else {
#line 126
            tmp___227 = __builtin_strcmp((char const   *)command, "admin.cgi");
#line 126
            tmp___224 = tmp___227;
          }
#line 126
          if (tmp___224) {
#line 128
            if (0) {
#line 128
              __s1_len___20 = strlen((char const   *)command);
#line 128
              __s2_len___20 = strlen("listclients");
#line 128
              if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                     1U)) {
                goto _L___42;
              } else {
#line 128
                if (__s1_len___20 >= 4U) {
                  _L___42: /* CIL Label */ 
#line 128
                  if (! ((unsigned int )((void const   *)("listclients" + 1)) - (unsigned int )((void const   *)"listclients") ==
                         1U)) {
#line 128
                    tmp___218 = 1;
                  } else {
#line 128
                    if (__s2_len___20 >= 4U) {
#line 128
                      tmp___218 = 1;
                    } else {
#line 128
                      tmp___218 = 0;
                    }
                  }
                } else {
#line 128
                  tmp___218 = 0;
                }
              }
#line 128
              if (tmp___218) {
#line 128
                tmp___214 = __builtin_strcmp((char const   *)command, "listclients");
              } else {
#line 128
                tmp___217 = __builtin_strcmp((char const   *)command, "listclients");
#line 128
                tmp___214 = tmp___217;
              }
            } else {
#line 128
              tmp___217 = __builtin_strcmp((char const   *)command, "listclients");
#line 128
              tmp___214 = tmp___217;
            }
#line 128
            if (tmp___214) {
#line 130
              if (0) {
#line 130
                __s1_len___19 = strlen((char const   *)command);
#line 130
                __s2_len___19 = strlen("listclients.xsl");
#line 130
                if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                       1U)) {
                  goto _L___40;
                } else {
#line 130
                  if (__s1_len___19 >= 4U) {
                    _L___40: /* CIL Label */ 
#line 130
                    if (! ((unsigned int )((void const   *)("listclients.xsl" + 1)) -
                           (unsigned int )((void const   *)"listclients.xsl") == 1U)) {
#line 130
                      tmp___208 = 1;
                    } else {
#line 130
                      if (__s2_len___19 >= 4U) {
#line 130
                        tmp___208 = 1;
                      } else {
#line 130
                        tmp___208 = 0;
                      }
                    }
                  } else {
#line 130
                    tmp___208 = 0;
                  }
                }
#line 130
                if (tmp___208) {
#line 130
                  tmp___204 = __builtin_strcmp((char const   *)command, "listclients.xsl");
                } else {
#line 130
                  tmp___207 = __builtin_strcmp((char const   *)command, "listclients.xsl");
#line 130
                  tmp___204 = tmp___207;
                }
              } else {
#line 130
                tmp___207 = __builtin_strcmp((char const   *)command, "listclients.xsl");
#line 130
                tmp___204 = tmp___207;
              }
#line 130
              if (tmp___204) {
#line 132
                if (0) {
#line 132
                  __s1_len___18 = strlen((char const   *)command);
#line 132
                  __s2_len___18 = strlen("stats");
#line 132
                  if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                         1U)) {
                    goto _L___38;
                  } else {
#line 132
                    if (__s1_len___18 >= 4U) {
                      _L___38: /* CIL Label */ 
#line 132
                      if (! ((unsigned int )((void const   *)("stats" + 1)) - (unsigned int )((void const   *)"stats") ==
                             1U)) {
#line 132
                        tmp___198 = 1;
                      } else {
#line 132
                        if (__s2_len___18 >= 4U) {
#line 132
                          tmp___198 = 1;
                        } else {
#line 132
                          tmp___198 = 0;
                        }
                      }
                    } else {
#line 132
                      tmp___198 = 0;
                    }
                  }
#line 132
                  if (tmp___198) {
#line 132
                    tmp___194 = __builtin_strcmp((char const   *)command, "stats");
                  } else {
#line 132
                    tmp___197 = __builtin_strcmp((char const   *)command, "stats");
#line 132
                    tmp___194 = tmp___197;
                  }
                } else {
#line 132
                  tmp___197 = __builtin_strcmp((char const   *)command, "stats");
#line 132
                  tmp___194 = tmp___197;
                }
#line 132
                if (tmp___194) {
#line 134
                  if (0) {
#line 134
                    __s1_len___17 = strlen((char const   *)command);
#line 134
                    __s2_len___17 = strlen("stats.xsl");
#line 134
                    if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                           1U)) {
                      goto _L___36;
                    } else {
#line 134
                      if (__s1_len___17 >= 4U) {
                        _L___36: /* CIL Label */ 
#line 134
                        if (! ((unsigned int )((void const   *)("stats.xsl" + 1)) -
                               (unsigned int )((void const   *)"stats.xsl") == 1U)) {
#line 134
                          tmp___188 = 1;
                        } else {
#line 134
                          if (__s2_len___17 >= 4U) {
#line 134
                            tmp___188 = 1;
                          } else {
#line 134
                            tmp___188 = 0;
                          }
                        }
                      } else {
#line 134
                        tmp___188 = 0;
                      }
                    }
#line 134
                    if (tmp___188) {
#line 134
                      tmp___184 = __builtin_strcmp((char const   *)command, "stats.xsl");
                    } else {
#line 134
                      tmp___187 = __builtin_strcmp((char const   *)command, "stats.xsl");
#line 134
                      tmp___184 = tmp___187;
                    }
                  } else {
#line 134
                    tmp___187 = __builtin_strcmp((char const   *)command, "stats.xsl");
#line 134
                    tmp___184 = tmp___187;
                  }
#line 134
                  if (tmp___184) {
#line 136
                    if (0) {
#line 136
                      __s1_len___16 = strlen((char const   *)command);
#line 136
                      __s2_len___16 = strlen("stats.xml");
#line 136
                      if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                             1U)) {
                        goto _L___34;
                      } else {
#line 136
                        if (__s1_len___16 >= 4U) {
                          _L___34: /* CIL Label */ 
#line 136
                          if (! ((unsigned int )((void const   *)("stats.xml" + 1)) -
                                 (unsigned int )((void const   *)"stats.xml") == 1U)) {
#line 136
                            tmp___178 = 1;
                          } else {
#line 136
                            if (__s2_len___16 >= 4U) {
#line 136
                              tmp___178 = 1;
                            } else {
#line 136
                              tmp___178 = 0;
                            }
                          }
                        } else {
#line 136
                          tmp___178 = 0;
                        }
                      }
#line 136
                      if (tmp___178) {
#line 136
                        tmp___174 = __builtin_strcmp((char const   *)command, "stats.xml");
                      } else {
#line 136
                        tmp___177 = __builtin_strcmp((char const   *)command, "stats.xml");
#line 136
                        tmp___174 = tmp___177;
                      }
                    } else {
#line 136
                      tmp___177 = __builtin_strcmp((char const   *)command, "stats.xml");
#line 136
                      tmp___174 = tmp___177;
                    }
#line 136
                    if (tmp___174) {
#line 138
                      if (0) {
#line 138
                        __s1_len___15 = strlen((char const   *)command);
#line 138
                        __s2_len___15 = strlen("listmounts");
#line 138
                        if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) ==
                               1U)) {
                          goto _L___32;
                        } else {
#line 138
                          if (__s1_len___15 >= 4U) {
                            _L___32: /* CIL Label */ 
#line 138
                            if (! ((unsigned int )((void const   *)("listmounts" +
                                                                    1)) - (unsigned int )((void const   *)"listmounts") ==
                                   1U)) {
#line 138
                              tmp___168 = 1;
                            } else {
#line 138
                              if (__s2_len___15 >= 4U) {
#line 138
                                tmp___168 = 1;
                              } else {
#line 138
                                tmp___168 = 0;
                              }
                            }
                          } else {
#line 138
                            tmp___168 = 0;
                          }
                        }
#line 138
                        if (tmp___168) {
#line 138
                          tmp___164 = __builtin_strcmp((char const   *)command, "listmounts");
                        } else {
#line 138
                          tmp___167 = __builtin_strcmp((char const   *)command, "listmounts");
#line 138
                          tmp___164 = tmp___167;
                        }
                      } else {
#line 138
                        tmp___167 = __builtin_strcmp((char const   *)command, "listmounts");
#line 138
                        tmp___164 = tmp___167;
                      }
#line 138
                      if (tmp___164) {
#line 140
                        if (0) {
#line 140
                          __s1_len___14 = strlen((char const   *)command);
#line 140
                          __s2_len___14 = strlen("listmounts.xsl");
#line 140
                          if (! ((unsigned int )((void const   *)(command + 1)) -
                                 (unsigned int )((void const   *)command) == 1U)) {
                            goto _L___30;
                          } else {
#line 140
                            if (__s1_len___14 >= 4U) {
                              _L___30: /* CIL Label */ 
#line 140
                              if (! ((unsigned int )((void const   *)("listmounts.xsl" +
                                                                      1)) - (unsigned int )((void const   *)"listmounts.xsl") ==
                                     1U)) {
#line 140
                                tmp___158 = 1;
                              } else {
#line 140
                                if (__s2_len___14 >= 4U) {
#line 140
                                  tmp___158 = 1;
                                } else {
#line 140
                                  tmp___158 = 0;
                                }
                              }
                            } else {
#line 140
                              tmp___158 = 0;
                            }
                          }
#line 140
                          if (tmp___158) {
#line 140
                            tmp___154 = __builtin_strcmp((char const   *)command,
                                                         "listmounts.xsl");
                          } else {
#line 140
                            tmp___157 = __builtin_strcmp((char const   *)command,
                                                         "listmounts.xsl");
#line 140
                            tmp___154 = tmp___157;
                          }
                        } else {
#line 140
                          tmp___157 = __builtin_strcmp((char const   *)command, "listmounts.xsl");
#line 140
                          tmp___154 = tmp___157;
                        }
#line 140
                        if (tmp___154) {
#line 142
                          if (0) {
#line 142
                            __s1_len___13 = strlen((char const   *)command);
#line 142
                            __s2_len___13 = strlen("streamlist");
#line 142
                            if (! ((unsigned int )((void const   *)(command + 1)) -
                                   (unsigned int )((void const   *)command) == 1U)) {
                              goto _L___28;
                            } else {
#line 142
                              if (__s1_len___13 >= 4U) {
                                _L___28: /* CIL Label */ 
#line 142
                                if (! ((unsigned int )((void const   *)("streamlist" +
                                                                        1)) - (unsigned int )((void const   *)"streamlist") ==
                                       1U)) {
#line 142
                                  tmp___148 = 1;
                                } else {
#line 142
                                  if (__s2_len___13 >= 4U) {
#line 142
                                    tmp___148 = 1;
                                  } else {
#line 142
                                    tmp___148 = 0;
                                  }
                                }
                              } else {
#line 142
                                tmp___148 = 0;
                              }
                            }
#line 142
                            if (tmp___148) {
#line 142
                              tmp___144 = __builtin_strcmp((char const   *)command,
                                                           "streamlist");
                            } else {
#line 142
                              tmp___147 = __builtin_strcmp((char const   *)command,
                                                           "streamlist");
#line 142
                              tmp___144 = tmp___147;
                            }
                          } else {
#line 142
                            tmp___147 = __builtin_strcmp((char const   *)command,
                                                         "streamlist");
#line 142
                            tmp___144 = tmp___147;
                          }
#line 142
                          if (tmp___144) {
#line 144
                            if (0) {
#line 144
                              __s1_len___12 = strlen((char const   *)command);
#line 144
                              __s2_len___12 = strlen("streamlist.txt");
#line 144
                              if (! ((unsigned int )((void const   *)(command + 1)) -
                                     (unsigned int )((void const   *)command) == 1U)) {
                                goto _L___26;
                              } else {
#line 144
                                if (__s1_len___12 >= 4U) {
                                  _L___26: /* CIL Label */ 
#line 144
                                  if (! ((unsigned int )((void const   *)("streamlist.txt" +
                                                                          1)) - (unsigned int )((void const   *)"streamlist.txt") ==
                                         1U)) {
#line 144
                                    tmp___138 = 1;
                                  } else {
#line 144
                                    if (__s2_len___12 >= 4U) {
#line 144
                                      tmp___138 = 1;
                                    } else {
#line 144
                                      tmp___138 = 0;
                                    }
                                  }
                                } else {
#line 144
                                  tmp___138 = 0;
                                }
                              }
#line 144
                              if (tmp___138) {
#line 144
                                tmp___134 = __builtin_strcmp((char const   *)command,
                                                             "streamlist.txt");
                              } else {
#line 144
                                tmp___137 = __builtin_strcmp((char const   *)command,
                                                             "streamlist.txt");
#line 144
                                tmp___134 = tmp___137;
                              }
                            } else {
#line 144
                              tmp___137 = __builtin_strcmp((char const   *)command,
                                                           "streamlist.txt");
#line 144
                              tmp___134 = tmp___137;
                            }
#line 144
                            if (tmp___134) {
#line 146
                              if (0) {
#line 146
                                __s1_len___11 = strlen((char const   *)command);
#line 146
                                __s2_len___11 = strlen("moveclients");
#line 146
                                if (! ((unsigned int )((void const   *)(command +
                                                                        1)) - (unsigned int )((void const   *)command) ==
                                       1U)) {
                                  goto _L___24;
                                } else {
#line 146
                                  if (__s1_len___11 >= 4U) {
                                    _L___24: /* CIL Label */ 
#line 146
                                    if (! ((unsigned int )((void const   *)("moveclients" +
                                                                            1)) -
                                           (unsigned int )((void const   *)"moveclients") ==
                                           1U)) {
#line 146
                                      tmp___128 = 1;
                                    } else {
#line 146
                                      if (__s2_len___11 >= 4U) {
#line 146
                                        tmp___128 = 1;
                                      } else {
#line 146
                                        tmp___128 = 0;
                                      }
                                    }
                                  } else {
#line 146
                                    tmp___128 = 0;
                                  }
                                }
#line 146
                                if (tmp___128) {
#line 146
                                  tmp___124 = __builtin_strcmp((char const   *)command,
                                                               "moveclients");
                                } else {
#line 146
                                  tmp___127 = __builtin_strcmp((char const   *)command,
                                                               "moveclients");
#line 146
                                  tmp___124 = tmp___127;
                                }
                              } else {
#line 146
                                tmp___127 = __builtin_strcmp((char const   *)command,
                                                             "moveclients");
#line 146
                                tmp___124 = tmp___127;
                              }
#line 146
                              if (tmp___124) {
#line 148
                                if (0) {
#line 148
                                  __s1_len___10 = strlen((char const   *)command);
#line 148
                                  __s2_len___10 = strlen("moveclients.xsl");
#line 148
                                  if (! ((unsigned int )((void const   *)(command +
                                                                          1)) - (unsigned int )((void const   *)command) ==
                                         1U)) {
                                    goto _L___22;
                                  } else {
#line 148
                                    if (__s1_len___10 >= 4U) {
                                      _L___22: /* CIL Label */ 
#line 148
                                      if (! ((unsigned int )((void const   *)("moveclients.xsl" +
                                                                              1)) -
                                             (unsigned int )((void const   *)"moveclients.xsl") ==
                                             1U)) {
#line 148
                                        tmp___118 = 1;
                                      } else {
#line 148
                                        if (__s2_len___10 >= 4U) {
#line 148
                                          tmp___118 = 1;
                                        } else {
#line 148
                                          tmp___118 = 0;
                                        }
                                      }
                                    } else {
#line 148
                                      tmp___118 = 0;
                                    }
                                  }
#line 148
                                  if (tmp___118) {
#line 148
                                    tmp___114 = __builtin_strcmp((char const   *)command,
                                                                 "moveclients.xsl");
                                  } else {
#line 148
                                    tmp___117 = __builtin_strcmp((char const   *)command,
                                                                 "moveclients.xsl");
#line 148
                                    tmp___114 = tmp___117;
                                  }
                                } else {
#line 148
                                  tmp___117 = __builtin_strcmp((char const   *)command,
                                                               "moveclients.xsl");
#line 148
                                  tmp___114 = tmp___117;
                                }
#line 148
                                if (tmp___114) {
#line 150
                                  if (0) {
#line 150
                                    __s1_len___9 = strlen((char const   *)command);
#line 150
                                    __s2_len___9 = strlen("killclient");
#line 150
                                    if (! ((unsigned int )((void const   *)(command +
                                                                            1)) -
                                           (unsigned int )((void const   *)command) ==
                                           1U)) {
                                      goto _L___20;
                                    } else {
#line 150
                                      if (__s1_len___9 >= 4U) {
                                        _L___20: /* CIL Label */ 
#line 150
                                        if (! ((unsigned int )((void const   *)("killclient" +
                                                                                1)) -
                                               (unsigned int )((void const   *)"killclient") ==
                                               1U)) {
#line 150
                                          tmp___108 = 1;
                                        } else {
#line 150
                                          if (__s2_len___9 >= 4U) {
#line 150
                                            tmp___108 = 1;
                                          } else {
#line 150
                                            tmp___108 = 0;
                                          }
                                        }
                                      } else {
#line 150
                                        tmp___108 = 0;
                                      }
                                    }
#line 150
                                    if (tmp___108) {
#line 150
                                      tmp___104 = __builtin_strcmp((char const   *)command,
                                                                   "killclient");
                                    } else {
#line 150
                                      tmp___107 = __builtin_strcmp((char const   *)command,
                                                                   "killclient");
#line 150
                                      tmp___104 = tmp___107;
                                    }
                                  } else {
#line 150
                                    tmp___107 = __builtin_strcmp((char const   *)command,
                                                                 "killclient");
#line 150
                                    tmp___104 = tmp___107;
                                  }
#line 150
                                  if (tmp___104) {
#line 152
                                    if (0) {
#line 152
                                      __s1_len___8 = strlen((char const   *)command);
#line 152
                                      __s2_len___8 = strlen("killclient.xsl");
#line 152
                                      if (! ((unsigned int )((void const   *)(command +
                                                                              1)) -
                                             (unsigned int )((void const   *)command) ==
                                             1U)) {
                                        goto _L___18;
                                      } else {
#line 152
                                        if (__s1_len___8 >= 4U) {
                                          _L___18: /* CIL Label */ 
#line 152
                                          if (! ((unsigned int )((void const   *)("killclient.xsl" +
                                                                                  1)) -
                                                 (unsigned int )((void const   *)"killclient.xsl") ==
                                                 1U)) {
#line 152
                                            tmp___98 = 1;
                                          } else {
#line 152
                                            if (__s2_len___8 >= 4U) {
#line 152
                                              tmp___98 = 1;
                                            } else {
#line 152
                                              tmp___98 = 0;
                                            }
                                          }
                                        } else {
#line 152
                                          tmp___98 = 0;
                                        }
                                      }
#line 152
                                      if (tmp___98) {
#line 152
                                        tmp___94 = __builtin_strcmp((char const   *)command,
                                                                    "killclient.xsl");
                                      } else {
#line 152
                                        tmp___97 = __builtin_strcmp((char const   *)command,
                                                                    "killclient.xsl");
#line 152
                                        tmp___94 = tmp___97;
                                      }
                                    } else {
#line 152
                                      tmp___97 = __builtin_strcmp((char const   *)command,
                                                                  "killclient.xsl");
#line 152
                                      tmp___94 = tmp___97;
                                    }
#line 152
                                    if (tmp___94) {
#line 154
                                      if (0) {
#line 154
                                        __s1_len___7 = strlen((char const   *)command);
#line 154
                                        __s2_len___7 = strlen("killsource");
#line 154
                                        if (! ((unsigned int )((void const   *)(command +
                                                                                1)) -
                                               (unsigned int )((void const   *)command) ==
                                               1U)) {
                                          goto _L___16;
                                        } else {
#line 154
                                          if (__s1_len___7 >= 4U) {
                                            _L___16: /* CIL Label */ 
#line 154
                                            if (! ((unsigned int )((void const   *)("killsource" +
                                                                                    1)) -
                                                   (unsigned int )((void const   *)"killsource") ==
                                                   1U)) {
#line 154
                                              tmp___88 = 1;
                                            } else {
#line 154
                                              if (__s2_len___7 >= 4U) {
#line 154
                                                tmp___88 = 1;
                                              } else {
#line 154
                                                tmp___88 = 0;
                                              }
                                            }
                                          } else {
#line 154
                                            tmp___88 = 0;
                                          }
                                        }
#line 154
                                        if (tmp___88) {
#line 154
                                          tmp___84 = __builtin_strcmp((char const   *)command,
                                                                      "killsource");
                                        } else {
#line 154
                                          tmp___87 = __builtin_strcmp((char const   *)command,
                                                                      "killsource");
#line 154
                                          tmp___84 = tmp___87;
                                        }
                                      } else {
#line 154
                                        tmp___87 = __builtin_strcmp((char const   *)command,
                                                                    "killsource");
#line 154
                                        tmp___84 = tmp___87;
                                      }
#line 154
                                      if (tmp___84) {
#line 156
                                        if (0) {
#line 156
                                          __s1_len___6 = strlen((char const   *)command);
#line 156
                                          __s2_len___6 = strlen("killsource.xsl");
#line 156
                                          if (! ((unsigned int )((void const   *)(command +
                                                                                  1)) -
                                                 (unsigned int )((void const   *)command) ==
                                                 1U)) {
                                            goto _L___14;
                                          } else {
#line 156
                                            if (__s1_len___6 >= 4U) {
                                              _L___14: /* CIL Label */ 
#line 156
                                              if (! ((unsigned int )((void const   *)("killsource.xsl" +
                                                                                      1)) -
                                                     (unsigned int )((void const   *)"killsource.xsl") ==
                                                     1U)) {
#line 156
                                                tmp___78 = 1;
                                              } else {
#line 156
                                                if (__s2_len___6 >= 4U) {
#line 156
                                                  tmp___78 = 1;
                                                } else {
#line 156
                                                  tmp___78 = 0;
                                                }
                                              }
                                            } else {
#line 156
                                              tmp___78 = 0;
                                            }
                                          }
#line 156
                                          if (tmp___78) {
#line 156
                                            tmp___74 = __builtin_strcmp((char const   *)command,
                                                                        "killsource.xsl");
                                          } else {
#line 156
                                            tmp___77 = __builtin_strcmp((char const   *)command,
                                                                        "killsource.xsl");
#line 156
                                            tmp___74 = tmp___77;
                                          }
                                        } else {
#line 156
                                          tmp___77 = __builtin_strcmp((char const   *)command,
                                                                      "killsource.xsl");
#line 156
                                          tmp___74 = tmp___77;
                                        }
#line 156
                                        if (tmp___74) {
#line 158
                                          if (0) {
#line 158
                                            __s1_len___5 = strlen((char const   *)command);
#line 158
                                            __s2_len___5 = strlen("manageauth");
#line 158
                                            if (! ((unsigned int )((void const   *)(command +
                                                                                    1)) -
                                                   (unsigned int )((void const   *)command) ==
                                                   1U)) {
                                              goto _L___12;
                                            } else {
#line 158
                                              if (__s1_len___5 >= 4U) {
                                                _L___12: /* CIL Label */ 
#line 158
                                                if (! ((unsigned int )((void const   *)("manageauth" +
                                                                                        1)) -
                                                       (unsigned int )((void const   *)"manageauth") ==
                                                       1U)) {
#line 158
                                                  tmp___68 = 1;
                                                } else {
#line 158
                                                  if (__s2_len___5 >= 4U) {
#line 158
                                                    tmp___68 = 1;
                                                  } else {
#line 158
                                                    tmp___68 = 0;
                                                  }
                                                }
                                              } else {
#line 158
                                                tmp___68 = 0;
                                              }
                                            }
#line 158
                                            if (tmp___68) {
#line 158
                                              tmp___64 = __builtin_strcmp((char const   *)command,
                                                                          "manageauth");
                                            } else {
#line 158
                                              tmp___67 = __builtin_strcmp((char const   *)command,
                                                                          "manageauth");
#line 158
                                              tmp___64 = tmp___67;
                                            }
                                          } else {
#line 158
                                            tmp___67 = __builtin_strcmp((char const   *)command,
                                                                        "manageauth");
#line 158
                                            tmp___64 = tmp___67;
                                          }
#line 158
                                          if (tmp___64) {
#line 160
                                            if (0) {
#line 160
                                              __s1_len___4 = strlen((char const   *)command);
#line 160
                                              __s2_len___4 = strlen("manageauth.xsl");
#line 160
                                              if (! ((unsigned int )((void const   *)(command +
                                                                                      1)) -
                                                     (unsigned int )((void const   *)command) ==
                                                     1U)) {
                                                goto _L___10;
                                              } else {
#line 160
                                                if (__s1_len___4 >= 4U) {
                                                  _L___10: /* CIL Label */ 
#line 160
                                                  if (! ((unsigned int )((void const   *)("manageauth.xsl" +
                                                                                          1)) -
                                                         (unsigned int )((void const   *)"manageauth.xsl") ==
                                                         1U)) {
#line 160
                                                    tmp___58 = 1;
                                                  } else {
#line 160
                                                    if (__s2_len___4 >= 4U) {
#line 160
                                                      tmp___58 = 1;
                                                    } else {
#line 160
                                                      tmp___58 = 0;
                                                    }
                                                  }
                                                } else {
#line 160
                                                  tmp___58 = 0;
                                                }
                                              }
#line 160
                                              if (tmp___58) {
#line 160
                                                tmp___54 = __builtin_strcmp((char const   *)command,
                                                                            "manageauth.xsl");
                                              } else {
#line 160
                                                tmp___57 = __builtin_strcmp((char const   *)command,
                                                                            "manageauth.xsl");
#line 160
                                                tmp___54 = tmp___57;
                                              }
                                            } else {
#line 160
                                              tmp___57 = __builtin_strcmp((char const   *)command,
                                                                          "manageauth.xsl");
#line 160
                                              tmp___54 = tmp___57;
                                            }
#line 160
                                            if (tmp___54) {
#line 162
                                              if (0) {
#line 162
                                                __s1_len___3 = strlen((char const   *)command);
#line 162
                                                __s2_len___3 = strlen("updatemetadata");
#line 162
                                                if (! ((unsigned int )((void const   *)(command +
                                                                                        1)) -
                                                       (unsigned int )((void const   *)command) ==
                                                       1U)) {
                                                  goto _L___8;
                                                } else {
#line 162
                                                  if (__s1_len___3 >= 4U) {
                                                    _L___8: /* CIL Label */ 
#line 162
                                                    if (! ((unsigned int )((void const   *)("updatemetadata" +
                                                                                            1)) -
                                                           (unsigned int )((void const   *)"updatemetadata") ==
                                                           1U)) {
#line 162
                                                      tmp___48 = 1;
                                                    } else {
#line 162
                                                      if (__s2_len___3 >= 4U) {
#line 162
                                                        tmp___48 = 1;
                                                      } else {
#line 162
                                                        tmp___48 = 0;
                                                      }
                                                    }
                                                  } else {
#line 162
                                                    tmp___48 = 0;
                                                  }
                                                }
#line 162
                                                if (tmp___48) {
#line 162
                                                  tmp___44 = __builtin_strcmp((char const   *)command,
                                                                              "updatemetadata");
                                                } else {
#line 162
                                                  tmp___47 = __builtin_strcmp((char const   *)command,
                                                                              "updatemetadata");
#line 162
                                                  tmp___44 = tmp___47;
                                                }
                                              } else {
#line 162
                                                tmp___47 = __builtin_strcmp((char const   *)command,
                                                                            "updatemetadata");
#line 162
                                                tmp___44 = tmp___47;
                                              }
#line 162
                                              if (tmp___44) {
#line 164
                                                if (0) {
#line 164
                                                  __s1_len___2 = strlen((char const   *)command);
#line 164
                                                  __s2_len___2 = strlen("updatemetadata.xsl");
#line 164
                                                  if (! ((unsigned int )((void const   *)(command +
                                                                                          1)) -
                                                         (unsigned int )((void const   *)command) ==
                                                         1U)) {
                                                    goto _L___6;
                                                  } else {
#line 164
                                                    if (__s1_len___2 >= 4U) {
                                                      _L___6: /* CIL Label */ 
#line 164
                                                      if (! ((unsigned int )((void const   *)("updatemetadata.xsl" +
                                                                                              1)) -
                                                             (unsigned int )((void const   *)"updatemetadata.xsl") ==
                                                             1U)) {
#line 164
                                                        tmp___38 = 1;
                                                      } else {
#line 164
                                                        if (__s2_len___2 >= 4U) {
#line 164
                                                          tmp___38 = 1;
                                                        } else {
#line 164
                                                          tmp___38 = 0;
                                                        }
                                                      }
                                                    } else {
#line 164
                                                      tmp___38 = 0;
                                                    }
                                                  }
#line 164
                                                  if (tmp___38) {
#line 164
                                                    tmp___34 = __builtin_strcmp((char const   *)command,
                                                                                "updatemetadata.xsl");
                                                  } else {
#line 164
                                                    tmp___37 = __builtin_strcmp((char const   *)command,
                                                                                "updatemetadata.xsl");
#line 164
                                                    tmp___34 = tmp___37;
                                                  }
                                                } else {
#line 164
                                                  tmp___37 = __builtin_strcmp((char const   *)command,
                                                                              "updatemetadata.xsl");
#line 164
                                                  tmp___34 = tmp___37;
                                                }
#line 164
                                                if (tmp___34) {
#line 166
                                                  if (0) {
#line 166
                                                    __s1_len___1 = strlen((char const   *)command);
#line 166
                                                    __s2_len___1 = strlen("buildm3u");
#line 166
                                                    if (! ((unsigned int )((void const   *)(command +
                                                                                            1)) -
                                                           (unsigned int )((void const   *)command) ==
                                                           1U)) {
                                                      goto _L___4;
                                                    } else {
#line 166
                                                      if (__s1_len___1 >= 4U) {
                                                        _L___4: /* CIL Label */ 
#line 166
                                                        if (! ((unsigned int )((void const   *)("buildm3u" +
                                                                                                1)) -
                                                               (unsigned int )((void const   *)"buildm3u") ==
                                                               1U)) {
#line 166
                                                          tmp___28 = 1;
                                                        } else {
#line 166
                                                          if (__s2_len___1 >= 4U) {
#line 166
                                                            tmp___28 = 1;
                                                          } else {
#line 166
                                                            tmp___28 = 0;
                                                          }
                                                        }
                                                      } else {
#line 166
                                                        tmp___28 = 0;
                                                      }
                                                    }
#line 166
                                                    if (tmp___28) {
#line 166
                                                      tmp___24 = __builtin_strcmp((char const   *)command,
                                                                                  "buildm3u");
                                                    } else {
#line 166
                                                      tmp___27 = __builtin_strcmp((char const   *)command,
                                                                                  "buildm3u");
#line 166
                                                      tmp___24 = tmp___27;
                                                    }
                                                  } else {
#line 166
                                                    tmp___27 = __builtin_strcmp((char const   *)command,
                                                                                "buildm3u");
#line 166
                                                    tmp___24 = tmp___27;
                                                  }
#line 166
                                                  if (tmp___24) {
#line 168
                                                    if (0) {
#line 168
                                                      __s1_len___0 = strlen((char const   *)command);
#line 168
                                                      __s2_len___0 = strlen("");
#line 168
                                                      if (! ((unsigned int )((void const   *)(command +
                                                                                              1)) -
                                                             (unsigned int )((void const   *)command) ==
                                                             1U)) {
                                                        goto _L___2;
                                                      } else {
#line 168
                                                        if (__s1_len___0 >= 4U) {
                                                          _L___2: /* CIL Label */ 
#line 168
                                                          if (! ((unsigned int )((void const   *)("" +
                                                                                                  1)) -
                                                                 (unsigned int )((void const   *)"") ==
                                                                 1U)) {
#line 168
                                                            tmp___18 = 1;
                                                          } else {
#line 168
                                                            if (__s2_len___0 >= 4U) {
#line 168
                                                              tmp___18 = 1;
                                                            } else {
#line 168
                                                              tmp___18 = 0;
                                                            }
                                                          }
                                                        } else {
#line 168
                                                          tmp___18 = 0;
                                                        }
                                                      }
#line 168
                                                      if (tmp___18) {
#line 168
                                                        tmp___14 = __builtin_strcmp((char const   *)command,
                                                                                    "");
                                                      } else {
#line 168
                                                        tmp___17 = __builtin_strcmp((char const   *)command,
                                                                                    "");
#line 168
                                                        tmp___14 = tmp___17;
                                                      }
                                                    } else {
#line 168
                                                      tmp___17 = __builtin_strcmp((char const   *)command,
                                                                                  "");
#line 168
                                                      tmp___14 = tmp___17;
                                                    }
#line 168
                                                    if (tmp___14) {
#line 170
                                                      if (0) {
#line 170
                                                        __s1_len = strlen((char const   *)command);
#line 170
                                                        __s2_len = strlen("");
#line 170
                                                        if (! ((unsigned int )((void const   *)(command +
                                                                                                1)) -
                                                               (unsigned int )((void const   *)command) ==
                                                               1U)) {
                                                          goto _L___0;
                                                        } else {
#line 170
                                                          if (__s1_len >= 4U) {
                                                            _L___0: /* CIL Label */ 
#line 170
                                                            if (! ((unsigned int )((void const   *)("" +
                                                                                                    1)) -
                                                                   (unsigned int )((void const   *)"") ==
                                                                   1U)) {
#line 170
                                                              tmp___8 = 1;
                                                            } else {
#line 170
                                                              if (__s2_len >= 4U) {
#line 170
                                                                tmp___8 = 1;
                                                              } else {
#line 170
                                                                tmp___8 = 0;
                                                              }
                                                            }
                                                          } else {
#line 170
                                                            tmp___8 = 0;
                                                          }
                                                        }
#line 170
                                                        if (tmp___8) {
#line 170
                                                          tmp___4 = __builtin_strcmp((char const   *)command,
                                                                                     "");
                                                        } else {
#line 170
                                                          tmp___7 = __builtin_strcmp((char const   *)command,
                                                                                     "");
#line 170
                                                          tmp___4 = tmp___7;
                                                        }
                                                      } else {
#line 170
                                                        tmp___7 = __builtin_strcmp((char const   *)command,
                                                                                   "");
#line 170
                                                        tmp___4 = tmp___7;
                                                      }
#line 170
                                                      if (tmp___4) {
#line 173
                                                        return (-1);
                                                      } else {
#line 171
                                                        return (202);
                                                      }
                                                    } else {
#line 169
                                                      return (202);
                                                    }
                                                  } else {
#line 167
                                                    return (501);
                                                  }
                                                } else {
#line 165
                                                  return (56);
                                                }
                                              } else {
#line 163
                                                return (7);
                                              }
                                            } else {
#line 161
                                              return (55);
                                            }
                                          } else {
#line 159
                                            return (5);
                                          }
                                        } else {
#line 157
                                          return (402);
                                        }
                                      } else {
#line 155
                                        return (302);
                                      }
                                    } else {
#line 153
                                      return (401);
                                    }
                                  } else {
#line 151
                                    return (301);
                                  }
                                } else {
#line 149
                                  return (54);
                                }
                              } else {
#line 147
                                return (4);
                              }
                            } else {
#line 145
                              return (104);
                            }
                          } else {
#line 143
                            return (103);
                          }
                        } else {
#line 141
                          return (201);
                        }
                      } else {
#line 139
                        return (101);
                      }
                    } else {
#line 137
                      return (102);
                    }
                  } else {
#line 135
                    return (202);
                  }
                } else {
#line 133
                  return (102);
                }
              } else {
#line 131
                return (53);
              }
            } else {
#line 129
              return (3);
            }
          } else {
#line 127
            return (6);
          }
        } else {
#line 125
          return (57);
        }
      } else {
#line 123
        return (2);
      }
    } else {
#line 121
      return (50);
    }
  } else {
#line 119
    return (1);
  }
}
}
#line 176
static void command_fallback(client_t *client , source_t *source , int response ) ;
#line 177
static void command_metadata(client_t *client , source_t *source , int response ) ;
#line 178
static void command_shoutcast_metadata(client_t *client , source_t *source ) ;
#line 179
static void command_show_listeners(client_t *client , source_t *source , int response ) ;
#line 181
static void command_move_clients(client_t *client , source_t *source , int response ) ;
#line 183
static void command_stats(client_t *client , int response ) ;
#line 184
static void command_list_mounts(client_t *client , int response ) ;
#line 185
static void command_kill_client(client_t *client , source_t *source , int response ) ;
#line 187
static void command_manageauth(client_t *client , source_t *source , int response ) ;
#line 189
static void command_buildm3u(client_t *client , source_t *source , int response ) ;
#line 191
static void command_kill_source(client_t *client , source_t *source , int response ) ;
#line 193
static void command_updatemetadata(client_t *client , source_t *source , int response ) ;
#line 195
static void admin_handle_mount_request(client_t *client , source_t *source , int command ) ;
#line 197
static void admin_handle_general_request(client_t *client , int command ) ;
#line 198
static void admin_send_response(xmlDocPtr doc , client_t *client , int response ,
                                char *xslt_template ) ;
#line 204 "admin.c"
xmlDocPtr admin_build_sourcelist(char const   *mount ) 
{ avl_node *node ;
  source_t *source ;
  xmlNodePtr xmlnode ;
  xmlNodePtr srcnode ;
  xmlDocPtr doc ;
  char buf[22] ;
  time_t now___0 ;
  time_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  ice_config_t *config ;
  mount_proxy *mountinfo ;
  char const   *tmp___10 ;

  {
#line 211
  tmp = time((time_t *)((void *)0));
#line 211
  now___0 = tmp;
#line 213
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 214
  xmlnode = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"icestats",
                          (xmlChar const   *)((void *)0));
#line 215
  xmlDocSetRootElement(doc, xmlnode);
#line 217
  if (mount) {
#line 218
    xmlNewChild(xmlnode, (xmlNs *)((void *)0), (xmlChar const   *)"current_source",
                (xmlChar const   *)mount);
  }
#line 221
  node = avl_get_first(global.source_tree);
#line 222
  while (node) {
#line 223
    source = (source_t *)node->key;
#line 224
    if (mount) {
#line 224
      if (0) {
#line 224
        __s1_len = strlen(mount);
#line 224
        __s2_len = strlen((char const   *)source->mount);
#line 224
        if (! ((unsigned int )((void const   *)(mount + 1)) - (unsigned int )((void const   *)mount) ==
               1U)) {
          goto _L___0;
        } else {
#line 224
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 224
            if (! ((unsigned int )((void const   *)(source->mount + 1)) - (unsigned int )((void const   *)source->mount) ==
                   1U)) {
#line 224
              tmp___9 = 1;
            } else {
#line 224
              if (__s2_len >= 4U) {
#line 224
                tmp___9 = 1;
              } else {
#line 224
                tmp___9 = 0;
              }
            }
          } else {
#line 224
            tmp___9 = 0;
          }
        }
#line 224
        if (tmp___9) {
#line 224
          tmp___5 = __builtin_strcmp(mount, (char const   *)source->mount);
        } else {
#line 224
          tmp___8 = __builtin_strcmp(mount, (char const   *)source->mount);
#line 224
          tmp___5 = tmp___8;
        }
      } else {
#line 224
        tmp___8 = __builtin_strcmp(mount, (char const   *)source->mount);
#line 224
        tmp___5 = tmp___8;
      }
#line 224
      if (tmp___5 == 0) {
#line 226
        node = avl_get_next(node);
#line 227
        continue;
      }
    }
#line 230
    if (source->running) {
      goto _L___1;
    } else {
#line 230
      if (source->on_demand) {
        _L___1: /* CIL Label */ 
#line 235
        srcnode = xmlNewChild(xmlnode, (xmlNs *)((void *)0), (xmlChar const   *)"source",
                              (xmlChar const   *)((void *)0));
#line 236
        xmlSetProp(srcnode, (xmlChar const   *)"mount", (xmlChar const   *)source->mount);
#line 238
        if ((unsigned int )source->fallback_mount != (unsigned int )((void *)0)) {
#line 238
          tmp___10 = (char const   *)source->fallback_mount;
        } else {
#line 238
          tmp___10 = "";
        }
#line 238
        xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"fallback",
                    (xmlChar const   *)tmp___10);
#line 241
        snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%lu",
                 source->listeners);
#line 242
        xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"listeners",
                    (xmlChar const   *)(buf));
#line 244
        config = config_get_config();
#line 245
        mountinfo = config_find_mount(config, (char const   *)source->mount);
#line 246
        if (mountinfo) {
#line 246
          if (mountinfo->auth) {
#line 248
            xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"authenticator",
                        (xmlChar const   *)(mountinfo->auth)->type);
          }
        }
#line 251
        config_release_config();
#line 253
        if (source->running) {
#line 255
          if (source->client) {
#line 257
            snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%lu",
                     (unsigned long )(now___0 - (source->con)->con_time));
#line 259
            xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"Connected",
                        (xmlChar const   *)(buf));
          }
#line 261
          xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"content-type",
                      (xmlChar const   *)(source->format)->contenttype);
        }
      }
    }
#line 265
    node = avl_get_next(node);
  }
#line 267
  return (doc);
}
}
#line 270 "admin.c"
static void admin_send_response(xmlDocPtr doc , client_t *client , int response ,
                                char *xslt_template ) 
{ xmlChar *buff ;
  int len ;
  unsigned int buf_len ;
  char const   *http ;
  size_t tmp ;
  char *fullpath_xslt_template ;
  int fullpath_xslt_template_len ;
  ice_config_t *config ;
  ice_config_t *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 273
  if (response == 1) {
#line 275
    buff = (xmlChar *)((void *)0);
#line 276
    len = 0;
#line 278
    http = "HTTP/1.0 200 OK\r\nContent-Type: text/xml\r\nContent-Length: ";
#line 281
    xmlDocDumpMemory(doc, & buff, & len);
#line 282
    tmp = strlen(http);
#line 282
    buf_len = (tmp + (size_t )len) + 20U;
#line 283
    client_set_queue(client, (refbuf_t *)((void *)0));
#line 284
    client->refbuf = refbuf_new((unsigned long )buf_len);
#line 285
    len = snprintf((char * __restrict  )(client->refbuf)->data, buf_len, (char const   * __restrict  )"%s%d\r\n\r\n%s",
                   http, len, buff);
#line 286
    (client->refbuf)->len = (unsigned long )len;
#line 287
    ((*xmlFree))((void *)buff);
#line 288
    client->respcode = 200;
#line 289
    fserve_add_client(client, (FILE *)((void *)0));
  }
#line 291
  if (response == 2) {
#line 295
    tmp___0 = config_get_config();
#line 295
    config = tmp___0;
#line 297
    tmp___1 = strlen((char const   *)config->adminroot_dir);
#line 297
    tmp___2 = strlen((char const   *)xslt_template);
#line 297
    fullpath_xslt_template_len = (int )((tmp___1 + tmp___2) + 2U);
#line 299
    fullpath_xslt_template = (char *)malloc((unsigned int )fullpath_xslt_template_len);
#line 300
    snprintf((char * __restrict  )fullpath_xslt_template, (unsigned int )fullpath_xslt_template_len,
             (char const   * __restrict  )"%s%s%s", config->adminroot_dir, "/", xslt_template);
#line 302
    config_release_config();
#line 304
    log_write(errorlog, 4U, "admin/", "admin_send_response", "Sending XSLT (%s)",
              fullpath_xslt_template);
#line 305
    xslt_transform(doc, (char const   *)fullpath_xslt_template, client);
#line 306
    free((void *)fullpath_xslt_template);
  }
#line 308
  return;
}
}
#line 311 "admin.c"
void admin_handle_request(client_t *client , char *uri ) 
{ char *mount ;
  char *command_string ;
  int command ;
  int noauth ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;
  ice_config_t *config ;
  char *pass ;
  char *tmp___45 ;
  source_t *source ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;

  {
#line 315
  noauth = 0;
#line 317
  log_write(errorlog, 4U, "admin/", "admin_handle_request", "Admin request (%s)",
            uri);
#line 318
  if (0) {
#line 318
    __s1_len = strlen((char const   *)uri);
#line 318
    __s2_len = strlen("/admin.cgi");
#line 318
    if (! ((unsigned int )((void const   *)(uri + 1)) - (unsigned int )((void const   *)uri) ==
           1U)) {
      goto _L___0;
    } else {
#line 318
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 318
        if (! ((unsigned int )((void const   *)("/admin.cgi" + 1)) - (unsigned int )((void const   *)"/admin.cgi") ==
               1U)) {
#line 318
          tmp___8 = 1;
        } else {
#line 318
          if (__s2_len >= 4U) {
#line 318
            tmp___8 = 1;
          } else {
#line 318
            tmp___8 = 0;
          }
        }
      } else {
#line 318
        tmp___8 = 0;
      }
    }
#line 318
    if (tmp___8) {
#line 318
      tmp___4 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
    } else {
#line 318
      tmp___7 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
#line 318
      tmp___4 = tmp___7;
    }
  } else {
#line 318
    tmp___7 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
#line 318
    tmp___4 = tmp___7;
  }
#line 319
  if (! (tmp___4 == 0)) {
#line 319
    if (0) {
#line 319
      if (0) {
#line 319
        __s1_len___1 = strlen("/admin/");
#line 319
        __s2_len___1 = strlen((char const   *)uri);
#line 319
        if (! ((unsigned int )((void const   *)("/admin/" + 1)) - (unsigned int )((void const   *)"/admin/") ==
               1U)) {
          goto _L___4;
        } else {
#line 319
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 319
            if (! ((unsigned int )((void const   *)(uri + 1)) - (unsigned int )((void const   *)uri) ==
                   1U)) {
#line 319
              tmp___32 = 1;
            } else {
#line 319
              if (__s2_len___1 >= 4U) {
#line 319
                tmp___32 = 1;
              } else {
#line 319
                tmp___32 = 0;
              }
            }
          } else {
#line 319
            tmp___32 = 0;
          }
        }
#line 319
        if (tmp___32) {
#line 319
          tmp___28 = __builtin_strcmp("/admin/", (char const   *)uri);
        } else {
#line 319
          tmp___31 = __builtin_strcmp("/admin/", (char const   *)uri);
#line 319
          tmp___28 = tmp___31;
        }
      } else {
#line 319
        tmp___31 = __builtin_strcmp("/admin/", (char const   *)uri);
#line 319
        tmp___28 = tmp___31;
      }
#line 319
      tmp___22 = tmp___28;
    } else {
#line 319
      tmp___22 = strncmp("/admin/", (char const   *)uri, 7U);
    }
#line 319
    if (! (tmp___22 == 0)) {
#line 320
      log_write(errorlog, 1U, "admin/", "admin_handle_request", "Internal error: admin request isn\'t");
#line 321
      client_send_401(client);
#line 322
      return;
    }
  }
#line 325
  if (0) {
#line 325
    __s1_len___2 = strlen((char const   *)uri);
#line 325
    __s2_len___2 = strlen("/admin.cgi");
#line 325
    if (! ((unsigned int )((void const   *)(uri + 1)) - (unsigned int )((void const   *)uri) ==
           1U)) {
      goto _L___6;
    } else {
#line 325
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 325
        if (! ((unsigned int )((void const   *)("/admin.cgi" + 1)) - (unsigned int )((void const   *)"/admin.cgi") ==
               1U)) {
#line 325
          tmp___44 = 1;
        } else {
#line 325
          if (__s2_len___2 >= 4U) {
#line 325
            tmp___44 = 1;
          } else {
#line 325
            tmp___44 = 0;
          }
        }
      } else {
#line 325
        tmp___44 = 0;
      }
    }
#line 325
    if (tmp___44) {
#line 325
      tmp___40 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
    } else {
#line 325
      tmp___43 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
#line 325
      tmp___40 = tmp___43;
    }
  } else {
#line 325
    tmp___43 = __builtin_strcmp((char const   *)uri, "/admin.cgi");
#line 325
    tmp___40 = tmp___43;
  }
#line 325
  if (tmp___40 == 0) {
#line 326
    command_string = uri + 1;
  } else {
#line 329
    command_string = uri + 7;
  }
#line 332
  log_write(errorlog, 4U, "admin/", "admin_handle_request", "Got command (%s)", command_string);
#line 333
  command = admin_get_command(command_string);
#line 335
  if (command < 0) {
#line 336
    log_write(errorlog, 1U, "admin/", "admin_handle_request", "Error parsing command string or unrecognised command: %s",
              command_string);
#line 338
    client_send_400(client, (char *)"Unrecognised command");
#line 339
    return;
  }
#line 342
  if (command == 6) {
#line 345
    tmp___45 = httpp_get_query_param(client->parser, (char *)"pass");
#line 345
    pass = tmp___45;
#line 346
    if ((unsigned int )pass == (unsigned int )((void *)0)) {
#line 348
      client_send_400(client, (char *)"missing pass parameter");
#line 349
      return;
    }
#line 351
    config = config_get_config();
#line 352
    httpp_set_query_param(client->parser, (char *)"mount", config->shoutcast_mount);
#line 353
    httpp_setvar(client->parser, "__protocol", "ICY");
#line 354
    httpp_setvar(client->parser, "__icy_password", (char const   *)pass);
#line 355
    config_release_config();
  }
#line 358
  mount = httpp_get_query_param(client->parser, (char *)"mount");
#line 360
  if ((unsigned int )mount != (unsigned int )((void *)0)) {
#line 363
    if (command == 501) {
#line 364
      noauth = 1;
    }
#line 367
    if (! noauth) {
#line 368
      tmp___47 = connection_check_admin_pass(client->parser);
#line 368
      if (! tmp___47) {
#line 369
        tmp___46 = connection_check_source_pass(client->parser, (char const   *)mount);
#line 369
        if (! tmp___46) {
#line 370
          log_write(errorlog, 3U, "admin/", "admin_handle_request", "Bad or missing password on mount modification admin request (command: %s)",
                    command_string);
#line 372
          client_send_401(client);
#line 373
          return;
        }
      }
    }
#line 378
    avl_tree_rlock(global.source_tree);
#line 379
    source = source_find_mount_raw((char const   *)mount);
#line 381
    if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 383
      log_write(errorlog, 2U, "admin/", "admin_handle_request", "Admin command %s on non-existent source %s",
                command_string, mount);
#line 385
      avl_tree_unlock(global.source_tree);
#line 386
      client_send_400(client, (char *)"Source does not exist");
    } else {
#line 390
      if (source->running == 0) {
#line 390
        if (source->on_demand == 0) {
#line 392
          avl_tree_unlock(global.source_tree);
#line 393
          log_write(errorlog, 3U, "admin/", "admin_handle_request", "Received admin command %s on unavailable mount \"%s\"",
                    command_string, mount);
#line 395
          client_send_400(client, (char *)"Source is not available");
#line 396
          return;
        }
      }
#line 398
      if (command == 6) {
#line 398
        if (source->shoutcast_compat == 0) {
#line 401
          avl_tree_unlock(global.source_tree);
#line 402
          log_write(errorlog, 1U, "admin/", "admin_handle_request", "illegal change of metadata on non-shoutcast compatible stream");
#line 404
          client_send_400(client, (char *)"illegal metadata call");
#line 405
          return;
        }
      }
#line 407
      log_write(errorlog, 3U, "admin/", "admin_handle_request", "Received admin command %s on mount \"%s\"",
                command_string, mount);
#line 409
      admin_handle_mount_request(client, source, command);
#line 410
      avl_tree_unlock(global.source_tree);
    }
  } else {
#line 415
    if (command == 104) {
#line 419
      tmp___48 = connection_check_relay_pass(client->parser);
#line 419
      if (! tmp___48) {
#line 420
        log_write(errorlog, 3U, "admin/", "admin_handle_request", "Bad or missing password on admin command request (command: %s)",
                  command_string);
#line 422
        client_send_401(client);
#line 423
        return;
      }
    } else {
#line 427
      tmp___49 = connection_check_admin_pass(client->parser);
#line 427
      if (! tmp___49) {
#line 428
        log_write(errorlog, 3U, "admin/", "admin_handle_request", "Bad or missing password on admin command request (command: %s)",
                  command_string);
#line 430
        client_send_401(client);
#line 431
        return;
      }
    }
#line 435
    admin_handle_general_request(client, command);
  }
#line 437
  return;
}
}
#line 439 "admin.c"
static void admin_handle_general_request(client_t *client , int command ) 
{ 

  {
#line 441
  switch (command) {
  case 102: 
#line 443
  command_stats(client, 1);
#line 444
  break;
  case 101: 
#line 446
  command_list_mounts(client, 1);
#line 447
  break;
  case 103: 
#line 449
  command_list_mounts(client, 1);
#line 450
  break;
  case 104: 
#line 452
  command_list_mounts(client, 3);
#line 453
  break;
  case 202: 
#line 455
  command_stats(client, 2);
#line 456
  break;
  case 201: 
#line 458
  command_list_mounts(client, 2);
#line 459
  break;
  case 203: 
#line 461
  command_list_mounts(client, 2);
#line 462
  break;
  case 54: 
#line 464
  command_list_mounts(client, 2);
#line 465
  break;
  default: 
#line 467
  log_write(errorlog, 2U, "admin/", "admin_handle_general_request", "General admin request not recognised");
#line 468
  client_send_400(client, (char *)"Unknown admin request");
#line 469
  return;
  }
#line 471
  return;
}
}
#line 473 "admin.c"
static void admin_handle_mount_request(client_t *client , source_t *source , int command ) 
{ 

  {
#line 476
  switch (command) {
  case 1: 
#line 478
  command_fallback(client, source, 1);
#line 479
  break;
  case 2: 
#line 481
  command_metadata(client, source, 1);
#line 482
  break;
  case 57: 
#line 484
  command_metadata(client, source, 2);
#line 485
  break;
  case 6: 
#line 487
  command_shoutcast_metadata(client, source);
#line 488
  break;
  case 3: 
#line 490
  command_show_listeners(client, source, 1);
#line 491
  break;
  case 4: 
#line 493
  command_move_clients(client, source, 1);
#line 494
  break;
  case 301: 
#line 496
  command_kill_client(client, source, 1);
#line 497
  break;
  case 302: 
#line 499
  command_kill_source(client, source, 1);
#line 500
  break;
  case 50: 
#line 502
  command_fallback(client, source, 1);
#line 503
  break;
  case 53: 
#line 505
  command_show_listeners(client, source, 2);
#line 506
  break;
  case 54: 
#line 508
  command_move_clients(client, source, 2);
#line 509
  break;
  case 401: 
#line 511
  command_kill_client(client, source, 2);
#line 512
  break;
  case 402: 
#line 514
  command_kill_source(client, source, 2);
#line 515
  break;
  case 55: 
#line 517
  command_manageauth(client, source, 2);
#line 518
  break;
  case 5: 
#line 520
  command_manageauth(client, source, 1);
#line 521
  break;
  case 56: 
#line 523
  command_updatemetadata(client, source, 2);
#line 524
  break;
  case 7: 
#line 526
  command_updatemetadata(client, source, 1);
#line 527
  break;
  case 501: 
#line 529
  command_buildm3u(client, source, 1);
#line 530
  break;
  default: 
#line 532
  log_write(errorlog, 2U, "admin/", "admin_handle_mount_request", "Mount request not recognised");
#line 533
  client_send_400(client, (char *)"Mount request unknown");
#line 534
  break;
  }
#line 536
  return;
}
}
#line 549 "admin.c"
static void html_success(client_t *client , char *message ) 
{ 

  {
#line 551
  client->respcode = 200;
#line 552
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n<html><head><title>Admin request successful</title></head><body><p>%s</p></body></html>",
           message);
#line 556
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 557
  fserve_add_client(client, (FILE *)((void *)0));
#line 558
  return;
}
}
#line 561 "admin.c"
static void command_move_clients(client_t *client , source_t *source , int response ) 
{ char *dest_source ;
  source_t *dest ;
  xmlDocPtr doc ;
  xmlNodePtr node ;
  char buf[255] ;
  int parameters_passed ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 569
  parameters_passed = 0;
#line 571
  log_write(errorlog, 4U, "admin/", "command_move_clients", "Doing optional check");
#line 572
  dest_source = httpp_get_query_param(client->parser, (char *)"destination");
#line 572
  if (dest_source) {
#line 573
    parameters_passed = 1;
  }
#line 575
  log_write(errorlog, 4U, "admin/", "command_move_clients", "Done optional check (%d)",
            parameters_passed);
#line 576
  if (! parameters_passed) {
#line 577
    doc = admin_build_sourcelist((char const   *)source->mount);
#line 578
    admin_send_response(doc, client, response, (char *)"moveclients.xsl");
#line 580
    xmlFreeDoc(doc);
#line 581
    return;
  }
#line 584
  dest = source_find_mount((char const   *)dest_source);
#line 586
  if ((unsigned int )dest == (unsigned int )((void *)0)) {
#line 588
    client_send_400(client, (char *)"No such destination");
#line 589
    return;
  }
#line 592
  if (0) {
#line 592
    __s1_len = strlen((char const   *)dest->mount);
#line 592
    __s2_len = strlen((char const   *)source->mount);
#line 592
    if (! ((unsigned int )((void const   *)(dest->mount + 1)) - (unsigned int )((void const   *)dest->mount) ==
           1U)) {
      goto _L___0;
    } else {
#line 592
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 592
        if (! ((unsigned int )((void const   *)(source->mount + 1)) - (unsigned int )((void const   *)source->mount) ==
               1U)) {
#line 592
          tmp___8 = 1;
        } else {
#line 592
          if (__s2_len >= 4U) {
#line 592
            tmp___8 = 1;
          } else {
#line 592
            tmp___8 = 0;
          }
        }
      } else {
#line 592
        tmp___8 = 0;
      }
    }
#line 592
    if (tmp___8) {
#line 592
      tmp___4 = __builtin_strcmp((char const   *)dest->mount, (char const   *)source->mount);
    } else {
#line 592
      tmp___7 = __builtin_strcmp((char const   *)dest->mount, (char const   *)source->mount);
#line 592
      tmp___4 = tmp___7;
    }
  } else {
#line 592
    tmp___7 = __builtin_strcmp((char const   *)dest->mount, (char const   *)source->mount);
#line 592
    tmp___4 = tmp___7;
  }
#line 592
  if (tmp___4 == 0) {
#line 594
    client_send_400(client, (char *)"supplied mountpoints are identical");
#line 595
    return;
  }
#line 598
  if (dest->running == 0) {
#line 598
    if (dest->on_demand == 0) {
#line 600
      client_send_400(client, (char *)"Destination not running");
#line 601
      return;
    }
  }
#line 604
  log_write(errorlog, 3U, "admin/", "command_move_clients", "source is \"%s\", destination is \"%s\"",
            source->mount, dest->mount);
#line 606
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 607
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"iceresponse",
                       (xmlChar const   *)((void *)0));
#line 608
  xmlDocSetRootElement(doc, node);
#line 610
  source_move_clients(source, dest);
#line 612
  memset((void *)(buf), '\000', sizeof(buf));
#line 613
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"Clients moved from %s to %s",
           source->mount, dest_source);
#line 615
  xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)(buf));
#line 616
  xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"1");
#line 618
  admin_send_response(doc, client, response, (char *)"response.xsl");
#line 620
  xmlFreeDoc(doc);
#line 621
  return;
}
}
#line 623 "admin.c"
static void command_show_listeners(client_t *client , source_t *source , int response ) 
{ xmlDocPtr doc ;
  xmlNodePtr node ;
  xmlNodePtr srcnode ;
  xmlNodePtr listenernode ;
  avl_node *client_node ;
  client_t *current ;
  char buf[22] ;
  char *userAgent ;
  time_t now___0 ;
  time_t tmp ;

  {
#line 631
  userAgent = (char *)((void *)0);
#line 632
  tmp = time((time_t *)((void *)0));
#line 632
  now___0 = tmp;
#line 634
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 635
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"icestats", (xmlChar const   *)((void *)0));
#line 636
  srcnode = xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"source", (xmlChar const   *)((void *)0));
#line 637
  xmlSetProp(srcnode, (xmlChar const   *)"mount", (xmlChar const   *)source->mount);
#line 638
  xmlDocSetRootElement(doc, node);
#line 640
  memset((void *)(buf), '\000', sizeof(buf));
#line 641
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%lu",
           source->listeners);
#line 642
  xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"Listeners", (xmlChar const   *)(buf));
#line 644
  avl_tree_rlock(source->client_tree);
#line 646
  client_node = avl_get_first(source->client_tree);
#line 647
  while (client_node) {
#line 648
    current = (client_t *)client_node->key;
#line 649
    listenernode = xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"listener",
                               (xmlChar const   *)((void *)0));
#line 650
    xmlNewChild(listenernode, (xmlNs *)((void *)0), (xmlChar const   *)"IP", (xmlChar const   *)(current->con)->ip);
#line 651
    userAgent = httpp_getvar(current->parser, "user-agent");
#line 652
    if (userAgent) {
#line 653
      xmlNewChild(listenernode, (xmlNs *)((void *)0), (xmlChar const   *)"UserAgent",
                  (xmlChar const   *)userAgent);
    } else {
#line 656
      xmlNewChild(listenernode, (xmlNs *)((void *)0), (xmlChar const   *)"UserAgent",
                  (xmlChar const   *)"Unknown");
    }
#line 658
    memset((void *)(buf), '\000', sizeof(buf));
#line 659
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%lu",
             (unsigned long )(now___0 - (current->con)->con_time));
#line 660
    xmlNewChild(listenernode, (xmlNs *)((void *)0), (xmlChar const   *)"Connected",
                (xmlChar const   *)(buf));
#line 661
    memset((void *)(buf), '\000', sizeof(buf));
#line 662
    snprintf((char * __restrict  )(buf), sizeof(buf) - 1U, (char const   * __restrict  )"%lu",
             (current->con)->id);
#line 663
    xmlNewChild(listenernode, (xmlNs *)((void *)0), (xmlChar const   *)"ID", (xmlChar const   *)(buf));
#line 664
    if (current->username) {
#line 665
      xmlNewChild(listenernode, (xmlNs *)((void *)0), (xmlChar const   *)"username",
                  (xmlChar const   *)current->username);
    }
#line 667
    client_node = avl_get_next(client_node);
  }
#line 670
  avl_tree_unlock(source->client_tree);
#line 671
  admin_send_response(doc, client, response, (char *)"listclients.xsl");
#line 673
  xmlFreeDoc(doc);
#line 674
  return;
}
}
#line 676 "admin.c"
static void command_buildm3u(client_t *client , source_t *source , int response ) 
{ char *username ;
  char *password ;
  ice_config_t *config ;

  {
#line 679
  username = (char *)((void *)0);
#line 680
  password = (char *)((void *)0);
#line 683
  while (1) {
#line 683
    username = httpp_get_query_param(client->parser, (char *)"username");
#line 683
    if ((unsigned int )username == (unsigned int )((void *)0)) {
#line 683
      client_send_400(client, (char *)"Missing parameter");
#line 683
      return;
    }
#line 683
    break;
  }
#line 684
  while (1) {
#line 684
    password = httpp_get_query_param(client->parser, (char *)"password");
#line 684
    if ((unsigned int )password == (unsigned int )((void *)0)) {
#line 684
      client_send_400(client, (char *)"Missing parameter");
#line 684
      return;
    }
#line 684
    break;
  }
#line 686
  client->respcode = 200;
#line 687
  config = config_get_config();
#line 688
  snprintf((char * __restrict  )(client->refbuf)->data, 4096U, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Type: audio/x-mpegurl\r\nContent-Disposition = attachment; filename=listen.m3u\r\n\r\nhttp://%s:%s@%s:%d%s\r\n",
           username, password, config->hostname, config->port, source->mount);
#line 699
  config_release_config();
#line 701
  (client->refbuf)->len = (unsigned long )strlen((char const   *)(client->refbuf)->data);
#line 702
  fserve_add_client(client, (FILE *)((void *)0));
#line 703
  return;
}
}
#line 706 "admin.c"
static void command_manageauth(client_t *client , source_t *source , int response ) 
{ xmlDocPtr doc ;
  xmlNodePtr node ;
  xmlNodePtr srcnode ;
  xmlNodePtr msgnode ;
  char *action ;
  char *username ;
  char *password ;
  char *message ;
  int ret ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;
  char *tmp___10 ;
  char *tmp___20 ;
  char *tmp___30 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  char *tmp___50 ;
  char *tmp___60 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___66 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 711
  action = (char *)((void *)0);
#line 712
  username = (char *)((void *)0);
#line 713
  password = (char *)((void *)0);
#line 714
  message = (char *)((void *)0);
#line 715
  ret = 1;
#line 716
  tmp = config_get_config();
#line 716
  config = tmp;
#line 717
  tmp___0 = config_find_mount(config, (char const   *)source->mount);
#line 717
  mountinfo = tmp___0;
#line 719
  action = httpp_get_query_param(client->parser, (char *)"action");
#line 719
  if (action) {
#line 720
    if ((unsigned int )mountinfo == (unsigned int )((void *)0)) {
#line 722
      log_write(errorlog, 2U, "admin/", "command_manageauth", "manage auth request for %s but no facility available",
                source->mount);
#line 723
      config_release_config();
#line 724
      client_send_404(client, (char *)"no such auth facility");
#line 725
      return;
    } else {
#line 720
      if ((unsigned int )mountinfo->auth == (unsigned int )((void *)0)) {
#line 722
        log_write(errorlog, 2U, "admin/", "command_manageauth", "manage auth request for %s but no facility available",
                  source->mount);
#line 723
        config_release_config();
#line 724
        client_send_404(client, (char *)"no such auth facility");
#line 725
        return;
      }
    }
#line 727
    if (0) {
#line 727
      __s1_len = strlen((char const   *)action);
#line 727
      __s2_len = strlen("add");
#line 727
      if (! ((unsigned int )((void const   *)(action + 1)) - (unsigned int )((void const   *)action) ==
             1U)) {
        goto _L___0;
      } else {
#line 727
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 727
          if (! ((unsigned int )((void const   *)("add" + 1)) - (unsigned int )((void const   *)"add") ==
                 1U)) {
#line 727
            tmp___40 = 1;
          } else {
#line 727
            if (__s2_len >= 4U) {
#line 727
              tmp___40 = 1;
            } else {
#line 727
              tmp___40 = 0;
            }
          }
        } else {
#line 727
          tmp___40 = 0;
        }
      }
#line 727
      if (tmp___40) {
#line 727
        tmp___36 = __builtin_strcmp((char const   *)action, "add");
      } else {
#line 727
        tmp___39 = __builtin_strcmp((char const   *)action, "add");
#line 727
        tmp___36 = tmp___39;
      }
    } else {
#line 727
      tmp___39 = __builtin_strcmp((char const   *)action, "add");
#line 727
      tmp___36 = tmp___39;
    }
#line 727
    if (! tmp___36) {
#line 728
      while (1) {
#line 728
        username = httpp_get_query_param(client->parser, (char *)"username");
#line 728
        if ((unsigned int )username == (unsigned int )((void *)0)) {
#line 728
          client_send_400(client, (char *)"Missing parameter");
#line 728
          return;
        }
#line 728
        break;
      }
#line 729
      while (1) {
#line 729
        password = httpp_get_query_param(client->parser, (char *)"password");
#line 729
        if ((unsigned int )password == (unsigned int )((void *)0)) {
#line 729
          client_send_400(client, (char *)"Missing parameter");
#line 729
          return;
        }
#line 729
        break;
      }
#line 730
      ret = (int )((*((mountinfo->auth)->adduser)))(mountinfo->auth, (char const   *)username,
                                                    (char const   *)password);
#line 731
      if (ret == 2) {
#line 732
        tmp___10 = __strdup("User add failed - check the icecast error log");
#line 732
        message = tmp___10;
      }
#line 734
      if (ret == 4) {
#line 735
        tmp___20 = __strdup("User added");
#line 735
        message = tmp___20;
      }
#line 737
      if (ret == 5) {
#line 738
        tmp___30 = __strdup("User already exists - not added");
#line 738
        message = tmp___30;
      }
    }
#line 741
    if (0) {
#line 741
      __s1_len___0 = strlen((char const   *)action);
#line 741
      __s2_len___0 = strlen("delete");
#line 741
      if (! ((unsigned int )((void const   *)(action + 1)) - (unsigned int )((void const   *)action) ==
             1U)) {
        goto _L___2;
      } else {
#line 741
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 741
          if (! ((unsigned int )((void const   *)("delete" + 1)) - (unsigned int )((void const   *)"delete") ==
                 1U)) {
#line 741
            tmp___70 = 1;
          } else {
#line 741
            if (__s2_len___0 >= 4U) {
#line 741
              tmp___70 = 1;
            } else {
#line 741
              tmp___70 = 0;
            }
          }
        } else {
#line 741
          tmp___70 = 0;
        }
      }
#line 741
      if (tmp___70) {
#line 741
        tmp___66 = __builtin_strcmp((char const   *)action, "delete");
      } else {
#line 741
        tmp___69 = __builtin_strcmp((char const   *)action, "delete");
#line 741
        tmp___66 = tmp___69;
      }
    } else {
#line 741
      tmp___69 = __builtin_strcmp((char const   *)action, "delete");
#line 741
      tmp___66 = tmp___69;
    }
#line 741
    if (! tmp___66) {
#line 742
      while (1) {
#line 742
        username = httpp_get_query_param(client->parser, (char *)"username");
#line 742
        if ((unsigned int )username == (unsigned int )((void *)0)) {
#line 742
          client_send_400(client, (char *)"Missing parameter");
#line 742
          return;
        }
#line 742
        break;
      }
#line 743
      ret = (int )((*((mountinfo->auth)->deleteuser)))(mountinfo->auth, (char const   *)username);
#line 744
      if (ret == 2) {
#line 745
        tmp___50 = __strdup("User delete failed - check the icecast error log");
#line 745
        message = tmp___50;
      }
#line 747
      if (ret == 6) {
#line 748
        tmp___60 = __strdup("User deleted");
#line 748
        message = tmp___60;
      }
    }
  }
#line 753
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 754
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"icestats", (xmlChar const   *)((void *)0));
#line 755
  srcnode = xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"source", (xmlChar const   *)((void *)0));
#line 756
  xmlSetProp(srcnode, (xmlChar const   *)"mount", (xmlChar const   *)source->mount);
#line 758
  if (message) {
#line 759
    msgnode = xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"iceresponse",
                          (xmlChar const   *)((void *)0));
#line 760
    xmlNewChild(msgnode, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)message);
  }
#line 763
  xmlDocSetRootElement(doc, node);
#line 765
  if (mountinfo) {
#line 765
    if (mountinfo->auth) {
#line 765
      if ((mountinfo->auth)->listuser) {
#line 766
        ((*((mountinfo->auth)->listuser)))(mountinfo->auth, srcnode);
      }
    }
  }
#line 768
  config_release_config();
#line 770
  admin_send_response(doc, client, response, (char *)"manageauth.xsl");
#line 772
  if (message) {
#line 773
    free((void *)message);
  }
#line 775
  xmlFreeDoc(doc);
#line 776
  return;
}
}
#line 778 "admin.c"
static void command_kill_source(client_t *client , source_t *source , int response ) 
{ xmlDocPtr doc ;
  xmlNodePtr node ;

  {
#line 784
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 785
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"iceresponse",
                       (xmlChar const   *)((void *)0));
#line 786
  xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)"Source Removed");
#line 787
  xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"1");
#line 788
  xmlDocSetRootElement(doc, node);
#line 790
  source->running = 0;
#line 792
  admin_send_response(doc, client, response, (char *)"response.xsl");
#line 794
  xmlFreeDoc(doc);
#line 795
  return;
}
}
#line 797 "admin.c"
static void command_kill_client(client_t *client , source_t *source , int response ) 
{ char *idtext ;
  int id ;
  client_t *listener ;
  xmlDocPtr doc ;
  xmlNodePtr node ;
  char buf[50] ;

  {
#line 805
  buf[0] = (char )'\000';
#line 807
  while (1) {
#line 807
    idtext = httpp_get_query_param(client->parser, (char *)"id");
#line 807
    if ((unsigned int )idtext == (unsigned int )((void *)0)) {
#line 807
      client_send_400(client, (char *)"Missing parameter");
#line 807
      return;
    }
#line 807
    break;
  }
#line 809
  id = atoi__extinline((char const   *)idtext);
#line 811
  listener = source_find_client(source, id);
#line 813
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 814
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"iceresponse",
                       (xmlChar const   *)((void *)0));
#line 815
  xmlDocSetRootElement(doc, node);
#line 816
  log_write(errorlog, 4U, "admin/", "command_kill_client", "Response is %d", response);
#line 818
  if ((unsigned int )listener != (unsigned int )((void *)0)) {
#line 819
    log_write(errorlog, 3U, "admin/", "command_kill_client", "Admin request: client %d removed",
              id);
#line 824
    (listener->con)->error = 1;
#line 825
    memset((void *)(buf), '\000', sizeof(buf));
#line 826
    snprintf((char * __restrict  )(buf), sizeof(buf) - 1U, (char const   * __restrict  )"Client %d removed",
             id);
#line 827
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)(buf));
#line 828
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"1");
  } else {
#line 831
    memset((void *)(buf), '\000', sizeof(buf));
#line 832
    snprintf((char * __restrict  )(buf), sizeof(buf) - 1U, (char const   * __restrict  )"Client %d not found",
             id);
#line 833
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)(buf));
#line 834
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"0");
  }
#line 836
  admin_send_response(doc, client, response, (char *)"response.xsl");
#line 838
  xmlFreeDoc(doc);
#line 839
  return;
}
}
#line 841 "admin.c"
static void command_fallback(client_t *client , source_t *source , int response ) 
{ char *fallback ;
  char *old ;
  char *tmp___8 ;

  {
#line 847
  log_write(errorlog, 4U, "admin/", "command_fallback", "Got fallback request");
#line 849
  while (1) {
#line 849
    fallback = httpp_get_query_param(client->parser, (char *)"fallback");
#line 849
    if ((unsigned int )fallback == (unsigned int )((void *)0)) {
#line 849
      client_send_400(client, (char *)"Missing parameter");
#line 849
      return;
    }
#line 849
    break;
  }
#line 851
  old = source->fallback_mount;
#line 852
  tmp___8 = __strdup((char const   *)fallback);
#line 852
  source->fallback_mount = tmp___8;
#line 853
  free((void *)old);
#line 855
  html_success(client, (char *)"Fallback configured");
#line 856
  return;
}
}
#line 858 "admin.c"
static void command_metadata(client_t *client , source_t *source , int response ) 
{ char *action ;
  char *song ;
  char *title ;
  char *artist ;
  format_plugin_t *plugin ;
  xmlDocPtr doc ;
  xmlNodePtr node ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 867
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 868
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"iceresponse",
                       (xmlChar const   *)((void *)0));
#line 869
  xmlDocSetRootElement(doc, node);
#line 871
  log_write(errorlog, 4U, "admin/", "command_metadata", "Got metadata update request");
#line 873
  while (1) {
#line 873
    action = httpp_get_query_param(client->parser, (char *)"mode");
#line 873
    if ((unsigned int )action == (unsigned int )((void *)0)) {
#line 873
      client_send_400(client, (char *)"Missing parameter");
#line 873
      return;
    }
#line 873
    break;
  }
#line 874
  song = httpp_get_query_param(client->parser, (char *)"song");
#line 875
  title = httpp_get_query_param(client->parser, (char *)"title");
#line 876
  artist = httpp_get_query_param(client->parser, (char *)"artist");
#line 878
  if (0) {
#line 878
    __s1_len = strlen((char const   *)action);
#line 878
    __s2_len = strlen("updinfo");
#line 878
    if (! ((unsigned int )((void const   *)(action + 1)) - (unsigned int )((void const   *)action) ==
           1U)) {
      goto _L___0;
    } else {
#line 878
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 878
        if (! ((unsigned int )((void const   *)("updinfo" + 1)) - (unsigned int )((void const   *)"updinfo") ==
               1U)) {
#line 878
          tmp___8 = 1;
        } else {
#line 878
          if (__s2_len >= 4U) {
#line 878
            tmp___8 = 1;
          } else {
#line 878
            tmp___8 = 0;
          }
        }
      } else {
#line 878
        tmp___8 = 0;
      }
    }
#line 878
    if (tmp___8) {
#line 878
      tmp___4 = __builtin_strcmp((char const   *)action, "updinfo");
    } else {
#line 878
      tmp___7 = __builtin_strcmp((char const   *)action, "updinfo");
#line 878
      tmp___4 = tmp___7;
    }
  } else {
#line 878
    tmp___7 = __builtin_strcmp((char const   *)action, "updinfo");
#line 878
    tmp___4 = tmp___7;
  }
#line 878
  if (tmp___4 != 0) {
#line 880
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)"No such action");
#line 881
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"0");
#line 882
    admin_send_response(doc, client, response, (char *)"response.xsl");
#line 884
    xmlFreeDoc(doc);
#line 885
    return;
  }
#line 888
  plugin = source->format;
#line 890
  if (plugin) {
#line 890
    if (plugin->set_tag) {
#line 892
      if (song) {
#line 894
        ((*(plugin->set_tag)))(plugin, (char *)"song", song);
#line 895
        log_write(errorlog, 3U, "admin/", "command_metadata", "Metadata on mountpoint %s changed to \"%s\"",
                  source->mount, song);
      } else {
#line 899
        if (artist) {
#line 899
          if (title) {
#line 901
            ((*(plugin->set_tag)))(plugin, (char *)"title", title);
#line 902
            ((*(plugin->set_tag)))(plugin, (char *)"artist", artist);
#line 903
            log_write(errorlog, 3U, "admin/", "command_metadata", "Metadata on mountpoint %s changed to \"%s - %s\"",
                      source->mount, artist, title);
          }
        }
      }
    } else {
#line 910
      xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)"Mountpoint will not accept URL updates");
#line 912
      xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"1");
#line 913
      admin_send_response(doc, client, response, (char *)"response.xsl");
#line 915
      xmlFreeDoc(doc);
#line 916
      return;
    }
  } else {
#line 910
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)"Mountpoint will not accept URL updates");
#line 912
    xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"1");
#line 913
    admin_send_response(doc, client, response, (char *)"response.xsl");
#line 915
    xmlFreeDoc(doc);
#line 916
    return;
  }
#line 919
  xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"message", (xmlChar const   *)"Metadata update successful");
#line 920
  xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"return", (xmlChar const   *)"1");
#line 921
  admin_send_response(doc, client, response, (char *)"response.xsl");
#line 923
  xmlFreeDoc(doc);
#line 924
  return;
}
}
#line 926 "admin.c"
static void command_shoutcast_metadata(client_t *client , source_t *source ) 
{ char *action ;
  char *value ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 931
  log_write(errorlog, 4U, "admin/", "command_shoutcast_metadata", "Got shoutcast metadata update request");
#line 933
  while (1) {
#line 933
    action = httpp_get_query_param(client->parser, (char *)"mode");
#line 933
    if ((unsigned int )action == (unsigned int )((void *)0)) {
#line 933
      client_send_400(client, (char *)"Missing parameter");
#line 933
      return;
    }
#line 933
    break;
  }
#line 934
  while (1) {
#line 934
    value = httpp_get_query_param(client->parser, (char *)"song");
#line 934
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 934
      client_send_400(client, (char *)"Missing parameter");
#line 934
      return;
    }
#line 934
    break;
  }
#line 936
  if (0) {
#line 936
    __s1_len = strlen((char const   *)action);
#line 936
    __s2_len = strlen("updinfo");
#line 936
    if (! ((unsigned int )((void const   *)(action + 1)) - (unsigned int )((void const   *)action) ==
           1U)) {
      goto _L___0;
    } else {
#line 936
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 936
        if (! ((unsigned int )((void const   *)("updinfo" + 1)) - (unsigned int )((void const   *)"updinfo") ==
               1U)) {
#line 936
          tmp___8 = 1;
        } else {
#line 936
          if (__s2_len >= 4U) {
#line 936
            tmp___8 = 1;
          } else {
#line 936
            tmp___8 = 0;
          }
        }
      } else {
#line 936
        tmp___8 = 0;
      }
    }
#line 936
    if (tmp___8) {
#line 936
      tmp___4 = __builtin_strcmp((char const   *)action, "updinfo");
    } else {
#line 936
      tmp___7 = __builtin_strcmp((char const   *)action, "updinfo");
#line 936
      tmp___4 = tmp___7;
    }
  } else {
#line 936
    tmp___7 = __builtin_strcmp((char const   *)action, "updinfo");
#line 936
    tmp___4 = tmp___7;
  }
#line 936
  if (tmp___4 != 0) {
#line 938
    client_send_400(client, (char *)"No such action");
#line 939
    return;
  }
#line 942
  if (source->format) {
#line 942
    if ((source->format)->set_tag) {
#line 944
      ((*((source->format)->set_tag)))(source->format, (char *)"title", value);
#line 946
      log_write(errorlog, 4U, "admin/", "command_shoutcast_metadata", "Metadata on mountpoint %s changed to \"%s\"",
                source->mount, value);
#line 948
      html_success(client, (char *)"Metadata update successful");
    } else {
#line 952
      client_send_400(client, (char *)"mountpoint will not accept URL updates");
    }
  } else {
#line 952
    client_send_400(client, (char *)"mountpoint will not accept URL updates");
  }
#line 954
  return;
}
}
#line 956 "admin.c"
static void command_stats(client_t *client , int response ) 
{ xmlDocPtr doc ;

  {
#line 959
  log_write(errorlog, 4U, "admin/", "command_stats", "Stats request, sending xml stats");
#line 961
  stats_get_xml(& doc, 1);
#line 962
  admin_send_response(doc, client, response, (char *)"stats.xsl");
#line 963
  xmlFreeDoc(doc);
#line 964
  return;
}
}
#line 967 "admin.c"
static void command_list_mounts(client_t *client , int response ) 
{ char *buf ;
  int remaining ;
  int ret ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mountinfo ;
  mount_proxy *current ;
  source_t *source ;
  xmlDocPtr doc ;
  xmlDocPtr tmp___0 ;

  {
#line 969
  log_write(errorlog, 4U, "admin/", "command_list_mounts", "List mounts request");
#line 971
  avl_tree_rlock(global.source_tree);
#line 972
  if (response == 3) {
#line 975
    remaining = 4096;
#line 977
    tmp = config_get_config();
#line 977
    config = tmp;
#line 978
    mountinfo = config->mounts;
#line 980
    buf = (client->refbuf)->data;
#line 981
    ret = snprintf((char * __restrict  )buf, (unsigned int )remaining, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n");
#line 984
    while (1) {
#line 984
      if (mountinfo) {
#line 984
        if (ret > 0) {
#line 984
          if (! (ret < remaining)) {
#line 984
            break;
          }
        } else {
#line 984
          break;
        }
      } else {
#line 984
        break;
      }
#line 986
      current = mountinfo;
#line 988
      mountinfo = mountinfo->next;
#line 991
      source = source_find_mount((char const   *)current->mountname);
#line 993
      if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 994
        continue;
      }
#line 995
      if (source->running == 0) {
#line 995
        if (source->on_demand == 0) {
#line 996
          continue;
        }
      }
#line 997
      if (source->hidden) {
#line 998
        continue;
      }
#line 999
      remaining -= ret;
#line 1000
      buf += ret;
#line 1001
      ret = snprintf((char * __restrict  )buf, (unsigned int )remaining, (char const   * __restrict  )"%s\n",
                     current->mountname);
    }
#line 1003
    avl_tree_unlock(global.source_tree);
#line 1004
    config_release_config();
#line 1007
    if (ret > 0) {
#line 1007
      if (ret < remaining) {
#line 1009
        remaining -= ret;
#line 1010
        buf += ret;
      }
    }
#line 1012
    (client->refbuf)->len = (unsigned long )(4096 - remaining);
#line 1013
    fserve_add_client(client, (FILE *)((void *)0));
  } else {
#line 1017
    tmp___0 = admin_build_sourcelist((char const   *)((void *)0));
#line 1017
    doc = tmp___0;
#line 1018
    avl_tree_unlock(global.source_tree);
#line 1020
    admin_send_response(doc, client, response, (char *)"listmounts.xsl");
#line 1022
    xmlFreeDoc(doc);
  }
#line 1024
  return;
}
}
#line 1026 "admin.c"
static void command_updatemetadata(client_t *client , source_t *source , int response ) 
{ xmlDocPtr doc ;
  xmlNodePtr node ;
  xmlNodePtr srcnode ;

  {
#line 1032
  doc = xmlNewDoc((xmlChar const   *)"1.0");
#line 1033
  node = xmlNewDocNode(doc, (xmlNs *)((void *)0), (xmlChar const   *)"icestats", (xmlChar const   *)((void *)0));
#line 1034
  srcnode = xmlNewChild(node, (xmlNs *)((void *)0), (xmlChar const   *)"source", (xmlChar const   *)((void *)0));
#line 1035
  xmlSetProp(srcnode, (xmlChar const   *)"mount", (xmlChar const   *)source->mount);
#line 1036
  xmlDocSetRootElement(doc, node);
#line 1038
  admin_send_response(doc, client, response, (char *)"updatemetadata.xsl");
#line 1040
  xmlFreeDoc(doc);
#line 1041
  return;
}
}
#line 1 "cil-iq1yP2vS.o"
#pragma merger(0,"/tmp/cil-cY2x5GPn.i","")
#line 1 "./src/md5.o_saved.c"
#pragma merger(0,"./md5.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 27 "md5.h"
void MD5Init(struct MD5Context *ctx ) ;
#line 28
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) ;
#line 30
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) ;
#line 46 "md5.c"
static void MD5Transform(uint32_t *buf , uint32_t const   *in ) ;
#line 51 "md5.c"
static void byteReverse(unsigned char *buf , unsigned int longs ) 
{ uint32_t t ;

  {
#line 54
  while (1) {
#line 56
    t = ((((unsigned int )(*(buf + 3)) << 8) | (unsigned int )(*(buf + 2))) << 16) |
        (((unsigned int )(*(buf + 1)) << 8) | (unsigned int )(*(buf + 0)));
#line 58
    (*((uint32_t *)buf)) = t;
#line 59
    buf += 4;
#line 54
    longs --;
#line 54
    if (! longs) {
#line 54
      break;
    }
  }
#line 62
  return;
}
}
#line 68 "md5.c"
void MD5Init(struct MD5Context *ctx ) 
{ 

  {
#line 70
  ctx->buf[0] = 1732584193U;
#line 71
  ctx->buf[1] = 4023233417U;
#line 72
  ctx->buf[2] = 2562383102U;
#line 73
  ctx->buf[3] = 271733878U;
#line 75
  ctx->bits[0] = 0U;
#line 76
  ctx->bits[1] = 0U;
#line 77
  return;
}
}
#line 83 "md5.c"
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf , unsigned int len ) 
{ uint32_t t ;
  unsigned char *p ;

  {
#line 90
  t = ctx->bits[0];
#line 91
  ctx->bits[0] = t + (len << 3);
#line 91
  if (ctx->bits[0] < t) {
#line 92
    ctx->bits[1] ++;
  }
#line 95
  ctx->bits[1] += len >> 29;
#line 97
  t = (t >> 3) & 63U;
#line 101
  if (t) {
#line 103
    p = ctx->in + t;
#line 104
    t = 64U - t;
#line 105
    if (len < t) {
#line 107
      memcpy((void * __restrict  )p, (void const   * __restrict  )buf, len);
#line 108
      return;
    }
#line 111
    memcpy((void * __restrict  )p, (void const   * __restrict  )buf, t);
#line 112
    byteReverse(ctx->in, 16U);
#line 113
    MD5Transform(ctx->buf, (uint32_t const   *)((uint32_t *)(ctx->in)));
#line 114
    buf += t;
#line 115
    len -= t;
  }
#line 119
  while (len >= 64U) {
#line 121
    memcpy((void * __restrict  )(ctx->in), (void const   * __restrict  )buf, 64U);
#line 122
    byteReverse(ctx->in, 16U);
#line 123
    MD5Transform(ctx->buf, (uint32_t const   *)((uint32_t *)(ctx->in)));
#line 124
    buf += 64;
#line 125
    len -= 64U;
  }
#line 129
  memcpy((void * __restrict  )(ctx->in), (void const   * __restrict  )buf, len);
#line 130
  return;
}
}
#line 136 "md5.c"
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) 
{ unsigned int count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 142
  count = (ctx->bits[0] >> 3) & 63U;
#line 146
  p = ctx->in + count;
#line 147
  tmp = p;
#line 147
  p ++;
#line 147
  (*tmp) = (unsigned char)128;
#line 150
  count = 63U - count;
#line 153
  if (count < 8U) {
#line 156
    memset((void *)p, 0, count);
#line 157
    byteReverse(ctx->in, 16U);
#line 158
    MD5Transform(ctx->buf, (uint32_t const   *)((uint32_t *)(ctx->in)));
#line 161
    memset((void *)(ctx->in), 0, 56U);
  } else {
#line 166
    memset((void *)p, 0, count - 8U);
  }
#line 168
  byteReverse(ctx->in, 14U);
#line 171
  (*((uint32_t *)(ctx->in) + 14)) = ctx->bits[0];
#line 172
  (*((uint32_t *)(ctx->in) + 15)) = ctx->bits[1];
#line 174
  MD5Transform(ctx->buf, (uint32_t const   *)((uint32_t *)(ctx->in)));
#line 175
  byteReverse((unsigned char *)(ctx->buf), 4U);
#line 176
  memcpy((void * __restrict  )digest, (void const   * __restrict  )(ctx->buf), 16U);
#line 177
  memset((void *)ctx, 0, sizeof(ctx));
#line 179
  return;
}
}
#line 197 "md5.c"
static void MD5Transform(uint32_t *buf , uint32_t const   *in ) 
{ register uint32_t a ;
  register uint32_t b ;
  register uint32_t c ;
  register uint32_t d ;

  {
#line 201
  a = (*(buf + 0));
#line 202
  b = (*(buf + 1));
#line 203
  c = (*(buf + 2));
#line 204
  d = (*(buf + 3));
#line 206
  while (1) {
#line 206
    a += ((d ^ (b & (c ^ d))) + (unsigned int )(*(in + 0))) + 3614090360U;
#line 206
    a = (a << 7) | (a >> 25);
#line 206
    a += b;
#line 206
    break;
  }
#line 207
  while (1) {
#line 207
    d += ((c ^ (a & (b ^ c))) + (unsigned int )(*(in + 1))) + 3905402710U;
#line 207
    d = (d << 12) | (d >> 20);
#line 207
    d += a;
#line 207
    break;
  }
#line 208
  while (1) {
#line 208
    c += ((b ^ (d & (a ^ b))) + (unsigned int )(*(in + 2))) + 606105819U;
#line 208
    c = (c << 17) | (c >> 15);
#line 208
    c += d;
#line 208
    break;
  }
#line 209
  while (1) {
#line 209
    b += ((a ^ (c & (d ^ a))) + (unsigned int )(*(in + 3))) + 3250441966U;
#line 209
    b = (b << 22) | (b >> 10);
#line 209
    b += c;
#line 209
    break;
  }
#line 210
  while (1) {
#line 210
    a += ((d ^ (b & (c ^ d))) + (unsigned int )(*(in + 4))) + 4118548399U;
#line 210
    a = (a << 7) | (a >> 25);
#line 210
    a += b;
#line 210
    break;
  }
#line 211
  while (1) {
#line 211
    d += ((c ^ (a & (b ^ c))) + (unsigned int )(*(in + 5))) + 1200080426U;
#line 211
    d = (d << 12) | (d >> 20);
#line 211
    d += a;
#line 211
    break;
  }
#line 212
  while (1) {
#line 212
    c += ((b ^ (d & (a ^ b))) + (unsigned int )(*(in + 6))) + 2821735955U;
#line 212
    c = (c << 17) | (c >> 15);
#line 212
    c += d;
#line 212
    break;
  }
#line 213
  while (1) {
#line 213
    b += ((a ^ (c & (d ^ a))) + (unsigned int )(*(in + 7))) + 4249261313U;
#line 213
    b = (b << 22) | (b >> 10);
#line 213
    b += c;
#line 213
    break;
  }
#line 214
  while (1) {
#line 214
    a += ((d ^ (b & (c ^ d))) + (unsigned int )(*(in + 8))) + 1770035416U;
#line 214
    a = (a << 7) | (a >> 25);
#line 214
    a += b;
#line 214
    break;
  }
#line 215
  while (1) {
#line 215
    d += ((c ^ (a & (b ^ c))) + (unsigned int )(*(in + 9))) + 2336552879U;
#line 215
    d = (d << 12) | (d >> 20);
#line 215
    d += a;
#line 215
    break;
  }
#line 216
  while (1) {
#line 216
    c += ((b ^ (d & (a ^ b))) + (unsigned int )(*(in + 10))) + 4294925233U;
#line 216
    c = (c << 17) | (c >> 15);
#line 216
    c += d;
#line 216
    break;
  }
#line 217
  while (1) {
#line 217
    b += ((a ^ (c & (d ^ a))) + (unsigned int )(*(in + 11))) + 2304563134U;
#line 217
    b = (b << 22) | (b >> 10);
#line 217
    b += c;
#line 217
    break;
  }
#line 218
  while (1) {
#line 218
    a += ((d ^ (b & (c ^ d))) + (unsigned int )(*(in + 12))) + 1804603682U;
#line 218
    a = (a << 7) | (a >> 25);
#line 218
    a += b;
#line 218
    break;
  }
#line 219
  while (1) {
#line 219
    d += ((c ^ (a & (b ^ c))) + (unsigned int )(*(in + 13))) + 4254626195U;
#line 219
    d = (d << 12) | (d >> 20);
#line 219
    d += a;
#line 219
    break;
  }
#line 220
  while (1) {
#line 220
    c += ((b ^ (d & (a ^ b))) + (unsigned int )(*(in + 14))) + 2792965006U;
#line 220
    c = (c << 17) | (c >> 15);
#line 220
    c += d;
#line 220
    break;
  }
#line 221
  while (1) {
#line 221
    b += ((a ^ (c & (d ^ a))) + (unsigned int )(*(in + 15))) + 1236535329U;
#line 221
    b = (b << 22) | (b >> 10);
#line 221
    b += c;
#line 221
    break;
  }
#line 223
  while (1) {
#line 223
    a += ((c ^ (d & (b ^ c))) + (unsigned int )(*(in + 1))) + 4129170786U;
#line 223
    a = (a << 5) | (a >> 27);
#line 223
    a += b;
#line 223
    break;
  }
#line 224
  while (1) {
#line 224
    d += ((b ^ (c & (a ^ b))) + (unsigned int )(*(in + 6))) + 3225465664U;
#line 224
    d = (d << 9) | (d >> 23);
#line 224
    d += a;
#line 224
    break;
  }
#line 225
  while (1) {
#line 225
    c += ((a ^ (b & (d ^ a))) + (unsigned int )(*(in + 11))) + 643717713U;
#line 225
    c = (c << 14) | (c >> 18);
#line 225
    c += d;
#line 225
    break;
  }
#line 226
  while (1) {
#line 226
    b += ((d ^ (a & (c ^ d))) + (unsigned int )(*(in + 0))) + 3921069994U;
#line 226
    b = (b << 20) | (b >> 12);
#line 226
    b += c;
#line 226
    break;
  }
#line 227
  while (1) {
#line 227
    a += ((c ^ (d & (b ^ c))) + (unsigned int )(*(in + 5))) + 3593408605U;
#line 227
    a = (a << 5) | (a >> 27);
#line 227
    a += b;
#line 227
    break;
  }
#line 228
  while (1) {
#line 228
    d += ((b ^ (c & (a ^ b))) + (unsigned int )(*(in + 10))) + 38016083U;
#line 228
    d = (d << 9) | (d >> 23);
#line 228
    d += a;
#line 228
    break;
  }
#line 229
  while (1) {
#line 229
    c += ((a ^ (b & (d ^ a))) + (unsigned int )(*(in + 15))) + 3634488961U;
#line 229
    c = (c << 14) | (c >> 18);
#line 229
    c += d;
#line 229
    break;
  }
#line 230
  while (1) {
#line 230
    b += ((d ^ (a & (c ^ d))) + (unsigned int )(*(in + 4))) + 3889429448U;
#line 230
    b = (b << 20) | (b >> 12);
#line 230
    b += c;
#line 230
    break;
  }
#line 231
  while (1) {
#line 231
    a += ((c ^ (d & (b ^ c))) + (unsigned int )(*(in + 9))) + 568446438U;
#line 231
    a = (a << 5) | (a >> 27);
#line 231
    a += b;
#line 231
    break;
  }
#line 232
  while (1) {
#line 232
    d += ((b ^ (c & (a ^ b))) + (unsigned int )(*(in + 14))) + 3275163606U;
#line 232
    d = (d << 9) | (d >> 23);
#line 232
    d += a;
#line 232
    break;
  }
#line 233
  while (1) {
#line 233
    c += ((a ^ (b & (d ^ a))) + (unsigned int )(*(in + 3))) + 4107603335U;
#line 233
    c = (c << 14) | (c >> 18);
#line 233
    c += d;
#line 233
    break;
  }
#line 234
  while (1) {
#line 234
    b += ((d ^ (a & (c ^ d))) + (unsigned int )(*(in + 8))) + 1163531501U;
#line 234
    b = (b << 20) | (b >> 12);
#line 234
    b += c;
#line 234
    break;
  }
#line 235
  while (1) {
#line 235
    a += ((c ^ (d & (b ^ c))) + (unsigned int )(*(in + 13))) + 2850285829U;
#line 235
    a = (a << 5) | (a >> 27);
#line 235
    a += b;
#line 235
    break;
  }
#line 236
  while (1) {
#line 236
    d += ((b ^ (c & (a ^ b))) + (unsigned int )(*(in + 2))) + 4243563512U;
#line 236
    d = (d << 9) | (d >> 23);
#line 236
    d += a;
#line 236
    break;
  }
#line 237
  while (1) {
#line 237
    c += ((a ^ (b & (d ^ a))) + (unsigned int )(*(in + 7))) + 1735328473U;
#line 237
    c = (c << 14) | (c >> 18);
#line 237
    c += d;
#line 237
    break;
  }
#line 238
  while (1) {
#line 238
    b += ((d ^ (a & (c ^ d))) + (unsigned int )(*(in + 12))) + 2368359562U;
#line 238
    b = (b << 20) | (b >> 12);
#line 238
    b += c;
#line 238
    break;
  }
#line 240
  while (1) {
#line 240
    a += (((b ^ c) ^ d) + (unsigned int )(*(in + 5))) + 4294588738U;
#line 240
    a = (a << 4) | (a >> 28);
#line 240
    a += b;
#line 240
    break;
  }
#line 241
  while (1) {
#line 241
    d += (((a ^ b) ^ c) + (unsigned int )(*(in + 8))) + 2272392833U;
#line 241
    d = (d << 11) | (d >> 21);
#line 241
    d += a;
#line 241
    break;
  }
#line 242
  while (1) {
#line 242
    c += (((d ^ a) ^ b) + (unsigned int )(*(in + 11))) + 1839030562U;
#line 242
    c = (c << 16) | (c >> 16);
#line 242
    c += d;
#line 242
    break;
  }
#line 243
  while (1) {
#line 243
    b += (((c ^ d) ^ a) + (unsigned int )(*(in + 14))) + 4259657740U;
#line 243
    b = (b << 23) | (b >> 9);
#line 243
    b += c;
#line 243
    break;
  }
#line 244
  while (1) {
#line 244
    a += (((b ^ c) ^ d) + (unsigned int )(*(in + 1))) + 2763975236U;
#line 244
    a = (a << 4) | (a >> 28);
#line 244
    a += b;
#line 244
    break;
  }
#line 245
  while (1) {
#line 245
    d += (((a ^ b) ^ c) + (unsigned int )(*(in + 4))) + 1272893353U;
#line 245
    d = (d << 11) | (d >> 21);
#line 245
    d += a;
#line 245
    break;
  }
#line 246
  while (1) {
#line 246
    c += (((d ^ a) ^ b) + (unsigned int )(*(in + 7))) + 4139469664U;
#line 246
    c = (c << 16) | (c >> 16);
#line 246
    c += d;
#line 246
    break;
  }
#line 247
  while (1) {
#line 247
    b += (((c ^ d) ^ a) + (unsigned int )(*(in + 10))) + 3200236656U;
#line 247
    b = (b << 23) | (b >> 9);
#line 247
    b += c;
#line 247
    break;
  }
#line 248
  while (1) {
#line 248
    a += (((b ^ c) ^ d) + (unsigned int )(*(in + 13))) + 681279174U;
#line 248
    a = (a << 4) | (a >> 28);
#line 248
    a += b;
#line 248
    break;
  }
#line 249
  while (1) {
#line 249
    d += (((a ^ b) ^ c) + (unsigned int )(*(in + 0))) + 3936430074U;
#line 249
    d = (d << 11) | (d >> 21);
#line 249
    d += a;
#line 249
    break;
  }
#line 250
  while (1) {
#line 250
    c += (((d ^ a) ^ b) + (unsigned int )(*(in + 3))) + 3572445317U;
#line 250
    c = (c << 16) | (c >> 16);
#line 250
    c += d;
#line 250
    break;
  }
#line 251
  while (1) {
#line 251
    b += (((c ^ d) ^ a) + (unsigned int )(*(in + 6))) + 76029189U;
#line 251
    b = (b << 23) | (b >> 9);
#line 251
    b += c;
#line 251
    break;
  }
#line 252
  while (1) {
#line 252
    a += (((b ^ c) ^ d) + (unsigned int )(*(in + 9))) + 3654602809U;
#line 252
    a = (a << 4) | (a >> 28);
#line 252
    a += b;
#line 252
    break;
  }
#line 253
  while (1) {
#line 253
    d += (((a ^ b) ^ c) + (unsigned int )(*(in + 12))) + 3873151461U;
#line 253
    d = (d << 11) | (d >> 21);
#line 253
    d += a;
#line 253
    break;
  }
#line 254
  while (1) {
#line 254
    c += (((d ^ a) ^ b) + (unsigned int )(*(in + 15))) + 530742520U;
#line 254
    c = (c << 16) | (c >> 16);
#line 254
    c += d;
#line 254
    break;
  }
#line 255
  while (1) {
#line 255
    b += (((c ^ d) ^ a) + (unsigned int )(*(in + 2))) + 3299628645U;
#line 255
    b = (b << 23) | (b >> 9);
#line 255
    b += c;
#line 255
    break;
  }
#line 257
  while (1) {
#line 257
    a += ((c ^ (b | ~ d)) + (unsigned int )(*(in + 0))) + 4096336452U;
#line 257
    a = (a << 6) | (a >> 26);
#line 257
    a += b;
#line 257
    break;
  }
#line 258
  while (1) {
#line 258
    d += ((b ^ (a | ~ c)) + (unsigned int )(*(in + 7))) + 1126891415U;
#line 258
    d = (d << 10) | (d >> 22);
#line 258
    d += a;
#line 258
    break;
  }
#line 259
  while (1) {
#line 259
    c += ((a ^ (d | ~ b)) + (unsigned int )(*(in + 14))) + 2878612391U;
#line 259
    c = (c << 15) | (c >> 17);
#line 259
    c += d;
#line 259
    break;
  }
#line 260
  while (1) {
#line 260
    b += ((d ^ (c | ~ a)) + (unsigned int )(*(in + 5))) + 4237533241U;
#line 260
    b = (b << 21) | (b >> 11);
#line 260
    b += c;
#line 260
    break;
  }
#line 261
  while (1) {
#line 261
    a += ((c ^ (b | ~ d)) + (unsigned int )(*(in + 12))) + 1700485571U;
#line 261
    a = (a << 6) | (a >> 26);
#line 261
    a += b;
#line 261
    break;
  }
#line 262
  while (1) {
#line 262
    d += ((b ^ (a | ~ c)) + (unsigned int )(*(in + 3))) + 2399980690U;
#line 262
    d = (d << 10) | (d >> 22);
#line 262
    d += a;
#line 262
    break;
  }
#line 263
  while (1) {
#line 263
    c += ((a ^ (d | ~ b)) + (unsigned int )(*(in + 10))) + 4293915773U;
#line 263
    c = (c << 15) | (c >> 17);
#line 263
    c += d;
#line 263
    break;
  }
#line 264
  while (1) {
#line 264
    b += ((d ^ (c | ~ a)) + (unsigned int )(*(in + 1))) + 2240044497U;
#line 264
    b = (b << 21) | (b >> 11);
#line 264
    b += c;
#line 264
    break;
  }
#line 265
  while (1) {
#line 265
    a += ((c ^ (b | ~ d)) + (unsigned int )(*(in + 8))) + 1873313359U;
#line 265
    a = (a << 6) | (a >> 26);
#line 265
    a += b;
#line 265
    break;
  }
#line 266
  while (1) {
#line 266
    d += ((b ^ (a | ~ c)) + (unsigned int )(*(in + 15))) + 4264355552U;
#line 266
    d = (d << 10) | (d >> 22);
#line 266
    d += a;
#line 266
    break;
  }
#line 267
  while (1) {
#line 267
    c += ((a ^ (d | ~ b)) + (unsigned int )(*(in + 6))) + 2734768916U;
#line 267
    c = (c << 15) | (c >> 17);
#line 267
    c += d;
#line 267
    break;
  }
#line 268
  while (1) {
#line 268
    b += ((d ^ (c | ~ a)) + (unsigned int )(*(in + 13))) + 1309151649U;
#line 268
    b = (b << 21) | (b >> 11);
#line 268
    b += c;
#line 268
    break;
  }
#line 269
  while (1) {
#line 269
    a += ((c ^ (b | ~ d)) + (unsigned int )(*(in + 4))) + 4149444226U;
#line 269
    a = (a << 6) | (a >> 26);
#line 269
    a += b;
#line 269
    break;
  }
#line 270
  while (1) {
#line 270
    d += ((b ^ (a | ~ c)) + (unsigned int )(*(in + 11))) + 3174756917U;
#line 270
    d = (d << 10) | (d >> 22);
#line 270
    d += a;
#line 270
    break;
  }
#line 271
  while (1) {
#line 271
    c += ((a ^ (d | ~ b)) + (unsigned int )(*(in + 2))) + 718787259U;
#line 271
    c = (c << 15) | (c >> 17);
#line 271
    c += d;
#line 271
    break;
  }
#line 272
  while (1) {
#line 272
    b += ((d ^ (c | ~ a)) + (unsigned int )(*(in + 9))) + 3951481745U;
#line 272
    b = (b << 21) | (b >> 11);
#line 272
    b += c;
#line 272
    break;
  }
#line 274
  (*(buf + 0)) = (*(buf + 0)) + a;
#line 275
  (*(buf + 1)) = (*(buf + 1)) + b;
#line 276
  (*(buf + 2)) = (*(buf + 2)) + c;
#line 277
  (*(buf + 3)) = (*(buf + 3)) + d;
#line 278
  return;
}
}
#line 1 "cil-z9aCcAs7.o"
#pragma merger(0,"/tmp/cil-4dARWxL7.i","")
#line 1 "./src/format.o_saved.c"
#pragma merger(0,"./format.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 63 "format.h"
int format_advance_queue(struct source_tag *source , client_t *client ) ;
#line 68 "format_ogg.h"
int format_ogg_get_plugin(source_t *source ) ;
#line 40 "format_mp3.h"
int format_mp3_get_plugin(struct source_tag *source ) ;
#line 52 "format.c"
static int format_prepare_headers(source_t *source , client_t *client ) ;
#line 55 "format.c"
format_type_t format_get_type(char *contenttype ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 57
  if (0) {
#line 57
    __s1_len___0 = strlen((char const   *)contenttype);
#line 57
    __s2_len___0 = strlen("application/x-ogg");
#line 57
    if (! ((unsigned int )((void const   *)(contenttype + 1)) - (unsigned int )((void const   *)contenttype) ==
           1U)) {
      goto _L___2;
    } else {
#line 57
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 57
        if (! ((unsigned int )((void const   *)("application/x-ogg" + 1)) - (unsigned int )((void const   *)"application/x-ogg") ==
               1U)) {
#line 57
          tmp___18 = 1;
        } else {
#line 57
          if (__s2_len___0 >= 4U) {
#line 57
            tmp___18 = 1;
          } else {
#line 57
            tmp___18 = 0;
          }
        }
      } else {
#line 57
        tmp___18 = 0;
      }
    }
#line 57
    if (tmp___18) {
#line 57
      tmp___14 = __builtin_strcmp((char const   *)contenttype, "application/x-ogg");
    } else {
#line 57
      tmp___17 = __builtin_strcmp((char const   *)contenttype, "application/x-ogg");
#line 57
      tmp___14 = tmp___17;
    }
  } else {
#line 57
    tmp___17 = __builtin_strcmp((char const   *)contenttype, "application/x-ogg");
#line 57
    tmp___14 = tmp___17;
  }
#line 57
  if (tmp___14 == 0) {
#line 58
    return (1);
  } else {
#line 59
    if (0) {
#line 59
      __s1_len = strlen((char const   *)contenttype);
#line 59
      __s2_len = strlen("application/ogg");
#line 59
      if (! ((unsigned int )((void const   *)(contenttype + 1)) - (unsigned int )((void const   *)contenttype) ==
             1U)) {
        goto _L___0;
      } else {
#line 59
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 59
          if (! ((unsigned int )((void const   *)("application/ogg" + 1)) - (unsigned int )((void const   *)"application/ogg") ==
                 1U)) {
#line 59
            tmp___8 = 1;
          } else {
#line 59
            if (__s2_len >= 4U) {
#line 59
              tmp___8 = 1;
            } else {
#line 59
              tmp___8 = 0;
            }
          }
        } else {
#line 59
          tmp___8 = 0;
        }
      }
#line 59
      if (tmp___8) {
#line 59
        tmp___4 = __builtin_strcmp((char const   *)contenttype, "application/ogg");
      } else {
#line 59
        tmp___7 = __builtin_strcmp((char const   *)contenttype, "application/ogg");
#line 59
        tmp___4 = tmp___7;
      }
    } else {
#line 59
      tmp___7 = __builtin_strcmp((char const   *)contenttype, "application/ogg");
#line 59
      tmp___4 = tmp___7;
    }
#line 59
    if (tmp___4 == 0) {
#line 60
      return (1);
    } else {
#line 64
      return (2);
    }
  }
}
}
#line 67 "format.c"
int format_get_plugin(format_type_t type , struct source_tag *source ) 
{ int ret ;

  {
#line 69
  ret = -1;
#line 71
  switch ((int )type) {
  case 1: 
#line 73
  ret = format_ogg_get_plugin(source);
#line 74
  break;
  case 2: 
#line 76
  ret = format_mp3_get_plugin(source);
#line 77
  break;
  default: ;
#line 79
  break;
  }
#line 81
  if (ret < 0) {
#line 82
    stats_event((char const   *)source->mount, "content-type", (char const   *)(source->format)->contenttype);
  }
#line 85
  return (ret);
}
}
#line 92 "format.c"
static void find_client_start(source_t *source , client_t *client ) 
{ refbuf_t *refbuf ;
  long size ;

  {
#line 94
  refbuf = source->burst_point;
#line 97
  if (client->intro_offset == -1L) {
#line 98
    refbuf = source->stream_data_tail;
  } else {
#line 101
    size = 0L;
#line 102
    refbuf = source->burst_point;
#line 103
    size = client->intro_offset;
#line 104
    while (1) {
#line 104
      if (size > 0L) {
#line 104
        if (! refbuf->next) {
#line 104
          break;
        }
      } else {
#line 104
        break;
      }
#line 106
      size = (long )((unsigned long )size - refbuf->len);
#line 107
      refbuf = refbuf->next;
    }
  }
#line 111
  while (refbuf) {
#line 113
    if (refbuf->sync_point) {
#line 115
      client_set_queue(client, refbuf);
#line 116
      client->check_buffer = & format_advance_queue;
#line 117
      client->write_to_client = (source->format)->write_buf_to_client;
#line 118
      client->intro_offset = -1L;
#line 119
      break;
    }
#line 121
    refbuf = refbuf->next;
  }
#line 123
  return;
}
}
#line 126 "format.c"
static int get_file_data(FILE *intro , client_t *client ) 
{ refbuf_t *refbuf ;
  int bytes ;
  int tmp ;

  {
#line 128
  refbuf = client->refbuf;
#line 131
  if ((unsigned int )intro == (unsigned int )((void *)0)) {
#line 132
    return (0);
  } else {
#line 131
    tmp = fseek(intro, client->intro_offset, 0);
#line 131
    if (tmp < 0) {
#line 132
      return (0);
    }
  }
#line 133
  bytes = (int )fread((void * __restrict  )refbuf->data, 1U, 4096U, (FILE * __restrict  )intro);
#line 134
  if (bytes == 0) {
#line 135
    return (0);
  }
#line 137
  refbuf->len = (unsigned long )bytes;
#line 138
  return (1);
}
}
#line 146 "format.c"
int format_check_file_buffer(struct source_tag *source , client_t *client ) 
{ refbuf_t *refbuf ;
  int tmp ;

  {
#line 148
  refbuf = client->refbuf;
#line 150
  if ((unsigned int )refbuf == (unsigned int )((void *)0)) {
#line 153
    if (source->client) {
#line 155
      find_client_start(source, client);
#line 156
      return (-1);
    }
#line 159
    refbuf = refbuf_new(4096UL);
#line 160
    client->refbuf = refbuf;
#line 161
    client->pos = refbuf->len;
#line 162
    client->intro_offset = 0L;
  }
#line 164
  if (client->pos == refbuf->len) {
#line 166
    tmp = get_file_data(source->intro_file, client);
#line 166
    if (tmp) {
#line 168
      client->pos = 0UL;
#line 169
      client->intro_offset = (long )((unsigned long )client->intro_offset + refbuf->len);
    } else {
#line 173
      if (source->stream_data_tail) {
#line 176
        client_set_queue(client, (refbuf_t *)((void *)0));
#line 177
        find_client_start(source, client);
      } else {
#line 180
        client->intro_offset = 0L;
      }
#line 181
      return (-1);
    }
  }
#line 184
  return (0);
}
}
#line 191 "format.c"
int format_check_http_buffer(struct source_tag *source , client_t *client ) 
{ refbuf_t *refbuf ;
  int tmp ;

  {
#line 193
  refbuf = client->refbuf;
#line 195
  if ((unsigned int )refbuf == (unsigned int )((void *)0)) {
#line 196
    return (-1);
  }
#line 198
  if (client->respcode == 0) {
#line 200
    log_write(errorlog, 4U, "format/", "format_check_http_buffer", "processing pending client headers");
#line 202
    client->respcode = 200;
#line 203
    tmp = format_prepare_headers(source, client);
#line 203
    if (tmp < 0) {
#line 205
      log_write(errorlog, 1U, "format/", "format_check_http_buffer", "internal problem, dropping client");
#line 206
      (client->con)->error = 1;
#line 207
      return (-1);
    }
  }
#line 211
  if (client->pos == refbuf->len) {
#line 213
    client->write_to_client = (source->format)->write_buf_to_client;
#line 214
    client->check_buffer = & format_check_file_buffer;
#line 215
    client->intro_offset = 0L;
#line 216
    refbuf->len = 4096UL;
#line 216
    client->pos = refbuf->len;
#line 217
    return (-1);
  }
#line 219
  return (0);
}
}
#line 223 "format.c"
int format_generic_write_to_client(client_t *client ) 
{ refbuf_t *refbuf ;
  int ret ;
  char const   *buf ;
  unsigned int len ;

  {
#line 225
  refbuf = client->refbuf;
#line 227
  buf = (char const   *)(refbuf->data + client->pos);
#line 228
  len = (unsigned int )(refbuf->len - client->pos);
#line 230
  ret = client_send_bytes(client, (void const   *)buf, len);
#line 232
  if (ret > 0) {
#line 233
    client->pos = client->pos + (unsigned long )ret;
  }
#line 235
  return (ret);
}
}
#line 243 "format.c"
int format_advance_queue(struct source_tag *source , client_t *client ) 
{ refbuf_t *refbuf ;

  {
#line 245
  refbuf = client->refbuf;
#line 247
  if ((unsigned int )refbuf == (unsigned int )((void *)0)) {
#line 248
    return (-1);
  }
#line 250
  if ((unsigned int )refbuf->next == (unsigned int )((void *)0)) {
#line 250
    if (client->pos == refbuf->len) {
#line 251
      return (-1);
    }
  }
#line 254
  if (refbuf->next) {
#line 254
    if (client->pos == refbuf->len) {
#line 256
      client_set_queue(client, refbuf->next);
#line 257
      refbuf = client->refbuf;
    }
  }
#line 259
  return (0);
}
}
#line 263 "format.c"
static int format_prepare_headers(source_t *source , client_t *client ) 
{ unsigned int remaining ;
  char *ptr ;
  int bytes ;
  int bitrate_filtered ;
  avl_node *node ;
  int next ;
  http_var_t *var ;
  char *brfield ;
  unsigned int bitrate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 268
  bitrate_filtered = 0;
#line 271
  remaining = (unsigned int )(client->refbuf)->len;
#line 272
  ptr = (client->refbuf)->data;
#line 273
  client->respcode = 200;
#line 275
  bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"HTTP/1.0 200 OK\r\nContent-Type: %s\r\n",
                   (source->format)->contenttype);
#line 278
  remaining -= (unsigned int )bytes;
#line 279
  ptr += bytes;
#line 282
  avl_tree_rlock((source->parser)->vars);
#line 283
  node = avl_get_first((source->parser)->vars);
#line 284
  while (node) {
#line 286
    next = 1;
#line 287
    var = (http_var_t *)node->key;
#line 288
    bytes = 0;
#line 289
    tmp___6 = strcasecmp((char const   *)var->name, "ice-audio-info");
#line 289
    if (tmp___6) {
#line 309
      tmp___4 = strcasecmp((char const   *)var->name, "ice-password");
#line 309
      if (tmp___4) {
#line 309
        tmp___5 = strcasecmp((char const   *)var->name, "icy-metaint");
#line 309
        if (tmp___5) {
#line 312
          tmp___3 = strncasecmp("ice-", (char const   *)var->name, 4U);
#line 312
          if (tmp___3) {
#line 324
            tmp___2 = strncasecmp("icy-", (char const   *)var->name, 4U);
#line 324
            if (! tmp___2) {
#line 326
              bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"icy%s:%s\r\n",
                               var->name + 3, var->value);
            }
          } else {
#line 314
            tmp___1 = strcasecmp("ice-public", (char const   *)var->name);
#line 314
            if (tmp___1) {
#line 317
              tmp___0 = strcasecmp("ice-bitrate", (char const   *)var->name);
#line 317
              if (tmp___0) {
#line 320
                bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"icy%s:%s\r\n",
                                 var->name + 3, var->value);
              } else {
#line 318
                bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"icy-br:%s\r\n",
                                 var->value);
              }
            } else {
#line 315
              bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"icy-pub:%s\r\n",
                               var->value);
            }
          }
        }
      }
    } else {
#line 292
      brfield = (char *)((void *)0);
#line 295
      if (bitrate_filtered == 0) {
#line 296
        brfield = strstr((char const   *)var->value, "bitrate=");
      }
#line 297
      if (brfield) {
#line 297
        tmp = sscanf((char const   * __restrict  )brfield, (char const   * __restrict  )"bitrate=%u",
                     & bitrate);
#line 297
        if (tmp) {
#line 299
          bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"icy-br:%u\r\n",
                           bitrate);
#line 300
          next = 0;
#line 301
          bitrate_filtered = 1;
        } else {
#line 305
          bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"%s: %s\r\n",
                           var->name, var->value);
        }
      } else {
#line 305
        bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"%s: %s\r\n",
                         var->name, var->value);
      }
    }
#line 332
    remaining -= (unsigned int )bytes;
#line 333
    ptr += bytes;
#line 334
    if (next) {
#line 335
      node = avl_get_next(node);
    }
  }
#line 337
  avl_tree_unlock((source->parser)->vars);
#line 339
  bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"Server: %s\r\n",
                   "Icecast 2.3.1");
#line 340
  remaining -= (unsigned int )bytes;
#line 341
  ptr += bytes;
#line 343
  bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"\r\n");
#line 344
  remaining -= (unsigned int )bytes;
#line 345
  ptr += bytes;
#line 347
  (client->refbuf)->len = (client->refbuf)->len - (unsigned long )remaining;
#line 348
  if ((source->format)->create_client_data) {
#line 349
    tmp___7 = ((*((source->format)->create_client_data)))(source, client);
#line 349
    if (tmp___7 < 0) {
#line 350
      return (-1);
    }
  }
#line 351
  return (0);
}
}
#line 1 "cil-1FYLA9Ul.o"
#pragma merger(0,"/tmp/cil-fVkR4Rtn.i","")
#line 1 "./src/format_ogg.o_saved.c"
#pragma merger(0,"./format_ogg.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 612 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 156 "/usr/include/ogg/ogg.h"
extern int ogg_sync_init(ogg_sync_state *oy ) ;
#line 157
extern int ogg_sync_clear(ogg_sync_state *oy ) ;
#line 161
extern char *ogg_sync_buffer(ogg_sync_state *oy , long size ) ;
#line 162
extern int ogg_sync_wrote(ogg_sync_state *oy , long bytes ) ;
#line 164
extern int ogg_sync_pageout(ogg_sync_state *oy , ogg_page *og ) ;
#line 182
extern int ogg_page_bos(ogg_page *og ) ;
#line 185
extern int ogg_page_serialno(ogg_page *og ) ;
#line 33 "yp.h"
void yp_touch(char const   *mount ) ;
#line 65 "format_ogg.h"
refbuf_t *make_refbuf_with_page(ogg_page *page ) ;
#line 66
void format_ogg_attach_header(ogg_state_t *ogg_info , ogg_page *page ) ;
#line 67
void format_ogg_free_headers(ogg_state_t *ogg_info ) ;
#line 19 "format_vorbis.h"
ogg_codec_t *initial_vorbis_page(format_plugin_t *plugin , ogg_page *page ) ;
#line 19 "format_midi.h"
ogg_codec_t *initial_midi_page(format_plugin_t *plugin , ogg_page *page ) ;
#line 19 "format_flac.h"
ogg_codec_t *initial_flac_page(format_plugin_t *plugin , ogg_page *page ) ;
#line 55 "format_ogg.c"
static void format_ogg_free_plugin(format_plugin_t *plugin ) ;
#line 56
static int create_ogg_client_data(source_t *source , client_t *client ) ;
#line 57
static void free_ogg_client_data(client_t *client ) ;
#line 59
static void write_ogg_to_file(struct source_tag *source , refbuf_t *refbuf ) ;
#line 60
static refbuf_t *ogg_get_buffer(source_t *source ) ;
#line 61
static int write_buf_to_client(client_t *client ) ;
#line 73 "format_ogg.c"
refbuf_t *make_refbuf_with_page(ogg_page *page ) 
{ refbuf_t *refbuf ;
  refbuf_t *tmp ;

  {
#line 75
  tmp = refbuf_new((unsigned long )(page->header_len + page->body_len));
#line 75
  refbuf = tmp;
#line 77
  memcpy((void * __restrict  )refbuf->data, (void const   * __restrict  )page->header,
         (unsigned int )page->header_len);
#line 78
  memcpy((void * __restrict  )(refbuf->data + page->header_len), (void const   * __restrict  )page->body,
         (unsigned int )page->body_len);
#line 79
  return (refbuf);
}
}
#line 86 "format_ogg.c"
void format_ogg_attach_header(ogg_state_t *ogg_info , ogg_page *page ) 
{ refbuf_t *refbuf ;
  refbuf_t *tmp ;
  int tmp___0 ;

  {
#line 88
  tmp = make_refbuf_with_page(page);
#line 88
  refbuf = tmp;
#line 90
  tmp___0 = ogg_page_bos(page);
#line 90
  if (tmp___0) {
#line 92
    log_write(errorlog, 4U, "format-ogg/", "format_ogg_attach_header", "attaching BOS page");
#line 93
    if ((unsigned int )(*(ogg_info->bos_end)) == (unsigned int )((void *)0)) {
#line 94
      ogg_info->header_pages_tail = refbuf;
    }
#line 95
    refbuf->next = (*(ogg_info->bos_end));
#line 96
    (*(ogg_info->bos_end)) = refbuf;
#line 97
    ogg_info->bos_end = & refbuf->next;
#line 98
    return;
  }
#line 100
  log_write(errorlog, 4U, "format-ogg/", "format_ogg_attach_header", "attaching header page");
#line 101
  if (ogg_info->header_pages_tail) {
#line 102
    (ogg_info->header_pages_tail)->next = refbuf;
  }
#line 103
  ogg_info->header_pages_tail = refbuf;
#line 105
  if ((unsigned int )ogg_info->header_pages == (unsigned int )((void *)0)) {
#line 106
    ogg_info->header_pages = refbuf;
  }
#line 107
  return;
}
}
#line 110 "format_ogg.c"
void format_ogg_free_headers(ogg_state_t *ogg_info ) 
{ refbuf_t *header ;
  refbuf_t *to_release ;

  {
#line 115
  log_write(errorlog, 4U, "format-ogg/", "format_ogg_free_headers", "releasing header pages");
#line 116
  header = ogg_info->header_pages;
#line 117
  while (header) {
#line 119
    to_release = header;
#line 120
    header = header->next;
#line 121
    refbuf_release(to_release);
  }
#line 123
  ogg_info->header_pages = (refbuf_t *)((void *)0);
#line 124
  ogg_info->header_pages_tail = (refbuf_t *)((void *)0);
#line 125
  ogg_info->bos_end = & ogg_info->header_pages;
#line 126
  return;
}
}
#line 130 "format_ogg.c"
static void free_ogg_codecs(ogg_state_t *ogg_info ) 
{ ogg_codec_t *codec ;
  ogg_codec_t *next ;

  {
#line 134
  if ((unsigned int )ogg_info == (unsigned int )((void *)0)) {
#line 135
    return;
  }
#line 137
  format_ogg_free_headers(ogg_info);
#line 140
  codec = ogg_info->codecs;
#line 141
  log_write(errorlog, 4U, "format-ogg/", "free_ogg_codecs", "freeing codecs");
#line 142
  while (codec) {
#line 144
    next = codec->next;
#line 145
    if (codec->possible_start) {
#line 146
      refbuf_release(codec->possible_start);
    }
#line 147
    ((*(codec->codec_free)))(ogg_info, codec);
#line 148
    codec = next;
  }
#line 150
  ogg_info->codecs = (struct ogg_codec_tag *)((void *)0);
#line 151
  ogg_info->current = (struct ogg_codec_tag *)((void *)0);
#line 152
  ogg_info->bos_completed = 0;
#line 153
  ogg_info->codec_count = 0;
#line 154
  return;
}
}
#line 157 "format_ogg.c"
int format_ogg_get_plugin(source_t *source ) 
{ format_plugin_t *plugin ;
  ogg_state_t *state ;
  ogg_state_t *tmp ;

  {
#line 160
  tmp = (ogg_state_t *)calloc(1U, sizeof(ogg_state_t ));
#line 160
  state = tmp;
#line 162
  plugin = (format_plugin_t *)calloc(1U, sizeof(format_plugin_t ));
#line 164
  plugin->type = 1;
#line 165
  plugin->get_buffer = & ogg_get_buffer;
#line 166
  plugin->write_buf_to_client = & write_buf_to_client;
#line 167
  plugin->write_buf_to_file = & write_ogg_to_file;
#line 168
  plugin->create_client_data = & create_ogg_client_data;
#line 169
  plugin->free_plugin = & format_ogg_free_plugin;
#line 170
  plugin->set_tag = (void (*)(struct _format_plugin_tag *plugin , char *tag , char *value ))((void *)0);
#line 171
  plugin->contenttype = (char *)"application/ogg";
#line 173
  ogg_sync_init(& state->oy);
#line 175
  plugin->_state = (void *)state;
#line 176
  source->format = plugin;
#line 177
  state->mount = source->mount;
#line 178
  state->bos_end = & state->header_pages;
#line 180
  return (0);
}
}
#line 184 "format_ogg.c"
static void format_ogg_free_plugin(format_plugin_t *plugin ) 
{ ogg_state_t *state ;

  {
#line 186
  state = (ogg_state_t *)plugin->_state;
#line 189
  free_ogg_codecs(state);
#line 190
  free((void *)state->artist);
#line 191
  free((void *)state->title);
#line 193
  ogg_sync_clear(& state->oy);
#line 194
  free((void *)state);
#line 196
  free((void *)plugin);
#line 197
  return;
}
}
#line 201 "format_ogg.c"
static int process_initial_page(format_plugin_t *plugin , ogg_page *page ) 
{ ogg_state_t *ogg_info ;
  ogg_codec_t *codec ;

  {
#line 203
  ogg_info = (ogg_state_t *)plugin->_state;
#line 206
  if (ogg_info->bos_completed) {
#line 208
    ogg_info->bitrate = 0L;
#line 209
    ogg_info->codec_sync = (struct ogg_codec_tag *)((void *)0);
#line 211
    free_ogg_codecs(ogg_info);
  }
#line 213
  while (1) {
#line 215
    if (ogg_info->codec_count > 10) {
#line 217
      log_write(errorlog, 1U, "format-ogg/", "process_initial_page", "many codecs in stream, playing safe, dropping source");
#line 218
      ogg_info->error = 1;
#line 219
      return (-1);
    }
#line 221
    codec = initial_vorbis_page(plugin, page);
#line 222
    if (codec) {
#line 223
      break;
    }
#line 229
    codec = initial_midi_page(plugin, page);
#line 230
    if (codec) {
#line 231
      break;
    }
#line 232
    codec = initial_flac_page(plugin, page);
#line 233
    if (codec) {
#line 234
      break;
    }
#line 242
    log_write(errorlog, 1U, "format-ogg/", "process_initial_page", "Seen BOS page with unknown type");
#line 243
    return (-1);
#line 213
    break;
  }
#line 246
  if (codec) {
#line 249
    codec->next = ogg_info->codecs;
#line 250
    ogg_info->codecs = codec;
#line 251
    ogg_info->codec_count ++;
  }
#line 254
  return (0);
}
}
#line 262 "format_ogg.c"
static void update_comments(source_t *source ) 
{ ogg_state_t *ogg_info ;
  char *title ;
  char *artist ;
  char *metadata ;
  unsigned int len ;
  ogg_codec_t *codec ;
  char codec_names[100] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int len___0 ;
  int tmp___3 ;
  int remaining ;
  char *where ;
  char *separator ;

  {
#line 264
  ogg_info = (ogg_state_t *)(source->format)->_state;
#line 265
  title = ogg_info->title;
#line 266
  artist = ogg_info->artist;
#line 267
  metadata = (char *)((void *)0);
#line 268
  len = 1U;
#line 270
  codec_names[0] = (char )'\000';
#line 272
  if (ogg_info->artist) {
#line 274
    if (title) {
#line 276
      tmp = strlen((char const   *)artist);
#line 276
      tmp___0 = strlen((char const   *)title);
#line 276
      len += (tmp + tmp___0) + 3U;
#line 277
      metadata = (char *)calloc(1U, len);
#line 278
      snprintf((char * __restrict  )metadata, len, (char const   * __restrict  )"%s - %s",
               artist, title);
    } else {
#line 282
      tmp___1 = strlen((char const   *)artist);
#line 282
      len += tmp___1;
#line 283
      metadata = (char *)calloc(1U, len);
#line 284
      snprintf((char * __restrict  )metadata, len, (char const   * __restrict  )"%s",
               artist);
    }
  } else {
#line 289
    if (title) {
#line 291
      tmp___2 = strlen((char const   *)title);
#line 291
      len += tmp___2;
#line 292
      metadata = (char *)calloc(1U, len);
#line 293
      snprintf((char * __restrict  )metadata, len, (char const   * __restrict  )"%s",
               title);
    }
  }
#line 296
  if (metadata) {
#line 298
    logging_playlist((char const   *)source->mount, (char const   *)metadata, (long )source->listeners);
#line 299
    free((void *)metadata);
  }
#line 301
  stats_event((char const   *)source->mount, "artist", (char const   *)artist);
#line 302
  stats_event((char const   *)source->mount, "title", (char const   *)title);
#line 304
  codec = ogg_info->codecs;
#line 305
  while (codec) {
#line 307
    if (codec->name) {
#line 309
      tmp___3 = (int )strlen((char const   *)(codec_names));
#line 309
      len___0 = tmp___3;
#line 310
      remaining = (int )(sizeof(codec_names) - (unsigned int )len___0);
#line 311
      where = codec_names + len___0;
#line 312
      separator = (char *)"/";
#line 313
      if (len___0 == 0) {
#line 314
        separator = (char *)"";
      }
#line 315
      snprintf((char * __restrict  )where, (unsigned int )remaining, (char const   * __restrict  )"%s%s",
               separator, codec->name);
    }
#line 317
    codec = codec->next;
  }
#line 319
  stats_event((char const   *)source->mount, "subtype", (char const   *)(codec_names));
#line 320
  yp_touch((char const   *)source->mount);
#line 321
  return;
}
}
#line 327 "format_ogg.c"
static refbuf_t *complete_buffer(source_t *source , refbuf_t *refbuf ) 
{ ogg_state_t *ogg_info ;
  refbuf_t *header ;

  {
#line 329
  ogg_info = (ogg_state_t *)(source->format)->_state;
#line 330
  header = ogg_info->header_pages;
#line 332
  while (header) {
#line 334
    refbuf_addref(header);
#line 335
    header = header->next;
  }
#line 337
  refbuf->associated = ogg_info->header_pages;
#line 339
  if (ogg_info->log_metadata) {
#line 341
    update_comments(source);
#line 342
    ogg_info->log_metadata = 0;
  }
#line 346
  if ((unsigned int )ogg_info->codec_sync == (unsigned int )((void *)0)) {
#line 347
    refbuf->sync_point = 1;
  }
#line 348
  return (refbuf);
}
}
#line 355 "format_ogg.c"
static refbuf_t *process_ogg_page(ogg_state_t *ogg_info , ogg_page *page ) 
{ ogg_codec_t *codec ;
  refbuf_t *refbuf ;
  int tmp ;

  {
#line 357
  codec = ogg_info->codecs;
#line 358
  refbuf = (refbuf_t *)((void *)0);
#line 360
  while (codec) {
#line 362
    tmp = ogg_page_serialno(page);
#line 362
    if ((long )tmp == codec->os.serialno) {
#line 364
      if (codec->process_page) {
#line 365
        refbuf = ((*(codec->process_page)))(ogg_info, codec, page);
      }
#line 366
      break;
    }
#line 369
    codec = codec->next;
  }
#line 371
  ogg_info->current = codec;
#line 372
  return (refbuf);
}
}
#line 380 "format_ogg.c"
static refbuf_t *ogg_get_buffer(source_t *source ) 
{ ogg_state_t *ogg_info ;
  format_plugin_t *format ;
  char *data ;
  int bytes ;
  ogg_page page ;
  refbuf_t *refbuf ;
  ogg_codec_t *codec ;
  refbuf_t *tmp ;
  int tmp___0 ;
  refbuf_t *tmp___1 ;
  int tmp___2 ;

  {
#line 382
  ogg_info = (ogg_state_t *)(source->format)->_state;
#line 383
  format = source->format;
#line 384
  data = (char *)((void *)0);
#line 385
  bytes = 0;
#line 387
  while (1) {
#line 389
    while (1) {
#line 392
      refbuf = (refbuf_t *)((void *)0);
#line 393
      codec = ogg_info->current;
#line 396
      if (codec) {
#line 396
        if (codec->process) {
#line 398
          refbuf = ((*(codec->process)))(ogg_info, codec);
#line 399
          if (refbuf) {
#line 400
            tmp = complete_buffer(source, refbuf);
#line 400
            return (tmp);
          }
#line 402
          ogg_info->current = (struct ogg_codec_tag *)((void *)0);
        }
      }
#line 405
      tmp___2 = ogg_sync_pageout(& ogg_info->oy, & page);
#line 405
      if (tmp___2 > 0) {
#line 407
        tmp___0 = ogg_page_bos(& page);
#line 407
        if (tmp___0) {
#line 409
          process_initial_page(source->format, & page);
        } else {
#line 413
          ogg_info->bos_completed = 1;
#line 414
          refbuf = process_ogg_page(ogg_info, & page);
        }
#line 416
        if (ogg_info->error) {
#line 418
          log_write(errorlog, 1U, "format-ogg/", "ogg_get_buffer", "Problem processing stream");
#line 419
          source->running = 0;
#line 420
          return ((refbuf_t *)((void *)0));
        }
#line 422
        if (refbuf) {
#line 423
          tmp___1 = complete_buffer(source, refbuf);
#line 423
          return (tmp___1);
        }
#line 424
        continue;
      }
#line 427
      break;
    }
#line 430
    data = ogg_sync_buffer(& ogg_info->oy, 4096L);
#line 432
    bytes = client_read_bytes(source->client, (void *)data, 4096U);
#line 433
    if (bytes <= 0) {
#line 435
      ogg_sync_wrote(& ogg_info->oy, 0L);
#line 436
      return ((refbuf_t *)((void *)0));
    }
#line 438
    format->read_bytes = format->read_bytes + (uint64_t )bytes;
#line 439
    ogg_sync_wrote(& ogg_info->oy, (long )bytes);
  }
}
}
#line 444 "format_ogg.c"
static int create_ogg_client_data(source_t *source , client_t *client ) 
{ struct ogg_client *client_data ;
  struct ogg_client *tmp ;
  int ret ;

  {
#line 446
  tmp = (struct ogg_client *)calloc(1U, sizeof(struct ogg_client ));
#line 446
  client_data = tmp;
#line 447
  ret = -1;
#line 449
  if (client_data) {
#line 451
    client_data->headers_sent = 1;
#line 452
    client->format_data = (void *)client_data;
#line 453
    client->free_client_data = & free_ogg_client_data;
#line 454
    ret = 0;
  }
#line 456
  return (ret);
}
}
#line 460 "format_ogg.c"
static void free_ogg_client_data(client_t *client ) 
{ 

  {
#line 462
  free(client->format_data);
#line 463
  client->format_data = (void *)0;
#line 464
  return;
}
}
#line 470 "format_ogg.c"
static int send_ogg_headers(client_t *client , refbuf_t *headers ) 
{ struct ogg_client *client_data ;
  refbuf_t *refbuf ;
  int written ;
  char *data ;
  unsigned int len ;
  int ret ;
  int tmp ;

  {
#line 472
  client_data = (struct ogg_client *)client->format_data;
#line 474
  written = 0;
#line 476
  if (client_data->headers_sent) {
#line 478
    client_data->header_page = headers;
#line 479
    client_data->pos = 0U;
#line 480
    client_data->headers_sent = 0;
  }
#line 482
  refbuf = client_data->header_page;
#line 483
  while (refbuf) {
#line 485
    data = refbuf->data + client_data->pos;
#line 486
    len = (unsigned int )(refbuf->len - (unsigned long )client_data->pos);
#line 489
    ret = client_send_bytes(client, (void const   *)data, len);
#line 490
    if (ret > 0) {
#line 491
      written += ret;
    }
#line 492
    if (ret < (int )len) {
#line 493
      if (written) {
#line 493
        tmp = written;
      } else {
#line 493
        tmp = -1;
      }
#line 493
      return (tmp);
    }
#line 494
    client_data->pos += (unsigned int )ret;
#line 495
    if ((unsigned long )client_data->pos == refbuf->len) {
#line 497
      refbuf = refbuf->next;
#line 498
      client_data->header_page = refbuf;
#line 499
      client_data->pos = 0U;
    }
  }
#line 502
  client_data->headers_sent = 1;
#line 503
  client_data->headers = headers;
#line 504
  return (written);
}
}
#line 511 "format_ogg.c"
static int write_buf_to_client(client_t *client ) 
{ refbuf_t *refbuf ;
  char *buf ;
  unsigned int len ;
  struct ogg_client *client_data ;
  int ret ;
  int written ;

  {
#line 513
  refbuf = client->refbuf;
#line 514
  buf = refbuf->data + client->pos;
#line 515
  len = (unsigned int )(refbuf->len - client->pos);
#line 516
  client_data = (struct ogg_client *)client->format_data;
#line 517
  written = 0;
#line 519
  while (1) {
#line 521
    if ((unsigned int )client_data->headers != (unsigned int )refbuf->associated) {
#line 523
      ret = send_ogg_headers(client, refbuf->associated);
#line 524
      if (client_data->headers_sent == 0) {
#line 525
        break;
      }
#line 526
      written += ret;
    }
#line 528
    ret = client_send_bytes(client, (void const   *)buf, len);
#line 530
    if (ret > 0) {
#line 531
      client->pos = client->pos + (unsigned long )ret;
    }
#line 533
    if (ret < (int )len) {
#line 534
      break;
    }
#line 535
    written += ret;
#line 537
    ret = 0;
#line 519
    break;
  }
#line 540
  if (ret > 0) {
#line 541
    written += ret;
  }
#line 542
  return (written);
}
}
#line 546 "format_ogg.c"
static int write_ogg_data(struct source_tag *source , refbuf_t *refbuf ) 
{ int ret ;
  size_t tmp ;

  {
#line 548
  ret = 1;
#line 550
  tmp = fwrite((void const   * __restrict  )refbuf->data, 1U, (unsigned int )refbuf->len,
               (FILE * __restrict  )source->dumpfile);
#line 550
  if ((unsigned long )tmp != refbuf->len) {
#line 552
    log_write(errorlog, 2U, "format-ogg/", "write_ogg_data", "Write to dump file failed, disabling");
#line 553
    fclose(source->dumpfile);
#line 554
    source->dumpfile = (FILE *)((void *)0);
#line 555
    ret = 0;
  }
#line 557
  return (ret);
}
}
#line 561 "format_ogg.c"
static void write_ogg_to_file(struct source_tag *source , refbuf_t *refbuf ) 
{ ogg_state_t *ogg_info ;
  refbuf_t *header ;
  int tmp ;

  {
#line 563
  ogg_info = (ogg_state_t *)(source->format)->_state;
#line 565
  if ((unsigned int )ogg_info->file_headers != (unsigned int )refbuf->associated) {
#line 567
    header = refbuf->associated;
#line 568
    while (header) {
#line 570
      tmp = write_ogg_data(source, header);
#line 570
      if (tmp == 0) {
#line 571
        return;
      }
#line 572
      header = header->next;
    }
#line 574
    ogg_info->file_headers = refbuf->associated;
  }
#line 576
  write_ogg_data(source, refbuf);
#line 577
  return;
}
}
#line 1 "cil-ofEPj2JH.o"
#pragma merger(0,"/tmp/cil-qeLAKAgt.i","")
#line 1 "./src/format_mp3.o_saved.c"
#pragma merger(0,"./format_mp3.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 56 "format_mp3.c"
static void format_mp3_free_plugin(format_plugin_t *self ) ;
#line 57
static refbuf_t *mp3_get_filter_meta(source_t *source ) ;
#line 58
static refbuf_t *mp3_get_no_meta(source_t *source ) ;
#line 60
static int format_mp3_create_client_data(source_t *source , client_t *client ) ;
#line 61
static void free_mp3_client_data(client_t *client ) ;
#line 62
static int format_mp3_write_buf_to_client(client_t *client ) ;
#line 63
static void write_mp3_to_file(struct source_tag *source , refbuf_t *refbuf ) ;
#line 64
static void mp3_set_tag(format_plugin_t *plugin , char *tag , char *value ) ;
#line 65
static void format_mp3_apply_settings(client_t *client , format_plugin_t *format ,
                                      mount_proxy *mount ) ;
#line 76 "format_mp3.c"
int format_mp3_get_plugin(struct source_tag *source ) 
{ char *metadata ;
  format_plugin_t *plugin ;
  mp3_state *state ;
  mp3_state *tmp ;
  refbuf_t *meta ;

  {
#line 80
  tmp = (mp3_state *)calloc(1U, sizeof(mp3_state ));
#line 80
  state = tmp;
#line 83
  plugin = (format_plugin_t *)calloc(1U, sizeof(format_plugin_t ));
#line 85
  plugin->type = 2;
#line 86
  plugin->get_buffer = & mp3_get_no_meta;
#line 87
  plugin->write_buf_to_client = & format_mp3_write_buf_to_client;
#line 88
  plugin->write_buf_to_file = & write_mp3_to_file;
#line 89
  plugin->create_client_data = & format_mp3_create_client_data;
#line 90
  plugin->free_plugin = & format_mp3_free_plugin;
#line 91
  plugin->set_tag = & mp3_set_tag;
#line 92
  plugin->apply_settings = & format_mp3_apply_settings;
#line 94
  plugin->contenttype = httpp_getvar(source->parser, "content-type");
#line 95
  if ((unsigned int )plugin->contenttype == (unsigned int )((void *)0)) {
#line 97
    plugin->contenttype = (char *)"audio/mpeg";
  }
#line 100
  plugin->_state = (void *)state;
#line 104
  meta = refbuf_new(17UL);
#line 105
  memcpy((void * __restrict  )meta->data, (void const   * __restrict  )"\001StreamTitle=\'\';",
         17U);
#line 106
  state->metadata = meta;
#line 107
  state->interval = -1;
#line 109
  metadata = httpp_getvar(source->parser, "icy-metaint");
#line 110
  if (metadata) {
#line 112
    state->inline_metadata_interval = atoi__extinline((char const   *)metadata);
#line 113
    if (state->inline_metadata_interval > 0) {
#line 115
      state->offset = 0;
#line 116
      plugin->get_buffer = & mp3_get_filter_meta;
#line 117
      state->interval = state->inline_metadata_interval;
    }
  }
#line 120
  source->format = plugin;
#line 121
  thread_mutex_create_c(& state->url_lock, 121, (char *)"format_mp3.c");
#line 123
  return (0);
}
}
#line 127 "format_mp3.c"
static void mp3_set_tag(format_plugin_t *plugin , char *tag , char *value ) 
{ mp3_state *source_mp3 ;
  unsigned int len ;
  char meta[14] ;
  int size ;
  size_t tmp ;
  char *p ;
  char *tmp___9 ;
  char *p___0 ;
  char *tmp___19 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;

  {
#line 129
  source_mp3 = (mp3_state *)plugin->_state;
#line 131
  meta[0] = (char )'S';
#line 131
  meta[1] = (char )'t';
#line 131
  meta[2] = (char )'r';
#line 131
  meta[3] = (char )'e';
#line 131
  meta[4] = (char )'a';
#line 131
  meta[5] = (char )'m';
#line 131
  meta[6] = (char )'T';
#line 131
  meta[7] = (char )'i';
#line 131
  meta[8] = (char )'t';
#line 131
  meta[9] = (char )'l';
#line 131
  meta[10] = (char )'e';
#line 131
  meta[11] = (char )'=';
#line 131
  meta[12] = (char )'\'';
#line 131
  meta[13] = (char )'\000';
#line 132
  size = (int )(sizeof(meta) + 1U);
#line 134
  if ((unsigned int )tag == (unsigned int )((void *)0)) {
#line 135
    return;
  } else {
#line 134
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 135
      return;
    }
  }
#line 137
  tmp = strlen((char const   *)value);
#line 137
  len = tmp + 1U;
#line 138
  size = (int )((unsigned int )size + len);
#line 140
  thread_mutex_lock_c(& source_mp3->url_lock, 140, (char *)"format_mp3.c");
#line 141
  if (0) {
#line 141
    __s1_len___0 = strlen((char const   *)tag);
#line 141
    __s2_len___0 = strlen("title");
#line 141
    if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
           1U)) {
      goto _L___2;
    } else {
#line 141
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 141
        if (! ((unsigned int )((void const   *)("title" + 1)) - (unsigned int )((void const   *)"title") ==
               1U)) {
#line 141
          tmp___39 = 1;
        } else {
#line 141
          if (__s2_len___0 >= 4U) {
#line 141
            tmp___39 = 1;
          } else {
#line 141
            tmp___39 = 0;
          }
        }
      } else {
#line 141
        tmp___39 = 0;
      }
    }
#line 141
    if (tmp___39) {
#line 141
      tmp___35 = __builtin_strcmp((char const   *)tag, "title");
    } else {
#line 141
      tmp___38 = __builtin_strcmp((char const   *)tag, "title");
#line 141
      tmp___35 = tmp___38;
    }
  } else {
#line 141
    tmp___38 = __builtin_strcmp((char const   *)tag, "title");
#line 141
    tmp___35 = tmp___38;
  }
#line 141
  if (tmp___35 == 0) {
    goto _L___5;
  } else {
#line 141
    if (0) {
#line 141
      __s1_len___1 = strlen((char const   *)tag);
#line 141
      __s2_len___1 = strlen("song");
#line 141
      if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
             1U)) {
        goto _L___4;
      } else {
#line 141
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 141
          if (! ((unsigned int )((void const   *)("song" + 1)) - (unsigned int )((void const   *)"song") ==
                 1U)) {
#line 141
            tmp___49 = 1;
          } else {
#line 141
            if (__s2_len___1 >= 4U) {
#line 141
              tmp___49 = 1;
            } else {
#line 141
              tmp___49 = 0;
            }
          }
        } else {
#line 141
          tmp___49 = 0;
        }
      }
#line 141
      if (tmp___49) {
#line 141
        tmp___45 = __builtin_strcmp((char const   *)tag, "song");
      } else {
#line 141
        tmp___48 = __builtin_strcmp((char const   *)tag, "song");
#line 141
        tmp___45 = tmp___48;
      }
    } else {
#line 141
      tmp___48 = __builtin_strcmp((char const   *)tag, "song");
#line 141
      tmp___45 = tmp___48;
    }
#line 141
    if (tmp___45 == 0) {
      _L___5: /* CIL Label */ 
#line 143
      tmp___9 = __strdup((char const   *)value);
#line 143
      p = tmp___9;
#line 144
      if (p) {
#line 146
        free((void *)source_mp3->url_title);
#line 147
        free((void *)source_mp3->url_artist);
#line 148
        source_mp3->url_artist = (char *)((void *)0);
#line 149
        source_mp3->url_title = p;
#line 150
        source_mp3->update_metadata = 1;
      }
    } else {
#line 153
      if (0) {
#line 153
        __s1_len = strlen((char const   *)tag);
#line 153
        __s2_len = strlen("artist");
#line 153
        if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
               1U)) {
          goto _L___0;
        } else {
#line 153
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 153
            if (! ((unsigned int )((void const   *)("artist" + 1)) - (unsigned int )((void const   *)"artist") ==
                   1U)) {
#line 153
              tmp___29 = 1;
            } else {
#line 153
              if (__s2_len >= 4U) {
#line 153
                tmp___29 = 1;
              } else {
#line 153
                tmp___29 = 0;
              }
            }
          } else {
#line 153
            tmp___29 = 0;
          }
        }
#line 153
        if (tmp___29) {
#line 153
          tmp___25 = __builtin_strcmp((char const   *)tag, "artist");
        } else {
#line 153
          tmp___28 = __builtin_strcmp((char const   *)tag, "artist");
#line 153
          tmp___25 = tmp___28;
        }
      } else {
#line 153
        tmp___28 = __builtin_strcmp((char const   *)tag, "artist");
#line 153
        tmp___25 = tmp___28;
      }
#line 153
      if (tmp___25 == 0) {
#line 155
        tmp___19 = __strdup((char const   *)value);
#line 155
        p___0 = tmp___19;
#line 156
        if (p___0) {
#line 158
          free((void *)source_mp3->url_artist);
#line 159
          source_mp3->url_artist = p___0;
#line 160
          source_mp3->update_metadata = 1;
        }
      }
    }
  }
#line 163
  thread_mutex_unlock_c(& source_mp3->url_lock, 163, (char *)"format_mp3.c");
#line 164
  return;
}
}
#line 167 "format_mp3.c"
static void filter_shoutcast_metadata(source_t *source , char *metadata , unsigned int meta_len ) 
{ char *end ;
  char *p ;
  int len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 169
  if (metadata) {
#line 174
    while (1) {
#line 176
      metadata ++;
#line 177
      if (0) {
#line 177
        if (0) {
#line 177
          __s1_len___0 = strlen((char const   *)metadata);
#line 177
          __s2_len___0 = strlen("StreamTitle=\'");
#line 177
          if (! ((unsigned int )((void const   *)(metadata + 1)) - (unsigned int )((void const   *)metadata) ==
                 1U)) {
            goto _L___2;
          } else {
#line 177
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 177
              if (! ((unsigned int )((void const   *)("StreamTitle=\'" + 1)) - (unsigned int )((void const   *)"StreamTitle=\'") ==
                     1U)) {
#line 177
                tmp___22 = 1;
              } else {
#line 177
                if (__s2_len___0 >= 4U) {
#line 177
                  tmp___22 = 1;
                } else {
#line 177
                  tmp___22 = 0;
                }
              }
            } else {
#line 177
              tmp___22 = 0;
            }
          }
#line 177
          if (tmp___22) {
#line 177
            tmp___18 = __builtin_strcmp((char const   *)metadata, "StreamTitle=\'");
          } else {
#line 177
            tmp___21 = __builtin_strcmp((char const   *)metadata, "StreamTitle=\'");
#line 177
            tmp___18 = tmp___21;
          }
        } else {
#line 177
          tmp___21 = __builtin_strcmp((char const   *)metadata, "StreamTitle=\'");
#line 177
          tmp___18 = tmp___21;
        }
#line 177
        tmp___12 = tmp___18;
      } else {
#line 177
        tmp___12 = strncmp((char const   *)metadata, "StreamTitle=\'", 13U);
      }
#line 177
      if (tmp___12) {
#line 178
        break;
      }
#line 179
      end = strstr((char const   *)metadata, "\';");
#line 179
      if ((unsigned int )end == (unsigned int )((void *)0)) {
#line 180
        break;
      }
#line 181
      len = (end - metadata) - 13;
#line 182
      p = (char *)calloc(1U, (unsigned int )(len + 1));
#line 183
      if (p) {
#line 185
        memcpy((void * __restrict  )p, (void const   * __restrict  )(metadata + 13),
               (unsigned int )len);
#line 186
        logging_playlist((char const   *)source->mount, (char const   *)p, (long )source->listeners);
#line 187
        stats_event((char const   *)source->mount, "title", (char const   *)p);
#line 188
        yp_touch((char const   *)source->mount);
#line 189
        free((void *)p);
      }
#line 174
      break;
    }
  }
#line 193
  return;
}
}
#line 196 "format_mp3.c"
static void format_mp3_apply_settings(client_t *client , format_plugin_t *format ,
                                      mount_proxy *mount ) 
{ mp3_state *source_mp3 ;
  char *metadata ;
  char *tmp ;
  int interval ;
  int tmp___0 ;

  {
#line 198
  source_mp3 = (mp3_state *)format->_state;
#line 200
  if ((unsigned int )mount == (unsigned int )((void *)0)) {
    goto _L;
  } else {
#line 200
    if (mount->mp3_meta_interval < 0) {
      _L: /* CIL Label */ 
#line 202
      tmp = httpp_getvar(client->parser, "icy-metaint");
#line 202
      metadata = tmp;
#line 203
      source_mp3->interval = -1;
#line 204
      if (metadata) {
#line 206
        tmp___0 = atoi__extinline((char const   *)metadata);
#line 206
        interval = tmp___0;
#line 207
        if (interval > 0) {
#line 208
          source_mp3->interval = interval;
        }
      }
    } else {
#line 212
      source_mp3->interval = mount->mp3_meta_interval;
    }
  }
#line 213
  log_write(errorlog, 4U, "format-mp3/", "format_mp3_apply_settings", "mp3 interval %d",
            source_mp3->interval);
#line 214
  return;
}
}
#line 220 "format_mp3.c"
static void mp3_set_title(source_t *source ) 
{ char meta[14] ;
  int size ;
  unsigned char len_byte ;
  refbuf_t *p ;
  unsigned int len ;
  mp3_state *source_mp3 ;
  size_t tmp ;
  size_t tmp___0 ;
  mp3_state *source_mp3___0 ;

  {
#line 222
  meta[0] = (char )'S';
#line 222
  meta[1] = (char )'t';
#line 222
  meta[2] = (char )'r';
#line 222
  meta[3] = (char )'e';
#line 222
  meta[4] = (char )'a';
#line 222
  meta[5] = (char )'m';
#line 222
  meta[6] = (char )'T';
#line 222
  meta[7] = (char )'i';
#line 222
  meta[8] = (char )'t';
#line 222
  meta[9] = (char )'l';
#line 222
  meta[10] = (char )'e';
#line 222
  meta[11] = (char )'=';
#line 222
  meta[12] = (char )'\'';
#line 222
  meta[13] = (char )'\000';
#line 226
  len = sizeof(meta) + 2U;
#line 227
  source_mp3 = (mp3_state *)(source->format)->_state;
#line 230
  thread_mutex_lock_c(& source_mp3->url_lock, 230, (char *)"format_mp3.c");
#line 233
  if (source_mp3->url_artist) {
#line 234
    tmp = strlen((char const   *)source_mp3->url_artist);
#line 234
    len += tmp;
  }
#line 235
  if (source_mp3->url_title) {
#line 236
    tmp___0 = strlen((char const   *)source_mp3->url_title);
#line 236
    len += tmp___0;
  }
#line 237
  if (source_mp3->url_artist) {
#line 237
    if (source_mp3->url_title) {
#line 238
      len += 3U;
    }
  }
#line 240
  if (len > 4080U) {
#line 242
    thread_mutex_unlock_c(& source_mp3->url_lock, 242, (char *)"format_mp3.c");
#line 243
    log_write(errorlog, 2U, "format-mp3/", "mp3_set_title", "Metadata too long at %d chars",
              len);
#line 244
    return;
  }
#line 247
  len_byte = (unsigned char )((len - 1U) / 16U + 1U);
#line 250
  size = (int )len_byte * 16 + 1;
#line 252
  p = refbuf_new((unsigned long )size);
#line 253
  if (p) {
#line 255
    source_mp3___0 = (mp3_state *)(source->format)->_state;
#line 257
    memset((void *)p->data, '\000', (unsigned int )size);
#line 258
    if (source_mp3___0->url_artist) {
#line 258
      if (source_mp3___0->url_title) {
#line 259
        snprintf((char * __restrict  )p->data, (unsigned int )size, (char const   * __restrict  )"%c%s%s - %s\';",
                 len_byte, meta, source_mp3___0->url_artist, source_mp3___0->url_title);
      } else {
#line 262
        snprintf((char * __restrict  )p->data, (unsigned int )size, (char const   * __restrict  )"%c%s%s\';",
                 len_byte, meta, source_mp3___0->url_title);
      }
    } else {
#line 262
      snprintf((char * __restrict  )p->data, (unsigned int )size, (char const   * __restrict  )"%c%s%s\';",
               len_byte, meta, source_mp3___0->url_title);
    }
#line 264
    filter_shoutcast_metadata(source, p->data, (unsigned int )size);
#line 266
    refbuf_release(source_mp3___0->metadata);
#line 267
    source_mp3___0->metadata = p;
  }
#line 269
  thread_mutex_unlock_c(& source_mp3->url_lock, 269, (char *)"format_mp3.c");
#line 270
  return;
}
}
#line 277 "format_mp3.c"
static int send_mp3_metadata(client_t *client , refbuf_t *associated ) 
{ int ret ;
  unsigned char *metadata ;
  int meta_len ;
  mp3_client_data *client_mp3 ;
  char *meta ;

  {
#line 279
  ret = 0;
#line 282
  client_mp3 = (mp3_client_data *)client->format_data;
#line 287
  if (associated) {
#line 287
    if ((unsigned int )associated != (unsigned int )client_mp3->associated) {
#line 289
      metadata = (unsigned char *)(associated->data + client_mp3->metadata_offset);
#line 290
      meta_len = (int )(associated->len - (unsigned long )client_mp3->metadata_offset);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 294
    if (associated) {
#line 296
      metadata = (unsigned char *)"\000";
#line 297
      meta_len = 1;
    } else {
#line 301
      meta = (char *)"\001StreamTitle=\'\';";
#line 302
      metadata = (unsigned char *)(meta + client_mp3->metadata_offset);
#line 303
      meta_len = 17 - client_mp3->metadata_offset;
    }
  }
#line 306
  ret = client_send_bytes(client, (void const   *)metadata, (unsigned int )meta_len);
#line 308
  if (ret == meta_len) {
#line 310
    client_mp3->associated = associated;
#line 311
    client_mp3->metadata_offset = 0;
#line 312
    client_mp3->in_metadata = 0;
#line 313
    client_mp3->since_meta_block = 0U;
#line 314
    return (ret);
  }
#line 316
  if (ret > 0) {
#line 317
    client_mp3->metadata_offset += ret;
  } else {
#line 319
    ret = 0;
  }
#line 320
  client_mp3->in_metadata = 1;
#line 322
  return (ret);
}
}
#line 329 "format_mp3.c"
static int format_mp3_write_buf_to_client(client_t *client ) 
{ int ret ;
  int written ;
  mp3_client_data *client_mp3 ;
  refbuf_t *refbuf ;
  char *buf ;
  unsigned int len ;
  refbuf_t *associated ;
  unsigned int remaining ;

  {
#line 331
  written = 0;
#line 332
  client_mp3 = (mp3_client_data *)client->format_data;
#line 333
  refbuf = client->refbuf;
#line 334
  buf = refbuf->data + client->pos;
#line 335
  len = (unsigned int )(refbuf->len - client->pos);
#line 337
  while (1) {
#line 340
    if (client_mp3->in_metadata) {
#line 342
      associated = refbuf->associated;
#line 343
      ret = send_mp3_metadata(client, associated);
#line 345
      if (client_mp3->in_metadata) {
#line 346
        break;
      }
#line 347
      written += ret;
    }
#line 350
    if (client_mp3->interval) {
#line 352
      remaining = client_mp3->interval - client_mp3->since_meta_block;
#line 356
      if (remaining <= len) {
#line 359
        if (remaining) {
#line 361
          ret = client_send_bytes(client, (void const   *)buf, remaining);
#line 363
          if (ret > 0) {
#line 365
            client_mp3->since_meta_block += (unsigned int )ret;
#line 366
            client->pos = client->pos + (unsigned long )ret;
          }
#line 368
          if (ret < (int )remaining) {
#line 369
            break;
          }
#line 370
          written += ret;
        }
#line 372
        ret = send_mp3_metadata(client, refbuf->associated);
#line 373
        if (client_mp3->in_metadata) {
#line 374
          break;
        }
#line 375
        written += ret;
#line 377
        buf += remaining;
#line 378
        len -= remaining;
#line 380
        if (len > client_mp3->interval) {
#line 381
          len = client_mp3->interval;
        }
      }
    }
#line 385
    if (len) {
#line 387
      ret = client_send_bytes(client, (void const   *)buf, len);
#line 389
      if (ret > 0) {
#line 391
        client_mp3->since_meta_block += (unsigned int )ret;
#line 392
        client->pos = client->pos + (unsigned long )ret;
      }
#line 394
      if (ret < (int )len) {
#line 395
        break;
      }
#line 396
      written += ret;
    }
#line 398
    ret = 0;
#line 337
    break;
  }
#line 401
  if (ret > 0) {
#line 402
    written += ret;
  }
#line 403
  return (written);
}
}
#line 406 "format_mp3.c"
static void format_mp3_free_plugin(format_plugin_t *self ) 
{ mp3_state *state ;

  {
#line 409
  state = (mp3_state *)self->_state;
#line 411
  thread_mutex_destroy(& state->url_lock);
#line 412
  free((void *)state->url_artist);
#line 413
  free((void *)state->url_title);
#line 414
  refbuf_release(state->metadata);
#line 415
  refbuf_release(state->read_data);
#line 416
  free((void *)state);
#line 417
  free((void *)self);
#line 418
  return;
}
}
#line 426 "format_mp3.c"
static int complete_read(source_t *source ) 
{ int bytes ;
  format_plugin_t *format ;
  mp3_state *source_mp3 ;
  char *buf ;
  refbuf_t *refbuf ;

  {
#line 429
  format = source->format;
#line 430
  source_mp3 = (mp3_state *)format->_state;
#line 436
  if ((unsigned int )source_mp3->read_data == (unsigned int )((void *)0)) {
#line 438
    source_mp3->read_data = refbuf_new(1400UL);
#line 439
    source_mp3->read_count = 0U;
  }
#line 441
  buf = (source_mp3->read_data)->data + source_mp3->read_count;
#line 443
  bytes = client_read_bytes(source->client, (void *)buf, 1400U - source_mp3->read_count);
#line 444
  if (bytes < 0) {
#line 446
    if (((source->client)->con)->error) {
#line 448
      refbuf_release(source_mp3->read_data);
#line 449
      source_mp3->read_data = (refbuf_t *)((void *)0);
    }
#line 451
    return (0);
  }
#line 453
  source_mp3->read_count += (unsigned int )bytes;
#line 454
  refbuf = source_mp3->read_data;
#line 455
  refbuf->len = (unsigned long )source_mp3->read_count;
#line 456
  format->read_bytes = format->read_bytes + (uint64_t )bytes;
#line 458
  if (source_mp3->read_count < 1400U) {
#line 460
    if (source_mp3->read_count == 0U) {
#line 462
      refbuf_release(source_mp3->read_data);
#line 463
      source_mp3->read_data = (refbuf_t *)((void *)0);
    }
#line 465
    return (0);
  }
#line 467
  return (1);
}
}
#line 472 "format_mp3.c"
static refbuf_t *mp3_get_no_meta(source_t *source ) 
{ refbuf_t *refbuf ;
  mp3_state *source_mp3 ;
  int tmp ;

  {
#line 475
  source_mp3 = (mp3_state *)(source->format)->_state;
#line 477
  tmp = complete_read(source);
#line 477
  if (tmp == 0) {
#line 478
    return ((refbuf_t *)((void *)0));
  }
#line 480
  refbuf = source_mp3->read_data;
#line 481
  source_mp3->read_data = (refbuf_t *)((void *)0);
#line 483
  if (source_mp3->update_metadata) {
#line 485
    mp3_set_title(source);
#line 486
    source_mp3->update_metadata = 0;
  }
#line 488
  refbuf->associated = source_mp3->metadata;
#line 489
  refbuf_addref(source_mp3->metadata);
#line 490
  refbuf->sync_point = 1;
#line 491
  return (refbuf);
}
}
#line 499 "format_mp3.c"
static refbuf_t *mp3_get_filter_meta(source_t *source ) 
{ refbuf_t *refbuf ;
  format_plugin_t *plugin ;
  mp3_state *source_mp3 ;
  unsigned char *src ;
  unsigned int bytes ;
  unsigned int mp3_block ;
  int tmp ;
  unsigned int metadata_remaining ;
  refbuf_t *meta ;
  refbuf_t *tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 502
  plugin = source->format;
#line 503
  source_mp3 = (mp3_state *)plugin->_state;
#line 507
  tmp = complete_read(source);
#line 507
  if (tmp == 0) {
#line 508
    return ((refbuf_t *)((void *)0));
  }
#line 510
  refbuf = source_mp3->read_data;
#line 511
  source_mp3->read_data = (refbuf_t *)((void *)0);
#line 512
  src = (unsigned char *)refbuf->data;
#line 514
  if (source_mp3->update_metadata) {
#line 516
    mp3_set_title(source);
#line 517
    source_mp3->update_metadata = 0;
  }
#line 520
  bytes = source_mp3->read_count;
#line 521
  refbuf->len = 0UL;
#line 522
  while (bytes > 0U) {
#line 526
    mp3_block = (unsigned int )(source_mp3->inline_metadata_interval - source_mp3->offset);
#line 529
    if (bytes <= mp3_block) {
#line 531
      refbuf->len = refbuf->len + (unsigned long )bytes;
#line 532
      source_mp3->offset = (int )((unsigned int )source_mp3->offset + bytes);
#line 533
      break;
    }
#line 537
    if (mp3_block) {
#line 539
      src += mp3_block;
#line 540
      bytes -= mp3_block;
#line 541
      refbuf->len = refbuf->len + (unsigned long )mp3_block;
#line 542
      source_mp3->offset = (int )((unsigned int )source_mp3->offset + mp3_block);
#line 543
      continue;
    }
#line 547
    if (source_mp3->build_metadata_len == 0U) {
#line 549
      memset((void *)(source_mp3->build_metadata), 0, sizeof(source_mp3->build_metadata));
#line 551
      source_mp3->build_metadata_offset = 0U;
#line 552
      source_mp3->build_metadata_len = (unsigned int )(1 + (int )(*src) * 16);
    }
#line 556
    metadata_remaining = source_mp3->build_metadata_len - source_mp3->build_metadata_offset;
#line 558
    if (bytes < metadata_remaining) {
#line 560
      memcpy((void * __restrict  )(source_mp3->build_metadata + source_mp3->build_metadata_offset),
             (void const   * __restrict  )src, bytes);
#line 562
      source_mp3->build_metadata_offset += bytes;
#line 563
      break;
    }
#line 567
    memcpy((void * __restrict  )(source_mp3->build_metadata + source_mp3->build_metadata_offset),
           (void const   * __restrict  )src, metadata_remaining - 1U);
#line 571
    bytes -= metadata_remaining;
#line 572
    memmove((void *)src, (void const   *)(src + metadata_remaining), bytes);
#line 576
    if (source_mp3->build_metadata_len > 1U) {
#line 576
      if (0) {
#line 576
        __s1_len___1 = strlen((char const   *)(source_mp3->build_metadata + 1));
#line 576
        __s2_len___1 = strlen((char const   *)((source_mp3->metadata)->data + 1));
#line 576
        if (! ((unsigned int )((void const   *)((source_mp3->build_metadata + 1) +
                                                1)) - (unsigned int )((void const   *)(source_mp3->build_metadata +
                                                                                       1)) ==
               1U)) {
          goto _L___4;
        } else {
#line 576
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 576
            if (! ((unsigned int )((void const   *)(((source_mp3->metadata)->data +
                                                     1) + 1)) - (unsigned int )((void const   *)((source_mp3->metadata)->data +
                                                                                                 1)) ==
                   1U)) {
#line 576
              tmp___36 = 1;
            } else {
#line 576
              if (__s2_len___1 >= 4U) {
#line 576
                tmp___36 = 1;
              } else {
#line 576
                tmp___36 = 0;
              }
            }
          } else {
#line 576
            tmp___36 = 0;
          }
        }
#line 576
        if (tmp___36) {
#line 576
          tmp___32 = __builtin_strcmp((char const   *)(source_mp3->build_metadata +
                                                       1), (char const   *)((source_mp3->metadata)->data +
                                                                            1));
        } else {
#line 576
          tmp___35 = __builtin_strcmp((char const   *)(source_mp3->build_metadata +
                                                       1), (char const   *)((source_mp3->metadata)->data +
                                                                            1));
#line 576
          tmp___32 = tmp___35;
        }
      } else {
#line 576
        tmp___35 = __builtin_strcmp((char const   *)(source_mp3->build_metadata +
                                                     1), (char const   *)((source_mp3->metadata)->data +
                                                                          1));
#line 576
        tmp___32 = tmp___35;
      }
#line 576
      if (tmp___32 != 0) {
#line 578
        tmp___0 = refbuf_new((unsigned long )source_mp3->build_metadata_len);
#line 578
        meta = tmp___0;
#line 579
        memcpy((void * __restrict  )meta->data, (void const   * __restrict  )(source_mp3->build_metadata),
               source_mp3->build_metadata_len);
#line 582
        log_write(errorlog, 4U, "format-mp3/", "mp3_get_filter_meta", "shoutcast metadata %.4080s",
                  meta->data + 1);
#line 583
        if (0) {
#line 583
          if (0) {
#line 583
            __s1_len___0 = strlen((char const   *)(meta->data + 1));
#line 583
            __s2_len___0 = strlen("StreamTitle=");
#line 583
            if (! ((unsigned int )((void const   *)((meta->data + 1) + 1)) - (unsigned int )((void const   *)(meta->data +
                                                                                                              1)) ==
                   1U)) {
              goto _L___2;
            } else {
#line 583
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 583
                if (! ((unsigned int )((void const   *)("StreamTitle=" + 1)) - (unsigned int )((void const   *)"StreamTitle=") ==
                       1U)) {
#line 583
                  tmp___24 = 1;
                } else {
#line 583
                  if (__s2_len___0 >= 4U) {
#line 583
                    tmp___24 = 1;
                  } else {
#line 583
                    tmp___24 = 0;
                  }
                }
              } else {
#line 583
                tmp___24 = 0;
              }
            }
#line 583
            if (tmp___24) {
#line 583
              tmp___20 = __builtin_strcmp((char const   *)(meta->data + 1), "StreamTitle=");
            } else {
#line 583
              tmp___23 = __builtin_strcmp((char const   *)(meta->data + 1), "StreamTitle=");
#line 583
              tmp___20 = tmp___23;
            }
          } else {
#line 583
            tmp___23 = __builtin_strcmp((char const   *)(meta->data + 1), "StreamTitle=");
#line 583
            tmp___20 = tmp___23;
          }
#line 583
          tmp___14 = tmp___20;
        } else {
#line 583
          tmp___14 = strncmp((char const   *)(meta->data + 1), "StreamTitle=", 12U);
        }
#line 583
        if (tmp___14 == 0) {
#line 585
          filter_shoutcast_metadata(source, source_mp3->build_metadata, source_mp3->build_metadata_len);
#line 587
          refbuf_release(source_mp3->metadata);
#line 588
          source_mp3->metadata = meta;
        } else {
#line 592
          log_write(errorlog, 1U, "format-mp3/", "mp3_get_filter_meta", "Incorrect metadata format, ending stream");
#line 593
          source->running = 0;
#line 594
          refbuf_release(refbuf);
#line 595
          refbuf_release(meta);
#line 596
          return ((refbuf_t *)((void *)0));
        }
      }
    }
#line 599
    source_mp3->offset = 0;
#line 600
    source_mp3->build_metadata_len = 0U;
  }
#line 603
  if (refbuf->len == 0UL) {
#line 605
    refbuf_release(refbuf);
#line 606
    return ((refbuf_t *)((void *)0));
  }
#line 608
  refbuf->associated = source_mp3->metadata;
#line 609
  refbuf_addref(source_mp3->metadata);
#line 610
  refbuf->sync_point = 1;
#line 612
  return (refbuf);
}
}
#line 616 "format_mp3.c"
static int format_mp3_create_client_data(source_t *source , client_t *client ) 
{ mp3_client_data *client_mp3 ;
  mp3_client_data *tmp ;
  mp3_state *source_mp3 ;
  char const   *metadata ;
  unsigned int remaining ;
  char *ptr ;
  int bytes ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 618
  tmp = (mp3_client_data *)calloc(1U, sizeof(mp3_client_data ));
#line 618
  client_mp3 = tmp;
#line 619
  source_mp3 = (mp3_state *)(source->format)->_state;
#line 622
  remaining = (unsigned int )((4096UL - (client->refbuf)->len) + 2UL);
#line 623
  ptr = ((client->refbuf)->data + (client->refbuf)->len) - 2;
#line 626
  if ((unsigned int )client_mp3 == (unsigned int )((void *)0)) {
#line 627
    return (-1);
  }
#line 630
  tmp___0 = httpp_getvar(client->parser, "x-flash-version");
#line 630
  if (tmp___0) {
#line 632
    bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"Content-Length: 347122319\r\n");
#line 633
    remaining -= (unsigned int )bytes;
#line 634
    ptr += bytes;
  }
#line 637
  client->format_data = (void *)client_mp3;
#line 638
  client->free_client_data = & free_mp3_client_data;
#line 639
  metadata = (char const   *)httpp_getvar(client->parser, "icy-metadata");
#line 640
  if (metadata) {
#line 640
    tmp___1 = atoi__extinline(metadata);
#line 640
    if (tmp___1) {
#line 642
      if (source_mp3->interval >= 0) {
#line 643
        client_mp3->interval = (unsigned int )source_mp3->interval;
      } else {
#line 645
        client_mp3->interval = 16000U;
      }
#line 646
      if (client_mp3->interval) {
#line 648
        bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"icy-metaint:%u\r\n",
                         client_mp3->interval);
#line 650
        if (bytes > 0) {
#line 652
          remaining -= (unsigned int )bytes;
#line 653
          ptr += bytes;
        }
      }
    }
  }
#line 657
  bytes = snprintf((char * __restrict  )ptr, remaining, (char const   * __restrict  )"\r\n");
#line 658
  remaining -= (unsigned int )bytes;
#line 659
  ptr += bytes;
#line 661
  (client->refbuf)->len = (unsigned long )(4096U - remaining);
#line 663
  return (0);
}
}
#line 667 "format_mp3.c"
static void free_mp3_client_data(client_t *client ) 
{ 

  {
#line 669
  free(client->format_data);
#line 670
  client->format_data = (void *)0;
#line 671
  return;
}
}
#line 674 "format_mp3.c"
static void write_mp3_to_file(struct source_tag *source , refbuf_t *refbuf ) 
{ size_t tmp ;

  {
#line 676
  if (refbuf->len == 0UL) {
#line 677
    return;
  }
#line 678
  tmp = fwrite((void const   * __restrict  )refbuf->data, 1U, (unsigned int )refbuf->len,
               (FILE * __restrict  )source->dumpfile);
#line 678
  if (tmp < (unsigned int )refbuf->len) {
#line 680
    log_write(errorlog, 2U, "format-mp3/", "write_mp3_to_file", "Write to dump file failed, disabling");
#line 681
    fclose(source->dumpfile);
#line 682
    source->dumpfile = (FILE *)((void *)0);
  }
#line 684
  return;
}
}
#line 1 "cil-bxeW9mYq.o"
#pragma merger(0,"/tmp/cil-u2tmobXe.i","")
#line 1 "./src/format_midi.o_saved.c"
#pragma merger(0,"./format_midi.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 165 "/usr/include/ogg/ogg.h"
extern int ogg_stream_pagein(ogg_stream_state *os , ogg_page *og ) ;
#line 166
extern int ogg_stream_packetout(ogg_stream_state *os , ogg_packet *op ) ;
#line 171
extern int ogg_stream_init(ogg_stream_state *os , int serialno ) ;
#line 172
extern int ogg_stream_clear(ogg_stream_state *os ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 35 "format_midi.c"
static void midi_codec_free(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ 

  {
#line 37
  log_write(errorlog, 4U, "format-midi/", "midi_codec_free", "freeing MIDI codec");
#line 38
  ogg_stream_clear(& codec->os);
#line 39
  free((void *)codec);
#line 40
  return;
}
}
#line 44 "format_midi.c"
static refbuf_t *process_midi_page(ogg_state_t *ogg_info , ogg_codec_t *codec , ogg_page *page ) 
{ refbuf_t *refbuf ;
  int tmp ;

  {
#line 48
  tmp = ogg_stream_pagein(& codec->os, page);
#line 48
  if (tmp < 0) {
#line 50
    ogg_info->error = 1;
#line 51
    return ((refbuf_t *)((void *)0));
  }
#line 53
  refbuf = make_refbuf_with_page(page);
#line 54
  return (refbuf);
}
}
#line 60 "format_midi.c"
ogg_codec_t *initial_midi_page(format_plugin_t *plugin , ogg_page *page ) 
{ ogg_state_t *ogg_info ;
  ogg_codec_t *codec ;
  ogg_codec_t *tmp ;
  ogg_packet packet ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 62
  ogg_info = (ogg_state_t *)plugin->_state;
#line 63
  tmp = (ogg_codec_t *)calloc(1U, sizeof(ogg_codec_t ));
#line 63
  codec = tmp;
#line 66
  tmp___0 = ogg_page_serialno(page);
#line 66
  ogg_stream_init(& codec->os, tmp___0);
#line 67
  ogg_stream_pagein(& codec->os, page);
#line 69
  ogg_stream_packetout(& codec->os, & packet);
#line 71
  log_write(errorlog, 4U, "format-midi/", "initial_midi_page", "checking for MIDI codec");
#line 72
  while (! (packet.bytes < 9L)) {
#line 76
    tmp___1 = memcmp((void const   *)packet.packet, (void const   *)"OggMIDI\000",
                     8U);
#line 76
    if (tmp___1 != 0) {
#line 77
      break;
    }
#line 78
    if (packet.bytes != 12L) {
#line 79
      break;
    }
#line 81
    log_write(errorlog, 3U, "format-midi/", "initial_midi_page", "seen initial MIDI header");
#line 82
    codec->process_page = & process_midi_page;
#line 83
    codec->codec_free = & midi_codec_free;
#line 84
    codec->headers = 1U;
#line 85
    codec->name = "MIDI";
#line 87
    format_ogg_attach_header(ogg_info, page);
#line 88
    return (codec);
#line 72
    break;
  }
#line 91
  ogg_stream_clear(& codec->os);
#line 92
  free((void *)codec);
#line 93
  return ((ogg_codec_t *)((void *)0));
}
}
#line 1 "cil-eysg29FG.o"
#pragma merger(0,"/tmp/cil-BafIVD6f.i","")
#line 1 "./src/format_flac.o_saved.c"
#pragma merger(0,"./format_flac.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 35 "format_flac.c"
static void flac_codec_free(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ 

  {
#line 37
  log_write(errorlog, 4U, "format-flac/", "flac_codec_free", "freeing FLAC codec");
#line 38
  stats_event((char const   *)ogg_info->mount, "FLAC_version", (char const   *)((void *)0));
#line 39
  ogg_stream_clear(& codec->os);
#line 40
  free((void *)codec);
#line 41
  return;
}
}
#line 45 "format_flac.c"
static refbuf_t *process_flac_page(ogg_state_t *ogg_info , ogg_codec_t *codec , ogg_page *page ) 
{ refbuf_t *refbuf ;
  int tmp ;
  ogg_packet packet ;
  int type ;
  int tmp___0 ;

  {
#line 49
  tmp = ogg_stream_pagein(& codec->os, page);
#line 49
  if (tmp < 0) {
#line 51
    ogg_info->error = 1;
#line 52
    return ((refbuf_t *)((void *)0));
  }
#line 54
  if (codec->headers) {
#line 57
    while (1) {
#line 57
      tmp___0 = ogg_stream_packetout(& codec->os, & packet);
#line 57
      if (! tmp___0) {
#line 57
        break;
      }
#line 59
      type = (int )(*(packet.packet + 0));
#line 60
      if (type == 255) {
#line 62
        codec->headers = 0U;
#line 63
        break;
      }
#line 65
      if (type >= 1) {
#line 65
        if (type <= 126) {
#line 66
          continue;
        }
      }
#line 67
      if (type >= 129) {
#line 67
        if (type <= 254) {
#line 68
          continue;
        }
      }
#line 69
      ogg_info->error = 1;
#line 70
      return ((refbuf_t *)((void *)0));
    }
#line 72
    if (codec->headers) {
#line 74
      format_ogg_attach_header(ogg_info, page);
#line 75
      return ((refbuf_t *)((void *)0));
    }
  }
#line 78
  refbuf = make_refbuf_with_page(page);
#line 79
  return (refbuf);
}
}
#line 85 "format_flac.c"
ogg_codec_t *initial_flac_page(format_plugin_t *plugin , ogg_page *page ) 
{ ogg_state_t *ogg_info ;
  ogg_codec_t *codec ;
  ogg_codec_t *tmp ;
  ogg_packet packet ;
  int tmp___0 ;
  unsigned char *parse ;
  int tmp___1 ;

  {
#line 87
  ogg_info = (ogg_state_t *)plugin->_state;
#line 88
  tmp = (ogg_codec_t *)calloc(1U, sizeof(ogg_codec_t ));
#line 88
  codec = tmp;
#line 91
  tmp___0 = ogg_page_serialno(page);
#line 91
  ogg_stream_init(& codec->os, tmp___0);
#line 92
  ogg_stream_pagein(& codec->os, page);
#line 94
  ogg_stream_packetout(& codec->os, & packet);
#line 96
  log_write(errorlog, 4U, "format-flac/", "initial_flac_page", "checking for FLAC codec");
#line 97
  while (1) {
#line 99
    parse = packet.packet;
#line 101
    if (page->header_len + page->body_len != 79L) {
#line 102
      break;
    }
#line 103
    if ((int )(*parse) != 127) {
#line 104
      break;
    }
#line 105
    parse ++;
#line 106
    tmp___1 = memcmp((void const   *)parse, (void const   *)"FLAC", 4U);
#line 106
    if (tmp___1 != 0) {
#line 107
      break;
    }
#line 109
    log_write(errorlog, 3U, "format-flac/", "initial_flac_page", "seen initial FLAC header");
#line 111
    parse += 4;
#line 112
    stats_event_args((char const   *)ogg_info->mount, (char *)"FLAC_version", (char *)"%d.%d",
                     (*(parse + 0)), (*(parse + 1)));
#line 113
    codec->process_page = & process_flac_page;
#line 114
    codec->codec_free = & flac_codec_free;
#line 115
    codec->headers = 1U;
#line 116
    codec->name = "FLAC";
#line 118
    format_ogg_attach_header(ogg_info, page);
#line 119
    return (codec);
#line 97
    break;
  }
#line 122
  ogg_stream_clear(& codec->os);
#line 123
  free((void *)codec);
#line 124
  return ((ogg_codec_t *)((void *)0));
}
}
#line 1 "cil-zA3EBLi7.o"
#pragma merger(0,"/tmp/cil-kt3he3ez.i","")
#line 1 "./src/auth.o_saved.c"
#pragma merger(0,"./auth.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 94 "auth.h"
int auth_postprocess_client(auth_client *auth_user ) ;
#line 20 "auth_htpasswd.h"
int auth_get_htpasswd_auth(auth_t *authenticator , config_options_t *options ) ;
#line 20 "auth_url.h"
int auth_get_url_auth(auth_t *authenticator , config_options_t *options ) ;
#line 40 "auth.c"
static auth_client volatile   *clients_to_auth  ;
#line 41 "auth.c"
static unsigned int volatile   auth_pending_count  ;
#line 42 "auth.c"
static int volatile   auth_running  ;
#line 43 "auth.c"
static mutex_t auth_lock  ;
#line 44 "auth.c"
static thread_type *auth_thread  ;
#line 47 "auth.c"
static void auth_client_setup(mount_proxy *mountinfo , client_t *client ) 
{ char *header ;
  char *tmp ;
  char *userpass ;
  char *tmp___0 ;
  char *username ;
  char *password ;
  char *tmp___2 ;
  char *tmp___12 ;
  char *tmp___22 ;
  int tmp___36 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;

  {
#line 50
  tmp = httpp_getvar(client->parser, "authorization");
#line 50
  header = tmp;
#line 54
  while (! ((unsigned int )header == (unsigned int )((void *)0))) {
#line 59
    if (0) {
#line 59
      if (0) {
#line 59
        __s1_len___0 = strlen((char const   *)header);
#line 59
        __s2_len___0 = strlen("Basic ");
#line 59
        if (! ((unsigned int )((void const   *)(header + 1)) - (unsigned int )((void const   *)header) ==
               1U)) {
          goto _L___2;
        } else {
#line 59
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 59
            if (! ((unsigned int )((void const   *)("Basic " + 1)) - (unsigned int )((void const   *)"Basic ") ==
                   1U)) {
#line 59
              tmp___46 = 1;
            } else {
#line 59
              if (__s2_len___0 >= 4U) {
#line 59
                tmp___46 = 1;
              } else {
#line 59
                tmp___46 = 0;
              }
            }
          } else {
#line 59
            tmp___46 = 0;
          }
        }
#line 59
        if (tmp___46) {
#line 59
          tmp___42 = __builtin_strcmp((char const   *)header, "Basic ");
        } else {
#line 59
          tmp___45 = __builtin_strcmp((char const   *)header, "Basic ");
#line 59
          tmp___42 = tmp___45;
        }
      } else {
#line 59
        tmp___45 = __builtin_strcmp((char const   *)header, "Basic ");
#line 59
        tmp___42 = tmp___45;
      }
#line 59
      tmp___36 = tmp___42;
    } else {
#line 59
      tmp___36 = strncmp((char const   *)header, "Basic ", 6U);
    }
#line 59
    if (tmp___36 == 0) {
#line 61
      userpass = util_base64_decode((unsigned char *)(header + 6));
#line 62
      if ((unsigned int )userpass == (unsigned int )((void *)0)) {
#line 64
        log_write(errorlog, 2U, "auth/", "auth_client_setup", "Base64 decode of Authorization header \"%s\" failed",
                  header + 6);
#line 66
        break;
      }
#line 69
      tmp___2 = __builtin_strchr(userpass, (char )':');
#line 69
      tmp___0 = tmp___2;
#line 70
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 72
        free((void *)userpass);
#line 73
        break;
      }
#line 76
      (*tmp___0) = (char)0;
#line 77
      username = userpass;
#line 78
      password = tmp___0 + 1;
#line 79
      tmp___12 = __strdup((char const   *)username);
#line 79
      client->username = tmp___12;
#line 80
      tmp___22 = __strdup((char const   *)password);
#line 80
      client->password = tmp___22;
#line 81
      free((void *)userpass);
#line 82
      break;
    }
#line 84
    log_write(errorlog, 3U, "auth/", "auth_client_setup", "unhandled authorization header: %s",
              header);
#line 54
    break;
  }
#line 88
  thread_mutex_lock_c(& (mountinfo->auth)->lock, 88, (char *)"auth.c");
#line 89
  client->auth = mountinfo->auth;
#line 90
  (client->auth)->refcount = (client->auth)->refcount + 1;
#line 91
  thread_mutex_unlock_c(& (mountinfo->auth)->lock, 91, (char *)"auth.c");
#line 92
  return;
}
}
#line 95 "auth.c"
static void queue_auth_client(auth_client *auth_user ) 
{ 

  {
#line 97
  thread_mutex_lock_c(& auth_lock, 97, (char *)"auth.c");
#line 98
  auth_user->next = (auth_client *)clients_to_auth;
#line 99
  clients_to_auth = (auth_client volatile   *)auth_user;
#line 100
  auth_pending_count ++;
#line 101
  thread_mutex_unlock_c(& auth_lock, 101, (char *)"auth.c");
#line 102
  return;
}
}
#line 108 "auth.c"
void auth_release(auth_t *authenticator ) 
{ 

  {
#line 110
  if ((unsigned int )authenticator == (unsigned int )((void *)0)) {
#line 111
    return;
  }
#line 113
  thread_mutex_lock_c(& authenticator->lock, 113, (char *)"auth.c");
#line 114
  authenticator->refcount = authenticator->refcount - 1;
#line 115
  if (authenticator->refcount) {
#line 117
    thread_mutex_unlock_c(& authenticator->lock, 117, (char *)"auth.c");
#line 118
    return;
  }
#line 121
  if (authenticator->free) {
#line 122
    ((*(authenticator->free)))(authenticator);
  }
#line 123
  ((*xmlFree))((void *)authenticator->type);
#line 124
  thread_mutex_unlock_c(& authenticator->lock, 124, (char *)"auth.c");
#line 125
  thread_mutex_destroy(& authenticator->lock);
#line 126
  free((void *)authenticator);
#line 127
  return;
}
}
#line 130 "auth.c"
void auth_client_free(auth_client *auth_user ) 
{ client_t *client ;

  {
#line 132
  if ((unsigned int )auth_user == (unsigned int )((void *)0)) {
#line 133
    return;
  }
#line 134
  if (auth_user->client) {
#line 136
    client = auth_user->client;
#line 138
    if (client->respcode) {
#line 139
      client_destroy(client);
    } else {
#line 141
      client_send_401(client);
    }
#line 142
    auth_user->client = (client_t *)((void *)0);
  }
#line 144
  free((void *)auth_user->mount);
#line 145
  free((void *)auth_user);
#line 146
  return;
}
}
#line 152 "auth.c"
static void auth_new_listener(auth_client *auth_user ) 
{ client_t *client ;
  auth_result tmp ;
  int tmp___0 ;

  {
#line 154
  client = auth_user->client;
#line 156
  if ((client->auth)->authenticate) {
#line 158
    tmp = ((*((client->auth)->authenticate)))(auth_user);
#line 158
    if ((int )tmp != 1) {
#line 160
      auth_release(client->auth);
#line 161
      client->auth = (struct auth_tag *)((void *)0);
#line 162
      return;
    }
  }
#line 165
  tmp___0 = auth_postprocess_client(auth_user);
#line 165
  if (tmp___0 < 0) {
#line 166
    log_write(errorlog, 3U, "auth/", "auth_new_listener", "client %lu failed", (client->con)->id);
  }
#line 167
  return;
}
}
#line 173 "auth.c"
static void auth_remove_listener(auth_client *auth_user ) 
{ client_t *client ;

  {
#line 175
  client = auth_user->client;
#line 177
  if ((client->auth)->release_client) {
#line 178
    ((*((client->auth)->release_client)))(auth_user);
  }
#line 179
  auth_release(client->auth);
#line 180
  client->auth = (struct auth_tag *)((void *)0);
#line 181
  return;
}
}
#line 186 "auth.c"
static void *auth_run_thread(void *arg ) 
{ auth_client *auth_user ;

  {
#line 188
  log_write(errorlog, 3U, "auth/", "auth_run_thread", "Authentication thread started");

  thread_register("auth_run_thread");
  thread_check_in();

#line 189
  LOOP_AUTH_RUN_THREAD:while (1) {

    __DSU_update("");

#line 191
    if (clients_to_auth) {

      thread_check_out();

#line 195
      thread_mutex_lock_c(& auth_lock, 195, (char *)"auth.c");
#line 196
      auth_user = (auth_client *)clients_to_auth;
#line 197
      clients_to_auth = (auth_client volatile   *)auth_user->next;
#line 198
      auth_pending_count --;
#line 199
      thread_mutex_unlock_c(& auth_lock, 199, (char *)"auth.c");
#line 200
      auth_user->next = (struct auth_client_tag *)((void *)0);
#line 202
      if (auth_user->process) {
#line 203
        ((*(auth_user->process)))(auth_user);
      } else {
#line 205
        log_write(errorlog, 1U, "auth/", "auth_run_thread", "client auth process not set");
      }
#line 207
      auth_client_free(auth_user);

      thread_check_in();

#line 209
      continue;
    }
#line 212
    if (auth_running == 0) {
#line 213
      break;
    }
#line 214
    thread_sleep(150000UL);
  }

  thread_deregister("auth_run_thread");

#line 216
  log_write(errorlog, 3U, "auth/", "auth_run_thread", "Authenication thread shutting down");
#line 217
  return ((void *)0);
}
}
#line 225 "auth.c"
static int check_duplicate_logins(source_t *source , client_t *client ) 
{ auth_t *auth ;
  avl_node *node ;
  client_t *existing_client ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  client_t *existing_client___0 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 227
  auth = client->auth;
#line 230
  if ((unsigned int )client->username == (unsigned int )((void *)0)) {
#line 231
    return (1);
  }
#line 233
  if (auth) {
#line 233
    if (auth->allow_duplicate_users == 0) {
#line 237
      avl_tree_rlock(source->client_tree);
#line 238
      node = avl_get_first(source->client_tree);
#line 239
      while (node) {
#line 241
        existing_client = (client_t *)node->key;
#line 243
        if (existing_client->username) {
#line 243
          if (0) {
#line 243
            __s1_len = strlen((char const   *)existing_client->username);
#line 243
            __s2_len = strlen((char const   *)client->username);
#line 243
            if (! ((unsigned int )((void const   *)(existing_client->username + 1)) -
                   (unsigned int )((void const   *)existing_client->username) == 1U)) {
              goto _L___0;
            } else {
#line 243
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 243
                if (! ((unsigned int )((void const   *)(client->username + 1)) - (unsigned int )((void const   *)client->username) ==
                       1U)) {
#line 243
                  tmp___8 = 1;
                } else {
#line 243
                  if (__s2_len >= 4U) {
#line 243
                    tmp___8 = 1;
                  } else {
#line 243
                    tmp___8 = 0;
                  }
                }
              } else {
#line 243
                tmp___8 = 0;
              }
            }
#line 243
            if (tmp___8) {
#line 243
              tmp___4 = __builtin_strcmp((char const   *)existing_client->username,
                                         (char const   *)client->username);
            } else {
#line 243
              tmp___7 = __builtin_strcmp((char const   *)existing_client->username,
                                         (char const   *)client->username);
#line 243
              tmp___4 = tmp___7;
            }
          } else {
#line 243
            tmp___7 = __builtin_strcmp((char const   *)existing_client->username,
                                       (char const   *)client->username);
#line 243
            tmp___4 = tmp___7;
          }
#line 243
          if (tmp___4 == 0) {
#line 245
            avl_tree_unlock(source->client_tree);
#line 246
            return (0);
          }
        }
#line 248
        node = avl_get_next(node);
      }
#line 250
      avl_tree_unlock(source->client_tree);
#line 252
      avl_tree_rlock(source->pending_tree);
#line 253
      node = avl_get_first(source->pending_tree);
#line 254
      while (node) {
#line 256
        existing_client___0 = (client_t *)node->key;
#line 258
        if (existing_client___0->username) {
#line 258
          if (0) {
#line 258
            __s1_len___0 = strlen((char const   *)existing_client___0->username);
#line 258
            __s2_len___0 = strlen((char const   *)client->username);
#line 258
            if (! ((unsigned int )((void const   *)(existing_client___0->username +
                                                    1)) - (unsigned int )((void const   *)existing_client___0->username) ==
                   1U)) {
              goto _L___2;
            } else {
#line 258
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 258
                if (! ((unsigned int )((void const   *)(client->username + 1)) - (unsigned int )((void const   *)client->username) ==
                       1U)) {
#line 258
                  tmp___18 = 1;
                } else {
#line 258
                  if (__s2_len___0 >= 4U) {
#line 258
                    tmp___18 = 1;
                  } else {
#line 258
                    tmp___18 = 0;
                  }
                }
              } else {
#line 258
                tmp___18 = 0;
              }
            }
#line 258
            if (tmp___18) {
#line 258
              tmp___14 = __builtin_strcmp((char const   *)existing_client___0->username,
                                          (char const   *)client->username);
            } else {
#line 258
              tmp___17 = __builtin_strcmp((char const   *)existing_client___0->username,
                                          (char const   *)client->username);
#line 258
              tmp___14 = tmp___17;
            }
          } else {
#line 258
            tmp___17 = __builtin_strcmp((char const   *)existing_client___0->username,
                                        (char const   *)client->username);
#line 258
            tmp___14 = tmp___17;
          }
#line 258
          if (tmp___14 == 0) {
#line 260
            avl_tree_unlock(source->pending_tree);
#line 261
            return (0);
          }
        }
#line 263
        node = avl_get_next(node);
      }
#line 265
      avl_tree_unlock(source->pending_tree);
    }
  }
#line 267
  return (1);
}
}
#line 274 "auth.c"
static int add_client_to_source(source_t *source , client_t *client ) 
{ int loop ;
  source_t *next ;
  source_t *tmp ;

  {
#line 276
  loop = 10;
#line 277
  while (1) {
#line 279
    log_write(errorlog, 4U, "auth/", "add_client_to_source", "max on %s is %ld (cur %lu)",
              source->mount, source->max_listeners, source->listeners);
#line 281
    if (source->max_listeners == -1L) {
#line 282
      break;
    }
#line 283
    if (source->listeners < (unsigned long )source->max_listeners) {
#line 284
      break;
    }
#line 286
    if (loop) {
#line 286
      if (source->fallback_when_full) {
#line 286
        if (source->fallback_mount) {
#line 288
          tmp = source_find_mount((char const   *)source->fallback_mount);
#line 288
          next = tmp;
#line 289
          log_write(errorlog, 3U, "auth/", "add_client_to_source", "stream full trying %s",
                    next->mount);
#line 290
          source = next;
#line 291
          loop --;
          goto __Cont;
        }
      }
    }
#line 295
    return (-1);
    __Cont: /* CIL Label */ ;
  }
#line 299
  client->write_to_client = & format_generic_write_to_client;
#line 300
  client->check_buffer = & format_check_http_buffer;
#line 301
  (client->refbuf)->len = 4096UL;
#line 302
  memset((void *)(client->refbuf)->data, 0, 4096U);
#line 305
  avl_tree_wlock(source->pending_tree);
#line 306
  avl_insert(source->pending_tree, (void *)client);
#line 307
  avl_tree_unlock(source->pending_tree);
#line 308
  stats_event_inc((char const   *)((void *)0), "listener_connections");
#line 310
  if (source->running == 0) {
#line 310
    if (source->on_demand) {
#line 313
      log_write(errorlog, 4U, "auth/", "add_client_to_source", "kicking off on-demand relay");
#line 314
      source->on_demand_req = 1;
#line 315
      slave_rescan();
    }
  }
#line 317
  log_write(errorlog, 4U, "auth/", "add_client_to_source", "Added client to %s", source->mount);
#line 318
  return (0);
}
}
#line 325 "auth.c"
static int add_authenticated_client(char const   *mount , mount_proxy *mountinfo ,
                                    client_t *client ) 
{ int ret ;
  source_t *source ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 327
  ret = 0;
#line 328
  source = (source_t *)((void *)0);
#line 330
  avl_tree_rlock(global.source_tree);
#line 331
  source = source_find_mount(mount);
#line 333
  if (source) {
#line 335
    if (client->auth) {
#line 335
      tmp = check_duplicate_logins(source, client);
#line 335
      if (tmp == 0) {
#line 337
        avl_tree_unlock(global.source_tree);
#line 338
        return (-1);
      }
    }
#line 340
    if (mountinfo) {
#line 343
      if (mountinfo->max_listener_duration) {
#line 343
        if ((client->con)->discon_time == 0L) {
#line 344
          tmp___0 = time((time_t *)((void *)0));
#line 344
          (client->con)->discon_time = (long )((unsigned long )tmp___0 + (unsigned long )mountinfo->max_listener_duration);
        }
      }
    }
#line 347
    ret = add_client_to_source(source, client);
#line 348
    avl_tree_unlock(global.source_tree);
#line 349
    if (ret == 0) {
#line 350
      log_write(errorlog, 4U, "auth/", "add_authenticated_client", "client authenticated, passed to source");
    }
  } else {
#line 354
    avl_tree_unlock(global.source_tree);
#line 355
    fserve_client_create(client, mount);
  }
#line 357
  return (ret);
}
}
#line 361 "auth.c"
int auth_postprocess_client(auth_client *auth_user ) 
{ int ret ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;

  {
#line 364
  tmp = config_get_config();
#line 364
  config = tmp;
#line 366
  tmp___0 = config_find_mount(config, (char const   *)auth_user->mount);
#line 366
  mountinfo = tmp___0;
#line 367
  (auth_user->client)->authenticated = 1;
#line 369
  ret = add_authenticated_client((char const   *)auth_user->mount, mountinfo, auth_user->client);
#line 370
  config_release_config();
#line 372
  if (ret < 0) {
#line 373
    client_send_401(auth_user->client);
  }
#line 374
  auth_user->client = (client_t *)((void *)0);
#line 376
  return (ret);
}
}
#line 383 "auth.c"
void add_client(char const   *mount , client_t *client ) 
{ mount_proxy *mountinfo ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  auth_client *auth_user ;
  char *tmp___9 ;
  int ret ;
  int tmp___10 ;

  {
#line 386
  tmp = config_get_config();
#line 386
  config = tmp;
#line 388
  mountinfo = config_find_mount(config, mount);
#line 389
  if (mountinfo) {
#line 389
    if (mountinfo->no_mount) {
#line 391
      config_release_config();
#line 392
      client_send_403(client, "mountpoint unavailable");
#line 393
      return;
    }
  }
#line 395
  if (mountinfo) {
#line 395
    if (mountinfo->auth) {
#line 399
      if (auth_pending_count > 30U) {
#line 401
        config_release_config();
#line 402
        log_write(errorlog, 2U, "auth/", "add_client", "too many clients awaiting authentication");
#line 403
        client_send_403(client, "busy, please try again later");
#line 404
        return;
      }
#line 406
      auth_client_setup(mountinfo, client);
#line 407
      config_release_config();
#line 409
      if ((unsigned int )client->auth == (unsigned int )((void *)0)) {
#line 411
        client_send_401(client);
#line 412
        return;
      }
#line 414
      auth_user = (auth_client *)calloc(1U, sizeof(auth_client ));
#line 415
      if ((unsigned int )auth_user == (unsigned int )((void *)0)) {
#line 417
        client_send_401(client);
#line 418
        return;
      }
#line 420
      tmp___9 = __strdup(mount);
#line 420
      auth_user->mount = tmp___9;
#line 421
      auth_user->process = & auth_new_listener;
#line 422
      auth_user->client = client;
#line 424
      log_write(errorlog, 3U, "auth/", "add_client", "adding client for authentication");
#line 425
      queue_auth_client(auth_user);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 429
    tmp___10 = add_authenticated_client(mount, mountinfo, client);
#line 429
    ret = tmp___10;
#line 430
    config_release_config();
#line 431
    if (ret < 0) {
#line 432
      client_send_403(client, "max listeners reached");
    }
  }
#line 434
  return;
}
}
#line 440 "auth.c"
int release_client(client_t *client ) 
{ auth_client *auth_user ;
  auth_client *tmp ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 442
  if (client->auth) {
#line 444
    tmp = (auth_client *)calloc(1U, sizeof(auth_client ));
#line 444
    auth_user = tmp;
#line 445
    if ((unsigned int )auth_user == (unsigned int )((void *)0)) {
#line 446
      return (0);
    }
#line 448
    tmp___18 = httpp_getvar(client->parser, "__uri");
#line 448
    tmp___19 = __strdup((char const   *)tmp___18);
#line 448
    auth_user->mount = tmp___19;
#line 449
    auth_user->process = & auth_remove_listener;
#line 450
    auth_user->client = client;
#line 452
    queue_auth_client(auth_user);
#line 453
    return (1);
  }
#line 455
  return (0);
}
}
#line 459 "auth.c"
static void get_authenticator(auth_t *auth , config_options_t *options ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 461
  while (1) {
#line 463
    log_write(errorlog, 4U, "auth/", "get_authenticator", "type is %s", auth->type);
#line 465
    if (0) {
#line 465
      __s1_len = strlen((char const   *)auth->type);
#line 465
      __s2_len = strlen("url");
#line 465
      if (! ((unsigned int )((void const   *)(auth->type + 1)) - (unsigned int )((void const   *)auth->type) ==
             1U)) {
        goto _L___0;
      } else {
#line 465
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 465
          if (! ((unsigned int )((void const   *)("url" + 1)) - (unsigned int )((void const   *)"url") ==
                 1U)) {
#line 465
            tmp___8 = 1;
          } else {
#line 465
            if (__s2_len >= 4U) {
#line 465
              tmp___8 = 1;
            } else {
#line 465
              tmp___8 = 0;
            }
          }
        } else {
#line 465
          tmp___8 = 0;
        }
      }
#line 465
      if (tmp___8) {
#line 465
        tmp___4 = __builtin_strcmp((char const   *)auth->type, "url");
      } else {
#line 465
        tmp___7 = __builtin_strcmp((char const   *)auth->type, "url");
#line 465
        tmp___4 = tmp___7;
      }
    } else {
#line 465
      tmp___7 = __builtin_strcmp((char const   *)auth->type, "url");
#line 465
      tmp___4 = tmp___7;
    }
#line 465
    if (tmp___4 == 0) {
#line 467
      auth_get_url_auth(auth, options);
#line 468
      break;
    }
#line 471
    if (0) {
#line 471
      __s1_len___0 = strlen((char const   *)auth->type);
#line 471
      __s2_len___0 = strlen("htpasswd");
#line 471
      if (! ((unsigned int )((void const   *)(auth->type + 1)) - (unsigned int )((void const   *)auth->type) ==
             1U)) {
        goto _L___2;
      } else {
#line 471
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 471
          if (! ((unsigned int )((void const   *)("htpasswd" + 1)) - (unsigned int )((void const   *)"htpasswd") ==
                 1U)) {
#line 471
            tmp___18 = 1;
          } else {
#line 471
            if (__s2_len___0 >= 4U) {
#line 471
              tmp___18 = 1;
            } else {
#line 471
              tmp___18 = 0;
            }
          }
        } else {
#line 471
          tmp___18 = 0;
        }
      }
#line 471
      if (tmp___18) {
#line 471
        tmp___14 = __builtin_strcmp((char const   *)auth->type, "htpasswd");
      } else {
#line 471
        tmp___17 = __builtin_strcmp((char const   *)auth->type, "htpasswd");
#line 471
        tmp___14 = tmp___17;
      }
    } else {
#line 471
      tmp___17 = __builtin_strcmp((char const   *)auth->type, "htpasswd");
#line 471
      tmp___14 = tmp___17;
    }
#line 471
    if (tmp___14 == 0) {
#line 473
      auth_get_htpasswd_auth(auth, options);
#line 474
      break;
    }
#line 477
    log_write(errorlog, 1U, "auth/", "get_authenticator", "Unrecognised authenticator type: \"%s\"",
              auth->type);
#line 478
    return;
#line 461
    break;
  }
#line 481
  auth->refcount = 1;
#line 482
  while (options) {
#line 484
    if (0) {
#line 484
      __s1_len___1 = strlen((char const   *)options->name);
#line 484
      __s2_len___1 = strlen("allow_duplicate_users");
#line 484
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___4;
      } else {
#line 484
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 484
          if (! ((unsigned int )((void const   *)("allow_duplicate_users" + 1)) -
                 (unsigned int )((void const   *)"allow_duplicate_users") == 1U)) {
#line 484
            tmp___28 = 1;
          } else {
#line 484
            if (__s2_len___1 >= 4U) {
#line 484
              tmp___28 = 1;
            } else {
#line 484
              tmp___28 = 0;
            }
          }
        } else {
#line 484
          tmp___28 = 0;
        }
      }
#line 484
      if (tmp___28) {
#line 484
        tmp___24 = __builtin_strcmp((char const   *)options->name, "allow_duplicate_users");
      } else {
#line 484
        tmp___27 = __builtin_strcmp((char const   *)options->name, "allow_duplicate_users");
#line 484
        tmp___24 = tmp___27;
      }
    } else {
#line 484
      tmp___27 = __builtin_strcmp((char const   *)options->name, "allow_duplicate_users");
#line 484
      tmp___24 = tmp___27;
    }
#line 484
    if (tmp___24 == 0) {
#line 485
      auth->allow_duplicate_users = atoi__extinline((char const   *)options->value);
    }
#line 486
    options = options->next;
  }
#line 488
  return;
}
}
#line 491 "auth.c"
auth_t *auth_get_authenticator(xmlNodePtr node ) 
{ auth_t *auth ;
  auth_t *tmp ;
  config_options_t *options ;
  config_options_t **next_option ;
  xmlNodePtr option ;
  xmlNodePtr current ;
  config_options_t *opt ;
  config_options_t *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  config_options_t *opt___0 ;

  {
#line 493
  tmp = (auth_t *)calloc(1U, sizeof(auth_t ));
#line 493
  auth = tmp;
#line 494
  options = (config_options_t *)((void *)0);
#line 494
  next_option = & options;
#line 497
  if ((unsigned int )auth == (unsigned int )((void *)0)) {
#line 498
    return ((auth_t *)((void *)0));
  }
#line 500
  option = node->children;
#line 501
  while (option) {
#line 503
    current = option;
#line 504
    option = option->next;
#line 505
    if (0) {
#line 505
      __s1_len___0 = strlen((char const   *)current->name);
#line 505
      __s2_len___0 = strlen("option");
#line 505
      if (! ((unsigned int )((void const   *)(current->name + 1)) - (unsigned int )((void const   *)current->name) ==
             1U)) {
        goto _L___2;
      } else {
#line 505
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 505
          if (! ((unsigned int )((void const   *)("option" + 1)) - (unsigned int )((void const   *)"option") ==
                 1U)) {
#line 505
            tmp___20 = 1;
          } else {
#line 505
            if (__s2_len___0 >= 4U) {
#line 505
              tmp___20 = 1;
            } else {
#line 505
              tmp___20 = 0;
            }
          }
        } else {
#line 505
          tmp___20 = 0;
        }
      }
#line 505
      if (tmp___20) {
#line 505
        tmp___16 = __builtin_strcmp((char const   *)current->name, "option");
      } else {
#line 505
        tmp___19 = __builtin_strcmp((char const   *)current->name, "option");
#line 505
        tmp___16 = tmp___19;
      }
    } else {
#line 505
      tmp___19 = __builtin_strcmp((char const   *)current->name, "option");
#line 505
      tmp___16 = tmp___19;
    }
#line 505
    if (tmp___16 == 0) {
#line 507
      tmp___0 = (config_options_t *)calloc(1U, sizeof(config_options_t ));
#line 507
      opt = tmp___0;
#line 508
      opt->name = (char *)xmlGetProp(current, (xmlChar const   *)"name");
#line 509
      if ((unsigned int )opt->name == (unsigned int )((void *)0)) {
#line 511
        free((void *)opt);
#line 512
        continue;
      }
#line 514
      opt->value = (char *)xmlGetProp(current, (xmlChar const   *)"value");
#line 515
      if ((unsigned int )opt->value == (unsigned int )((void *)0)) {
#line 517
        ((*xmlFree))((void *)opt->name);
#line 518
        free((void *)opt);
#line 519
        continue;
      }
#line 521
      (*next_option) = opt;
#line 522
      next_option = & opt->next;
    } else {
#line 525
      if (0) {
#line 525
        __s1_len = strlen((char const   *)current->name);
#line 525
        __s2_len = strlen("text");
#line 525
        if (! ((unsigned int )((void const   *)(current->name + 1)) - (unsigned int )((void const   *)current->name) ==
               1U)) {
          goto _L___0;
        } else {
#line 525
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 525
            if (! ((unsigned int )((void const   *)("text" + 1)) - (unsigned int )((void const   *)"text") ==
                   1U)) {
#line 525
              tmp___10 = 1;
            } else {
#line 525
              if (__s2_len >= 4U) {
#line 525
                tmp___10 = 1;
              } else {
#line 525
                tmp___10 = 0;
              }
            }
          } else {
#line 525
            tmp___10 = 0;
          }
        }
#line 525
        if (tmp___10) {
#line 525
          tmp___6 = __builtin_strcmp((char const   *)current->name, "text");
        } else {
#line 525
          tmp___9 = __builtin_strcmp((char const   *)current->name, "text");
#line 525
          tmp___6 = tmp___9;
        }
      } else {
#line 525
        tmp___9 = __builtin_strcmp((char const   *)current->name, "text");
#line 525
        tmp___6 = tmp___9;
      }
#line 525
      if (tmp___6 != 0) {
#line 526
        log_write(errorlog, 2U, "auth/", "auth_get_authenticator", "unknown auth setting (%s)",
                  current->name);
      }
    }
  }
#line 528
  auth->type = (char *)xmlGetProp(node, (xmlChar const   *)"type");
#line 529
  get_authenticator(auth, options);
#line 530
  thread_mutex_create_c(& auth->lock, 530, (char *)"auth.c");
#line 531
  while (options) {
#line 533
    opt___0 = options;
#line 534
    options = opt___0->next;
#line 535
    ((*xmlFree))((void *)opt___0->name);
#line 536
    ((*xmlFree))((void *)opt___0->value);
#line 537
    free((void *)opt___0);
  }
#line 539
  return (auth);
}
}
#line 546 "auth.c"
void auth_stream_start(struct _mount_proxy *mountinfo , char const   *mount ) 
{ auth_client *auth_user ;
  auth_client *tmp ;
  char *tmp___9 ;

  {
#line 548
  if (mountinfo) {
#line 548
    if (mountinfo->auth) {
#line 548
      if ((mountinfo->auth)->stream_start) {
#line 550
        tmp = (auth_client *)calloc(1U, sizeof(auth_client ));
#line 550
        auth_user = tmp;
#line 551
        if (auth_user) {
#line 553
          tmp___9 = __strdup(mount);
#line 553
          auth_user->mount = tmp___9;
#line 554
          auth_user->process = (mountinfo->auth)->stream_start;
#line 556
          queue_auth_client(auth_user);
        }
      }
    }
  }
#line 559
  return;
}
}
#line 565 "auth.c"
void auth_stream_end(struct _mount_proxy *mountinfo , char const   *mount ) 
{ auth_client *auth_user ;
  auth_client *tmp ;
  char *tmp___9 ;

  {
#line 567
  if (mountinfo) {
#line 567
    if (mountinfo->auth) {
#line 567
      if ((mountinfo->auth)->stream_end) {
#line 569
        tmp = (auth_client *)calloc(1U, sizeof(auth_client ));
#line 569
        auth_user = tmp;
#line 570
        if (auth_user) {
#line 572
          tmp___9 = __strdup(mount);
#line 572
          auth_user->mount = tmp___9;
#line 573
          auth_user->process = (mountinfo->auth)->stream_end;
#line 575
          queue_auth_client(auth_user);
        }
      }
    }
  }
#line 578
  return;
}
}
#line 583 "auth.c"
void auth_initialise(void) 
{ 

  {
#line 585
  clients_to_auth = (auth_client volatile   *)((void *)0);
#line 586
  auth_pending_count = (unsigned int volatile   )0;
#line 587
  auth_running = (int volatile   )1;
#line 588
  thread_mutex_create_c(& auth_lock, 588, (char *)"auth.c");
#line 589
  auth_thread = thread_create_c((char *)"auth thread", & auth_run_thread, (void *)0,
                                0, 589, (char *)"auth.c");
#line 590
  return;
}
}
#line 592 "auth.c"
void auth_shutdown(void) 
{ 

  {
#line 594
  if (auth_thread) {
#line 596
    auth_running = (int volatile   )0;
#line 597
    thread_join(auth_thread);
#line 598
    log_write(errorlog, 3U, "auth/", "auth_shutdown", "Auth thread has terminated");
  }
#line 600
  return;
}
}
#line 1 "cil-SUE3AM4S.o"
#pragma merger(0,"/tmp/cil-LC6SJvKo.i","")
#line 1 "./src/auth_htpasswd.o_saved.c"
#pragma merger(0,"./auth_htpasswd.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 42 "auth_htpasswd.c"
static auth_result htpasswd_adduser(auth_t *auth , char const   *username , char const   *password ) ;
#line 43
static auth_result htpasswd_deleteuser(auth_t *auth , char const   *username ) ;
#line 44
static auth_result htpasswd_userlist(auth_t *auth , xmlNodePtr srcnode ) ;
#line 45
static int _free_user(void *key ) ;
#line 60 "auth_htpasswd.c"
static void htpasswd_clear(auth_t *self ) 
{ htpasswd_auth_state *state ;

  {
#line 61
  state = (htpasswd_auth_state *)self->state;
#line 62
  free((void *)state->filename);
#line 63
  if (state->users) {
#line 64
    avl_tree_free(state->users, & _free_user);
  }
#line 65
  thread_rwlock_destroy(& state->file_rwlock);
#line 66
  free((void *)state);
#line 67
  return;
}
}
#line 69 "auth_htpasswd.c"
static int get_line(FILE *file , char *buf , int len ) 
{ int len___0 ;
  int tmp ;
  char *tmp___0 ;

  {
#line 71
  tmp___0 = fgets((char * __restrict  )buf, len, (FILE * __restrict  )file);
#line 71
  if (tmp___0) {
#line 72
    tmp = (int )strlen((char const   *)buf);
#line 72
    len___0 = tmp;
#line 73
    if (len___0 > 0) {
#line 73
      if ((int )(*(buf + (len___0 - 1))) == 10) {
#line 74
        len___0 --;
#line 74
        (*(buf + len___0)) = (char)0;
#line 75
        if (len___0 > 0) {
#line 75
          if ((int )(*(buf + (len___0 - 1))) == 13) {
#line 76
            len___0 --;
#line 76
            (*(buf + len___0)) = (char)0;
          }
        }
      }
    }
#line 78
    return (1);
  }
#line 80
  return (0);
}
}
#line 84 "auth_htpasswd.c"
static char *get_hash(char const   *data , int len ) 
{ struct MD5Context context ;
  unsigned char digest[16] ;
  char *tmp ;

  {
#line 89
  MD5Init(& context);
#line 91
  MD5Update(& context, (unsigned char const   *)data, (unsigned int )len);
#line 93
  MD5Final(digest, & context);
#line 95
  tmp = util_bin_to_hex(digest, 16);
#line 95
  return (tmp);
}
}
#line 101 "auth_htpasswd.c"
static int compare_users(void *arg , void *a , void *b ) 
{ htpasswd_user *user1 ;
  htpasswd_user *user2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 103
  user1 = (htpasswd_user *)a;
#line 104
  user2 = (htpasswd_user *)b;
#line 106
  if (0) {
#line 106
    __s1_len = strlen((char const   *)user1->name);
#line 106
    __s2_len = strlen((char const   *)user2->name);
#line 106
    if (! ((unsigned int )((void const   *)(user1->name + 1)) - (unsigned int )((void const   *)user1->name) ==
           1U)) {
      goto _L___0;
    } else {
#line 106
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 106
        if (! ((unsigned int )((void const   *)(user2->name + 1)) - (unsigned int )((void const   *)user2->name) ==
               1U)) {
#line 106
          tmp___8 = 1;
        } else {
#line 106
          if (__s2_len >= 4U) {
#line 106
            tmp___8 = 1;
          } else {
#line 106
            tmp___8 = 0;
          }
        }
      } else {
#line 106
        tmp___8 = 0;
      }
    }
#line 106
    if (tmp___8) {
#line 106
      tmp___4 = __builtin_strcmp((char const   *)user1->name, (char const   *)user2->name);
    } else {
#line 106
      tmp___7 = __builtin_strcmp((char const   *)user1->name, (char const   *)user2->name);
#line 106
      tmp___4 = tmp___7;
    }
  } else {
#line 106
    tmp___7 = __builtin_strcmp((char const   *)user1->name, (char const   *)user2->name);
#line 106
    tmp___4 = tmp___7;
  }
#line 106
  return (tmp___4);
}
}
#line 110 "auth_htpasswd.c"
static int _free_user(void *key ) 
{ htpasswd_user *user ;

  {
#line 112
  user = (htpasswd_user *)key;
#line 114
  free((void *)user->name);
#line 115
  free((void *)user);
#line 116
  return (1);
}
}
#line 120 "auth_htpasswd.c"
static void htpasswd_recheckfile(htpasswd_auth_state *htpasswd ) 
{ FILE *passwdfile ;
  avl_tree *new_users ;
  int num ;
  struct stat file_stat ;
  char *sep ;
  char line[512] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int len ;
  htpasswd_user *entry ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 124
  num = 0;
#line 129
  tmp = stat__extinline((char const   *)htpasswd->filename, & file_stat);
#line 129
  if (tmp < 0) {
#line 131
    log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_recheckfile", "failed to check status of %s",
              htpasswd->filename);
#line 134
    thread_rwlock_wlock_c(& htpasswd->file_rwlock, 134, (char *)"auth_htpasswd.c");
#line 135
    if (! htpasswd->users) {
#line 136
      htpasswd->users = avl_tree_new(& compare_users, (void *)0);
    }
#line 137
    thread_rwlock_unlock_c(& htpasswd->file_rwlock, 137, (char *)"auth_htpasswd.c");
#line 139
    return;
  }
#line 142
  if (file_stat.st_mtim.tv_sec == htpasswd->mtime) {
#line 145
    return;
  }
#line 147
  log_write(errorlog, 3U, "auth_htpasswd/", "htpasswd_recheckfile", "re-reading htpasswd file \"%s\"",
            htpasswd->filename);
#line 148
  passwdfile = fopen((char const   * __restrict  )htpasswd->filename, (char const   * __restrict  )"rb");
#line 149
  if ((unsigned int )passwdfile == (unsigned int )((void *)0)) {
#line 151
    tmp___0 = __errno_location();
#line 151
    tmp___1 = strerror((*tmp___0));
#line 151
    log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_recheckfile", "Failed to open authentication database \"%s\": %s",
              htpasswd->filename, tmp___1);
#line 153
    return;
  }
#line 155
  htpasswd->mtime = file_stat.st_mtim.tv_sec;
#line 157
  new_users = avl_tree_new(& compare_users, (void *)0);
#line 159
  while (1) {
#line 159
    tmp___3 = get_line(passwdfile, line, 512);
#line 159
    if (! tmp___3) {
#line 159
      break;
    }
#line 164
    num ++;
#line 165
    if (! line[0]) {
#line 166
      continue;
    } else {
#line 165
      if ((int )line[0] == 35) {
#line 166
        continue;
      }
    }
#line 168
    sep = strrchr((char const   *)(line), ':');
#line 169
    if ((unsigned int )sep == (unsigned int )((void *)0)) {
#line 171
      log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_recheckfile", "No separator on line %d (%s)",
                num, htpasswd->filename);
#line 172
      continue;
    }
#line 174
    entry = (htpasswd_user *)calloc(1U, sizeof(htpasswd_user ));
#line 175
    tmp___2 = strlen((char const   *)(line));
#line 175
    len = (int )(tmp___2 + 1U);
#line 176
    entry->name = (char *)malloc((unsigned int )len);
#line 177
    (*sep) = (char)0;
#line 178
    memcpy((void * __restrict  )entry->name, (void const   * __restrict  )(line),
           (unsigned int )len);
#line 179
    entry->pass = (entry->name + (sep - line)) + 1;
#line 180
    avl_insert(new_users, (void *)entry);
  }
#line 182
  fclose(passwdfile);
#line 184
  thread_rwlock_wlock_c(& htpasswd->file_rwlock, 184, (char *)"auth_htpasswd.c");
#line 185
  if (htpasswd->users) {
#line 186
    avl_tree_free(htpasswd->users, & _free_user);
  }
#line 187
  htpasswd->users = new_users;
#line 188
  thread_rwlock_unlock_c(& htpasswd->file_rwlock, 188, (char *)"auth_htpasswd.c");
#line 189
  return;
}
}
#line 192 "auth_htpasswd.c"
static auth_result htpasswd_auth(auth_client *auth_user ) 
{ auth_t *auth ;
  htpasswd_auth_state *htpasswd ;
  client_t *client ;
  htpasswd_user entry ;
  void *result ;
  htpasswd_user *found ;
  char *hashed_pw ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 194
  auth = (auth_user->client)->auth;
#line 195
  htpasswd = (htpasswd_auth_state *)auth->state;
#line 196
  client = auth_user->client;
#line 200
  if ((unsigned int )client->username == (unsigned int )((void *)0)) {
#line 201
    return (2);
  } else {
#line 200
    if ((unsigned int )client->password == (unsigned int )((void *)0)) {
#line 201
      return (2);
    }
  }
#line 203
  htpasswd_recheckfile(htpasswd);
#line 205
  thread_rwlock_rlock_c(& htpasswd->file_rwlock, 205, (char *)"auth_htpasswd.c");
#line 206
  entry.name = client->username;
#line 207
  tmp___10 = avl_get_by_key(htpasswd->users, (void *)(& entry), & result);
#line 207
  if (tmp___10 == 0) {
#line 209
    found = (htpasswd_user *)result;
#line 212
    thread_rwlock_unlock_c(& htpasswd->file_rwlock, 212, (char *)"auth_htpasswd.c");
#line 213
    tmp = strlen((char const   *)client->password);
#line 213
    hashed_pw = get_hash((char const   *)client->password, (int )tmp);
#line 214
    if (0) {
#line 214
      __s1_len = strlen((char const   *)found->pass);
#line 214
      __s2_len = strlen((char const   *)hashed_pw);
#line 214
      if (! ((unsigned int )((void const   *)(found->pass + 1)) - (unsigned int )((void const   *)found->pass) ==
             1U)) {
        goto _L___0;
      } else {
#line 214
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 214
          if (! ((unsigned int )((void const   *)(hashed_pw + 1)) - (unsigned int )((void const   *)hashed_pw) ==
                 1U)) {
#line 214
            tmp___9 = 1;
          } else {
#line 214
            if (__s2_len >= 4U) {
#line 214
              tmp___9 = 1;
            } else {
#line 214
              tmp___9 = 0;
            }
          }
        } else {
#line 214
          tmp___9 = 0;
        }
      }
#line 214
      if (tmp___9) {
#line 214
        tmp___5 = __builtin_strcmp((char const   *)found->pass, (char const   *)hashed_pw);
      } else {
#line 214
        tmp___8 = __builtin_strcmp((char const   *)found->pass, (char const   *)hashed_pw);
#line 214
        tmp___5 = tmp___8;
      }
    } else {
#line 214
      tmp___8 = __builtin_strcmp((char const   *)found->pass, (char const   *)hashed_pw);
#line 214
      tmp___5 = tmp___8;
    }
#line 214
    if (tmp___5 == 0) {
#line 216
      free((void *)hashed_pw);
#line 217
      return (1);
    }
#line 219
    free((void *)hashed_pw);
#line 220
    log_write(errorlog, 4U, "auth_htpasswd/", "htpasswd_auth", "incorrect password for client");
#line 221
    return (2);
  }
#line 223
  log_write(errorlog, 4U, "auth_htpasswd/", "htpasswd_auth", "no such username: %s",
            client->username);
#line 224
  thread_rwlock_unlock_c(& htpasswd->file_rwlock, 224, (char *)"auth_htpasswd.c");
#line 225
  return (2);
}
}
#line 229 "auth_htpasswd.c"
int auth_get_htpasswd_auth(auth_t *authenticator , config_options_t *options ) 
{ htpasswd_auth_state *state ;
  char *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 233
  authenticator->authenticate = & htpasswd_auth;
#line 234
  authenticator->free = & htpasswd_clear;
#line 235
  authenticator->adduser = & htpasswd_adduser;
#line 236
  authenticator->deleteuser = & htpasswd_deleteuser;
#line 237
  authenticator->listuser = & htpasswd_userlist;
#line 239
  state = (htpasswd_auth_state *)calloc(1U, sizeof(htpasswd_auth_state ));
#line 241
  while (options) {
#line 242
    if (0) {
#line 242
      __s1_len = strlen((char const   *)options->name);
#line 242
      __s2_len = strlen("filename");
#line 242
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___0;
      } else {
#line 242
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 242
          if (! ((unsigned int )((void const   *)("filename" + 1)) - (unsigned int )((void const   *)"filename") ==
                 1U)) {
#line 242
            tmp___18 = 1;
          } else {
#line 242
            if (__s2_len >= 4U) {
#line 242
              tmp___18 = 1;
            } else {
#line 242
              tmp___18 = 0;
            }
          }
        } else {
#line 242
          tmp___18 = 0;
        }
      }
#line 242
      if (tmp___18) {
#line 242
        tmp___14 = __builtin_strcmp((char const   *)options->name, "filename");
      } else {
#line 242
        tmp___17 = __builtin_strcmp((char const   *)options->name, "filename");
#line 242
        tmp___14 = tmp___17;
      }
    } else {
#line 242
      tmp___17 = __builtin_strcmp((char const   *)options->name, "filename");
#line 242
      tmp___14 = tmp___17;
    }
#line 242
    if (! tmp___14) {
#line 243
      tmp___8 = __strdup((char const   *)options->value);
#line 243
      state->filename = tmp___8;
    }
#line 244
    options = options->next;
  }
#line 247
  if (! state->filename) {
#line 248
    free((void *)state);
#line 249
    log_write(errorlog, 1U, "auth_htpasswd/", "auth_get_htpasswd_auth", "No filename given in options for authenticator.");
#line 250
    return (-1);
  }
#line 253
  authenticator->state = (void *)state;
#line 254
  log_write(errorlog, 4U, "auth_htpasswd/", "auth_get_htpasswd_auth", "Configured htpasswd authentication using password file %s",
            state->filename);
#line 257
  thread_rwlock_create_c(& state->file_rwlock, 257, (char *)"auth_htpasswd.c");
#line 258
  htpasswd_recheckfile(state);
#line 260
  return (0);
}
}
#line 264 "auth_htpasswd.c"
static auth_result htpasswd_adduser(auth_t *auth , char const   *username , char const   *password ) 
{ FILE *passwdfile ;
  char *hashed_password ;
  htpasswd_auth_state *state ;
  htpasswd_user entry ;
  void *result ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 267
  hashed_password = (char *)((void *)0);
#line 268
  state = (htpasswd_auth_state *)auth->state;
#line 272
  htpasswd_recheckfile(state);
#line 274
  thread_rwlock_wlock_c(& state->file_rwlock, 274, (char *)"auth_htpasswd.c");
#line 276
  entry.name = (char *)username;
#line 277
  tmp = avl_get_by_key(state->users, (void *)(& entry), & result);
#line 277
  if (tmp == 0) {
#line 279
    thread_rwlock_unlock_c(& state->file_rwlock, 279, (char *)"auth_htpasswd.c");
#line 280
    return (5);
  }
#line 283
  passwdfile = fopen((char const   * __restrict  )state->filename, (char const   * __restrict  )"ab");
#line 285
  if ((unsigned int )passwdfile == (unsigned int )((void *)0)) {
#line 287
    thread_rwlock_unlock_c(& state->file_rwlock, 287, (char *)"auth_htpasswd.c");
#line 288
    tmp___0 = __errno_location();
#line 288
    tmp___1 = strerror((*tmp___0));
#line 288
    log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_adduser", "Failed to open authentication database \"%s\": %s",
              state->filename, tmp___1);
#line 290
    return (2);
  }
#line 293
  tmp___2 = strlen(password);
#line 293
  hashed_password = get_hash(password, (int )tmp___2);
#line 294
  if (hashed_password) {
#line 295
    fprintf((FILE * __restrict  )passwdfile, (char const   * __restrict  )"%s:%s\n",
            username, hashed_password);
#line 296
    free((void *)hashed_password);
  }
#line 299
  fclose(passwdfile);
#line 300
  thread_rwlock_unlock_c(& state->file_rwlock, 300, (char *)"auth_htpasswd.c");
#line 302
  return (4);
}
}
#line 306 "auth_htpasswd.c"
static auth_result htpasswd_deleteuser(auth_t *auth , char const   *username ) 
{ FILE *passwdfile ;
  FILE *tmp_passwdfile ;
  htpasswd_auth_state *state ;
  char line[512] ;
  char *sep ;
  char *tmpfile___0 ;
  int tmpfile_len ;
  struct stat file_info ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___6 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 313
  tmpfile___0 = (char *)((void *)0);
#line 314
  tmpfile_len = 0;
#line 317
  state = (htpasswd_auth_state *)auth->state;
#line 318
  thread_rwlock_wlock_c(& state->file_rwlock, 318, (char *)"auth_htpasswd.c");
#line 319
  passwdfile = fopen((char const   * __restrict  )state->filename, (char const   * __restrict  )"rb");
#line 321
  if ((unsigned int )passwdfile == (unsigned int )((void *)0)) {
#line 322
    tmp = __errno_location();
#line 322
    tmp___0 = strerror((*tmp));
#line 322
    log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_deleteuser", "Failed to open authentication database \"%s\": %s",
              state->filename, tmp___0);
#line 324
    thread_rwlock_unlock_c(& state->file_rwlock, 324, (char *)"auth_htpasswd.c");
#line 325
    return (2);
  }
#line 327
  tmp___1 = strlen((char const   *)state->filename);
#line 327
  tmpfile_len = (int )(tmp___1 + 6U);
#line 328
  tmpfile___0 = (char *)calloc(1U, (unsigned int )tmpfile_len);
#line 329
  snprintf((char * __restrict  )tmpfile___0, (unsigned int )tmpfile_len, (char const   * __restrict  )"%s.tmp",
           state->filename);
#line 330
  tmp___2 = stat__extinline((char const   *)tmpfile___0, & file_info);
#line 330
  if (tmp___2 == 0) {
#line 332
    log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_deleteuser", "temp file \"%s\" exists, rejecting operation",
              tmpfile___0);
#line 333
    free((void *)tmpfile___0);
#line 334
    fclose(passwdfile);
#line 335
    thread_rwlock_unlock_c(& state->file_rwlock, 335, (char *)"auth_htpasswd.c");
#line 336
    return (2);
  }
#line 339
  tmp_passwdfile = fopen((char const   * __restrict  )tmpfile___0, (char const   * __restrict  )"wb");
#line 341
  if ((unsigned int )tmp_passwdfile == (unsigned int )((void *)0)) {
#line 342
    tmp___3 = __errno_location();
#line 342
    tmp___4 = strerror((*tmp___3));
#line 342
    log_write(errorlog, 2U, "auth_htpasswd/", "htpasswd_deleteuser", "Failed to open temporary authentication database \"%s\": %s",
              tmpfile___0, tmp___4);
#line 344
    fclose(passwdfile);
#line 345
    free((void *)tmpfile___0);
#line 346
    thread_rwlock_unlock_c(& state->file_rwlock, 346, (char *)"auth_htpasswd.c");
#line 347
    return (2);
  }
#line 351
  while (1) {
#line 351
    tmp___17 = get_line(passwdfile, line, 512);
#line 351
    if (! tmp___17) {
#line 351
      break;
    }
#line 352
    if (! line[0]) {
#line 353
      continue;
    } else {
#line 352
      if ((int )line[0] == 35) {
#line 353
        continue;
      }
    }
#line 355
    tmp___6 = __builtin_strchr(line, (char )':');
#line 355
    sep = tmp___6;
#line 356
    if ((unsigned int )sep == (unsigned int )((void *)0)) {
#line 357
      log_write(errorlog, 4U, "auth_htpasswd/", "htpasswd_deleteuser", "No separator in line");
#line 358
      continue;
    }
#line 361
    (*sep) = (char)0;
#line 362
    if (0) {
#line 362
      __s1_len = strlen(username);
#line 362
      __s2_len = strlen((char const   *)(line));
#line 362
      if (! ((unsigned int )((void const   *)(username + 1)) - (unsigned int )((void const   *)username) ==
             1U)) {
        goto _L___0;
      } else {
#line 362
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 362
          if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)(line)) ==
                 1U)) {
#line 362
            tmp___16 = 1;
          } else {
#line 362
            if (__s2_len >= 4U) {
#line 362
              tmp___16 = 1;
            } else {
#line 362
              tmp___16 = 0;
            }
          }
        } else {
#line 362
          tmp___16 = 0;
        }
      }
#line 362
      if (tmp___16) {
#line 362
        tmp___12 = __builtin_strcmp(username, (char const   *)(line));
      } else {
#line 362
        tmp___15 = __builtin_strcmp(username, (char const   *)(line));
#line 362
        tmp___12 = tmp___15;
      }
    } else {
#line 362
      tmp___15 = __builtin_strcmp(username, (char const   *)(line));
#line 362
      tmp___12 = tmp___15;
    }
#line 362
    if (tmp___12) {
#line 365
      (*sep) = (char )':';
#line 366
      fprintf((FILE * __restrict  )tmp_passwdfile, (char const   * __restrict  )"%s\n",
              line);
    }
  }
#line 370
  fclose(tmp_passwdfile);
#line 371
  fclose(passwdfile);
#line 376
  tmp___23 = remove((char const   *)state->filename);
#line 376
  if (tmp___23 != 0) {
#line 377
    tmp___18 = __errno_location();
#line 377
    tmp___19 = strerror((*tmp___18));
#line 377
    log_write(errorlog, 1U, "auth_htpasswd/", "htpasswd_deleteuser", "Problem moving temp authentication file to original \"%s\" - \"%s\": %s",
              tmpfile___0, state->filename, tmp___19);
  } else {
#line 381
    tmp___22 = rename((char const   *)tmpfile___0, (char const   *)state->filename);
#line 381
    if (tmp___22 != 0) {
#line 382
      tmp___20 = __errno_location();
#line 382
      tmp___21 = strerror((*tmp___20));
#line 382
      log_write(errorlog, 1U, "auth_htpasswd/", "htpasswd_deleteuser", "Problem moving temp authentication file to original \"%s\" - \"%s\": %s",
                tmpfile___0, state->filename, tmp___21);
    }
  }
#line 386
  free((void *)tmpfile___0);
#line 387
  thread_rwlock_unlock_c(& state->file_rwlock, 387, (char *)"auth_htpasswd.c");
#line 388
  htpasswd_recheckfile(state);
#line 390
  return (6);
}
}
#line 394 "auth_htpasswd.c"
static auth_result htpasswd_userlist(auth_t *auth , xmlNodePtr srcnode ) 
{ htpasswd_auth_state *state ;
  xmlNodePtr newnode ;
  avl_node *node ;
  htpasswd_user *user ;

  {
#line 400
  state = (htpasswd_auth_state *)auth->state;
#line 402
  htpasswd_recheckfile(state);
#line 404
  thread_rwlock_rlock_c(& state->file_rwlock, 404, (char *)"auth_htpasswd.c");
#line 405
  node = avl_get_first(state->users);
#line 406
  while (node) {
#line 408
    user = (htpasswd_user *)node->key;
#line 409
    newnode = xmlNewChild(srcnode, (xmlNs *)((void *)0), (xmlChar const   *)"User",
                          (xmlChar const   *)((void *)0));
#line 410
    xmlNewChild(newnode, (xmlNs *)((void *)0), (xmlChar const   *)"username", (xmlChar const   *)user->name);
#line 411
    xmlNewChild(newnode, (xmlNs *)((void *)0), (xmlChar const   *)"password", (xmlChar const   *)user->pass);
#line 412
    node = avl_get_next(node);
  }
#line 414
  thread_rwlock_unlock_c(& state->file_rwlock, 414, (char *)"auth_htpasswd.c");
#line 416
  return (1);
}
}
#line 1 "cil-5FZpOTGo.o"
#pragma merger(0,"/tmp/cil-4xml6TBr.i","")
#line 1 "./src/format_vorbis.o_saved.c"
#pragma merger(0,"./format_vorbis.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 496 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 150 "/usr/include/ogg/ogg.h"
extern int ogg_stream_packetin(ogg_stream_state *os , ogg_packet *op ) ;
#line 151
extern int ogg_stream_pageout(ogg_stream_state *os , ogg_page *og ) ;
#line 152
extern int ogg_stream_flush(ogg_stream_state *os , ogg_page *og ) ;
#line 184
extern ogg_int64_t ogg_page_granulepos(ogg_page *og ) ;
#line 189
extern void ogg_packet_clear(ogg_packet *op ) ;
#line 165 "/usr/include/vorbis/codec.h"
extern void vorbis_info_init(vorbis_info *vi ) ;
#line 166
extern void vorbis_info_clear(vorbis_info *vi ) ;
#line 168
extern void vorbis_comment_init(vorbis_comment *vc ) ;
#line 169
extern void vorbis_comment_add(vorbis_comment *vc , char *comment ) ;
#line 170
extern void vorbis_comment_add_tag(vorbis_comment *vc , char *tag , char *contents ) ;
#line 172
extern char *vorbis_comment_query(vorbis_comment *vc , char *tag , int count ) ;
#line 174
extern void vorbis_comment_clear(vorbis_comment *vc ) ;
#line 185
extern int vorbis_commentheader_out(vorbis_comment *vc , ogg_packet *op ) ;
#line 201
extern int vorbis_synthesis_headerin(vorbis_info *vi , vorbis_comment *vc , ogg_packet *op ) ;
#line 212
extern long vorbis_packet_blocksize(vorbis_info *vi , ogg_packet *op ) ;
#line 66 "format_vorbis.c"
static int process_vorbis_headers(ogg_state_t *ogg_info , ogg_codec_t *codec ) ;
#line 67
static refbuf_t *process_vorbis_page(ogg_state_t *ogg_info , ogg_codec_t *codec ,
                                     ogg_page *page ) ;
#line 69
static refbuf_t *process_vorbis(ogg_state_t *ogg_info , ogg_codec_t *codec ) ;
#line 70
static void vorbis_set_tag(format_plugin_t *plugin , char *tag , char *value ) ;
#line 73 "format_vorbis.c"
static void free_ogg_packet(ogg_packet *packet ) 
{ 

  {
#line 75
  if (packet) {
#line 77
    free((void *)packet->packet);
#line 78
    free((void *)packet);
  }
#line 80
  return;
}
}
#line 83 "format_vorbis.c"
static void vorbis_codec_free(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ vorbis_codec_t *vorbis ;

  {
#line 85
  vorbis = (vorbis_codec_t *)codec->specific;
#line 87
  log_write(errorlog, 4U, "format-vorbis/", "vorbis_codec_free", "freeing vorbis codec");
#line 88
  stats_event((char const   *)ogg_info->mount, "audio_bitrate", (char const   *)((void *)0));
#line 89
  stats_event((char const   *)ogg_info->mount, "audio_channels", (char const   *)((void *)0));
#line 90
  stats_event((char const   *)ogg_info->mount, "audio_samplerate", (char const   *)((void *)0));
#line 91
  vorbis_info_clear(& vorbis->vi);
#line 92
  vorbis_comment_clear(& vorbis->vc);
#line 93
  ogg_stream_clear(& codec->os);
#line 94
  ogg_stream_clear(& vorbis->new_os);
#line 95
  free_ogg_packet(vorbis->header[0]);
#line 96
  free_ogg_packet(vorbis->header[1]);
#line 97
  free_ogg_packet(vorbis->header[2]);
#line 98
  free_ogg_packet(vorbis->prev_packet);
#line 99
  free((void *)vorbis->bos_page.header);
#line 100
  free((void *)vorbis);
#line 101
  free((void *)codec);
#line 102
  return;
}
}
#line 105 "format_vorbis.c"
static ogg_packet *copy_ogg_packet(ogg_packet *packet ) 
{ ogg_packet *next ;

  {
#line 108
  while (1) {
#line 110
    next = (ogg_packet *)malloc(sizeof(ogg_packet ));
#line 111
    if ((unsigned int )next == (unsigned int )((void *)0)) {
#line 112
      break;
    }
#line 113
    memcpy((void * __restrict  )next, (void const   * __restrict  )packet, sizeof(ogg_packet ));
#line 114
    next->packet = (unsigned char *)malloc((unsigned int )next->bytes);
#line 115
    if ((unsigned int )next->packet == (unsigned int )((void *)0)) {
#line 116
      break;
    }
#line 117
    memcpy((void * __restrict  )next->packet, (void const   * __restrict  )packet->packet,
           (unsigned int )next->bytes);
#line 118
    return (next);
#line 108
    break;
  }
#line 121
  if (next) {
#line 122
    free((void *)next);
  }
#line 123
  return ((ogg_packet *)((void *)0));
}
}
#line 127 "format_vorbis.c"
static void add_audio_packet(vorbis_codec_t *source_vorbis , ogg_packet *packet ) 
{ 

  {
#line 129
  if (source_vorbis->initial_audio_packet) {
#line 131
    packet->granulepos = 0LL;
#line 132
    source_vorbis->initial_audio_packet = 0;
  } else {
#line 136
    source_vorbis->samples_in_page += packet->granulepos - source_vorbis->prev_granulepos;
#line 138
    source_vorbis->prev_granulepos = packet->granulepos;
#line 139
    source_vorbis->granulepos += (ogg_int64_t )source_vorbis->prev_window;
  }
#line 141
  ogg_stream_packetin(& source_vorbis->new_os, packet);
#line 142
  return;
}
}
#line 145 "format_vorbis.c"
static refbuf_t *get_buffer_audio(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ refbuf_t *refbuf ;
  ogg_page page ;
  vorbis_codec_t *source_vorbis ;
  int (*get_ogg_page)(ogg_stream_state * , ogg_page * ) ;
  ogg_int64_t tmp ;
  int tmp___0 ;

  {
#line 147
  refbuf = (refbuf_t *)((void *)0);
#line 149
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 150
  get_ogg_page = & ogg_stream_pageout;
#line 152
  if (source_vorbis->samples_in_page > (ogg_int64_t )source_vorbis->page_samples_trigger) {
#line 153
    get_ogg_page = & ogg_stream_flush;
  }
#line 155
  tmp___0 = ((*get_ogg_page))(& source_vorbis->new_os, & page);
#line 155
  if (tmp___0 > 0) {
#line 158
    tmp = ogg_page_granulepos(& page);
#line 158
    source_vorbis->samples_in_page -= tmp - source_vorbis->prev_page_samples;
#line 159
    source_vorbis->prev_page_samples = ogg_page_granulepos(& page);
#line 161
    refbuf = make_refbuf_with_page(& page);
  }
#line 163
  return (refbuf);
}
}
#line 167 "format_vorbis.c"
static refbuf_t *get_buffer_header(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ int headers_flushed ;
  ogg_page page ;
  vorbis_codec_t *source_vorbis ;
  int tmp ;

  {
#line 169
  headers_flushed = 0;
#line 171
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 173
  while (1) {
#line 173
    tmp = ogg_stream_flush(& source_vorbis->new_os, & page);
#line 173
    if (! (tmp > 0)) {
#line 173
      break;
    }
#line 175
    format_ogg_attach_header(ogg_info, & page);
#line 176
    headers_flushed = 1;
  }
#line 178
  if (headers_flushed) {
#line 180
    source_vorbis->get_buffer_page = & get_buffer_audio;
  }
#line 182
  return ((refbuf_t *)((void *)0));
}
}
#line 186 "format_vorbis.c"
static refbuf_t *get_buffer_finished(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ vorbis_codec_t *source_vorbis ;
  ogg_page page ;
  refbuf_t *refbuf ;
  ogg_int64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 188
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 192
  tmp___0 = ogg_stream_flush(& source_vorbis->new_os, & page);
#line 192
  if (tmp___0 > 0) {
#line 194
    tmp = ogg_page_granulepos(& page);
#line 194
    source_vorbis->samples_in_page -= tmp - source_vorbis->prev_page_samples;
#line 195
    source_vorbis->prev_page_samples = ogg_page_granulepos(& page);
#line 197
    refbuf = make_refbuf_with_page(& page);
#line 198
    log_write(errorlog, 4U, "format-vorbis/", "get_buffer_finished", "flushing page");
#line 199
    return (refbuf);
  }
#line 201
  ogg_stream_clear(& source_vorbis->new_os);
#line 202
  tmp___1 = rand();
#line 202
  ogg_stream_init(& source_vorbis->new_os, tmp___1);
#line 204
  format_ogg_free_headers(ogg_info);
#line 205
  source_vorbis->get_buffer_page = (refbuf_t *(*)(ogg_state_t *ogg_info , ogg_codec_t *codec ))((void *)0);
#line 206
  if (source_vorbis->prev_packet) {
#line 207
    source_vorbis->process_packet = & process_vorbis_headers;
  } else {
#line 209
    source_vorbis->process_packet = (int (*)(ogg_state_t *ogg_info , ogg_codec_t *codec ))((void *)0);
  }
#line 211
  if (source_vorbis->initial_audio_packet == 0) {
#line 212
    source_vorbis->prev_window = 0;
  }
#line 214
  return ((refbuf_t *)((void *)0));
}
}
#line 219 "format_vorbis.c"
static void initiate_flush(vorbis_codec_t *source_vorbis ) 
{ 

  {
#line 221
  if (source_vorbis->prev_packet) {
#line 224
    log_write(errorlog, 4U, "format-vorbis/", "initiate_flush", "adding EOS packet");
#line 225
    (source_vorbis->prev_packet)->e_o_s = 1L;
#line 226
    add_audio_packet(source_vorbis, source_vorbis->prev_packet);
#line 227
    (source_vorbis->prev_packet)->e_o_s = 0L;
  }
#line 229
  source_vorbis->get_buffer_page = & get_buffer_finished;
#line 230
  source_vorbis->initial_audio_packet = 1;
#line 231
  return;
}
}
#line 238 "format_vorbis.c"
static int process_vorbis_audio(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ vorbis_codec_t *source_vorbis ;
  int window ;
  ogg_packet packet ;
  int tmp ;
  long tmp___0 ;
  ogg_packet *prev_packet ;

  {
#line 240
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 242
  while (1) {
#line 248
    tmp = ogg_stream_packetout(& codec->os, & packet);
#line 248
    if (tmp <= 0) {
#line 249
      break;
    }
#line 252
    tmp___0 = vorbis_packet_blocksize(& source_vorbis->vi, & packet);
#line 252
    window = (int )(tmp___0 / 4L);
#line 254
    source_vorbis->granulepos += (ogg_int64_t )window;
#line 255
    if (source_vorbis->prev_packet) {
#line 257
      prev_packet = source_vorbis->prev_packet;
#line 259
      add_audio_packet(source_vorbis, prev_packet);
#line 260
      free_ogg_packet(prev_packet);
#line 263
      if (packet.packetno == 4LL) {
#line 265
        if (source_vorbis->initial_page_granulepos < source_vorbis->granulepos) {
#line 267
          source_vorbis->granulepos -= source_vorbis->initial_page_granulepos;
#line 268
          source_vorbis->samples_in_page = (long long )source_vorbis->page_samples_trigger;
        }
      }
#line 272
      if (packet.granulepos == source_vorbis->initial_page_granulepos) {
#line 274
        if (source_vorbis->initial_page_granulepos > source_vorbis->granulepos) {
#line 275
          source_vorbis->granulepos = source_vorbis->initial_page_granulepos;
        }
      }
#line 278
      if (packet.e_o_s == 0L) {
#line 279
        packet.granulepos = source_vorbis->granulepos;
      }
    } else {
#line 283
      packet.granulepos = 0LL;
    }
#line 287
    source_vorbis->prev_window = window;
#line 288
    source_vorbis->prev_packet = copy_ogg_packet(& packet);
#line 289
    if (packet.e_o_s) {
#line 291
      initiate_flush(source_vorbis);
#line 292
      free_ogg_packet(source_vorbis->prev_packet);
#line 293
      source_vorbis->prev_packet = (ogg_packet *)((void *)0);
#line 294
      return (1);
    }
#line 298
    if (source_vorbis->samples_in_page > (ogg_int64_t )source_vorbis->page_samples_trigger) {
#line 299
      return (1);
    }
  }
#line 301
  if (source_vorbis->stream_notify) {
#line 303
    initiate_flush(source_vorbis);
#line 304
    source_vorbis->stream_notify = 0;
#line 305
    return (1);
  }
#line 307
  return (-1);
}
}
#line 314 "format_vorbis.c"
static int process_vorbis_headers(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ vorbis_codec_t *source_vorbis ;
  vorbis_comment vc ;
  ogg_packet header ;

  {
#line 316
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 318
  if ((unsigned int )source_vorbis->header[0] == (unsigned int )((void *)0)) {
#line 319
    return (0);
  }
#line 321
  log_write(errorlog, 4U, "format-vorbis/", "process_vorbis_headers", "Adding the 3 header packets");
#line 322
  ogg_stream_packetin(& source_vorbis->new_os, source_vorbis->header[0]);
#line 324
  if (source_vorbis->rebuild_comment) {
#line 329
    vorbis_comment_init(& vc);
#line 330
    if (ogg_info->artist) {
#line 331
      vorbis_comment_add_tag(& vc, (char *)"artist", ogg_info->artist);
    }
#line 332
    if (ogg_info->title) {
#line 333
      vorbis_comment_add_tag(& vc, (char *)"title", ogg_info->title);
    }
#line 334
    vorbis_comment_add(& vc, (char *)"server=Icecast 2.3.1");
#line 335
    vorbis_commentheader_out(& vc, & header);
#line 337
    ogg_stream_packetin(& source_vorbis->new_os, & header);
#line 338
    vorbis_comment_clear(& vc);
#line 339
    ogg_packet_clear(& header);
  } else {
#line 342
    ogg_stream_packetin(& source_vorbis->new_os, source_vorbis->header[1]);
  }
#line 343
  ogg_stream_packetin(& source_vorbis->new_os, source_vorbis->header[2]);
#line 344
  source_vorbis->rebuild_comment = 0;
#line 346
  ogg_info->log_metadata = 1;
#line 347
  source_vorbis->get_buffer_page = & get_buffer_header;
#line 348
  source_vorbis->process_packet = & process_vorbis_audio;
#line 349
  source_vorbis->granulepos = (long long )source_vorbis->prev_window;
#line 350
  source_vorbis->initial_audio_packet = 1;
#line 351
  return (1);
}
}
#line 358 "format_vorbis.c"
ogg_codec_t *initial_vorbis_page(format_plugin_t *plugin , ogg_page *page ) 
{ ogg_codec_t *codec ;
  ogg_codec_t *tmp ;
  ogg_packet packet ;
  vorbis_codec_t *vorbis ;
  vorbis_codec_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 360
  tmp = (ogg_codec_t *)calloc(1U, sizeof(ogg_codec_t ));
#line 360
  codec = tmp;
#line 363
  tmp___0 = (vorbis_codec_t *)calloc(1U, sizeof(vorbis_codec_t ));
#line 363
  vorbis = tmp___0;
#line 365
  tmp___1 = ogg_page_serialno(page);
#line 365
  ogg_stream_init(& codec->os, tmp___1);
#line 366
  ogg_stream_pagein(& codec->os, page);
#line 368
  vorbis_info_init(& vorbis->vi);
#line 369
  vorbis_comment_init(& vorbis->vc);
#line 371
  ogg_stream_packetout(& codec->os, & packet);
#line 373
  log_write(errorlog, 4U, "format-vorbis/", "initial_vorbis_page", "checking for vorbis codec");
#line 374
  tmp___2 = vorbis_synthesis_headerin(& vorbis->vi, & vorbis->vc, & packet);
#line 374
  if (tmp___2 < 0) {
#line 376
    ogg_stream_clear(& codec->os);
#line 377
    vorbis_info_clear(& vorbis->vi);
#line 378
    vorbis_comment_clear(& vorbis->vc);
#line 379
    free((void *)vorbis);
#line 380
    free((void *)codec);
#line 381
    return ((ogg_codec_t *)((void *)0));
  }
#line 383
  log_write(errorlog, 3U, "format-vorbis/", "initial_vorbis_page", "seen initial vorbis header");
#line 384
  codec->specific = (void *)vorbis;
#line 385
  codec->codec_free = & vorbis_codec_free;
#line 386
  codec->headers = 1U;
#line 387
  codec->name = "Vorbis";
#line 389
  free_ogg_packet(vorbis->header[0]);
#line 390
  free_ogg_packet(vorbis->header[1]);
#line 391
  free_ogg_packet(vorbis->header[2]);
#line 392
  memset((void *)(vorbis->header), 0, sizeof(vorbis->header));
#line 393
  vorbis->header[0] = copy_ogg_packet(& packet);
#line 394
  tmp___3 = rand();
#line 394
  ogg_stream_init(& vorbis->new_os, tmp___3);
#line 396
  codec->process_page = & process_vorbis_page;
#line 397
  codec->process = & process_vorbis;
#line 398
  plugin->set_tag = & vorbis_set_tag;
#line 400
  vorbis->bos_page.header = (unsigned char *)malloc((unsigned int )(page->header_len +
                                                                    page->body_len));
#line 402
  memcpy((void * __restrict  )vorbis->bos_page.header, (void const   * __restrict  )page->header,
         (unsigned int )page->header_len);
#line 403
  vorbis->bos_page.header_len = page->header_len;
#line 405
  vorbis->bos_page.body = vorbis->bos_page.header + page->header_len;
#line 406
  memcpy((void * __restrict  )vorbis->bos_page.body, (void const   * __restrict  )page->body,
         (unsigned int )page->body_len);
#line 407
  vorbis->bos_page.body_len = page->body_len;
#line 409
  return (codec);
}
}
#line 416 "format_vorbis.c"
static void vorbis_set_tag(format_plugin_t *plugin , char *tag , char *value ) 
{ ogg_state_t *ogg_info ;
  ogg_codec_t *codec ;
  vorbis_codec_t *source_vorbis ;
  int change ;
  char *p ;
  char *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  char *p___0 ;
  char *tmp___28 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  char *p___1 ;
  char *tmp___48 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;

  {
#line 418
  ogg_info = (ogg_state_t *)plugin->_state;
#line 419
  codec = ogg_info->codecs;
#line 421
  change = 0;
#line 424
  if (codec) {
#line 424
    if ((unsigned int )codec->next == (unsigned int )((void *)0)) {
#line 425
      source_vorbis = (vorbis_codec_t *)codec->specific;
    } else {
#line 427
      return;
    }
  } else {
#line 427
    return;
  }
#line 429
  if (0) {
#line 429
    __s1_len = strlen((char const   *)tag);
#line 429
    __s2_len = strlen("artist");
#line 429
    if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
           1U)) {
      goto _L___0;
    } else {
#line 429
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 429
        if (! ((unsigned int )((void const   *)("artist" + 1)) - (unsigned int )((void const   *)"artist") ==
               1U)) {
#line 429
          tmp___18 = 1;
        } else {
#line 429
          if (__s2_len >= 4U) {
#line 429
            tmp___18 = 1;
          } else {
#line 429
            tmp___18 = 0;
          }
        }
      } else {
#line 429
        tmp___18 = 0;
      }
    }
#line 429
    if (tmp___18) {
#line 429
      tmp___14 = __builtin_strcmp((char const   *)tag, "artist");
    } else {
#line 429
      tmp___17 = __builtin_strcmp((char const   *)tag, "artist");
#line 429
      tmp___14 = tmp___17;
    }
  } else {
#line 429
    tmp___17 = __builtin_strcmp((char const   *)tag, "artist");
#line 429
    tmp___14 = tmp___17;
  }
#line 429
  if (tmp___14 == 0) {
#line 431
    tmp___8 = __strdup((char const   *)value);
#line 431
    p = tmp___8;
#line 432
    if (p) {
#line 434
      free((void *)ogg_info->artist);
#line 435
      ogg_info->artist = p;
#line 436
      change = 1;
    }
  }
#line 439
  if (0) {
#line 439
    __s1_len___0 = strlen((char const   *)tag);
#line 439
    __s2_len___0 = strlen("title");
#line 439
    if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
           1U)) {
      goto _L___2;
    } else {
#line 439
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 439
        if (! ((unsigned int )((void const   *)("title" + 1)) - (unsigned int )((void const   *)"title") ==
               1U)) {
#line 439
          tmp___38 = 1;
        } else {
#line 439
          if (__s2_len___0 >= 4U) {
#line 439
            tmp___38 = 1;
          } else {
#line 439
            tmp___38 = 0;
          }
        }
      } else {
#line 439
        tmp___38 = 0;
      }
    }
#line 439
    if (tmp___38) {
#line 439
      tmp___34 = __builtin_strcmp((char const   *)tag, "title");
    } else {
#line 439
      tmp___37 = __builtin_strcmp((char const   *)tag, "title");
#line 439
      tmp___34 = tmp___37;
    }
  } else {
#line 439
    tmp___37 = __builtin_strcmp((char const   *)tag, "title");
#line 439
    tmp___34 = tmp___37;
  }
#line 439
  if (tmp___34 == 0) {
#line 441
    tmp___28 = __strdup((char const   *)value);
#line 441
    p___0 = tmp___28;
#line 442
    if (p___0) {
#line 444
      free((void *)ogg_info->title);
#line 445
      ogg_info->title = p___0;
#line 446
      change = 1;
    }
  }
#line 449
  if (0) {
#line 449
    __s1_len___1 = strlen((char const   *)tag);
#line 449
    __s2_len___1 = strlen("song");
#line 449
    if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
           1U)) {
      goto _L___4;
    } else {
#line 449
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 449
        if (! ((unsigned int )((void const   *)("song" + 1)) - (unsigned int )((void const   *)"song") ==
               1U)) {
#line 449
          tmp___58 = 1;
        } else {
#line 449
          if (__s2_len___1 >= 4U) {
#line 449
            tmp___58 = 1;
          } else {
#line 449
            tmp___58 = 0;
          }
        }
      } else {
#line 449
        tmp___58 = 0;
      }
    }
#line 449
    if (tmp___58) {
#line 449
      tmp___54 = __builtin_strcmp((char const   *)tag, "song");
    } else {
#line 449
      tmp___57 = __builtin_strcmp((char const   *)tag, "song");
#line 449
      tmp___54 = tmp___57;
    }
  } else {
#line 449
    tmp___57 = __builtin_strcmp((char const   *)tag, "song");
#line 449
    tmp___54 = tmp___57;
  }
#line 449
  if (tmp___54 == 0) {
#line 451
    tmp___48 = __strdup((char const   *)value);
#line 451
    p___1 = tmp___48;
#line 452
    if (p___1) {
#line 454
      free((void *)ogg_info->artist);
#line 455
      free((void *)ogg_info->title);
#line 456
      ogg_info->artist = (char *)((void *)0);
#line 457
      ogg_info->title = p___1;
#line 458
      change = 1;
    }
  }
#line 461
  if (change) {
#line 463
    source_vorbis->stream_notify = 1;
#line 464
    source_vorbis->rebuild_comment = 1;
  }
#line 466
  return;
}
}
#line 472 "format_vorbis.c"
static refbuf_t *process_vorbis(ogg_state_t *ogg_info , ogg_codec_t *codec ) 
{ vorbis_codec_t *source_vorbis ;
  refbuf_t *refbuf ;
  int tmp ;

  {
#line 474
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 477
  while (1) {
#line 479
    if (source_vorbis->get_buffer_page) {
#line 481
      refbuf = ((*(source_vorbis->get_buffer_page)))(ogg_info, codec);
#line 482
      if (refbuf) {
#line 483
        return (refbuf);
      }
    }
#line 486
    if (source_vorbis->process_packet) {
#line 486
      tmp = ((*(source_vorbis->process_packet)))(ogg_info, codec);
#line 486
      if (tmp > 0) {
#line 488
        continue;
      }
    }
#line 489
    return ((refbuf_t *)((void *)0));
  }
}
}
#line 497 "format_vorbis.c"
static refbuf_t *process_vorbis_passthru_page(ogg_state_t *ogg_info , ogg_codec_t *codec ,
                                              ogg_page *page ) 
{ refbuf_t *tmp ;

  {
#line 500
  tmp = make_refbuf_with_page(page);
#line 500
  return (tmp);
}
}
#line 507 "format_vorbis.c"
static refbuf_t *process_vorbis_page(ogg_state_t *ogg_info , ogg_codec_t *codec ,
                                     ogg_page *page ) 
{ ogg_packet header ;
  vorbis_codec_t *source_vorbis ;
  char *comment___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___11 ;
  char *tmp___21 ;

  {
#line 511
  source_vorbis = (vorbis_codec_t *)codec->specific;
#line 514
  tmp = ogg_stream_pagein(& codec->os, page);
#line 514
  if (tmp < 0) {
#line 516
    ogg_info->error = 1;
#line 517
    return ((refbuf_t *)((void *)0));
  }
#line 519
  if (codec->headers == 3U) {
#line 521
    if (source_vorbis->initial_audio_page) {
#line 523
      source_vorbis->initial_page_granulepos = ogg_page_granulepos(page);
#line 524
      source_vorbis->initial_audio_page = 0;
    }
#line 526
    return ((refbuf_t *)((void *)0));
  }
#line 529
  while (codec->headers < 3U) {
#line 532
    log_write(errorlog, 4U, "format-vorbis/", "process_vorbis_page", "processing incoming header packet (%d)",
              codec->headers);
#line 534
    tmp___0 = ogg_stream_packetout(& codec->os, & header);
#line 534
    if (tmp___0 <= 0) {
#line 536
      if ((ogg_info->codecs)->next) {
#line 537
        format_ogg_attach_header(ogg_info, page);
      }
#line 538
      return ((refbuf_t *)((void *)0));
    }
#line 542
    tmp___1 = vorbis_synthesis_headerin(& source_vorbis->vi, & source_vorbis->vc,
                                        & header);
#line 542
    if (tmp___1 < 0) {
#line 544
      ogg_info->error = 1;
#line 545
      log_write(errorlog, 2U, "format-vorbis/", "process_vorbis_page", "Problem parsing ogg vorbis header");
#line 546
      return ((refbuf_t *)((void *)0));
    }
#line 548
    header.granulepos = 0LL;
#line 549
    source_vorbis->header[codec->headers] = copy_ogg_packet(& header);
#line 550
    codec->headers = codec->headers + 1U;
  }
#line 552
  log_write(errorlog, 4U, "format-vorbis/", "process_vorbis_page", "we have the header packets now");
#line 555
  if ((unsigned int )(ogg_info->codecs)->next == (unsigned int )((void *)0)) {
#line 558
    source_vorbis->page_samples_trigger = (int )(source_vorbis->vi.rate / 2L);
#line 559
    source_vorbis->process_packet = & process_vorbis_headers;
#line 560
    source_vorbis->initial_audio_page = 1;
  } else {
#line 564
    format_ogg_attach_header(ogg_info, & source_vorbis->bos_page);
#line 565
    format_ogg_attach_header(ogg_info, page);
#line 566
    codec->process_page = & process_vorbis_passthru_page;
  }
#line 569
  free((void *)ogg_info->title);
#line 570
  comment___0 = vorbis_comment_query(& source_vorbis->vc, (char *)"TITLE", 0);
#line 571
  if (comment___0) {
#line 572
    tmp___11 = __strdup((char const   *)comment___0);
#line 572
    ogg_info->title = tmp___11;
  } else {
#line 574
    ogg_info->title = (char *)((void *)0);
  }
#line 576
  free((void *)ogg_info->artist);
#line 577
  comment___0 = vorbis_comment_query(& source_vorbis->vc, (char *)"ARTIST", 0);
#line 578
  if (comment___0) {
#line 579
    tmp___21 = __strdup((char const   *)comment___0);
#line 579
    ogg_info->artist = tmp___21;
  } else {
#line 581
    ogg_info->artist = (char *)((void *)0);
  }
#line 582
  ogg_info->log_metadata = 1;
#line 584
  stats_event_args((char const   *)ogg_info->mount, (char *)"audio_samplerate", (char *)"%ld",
                   source_vorbis->vi.rate);
#line 585
  stats_event_args((char const   *)ogg_info->mount, (char *)"audio_channels", (char *)"%ld",
                   (long )source_vorbis->vi.channels);
#line 586
  stats_event_args((char const   *)ogg_info->mount, (char *)"audio_bitrate", (char *)"%ld",
                   source_vorbis->vi.bitrate_nominal);
#line 587
  stats_event_args((char const   *)ogg_info->mount, (char *)"ice-bitrate", (char *)"%ld",
                   source_vorbis->vi.bitrate_nominal / 1000L);
#line 589
  return ((refbuf_t *)((void *)0));
}
}
#line 1 "cil-JISsdt4f.o"
#pragma merger(0,"/tmp/cil-7VKFClgV.i","")
#line 1 "./src/auth_url.o_saved.c"
#pragma merger(0,"./auth_url.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 29 "/usr/include/curl/easy.h"
extern CURL *curl_easy_init(void) ;
#line 30
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
#line 31
extern CURLcode curl_easy_perform(CURL *curl ) ;
#line 32
extern void curl_easy_cleanup(CURL *curl ) ;
#line 95 "auth_url.c"
static void auth_url_clear(auth_t *self ) 
{ auth_url *url ;

  {
#line 99
  log_write(errorlog, 3U, "auth_url/", "auth_url_clear", "Doing auth URL cleanup");
#line 100
  url = (auth_url *)self->state;
#line 101
  curl_easy_cleanup(url->handle);
#line 102
  free((void *)url->username);
#line 103
  free((void *)url->password);
#line 104
  free((void *)url->removeurl);
#line 105
  free((void *)url->addurl);
#line 106
  free((void *)url->stream_start);
#line 107
  free((void *)url->stream_end);
#line 108
  free((void *)url->auth_header);
#line 109
  free((void *)url->timelimit_header);
#line 110
  free((void *)url->userpwd);
#line 111
  free((void *)url);
#line 112
  return;
}
}
#line 116 "auth_url.c"
static int my_getpass(void *client , char *prompt , char *buffer , int buflen ) 
{ 

  {
#line 118
  (*(buffer + 0)) = (char )'\000';
#line 119
  return (0);
}
}
#line 123 "auth_url.c"
static int handle_returned_header(void *ptr , size_t size , size_t nmemb , void *stream ) 
{ auth_client *auth_user ;
  unsigned int bytes ;
  client_t *client ;
  auth_t *auth ;
  auth_url *url ;
  int tmp ;
  unsigned int limit ;
  time_t tmp___0 ;
  int tmp___1 ;
  char *eol ;
  char *tmp___3 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 125
  auth_user = (auth_client *)stream;
#line 126
  bytes = size * nmemb;
#line 127
  client = auth_user->client;
#line 129
  if (client) {
#line 131
    auth = client->auth;
#line 132
    url = (auth_url *)auth->state;
#line 133
    tmp = strncasecmp((char const   *)ptr, (char const   *)url->auth_header, (unsigned int )url->auth_header_len);
#line 133
    if (tmp == 0) {
#line 134
      client->authenticated = 1;
    }
#line 135
    tmp___1 = strncasecmp((char const   *)ptr, (char const   *)url->timelimit_header,
                          (unsigned int )url->timelimit_header_len);
#line 135
    if (tmp___1 == 0) {
#line 137
      limit = 0U;
#line 138
      sscanf((char const   * __restrict  )((char *)ptr + url->timelimit_header_len),
             (char const   * __restrict  )"%u\r\n", & limit);
#line 139
      tmp___0 = time((time_t *)((void *)0));
#line 139
      (client->con)->discon_time = (long )((unsigned long )tmp___0 + (unsigned long )limit);
    }
#line 141
    tmp___6 = strncasecmp((char const   *)ptr, "icecast-auth-message: ", 22U);
#line 141
    if (tmp___6 == 0) {
#line 144
      snprintf((char * __restrict  )(url->errormsg), sizeof(url->errormsg), (char const   * __restrict  )"%s",
               (char *)ptr + 22);
#line 145
      tmp___3 = __builtin_strchr(url->errormsg, (char )'\r');
#line 145
      eol = tmp___3;
#line 146
      if ((unsigned int )eol == (unsigned int )((void *)0)) {
#line 147
        tmp___5 = __builtin_strchr(url->errormsg, (char )'\n');
#line 147
        eol = tmp___5;
      }
#line 148
      if (eol) {
#line 149
        (*eol) = (char )'\000';
      }
    }
  }
#line 153
  return ((int )bytes);
}
}
#line 157 "auth_url.c"
static int handle_returned_data(void *ptr , size_t size , size_t nmemb , void *stream ) 
{ 

  {
#line 159
  return ((int )(size * nmemb));
}
}
#line 163 "auth_url.c"
static auth_result url_remove_client(auth_client *auth_user ) 
{ client_t *client ;
  auth_t *auth ;
  auth_url *url ;
  time_t duration ;
  time_t tmp ;
  char *username ;
  char *password ;
  char *mount ;
  char *server ;
  ice_config_t *config ;
  int port ;
  char *userpwd ;
  char post[4096] ;
  char *tmp___9 ;
  char *tmp___19 ;
  int len ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  char *tmp___23 ;
  CURLcode tmp___24 ;

  {
#line 165
  client = auth_user->client;
#line 166
  auth = client->auth;
#line 167
  url = (auth_url *)auth->state;
#line 168
  tmp = time((time_t *)((void *)0));
#line 168
  duration = tmp - (client->con)->con_time;
#line 172
  userpwd = (char *)((void *)0);
#line 174
  if ((unsigned int )url->removeurl == (unsigned int )((void *)0)) {
#line 175
    return (1);
  }
#line 176
  config = config_get_config();
#line 177
  server = util_url_escape(config->hostname);
#line 178
  port = config->port;
#line 179
  config_release_config();
#line 181
  if (client->username) {
#line 182
    username = util_url_escape(client->username);
  } else {
#line 184
    tmp___9 = __strdup("");
#line 184
    username = tmp___9;
  }
#line 186
  if (client->password) {
#line 187
    password = util_url_escape(client->password);
  } else {
#line 189
    tmp___19 = __strdup("");
#line 189
    password = tmp___19;
  }
#line 192
  mount = httpp_getvar(client->parser, "__rawuri");
#line 193
  if ((unsigned int )mount == (unsigned int )((void *)0)) {
#line 194
    mount = httpp_getvar(client->parser, "__uri");
  }
#line 195
  mount = util_url_escape(mount);
#line 197
  snprintf((char * __restrict  )(post), sizeof(post), (char const   * __restrict  )"action=listener_remove&server=%s&port=%d&client=%lu&mount=%s&user=%s&pass=%s&duration=%lu",
           server, port, (client->con)->id, mount, username, password, (unsigned long )duration);
#line 202
  free((void *)server);
#line 203
  free((void *)mount);
#line 204
  free((void *)username);
#line 205
  free((void *)password);
#line 207
  tmp___23 = __builtin_strchr(url->removeurl, (char )'@');
#line 207
  if ((unsigned int )tmp___23 == (unsigned int )((void *)0)) {
#line 209
    if (url->userpwd) {
#line 210
      curl_easy_setopt(url->handle, 10005, url->userpwd);
    } else {
#line 214
      if (client->username) {
#line 214
        if (client->password) {
#line 216
          tmp___20 = strlen((char const   *)client->username);
#line 216
          tmp___21 = strlen((char const   *)client->password);
#line 216
          len = (int )((tmp___20 + tmp___21) + 2U);
#line 217
          userpwd = (char *)malloc((unsigned int )len);
#line 218
          snprintf((char * __restrict  )userpwd, (unsigned int )len, (char const   * __restrict  )"%s:%s",
                   client->username, client->password);
#line 219
          curl_easy_setopt(url->handle, 10005, userpwd);
        } else {
#line 222
          curl_easy_setopt(url->handle, 10005, "");
        }
      } else {
#line 222
        curl_easy_setopt(url->handle, 10005, "");
      }
    }
  } else {
#line 228
    curl_easy_setopt(url->handle, 10005, "");
  }
#line 230
  curl_easy_setopt(url->handle, 10002, url->removeurl);
#line 231
  curl_easy_setopt(url->handle, 10015, post);
#line 232
  curl_easy_setopt(url->handle, 10029, auth_user);
#line 234
  tmp___24 = curl_easy_perform(url->handle);
#line 234
  if (tmp___24) {
#line 235
    log_write(errorlog, 2U, "auth_url/", "url_remove_client", "auth to server %s failed with %s",
              url->removeurl, url->errormsg);
  }
#line 237
  free((void *)userpwd);
#line 239
  return (1);
}
}
#line 243 "auth_url.c"
static auth_result url_add_client(auth_client *auth_user ) 
{ client_t *client ;
  auth_t *auth ;
  auth_url *url ;
  int res ;
  int port ;
  char *agent ;
  char *user_agent ;
  char *username ;
  char *password ;
  char *mount ;
  char *ipaddr ;
  char *server ;
  ice_config_t *config ;
  char *userpwd ;
  char post[4096] ;
  char *tmp___8 ;
  char *tmp___18 ;
  int len ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___22 ;

  {
#line 245
  client = auth_user->client;
#line 246
  auth = client->auth;
#line 247
  url = (auth_url *)auth->state;
#line 248
  res = 0;
#line 252
  userpwd = (char *)((void *)0);
#line 254
  if ((unsigned int )url->addurl == (unsigned int )((void *)0)) {
#line 255
    return (1);
  }
#line 257
  config = config_get_config();
#line 258
  server = util_url_escape(config->hostname);
#line 259
  port = config->port;
#line 260
  config_release_config();
#line 261
  agent = httpp_getvar(client->parser, "user-agent");
#line 262
  if ((unsigned int )agent == (unsigned int )((void *)0)) {
#line 263
    agent = (char *)"-";
  }
#line 264
  user_agent = util_url_escape(agent);
#line 265
  if (client->username) {
#line 266
    username = util_url_escape(client->username);
  } else {
#line 268
    tmp___8 = __strdup("");
#line 268
    username = tmp___8;
  }
#line 269
  if (client->password) {
#line 270
    password = util_url_escape(client->password);
  } else {
#line 272
    tmp___18 = __strdup("");
#line 272
    password = tmp___18;
  }
#line 275
  mount = httpp_getvar(client->parser, "__rawuri");
#line 276
  if ((unsigned int )mount == (unsigned int )((void *)0)) {
#line 277
    mount = httpp_getvar(client->parser, "__uri");
  }
#line 278
  mount = util_url_escape(mount);
#line 279
  ipaddr = util_url_escape((client->con)->ip);
#line 281
  snprintf((char * __restrict  )(post), sizeof(post), (char const   * __restrict  )"action=listener_add&server=%s&port=%d&client=%lu&mount=%s&user=%s&pass=%s&ip=%s&agent=%s",
           server, port, (client->con)->id, mount, username, password, ipaddr, user_agent);
#line 286
  free((void *)server);
#line 287
  free((void *)mount);
#line 288
  free((void *)user_agent);
#line 289
  free((void *)username);
#line 290
  free((void *)password);
#line 291
  free((void *)ipaddr);
#line 293
  tmp___22 = __builtin_strchr(url->addurl, (char )'@');
#line 293
  if ((unsigned int )tmp___22 == (unsigned int )((void *)0)) {
#line 295
    if (url->userpwd) {
#line 296
      curl_easy_setopt(url->handle, 10005, url->userpwd);
    } else {
#line 300
      if (client->username) {
#line 300
        if (client->password) {
#line 302
          tmp___19 = strlen((char const   *)client->username);
#line 302
          tmp___20 = strlen((char const   *)client->password);
#line 302
          len = (int )((tmp___19 + tmp___20) + 2U);
#line 303
          userpwd = (char *)malloc((unsigned int )len);
#line 304
          snprintf((char * __restrict  )userpwd, (unsigned int )len, (char const   * __restrict  )"%s:%s",
                   client->username, client->password);
#line 305
          curl_easy_setopt(url->handle, 10005, userpwd);
        } else {
#line 308
          curl_easy_setopt(url->handle, 10005, "");
        }
      } else {
#line 308
        curl_easy_setopt(url->handle, 10005, "");
      }
    }
  } else {
#line 314
    curl_easy_setopt(url->handle, 10005, "");
  }
#line 316
  curl_easy_setopt(url->handle, 10002, url->addurl);
#line 317
  curl_easy_setopt(url->handle, 10015, post);
#line 318
  curl_easy_setopt(url->handle, 10029, auth_user);
#line 319
  url->errormsg[0] = (char )'\000';
#line 321
  res = (int )curl_easy_perform(url->handle);
#line 323
  free((void *)userpwd);
#line 325
  if (res) {
#line 327
    log_write(errorlog, 2U, "auth_url/", "url_add_client", "auth to server %s failed with %s",
              url->addurl, url->errormsg);
#line 328
    return (2);
  }
#line 331
  if (client->authenticated) {
#line 332
    return (1);
  }
#line 333
  log_write(errorlog, 3U, "auth_url/", "url_add_client", "client auth (%s) failed with \"%s\"",
            url->addurl, url->errormsg);
#line 334
  return (2);
}
}
#line 341 "auth_url.c"
static void url_stream_start(auth_client *auth_user ) 
{ char *mount ;
  char *server ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;
  auth_t *auth ;
  auth_url *url ;
  char *stream_start_url ;
  int port ;
  char post[4096] ;
  char *tmp___10 ;
  char *tmp___12 ;
  CURLcode tmp___13 ;

  {
#line 344
  tmp = config_get_config();
#line 344
  config = tmp;
#line 345
  tmp___0 = config_find_mount(config, (char const   *)auth_user->mount);
#line 345
  mountinfo = tmp___0;
#line 346
  auth = mountinfo->auth;
#line 347
  url = (auth_url *)auth->state;
#line 352
  if ((unsigned int )url->stream_start == (unsigned int )((void *)0)) {
#line 354
    config_release_config();
#line 355
    return;
  }
#line 357
  server = util_url_escape(config->hostname);
#line 358
  port = config->port;
#line 359
  tmp___10 = __strdup((char const   *)url->stream_start);
#line 359
  stream_start_url = tmp___10;
#line 362
  (mountinfo->auth)->refcount = (mountinfo->auth)->refcount + 1;
#line 363
  config_release_config();
#line 364
  mount = util_url_escape(auth_user->mount);
#line 366
  snprintf((char * __restrict  )(post), sizeof(post), (char const   * __restrict  )"action=mount_add&mount=%s&server=%s&port=%d",
           mount, server, port);
#line 368
  free((void *)server);
#line 369
  free((void *)mount);
#line 371
  tmp___12 = __builtin_strchr(url->stream_start, (char )'@');
#line 371
  if ((unsigned int )tmp___12 == (unsigned int )((void *)0)) {
#line 373
    if (url->userpwd) {
#line 374
      curl_easy_setopt(url->handle, 10005, url->userpwd);
    } else {
#line 376
      curl_easy_setopt(url->handle, 10005, "");
    }
  } else {
#line 379
    curl_easy_setopt(url->handle, 10005, "");
  }
#line 380
  curl_easy_setopt(url->handle, 10002, stream_start_url);
#line 381
  curl_easy_setopt(url->handle, 10015, post);
#line 382
  curl_easy_setopt(url->handle, 10029, auth_user);
#line 384
  tmp___13 = curl_easy_perform(url->handle);
#line 384
  if (tmp___13) {
#line 385
    log_write(errorlog, 2U, "auth_url/", "url_stream_start", "auth to server %s failed with %s",
              stream_start_url, url->errormsg);
  }
#line 387
  auth_release(auth);
#line 388
  free((void *)stream_start_url);
#line 389
  return;
}
}
#line 393 "auth_url.c"
static void url_stream_end(auth_client *auth_user ) 
{ char *mount ;
  char *server ;
  ice_config_t *config ;
  ice_config_t *tmp ;
  mount_proxy *mountinfo ;
  mount_proxy *tmp___0 ;
  auth_t *auth ;
  auth_url *url ;
  char *stream_end_url ;
  int port ;
  char post[4096] ;
  char *tmp___10 ;
  char *tmp___12 ;
  CURLcode tmp___13 ;

  {
#line 396
  tmp = config_get_config();
#line 396
  config = tmp;
#line 397
  tmp___0 = config_find_mount(config, (char const   *)auth_user->mount);
#line 397
  mountinfo = tmp___0;
#line 398
  auth = mountinfo->auth;
#line 399
  url = (auth_url *)auth->state;
#line 404
  if ((unsigned int )url->stream_end == (unsigned int )((void *)0)) {
#line 406
    config_release_config();
#line 407
    return;
  }
#line 409
  server = util_url_escape(config->hostname);
#line 410
  port = config->port;
#line 411
  tmp___10 = __strdup((char const   *)url->stream_end);
#line 411
  stream_end_url = tmp___10;
#line 414
  (mountinfo->auth)->refcount = (mountinfo->auth)->refcount + 1;
#line 415
  config_release_config();
#line 416
  mount = util_url_escape(auth_user->mount);
#line 418
  snprintf((char * __restrict  )(post), sizeof(post), (char const   * __restrict  )"action=mount_remove&mount=%s&server=%s&port=%d",
           mount, server, port);
#line 420
  free((void *)server);
#line 421
  free((void *)mount);
#line 423
  tmp___12 = __builtin_strchr(url->stream_end, (char )'@');
#line 423
  if ((unsigned int )tmp___12 == (unsigned int )((void *)0)) {
#line 425
    if (url->userpwd) {
#line 426
      curl_easy_setopt(url->handle, 10005, url->userpwd);
    } else {
#line 428
      curl_easy_setopt(url->handle, 10005, "");
    }
  } else {
#line 431
    curl_easy_setopt(url->handle, 10005, "");
  }
#line 432
  curl_easy_setopt(url->handle, 10002, url->stream_end);
#line 433
  curl_easy_setopt(url->handle, 10015, post);
#line 434
  curl_easy_setopt(url->handle, 10029, auth_user);
#line 436
  tmp___13 = curl_easy_perform(url->handle);
#line 436
  if (tmp___13) {
#line 437
    log_write(errorlog, 2U, "auth_url/", "url_stream_end", "auth to server %s failed with %s",
              stream_end_url, url->errormsg);
  }
#line 439
  auth_release(auth);
#line 440
  free((void *)stream_end_url);
#line 441
  return;
}
}
#line 445 "auth_url.c"
static auth_result auth_url_adduser(auth_t *auth , char const   *username , char const   *password ) 
{ 

  {
#line 447
  return (2);
}
}
#line 450 "auth_url.c"
static auth_result auth_url_deleteuser(auth_t *auth , char const   *username ) 
{ 

  {
#line 452
  return (2);
}
}
#line 455 "auth_url.c"
static auth_result auth_url_listuser(auth_t *auth , xmlNodePtr srcnode ) 
{ 

  {
#line 457
  return (2);
}
}
#line 460 "auth_url.c"
int auth_get_url_auth(auth_t *authenticator , config_options_t *options ) 
{ auth_url *url_info ;
  char *tmp___8 ;
  char *tmp___18 ;
  char *tmp___28 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___48 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  char *tmp___68 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  char *tmp___88 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___94 ;
  int tmp___97 ;
  int tmp___98 ;
  char *tmp___108 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___114 ;
  int tmp___117 ;
  int tmp___118 ;
  char *tmp___128 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___134 ;
  int tmp___137 ;
  int tmp___138 ;
  char *tmp___148 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___154 ;
  int tmp___157 ;
  int tmp___158 ;
  char *tmp___168 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___174 ;
  int tmp___177 ;
  int tmp___178 ;
  int len ;
  size_t tmp___179 ;
  size_t tmp___180 ;

  {
#line 464
  authenticator->authenticate = & url_add_client;
#line 465
  authenticator->release_client = & url_remove_client;
#line 467
  authenticator->free = & auth_url_clear;
#line 468
  authenticator->adduser = & auth_url_adduser;
#line 469
  authenticator->deleteuser = & auth_url_deleteuser;
#line 470
  authenticator->listuser = & auth_url_listuser;
#line 472
  authenticator->stream_start = & url_stream_start;
#line 473
  authenticator->stream_end = & url_stream_end;
#line 475
  url_info = (auth_url *)calloc(1U, sizeof(auth_url ));
#line 476
  tmp___8 = __strdup("icecast-auth-user: 1\r\n");
#line 476
  url_info->auth_header = tmp___8;
#line 477
  tmp___18 = __strdup("icecast-auth-timelimit:");
#line 477
  url_info->timelimit_header = tmp___18;
#line 479
  while (options) {
#line 480
    if (0) {
#line 480
      __s1_len = strlen((char const   *)options->name);
#line 480
      __s2_len = strlen("username");
#line 480
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___0;
      } else {
#line 480
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 480
          if (! ((unsigned int )((void const   *)("username" + 1)) - (unsigned int )((void const   *)"username") ==
                 1U)) {
#line 480
            tmp___38 = 1;
          } else {
#line 480
            if (__s2_len >= 4U) {
#line 480
              tmp___38 = 1;
            } else {
#line 480
              tmp___38 = 0;
            }
          }
        } else {
#line 480
          tmp___38 = 0;
        }
      }
#line 480
      if (tmp___38) {
#line 480
        tmp___34 = __builtin_strcmp((char const   *)options->name, "username");
      } else {
#line 480
        tmp___37 = __builtin_strcmp((char const   *)options->name, "username");
#line 480
        tmp___34 = tmp___37;
      }
    } else {
#line 480
      tmp___37 = __builtin_strcmp((char const   *)options->name, "username");
#line 480
      tmp___34 = tmp___37;
    }
#line 480
    if (! tmp___34) {
#line 481
      tmp___28 = __strdup((char const   *)options->value);
#line 481
      url_info->username = tmp___28;
    }
#line 482
    if (0) {
#line 482
      __s1_len___0 = strlen((char const   *)options->name);
#line 482
      __s2_len___0 = strlen("password");
#line 482
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___2;
      } else {
#line 482
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 482
          if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") ==
                 1U)) {
#line 482
            tmp___58 = 1;
          } else {
#line 482
            if (__s2_len___0 >= 4U) {
#line 482
              tmp___58 = 1;
            } else {
#line 482
              tmp___58 = 0;
            }
          }
        } else {
#line 482
          tmp___58 = 0;
        }
      }
#line 482
      if (tmp___58) {
#line 482
        tmp___54 = __builtin_strcmp((char const   *)options->name, "password");
      } else {
#line 482
        tmp___57 = __builtin_strcmp((char const   *)options->name, "password");
#line 482
        tmp___54 = tmp___57;
      }
    } else {
#line 482
      tmp___57 = __builtin_strcmp((char const   *)options->name, "password");
#line 482
      tmp___54 = tmp___57;
    }
#line 482
    if (! tmp___54) {
#line 483
      tmp___48 = __strdup((char const   *)options->value);
#line 483
      url_info->password = tmp___48;
    }
#line 484
    if (0) {
#line 484
      __s1_len___1 = strlen((char const   *)options->name);
#line 484
      __s2_len___1 = strlen("listener_add");
#line 484
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___4;
      } else {
#line 484
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 484
          if (! ((unsigned int )((void const   *)("listener_add" + 1)) - (unsigned int )((void const   *)"listener_add") ==
                 1U)) {
#line 484
            tmp___78 = 1;
          } else {
#line 484
            if (__s2_len___1 >= 4U) {
#line 484
              tmp___78 = 1;
            } else {
#line 484
              tmp___78 = 0;
            }
          }
        } else {
#line 484
          tmp___78 = 0;
        }
      }
#line 484
      if (tmp___78) {
#line 484
        tmp___74 = __builtin_strcmp((char const   *)options->name, "listener_add");
      } else {
#line 484
        tmp___77 = __builtin_strcmp((char const   *)options->name, "listener_add");
#line 484
        tmp___74 = tmp___77;
      }
    } else {
#line 484
      tmp___77 = __builtin_strcmp((char const   *)options->name, "listener_add");
#line 484
      tmp___74 = tmp___77;
    }
#line 484
    if (! tmp___74) {
#line 485
      tmp___68 = __strdup((char const   *)options->value);
#line 485
      url_info->addurl = tmp___68;
    }
#line 486
    if (0) {
#line 486
      __s1_len___2 = strlen((char const   *)options->name);
#line 486
      __s2_len___2 = strlen("listener_remove");
#line 486
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___6;
      } else {
#line 486
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 486
          if (! ((unsigned int )((void const   *)("listener_remove" + 1)) - (unsigned int )((void const   *)"listener_remove") ==
                 1U)) {
#line 486
            tmp___98 = 1;
          } else {
#line 486
            if (__s2_len___2 >= 4U) {
#line 486
              tmp___98 = 1;
            } else {
#line 486
              tmp___98 = 0;
            }
          }
        } else {
#line 486
          tmp___98 = 0;
        }
      }
#line 486
      if (tmp___98) {
#line 486
        tmp___94 = __builtin_strcmp((char const   *)options->name, "listener_remove");
      } else {
#line 486
        tmp___97 = __builtin_strcmp((char const   *)options->name, "listener_remove");
#line 486
        tmp___94 = tmp___97;
      }
    } else {
#line 486
      tmp___97 = __builtin_strcmp((char const   *)options->name, "listener_remove");
#line 486
      tmp___94 = tmp___97;
    }
#line 486
    if (! tmp___94) {
#line 487
      tmp___88 = __strdup((char const   *)options->value);
#line 487
      url_info->removeurl = tmp___88;
    }
#line 488
    if (0) {
#line 488
      __s1_len___3 = strlen((char const   *)options->name);
#line 488
      __s2_len___3 = strlen("mount_add");
#line 488
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___8;
      } else {
#line 488
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 488
          if (! ((unsigned int )((void const   *)("mount_add" + 1)) - (unsigned int )((void const   *)"mount_add") ==
                 1U)) {
#line 488
            tmp___118 = 1;
          } else {
#line 488
            if (__s2_len___3 >= 4U) {
#line 488
              tmp___118 = 1;
            } else {
#line 488
              tmp___118 = 0;
            }
          }
        } else {
#line 488
          tmp___118 = 0;
        }
      }
#line 488
      if (tmp___118) {
#line 488
        tmp___114 = __builtin_strcmp((char const   *)options->name, "mount_add");
      } else {
#line 488
        tmp___117 = __builtin_strcmp((char const   *)options->name, "mount_add");
#line 488
        tmp___114 = tmp___117;
      }
    } else {
#line 488
      tmp___117 = __builtin_strcmp((char const   *)options->name, "mount_add");
#line 488
      tmp___114 = tmp___117;
    }
#line 488
    if (! tmp___114) {
#line 489
      tmp___108 = __strdup((char const   *)options->value);
#line 489
      url_info->stream_start = tmp___108;
    }
#line 490
    if (0) {
#line 490
      __s1_len___4 = strlen((char const   *)options->name);
#line 490
      __s2_len___4 = strlen("mount_remove");
#line 490
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___10;
      } else {
#line 490
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 490
          if (! ((unsigned int )((void const   *)("mount_remove" + 1)) - (unsigned int )((void const   *)"mount_remove") ==
                 1U)) {
#line 490
            tmp___138 = 1;
          } else {
#line 490
            if (__s2_len___4 >= 4U) {
#line 490
              tmp___138 = 1;
            } else {
#line 490
              tmp___138 = 0;
            }
          }
        } else {
#line 490
          tmp___138 = 0;
        }
      }
#line 490
      if (tmp___138) {
#line 490
        tmp___134 = __builtin_strcmp((char const   *)options->name, "mount_remove");
      } else {
#line 490
        tmp___137 = __builtin_strcmp((char const   *)options->name, "mount_remove");
#line 490
        tmp___134 = tmp___137;
      }
    } else {
#line 490
      tmp___137 = __builtin_strcmp((char const   *)options->name, "mount_remove");
#line 490
      tmp___134 = tmp___137;
    }
#line 490
    if (! tmp___134) {
#line 491
      tmp___128 = __strdup((char const   *)options->value);
#line 491
      url_info->stream_end = tmp___128;
    }
#line 492
    if (0) {
#line 492
      __s1_len___5 = strlen((char const   *)options->name);
#line 492
      __s2_len___5 = strlen("auth_header");
#line 492
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___12;
      } else {
#line 492
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 492
          if (! ((unsigned int )((void const   *)("auth_header" + 1)) - (unsigned int )((void const   *)"auth_header") ==
                 1U)) {
#line 492
            tmp___158 = 1;
          } else {
#line 492
            if (__s2_len___5 >= 4U) {
#line 492
              tmp___158 = 1;
            } else {
#line 492
              tmp___158 = 0;
            }
          }
        } else {
#line 492
          tmp___158 = 0;
        }
      }
#line 492
      if (tmp___158) {
#line 492
        tmp___154 = __builtin_strcmp((char const   *)options->name, "auth_header");
      } else {
#line 492
        tmp___157 = __builtin_strcmp((char const   *)options->name, "auth_header");
#line 492
        tmp___154 = tmp___157;
      }
    } else {
#line 492
      tmp___157 = __builtin_strcmp((char const   *)options->name, "auth_header");
#line 492
      tmp___154 = tmp___157;
    }
#line 492
    if (! tmp___154) {
#line 494
      free((void *)url_info->auth_header);
#line 495
      tmp___148 = __strdup((char const   *)options->value);
#line 495
      url_info->auth_header = tmp___148;
    }
#line 497
    if (0) {
#line 497
      __s1_len___6 = strlen((char const   *)options->name);
#line 497
      __s2_len___6 = strlen("timelimit_header");
#line 497
      if (! ((unsigned int )((void const   *)(options->name + 1)) - (unsigned int )((void const   *)options->name) ==
             1U)) {
        goto _L___14;
      } else {
#line 497
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 497
          if (! ((unsigned int )((void const   *)("timelimit_header" + 1)) - (unsigned int )((void const   *)"timelimit_header") ==
                 1U)) {
#line 497
            tmp___178 = 1;
          } else {
#line 497
            if (__s2_len___6 >= 4U) {
#line 497
              tmp___178 = 1;
            } else {
#line 497
              tmp___178 = 0;
            }
          }
        } else {
#line 497
          tmp___178 = 0;
        }
      }
#line 497
      if (tmp___178) {
#line 497
        tmp___174 = __builtin_strcmp((char const   *)options->name, "timelimit_header");
      } else {
#line 497
        tmp___177 = __builtin_strcmp((char const   *)options->name, "timelimit_header");
#line 497
        tmp___174 = tmp___177;
      }
    } else {
#line 497
      tmp___177 = __builtin_strcmp((char const   *)options->name, "timelimit_header");
#line 497
      tmp___174 = tmp___177;
    }
#line 497
    if (tmp___174 == 0) {
#line 499
      free((void *)url_info->timelimit_header);
#line 500
      tmp___168 = __strdup((char const   *)options->value);
#line 500
      url_info->timelimit_header = tmp___168;
    }
#line 502
    options = options->next;
  }
#line 504
  url_info->handle = curl_easy_init();
#line 505
  if ((unsigned int )url_info->handle == (unsigned int )((void *)0)) {
#line 507
    free((void *)url_info);
#line 508
    return (-1);
  }
#line 510
  if (url_info->auth_header) {
#line 511
    url_info->auth_header_len = (int )strlen((char const   *)url_info->auth_header);
  }
#line 512
  if (url_info->timelimit_header) {
#line 513
    url_info->timelimit_header_len = (int )strlen((char const   *)url_info->timelimit_header);
  }
#line 515
  curl_easy_setopt(url_info->handle, 10018, "Icecast 2.3.1");
#line 516
  curl_easy_setopt(url_info->handle, 20079, & handle_returned_header);
#line 517
  curl_easy_setopt(url_info->handle, 20011, & handle_returned_data);
#line 518
  curl_easy_setopt(url_info->handle, 10001, url_info->handle);
#line 519
  curl_easy_setopt(url_info->handle, 99, 1L);
#line 520
  curl_easy_setopt(url_info->handle, 13, 15L);
#line 521
  curl_easy_setopt(url_info->handle, (enum __anonenum_CURLoption_1 )-3, & my_getpass);
#line 522
  curl_easy_setopt(url_info->handle, 10010, & url_info->errormsg[0]);
#line 524
  if (url_info->username) {
#line 524
    if (url_info->password) {
#line 526
      tmp___179 = strlen((char const   *)url_info->username);
#line 526
      tmp___180 = strlen((char const   *)url_info->password);
#line 526
      len = (int )((tmp___179 + tmp___180) + 2U);
#line 527
      url_info->userpwd = (char *)malloc((unsigned int )len);
#line 528
      snprintf((char * __restrict  )url_info->userpwd, (unsigned int )len, (char const   * __restrict  )"%s:%s",
               url_info->username, url_info->password);
    }
  }
#line 531
  authenticator->state = (void *)url_info;
#line 532
  log_write(errorlog, 3U, "auth_url/", "auth_get_url_auth", "URL based authentication setup");
#line 533
  return (0);
}
}
#line 1 "cil-R9mQhuin.o"
#pragma merger(0,"/tmp/cil-kfIIbJRX.i","")
#line 1 "./src/yp.o_saved.c"
#pragma merger(0,"./yp.i","-Wall -ffast-math -fsigned-char -pthread -g -O2")
#line 1171 "/usr/include/curl/curl.h"
extern void curl_global_cleanup(void) ;
#line 85 "yp.c"
static rwlock_t yp_lock  ;
#line 86 "yp.c"
static mutex_t yp_pending_lock  ;
#line 88 "yp.c"
static struct yp_server  volatile  *active_yps  =    (struct yp_server  volatile  *)((void *)0);
#line 88 "yp.c"
static struct yp_server  volatile  *pending_yps  =    (struct yp_server  volatile  *)((void *)0);
#line 89 "yp.c"
static int volatile   yp_update  =    (int volatile   )0;
#line 90 "yp.c"
static int yp_running  ;
#line 91 "yp.c"
static time_t now  ;
#line 92 "yp.c"
static thread_type *yp_thread  ;
#line 93 "yp.c"
static unsigned int volatile   client_limit  =    (unsigned int volatile   )0;
#line 95
static void *yp_update_thread(void *arg ) ;
#line 96
static void add_yp_info(ypdata_t *yp , void *info , int type ) ;
#line 97
static unsigned int do_yp_remove(ypdata_t *yp , char *s , unsigned int len ) ;
#line 98
static unsigned int do_yp_add(ypdata_t *yp , char *s , unsigned int len ) ;
#line 99
static unsigned int do_yp_touch(ypdata_t *yp , char *s , unsigned int len ) ;
#line 100
static void yp_destroy_ypdata(ypdata_t *ypdata ) ;
#line 104 "yp.c"
static int handle_returned_header___0(void *ptr , size_t size , size_t nmemb , void *stream ) 
{ ypdata_t *yp ;
  unsigned int bytes ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned int len ;
  int tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  unsigned int len___0 ;
  int tmp___64 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___70 ;
  int tmp___73 ;
  int tmp___74 ;
  unsigned int secs ;
  int tmp___90 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___96 ;
  int tmp___99 ;
  int tmp___100 ;

  {
#line 106
  yp = (ypdata_t *)stream;
#line 107
  bytes = size * nmemb;
#line 110
  if (0) {
#line 110
    if (0) {
#line 110
      __s1_len___0 = strlen((char const   *)ptr);
#line 110
      __s2_len___0 = strlen("YPResponse: 1");
#line 110
      if (! ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
             1U)) {
        goto _L___2;
      } else {
#line 110
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 110
          if (! ((unsigned int )((void const   *)("YPResponse: 1" + 1)) - (unsigned int )((void const   *)"YPResponse: 1") ==
                 1U)) {
#line 110
            tmp___22 = 1;
          } else {
#line 110
            if (__s2_len___0 >= 4U) {
#line 110
              tmp___22 = 1;
            } else {
#line 110
              tmp___22 = 0;
            }
          }
        } else {
#line 110
          tmp___22 = 0;
        }
      }
#line 110
      if (tmp___22) {
#line 110
        tmp___18 = __builtin_strcmp((char const   *)ptr, "YPResponse: 1");
      } else {
#line 110
        tmp___21 = __builtin_strcmp((char const   *)ptr, "YPResponse: 1");
#line 110
        tmp___18 = tmp___21;
      }
    } else {
#line 110
      tmp___21 = __builtin_strcmp((char const   *)ptr, "YPResponse: 1");
#line 110
      tmp___18 = tmp___21;
    }
#line 110
    tmp___12 = tmp___18;
  } else {
#line 110
    tmp___12 = strncmp((char const   *)ptr, "YPResponse: 1", 13U);
  }
#line 110
  if (tmp___12 == 0) {
#line 111
    yp->cmd_ok = 1;
  }
#line 113
  if (0) {
#line 113
    if (0) {
#line 113
      __s1_len___2 = strlen((char const   *)ptr);
#line 113
      __s2_len___2 = strlen("YPMessage: ");
#line 113
      if (! ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
             1U)) {
        goto _L___6;
      } else {
#line 113
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 113
          if (! ((unsigned int )((void const   *)("YPMessage: " + 1)) - (unsigned int )((void const   *)"YPMessage: ") ==
                 1U)) {
#line 113
            tmp___48 = 1;
          } else {
#line 113
            if (__s2_len___2 >= 4U) {
#line 113
              tmp___48 = 1;
            } else {
#line 113
              tmp___48 = 0;
            }
          }
        } else {
#line 113
          tmp___48 = 0;
        }
      }
#line 113
      if (tmp___48) {
#line 113
        tmp___44 = __builtin_strcmp((char const   *)ptr, "YPMessage: ");
      } else {
#line 113
        tmp___47 = __builtin_strcmp((char const   *)ptr, "YPMessage: ");
#line 113
        tmp___44 = tmp___47;
      }
    } else {
#line 113
      tmp___47 = __builtin_strcmp((char const   *)ptr, "YPMessage: ");
#line 113
      tmp___44 = tmp___47;
    }
#line 113
    tmp___38 = tmp___44;
  } else {
#line 113
    tmp___38 = strncmp((char const   *)ptr, "YPMessage: ", 11U);
  }
#line 113
  if (tmp___38 == 0) {
#line 115
    len = bytes - 11U;
#line 116
    free((void *)yp->error_msg);
#line 117
    yp->error_msg = (char *)calloc(1U, len);
#line 118
    if (yp->error_msg) {
#line 119
      sscanf((char const   * __restrict  )ptr, (char const   * __restrict  )"YPMessage: %[^\r\n]",
             yp->error_msg);
    }
  }
#line 122
  if ((unsigned int )yp->process == (unsigned int )(& do_yp_add)) {
#line 124
    if (0) {
#line 124
      if (0) {
#line 124
        __s1_len___4 = strlen((char const   *)ptr);
#line 124
        __s2_len___4 = strlen("SID: ");
#line 124
        if (! ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
               1U)) {
          goto _L___10;
        } else {
#line 124
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 124
            if (! ((unsigned int )((void const   *)("SID: " + 1)) - (unsigned int )((void const   *)"SID: ") ==
                   1U)) {
#line 124
              tmp___74 = 1;
            } else {
#line 124
              if (__s2_len___4 >= 4U) {
#line 124
                tmp___74 = 1;
              } else {
#line 124
                tmp___74 = 0;
              }
            }
          } else {
#line 124
            tmp___74 = 0;
          }
        }
#line 124
        if (tmp___74) {
#line 124
          tmp___70 = __builtin_strcmp((char const   *)ptr, "SID: ");
        } else {
#line 124
          tmp___73 = __builtin_strcmp((char const   *)ptr, "SID: ");
#line 124
          tmp___70 = tmp___73;
        }
      } else {
#line 124
        tmp___73 = __builtin_strcmp((char const   *)ptr, "SID: ");
#line 124
        tmp___70 = tmp___73;
      }
#line 124
      tmp___64 = tmp___70;
    } else {
#line 124
      tmp___64 = strncmp((char const   *)ptr, "SID: ", 5U);
    }
#line 124
    if (tmp___64 == 0) {
#line 126
      len___0 = bytes - 5U;
#line 127
      free((void *)yp->sid);
#line 128
      yp->sid = (char *)calloc(1U, len___0);
#line 129
      if (yp->sid) {
#line 130
        sscanf((char const   * __restrict  )ptr, (char const   * __restrict  )"SID: %[^\r\n]",
               yp->sid);
      }
    }
  }
#line 133
  if (0) {
#line 133
    if (0) {
#line 133
      __s1_len___6 = strlen((char const   *)ptr);
#line 133
      __s2_len___6 = strlen("TouchFreq: ");
#line 133
      if (! ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
             1U)) {
        goto _L___14;
      } else {
#line 133
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 133
          if (! ((unsigned int )((void const   *)("TouchFreq: " + 1)) - (unsigned int )((void const   *)"TouchFreq: ") ==
                 1U)) {
#line 133
            tmp___100 = 1;
          } else {
#line 133
            if (__s2_len___6 >= 4U) {
#line 133
              tmp___100 = 1;
            } else {
#line 133
              tmp___100 = 0;
            }
          }
        } else {
#line 133
          tmp___100 = 0;
        }
      }
#line 133
      if (tmp___100) {
#line 133
        tmp___96 = __builtin_strcmp((char const   *)ptr, "TouchFreq: ");
      } else {
#line 133
        tmp___99 = __builtin_strcmp((char const   *)ptr, "TouchFreq: ");
#line 133
        tmp___96 = tmp___99;
      }
    } else {
#line 133
      tmp___99 = __builtin_strcmp((char const   *)ptr, "TouchFreq: ");
#line 133
      tmp___96 = tmp___99;
    }
#line 133
    tmp___90 = tmp___96;
  } else {
#line 133
    tmp___90 = strncmp((char const   *)ptr, "TouchFreq: ", 11U);
  }
#line 133
  if (tmp___90 == 0) {
#line 136
    sscanf((char const   * __restrict  )ptr, (char const   * __restrict  )"TouchFreq: %u",
           & secs);
#line 137
    if (secs < 30U) {
#line 138
      secs = 30U;
    }
#line 139
    log_write(errorlog, 4U, "yp/", "handle_returned_header", "server touch interval is %u",
              secs);
#line 140
    yp->touch_interval = secs;
  }
#line 142
  return ((int )bytes);
}
}
#line 147 "yp.c"
static int handle_returned_data___0(void *ptr , size_t size , size_t nmemb , void *stream ) 
{ 

  {
#line 149
  return ((int )(size * nmemb));
}
}
#line 154 "yp.c"
static struct yp_server *find_yp_server(char const   *url ) 
{ struct yp_server *server ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 158
  server = (struct yp_server *)active_yps;
#line 159
  while (server) {
#line 161
    if (0) {
#line 161
      __s1_len = strlen((char const   *)server->url);
#line 161
      __s2_len = strlen(url);
#line 161
      if (! ((unsigned int )((void const   *)(server->url + 1)) - (unsigned int )((void const   *)server->url) ==
             1U)) {
        goto _L___0;
      } else {
#line 161
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 161
          if (! ((unsigned int )((void const   *)(url + 1)) - (unsigned int )((void const   *)url) ==
                 1U)) {
#line 161
            tmp___8 = 1;
          } else {
#line 161
            if (__s2_len >= 4U) {
#line 161
              tmp___8 = 1;
            } else {
#line 161
              tmp___8 = 0;
            }
          }
        } else {
#line 161
          tmp___8 = 0;
        }
      }
#line 161
      if (tmp___8) {
#line 161
        tmp___4 = __builtin_strcmp((char const   *)server->url, url);
      } else {
#line 161
        tmp___7 = __builtin_strcmp((char const   *)server->url, url);
#line 161
        tmp___4 = tmp___7;
      }
    } else {
#line 161
      tmp___7 = __builtin_strcmp((char const   *)server->url, url);
#line 161
      tmp___4 = tmp___7;
    }
#line 161
    if (tmp___4 == 0) {
#line 162
      return (server);
    }
#line 163
    server = server->next;
  }
#line 165
  server = (struct yp_server *)pending_yps;
#line 166
  while (server) {
#line 168
    if (0) {
#line 168
      __s1_len___0 = strlen((char const   *)server->url);
#line 168
      __s2_len___0 = strlen(url);
#line 168
      if (! ((unsigned int )((void const   *)(server->url + 1)) - (unsigned int )((void const   *)server->url) ==
             1U)) {
        goto _L___2;
      } else {
#line 168
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 168
          if (! ((unsigned int )((void const   *)(url + 1)) - (unsigned int )((void const   *)url) ==
                 1U)) {
#line 168
            tmp___18 = 1;
          } else {
#line 168
            if (__s2_len___0 >= 4U) {
#line 168
              tmp___18 = 1;
            } else {
#line 168
              tmp___18 = 0;
            }
          }
        } else {
#line 168
          tmp___18 = 0;
        }
      }
#line 168
      if (tmp___18) {
#line 168
        tmp___14 = __builtin_strcmp((char const   *)server->url, url);
      } else {
#line 168
        tmp___17 = __builtin_strcmp((char const   *)server->url, url);
#line 168
        tmp___14 = tmp___17;
      }
    } else {
#line 168
      tmp___17 = __builtin_strcmp((char const   *)server->url, url);
#line 168
      tmp___14 = tmp___17;
    }
#line 168
    if (tmp___14 == 0) {
#line 169
      break;
    }
#line 170
    server = server->next;
  }
#line 172
  return (server);
}
}
#line 176 "yp.c"
static void destroy_yp_server(struct yp_server *server ) 
{ 

  {
#line 178
  if ((unsigned int )server == (unsigned int )((void *)0)) {
#line 179
    return;
  }
#line 180
  log_write(errorlog, 4U, "yp/", "destroy_yp_server", "Removing YP server entry for %s",
            server->url);
#line 181
  if (server->curl) {
#line 182
    curl_easy_cleanup(server->curl);
  }
#line 183
  if (server->mounts) {
#line 183
    log_write(errorlog, 2U, "yp/", "destroy_yp_server", "active ypdata not freed up");
  }
#line 184
  if (server->pending_mounts) {
#line 184
    log_write(errorlog, 2U, "yp/", "destroy_yp_server", "pending ypdata not freed up");
  }
#line 185
  free((void *)server->url);
#line 186
  free((void *)server);
#line 187
  return;
}
}
#line 192 "yp.c"
static ypdata_t *find_yp_mount(ypdata_t *mounts , char const   *mount ) 
{ ypdata_t *yp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 194
  yp = mounts;
#line 195
  while (yp) {
#line 197
    if (0) {
#line 197
      __s1_len = strlen((char const   *)yp->mount);
#line 197
      __s2_len = strlen(mount);
#line 197
      if (! ((unsigned int )((void const   *)(yp->mount + 1)) - (unsigned int )((void const   *)yp->mount) ==
             1U)) {
        goto _L___0;
      } else {
#line 197
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 197
          if (! ((unsigned int )((void const   *)(mount + 1)) - (unsigned int )((void const   *)mount) ==
                 1U)) {
#line 197
            tmp___8 = 1;
          } else {
#line 197
            if (__s2_len >= 4U) {
#line 197
              tmp___8 = 1;
            } else {
#line 197
              tmp___8 = 0;
            }
          }
        } else {
#line 197
          tmp___8 = 0;
        }
      }
#line 197
      if (tmp___8) {
#line 197
        tmp___4 = __builtin_strcmp((char const   *)yp->mount, mount);
      } else {
#line 197
        tmp___7 = __builtin_strcmp((char const   *)yp->mount, mount);
#line 197
        tmp___4 = tmp___7;
      }
    } else {
#line 197
      tmp___7 = __builtin_strcmp((char const   *)yp->mount, mount);
#line 197
      tmp___4 = tmp___7;
    }
#line 197
    if (tmp___4 == 0) {
#line 198
      break;
    }
#line 199
    yp = yp->next;
  }
#line 201
  return (yp);
}
}
#line 205 "yp.c"
void yp_recheck_config(ice_config_t *config ) 
{ int i ;
  struct yp_server *server ;
  char *tmp___8 ;

  {
#line 210
  log_write(errorlog, 4U, "yp/", "yp_recheck_config", "Updating YP configuration");
#line 211
  thread_rwlock_rlock_c(& yp_lock, 211, (char *)"yp.c");
#line 213
  server = (struct yp_server *)active_yps;
#line 214
  while (server) {
#line 216
    server->remove = 1;
#line 217
    server = server->next;
  }
#line 219
  client_limit = (unsigned int volatile   )config->client_limit;
#line 222
  i = 0;
#line 222
  while (i < config->num_yp_directories) {
#line 224
    server = find_yp_server((char const   *)config->yp_url[i]);
#line 225
    if ((unsigned int )server == (unsigned int )((void *)0)) {
#line 227
      server = (struct yp_server *)calloc(1U, sizeof(struct yp_server ));
#line 229
      if ((unsigned int )server == (unsigned int )((void *)0)) {
#line 231
        destroy_yp_server(server);
#line 232
        break;
      }
#line 234
      tmp___8 = __strdup((char const   *)config->yp_url[i]);
#line 234
      server->url = tmp___8;
#line 235
      server->url_timeout = (unsigned int )config->yp_url_timeout[i];
#line 236
      server->touch_interval = (unsigned int )config->yp_touch_interval[i];
#line 237
      server->curl = curl_easy_init();
#line 238
      if ((unsigned int )server->curl == (unsigned int )((void *)0)) {
#line 240
        destroy_yp_server(server);
#line 241
        break;
      }
#line 243
      if (server->touch_interval < 30U) {
#line 244
        server->touch_interval = 30U;
      }
#line 245
      curl_easy_setopt(server->curl, 10018, "Icecast 2.3.1");
#line 246
      curl_easy_setopt(server->curl, 10002, server->url);
#line 247
      curl_easy_setopt(server->curl, 20079, & handle_returned_header___0);
#line 248
      curl_easy_setopt(server->curl, 20011, & handle_returned_data___0);
#line 249
      curl_easy_setopt(server->curl, 10001, server->curl);
#line 250
      curl_easy_setopt(server->curl, 13, server->url_timeout);
#line 251
      curl_easy_setopt(server->curl, 99, 1L);
#line 252
      curl_easy_setopt(server->curl, 10010, & server->curl_error[0]);
#line 253
      server->next = (struct yp_server *)pending_yps;
#line 254
      pending_yps = (struct yp_server  volatile  *)server;
#line 255
      log_write(errorlog, 3U, "yp/", "yp_recheck_config", "Adding new YP server \"%s\" (timeout %ds, default interval %ds)",
                server->url, server->url_timeout, server->touch_interval);
    } else {
#line 260
      server->remove = 0;
    }
#line 222
    i ++;
  }
#line 263
  thread_rwlock_unlock_c(& yp_lock, 263, (char *)"yp.c");
#line 264
  yp_update = (int volatile   )1;
#line 265
  return;
}
}
#line 268 "yp.c"
void yp_initialize(void) 
{ ice_config_t *config ;
  ice_config_t *tmp ;

  {
#line 270
  tmp = config_get_config();
#line 270
  config = tmp;
#line 271
  thread_rwlock_create_c(& yp_lock, 271, (char *)"yp.c");
#line 272
  thread_mutex_create_c(& yp_pending_lock, 272, (char *)"yp.c");
#line 273
  yp_recheck_config(config);
#line 274
  config_release_config();
#line 275
  yp_thread = thread_create_c((char *)"YP Touch Thread", & yp_update_thread, (void *)0,
                              0, 276, (char *)"yp.c");
#line 277
  return;
}
}
#line 282 "yp.c"
static int send_to_yp(char const   *cmd , ypdata_t *yp , char *post ) 
{ int curlcode ;
  struct yp_server *server ;
  char *tmp___8 ;

  {
#line 285
  server = yp->server;
#line 288
  yp->cmd_ok = 0;
#line 289
  curl_easy_setopt(server->curl, 10015, post);
#line 290
  curl_easy_setopt(server->curl, 10029, yp);
#line 291
  curlcode = (int )curl_easy_perform(server->curl);
#line 292
  if (curlcode) {
#line 294
    yp->process = & do_yp_add;
#line 295
    yp->next_update += 300L;
#line 296
    log_write(errorlog, 1U, "yp/", "send_to_yp", "connection to %s failed with \"%s\"",
              server->url, server->curl_error);
#line 297
    return (-1);
  }
#line 299
  if (yp->cmd_ok == 0) {
#line 301
    if ((unsigned int )yp->error_msg == (unsigned int )((void *)0)) {
#line 302
      tmp___8 = __strdup("no response from server");
#line 302
      yp->error_msg = tmp___8;
    }
#line 303
    yp->process = & do_yp_add;
#line 304
    yp->next_update += 300L;
#line 305
    log_write(errorlog, 1U, "yp/", "send_to_yp", "YP %s on %s failed: %s", cmd, server->url,
              yp->error_msg);
#line 306
    return (-1);
  }
#line 308
  log_write(errorlog, 4U, "yp/", "send_to_yp", "YP %s at %s succeeded", cmd, server->url);
#line 309
  return (0);
}
}
#line 314 "yp.c"
static unsigned int do_yp_remove(ypdata_t *yp , char *s , unsigned int len ) 
{ int ret ;
  int tmp ;

  {
#line 316
  if (yp->sid) {
#line 318
    tmp = snprintf((char * __restrict  )s, len, (char const   * __restrict  )"action=remove&sid=%s",
                   yp->sid);
#line 318
    ret = tmp;
#line 319
    if (ret >= (int )len) {
#line 320
      return ((unsigned int )(ret + 1));
    }
#line 322
    log_write(errorlog, 3U, "yp/", "do_yp_remove", "clearing up YP entry for %s",
              yp->mount);
#line 323
    send_to_yp("remove", yp, s);
#line 324
    free((void *)yp->sid);
#line 325
    yp->sid = (char *)((void *)0);
  }
#line 327
  yp_update = (int volatile   )1;
#line 328
  yp->remove = 1;
#line 329
  yp->process = & do_yp_add;
#line 331
  return (0U);
}
}
#line 335 "yp.c"
static unsigned int do_yp_add(ypdata_t *yp , char *s , unsigned int len ) 
{ int ret ;
  char *value ;
  time_t tmp ;
  int tmp___0 ;

  {
#line 340
  value = stats_get_value(yp->mount, (char *)"server_type");
#line 341
  add_yp_info(yp, (void *)value, 7);
#line 342
  free((void *)value);
#line 344
  value = stats_get_value(yp->mount, (char *)"server_name");
#line 345
  add_yp_info(yp, (void *)value, 1);
#line 346
  free((void *)value);
#line 348
  value = stats_get_value(yp->mount, (char *)"server_url");
#line 349
  add_yp_info(yp, (void *)value, 4);
#line 350
  free((void *)value);
#line 352
  value = stats_get_value(yp->mount, (char *)"genre");
#line 353
  add_yp_info(yp, (void *)value, 3);
#line 354
  free((void *)value);
#line 356
  value = stats_get_value(yp->mount, (char *)"bitrate");
#line 357
  add_yp_info(yp, (void *)value, 5);
#line 358
  free((void *)value);
#line 360
  value = stats_get_value(yp->mount, (char *)"server_description");
#line 361
  add_yp_info(yp, (void *)value, 2);
#line 362
  free((void *)value);
#line 364
  value = stats_get_value(yp->mount, (char *)"subtype");
#line 365
  add_yp_info(yp, (void *)value, 10);
#line 366
  free((void *)value);
#line 368
  value = stats_get_value(yp->mount, (char *)"audio_info");
#line 369
  add_yp_info(yp, (void *)value, 6);
#line 370
  free((void *)value);
#line 372
  ret = snprintf((char * __restrict  )s, len, (char const   * __restrict  )"action=add&sn=%s&genre=%s&cpswd=%s&desc=%s&url=%s&listenurl=%s&type=%s&stype=%s&b=%s&%s\r\n",
                 yp->server_name, yp->server_genre, yp->cluster_password, yp->server_desc,
                 yp->url, yp->listen_url, yp->server_type, yp->subtype, yp->bitrate,
                 yp->audio_info);
#line 377
  if (ret >= (int )len) {
#line 378
    return ((unsigned int )(ret + 1));
  }
#line 379
  tmp___0 = send_to_yp("add", yp, s);
#line 379
  if (tmp___0 == 0) {
#line 381
    yp->process = & do_yp_touch;
#line 383
    tmp = time((time_t *)((void *)0));
#line 383
    yp->next_update = tmp + 5L;
  }
#line 386
  return (0U);
}
}
#line 390 "yp.c"
static unsigned int do_yp_touch(ypdata_t *yp , char *s , unsigned int len ) 
{ unsigned int listeners ;
  unsigned int max_listeners ;
  char *val ;
  char *artist ;
  char *title ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  char *song ;
  char *separator ;
  char *tmp___10 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char *tmp___24 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 392
  listeners = 0U;
#line 392
  max_listeners = 1U;
#line 396
  tmp = stats_get_value(yp->mount, (char *)"artist");
#line 396
  artist = tmp;
#line 397
  tmp___0 = stats_get_value(yp->mount, (char *)"title");
#line 397
  title = tmp___0;
#line 398
  if (artist) {
    goto _L;
  } else {
#line 398
    if (title) {
      _L: /* CIL Label */ 
#line 401
      separator = (char *)" - ";
#line 402
      if ((unsigned int )artist == (unsigned int )((void *)0)) {
#line 404
        tmp___10 = __strdup("");
#line 404
        artist = tmp___10;
#line 405
        separator = (char *)"";
      }
#line 407
      if ((unsigned int )title == (unsigned int )((void *)0)) {
#line 407
        tmp___20 = __strdup("");
#line 407
        title = tmp___20;
      }
#line 408
      tmp___21 = strlen((char const   *)artist);
#line 408
      tmp___22 = strlen((char const   *)title);
#line 408
      tmp___23 = strlen((char const   *)separator);
#line 408
      song = (char *)malloc(((tmp___21 + tmp___22) + tmp___23) + 1U);
#line 409
      if (song) {
#line 411
        sprintf((char * __restrict  )song, (char const   * __restrict  )"%s%s%s",
                artist, separator, title);
#line 412
        add_yp_info(yp, (void *)song, 8);
#line 413
        stats_event((char const   *)yp->mount, "yp_currently_playing", (char const   *)song);
#line 414
        free((void *)song);
      }
    }
  }
#line 417
  free((void *)artist);
#line 418
  free((void *)title);
#line 420
  tmp___24 = stats_get_value(yp->mount, (char *)"listeners");
#line 420
  val = tmp___24;
#line 421
  if (val) {
#line 423
    listeners = (unsigned int )atoi__extinline((char const   *)val);
#line 424
    free((void *)val);
  }
#line 426
  val = stats_get_value(yp->mount, (char *)"max_listeners");
#line 427
  if ((unsigned int )val == (unsigned int )((void *)0)) {
#line 429
    free((void *)val);
#line 430
    max_listeners = (unsigned int )client_limit;
  } else {
#line 427
    if (0) {
#line 427
      __s1_len = strlen((char const   *)val);
#line 427
      __s2_len = strlen("unlimited");
#line 427
      if (! ((unsigned int )((void const   *)(val + 1)) - (unsigned int )((void const   *)val) ==
             1U)) {
        goto _L___1;
      } else {
#line 427
        if (__s1_len >= 4U) {
          _L___1: /* CIL Label */ 
#line 427
          if (! ((unsigned int )((void const   *)("unlimited" + 1)) - (unsigned int )((void const   *)"unlimited") ==
                 1U)) {
#line 427
            tmp___34 = 1;
          } else {
#line 427
            if (__s2_len >= 4U) {
#line 427
              tmp___34 = 1;
            } else {
#line 427
              tmp___34 = 0;
            }
          }
        } else {
#line 427
          tmp___34 = 0;
        }
      }
#line 427
      if (tmp___34) {
#line 427
        tmp___30 = __builtin_strcmp((char const   *)val, "unlimited");
      } else {
#line 427
        tmp___33 = __builtin_strcmp((char const   *)val, "unlimited");
#line 427
        tmp___30 = tmp___33;
      }
    } else {
#line 427
      tmp___33 = __builtin_strcmp((char const   *)val, "unlimited");
#line 427
      tmp___30 = tmp___33;
    }
#line 427
    if (tmp___30 == 0) {
#line 429
      free((void *)val);
#line 430
      max_listeners = (unsigned int )client_limit;
    } else {
#line 433
      max_listeners = (unsigned int )atoi__extinline((char const   *)val);
    }
  }
#line 435
  val = stats_get_value(yp->mount, (char *)"subtype");
#line 436
  if (val) {
#line 438
    add_yp_info(yp, (void *)val, 10);
#line 439
    free((void *)val);
  }
#line 442
  ret = snprintf((char * __restrict  )s, len, (char const   * __restrict  )"action=touch&sid=%s&st=%s&listeners=%u&max_listeners=%u&stype=%s\r\n",
                 yp->sid, yp->current_song, listeners, max_listeners, yp->subtype);
#line 446
  if (ret >= (int )len) {
#line 447
    return ((unsigned int )(ret + 1));
  }
#line 449
  send_to_yp("touch", yp, s);
#line 450
  return (0U);
}
}
#line 455 "yp.c"
static void process_ypdata(struct yp_server *server , ypdata_t *yp ) 
{ unsigned int len ;
  char *s ;
  char *tmp ;
  unsigned int ret ;

  {
#line 457
  len = 512U;
#line 458
  s = (char *)((void *)0);
#line 460
  if (now < yp->next_update) {
#line 461
    return;
  }
#line 462
  yp->next_update = (long )((unsigned long )now + (unsigned long )yp->touch_interval);
#line 465
  while (1) {
#line 468
    tmp = (char *)realloc((void *)s, len);
#line 468
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 469
      return;
    }
#line 470
    s = tmp;
#line 472
    if (yp->release) {
#line 474
      yp->process = & do_yp_remove;
#line 475
      yp->next_update = 0L;
    }
#line 478
    ret = ((*(yp->process)))(yp, s, len);
#line 479
    if (ret == 0U) {
#line 481
      free((void *)s);
#line 482
      return;
    }
#line 484
    len = ret;
  }
}
}
#line 489 "yp.c"
static void yp_process_server(struct yp_server *server ) 
{ ypdata_t *yp ;

  {
#line 494
  yp = server->mounts;
#line 495
  while (yp) {
#line 497
    now = time((time_t *)((void *)0));
#line 498
    process_ypdata(server, yp);
#line 499
    yp = yp->next;
  }
#line 501
  return;
}
}
#line 505 "yp.c"
static ypdata_t *create_yp_entry(char const   *mount ) 
{ ypdata_t *yp ;
  char *s ;
  unsigned int len ;
  int ret ;
  char *url ;
  mount_proxy *mountproxy ;
  ice_config_t *config ;
  char *tmp___8 ;
  char *tmp___18 ;
  char *tmp___28 ;
  char *tmp___38 ;
  char *tmp___48 ;
  char *tmp___58 ;
  char *tmp___68 ;
  char *tmp___78 ;
  char *tmp___88 ;
  char *tmp___98 ;
  char *tmp___108 ;

  {
#line 510
  yp = (ypdata_t *)calloc(1U, sizeof(ypdata_t ));
#line 511
  while (1) {
#line 513
    len = 512U;
#line 516
    mountproxy = (mount_proxy *)((void *)0);
#line 519
    if ((unsigned int )yp == (unsigned int )((void *)0)) {
#line 520
      break;
    }
#line 521
    tmp___8 = __strdup(mount);
#line 521
    yp->mount = tmp___8;
#line 522
    tmp___18 = __strdup("");
#line 522
    yp->server_name = tmp___18;
#line 523
    tmp___28 = __strdup("");
#line 523
    yp->server_desc = tmp___28;
#line 524
    tmp___38 = __strdup("");
#line 524
    yp->server_genre = tmp___38;
#line 525
    tmp___48 = __strdup("");
#line 525
    yp->bitrate = tmp___48;
#line 526
    tmp___58 = __strdup("");
#line 526
    yp->server_type = tmp___58;
#line 527
    tmp___68 = __strdup("");
#line 527
    yp->cluster_password = tmp___68;
#line 528
    tmp___78 = __strdup("");
#line 528
    yp->url = tmp___78;
#line 529
    tmp___88 = __strdup("");
#line 529
    yp->current_song = tmp___88;
#line 530
    tmp___98 = __strdup("");
#line 530
    yp->audio_info = tmp___98;
#line 531
    tmp___108 = __strdup("");
#line 531
    yp->subtype = tmp___108;
#line 532
    yp->process = & do_yp_add;
#line 534
    url = (char *)malloc(len);
#line 535
    if ((unsigned int )url == (unsigned int )((void *)0)) {
#line 536
      break;
    }
#line 537
    config = config_get_config();
#line 538
    ret = snprintf((char * __restrict  )url, len, (char const   * __restrict  )"http://%s:%d%s",
                   config->hostname, config->port, mount);
#line 539
    if (ret >= (int )len) {
#line 541
      ret ++;
#line 541
      s = (char *)realloc((void *)url, (unsigned int )ret);
#line 542
      if (s) {
#line 542
        url = s;
      }
#line 543
      snprintf((char * __restrict  )url, (unsigned int )ret, (char const   * __restrict  )"http://%s:%d%s",
               config->hostname, config->port, mount);
    }
#line 546
    mountproxy = config_find_mount(config, mount);
#line 547
    if (mountproxy) {
#line 547
      if (mountproxy->cluster_password) {
#line 548
        add_yp_info(yp, (void *)mountproxy->cluster_password, 9);
      }
    }
#line 549
    config_release_config();
#line 551
    yp->listen_url = util_url_escape(url);
#line 552
    free((void *)url);
#line 553
    if ((unsigned int )yp->listen_url == (unsigned int )((void *)0)) {
#line 554
      break;
    }
#line 556
    return (yp);
#line 511
    break;
  }
#line 559
  yp_destroy_ypdata(yp);
#line 560
  return ((ypdata_t *)((void *)0));
}
}
#line 565 "yp.c"
static void check_servers(void) 
{ struct yp_server *server ;
  struct yp_server **server_p ;
  struct yp_server *to_go ;
  avl_node *node ;
  ypdata_t *yp ;
  source_t *source ;

  {
#line 567
  server = (struct yp_server *)active_yps;
#line 567
  server_p = (struct yp_server **)(& active_yps);
#line 570
  while (server) {
#line 572
    if (server->remove) {
#line 574
      to_go = server;
#line 575
      log_write(errorlog, 4U, "yp/", "check_servers", "YP server \"%s\"removed", server->url);
#line 576
      (*server_p) = server->next;
#line 577
      server = server->next;
#line 578
      destroy_yp_server(to_go);
#line 579
      continue;
    }
#line 581
    server_p = & server->next;
#line 582
    server = server->next;
  }
#line 585
  while (pending_yps) {
#line 589
    server = (struct yp_server *)pending_yps;
#line 590
    pending_yps = (struct yp_server  volatile  *)server->next;
#line 592
    log_write(errorlog, 4U, "yp/", "check_servers", "Add pending yps %s", server->url);
#line 593
    server->next = (struct yp_server *)active_yps;
#line 594
    active_yps = (struct yp_server  volatile  *)server;
#line 597
    avl_tree_rlock(global.source_tree);
#line 598
    node = avl_get_first(global.source_tree);
#line 599
    while (node) {
#line 603
      source = (source_t *)node->key;
#line 604
      if (source->yp_public) {
#line 604
        yp = create_yp_entry((char const   *)source->mount);
#line 604
        if ((unsigned int )yp != (unsigned int )((void *)0)) {
#line 606
          log_write(errorlog, 4U, "yp/", "check_servers", "Adding existing mount %s",
                    source->mount);
#line 607
          yp->server = server;
#line 608
          yp->touch_interval = server->touch_interval;
#line 609
          yp->next = server->mounts;
#line 610
          server->mounts = yp;
        }
      }
#line 612
      node = avl_get_next(node);
    }
#line 614
    avl_tree_unlock(global.source_tree);
  }
#line 616
  return;
}
}
#line 619 "yp.c"
static void add_pending_yp(struct yp_server *server ) 
{ ypdata_t *current ;
  ypdata_t *yp ;
  unsigned int count ;

  {
#line 622
  count = 0U;
#line 624
  if ((unsigned int )server->pending_mounts == (unsigned int )((void *)0)) {
#line 625
    return;
  }
#line 626
  current = server->mounts;
#line 627
  server->mounts = server->pending_mounts;
#line 628
  server->pending_mounts = (struct ypdata_tag *)((void *)0);
#line 629
  yp = server->mounts;
#line 630
  while (1) {
#line 632
    count ++;
#line 633
    if ((unsigned int )yp->next == (unsigned int )((void *)0)) {
#line 634
      break;
    }
#line 635
    yp = yp->next;
  }
#line 637
  yp->next = current;
#line 638
  log_write(errorlog, 4U, "yp/", "add_pending_yp", "%u YP entries added to %s", count,
            server->url);
#line 639
  return;
}
}
#line 642 "yp.c"
static void delete_marked_yp(struct yp_server *server ) 
{ ypdata_t *yp ;
  ypdata_t **prev ;
  ypdata_t *to_go ;

  {
#line 644
  yp = server->mounts;
#line 644
  prev = & server->mounts;
#line 646
  while (yp) {
#line 648
    if (yp->remove) {
#line 650
      to_go = yp;
#line 651
      log_write(errorlog, 4U, "yp/", "delete_marked_yp", "removed %s from YP server %s",
                yp->mount, server->url);
#line 652
      (*prev) = yp->next;
#line 653
      yp = yp->next;
#line 654
      yp_destroy_ypdata(to_go);
#line 655
      continue;
    }
#line 657
    prev = & yp->next;
#line 658
    yp = yp->next;
  }
#line 660
  return;
}
}
#line 663 "yp.c"
static void *yp_update_thread(void *arg ) 
{ struct yp_server *server ;
  struct yp_server *server___0 ;

  {
#line 665
  log_write(errorlog, 3U, "yp/", "yp_update_thread", "YP update thread started");
#line 667
  yp_running = 1;

  thread_register("yp_update_thread");
  thread_check_in();


#line 668
  LOOP_YP_UPDATE_THREAD:while (yp_running) {
#line 672
    thread_sleep(200000UL);

    __DSU_update("");
     thread_check_out();

#line 675
    thread_rwlock_rlock_c(& yp_lock, 675, (char *)"yp.c");
#line 676
    server = (struct yp_server *)active_yps;
#line 677
    while (server) {
#line 680
      yp_process_server(server);
#line 681
      server = server->next;
    }
#line 683
    thread_rwlock_unlock_c(& yp_lock, 683, (char *)"yp.c");
#line 686
    if (yp_update) {
#line 688
      thread_rwlock_wlock_c(& yp_lock, 688, (char *)"yp.c");
#line 689
      check_servers();
#line 690
      server = (struct yp_server *)active_yps;
#line 691
      while (server) {
#line 694
        add_pending_yp(server);
#line 695
        delete_marked_yp(server);
#line 696
        server = server->next;
      }
#line 698
      yp_update = (int volatile   )0;
#line 699
      thread_rwlock_unlock_c(& yp_lock, 699, (char *)"yp.c");
    }

    thread_check_in();
  }

  thread_deregister("yp_update_thread");

#line 702
  thread_rwlock_destroy(& yp_lock);
#line 703
  thread_mutex_destroy(& yp_pending_lock);
#line 705
  while (active_yps) {
#line 707
    server___0 = (struct yp_server *)active_yps;
#line 708
    active_yps = (struct yp_server  volatile  *)server___0->next;
#line 709
    destroy_yp_server(server___0);
  }
#line 712
  return ((void *)0);
}
}
#line 717 "yp.c"
static void yp_destroy_ypdata(ypdata_t *ypdata ) 
{ 

  {
#line 719
  if (ypdata) {
#line 720
    if (ypdata->mount) {
#line 721
      free((void *)ypdata->mount);
    }
#line 723
    if (ypdata->url) {
#line 724
      free((void *)ypdata->url);
    }
#line 726
    if (ypdata->sid) {
#line 727
      free((void *)ypdata->sid);
    }
#line 729
    if (ypdata->server_name) {
#line 730
      free((void *)ypdata->server_name);
    }
#line 732
    if (ypdata->server_desc) {
#line 733
      free((void *)ypdata->server_desc);
    }
#line 735
    if (ypdata->server_genre) {
#line 736
      free((void *)ypdata->server_genre);
    }
#line 738
    if (ypdata->cluster_password) {
#line 739
      free((void *)ypdata->cluster_password);
    }
#line 741
    if (ypdata->listen_url) {
#line 742
      free((void *)ypdata->listen_url);
    }
#line 744
    if (ypdata->current_song) {
#line 745
      free((void *)ypdata->current_song);
    }
#line 747
    if (ypdata->bitrate) {
#line 748
      free((void *)ypdata->bitrate);
    }
#line 750
    if (ypdata->server_type) {
#line 751
      free((void *)ypdata->server_type);
    }
#line 753
    if (ypdata->audio_info) {
#line 754
      free((void *)ypdata->audio_info);
    }
#line 756
    free((void *)ypdata->subtype);
#line 757
    free((void *)ypdata->error_msg);
#line 758
    free((void *)ypdata);
  }
#line 760
  return;
}
}
#line 762 "yp.c"
static void add_yp_info(ypdata_t *yp , void *info , int type ) 
{ char *escaped ;

  {
#line 766
  if (! info) {
#line 767
    return;
  }
#line 769
  escaped = util_url_escape((char *)info);
#line 770
  if ((unsigned int )escaped == (unsigned int )((void *)0)) {
#line 771
    return;
  }
#line 773
  switch (type) {
  case 1: 
#line 776
  free((void *)yp->server_name);
#line 777
  yp->server_name = escaped;
#line 778
  break;
  case 2: 
#line 780
  free((void *)yp->server_desc);
#line 781
  yp->server_desc = escaped;
#line 782
  break;
  case 3: 
#line 784
  free((void *)yp->server_genre);
#line 785
  yp->server_genre = escaped;
#line 786
  break;
  case 4: 
#line 788
  free((void *)yp->url);
#line 789
  yp->url = escaped;
#line 790
  break;
  case 5: 
#line 792
  free((void *)yp->bitrate);
#line 793
  yp->bitrate = escaped;
#line 794
  break;
  case 6: 
#line 796
  free((void *)yp->audio_info);
#line 797
  yp->audio_info = escaped;
#line 798
  break;
  case 7: 
#line 800
  free((void *)yp->server_type);
#line 801
  yp->server_type = escaped;
#line 802
  break;
  case 8: 
#line 804
  free((void *)yp->current_song);
#line 805
  yp->current_song = escaped;
#line 806
  break;
  case 9: 
#line 808
  free((void *)yp->cluster_password);
#line 809
  yp->cluster_password = escaped;
#line 810
  break;
  case 10: 
#line 812
  free((void *)yp->subtype);
#line 813
  yp->subtype = escaped;
#line 814
  break;
  }
#line 816
  return;
}
}
#line 820 "yp.c"
void yp_add(char const   *mount ) 
{ struct yp_server *server ;
  ypdata_t *yp ;
  time_t tmp ;

  {
#line 825
  thread_rwlock_rlock_c(& yp_lock, 825, (char *)"yp.c");
#line 828
  thread_mutex_lock_c(& yp_pending_lock, 828, (char *)"yp.c");
#line 829
  server = (struct yp_server *)active_yps;
#line 830
  while (server) {
#line 835
    yp = find_yp_mount(server->mounts, mount);
#line 836
    if ((unsigned int )yp == (unsigned int )((void *)0)) {
#line 839
      yp = create_yp_entry(mount);
#line 840
      if (yp) {
#line 842
        log_write(errorlog, 4U, "yp/", "yp_add", "Adding %s to %s", mount, server->url);
#line 843
        yp->server = server;
#line 844
        yp->touch_interval = server->touch_interval;
#line 845
        yp->next = server->pending_mounts;
#line 846
        tmp = time((time_t *)((void *)0));
#line 846
        yp->next_update = tmp + 5L;
#line 847
        server->pending_mounts = yp;
#line 848
        yp_update = (int volatile   )1;
      }
    } else {
#line 852
      log_write(errorlog, 4U, "yp/", "yp_add", "YP entry %s already exists", mount);
    }
#line 853
    server = server->next;
  }
#line 855
  thread_mutex_unlock_c(& yp_pending_lock, 855, (char *)"yp.c");
#line 856
  thread_rwlock_unlock_c(& yp_lock, 856, (char *)"yp.c");
#line 857
  return;
}
}
#line 862 "yp.c"
void yp_remove(char const   *mount ) 
{ struct yp_server *server ;
  ypdata_t *yp ;
  ypdata_t *tmp ;

  {
#line 864
  server = (struct yp_server *)active_yps;
#line 866
  thread_rwlock_rlock_c(& yp_lock, 866, (char *)"yp.c");
#line 867
  while (server) {
#line 869
    tmp = find_yp_mount(server->mounts, mount);
#line 869
    yp = tmp;
#line 870
    if (yp) {
#line 872
      log_write(errorlog, 4U, "yp/", "yp_remove", "release %s on YP %s", mount, server->url);
#line 873
      yp->release = 1;
#line 874
      yp->next_update = 0L;
    }
#line 876
    server = server->next;
  }
#line 878
  thread_rwlock_unlock_c(& yp_lock, 878, (char *)"yp.c");
#line 879
  return;
}
}
#line 884 "yp.c"
void yp_touch(char const   *mount ) 
{ struct yp_server *server ;
  time_t trigger ;
  ypdata_t *search_list ;
  time_t tmp ;
  ypdata_t *yp ;
  ypdata_t *tmp___0 ;

  {
#line 886
  server = (struct yp_server *)active_yps;
#line 888
  search_list = (ypdata_t *)((void *)0);
#line 890
  thread_rwlock_rlock_c(& yp_lock, 890, (char *)"yp.c");
#line 892
  tmp = time((time_t *)((void *)0));
#line 892
  trigger = tmp + 3L;
#line 893
  if (server) {
#line 894
    search_list = server->mounts;
  }
#line 896
  while (server) {
#line 898
    tmp___0 = find_yp_mount(search_list, mount);
#line 898
    yp = tmp___0;
#line 899
    if (yp) {
#line 902
      if (yp->release != 0) {
#line 904
        search_list = yp->next;
#line 905
        continue;
      } else {
#line 902
        if (yp->remove != 0) {
#line 904
          search_list = yp->next;
#line 905
          continue;
        }
      }
#line 908
      if ((unsigned int )yp->process == (unsigned int )(& do_yp_touch)) {
#line 909
        yp->next_update = trigger;
      }
    }
#line 911
    server = server->next;
#line 912
    if (server) {
#line 913
      search_list = server->mounts;
    }
  }
#line 915
  thread_rwlock_unlock_c(& yp_lock, 915, (char *)"yp.c");
#line 916
  return;
}
}
#line 919 "yp.c"
void yp_shutdown(void) 
{ 

  {
#line 921
  yp_running = 0;
#line 922
  yp_update = (int volatile   )1;
#line 923
  if (yp_thread) {
#line 924
    thread_join(yp_thread);
  }
#line 925
  curl_global_cleanup();
#line 926
  log_write(errorlog, 3U, "yp/", "yp_shutdown", "YP thread down");
#line 927
  return;
}
}
