/* Generated by CIL v. 1.3.4 */
/* print_CIL_Input is true */

struct __anonstruct___kernel_fd_set_1 {
   unsigned long fds_bits[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
typedef struct __anonstruct___kernel_fd_set_1 __kernel_fd_set;
typedef void (*__kernel_sighandler_t)(int  );
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;
typedef long long __kernel_loff_t;
struct __anonstruct___kernel_fsid_t_2 {
   int val[2] ;
};
typedef struct __anonstruct___kernel_fsid_t_2 __kernel_fsid_t;
typedef unsigned short umode_t;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef u64 dma_addr_t;
typedef u64 dma64_addr_t;
typedef unsigned short kmem_bufctl_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
typedef __kernel_old_uid_t old_uid_t;
typedef __kernel_old_gid_t old_gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_ptrdiff_t ptrdiff_t;
typedef __kernel_time_t time_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_caddr_t caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
typedef unsigned long sector_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
typedef struct __user_cap_header_struct *cap_user_header_t;
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
typedef struct __user_cap_data_struct *cap_user_data_t;
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
struct __anonstruct_pte_t_3 {
   unsigned long pte_low ;
   unsigned long pte_high ;
};
typedef struct __anonstruct_pte_t_3 pte_t;
struct __anonstruct_pmd_t_4 {
   unsigned long long pmd ;
};
typedef struct __anonstruct_pmd_t_4 pmd_t;
struct __anonstruct_pgd_t_5 {
   unsigned long long pgd ;
};
typedef struct __anonstruct_pgd_t_5 pgd_t;
struct __anonstruct_pgprot_t_6 {
   unsigned long long pgprot ;
};
typedef struct __anonstruct_pgprot_t_6 pgprot_t;
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct revectored_struct {
   unsigned long __map[8] ;
};
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
struct kernel_vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct pt_regs;
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
struct _xmmreg {
   unsigned long element[4] ;
};
struct _fpstate {
   unsigned long cw ;
   unsigned long sw ;
   unsigned long tag ;
   unsigned long ipoff ;
   unsigned long cssel ;
   unsigned long dataoff ;
   unsigned long datasel ;
   struct _fpreg _st[8] ;
   unsigned short status ;
   unsigned short magic ;
   unsigned long _fxsr_env[6] ;
   unsigned long mxcsr ;
   unsigned long reserved ;
   struct _fpxreg _fxsr_st[8] ;
   struct _xmmreg _xmm[8] ;
   unsigned long padding[56] ;
};
struct sigcontext {
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned long edi ;
   unsigned long esi ;
   unsigned long ebp ;
   unsigned long esp ;
   unsigned long ebx ;
   unsigned long edx ;
   unsigned long ecx ;
   unsigned long eax ;
   unsigned long trapno ;
   unsigned long err ;
   unsigned long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned long eflags ;
   unsigned long esp_at_signal ;
   unsigned short ss ;
   unsigned short __ssh ;
   struct _fpstate *fpstate ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
struct info {
   long ___orig_eip ;
   long ___ebx ;
   long ___ecx ;
   long ___edx ;
   long ___esi ;
   long ___edi ;
   long ___ebp ;
   long ___eax ;
   long ___ds ;
   long ___es ;
   long ___orig_eax ;
   long ___eip ;
   long ___cs ;
   long ___eflags ;
   long ___esp ;
   long ___ss ;
   long ___vm86_es ;
   long ___vm86_ds ;
   long ___vm86_fs ;
   long ___vm86_gs ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct __anonstruct_s_8 {
   __u32 a ;
   __u32 b ;
};
union __anonunion_v_7 {
   struct __anonstruct_s_8 s ;
   __u64 u ;
};
struct completion;
struct notifier_block;
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
};
struct sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(int )((20U - 2U * sizeof(long )) - sizeof(int ))] ;
};
struct task_struct;
struct __xchg_dummy {
   unsigned long a[100] ;
};
struct alt_instr {
   __u8 *instr ;
   __u8 *replacement ;
   __u8 cpuid ;
   __u8 instrlen ;
   __u8 replacementlen ;
   __u8 pad ;
};
struct desc_struct {
   unsigned long a ;
   unsigned long b ;
};
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   int cpuid_level ;
   unsigned long x86_capability[7] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int fdiv_bug ;
   int f00f_bug ;
   int coma_bug ;
   unsigned long loops_per_jiffy ;
   unsigned char x86_num_cores ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct tss_struct;
struct i387_fsave_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
   long status ;
};
struct i387_fxsave_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long mxcsr_mask ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
   unsigned char ftop ;
   unsigned char changed ;
   unsigned char lookahead ;
   unsigned char no_update ;
   unsigned char rm ;
   unsigned char alimit ;
   struct info *info ;
   unsigned long entry_eip ;
};
union i387_union {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
};
struct __anonstruct_mm_segment_t_9 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_9 mm_segment_t;
struct thread_struct;
struct tss_struct {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long esp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long esp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long esp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long eip ;
   unsigned long eflags ;
   unsigned long eax ;
   unsigned long ecx ;
   unsigned long edx ;
   unsigned long ebx ;
   unsigned long esp ;
   unsigned long ebp ;
   unsigned long esi ;
   unsigned long edi ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
   unsigned long io_bitmap[(int )(8192U / sizeof(long ) + 1U)] ;
   unsigned long io_bitmap_max ;
   struct thread_struct *io_bitmap_owner ;
   unsigned long __cacheline_filler[35] ;
   unsigned long stack[64] ;
} __attribute__((__packed__)) ;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long esp0 ;
   unsigned long sysenter_cs ;
   unsigned long eip ;
   unsigned long esp ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg[8] ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union i387_union i387 ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_esp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long io_bitmap_max ;
};
struct mm_struct;
struct microcode_header {
   unsigned int hdrver ;
   unsigned int rev ;
   unsigned int date ;
   unsigned int sig ;
   unsigned int cksum ;
   unsigned int ldrver ;
   unsigned int pf ;
   unsigned int datasize ;
   unsigned int totalsize ;
   unsigned int reserved[3] ;
};
struct microcode {
   struct microcode_header hdr ;
   unsigned int bits[0] ;
};
typedef struct microcode microcode_t;
typedef struct microcode_header microcode_header_t;
struct extended_signature {
   unsigned int sig ;
   unsigned int pf ;
   unsigned int cksum ;
};
struct extended_sigtable {
   unsigned int count ;
   unsigned int cksum ;
   unsigned int reserved[3] ;
   struct extended_signature sigs[0] ;
};
struct exec_domain;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   unsigned long flags ;
   unsigned long status ;
   __u32 cpu ;
   __s32 preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
};
struct __anonstruct_atomic_t_10 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_10 atomic_t;
struct __anonstruct_spinlock_t_11 {
   unsigned int volatile   slock ;
};
typedef struct __anonstruct_spinlock_t_11 spinlock_t;
struct __anonstruct_rwlock_t_12 {
   unsigned int volatile   lock ;
};
typedef struct __anonstruct_rwlock_t_12 rwlock_t;
typedef __u32 kernel_cap_t;
struct __anonstruct_seqlock_t_13 {
   unsigned int sequence ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_13 seqlock_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct itimerval;
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
typedef unsigned long long cycles_t;
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
struct rb_node {
   struct rb_node *rb_parent ;
   int rb_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct __anonstruct_cpumask_t_14 {
   unsigned long bits[1] ;
};
typedef struct __anonstruct_cpumask_t_14 cpumask_t;
struct __anonstruct_nodemask_t_15 {
   unsigned long bits[1] ;
};
typedef struct __anonstruct_nodemask_t_15 nodemask_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key );
struct __wait_queue {
   unsigned int flags ;
   struct task_struct *task ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
};
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct rw_semaphore;
struct rwsem_waiter;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct semaphore {
   atomic_t count ;
   int sleepers ;
   wait_queue_head_t wait ;
};
struct pt_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   int xds ;
   int xes ;
   long orig_eax ;
   long eip ;
   int xcs ;
   long eflags ;
   long esp ;
   int xss ;
};
struct __anonstruct_mm_context_t_16 {
   int size ;
   struct semaphore sem ;
   void *ldt ;
};
typedef struct __anonstruct_mm_context_t_16 mm_context_t;
typedef unsigned long cputime_t;
typedef u64 cputime64_t;
struct __anonstruct___reserved_01_17 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_02_18 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_id_19 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_version_20 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_03_21 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_04_22 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_05_23 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_06_24 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_tpr_25 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_apr_26 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_ppr_27 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_eoi_28 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_07_29 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_ldr_30 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_dfr_31 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_svr_32 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_isr_33 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_tmr_34 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_irr_35 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_error_bits_37 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_all_errors_38 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
union __anonunion_esr_36 {
   struct __anonstruct_error_bits_37 error_bits ;
   struct __anonstruct_all_errors_38 all_errors ;
};
struct __anonstruct___reserved_08_39 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_09_40 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_10_41 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_11_42 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_12_43 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_13_44 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_14_45 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_icr1_46 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
union __anonunion_dest_48 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
struct __anonstruct_icr2_47 {
   union __anonunion_dest_48 dest ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_timer_49 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_thermal_50 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_pc_51 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_lint0_52 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_lint1_53 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_error_54 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_timer_icr_55 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_timer_ccr_56 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_16_57 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_17_58 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_18_59 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_19_60 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_timer_dcr_61 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_20_62 {
   unsigned int __reserved[4] ;
};
struct local_apic {
   struct __anonstruct___reserved_01_17 __reserved_01 ;
   struct __anonstruct___reserved_02_18 __reserved_02 ;
   struct __anonstruct_id_19 id ;
   struct __anonstruct_version_20  const  version ;
   struct __anonstruct___reserved_03_21 __reserved_03 ;
   struct __anonstruct___reserved_04_22 __reserved_04 ;
   struct __anonstruct___reserved_05_23 __reserved_05 ;
   struct __anonstruct___reserved_06_24 __reserved_06 ;
   struct __anonstruct_tpr_25 tpr ;
   struct __anonstruct_apr_26  const  apr ;
   struct __anonstruct_ppr_27  const  ppr ;
   struct __anonstruct_eoi_28 eoi ;
   struct __anonstruct___reserved_07_29 __reserved_07 ;
   struct __anonstruct_ldr_30 ldr ;
   struct __anonstruct_dfr_31 dfr ;
   struct __anonstruct_svr_32 svr ;
   struct __anonstruct_isr_33 isr[8] ;
   struct __anonstruct_tmr_34 tmr[8] ;
   struct __anonstruct_irr_35 irr[8] ;
   union __anonunion_esr_36 esr ;
   struct __anonstruct___reserved_08_39 __reserved_08 ;
   struct __anonstruct___reserved_09_40 __reserved_09 ;
   struct __anonstruct___reserved_10_41 __reserved_10 ;
   struct __anonstruct___reserved_11_42 __reserved_11 ;
   struct __anonstruct___reserved_12_43 __reserved_12 ;
   struct __anonstruct___reserved_13_44 __reserved_13 ;
   struct __anonstruct___reserved_14_45 __reserved_14 ;
   struct __anonstruct_icr1_46 icr1 ;
   struct __anonstruct_icr2_47 icr2 ;
   struct __anonstruct_lvt_timer_49 lvt_timer ;
   struct __anonstruct_lvt_thermal_50 lvt_thermal ;
   struct __anonstruct_lvt_pc_51 lvt_pc ;
   struct __anonstruct_lvt_lint0_52 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_53 lvt_lint1 ;
   struct __anonstruct_lvt_error_54 lvt_error ;
   struct __anonstruct_timer_icr_55 timer_icr ;
   struct __anonstruct_timer_ccr_56  const  timer_ccr ;
   struct __anonstruct___reserved_16_57 __reserved_16 ;
   struct __anonstruct___reserved_17_58 __reserved_17 ;
   struct __anonstruct___reserved_18_59 __reserved_18 ;
   struct __anonstruct___reserved_19_60 __reserved_19 ;
   struct __anonstruct_timer_dcr_61 timer_dcr ;
   struct __anonstruct___reserved_20_62 __reserved_20 ;
} __attribute__((__packed__)) ;
enum km_type {
    __KM_FENCE_0 = 0,
    KM_BOUNCE_READ = 1,
    __KM_FENCE_1 = 2,
    KM_SKB_SUNRPC_DATA = 3,
    __KM_FENCE_2 = 4,
    KM_SKB_DATA_SOFTIRQ = 5,
    __KM_FENCE_3 = 6,
    KM_USER0 = 7,
    __KM_FENCE_4 = 8,
    KM_USER1 = 9,
    __KM_FENCE_5 = 10,
    KM_BIO_SRC_IRQ = 11,
    __KM_FENCE_6 = 12,
    KM_BIO_DST_IRQ = 13,
    __KM_FENCE_7 = 14,
    KM_PTE0 = 15,
    __KM_FENCE_8 = 16,
    KM_PTE1 = 17,
    __KM_FENCE_9 = 18,
    KM_IRQ0 = 19,
    __KM_FENCE_10 = 20,
    KM_IRQ1 = 21,
    __KM_FENCE_11 = 22,
    KM_SOFTIRQ0 = 23,
    __KM_FENCE_12 = 24,
    KM_SOFTIRQ1 = 25,
    __KM_FENCE_13 = 26,
    KM_TYPE_NR = 27
};
enum fixed_addresses {
    FIX_HOLE = 0,
    FIX_VSYSCALL = 1,
    FIX_APIC_BASE = 2,
    FIX_IO_APIC_BASE_0 = 3,
    FIX_IO_APIC_BASE_END = 10,
    FIX_CYCLONE_TIMER = 11,
    FIX_KMAP_BEGIN = 12,
    FIX_KMAP_END = 227,
    __end_of_permanent_fixed_addresses = 228,
    FIX_BTMAP_END = 228,
    FIX_BTMAP_BEGIN = 243,
    FIX_WP_TEST = 244,
    __end_of_fixed_addresses = 245
};
struct intel_mp_floating {
   char mpf_signature[4] ;
   unsigned long mpf_physptr ;
   unsigned char mpf_length ;
   unsigned char mpf_specification ;
   unsigned char mpf_checksum ;
   unsigned char mpf_feature1 ;
   unsigned char mpf_feature2 ;
   unsigned char mpf_feature3 ;
   unsigned char mpf_feature4 ;
   unsigned char mpf_feature5 ;
};
struct mp_config_table {
   char mpc_signature[4] ;
   unsigned short mpc_length ;
   char mpc_spec ;
   char mpc_checksum ;
   char mpc_oem[8] ;
   char mpc_productid[12] ;
   unsigned long mpc_oemptr ;
   unsigned short mpc_oemsize ;
   unsigned short mpc_oemcount ;
   unsigned long mpc_lapic ;
   unsigned long reserved ;
};
struct mpc_config_processor {
   unsigned char mpc_type ;
   unsigned char mpc_apicid ;
   unsigned char mpc_apicver ;
   unsigned char mpc_cpuflag ;
   unsigned long mpc_cpufeature ;
   unsigned long mpc_featureflag ;
   unsigned long mpc_reserved[2] ;
};
struct mpc_config_bus {
   unsigned char mpc_type ;
   unsigned char mpc_busid ;
   unsigned char mpc_bustype[6]  __attribute__((__packed__)) ;
};
struct mpc_config_ioapic {
   unsigned char mpc_type ;
   unsigned char mpc_apicid ;
   unsigned char mpc_apicver ;
   unsigned char mpc_flags ;
   unsigned long mpc_apicaddr ;
};
struct mpc_config_intsrc {
   unsigned char mpc_type ;
   unsigned char mpc_irqtype ;
   unsigned short mpc_irqflag ;
   unsigned char mpc_srcbus ;
   unsigned char mpc_srcbusirq ;
   unsigned char mpc_dstapic ;
   unsigned char mpc_dstirq ;
};
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
};
struct mpc_config_lintsrc {
   unsigned char mpc_type ;
   unsigned char mpc_irqtype ;
   unsigned short mpc_irqflag ;
   unsigned char mpc_srcbusid ;
   unsigned char mpc_srcbusirq ;
   unsigned char mpc_destapic ;
   unsigned char mpc_destapiclint ;
};
struct mp_config_oemtable {
   char oem_signature[4] ;
   unsigned short oem_length ;
   char oem_rev ;
   char oem_checksum ;
   char mpc_oem[8] ;
};
struct mpc_config_translation {
   unsigned char mpc_type ;
   unsigned char trans_len ;
   unsigned char trans_type ;
   unsigned char trans_quad ;
   unsigned char trans_global ;
   unsigned char trans_local ;
   unsigned short trans_reserved ;
};
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3,
    MP_BUS_MCA = 4,
    MP_BUS_NEC98 = 5
};
struct physid_mask {
   unsigned long mask[8] ;
};
typedef struct physid_mask physid_mask_t;
struct __anonstruct_bits_63 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_63 bits ;
};
struct __anonstruct_bits_64 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_64 bits ;
};
struct __anonstruct_bits_65 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_65 bits ;
};
struct __anonstruct_bits_66 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_66 bits ;
};
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
};
struct __anonstruct_physical_68 {
   __u32 __reserved_1 : 24 ;
   __u32 physical_dest : 4 ;
   __u32 __reserved_2 : 4 ;
};
struct __anonstruct_logical_69 {
   __u32 __reserved_1 : 24 ;
   __u32 logical_dest : 8 ;
};
union __anonunion_dest_67 {
   struct __anonstruct_physical_68 physical ;
   struct __anonstruct_logical_69 logical ;
};
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   union __anonunion_dest_67 dest ;
} __attribute__((__packed__)) ;
typedef int pm_request_t;
typedef int pm_dev_t;
enum __anonenum_70 {
    PM_SYS_UNKNOWN = 0,
    PM_SYS_KBC = 1104151299,
    PM_SYS_COM = 1104151808,
    PM_SYS_IRDA = 1104151824,
    PM_SYS_FDC = 1104152320,
    PM_SYS_VGA = 1104152832,
    PM_SYS_PCMCIA = 1104154112
};
struct pm_dev;
typedef int (*pm_callback)(struct pm_dev *dev , pm_request_t rqst , void *data );
struct pm_dev {
   pm_dev_t type ;
   unsigned long id ;
   int (*callback)(struct pm_dev *dev , pm_request_t rqst , void *data ) ;
   void *data ;
   unsigned long flags ;
   unsigned long state ;
   unsigned long prev_state ;
   struct list_head entry ;
};
typedef int suspend_state_t;
typedef int suspend_disk_method_t;
struct pm_ops {
   suspend_disk_method_t pm_disk_mode ;
   int (*prepare)(suspend_state_t state ) ;
   int (*enter)(suspend_state_t state ) ;
   int (*finish)(suspend_state_t state ) ;
};
struct device;
typedef u32 pm_message_t;
struct dev_pm_info {
   pm_message_t power_state ;
   pm_message_t prev_state ;
   void *saved_state ;
   atomic_t pm_users ;
   struct device *pm_parent ;
   struct list_head entry ;
};
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
struct kern_ipc_perm {
   spinlock_t lock ;
   int deleted ;
   key_t key ;
   uid_t uid ;
   gid_t gid ;
   uid_t cuid ;
   gid_t cgid ;
   mode_t mode ;
   unsigned long seq ;
   void *security ;
};
struct sem;
struct sem_queue;
struct sem_undo;
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
struct seminfo;
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
struct sem {
   int semval ;
   int sempid ;
};
struct sem_array {
   struct kern_ipc_perm sem_perm ;
   time_t sem_otime ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned long sem_nsems ;
};
struct sem_queue {
   struct sem_queue *next ;
   struct sem_queue **prev ;
   struct task_struct *sleeper ;
   struct sem_undo *undo ;
   int pid ;
   int status ;
   struct sem_array *sma ;
   int id ;
   struct sembuf *sops ;
   int nsops ;
   int alter ;
};
struct sem_undo {
   struct sem_undo *proc_next ;
   struct sem_undo *id_next ;
   int semid ;
   short *semadj ;
};
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct sem_undo *proc_list ;
};
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct siginfo;
typedef unsigned long old_sigset_t;
struct __anonstruct_sigset_t_71 {
   unsigned long sig[2] ;
};
typedef struct __anonstruct_sigset_t_71 sigset_t;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct old_sigaction {
   __sighandler_t sa_handler ;
   old_sigset_t sa_mask ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
typedef struct sigaltstack stack_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_73 {
   pid_t _pid ;
   uid_t _uid ;
};
struct __anonstruct__timer_74 {
   timer_t _tid ;
   int _overrun ;
   char _pad[(int )(sizeof(uid_t ) - sizeof(int ))] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_75 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_76 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
struct __anonstruct__sigfault_77 {
   void *_addr ;
};
struct __anonstruct__sigpoll_78 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_72 {
   int _pad[(int )((128U - 3U * sizeof(int )) / sizeof(int ))] ;
   struct __anonstruct__kill_73 _kill ;
   struct __anonstruct__timer_74 _timer ;
   struct __anonstruct__rt_75 _rt ;
   struct __anonstruct__sigchld_76 _sigchld ;
   struct __anonstruct__sigfault_77 _sigfault ;
   struct __anonstruct__sigpoll_78 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_72 _sifields ;
};
typedef struct siginfo siginfo_t;
struct __anonstruct__sigev_thread_80 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
union __anonunion__sigev_un_79 {
   int _pad[(int )((64U - (sizeof(int ) * 2U + sizeof(sigval_t ))) / sizeof(int ))] ;
   int _tid ;
   struct __anonstruct__sigev_thread_80 _sigev_thread ;
};
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_79 _sigev_un ;
};
typedef struct sigevent sigevent_t;
struct user_struct;
struct sigqueue {
   struct list_head list ;
   spinlock_t *lock ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct dentry;
struct vfsmount;
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct dentry *root ;
   struct dentry *pwd ;
   struct dentry *altroot ;
   struct vfsmount *rootmnt ;
   struct vfsmount *pwdmnt ;
   struct vfsmount *altrootmnt ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_TGID = 1,
    PIDTYPE_PGID = 2,
    PIDTYPE_SID = 3,
    PIDTYPE_MAX = 4
};
struct pid {
   int nr ;
   struct hlist_node pid_chain ;
   struct list_head pid_list ;
};
struct kmem_cache_s;
typedef struct kmem_cache_s kmem_cache_t;
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
struct free_area {
   struct list_head free_list ;
   unsigned long nr_free ;
};
struct pglist_data;
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct per_cpu_pages {
   int count ;
   int low ;
   int high ;
   int batch ;
   struct list_head list ;
};
struct per_cpu_pageset {
   struct per_cpu_pages pcp[2] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct page;
struct zone {
   unsigned long free_pages ;
   unsigned long pages_min ;
   unsigned long pages_low ;
   unsigned long pages_high ;
   unsigned long lowmem_reserve[3] ;
   struct per_cpu_pageset pageset[8] ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct list_head active_list ;
   struct list_head inactive_list ;
   unsigned long nr_scan_active ;
   unsigned long nr_scan_inactive ;
   unsigned long nr_active ;
   unsigned long nr_inactive ;
   unsigned long pages_scanned ;
   int all_unreclaimable ;
   int temp_priority ;
   int prev_priority ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_size ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   struct page *zone_mem_map ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char *name ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct zonelist {
   struct zone *zones[4] ;
};
struct bootmem_data;
struct pglist_data {
   struct zone node_zones[3] ;
   struct zonelist node_zonelists[3] ;
   int nr_zones ;
   struct page *node_mem_map ;
   struct bootmem_data *bdata ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   struct pglist_data *pgdat_next ;
   wait_queue_head_t kswapd_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
};
typedef struct pglist_data pg_data_t;
struct ctl_table;
struct file;
struct vm_area_struct;
struct cache_sizes {
   size_t cs_size ;
   kmem_cache_t *cs_cachep ;
   kmem_cache_t *cs_dmacachep ;
};
struct percpu_data {
   void *ptrs[8] ;
   void *blkp ;
};
struct __anonstruct_seccomp_t_81 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_81 seccomp_t;
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct tvec_t_base_s;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   spinlock_t lock ;
   unsigned long magic ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_t_base_s *base ;
};
struct sched_param {
   int sched_priority ;
};
typedef struct task_struct task_t;
struct namespace;
struct workqueue_struct;
struct work_struct {
   unsigned long pending ;
   struct list_head entry ;
   void (*func)(void * ) ;
   void *data ;
   void *wq_data ;
   struct timer_list timer ;
};
typedef unsigned long aio_context_t;
enum __anonenum_82 {
    IOCB_CMD_PREAD = 0,
    IOCB_CMD_PWRITE = 1,
    IOCB_CMD_FSYNC = 2,
    IOCB_CMD_FDSYNC = 3,
    IOCB_CMD_NOOP = 6
};
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
struct iocb {
   __u64 aio_data ;
   __u32 aio_key ;
   __u32 aio_reserved1 ;
   __u16 aio_lio_opcode ;
   __s16 aio_reqprio ;
   __u32 aio_fildes ;
   __u64 aio_buf ;
   __u64 aio_nbytes ;
   __s64 aio_offset ;
   __u64 aio_reserved2 ;
   __u64 aio_reserved3 ;
};
struct kioctx;
union __anonunion_ki_obj_83 {
   void *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   struct list_head ki_list ;
   union __anonunion_ki_obj_83 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   wait_queue_t ki_wait ;
   long ki_retried ;
   long ki_kicked ;
   long ki_queued ;
   void *private ;
};
struct aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct io_event io_events[0] ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct kioctx *next ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct work_struct wq ;
};
typedef unsigned long mm_counter_t;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct vm_area_struct *area ) ;
   unsigned long mmap_base ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   mm_counter_t _rss ;
   mm_counter_t _anon_rss ;
   unsigned long saved_auxv[42] ;
   unsigned int dumpable : 1 ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned long swap_token_time ;
   char recent_pagein ;
   int core_waiters ;
   struct completion *core_startup_done ;
   struct completion core_done ;
   rwlock_t ioctx_list_lock ;
   struct kioctx *ioctx_list ;
   struct kioctx default_kioctx ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
};
struct tty_struct;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   task_t *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   struct task_struct *group_exit_task ;
   int notify_count ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct timer_list real_timer ;
   unsigned long it_real_value ;
   unsigned long it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   pid_t pgrp ;
   pid_t tty_old_pgrp ;
   pid_t session ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long long sched_time ;
   struct rlimit rlim[15] ;
   struct list_head cpu_timers[3] ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct list_head uidhash_list ;
   uid_t uid ;
};
struct prio_array;
typedef struct prio_array prio_array_t;
struct backing_dev_info;
struct reclaim_state;
enum idle_type {
    SCHED_IDLE = 0,
    NOT_IDLE = 1,
    NEWLY_IDLE = 2,
    MAX_IDLE_TYPES = 3
};
struct sched_group {
   struct sched_group *next ;
   cpumask_t cpumask ;
   unsigned long cpu_power ;
};
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_group *groups ;
   cpumask_t span ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned long long cache_hot_time ;
   unsigned int cache_nice_tries ;
   unsigned int per_cpu_gain ;
   int flags ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
};
struct io_context;
struct cpuset;
struct group_info {
   int ngroups ;
   atomic_t usage ;
   gid_t small_block[32] ;
   int nblocks ;
   gid_t *blocks[0] ;
};
struct audit_context;
struct mempolicy;
struct linux_binfmt;
struct files_struct;
struct task_struct {
   long volatile   state ;
   struct thread_info *thread_info ;
   atomic_t usage ;
   unsigned long flags ;
   unsigned long ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   struct list_head run_list ;
   prio_array_t *array ;
   unsigned long sleep_avg ;
   unsigned long long timestamp ;
   unsigned long long last_ran ;
   unsigned long long sched_time ;
   int activated ;
   unsigned long policy ;
   cpumask_t cpus_allowed ;
   unsigned int time_slice ;
   unsigned int first_time_slice ;
   struct list_head tasks ;
   struct list_head ptrace_children ;
   struct list_head ptrace_list ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   long exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct pid pids[4] ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   unsigned long rt_priority ;
   cputime_t utime ;
   cputime_t stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   unsigned long long it_sched_expires ;
   struct list_head cpu_timers[3] ;
   uid_t uid ;
   uid_t euid ;
   uid_t suid ;
   uid_t fsuid ;
   gid_t gid ;
   gid_t egid ;
   gid_t sgid ;
   gid_t fsgid ;
   struct group_info *group_info ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   unsigned int keep_capabilities : 1 ;
   struct user_struct *user ;
   int oomkilladj ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct namespace *namespace ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   void *security ;
   struct audit_context *audit_context ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t proc_lock ;
   spinlock_t switch_lock ;
   void *journal_info ;
   struct reclaim_state *reclaim_state ;
   struct dentry *proc_dentry ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   wait_queue_t *io_wait ;
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   clock_t acct_stimexpd ;
};
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[(int )(8192U / sizeof(long ))] ;
};
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned long st_size ;
   unsigned long st_atime ;
   unsigned long st_mtime ;
   unsigned long st_ctime ;
};
struct stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned long st_rdev ;
   unsigned long st_size ;
   unsigned long st_blksize ;
   unsigned long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct stat64 {
   unsigned long long st_dev ;
   unsigned char __pad0[4] ;
   unsigned long __st_ino ;
   unsigned int st_mode ;
   unsigned int st_nlink ;
   unsigned long st_uid ;
   unsigned long st_gid ;
   unsigned long long st_rdev ;
   unsigned char __pad3[4] ;
   long long st_size ;
   unsigned long st_blksize ;
   unsigned long st_blocks ;
   unsigned long __pad4 ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned int st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   unsigned long long st_ino ;
};
struct kstat {
   unsigned long ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long blocks ;
};
struct user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
struct user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
struct user_regs_struct {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   unsigned short ds ;
   unsigned short __ds ;
   unsigned short es ;
   unsigned short __es ;
   unsigned short fs ;
   unsigned short __fs ;
   unsigned short gs ;
   unsigned short __gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __cs ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ss ;
};
struct user_pt_regs;
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   struct user_pt_regs *u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   int u_debugreg[8] ;
};
struct oldold_utsname {
   char sysname[9] ;
   char nodename[9] ;
   char release[9] ;
   char version[9] ;
   char machine[9] ;
};
struct old_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
};
struct new_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
typedef unsigned long elf_greg_t;
typedef elf_greg_t elf_gregset_t[(int )(sizeof(struct user_regs_struct ) / sizeof(elf_greg_t ))];
typedef struct user_i387_struct elf_fpregset_t;
typedef struct user_fxsr_struct elf_fpxregset_t;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Off;
typedef __s32 Elf32_Sword;
typedef __u32 Elf32_Word;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s16 Elf64_SHalf;
typedef __u64 Elf64_Off;
typedef __s32 Elf64_Sword;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef __s64 Elf64_Sxword;
union __anonunion_d_un_84 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_84 d_un ;
};
typedef struct dynamic Elf32_Dyn;
union __anonunion_d_un_86 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
struct __anonstruct_Elf64_Dyn_85 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_86 d_un ;
};
typedef struct __anonstruct_Elf64_Dyn_85 Elf64_Dyn;
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
typedef struct elf32_rel Elf32_Rel;
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
typedef struct elf64_rel Elf64_Rel;
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
typedef struct elf32_rela Elf32_Rela;
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
typedef struct elf64_rela Elf64_Rela;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
typedef struct elf32_hdr Elf32_Ehdr;
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
typedef struct elf64_hdr Elf64_Ehdr;
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
typedef struct elf32_phdr Elf32_Phdr;
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
typedef struct elf64_phdr Elf64_Phdr;
struct __anonstruct_Elf32_Shdr_87 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
typedef struct __anonstruct_Elf32_Shdr_87 Elf32_Shdr;
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
typedef struct elf64_shdr Elf64_Shdr;
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
typedef struct elf32_note Elf32_Nhdr;
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
typedef struct elf64_note Elf64_Nhdr;
struct kobject;
struct module;
struct attribute {
   char *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char *name ;
   struct attribute **attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , char * , loff_t  , size_t  ) ;
   ssize_t (*write)(struct kobject * , char * , loff_t  , size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct sysfs_dirent {
   atomic_t s_count ;
   struct list_head s_sibling ;
   struct list_head s_children ;
   void *s_element ;
   int s_type ;
   umode_t s_mode ;
   struct dentry *s_dentry ;
};
struct kref {
   atomic_t refcount ;
};
typedef int kobject_action_t;
enum kobject_action {
    KOBJ_ADD = 1,
    KOBJ_REMOVE = 2,
    KOBJ_CHANGE = 3,
    KOBJ_MOUNT = 4,
    KOBJ_UMOUNT = 5,
    KOBJ_OFFLINE = 6,
    KOBJ_ONLINE = 7
};
struct kset;
struct kobj_type;
struct kobject {
   char *k_name ;
   char name[20] ;
   struct kref kref ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct dentry *dentry ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kset_hotplug_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*hotplug)(struct kset *kset , struct kobject *kobj , char **envp , int num_envp ,
                  char *buffer , int buffer_size ) ;
};
struct subsystem;
struct kset {
   struct subsystem *subsys ;
   struct kobj_type *ktype ;
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_hotplug_ops *hotplug_ops ;
};
struct subsystem {
   struct kset kset ;
   struct rw_semaphore rwsem ;
};
struct subsys_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct subsystem * , char * ) ;
   ssize_t (*store)(struct subsystem * , char const   * , size_t  ) ;
};
struct kernel_param;
typedef int (*param_set_fn)(char const   *val , struct kernel_param *kp );
typedef int (*param_get_fn)(char *buffer , struct kernel_param *kp );
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   void *arg ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
struct __anonstruct_local_t_88 {
   unsigned long volatile   counter ;
};
typedef struct __anonstruct_local_t_88 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct modversion_info {
   unsigned long crc ;
   char name[(int )(64U - sizeof(unsigned long ))] ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
};
struct exception_table_entry;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
};
struct module_sect_attr {
   struct module_attribute mattr ;
   char name[32] ;
   unsigned long address ;
};
struct module_sect_attrs {
   struct attribute_group grp ;
   struct module_sect_attr attrs[0] ;
};
struct module_param_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[(int )(64U - sizeof(unsigned long ))] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct kernel_symbol  const  *syms ;
   unsigned int num_syms ;
   unsigned long const   *crcs ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned int num_gpl_syms ;
   unsigned long const   *gpl_crcs ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned long init_size ;
   unsigned long core_size ;
   unsigned long init_text_size ;
   unsigned long core_text_size ;
   struct mod_arch_specific arch ;
   int unsafe ;
   int license_gplok ;
   Elf32_Sym *symtab ;
   unsigned long num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   void *percpu ;
   char *args ;
};
struct device_driver;
struct obsolete_modparm {
   char name[64] ;
   char type[(int )(64U - sizeof(void *))] ;
   void *addr ;
};
struct flock {
   short l_type ;
   short l_whence ;
   off_t l_start ;
   off_t l_len ;
   pid_t l_pid ;
};
struct flock64 {
   short l_type ;
   short l_whence ;
   loff_t l_start ;
   loff_t l_len ;
   pid_t l_pid ;
};
struct hw_interrupt_type {
   char const   *typename ;
   unsigned int (*startup)(unsigned int irq ) ;
   void (*shutdown)(unsigned int irq ) ;
   void (*enable)(unsigned int irq ) ;
   void (*disable)(unsigned int irq ) ;
   void (*ack)(unsigned int irq ) ;
   void (*end)(unsigned int irq ) ;
   void (*set_affinity)(unsigned int irq , cpumask_t dest ) ;
};
typedef struct hw_interrupt_type hw_irq_controller;
struct irqaction;
struct irq_desc {
   hw_irq_controller *handler ;
   void *handler_data ;
   struct irqaction *action ;
   unsigned int status ;
   unsigned int depth ;
   unsigned int irq_count ;
   unsigned int irqs_unhandled ;
   spinlock_t lock ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct irq_desc irq_desc_t;
struct proc_dir_entry;
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
};
struct __anonstruct_irq_cpustat_t_89 {
   unsigned int __softirq_pending ;
   unsigned long idle_timestamp ;
   unsigned int __nmi_count ;
   unsigned int apic_timer_irqs ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct __anonstruct_irq_cpustat_t_89 irq_cpustat_t;
typedef int irqreturn_t;
struct irqaction {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   unsigned long flags ;
   cpumask_t mask ;
   char const   *name ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   struct proc_dir_entry *dir ;
};
enum __anonenum_90 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    SCSI_SOFTIRQ = 4,
    TASKLET_SOFTIRQ = 5
};
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
   void *data ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
enum __anonenum_91 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
};
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
struct sockaddr;
struct __kernel_sockaddr_storage {
   unsigned short ss_family ;
   char __data[(int )(128U - sizeof(unsigned short ))] ;
} __attribute__((__aligned__(__alignof__(struct sockaddr *)))) ;
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct linger {
   int l_onoff ;
   int l_linger ;
};
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
struct cmsghdr {
   __kernel_size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
};
struct ucred {
   __u32 pid ;
   __u32 uid ;
   __u32 gid ;
};
enum __anonenum_92 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_IPV6 = 41,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256
};
struct in_addr {
   __u32 s_addr ;
};
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
struct ip_mreq_source {
   __u32 imr_multiaddr ;
   __u32 imr_interface ;
   __u32 imr_sourceaddr ;
};
struct ip_msfilter {
   __u32 imsf_multiaddr ;
   __u32 imsf_interface ;
   __u32 imsf_fmode ;
   __u32 imsf_numsrc ;
   __u32 imsf_slist[1] ;
};
struct group_req {
   __u32 gr_interface ;
   struct __kernel_sockaddr_storage gr_group ;
};
struct group_source_req {
   __u32 gsr_interface ;
   struct __kernel_sockaddr_storage gsr_group ;
   struct __kernel_sockaddr_storage gsr_source ;
};
struct group_filter {
   __u32 gf_interface ;
   struct __kernel_sockaddr_storage gf_group ;
   __u32 gf_fmode ;
   __u32 gf_numsrc ;
   struct __kernel_sockaddr_storage gf_slist[1] ;
};
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   unsigned short sin_port ;
   struct in_addr sin_addr ;
   unsigned char __pad[(int )(((16U - sizeof(short )) - sizeof(unsigned short )) -
                              sizeof(struct in_addr ))] ;
};
struct vm_struct {
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   unsigned long phys_addr ;
   struct vm_struct *next ;
};
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
struct __large_struct {
   unsigned long buf[100] ;
};
struct __anonstruct_sync_serial_settings_93 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_93 sync_serial_settings;
struct __anonstruct_te1_settings_94 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_94 te1_settings;
struct __anonstruct_raw_hdlc_proto_95 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_95 raw_hdlc_proto;
struct __anonstruct_fr_proto_96 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_96 fr_proto;
struct __anonstruct_fr_proto_pvc_97 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_97 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_98 {
   unsigned int dlci ;
   char master[16] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_98 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_99 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_99 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_100 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_100 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_101 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_102 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_101 ifr_ifrn ;
   union __anonunion_ifr_ifru_102 ifr_ifru ;
};
union __anonunion_ifc_ifcu_103 {
   char *ifcu_buf ;
   struct ifreq *ifcu_req ;
};
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_103 ifc_ifcu ;
};
struct ethhdr {
   unsigned char h_dest[6] ;
   unsigned char h_source[6] ;
   unsigned short h_proto ;
} __attribute__((__packed__)) ;
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
struct prio_tree_iter {
   struct prio_tree_node *cur ;
   unsigned long mask ;
   unsigned long value ;
   int size_level ;
   struct prio_tree_root *root ;
   unsigned long r_index ;
   unsigned long h_index ;
};
struct files_stat_struct {
   int nr_files ;
   int nr_free_files ;
   int max_files ;
};
struct inodes_stat_t {
   int nr_inodes ;
   int nr_unused ;
   int dummy[5] ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
struct rcu_ctrlblk {
   long cur ;
   long completed ;
   int next_pending ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct rcu_data {
   long quiescbatch ;
   int passed_quiesc ;
   int qs_pending ;
   long batch ;
   struct rcu_head *nxtlist ;
   struct rcu_head **nxttail ;
   struct rcu_head *curlist ;
   struct rcu_head **curtail ;
   struct rcu_head *donelist ;
   struct rcu_head **donetail ;
   int cpu ;
};
struct nameidata;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
struct dentry_stat_t {
   int nr_dentry ;
   int nr_unused ;
   int age_limit ;
   int want_pages ;
   int dummy[2] ;
};
struct dcookie_struct;
struct inode;
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   struct inode *d_inode ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   struct rcu_head d_rcu ;
   struct dcookie_struct *d_cookie ;
   struct hlist_node d_hash ;
   int d_mounted ;
   unsigned char d_iname[36] ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   int gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct buffer_head;
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
typedef int get_blocks_t(struct inode *inode , sector_t iblock , unsigned long max_blocks ,
                         struct buffer_head *bh_result , int create );
typedef void dio_iodone_t(struct inode *inode , loff_t offset , ssize_t bytes , void *private );
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   unsigned int ia_attr_flags ;
};
typedef __kernel_uid32_t qid_t;
typedef __u64 qsize_t;
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
typedef struct fs_disk_quota fs_disk_quota_t;
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
typedef struct fs_quota_stat fs_quota_stat_t;
struct v1_mem_dqinfo {

};
struct v2_mem_dqinfo {
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
};
struct mem_dqblk {
   __u32 dqb_bhardlimit ;
   __u32 dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   __u32 dqb_ihardlimit ;
   __u32 dqb_isoftlimit ;
   __u32 dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
union __anonunion_u_104 {
   struct v1_mem_dqinfo v1_i ;
   struct v2_mem_dqinfo v2_i ;
};
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   union __anonunion_u_104 u ;
};
struct dqstats {
   int lookups ;
   int drops ;
   int reads ;
   int writes ;
   int cache_hits ;
   int allocated_dquots ;
   int free_dquots ;
   int syncs ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct semaphore dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , unsigned long  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , unsigned long  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct semaphore dqio_sem ;
   struct semaphore dqonoff_sem ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct vfsmount *mnt[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
struct address_space;
struct writeback_control;
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*prepare_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   int (*commit_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   int (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , int  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   rwlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   int bd_openers ;
   struct semaphore bd_sem ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
};
struct inode_operations;
struct file_operations;
struct file_lock;
struct cdev;
struct dnotify_struct;
union __anonunion_u_105 {
   void *generic_ip ;
};
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   umode_t i_mode ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   unsigned long i_blksize ;
   unsigned long i_version ;
   unsigned long i_blocks ;
   unsigned short i_bytes ;
   spinlock_t i_lock ;
   struct semaphore i_sem ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations *i_op ;
   struct file_operations *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   union __anonunion_u_105 u ;
   seqcount_t i_size_seqcount ;
};
struct fown_struct {
   rwlock_t lock ;
   int pid ;
   uid_t uid ;
   uid_t euid ;
   void *security ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned long size ;
   unsigned long flags ;
   unsigned long cache_hit ;
   unsigned long prev_page ;
   unsigned long ahead_start ;
   unsigned long ahead_size ;
   unsigned long ra_pages ;
   unsigned long mmap_hit ;
   unsigned long mmap_miss ;
};
struct file {
   struct list_head f_list ;
   struct dentry *f_dentry ;
   struct vfsmount *f_vfsmnt ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   int f_error ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   unsigned int f_uid ;
   unsigned int f_gid ;
   struct file_ra_state f_ra ;
   size_t f_maxcount ;
   unsigned long f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_insert)(struct file_lock * ) ;
   void (*fl_remove)(struct file_lock * ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
typedef u32 rpc_authflavor_t;
enum rpc_auth_flavors {
    RPC_AUTH_NULL = 0,
    RPC_AUTH_UNIX = 1,
    RPC_AUTH_SHORT = 2,
    RPC_AUTH_DES = 3,
    RPC_AUTH_KRB = 4,
    RPC_AUTH_GSS = 6,
    RPC_AUTH_MAXFLAVOR = 8,
    RPC_AUTH_GSS_KRB5 = 390003,
    RPC_AUTH_GSS_KRB5I = 390004,
    RPC_AUTH_GSS_KRB5P = 390005,
    RPC_AUTH_GSS_LKEY = 390006,
    RPC_AUTH_GSS_LKEYI = 390007,
    RPC_AUTH_GSS_LKEYP = 390008,
    RPC_AUTH_GSS_SPKM = 390009,
    RPC_AUTH_GSS_SPKMI = 390010,
    RPC_AUTH_GSS_SPKMP = 390011
};
enum rpc_msg_type {
    RPC_CALL = 0,
    RPC_REPLY = 1
};
enum rpc_reply_stat {
    RPC_MSG_ACCEPTED = 0,
    RPC_MSG_DENIED = 1
};
enum rpc_accept_stat {
    RPC_SUCCESS = 0,
    RPC_PROG_UNAVAIL = 1,
    RPC_PROG_MISMATCH = 2,
    RPC_PROC_UNAVAIL = 3,
    RPC_GARBAGE_ARGS = 4,
    RPC_SYSTEM_ERR = 5
};
enum rpc_reject_stat {
    RPC_MISMATCH = 0,
    RPC_AUTH_ERROR = 1
};
enum rpc_auth_stat {
    RPC_AUTH_OK = 0,
    RPC_AUTH_BADCRED = 1,
    RPC_AUTH_REJECTEDCRED = 2,
    RPC_AUTH_BADVERF = 3,
    RPC_AUTH_REJECTEDVERF = 4,
    RPC_AUTH_TOOWEAK = 5,
    RPCSEC_GSS_CREDPROBLEM = 13,
    RPCSEC_GSS_CTXPROBLEM = 14
};
enum nfs_stat {
    NFS_OK = 0,
    NFSERR_PERM = 1,
    NFSERR_NOENT = 2,
    NFSERR_IO = 5,
    NFSERR_NXIO = 6,
    NFSERR_EAGAIN = 11,
    NFSERR_ACCES = 13,
    NFSERR_EXIST = 17,
    NFSERR_XDEV = 18,
    NFSERR_NODEV = 19,
    NFSERR_NOTDIR = 20,
    NFSERR_ISDIR = 21,
    NFSERR_INVAL = 22,
    NFSERR_FBIG = 27,
    NFSERR_NOSPC = 28,
    NFSERR_ROFS = 30,
    NFSERR_MLINK = 31,
    NFSERR_OPNOTSUPP = 45,
    NFSERR_NAMETOOLONG = 63,
    NFSERR_NOTEMPTY = 66,
    NFSERR_DQUOT = 69,
    NFSERR_STALE = 70,
    NFSERR_REMOTE = 71,
    NFSERR_WFLUSH = 99,
    NFSERR_BADHANDLE = 10001,
    NFSERR_NOT_SYNC = 10002,
    NFSERR_BAD_COOKIE = 10003,
    NFSERR_NOTSUPP = 10004,
    NFSERR_TOOSMALL = 10005,
    NFSERR_SERVERFAULT = 10006,
    NFSERR_BADTYPE = 10007,
    NFSERR_JUKEBOX = 10008,
    NFSERR_SAME = 10009,
    NFSERR_DENIED = 10010,
    NFSERR_EXPIRED = 10011,
    NFSERR_LOCKED = 10012,
    NFSERR_GRACE = 10013,
    NFSERR_FHEXPIRED = 10014,
    NFSERR_SHARE_DENIED = 10015,
    NFSERR_WRONGSEC = 10016,
    NFSERR_CLID_INUSE = 10017,
    NFSERR_RESOURCE = 10018,
    NFSERR_MOVED = 10019,
    NFSERR_NOFILEHANDLE = 10020,
    NFSERR_MINOR_VERS_MISMATCH = 10021,
    NFSERR_STALE_CLIENTID = 10022,
    NFSERR_STALE_STATEID = 10023,
    NFSERR_OLD_STATEID = 10024,
    NFSERR_BAD_STATEID = 10025,
    NFSERR_BAD_SEQID = 10026,
    NFSERR_NOT_SAME = 10027,
    NFSERR_LOCK_RANGE = 10028,
    NFSERR_SYMLINK = 10029,
    NFSERR_RESTOREFH = 10030,
    NFSERR_LEASE_MOVED = 10031,
    NFSERR_ATTRNOTSUPP = 10032,
    NFSERR_NO_GRACE = 10033,
    NFSERR_RECLAIM_BAD = 10034,
    NFSERR_RECLAIM_CONFLICT = 10035,
    NFSERR_BAD_XDR = 10036,
    NFSERR_LOCKS_HELD = 10037,
    NFSERR_OPENMODE = 10038,
    NFSERR_BADOWNER = 10039,
    NFSERR_BADCHAR = 10040,
    NFSERR_BADNAME = 10041,
    NFSERR_BAD_RANGE = 10042,
    NFSERR_LOCK_NOTSUPP = 10043,
    NFSERR_OP_ILLEGAL = 10044,
    NFSERR_DEADLOCK = 10045,
    NFSERR_FILE_OPEN = 10046,
    NFSERR_ADMIN_REVOKED = 10047,
    NFSERR_CB_PATH_DOWN = 10048,
    NFSERR_REPLAY_ME = 10049
};
enum nfs_ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5,
    NFSOCK = 6,
    NFBAD = 7,
    NFFIFO = 8
};
struct nfs_fh {
   unsigned short size ;
   unsigned char data[128] ;
};
enum nfs3_stable_how {
    NFS_UNSTABLE = 0,
    NFS_DATA_SYNC = 1,
    NFS_FILE_SYNC = 2
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   u32 flags ;
   struct nlm_lockowner *owner ;
};
struct fasync_struct;
union __anonunion_fl_u_106 {
   struct nfs_lock_info nfs_fl ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_pid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_106 fl_u ;
};
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
struct file_system_type;
struct super_operations;
struct export_operations;
struct xattr_handler;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned long s_old_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct semaphore s_lock ;
   int s_count ;
   int s_syncing ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct block_device *s_bdev ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   struct semaphore s_vfs_rename_sem ;
   u32 s_time_gran ;
};
enum __anonenum_107 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_TRANS = 2
};
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , ino_t  , unsigned int  );
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   struct module *owner ;
};
union __anonunion_arg_109 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_108 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_109 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_108 read_descriptor_t;
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , char * , size_t  , loff_t  ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_write)(struct kiocb * , char const   * , size_t  , loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
};
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   int (*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  , struct nameidata * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
};
struct seq_file;
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*read_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*put_inode)(struct inode * ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   void (*write_super_lockfs)(struct super_block * ) ;
   void (*unlockfs)(struct super_block * ) ;
   int (*statfs)(struct super_block * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
};
struct export_operations {
   struct dentry *(*decode_fh)(struct super_block *sb , __u32 *fh , int fh_len , int fh_type ,
                               int (*acceptable)(void *context , struct dentry *de ) ,
                               void *context ) ;
   int (*encode_fh)(struct dentry *de , __u32 *fh , int *max_len , int connectable ) ;
   int (*get_name)(struct dentry *parent , char *name , struct dentry *child ) ;
   struct dentry *(*get_parent)(struct dentry *child ) ;
   struct dentry *(*get_dentry)(struct super_block *sb , void *inump ) ;
   struct dentry *(*find_exported_dentry)(struct super_block *sb , void *obj , void *parent ,
                                          int (*acceptable)(void *context , struct dentry *de ) ,
                                          void *context ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct super_block *(*get_sb)(struct file_system_type * , int  , char const   * ,
                                 void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
};
struct bio;
enum __anonenum_110 {
    DIO_LOCKING = 1,
    DIO_NO_LOCKING = 2,
    DIO_OWN_LOCKING = 3
};
struct tree_descr {
   char *name ;
   struct file_operations *ops ;
   int mode ;
};
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
struct anon_vma;
struct __anonstruct_pud_t_111 {
   pgd_t pgd ;
};
typedef struct __anonstruct_pud_t_111 pud_t;
struct __anonstruct_vm_set_113 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_112 {
   struct __anonstruct_vm_set_113 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct vm_operations_struct;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_112 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
struct vm_list_struct {
   struct vm_list_struct *next ;
   struct vm_area_struct *vma ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   struct page *(*nopage)(struct vm_area_struct *area , unsigned long address , int *type ) ;
   int (*populate)(struct vm_area_struct *area , unsigned long address , unsigned long len ,
                   pgprot_t prot , unsigned long pgoff , int nonblock ) ;
};
struct mmu_gather;
typedef unsigned long page_flags_t;
struct page {
   page_flags_t flags ;
   atomic_t _count ;
   atomic_t _mapcount ;
   unsigned long private ;
   struct address_space *mapping ;
   unsigned long index ;
   struct list_head lru ;
};
struct page_state {
   unsigned long nr_dirty ;
   unsigned long nr_writeback ;
   unsigned long nr_unstable ;
   unsigned long nr_page_table_pages ;
   unsigned long nr_mapped ;
   unsigned long nr_slab ;
   unsigned long pgpgin ;
   unsigned long pgpgout ;
   unsigned long pswpin ;
   unsigned long pswpout ;
   unsigned long pgalloc_high ;
   unsigned long pgalloc_normal ;
   unsigned long pgalloc_dma ;
   unsigned long pgfree ;
   unsigned long pgactivate ;
   unsigned long pgdeactivate ;
   unsigned long pgfault ;
   unsigned long pgmajfault ;
   unsigned long pgrefill_high ;
   unsigned long pgrefill_normal ;
   unsigned long pgrefill_dma ;
   unsigned long pgsteal_high ;
   unsigned long pgsteal_normal ;
   unsigned long pgsteal_dma ;
   unsigned long pgscan_kswapd_high ;
   unsigned long pgscan_kswapd_normal ;
   unsigned long pgscan_kswapd_dma ;
   unsigned long pgscan_direct_high ;
   unsigned long pgscan_direct_normal ;
   unsigned long pgscan_direct_dma ;
   unsigned long pginodesteal ;
   unsigned long slabs_scanned ;
   unsigned long kswapd_steal ;
   unsigned long kswapd_inodesteal ;
   unsigned long pageoutrun ;
   unsigned long allocstall ;
   unsigned long pgrotated ;
   unsigned long nr_bounce ;
};
struct zap_details {
   struct vm_area_struct *nonlinear_vma ;
   struct address_space *check_mapping ;
   unsigned long first_index ;
   unsigned long last_index ;
   spinlock_t *i_mmap_lock ;
   unsigned long truncate_count ;
};
typedef int (*shrinker_t)(int nr_to_scan , unsigned int gfp_mask );
struct shrinker;
struct tlb_state {
   struct mm_struct *active_mm ;
   int state ;
   char __cacheline_padding[24] ;
};
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
typedef void (*poll_queue_proc)(struct file * , wait_queue_head_t * , struct poll_table_struct * );
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
typedef struct poll_table_struct poll_table;
struct poll_table_page;
struct poll_wqueues {
   poll_table pt ;
   struct poll_table_page *table ;
   int error ;
};
struct __anonstruct_fd_set_bits_114 {
   unsigned long *in ;
   unsigned long *out ;
   unsigned long *ex ;
   unsigned long *res_in ;
   unsigned long *res_out ;
   unsigned long *res_ex ;
};
typedef struct __anonstruct_fd_set_bits_114 fd_set_bits;
enum __anonenum_socket_state_115 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};
typedef enum __anonenum_socket_state_115 socket_state;
enum sock_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_PACKET = 10
};
struct proto_ops;
struct sock;
struct socket {
   socket_state state ;
   unsigned long flags ;
   struct proto_ops *ops ;
   struct fasync_struct *fasync_list ;
   struct file *file ;
   struct sock *sk ;
   wait_queue_head_t wait ;
   short type ;
};
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *sock ) ;
   int (*bind)(struct socket *sock , struct sockaddr *myaddr , int sockaddr_len ) ;
   int (*connect)(struct socket *sock , struct sockaddr *vaddr , int sockaddr_len ,
                  int flags ) ;
   int (*socketpair)(struct socket *sock1 , struct socket *sock2 ) ;
   int (*accept)(struct socket *sock , struct socket *newsock , int flags ) ;
   int (*getname)(struct socket *sock , struct sockaddr *addr , int *sockaddr_len ,
                  int peer ) ;
   unsigned int (*poll)(struct file *file , struct socket *sock , struct poll_table_struct *wait ) ;
   int (*ioctl)(struct socket *sock , unsigned int cmd , unsigned long arg ) ;
   int (*listen)(struct socket *sock , int len ) ;
   int (*shutdown)(struct socket *sock , int flags ) ;
   int (*setsockopt)(struct socket *sock , int level , int optname , char *optval ,
                     int optlen ) ;
   int (*getsockopt)(struct socket *sock , int level , int optname , char *optval ,
                     int *optlen ) ;
   int (*sendmsg)(struct kiocb *iocb , struct socket *sock , struct msghdr *m , size_t total_len ) ;
   int (*recvmsg)(struct kiocb *iocb , struct socket *sock , struct msghdr *m , size_t total_len ,
                  int flags ) ;
   int (*mmap)(struct file *file , struct socket *sock , struct vm_area_struct *vma ) ;
   ssize_t (*sendpage)(struct socket *sock , struct page *page , int offset , size_t size ,
                       int flags ) ;
};
struct net_proto_family {
   int family ;
   int (*create)(struct socket *sock , int protocol ) ;
   short authentication ;
   short encryption ;
   short encrypt_net ;
   struct module *owner ;
};
union __anonunion_in6_u_116 {
   __u8 u6_addr8[16] ;
   __u16 u6_addr16[8] ;
   __u32 u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion_in6_u_116 in6_u ;
};
struct sockaddr_in6 {
   unsigned short sin6_family ;
   __u16 sin6_port ;
   __u32 sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   __u32 sin6_scope_id ;
};
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   int ipv6mr_ifindex ;
};
struct in6_flowlabel_req {
   struct in6_addr flr_dst ;
   __u32 flr_label ;
   __u8 flr_action ;
   __u8 flr_share ;
   __u16 flr_flags ;
   __u16 flr_expires ;
   __u16 flr_linger ;
   __u32 __flr_pad ;
};
struct net_device;
struct nf_conntrack {
   atomic_t use ;
   void (*destroy)(struct nf_conntrack * ) ;
};
struct nf_bridge_info {
   atomic_t use ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   struct net_device *netoutdev ;
   unsigned int mask ;
   unsigned long data[(int )(32U / sizeof(unsigned long ))] ;
};
struct sk_buff;
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
struct skb_frag_struct;
typedef struct skb_frag_struct skb_frag_t;
struct skb_frag_struct {
   struct page *page ;
   __u16 page_offset ;
   __u16 size ;
};
struct skb_shared_info {
   atomic_t dataref ;
   unsigned int nr_frags ;
   unsigned short tso_size ;
   unsigned short tso_segs ;
   struct sk_buff *frag_list ;
   skb_frag_t frags[18] ;
};
struct tcphdr;
struct udphdr;
struct icmphdr;
struct igmphdr;
struct iphdr;
struct ipv6hdr;
union __anonunion_h_117 {
   struct tcphdr *th ;
   struct udphdr *uh ;
   struct icmphdr *icmph ;
   struct igmphdr *igmph ;
   struct iphdr *ipiph ;
   struct ipv6hdr *ipv6h ;
   unsigned char *raw ;
};
struct arphdr;
union __anonunion_nh_118 {
   struct iphdr *iph ;
   struct ipv6hdr *ipv6h ;
   struct arphdr *arph ;
   unsigned char *raw ;
};
union __anonunion_mac_119 {
   unsigned char *raw ;
};
struct dst_entry;
struct sec_path;
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   struct sk_buff_head *list ;
   struct sock *sk ;
   struct timeval stamp ;
   struct net_device *dev ;
   struct net_device *input_dev ;
   struct net_device *real_dev ;
   union __anonunion_h_117 h ;
   union __anonunion_nh_118 nh ;
   union __anonunion_mac_119 mac ;
   struct dst_entry *dst ;
   struct sec_path *sp ;
   char cb[40] ;
   unsigned int len ;
   unsigned int data_len ;
   unsigned int mac_len ;
   unsigned int csum ;
   unsigned char local_df ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char pkt_type ;
   unsigned char ip_summed ;
   __u32 priority ;
   unsigned short protocol ;
   unsigned short security ;
   void (*destructor)(struct sk_buff *skb ) ;
   unsigned long nfmark ;
   __u32 nfcache ;
   __u32 nfctinfo ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   __u32 tc_index ;
   unsigned int truesize ;
   atomic_t users ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned char *tail ;
   unsigned char *end ;
};
struct sockaddr_pkt {
   unsigned short spkt_family ;
   unsigned char spkt_device[14] ;
   unsigned short spkt_protocol ;
};
struct sockaddr_ll {
   unsigned short sll_family ;
   unsigned short sll_protocol ;
   int sll_ifindex ;
   unsigned short sll_hatype ;
   unsigned char sll_pkttype ;
   unsigned char sll_halen ;
   unsigned char sll_addr[8] ;
};
struct tpacket_stats {
   unsigned int tp_packets ;
   unsigned int tp_drops ;
};
struct tpacket_hdr {
   unsigned long tp_status ;
   unsigned int tp_len ;
   unsigned int tp_snaplen ;
   unsigned short tp_mac ;
   unsigned short tp_net ;
   unsigned int tp_sec ;
   unsigned int tp_usec ;
};
struct tpacket_req {
   unsigned int tp_block_size ;
   unsigned int tp_block_nr ;
   unsigned int tp_frame_size ;
   unsigned int tp_frame_nr ;
};
struct packet_mreq {
   int mr_ifindex ;
   unsigned short mr_type ;
   unsigned short mr_alen ;
   unsigned char mr_address[8] ;
};
enum __anonenum_120 {
    SUSPEND_NOTIFY = 0,
    SUSPEND_SAVE_STATE = 1,
    SUSPEND_DISABLE = 2,
    SUSPEND_POWER_DOWN = 3
};
enum __anonenum_121 {
    RESUME_POWER_ON = 0,
    RESUME_RESTORE_STATE = 1,
    RESUME_ENABLE = 2
};
struct class;
struct class_device;
struct class_simple;
struct bus_attribute;
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char *name ;
   struct subsystem subsys ;
   struct kset drivers ;
   struct kset devices ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*hotplug)(struct device *dev , char **envp , int num_envp , char *buffer ,
                  int buffer_size ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
};
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char *buf ) ;
   ssize_t (*store)(struct bus_type * , char const   *buf , size_t count ) ;
};
struct device_driver {
   char *name ;
   struct bus_type *bus ;
   struct completion unloaded ;
   struct kobject kobj ;
   struct list_head devices ;
   struct module *owner ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state , u32 level ) ;
   int (*resume)(struct device *dev , u32 level ) ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char *buf ) ;
   ssize_t (*store)(struct device_driver * , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class_device_attribute;
struct class {
   char *name ;
   struct subsystem subsys ;
   struct list_head children ;
   struct list_head interfaces ;
   struct semaphore sem ;
   struct class_attribute *class_attrs ;
   struct class_device_attribute *class_dev_attrs ;
   int (*hotplug)(struct class_device *dev , char **envp , int num_envp , char *buffer ,
                  int buffer_size ) ;
   void (*release)(struct class_device *dev ) ;
   void (*class_release)(struct class *class ) ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , char *buf ) ;
   ssize_t (*store)(struct class * , char const   *buf , size_t count ) ;
};
struct class_device {
   struct list_head node ;
   struct kobject kobj ;
   struct class *class ;
   dev_t devt ;
   struct device *dev ;
   void *class_data ;
   char class_id[20] ;
};
struct class_device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class_device * , char *buf ) ;
   ssize_t (*store)(struct class_device * , char const   *buf , size_t count ) ;
};
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add)(struct class_device * ) ;
   void (*remove)(struct class_device * ) ;
};
struct dma_coherent_mem;
struct device {
   struct list_head node ;
   struct list_head bus_list ;
   struct list_head driver_list ;
   struct list_head children ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   void (*release)(struct device *dev ) ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , char *buf ) ;
   ssize_t (*store)(struct device *dev , char const   *buf , size_t count ) ;
};
struct platform_device {
   char *name ;
   u32 id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
};
struct divert_blk;
struct vlan_group;
struct ethtool_ops;
struct netpoll;
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
enum __anonenum_122 {
    IF_PORT_UNKNOWN = 0,
    IF_PORT_10BASE2 = 1,
    IF_PORT_10BASET = 2,
    IF_PORT_AUI = 3,
    IF_PORT_100BASET = 4,
    IF_PORT_100BASETX = 5,
    IF_PORT_100BASEFX = 6
};
struct neighbour;
struct neigh_parms;
struct netif_rx_stats {
   unsigned int total ;
   unsigned int dropped ;
   unsigned int time_squeeze ;
   unsigned int throttled ;
   unsigned int fastroute_hit ;
   unsigned int fastroute_success ;
   unsigned int fastroute_defer ;
   unsigned int fastroute_deferred_out ;
   unsigned int fastroute_latency_reduction ;
   unsigned int cpu_collision ;
};
struct dev_mc_list {
   struct dev_mc_list *next ;
   __u8 dmi_addr[32] ;
   unsigned char dmi_addrlen ;
   int dmi_users ;
   int dmi_gusers ;
};
struct hh_cache {
   struct hh_cache *hh_next ;
   atomic_t hh_refcnt ;
   unsigned short hh_type ;
   int hh_len ;
   int (*hh_output)(struct sk_buff *skb ) ;
   rwlock_t hh_lock ;
   unsigned long hh_data[(int )(48U / sizeof(long ))] ;
};
enum netdev_state_t {
    __LINK_STATE_XOFF = 0,
    __LINK_STATE_START = 1,
    __LINK_STATE_PRESENT = 2,
    __LINK_STATE_SCHED = 3,
    __LINK_STATE_NOCARRIER = 4,
    __LINK_STATE_RX_SCHED = 5,
    __LINK_STATE_LINKWATCH_PENDING = 6
};
struct netdev_boot_setup {
   char name[16] ;
   struct ifmap map ;
};
struct iw_statistics;
struct iw_handler_def;
struct iw_public_data;
struct Qdisc;
enum __anonenum_reg_state_123 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERING = 1,
    NETREG_REGISTERED = 2,
    NETREG_UNREGISTERING = 3,
    NETREG_UNREGISTERED = 4,
    NETREG_RELEASED = 5
};
struct net_bridge_port;
struct net_device {
   char name[16] ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned long state ;
   struct net_device *next ;
   int (*init)(struct net_device *dev ) ;
   struct net_device *next_sched ;
   int ifindex ;
   int iflink ;
   struct net_device_stats *(*get_stats)(struct net_device *dev ) ;
   struct iw_statistics *(*get_wireless_stats)(struct net_device *dev ) ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct ethtool_ops *ethtool_ops ;
   unsigned long trans_start ;
   unsigned long last_rx ;
   unsigned short flags ;
   unsigned short gflags ;
   unsigned short priv_flags ;
   unsigned short padded ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   void *priv ;
   struct net_device *master ;
   unsigned char broadcast[32] ;
   unsigned char dev_addr[32] ;
   unsigned char addr_len ;
   unsigned short dev_id ;
   struct dev_mc_list *mc_list ;
   int mc_count ;
   int promiscuity ;
   int allmulti ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   void *atalk_ptr ;
   void *ip_ptr ;
   void *dn_ptr ;
   void *ip6_ptr ;
   void *ec_ptr ;
   void *ax25_ptr ;
   struct list_head poll_list ;
   int quota ;
   int weight ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct Qdisc *qdisc_ingress ;
   struct list_head qdisc_list ;
   unsigned long tx_queue_len ;
   spinlock_t ingress_lock ;
   spinlock_t xmit_lock ;
   int xmit_lock_owner ;
   spinlock_t queue_lock ;
   atomic_t refcnt ;
   struct list_head todo_list ;
   struct hlist_node name_hlist ;
   struct hlist_node index_hlist ;
   enum __anonenum_reg_state_123 reg_state ;
   unsigned long features ;
   void (*uninit)(struct net_device *dev ) ;
   void (*destructor)(struct net_device *dev ) ;
   int (*open)(struct net_device *dev ) ;
   int (*stop)(struct net_device *dev ) ;
   int (*hard_start_xmit)(struct sk_buff *skb , struct net_device *dev ) ;
   int (*poll)(struct net_device *dev , int *quota ) ;
   int (*hard_header)(struct sk_buff *skb , struct net_device *dev , unsigned short type ,
                      void *daddr , void *saddr , unsigned int len ) ;
   int (*rebuild_header)(struct sk_buff *skb ) ;
   void (*set_multicast_list)(struct net_device *dev ) ;
   int (*set_mac_address)(struct net_device *dev , void *addr ) ;
   int (*do_ioctl)(struct net_device *dev , struct ifreq *ifr , int cmd ) ;
   int (*set_config)(struct net_device *dev , struct ifmap *map ) ;
   int (*hard_header_cache)(struct neighbour *neigh , struct hh_cache *hh ) ;
   void (*header_cache_update)(struct hh_cache *hh , struct net_device *dev , unsigned char *haddr ) ;
   int (*change_mtu)(struct net_device *dev , int new_mtu ) ;
   void (*tx_timeout)(struct net_device *dev ) ;
   void (*vlan_rx_register)(struct net_device *dev , struct vlan_group *grp ) ;
   void (*vlan_rx_add_vid)(struct net_device *dev , unsigned short vid ) ;
   void (*vlan_rx_kill_vid)(struct net_device *dev , unsigned short vid ) ;
   int (*hard_header_parse)(struct sk_buff *skb , unsigned char *haddr ) ;
   int (*neigh_setup)(struct net_device *dev , struct neigh_parms * ) ;
   struct netpoll *np ;
   void (*poll_controller)(struct net_device *dev ) ;
   struct net_bridge_port *br_port ;
   struct divert_blk *divert ;
   struct class_device class_dev ;
};
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block *self , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
typedef int gifconf_func_t(struct net_device *dev , char *bufptr , int len );
struct softnet_data {
   int throttle ;
   int cng_level ;
   int avg_blog ;
   struct sk_buff_head input_pkt_queue ;
   struct list_head poll_list ;
   struct net_device *output_queue ;
   struct sk_buff *completion_queue ;
   struct net_device backlog_dev ;
};
enum __anonenum_124 {
    NETIF_MSG_DRV = 1,
    NETIF_MSG_PROBE = 2,
    NETIF_MSG_LINK = 4,
    NETIF_MSG_TIMER = 8,
    NETIF_MSG_IFDOWN = 16,
    NETIF_MSG_IFUP = 32,
    NETIF_MSG_RX_ERR = 64,
    NETIF_MSG_TX_ERR = 128,
    NETIF_MSG_TX_QUEUED = 256,
    NETIF_MSG_INTR = 512,
    NETIF_MSG_TX_DONE = 1024,
    NETIF_MSG_RX_STATUS = 2048,
    NETIF_MSG_PKTDATA = 4096,
    NETIF_MSG_HW = 8192,
    NETIF_MSG_WOL = 16384
};
struct rand_pool_info {
   int entropy_count ;
   int buf_size ;
   __u32 buf[0] ;
};
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
struct iw_discarded {
   __u32 nwid ;
   __u32 code ;
   __u32 fragment ;
   __u32 retries ;
   __u32 misc ;
};
struct iw_missed {
   __u32 beacon ;
};
struct iw_thrspy {
   struct sockaddr addr ;
   struct iw_quality qual ;
   struct iw_quality low ;
   struct iw_quality high ;
};
struct iw_statistics {
   __u16 status ;
   struct iw_quality qual ;
   struct iw_discarded discard ;
   struct iw_missed miss ;
};
union iwreq_data {
   char name[16] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
union __anonunion_ifr_ifrn_125 {
   char ifrn_name[16] ;
};
struct iwreq {
   union __anonunion_ifr_ifrn_125 ifr_ifrn ;
   union iwreq_data u ;
};
struct iw_range {
   __u32 throughput ;
   __u32 min_nwid ;
   __u32 max_nwid ;
   __u16 old_num_channels ;
   __u8 old_num_frequency ;
   __u32 event_capa[6] ;
   __s32 sensitivity ;
   struct iw_quality max_qual ;
   struct iw_quality avg_qual ;
   __u8 num_bitrates ;
   __s32 bitrate[32] ;
   __s32 min_rts ;
   __s32 max_rts ;
   __s32 min_frag ;
   __s32 max_frag ;
   __s32 min_pmp ;
   __s32 max_pmp ;
   __s32 min_pmt ;
   __s32 max_pmt ;
   __u16 pmp_flags ;
   __u16 pmt_flags ;
   __u16 pm_capa ;
   __u16 encoding_size[8] ;
   __u8 num_encoding_sizes ;
   __u8 max_encoding_tokens ;
   __u8 encoding_login_index ;
   __u16 txpower_capa ;
   __u8 num_txpower ;
   __s32 txpower[8] ;
   __u8 we_version_compiled ;
   __u8 we_version_source ;
   __u16 retry_capa ;
   __u16 retry_flags ;
   __u16 r_time_flags ;
   __s32 min_retry ;
   __s32 max_retry ;
   __s32 min_r_time ;
   __s32 max_r_time ;
   __u16 num_channels ;
   __u8 num_frequency ;
   struct iw_freq freq[32] ;
};
struct iw_priv_args {
   __u32 cmd ;
   __u16 set_args ;
   __u16 get_args ;
   char name[16] ;
};
struct iw_event {
   __u16 len ;
   __u16 cmd ;
   union iwreq_data u ;
};
struct iw_request_info {
   __u16 cmd ;
   __u16 flags ;
};
typedef int (*iw_handler)(struct net_device *dev , struct iw_request_info *info ,
                          union iwreq_data *wrqu , char *extra );
struct iw_handler_def {
   __u16 num_standard ;
   __u16 num_private ;
   __u16 num_private_args ;
   iw_handler const   *standard ;
   iw_handler const   *private ;
   struct iw_priv_args  const  *private_args ;
   long spy_offset ;
   struct iw_statistics *(*get_wireless_stats)(struct net_device *dev ) ;
};
struct iw_ioctl_description {
   __u8 header_type ;
   __u8 token_type ;
   __u16 token_size ;
   __u16 min_tokens ;
   __u16 max_tokens ;
   __u32 flags ;
};
struct iw_spy_data {
   int spy_number ;
   u_char spy_address[8][6] ;
   struct iw_quality spy_stat[8] ;
   struct iw_quality spy_thr_low ;
   struct iw_quality spy_thr_high ;
   u_char spy_thr_under[8] ;
};
struct iw_public_data {
   struct iw_spy_data *spy_data ;
};
struct scp_t;
typedef struct scp_t scp_t;
struct scp_t {
   unsigned short scp_sysbus ;
   unsigned short scp_junk[2] ;
   unsigned short scp_iscpl ;
   unsigned short scp_iscph ;
};
struct iscp_t;
typedef struct iscp_t iscp_t;
struct iscp_t {
   unsigned short iscp_busy ;
   unsigned short iscp_offset ;
   unsigned short iscp_basel ;
   unsigned short iscp_baseh ;
};
struct scb_t;
typedef struct scb_t scb_t;
struct scb_t {
   unsigned short scb_status ;
   unsigned short scb_command ;
   unsigned short scb_cbl_offset ;
   unsigned short scb_rfa_offset ;
   unsigned short scb_crcerrs ;
   unsigned short scb_alnerrs ;
   unsigned short scb_rscerrs ;
   unsigned short scb_ovrnerrs ;
};
enum acmd_e;
typedef enum acmd_e acmd_e;
enum acmd_e {
    acmd_nop = 0,
    acmd_ia_setup = 1,
    acmd_configure = 2,
    acmd_mc_setup = 3,
    acmd_transmit = 4,
    acmd_tdr = 5,
    acmd_dump = 6,
    acmd_diagnose = 7
};
struct ach_t;
typedef struct ach_t ach_t;
struct ach_t {
   unsigned short ac_status ;
   unsigned short ac_command ;
   unsigned short ac_link ;
};
struct ac_nop_t;
typedef struct ac_nop_t ac_nop_t;
struct ac_nop_t {
   ach_t nop_h ;
};
struct ac_ias_t;
typedef struct ac_ias_t ac_ias_t;
struct ac_ias_t {
   ach_t ias_h ;
   unsigned char ias_addr[6] ;
};
struct ac_cfg_t;
typedef struct ac_cfg_t ac_cfg_t;
struct ac_cfg_t {
   ach_t cfg_h ;
   unsigned char cfg_byte_cnt ;
   unsigned char cfg_fifolim ;
   unsigned char cfg_byte8 ;
   unsigned char cfg_byte9 ;
   unsigned char cfg_byte10 ;
   unsigned char cfg_ifs ;
   unsigned char cfg_slotl ;
   unsigned char cfg_byte13 ;
   unsigned char cfg_byte14 ;
   unsigned char cfg_byte15 ;
   unsigned short cfg_min_frm_len ;
};
struct ac_mcs_t;
typedef struct ac_mcs_t ac_mcs_t;
struct ac_mcs_t {
   ach_t mcs_h ;
   unsigned short mcs_cnt ;
};
struct ac_tx_t;
typedef struct ac_tx_t ac_tx_t;
struct ac_tx_t {
   ach_t tx_h ;
   unsigned short tx_tbd_offset ;
};
struct ac_tdr_t;
typedef struct ac_tdr_t ac_tdr_t;
struct ac_tdr_t {
   ach_t tdr_h ;
   unsigned short tdr_result ;
};
struct ac_dmp_t;
typedef struct ac_dmp_t ac_dmp_t;
struct ac_dmp_t {
   ach_t dmp_h ;
   unsigned short dmp_offset ;
};
struct ac_dgn_t;
typedef struct ac_dgn_t ac_dgn_t;
struct ac_dgn_t {
   ach_t dgn_h ;
};
struct tbd_t;
typedef struct tbd_t tbd_t;
struct tbd_t {
   unsigned short tbd_status ;
   unsigned short tbd_next_bd_offset ;
   unsigned short tbd_bufl ;
   unsigned short tbd_bufh ;
};
struct rbd_t;
typedef struct rbd_t rbd_t;
struct rbd_t {
   unsigned short rbd_status ;
   unsigned short rbd_next_rbd_offset ;
   unsigned short rbd_bufl ;
   unsigned short rbd_bufh ;
   unsigned short rbd_el_size ;
};
struct fd_t;
typedef struct fd_t fd_t;
struct fd_t {
   unsigned short fd_status ;
   unsigned short fd_command ;
   unsigned short fd_link_offset ;
   unsigned short fd_rbd_offset ;
   unsigned char fd_dest[6] ;
   unsigned char fd_src[6] ;
   unsigned short fd_length ;
};
union hacs_u;
typedef union hacs_u hacs_u;
union hacs_u {
   unsigned short hu_command ;
   unsigned short hu_status ;
};
struct ha_t;
typedef struct ha_t ha_t;
struct ha_t {
   hacs_u ha_cs ;
   unsigned short ha_mmcr ;
   unsigned short ha_pior0 ;
   unsigned short ha_piop0 ;
   unsigned short ha_pior1 ;
   unsigned short ha_piop1 ;
   unsigned short ha_pior2 ;
   unsigned short ha_piop2 ;
};
struct psa_t;
typedef struct psa_t psa_t;
struct psa_t {
   unsigned char psa_io_base_addr_1 ;
   unsigned char psa_io_base_addr_2 ;
   unsigned char psa_io_base_addr_3 ;
   unsigned char psa_io_base_addr_4 ;
   unsigned char psa_rem_boot_addr_1 ;
   unsigned char psa_rem_boot_addr_2 ;
   unsigned char psa_rem_boot_addr_3 ;
   unsigned char psa_holi_params ;
   unsigned char psa_int_req_no ;
   unsigned char psa_unused0[7] ;
   unsigned char psa_univ_mac_addr[6] ;
   unsigned char psa_local_mac_addr[6] ;
   unsigned char psa_univ_local_sel ;
   unsigned char psa_comp_number ;
   unsigned char psa_thr_pre_set ;
   unsigned char psa_feature_select ;
   unsigned char psa_subband ;
   unsigned char psa_quality_thr ;
   unsigned char psa_mod_delay ;
   unsigned char psa_nwid[2] ;
   unsigned char psa_nwid_select ;
   unsigned char psa_encryption_select ;
   unsigned char psa_encryption_key[8] ;
   unsigned char psa_databus_width ;
   unsigned char psa_call_code[8] ;
   unsigned char psa_nwid_prefix[2] ;
   unsigned char psa_reserved[2] ;
   unsigned char psa_conf_status ;
   unsigned char psa_crc[2] ;
   unsigned char psa_crc_status ;
};
struct mmw_t;
typedef struct mmw_t mmw_t;
struct mmw_t {
   unsigned char mmw_encr_key[8] ;
   unsigned char mmw_encr_enable ;
   unsigned char mmw_unused0[1] ;
   unsigned char mmw_des_io_invert ;
   unsigned char mmw_unused1[5] ;
   unsigned char mmw_loopt_sel ;
   unsigned char mmw_jabber_enable ;
   unsigned char mmw_freeze ;
   unsigned char mmw_anten_sel ;
   unsigned char mmw_ifs ;
   unsigned char mmw_mod_delay ;
   unsigned char mmw_jam_time ;
   unsigned char mmw_unused2[1] ;
   unsigned char mmw_thr_pre_set ;
   unsigned char mmw_decay_prm ;
   unsigned char mmw_decay_updat_prm ;
   unsigned char mmw_quality_thr ;
   unsigned char mmw_netw_id_l ;
   unsigned char mmw_netw_id_h ;
   unsigned char mmw_mode_select ;
   unsigned char mmw_unused3[1] ;
   unsigned char mmw_fee_ctrl ;
   unsigned char mmw_fee_addr ;
   unsigned char mmw_fee_data_l ;
   unsigned char mmw_fee_data_h ;
   unsigned char mmw_ext_ant ;
};
struct mmr_t;
typedef struct mmr_t mmr_t;
struct mmr_t {
   unsigned char mmr_unused0[8] ;
   unsigned char mmr_des_status ;
   unsigned char mmr_des_avail ;
   unsigned char mmr_des_io_invert ;
   unsigned char mmr_unused1[5] ;
   unsigned char mmr_dce_status ;
   unsigned char mmr_dsp_id ;
   unsigned char mmr_unused2[2] ;
   unsigned char mmr_correct_nwid_l ;
   unsigned char mmr_correct_nwid_h ;
   unsigned char mmr_wrong_nwid_l ;
   unsigned char mmr_wrong_nwid_h ;
   unsigned char mmr_thr_pre_set ;
   unsigned char mmr_signal_lvl ;
   unsigned char mmr_silence_lvl ;
   unsigned char mmr_sgnl_qual ;
   unsigned char mmr_netw_id_l ;
   unsigned char mmr_unused3[3] ;
   unsigned char mmr_fee_status ;
   unsigned char mmr_unused4[1] ;
   unsigned char mmr_fee_data_l ;
   unsigned char mmr_fee_data_h ;
};
union mm_t {
   struct mmw_t w ;
   struct mmr_t r ;
};
typedef union mm_t mm_t;
typedef struct net_device_stats en_stats;
typedef struct iw_statistics iw_stats;
typedef struct iw_quality iw_qual;
typedef struct iw_freq iw_freq;
struct net_local;
typedef struct net_local net_local;
typedef struct timer_list timer_list;
typedef u_char mac_addr[6];
struct net_local {
   net_local *next ;
   struct net_device *dev ;
   spinlock_t spinlock ;
   en_stats stats ;
   int nresets ;
   u_char reconfig_82586 ;
   u_char promiscuous ;
   int mc_count ;
   u_short hacr ;
   int tx_n_in_use ;
   u_short rx_head ;
   u_short rx_last ;
   u_short tx_first_free ;
   u_short tx_first_in_use ;
   iw_stats wstats ;
   struct iw_spy_data spy_data ;
   struct iw_public_data wireless_data ;
};
struct __anonstruct_s_8___0 {
   __u32 a ;
   __u32 b ;
};
union __anonunion_v_7___0 {
   struct __anonstruct_s_8___0 s ;
   __u64 u ;
};
enum __anonenum_70___0 {
    PM_SYS_UNKNOWN___0 = 0,
    PM_SYS_KBC___0 = 1104151299,
    PM_SYS_COM___0 = 1104151808,
    PM_SYS_IRDA___0 = 1104151824,
    PM_SYS_FDC___0 = 1104152320,
    PM_SYS_VGA___0 = 1104152832,
    PM_SYS_PCMCIA___0 = 1104154112
};
enum __anonenum_82___0 {
    IOCB_CMD_PREAD___0 = 0,
    IOCB_CMD_PWRITE___0 = 1,
    IOCB_CMD_FSYNC___0 = 2,
    IOCB_CMD_FDSYNC___0 = 3,
    IOCB_CMD_NOOP___0 = 6
};
#pragma merger(0,"/tmp/cil-vwrtspdb.i","")
extern long do_no_restart_syscall(struct restart_block *parm ) ;
__inline static int __attribute__((__always_inline__))  generic_ffs(int x ) 
{ int r ;

  {
  r = 1;
  if (! x) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  if (! (x & 65535)) {
    x >>= 16;
    r += 16;
  }
  if (! (x & 255)) {
    x >>= 8;
    r += 8;
  }
  if (! (x & 15)) {
    x >>= 4;
    r += 4;
  }
  if (! (x & 3)) {
    x >>= 2;
    r += 2;
  }
  if (! (x & 1)) {
    x >>= 1;
    r ++;
  }
  return ((int __attribute__((__always_inline__))  )r);
}
}
__inline static int __attribute__((__always_inline__))  generic_fls(int x ) 
{ int r ;

  {
  r = 32;
  if (! x) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  if (! ((unsigned int )x & 4294901760U)) {
    x <<= 16;
    r -= 16;
  }
  if (! ((unsigned int )x & 4278190080U)) {
    x <<= 8;
    r -= 8;
  }
  if (! ((unsigned int )x & 4026531840U)) {
    x <<= 4;
    r -= 4;
  }
  if (! ((unsigned int )x & 3221225472U)) {
    x <<= 2;
    r -= 2;
  }
  if (! ((unsigned int )x & 2147483648U)) {
    x <<= 1;
    r --;
  }
  return ((int __attribute__((__always_inline__))  )r);
}
}
__inline static void __attribute__((__always_inline__))  set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "btsl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  __set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  ("btsl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "btrl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  __clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("btrl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  __change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("btcl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "btcl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_bit(int nr ,
                                                                         unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("lock ; "
                       "btsl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  __test_and_set_bit(int nr ,
                                                                           unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  ("btsl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr));
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_bit(int nr ,
                                                                           unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("lock ; "
                       "btrl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  __test_and_clear_bit(int nr ,
                                                                             unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  ("btrl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr));
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  __test_and_change_bit(int nr ,
                                                                              unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("btcl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  test_and_change_bit(int nr ,
                                                                            unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("lock ; "
                       "btcl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  constant_test_bit(int nr ,
                                                                          unsigned long const volatile   *addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(((1UL << (nr & 31)) & (unsigned long )(*(addr +
                                                                                              (nr >>
                                                                                               5)))) !=
                                                     0UL));
}
}
__inline static int __attribute__((__always_inline__))  variable_test_bit(int nr ,
                                                                          unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("btl %2,%1\n\tsbbl %0,%0": "=r" (oldbit): "m" ((*((long volatile   *)addr))),
                       "Ir" (nr));
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  find_first_zero_bit(unsigned long const   *addr ,
                                                                            unsigned int size ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int res ;

  {
  if (! size) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  __asm__  volatile   ("movl $-1,%%eax\n\t"
                       "xorl %%edx,%%edx\n\t"
                       "repe; scasl\n\t"
                       "je 1f\n\t"
                       "xorl -4(%%edi),%%eax\n\t"
                       "subl $4,%%edi\n\t"
                       "bsfl %%eax,%%edx\n"
                       "1:\tsubl %%ebx,%%edi\n\t"
                       "shll $3,%%edi\n\t"
                       "addl %%edi,%%edx": "=d" (res), "=&c" (d0), "=&D" (d1), "=&a" (d2): "1" ((size +
                                                                                                 31U) >>
                                                                                                5),
                       "2" (addr), "b" (addr): "memory");
  return ((int __attribute__((__always_inline__))  )res);
}
}
extern int find_next_zero_bit(unsigned long const   *addr , int size , int offset ) ;
__inline static int __attribute__((__always_inline__))  find_first_bit(unsigned long const   *addr ,
                                                                       unsigned int size ) 
{ int d0 ;
  int d1 ;
  int res ;

  {
  __asm__  volatile   ("xorl %%eax,%%eax\n\t"
                       "repe; scasl\n\t"
                       "jz 1f\n\t"
                       "leal -4(%%edi),%%edi\n\t"
                       "bsfl (%%edi),%%eax\n"
                       "1:\tsubl %%ebx,%%edi\n\t"
                       "shll $3,%%edi\n\t"
                       "addl %%edi,%%eax": "=a" (res), "=&c" (d0), "=&D" (d1): "1" ((size +
                                                                                     31U) >>
                                                                                    5),
                       "2" (addr), "b" (addr): "memory");
  return ((int __attribute__((__always_inline__))  )res);
}
}
extern int find_next_bit(unsigned long const   *addr , int size , int offset ) ;
__inline static unsigned long __attribute__((__always_inline__))  ffz(unsigned long word ) 
{ 

  {
  __asm__  ("bsfl %1,%0": "=r" (word): "r" (~ word));
  return ((unsigned long __attribute__((__always_inline__))  )word);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __ffs(unsigned long word ) 
{ 

  {
  __asm__  ("bsfl %1,%0": "=r" (word): "rm" (word));
  return ((unsigned long __attribute__((__always_inline__))  )word);
}
}
__inline static int __attribute__((__always_inline__))  sched_find_first_bit(unsigned long const   *b ) 
{ int __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;
  long tmp___2 ;
  unsigned long __attribute__((__always_inline__))  tmp___3 ;
  long tmp___4 ;
  unsigned long __attribute__((__always_inline__))  tmp___5 ;
  unsigned long __attribute__((__always_inline__))  tmp___6 ;

  {
  tmp___0 = __builtin_expect((long )(! (! (*(b + 0))) != 0), 0L);
  if (tmp___0) {
    tmp = (int __attribute__((__always_inline__))  )__ffs((unsigned long )(*(b + 0)));
    return (tmp);
  }
  tmp___2 = __builtin_expect((long )(! (! (*(b + 1))) != 0), 0L);
  if (tmp___2) {
    tmp___1 = __ffs((unsigned long )(*(b + 1)));
    return ((int __attribute__((__always_inline__))  )(tmp___1 + 32UL));
  }
  tmp___4 = __builtin_expect((long )(! (! (*(b + 2))) != 0), 0L);
  if (tmp___4) {
    tmp___3 = __ffs((unsigned long )(*(b + 2)));
    return ((int __attribute__((__always_inline__))  )(tmp___3 + 64UL));
  }
  if ((*(b + 3))) {
    tmp___5 = __ffs((unsigned long )(*(b + 3)));
    return ((int __attribute__((__always_inline__))  )(tmp___5 + 96UL));
  }
  tmp___6 = __ffs((unsigned long )(*(b + 4)));
  return ((int __attribute__((__always_inline__))  )(tmp___6 + 128UL));
}
}
__inline static int __attribute__((__always_inline__))  ffs(int x ) 
{ int r ;

  {
  __asm__  ("bsfl %1,%0\n\t"
            "jnz 1f\n\t"
            "movl $-1,%0\n"
            "1:": "=r" (r): "rm" (x));
  return ((int __attribute__((__always_inline__))  )(r + 1));
}
}
__inline static int __attribute__((__always_inline__))  get_bitmask_order(unsigned int count ) 
{ int order ;

  {
  order = (int )generic_fls((int )count);
  return ((int __attribute__((__always_inline__))  )order);
}
}
__inline static unsigned int __attribute__((__always_inline__))  generic_hweight32(unsigned int w ) 
{ unsigned int res ;

  {
  res = (w & 1431655765U) + ((w >> 1) & 1431655765U);
  res = (res & 858993459U) + ((res >> 2) & 858993459U);
  res = (res & 252645135U) + ((res >> 4) & 252645135U);
  res = (res & 16711935U) + ((res >> 8) & 16711935U);
  return ((unsigned int __attribute__((__always_inline__))  )((res & 65535U) + ((res >>
                                                                                 16) &
                                                                                65535U)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  generic_hweight16(unsigned int w ) 
{ unsigned int res ;

  {
  res = (w & 21845U) + ((w >> 1) & 21845U);
  res = (res & 13107U) + ((res >> 2) & 13107U);
  res = (res & 3855U) + ((res >> 4) & 3855U);
  return ((unsigned int __attribute__((__always_inline__))  )((res & 255U) + ((res >>
                                                                               8) &
                                                                              255U)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  generic_hweight8(unsigned int w ) 
{ unsigned int res ;

  {
  res = (w & 85U) + ((w >> 1) & 85U);
  res = (res & 51U) + ((res >> 2) & 51U);
  return ((unsigned int __attribute__((__always_inline__))  )((res & 15U) + ((res >>
                                                                              4) &
                                                                             15U)));
}
}
__inline static unsigned long __attribute__((__always_inline__))  generic_hweight64(__u64 w ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = generic_hweight32((unsigned int )(w >> 32));
  tmp___0 = generic_hweight32((unsigned int )w);
  return ((unsigned long __attribute__((__always_inline__))  )(tmp + tmp___0));
}
}
__inline static unsigned long __attribute__((__always_inline__))  hweight_long(unsigned long w ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned long __attribute__((__always_inline__))  tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;

  {
  if (sizeof(w) == 4U) {
    tmp___1 = (unsigned long __attribute__((__always_inline__))  )generic_hweight32((unsigned int )w);
  } else {
    tmp___1 = generic_hweight64((unsigned long long )w);
  }
  return (tmp___1);
}
}
__inline static __u32 __attribute__((__always_inline__))  rol32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word << shift) | (word >> (32U - shift)));
}
}
__inline static __u32 __attribute__((__always_inline__))  ror32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word >> shift) | (word << (32U - shift)));
}
}
extern int nx_enabled ;
extern unsigned long long __supported_pte_mask ;
extern unsigned int __VMALLOC_RESERVE ;
__inline static int __attribute__((__always_inline__))  get_order(unsigned long size ) 
{ int order ;

  {
  size = (size - 1UL) >> 11;
  order = -1;
  while (1) {
    size >>= 1;
    order ++;
    if (! size) {
      break;
    }
  }
  return ((int __attribute__((__always_inline__))  )order);
}
}
extern int sysctl_legacy_va_layout ;
extern void handle_vm86_fault(struct kernel_vm86_regs * , long  ) ;
extern int handle_vm86_trap(struct kernel_vm86_regs * , long  , int  ) ;
extern int restore_i387_soft(void *s387 , struct _fpstate *buf ) ;
extern int save_i387_soft(void *s387 , struct _fpstate *buf ) ;
__inline static void __attribute__((__always_inline__))  wrmsrl(unsigned long msr ,
                                                                unsigned long long val ) 
{ unsigned long lo ;
  unsigned long hi ;

  {
  lo = (unsigned long )val;
  hi = (unsigned long )(val >> 32);
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (lo), "d" (hi));
}
}
__inline static __u32 __attribute__((__always_inline__))  ___arch__swab32(__u32 x )  __attribute__((__const__)) ;
__inline static __u32 __attribute__((__always_inline__))  ___arch__swab32(__u32 x ) 
{ 

  {
  __asm__  ("bswap %0": "=r" (x): "0" (x));
  return (x);
}
}
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64(__u64 val ) 
{ union __anonunion_v_7 v ;

  {
  v.u = val;
  __asm__  ("bswapl %0 ; bswapl %1 ; xchgl %0,%1": "=r" (v.s.a), "=r" (v.s.b): "0" (v.s.a),
            "1" (v.s.b));
  return (v.u);
}
}
__inline static __u16 __attribute__((__always_inline__))  __fswab16(__u16 x )  __attribute__((__const__)) ;
__inline static __u16 __attribute__((__always_inline__))  __fswab16(__u16 x ) 
{ __u16 __tmp ;
  __u16 __x ;

  {
  __tmp = x;
  __x = __tmp;
  return ((unsigned short )((((int )__x & 255) << 8) | (((int )__x & 65280) >> 8)));
}
}
__inline static __u16 __attribute__((__always_inline__))  __swab16p(__u16 const   *x ) 
{ __u16 __tmp ;
  __u16 __x ;

  {
  __tmp = (__u16 )(*x);
  __x = __tmp;
  return ((unsigned short )((((int )__x & 255) << 8) | (((int )__x & 65280) >> 8)));
}
}
__inline static void __attribute__((__always_inline__))  __swab16s(__u16 *addr ) 
{ __u16 __tmp ;
  __u16 __x ;

  {
  while (1) {
    __tmp = (*addr);
    __x = __tmp;
    (*addr) = (unsigned short )((((int )__x & 255) << 8) | (((int )__x & 65280) >>
                                                            8));
    break;
  }
  return;
}
}
__inline static __u32 __attribute__((__always_inline__))  __fswab32(__u32 x )  __attribute__((__const__)) ;
__inline static __u32 __attribute__((__always_inline__))  __fswab32(__u32 x ) 
{ __u32 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab32(x);
  return (tmp);
}
}
__inline static __u32 __attribute__((__always_inline__))  __swab32p(__u32 const   *x ) 
{ __u32 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab32((*x));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __swab32s(__u32 *addr ) 
{ 

  {
  while (1) {
    (*addr) = (__u32 )___arch__swab32((*addr));
    break;
  }
  return;
}
}
__inline static __u64 __attribute__((__always_inline__))  __fswab64(__u64 x )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  __fswab64(__u64 x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64(x);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __swab64p(__u64 const   *x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64((*x));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __swab64s(__u64 *addr ) 
{ 

  {
  while (1) {
    (*addr) = (__u64 )___arch__swab64((*addr));
    break;
  }
  return;
}
}
__inline static __le64 __attribute__((__always_inline__))  __cpu_to_le64p(__u64 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __u64 __attribute__((__always_inline__))  __le64_to_cpup(__le64 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __le32 __attribute__((__always_inline__))  __cpu_to_le32p(__u32 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __u32 __attribute__((__always_inline__))  __le32_to_cpup(__le32 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __le16 __attribute__((__always_inline__))  __cpu_to_le16p(__u16 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __u16 __attribute__((__always_inline__))  __le16_to_cpup(__le16 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __be64 __attribute__((__always_inline__))  __cpu_to_be64p(__u64 const   *p ) 
{ __be64 tmp ;

  {
  tmp = (__be64 )__swab64p(p);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __be64_to_cpup(__be64 const   *p ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  return (tmp);
}
}
__inline static __be32 __attribute__((__always_inline__))  __cpu_to_be32p(__u32 const   *p ) 
{ __be32 tmp ;

  {
  tmp = (__be32 )__swab32p(p);
  return (tmp);
}
}
__inline static __u32 __attribute__((__always_inline__))  __be32_to_cpup(__be32 const   *p ) 
{ __u32 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  return (tmp);
}
}
__inline static __be16 __attribute__((__always_inline__))  __cpu_to_be16p(__u16 const   *p ) 
{ __be16 tmp ;

  {
  tmp = (__be16 )__swab16p(p);
  return (tmp);
}
}
__inline static __u16 __attribute__((__always_inline__))  __be16_to_cpup(__be16 const   *p ) 
{ __u16 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  return (tmp);
}
}
extern __u32 ntohl(__be32  ) ;
extern __be32 htonl(__u32  ) ;
extern __u16 ntohs(__be16  ) ;
extern __be16 htons(__u16  ) ;
extern char const   linux_banner[] ;
extern int console_printk[] ;
extern struct notifier_block *panic_notifier_list ;
extern long (*panic_blink)(long time ) ;
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...) ;
extern  __attribute__((__noreturn__)) void ( __attribute__((__regparm__(3))) do_exit)(long error_code ) ;
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
extern int get_option(char **str , int *pint ) ;
extern char *get_options(char const   *str , int nints , int *ints ) ;
extern unsigned long long memparse(char *ptr , char **retptr ) ;
extern int __kernel_text_address(unsigned long addr ) ;
extern int kernel_text_address(unsigned long addr ) ;
extern int session_of_pgrp(int pgrp ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) vprintk)(char const   *fmt ,
                                                                             va_list args ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...) ;
extern unsigned long int_sqrt(unsigned long  ) ;
__inline static int __attribute__((__pure__, __always_inline__))  long_log2(unsigned long x ) 
{ int r ;

  {
  r = 0;
  x >>= 1;
  while (x > 0UL) {
    r ++;
    x >>= 1;
  }
  return ((int __attribute__((__pure__, __always_inline__))  )r);
}
}
__inline static unsigned long __attribute__((__always_inline__))  roundup_pow_of_two(unsigned long x )  __attribute__((__const__)) ;
__inline static unsigned long __attribute__((__always_inline__))  roundup_pow_of_two(unsigned long x ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = generic_fls((int )(x - 1UL));
  return ((unsigned long __attribute__((__always_inline__))  )(1UL << tmp));
}
}
extern int printk_ratelimit(void) ;
extern int __printk_ratelimit(int ratelimit_jiffies , int ratelimit_burst ) ;
__inline static void __attribute__((__always_inline__))  console_silent(void) 
{ 

  {
  console_printk[0] = 0;
  return;
}
}
__inline static void __attribute__((__always_inline__))  console_verbose(void) 
{ 

  {
  if (console_printk[0]) {
    console_printk[0] = 15;
  }
  return;
}
}
extern void bust_spinlocks(int yes ) ;
extern int oops_in_progress ;
extern int panic_timeout ;
extern int panic_on_oops ;
extern int tainted ;
extern char const   *print_tainted(void) ;
extern void add_taint(unsigned int  ) ;
extern enum system_states system_state ;
extern void dump_stack(void) ;
extern void BUILD_BUG(void) ;
extern int randomize_va_space ;
extern struct task_struct *( __attribute__((__regparm__(3))) __switch_to)(struct task_struct *prev ,
                                                                          struct task_struct *next ) ;
__inline static unsigned long __attribute__((__always_inline__))  _get_base(char *addr ) 
{ unsigned long __base ;

  {
  __asm__  ("movb %3,%%dh\n\t"
            "movb %2,%%dl\n\t"
            "shll $16,%%edx\n\t"
            "movw %1,%%dx": "=&d" (__base): "m" ((*(addr + 2))), "m" ((*(addr + 4))),
            "m" ((*(addr + 7))));
  return ((unsigned long __attribute__((__always_inline__))  )__base);
}
}
__inline static unsigned long __attribute__((__always_inline__))  get_limit(unsigned long segment ) 
{ unsigned long __limit ;

  {
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  return ((unsigned long __attribute__((__always_inline__))  )(__limit + 1UL));
}
}
__inline static void __attribute__((__always_inline__))  __set_64bit(unsigned long long *ptr ,
                                                                     unsigned int low ,
                                                                     unsigned int high ) 
{ 

  {
  __asm__  volatile   ("\n1:\t"
                       "movl (%0), %%eax\n\t"
                       "movl 4(%0), %%edx\n\t"
                       "lock cmpxchg8b (%0)\n\t"
                       "jnz 1b": : "D" (ptr), "b" (low), "c" (high): "ax", "dx", "memory");
}
}
__inline static void __attribute__((__always_inline__))  __set_64bit_constant(unsigned long long *ptr ,
                                                                              unsigned long long value ) 
{ 

  {
  __set_64bit(ptr, (unsigned int )value, (unsigned int )(value >> 32ULL));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __set_64bit_var(unsigned long long *ptr ,
                                                                         unsigned long long value ) 
{ 

  {
  __set_64bit(ptr, (*((unsigned int *)(& value) + 0)), (*((unsigned int *)(& value) +
                                                          1)));
  return;
}
}
__inline static unsigned long __attribute__((__always_inline__))  __xchg(unsigned long x ,
                                                                         void volatile   *ptr ,
                                                                         int size ) 
{ 

  {
  switch (size) {
  case 1: 
  __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (x): "memory");
  break;
  case 2: 
  __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (x): "memory");
  break;
  case 4: 
  __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (x): "memory");
  break;
  }
  return ((unsigned long __attribute__((__always_inline__))  )x);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __cmpxchg(void volatile   *ptr ,
                                                                            unsigned long old ,
                                                                            unsigned long new ,
                                                                            int size ) 
{ unsigned long prev ;

  {
  switch (size) {
  case 1: 
  __asm__  volatile   ("lock ; "
                       "cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (old): "memory");
  return ((unsigned long __attribute__((__always_inline__))  )prev);
  case 2: 
  __asm__  volatile   ("lock ; "
                       "cmpxchgw %w1,%2": "=a" (prev): "q" (new), "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (old): "memory");
  return ((unsigned long __attribute__((__always_inline__))  )prev);
  case 4: 
  __asm__  volatile   ("lock ; "
                       "cmpxchgl %1,%2": "=a" (prev): "q" (new), "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (old): "memory");
  return ((unsigned long __attribute__((__always_inline__))  )prev);
  }
  return ((unsigned long __attribute__((__always_inline__))  )old);
}
}
extern void disable_hlt(void) ;
extern void enable_hlt(void) ;
extern int es7000_plat ;
extern void cpu_idle_wait(void) ;
extern unsigned long arch_align_stack(unsigned long sp ) ;
extern unsigned long __per_cpu_offset[8] ;
extern int tsc_disable ;
extern struct cpuinfo_x86 boot_cpu_data ;
extern struct cpuinfo_x86 new_cpu_data ;
extern struct tss_struct doublefault_tss ;
extern struct tss_struct per_cpu__init_tss ;
extern struct cpuinfo_x86 cpu_data[] ;
extern int phys_proc_id[8] ;
extern int cpu_core_id[8] ;
extern char ignore_fpu_irq ;
extern void identify_cpu(struct cpuinfo_x86 * ) ;
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
extern void detect_ht(struct cpuinfo_x86 *c ) ;
__inline static void __attribute__((__always_inline__))  cpuid(unsigned int op , unsigned int *eax ,
                                                               unsigned int *ebx ,
                                                               unsigned int *ecx ,
                                                               unsigned int *edx ) 
{ 

  {
  __asm__  ("cpuid": "=a" ((*eax)), "=b" ((*ebx)), "=c" ((*ecx)), "=d" ((*edx)): "0" (op),
            "c" (0));
}
}
__inline static void __attribute__((__always_inline__))  cpuid_count(int op , int count ,
                                                                     int *eax , int *ebx ,
                                                                     int *ecx , int *edx ) 
{ 

  {
  __asm__  ("cpuid": "=a" ((*eax)), "=b" ((*ebx)), "=c" ((*ecx)), "=d" ((*edx)): "0" (op),
            "c" (count));
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_eax(unsigned int op ) 
{ unsigned int eax ;

  {
  __asm__  ("cpuid": "=a" (eax): "0" (op): "bx", "cx", "dx");
  return ((unsigned int __attribute__((__always_inline__))  )eax);
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_ebx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;

  {
  __asm__  ("cpuid": "=a" (eax), "=b" (ebx): "0" (op): "cx", "dx");
  return ((unsigned int __attribute__((__always_inline__))  )ebx);
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_ecx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ecx ;

  {
  __asm__  ("cpuid": "=a" (eax), "=c" (ecx): "0" (op): "bx", "dx");
  return ((unsigned int __attribute__((__always_inline__))  )ecx);
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_edx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int edx ;

  {
  __asm__  ("cpuid": "=a" (eax), "=d" (edx): "0" (op): "bx", "cx");
  return ((unsigned int __attribute__((__always_inline__))  )edx);
}
}
extern unsigned long mmu_cr4_features ;
__inline static void __attribute__((__always_inline__))  set_in_cr4(unsigned long mask ) 
{ 

  {
  mmu_cr4_features |= mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "orl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  clear_in_cr4(unsigned long mask ) 
{ 

  {
  mmu_cr4_features &= ~ mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "andl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (~ mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  __monitor(void const   *eax ,
                                                                   unsigned long ecx ,
                                                                   unsigned long edx ) 
{ 

  {
  __asm__  volatile   (".byte 0x0f,0x01,0xc8;": : "a" (eax), "c" (ecx), "d" (edx));
}
}
__inline static void __attribute__((__always_inline__))  __mwait(unsigned long eax ,
                                                                 unsigned long ecx ) 
{ 

  {
  __asm__  volatile   (".byte 0x0f,0x01,0xc9;": : "a" (eax), "c" (ecx));
}
}
extern unsigned int machine_id ;
extern unsigned int machine_submodel_id ;
extern unsigned int BIOS_revision ;
extern unsigned int mca_pentium_flag ;
extern int bootloader_type ;
__inline static void __attribute__((__always_inline__))  load_esp0(struct tss_struct *tss ,
                                                                   struct thread_struct *thread ) 
{ long tmp ;

  {
  tss->esp0 = thread->esp0;
  tmp = __builtin_expect((long )(! (! ((unsigned long )tss->ss1 != thread->sysenter_cs)) !=
                                 0), 0L);
  if (tmp) {
    tss->ss1 = (unsigned short )thread->sysenter_cs;
    __asm__  volatile   ("wrmsr": : "c" (372), "a" (thread->sysenter_cs), "d" (0));
  }
  return;
}
}
extern void release_thread(struct task_struct * ) ;
extern void prepare_to_copy(struct task_struct *tsk ) ;
extern int kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
extern unsigned long thread_saved_pc(struct task_struct *tsk ) ;
extern void show_trace(struct task_struct *task , unsigned long *stack ) ;
extern unsigned long get_wchan(struct task_struct *p ) ;
__inline static void __attribute__((__always_inline__))  rep_nop(void) 
{ 

  {
  __asm__  volatile   ("rep;nop": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  prefetch__extinline(void const   *x ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
}
}
__inline static void __attribute__((__always_inline__))  prefetchw__extinline(void const   *x ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchw (%1)"
                       "\n664:\n"
                       ".previous": : "i" (63), "r" (x));
}
}
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
extern unsigned long boot_option_idle_override ;
__inline static struct thread_info  __attribute__((__always_inline__)) *current_thread_info(void) 
{ struct thread_info *ti ;

  {
  __asm__  ("andl %%esp,%0; ": "=r" (ti): "0" (~ 8191));
  return ((struct thread_info  __attribute__((__always_inline__)) *)ti);
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__unused__))  ;
__inline static void __attribute__((__always_inline__))  set_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = current_thread_info();
  set_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = current_thread_info();
  clear_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return;
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = current_thread_info();
  tmp___0 = test_and_set_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = current_thread_info();
  tmp___0 = test_and_clear_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  test_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;

  {
  tmp___1 = current_thread_info();
  tmp___2 = variable_test_bit(flag, (unsigned long const volatile   *)(& tmp___1->flags));
  return (tmp___2);
}
}
__inline static void __attribute__((__always_inline__))  set_ti_thread_flag(struct thread_info *ti ,
                                                                            int flag ) 
{ 

  {
  set_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_ti_thread_flag(struct thread_info *ti ,
                                                                              int flag ) 
{ 

  {
  clear_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return;
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_ti_thread_flag(struct thread_info *ti ,
                                                                                    int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_ti_thread_flag(struct thread_info *ti ,
                                                                                      int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_clear_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_ti_thread_flag(struct thread_info *ti ,
                                                                            int flag ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  set_need_resched(void) 
{ 

  {
  set_thread_flag(3);
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_need_resched(void) 
{ 

  {
  clear_thread_flag(3);
  return;
}
}
__inline static void __attribute__((__always_inline__))  atomic_add(int i , atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "addl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  atomic_sub(int i , atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "subl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
__inline static int __attribute__((__always_inline__))  atomic_sub_and_test(int i ,
                                                                            atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "subl %2,%0; sete %1": "=m" (v->counter), "=qm" (c): "ir" (i),
                       "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )c);
}
}
__inline static void __attribute__((__always_inline__))  atomic_inc(atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "incl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  atomic_dec(atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "decl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static int __attribute__((__always_inline__))  atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "decl %0; sete %1": "=m" (v->counter), "=qm" (c): "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )((int )c != 0));
}
}
__inline static int __attribute__((__always_inline__))  atomic_inc_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "incl %0; sete %1": "=m" (v->counter), "=qm" (c): "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )((int )c != 0));
}
}
__inline static int __attribute__((__always_inline__))  atomic_add_negative(int i ,
                                                                            atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "addl %2,%0; sets %1": "=m" (v->counter), "=qm" (c): "ir" (i),
                       "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )c);
}
}
__inline static int __attribute__((__always_inline__))  atomic_add_return(int i ,
                                                                          atomic_t *v ) 
{ int __i ;

  {
  __i = i;
  __asm__  volatile   ("lock ; "
                       "xaddl %0, %1;": "=r" (i): "m" (v->counter), "0" (i));
  return ((int __attribute__((__always_inline__))  )(i + __i));
}
}
__inline static int __attribute__((__always_inline__))  atomic_sub_return(int i ,
                                                                          atomic_t *v ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = atomic_add_return(- i, v);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  _raw_spin_unlock(spinlock_t *lock ) 
{ char oldval ;

  {
  oldval = (char)1;
  __asm__  volatile   ("xchgb %b0, %1": "=q" (oldval), "=m" (lock->slock): "0" (oldval): "memory");
}
}
__inline static int __attribute__((__always_inline__))  _raw_spin_trylock(spinlock_t *lock ) 
{ char oldval ;

  {
  __asm__  volatile   ("xchgb %b0,%1": "=q" (oldval), "=m" (lock->slock): "0" (0): "memory");
  return ((int __attribute__((__always_inline__))  )((int )oldval > 0));
}
}
__inline static void __attribute__((__always_inline__))  _raw_spin_lock(spinlock_t *lock ) 
{ 

  {
  __asm__  volatile   ("\n1:\t"
                       "lock ; decb %0\n\t"
                       "jns 3f\n"
                       "2:\t"
                       "rep;nop\n\t"
                       "cmpb $0,%0\n\t"
                       "jle 2b\n\t"
                       "jmp 1b\n"
                       "3:\n\t": "=m" (lock->slock): : "memory");
}
}
__inline static void __attribute__((__always_inline__))  _raw_spin_lock_flags(spinlock_t *lock ,
                                                                              unsigned long flags ) 
{ 

  {
  __asm__  volatile   ("\n1:\t"
                       "lock ; decb %0\n\t"
                       "jns 4f\n\t"
                       "2:\t"
                       "testl $0x200, %1\n\t"
                       "jz 3f\n\t"
                       "sti\n\t"
                       "3:\t"
                       "rep;nop\n\t"
                       "cmpb $0, %0\n\t"
                       "jle 3b\n\t"
                       "cli\n\t"
                       "jmp 1b\n"
                       "4:\n\t": "=m" (lock->slock): "r" (flags): "memory");
}
}
__inline static void __attribute__((__always_inline__))  _raw_read_lock(rwlock_t *rw ) 
{ 

  {
  while (1) {
    __asm__  volatile   ("lock ; "
                         "subl $1,(%0)\n\t"
                         "jns 1f\n"
                         "call "
                         "__read_lock_failed"
                         "\n\t"
                         "1:\n": : "a" (rw): "memory");
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  _raw_write_lock(rwlock_t *rw ) 
{ 

  {
  while (1) {
    __asm__  volatile   ("lock ; "
                         "subl $"
                         "0x01000000"
                         ",(%0)\n\t"
                         "jz 1f\n"
                         "call "
                         "__write_lock_failed"
                         "\n\t"
                         "1:\n": : "a" (rw): "memory");
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  _raw_read_trylock(rwlock_t *lock ) 
{ atomic_t *count ;

  {
  count = (atomic_t *)lock;
  atomic_dec(count);
  if (count->counter >= 0) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  atomic_inc(count);
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  _raw_write_trylock(rwlock_t *lock ) 
{ atomic_t *count ;
  int __attribute__((__always_inline__))  tmp ;

  {
  count = (atomic_t *)lock;
  tmp = atomic_sub_and_test(16777216, count);
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  atomic_add(16777216, count);
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int ( __attribute__((__regparm__(3))) _spin_trylock)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) _read_trylock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) _write_trylock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_lock)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_lock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_lock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _spin_lock_irqsave)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _read_lock_irqsave)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _write_lock_irqsave)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_lock_irq)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_lock_bh)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_lock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_lock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_lock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_lock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock_irqrestore)(spinlock_t *lock ,
                                                                       unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock_irq)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock_bh)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_irqrestore)(rwlock_t *lock ,
                                                                       unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_irqrestore)(rwlock_t *lock ,
                                                                        unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) _spin_trylock_bh)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) generic_raw_read_trylock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int in_lock_functions(unsigned long addr ) ;
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
__inline static void __attribute__((__always_inline__))  bit_spin_lock(int bitnum ,
                                                                       unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  while (1) {
    break;
  }
  while (1) {
    tmp___1 = test_and_set_bit(bitnum, (unsigned long volatile   *)addr);
    if (! tmp___1) {
      break;
    }
    while (1) {
      tmp___0 = variable_test_bit(bitnum, (unsigned long const volatile   *)addr);
      if (! tmp___0) {
        break;
      }
      while (1) {
        break;
      }
      rep_nop();
      while (1) {
        break;
      }
    }
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  bit_spin_trylock(int bitnum ,
                                                                         unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = test_and_set_bit(bitnum, (unsigned long volatile   *)addr);
  if (tmp) {
    while (1) {
      break;
    }
    return ((int __attribute__((__always_inline__))  )0);
  }
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static void __attribute__((__always_inline__))  bit_spin_unlock(int bitnum ,
                                                                         unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  while (1) {
    tmp___0 = variable_test_bit(bitnum, (unsigned long const volatile   *)addr);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1 != 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    if (tmp___3) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (575), "i" ("include/linux/spinlock.h"));
    }
    break;
  }
  __asm__  volatile   ("": : : "memory");
  clear_bit(bitnum, (unsigned long volatile   *)addr);
  while (1) {
    break;
  }
}
}
__inline static int __attribute__((__always_inline__))  bit_spin_is_locked(int bitnum ,
                                                                           unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = variable_test_bit(bitnum, (unsigned long const volatile   *)addr);
  return (tmp___0);
}
}
extern kernel_cap_t cap_bset ;
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_combine(kernel_cap_t a ,
                                                                             kernel_cap_t b ) 
{ kernel_cap_t dest ;

  {
  dest = a | b;
  return (dest);
}
}
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_intersect(kernel_cap_t a ,
                                                                               kernel_cap_t b ) 
{ kernel_cap_t dest ;

  {
  dest = a & b;
  return (dest);
}
}
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_drop(kernel_cap_t a ,
                                                                          kernel_cap_t drop ) 
{ kernel_cap_t dest ;

  {
  dest = a & ~ drop;
  return (dest);
}
}
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_invert(kernel_cap_t c ) 
{ kernel_cap_t dest ;

  {
  dest = ~ c;
  return (dest);
}
}
__inline static void __attribute__((__always_inline__))  write_seqlock(seqlock_t *sl ) 
{ 

  {
  _spin_lock(& sl->lock);
  sl->sequence ++;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_sequnlock(seqlock_t *sl ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  sl->sequence ++;
  _spin_unlock(& sl->lock);
}
}
__inline static int __attribute__((__always_inline__))  write_tryseqlock(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  tmp = _spin_trylock(& sl->lock);
  ret = tmp;
  if (ret) {
    sl->sequence ++;
    __asm__  volatile   ("": : : "memory");
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static unsigned int __attribute__((__always_inline__))  read_seqbegin(seqlock_t const   *sl ) 
{ unsigned int ret ;

  {
  ret = (unsigned int )sl->sequence;
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((unsigned int __attribute__((__always_inline__))  )ret);
}
}
__inline static int __attribute__((__always_inline__))  read_seqretry(seqlock_t const   *sl ,
                                                                      unsigned int iv ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((int __attribute__((__always_inline__))  )((iv & 1U) | (unsigned int )(sl->sequence ^
                                                                                 (unsigned int const   )iv)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  read_seqcount_begin(seqcount_t const   *s ) 
{ unsigned int ret ;

  {
  ret = (unsigned int )s->sequence;
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((unsigned int __attribute__((__always_inline__))  )ret);
}
}
__inline static int __attribute__((__always_inline__))  read_seqcount_retry(seqcount_t const   *s ,
                                                                            unsigned int iv ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((int __attribute__((__always_inline__))  )((iv & 1U) | (unsigned int )(s->sequence ^
                                                                                 (unsigned int const   )iv)));
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_begin(seqcount_t *s ) 
{ 

  {
  s->sequence ++;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_end(seqcount_t *s ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  s->sequence ++;
}
}
__inline static int __attribute__((__always_inline__))  timespec_equal(struct timespec *a ,
                                                                       struct timespec *b ) 
{ int tmp ;

  {
  if (a->tv_sec == b->tv_sec) {
    if (a->tv_nsec == b->tv_nsec) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  mktime(unsigned int year ,
                                                                         unsigned int mon ,
                                                                         unsigned int day ,
                                                                         unsigned int hour ,
                                                                         unsigned int min ,
                                                                         unsigned int sec ) 
{ 

  {
  mon -= 2U;
  if (0 >= (int )mon) {
    mon += 12U;
    year --;
  }
  return ((unsigned long __attribute__((__always_inline__))  )((((((unsigned long )((((year /
                                                                                       4U -
                                                                                       year /
                                                                                       100U) +
                                                                                      year /
                                                                                      400U) +
                                                                                     (367U *
                                                                                      mon) /
                                                                                     12U) +
                                                                                    day) +
                                                                   (unsigned long )(year *
                                                                                    365U)) -
                                                                  719499UL) * 24UL +
                                                                 (unsigned long )hour) *
                                                                60UL + (unsigned long )min) *
                                                               60UL + (unsigned long )sec));
}
}
extern struct timespec xtime ;
extern struct timespec wall_to_monotonic ;
extern seqlock_t xtime_lock ;
__inline static unsigned long __attribute__((__always_inline__))  get_seconds(void) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )xtime.tv_sec);
}
}
extern struct timespec current_kernel_time(void) ;
extern void do_gettimeofday(struct timeval *tv ) ;
extern int do_settimeofday(struct timespec *tv ) ;
extern int do_sys_settimeofday(struct timespec *tv , struct timezone *tz ) ;
extern void clock_was_set(void) ;
extern int do_posix_clock_monotonic_gettime(struct timespec *tp ) ;
extern long do_nanosleep(struct timespec *t ) ;
extern long do_utimes(char *filename , struct timeval *times ) ;
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
extern int do_getitimer(int which , struct itimerval *value ) ;
extern void getnstimeofday(struct timespec *tv ) ;
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
__inline static void __attribute__((__always_inline__))  set_normalized_timespec(struct timespec *ts ,
                                                                                 time_t sec ,
                                                                                 long nsec ) 
{ 

  {
  while (nsec > 1000000000L) {
    nsec -= 1000000000L;
    sec ++;
  }
  while (nsec < 0L) {
    nsec += 1000000000L;
    sec --;
  }
  ts->tv_sec = sec;
  ts->tv_nsec = nsec;
  return;
}
}
__inline static cycles_t __attribute__((__always_inline__))  get_cycles(void) 
{ unsigned long long ret ;

  {
  ret = 0ULL;
  __asm__  volatile   ("rdtsc": "=A" (ret));
  return (ret);
}
}
extern unsigned long cpu_khz ;
extern unsigned long tick_usec ;
extern unsigned long tick_nsec ;
extern int tickadj ;
extern int time_state ;
extern int time_status ;
extern long time_offset ;
extern long time_constant ;
extern long time_tolerance ;
extern long time_precision ;
extern long time_maxerror ;
extern long time_esterror ;
extern long time_freq ;
extern long time_reftime ;
extern long time_adjust ;
extern long time_next_adjust ;
extern long pps_offset ;
extern long pps_jitter ;
extern long pps_freq ;
extern long pps_stabil ;
extern long pps_valid ;
extern int pps_shift ;
extern long pps_jitcnt ;
extern long pps_calcnt ;
extern long pps_errcnt ;
extern long pps_stbcnt ;
__inline static void __attribute__((__always_inline__))  time_interpolator_reset(void) 
{ 

  {
  return;
}
}
__inline static long __attribute__((__always_inline__))  div_ll_X_l_rem__extinline(long long divs ,
                                                                                   long div ,
                                                                                   long *rem ) 
{ long dum2 ;

  {
  __asm__  ("divl %2": "=a" (dum2), "=d" ((*rem)): "rm" (div), "A" (divs));
  return ((long __attribute__((__always_inline__))  )dum2);
}
}
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
extern u64 get_jiffies_64(void) ;
__inline static unsigned int __attribute__((__always_inline__))  jiffies_to_msecs(unsigned long j ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )j);
}
}
__inline static unsigned int __attribute__((__always_inline__))  jiffies_to_usecs(unsigned long j ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(1000UL * j));
}
}
__inline static unsigned long __attribute__((__always_inline__))  msecs_to_jiffies(unsigned int m ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = jiffies_to_msecs(2147483646UL);
  if (m > (unsigned int )tmp) {
    return ((unsigned long __attribute__((__always_inline__))  )2147483646UL);
  }
  return ((unsigned long __attribute__((__always_inline__))  )((m + 1U) - 1U));
}
}
__inline static unsigned long __attribute__((__always_inline__))  usecs_to_jiffies(unsigned int u ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = jiffies_to_usecs(2147483646UL);
  if (u > (unsigned int )tmp) {
    return ((unsigned long __attribute__((__always_inline__))  )2147483646UL);
  }
  return ((unsigned long __attribute__((__always_inline__))  )(((u + 1000U) - 1U) /
                                                               1000U));
}
}
__inline static unsigned long __attribute__((__always_inline__))  timespec_to_jiffies(struct timespec  const  *value ) 
{ unsigned long sec ;
  long nsec ;

  {
  sec = (unsigned long )value->tv_sec;
  nsec = (long )(((unsigned long )value->tv_nsec + 999848UL) - 1UL);
  if (sec >= 2147157UL) {
    sec = 2147157UL;
    nsec = 0L;
  }
  return ((unsigned long __attribute__((__always_inline__))  )(((unsigned long long )sec *
                                                                4194941632ULL + ((unsigned long long )nsec *
                                                                                 2252142140ULL >>
                                                                                 29)) >>
                                                               22));
}
}
__inline static void __attribute__((__always_inline__))  jiffies_to_timespec(unsigned long jiffies___0 ,
                                                                             struct timespec *value ) 
{ u64 nsec ;

  {
  nsec = (unsigned long long )jiffies___0 * 999848ULL;
  value->tv_sec = (time_t )div_ll_X_l_rem__extinline((long long )nsec, 1000000000L,
                                                     & value->tv_nsec);
  return;
}
}
__inline static unsigned long __attribute__((__always_inline__))  timeval_to_jiffies(struct timeval  const  *value ) 
{ unsigned long sec ;
  long usec ;

  {
  sec = (unsigned long )value->tv_sec;
  usec = (long )value->tv_usec;
  if (sec >= 2147157UL) {
    sec = 2147157UL;
    usec = 0L;
  }
  return ((unsigned long __attribute__((__always_inline__))  )(((unsigned long long )sec *
                                                                4194941632ULL + (((unsigned long long )usec *
                                                                                  2199357558ULL +
                                                                                  2199023255551ULL) >>
                                                                                 19)) >>
                                                               22));
}
}
__inline static void __attribute__((__always_inline__))  jiffies_to_timeval(unsigned long jiffies___0 ,
                                                                            struct timeval *value ) 
{ u64 nsec ;

  {
  nsec = (unsigned long long )jiffies___0 * 999848ULL;
  value->tv_sec = (time_t )div_ll_X_l_rem__extinline((long long )nsec, 1000000000L,
                                                     & value->tv_usec);
  value->tv_usec /= 1000L;
  return;
}
}
__inline static clock_t __attribute__((__always_inline__))  jiffies_to_clock_t(long x ) 
{ u64 tmp ;
  unsigned long __upper ;
  unsigned long __low ;
  unsigned long __high ;
  unsigned long __mod ;
  unsigned long __base ;

  {
  tmp = (unsigned long long )x * 999848ULL;
  __base = 10000000UL;
  __asm__  ("": "=a" (__low), "=d" (__high): "A" (tmp));
  __upper = __high;
  if (__high) {
    __upper = __high % __base;
    __high = __high / __base;
  }
  __asm__  ("divl %2": "=a" (__low), "=d" (__mod): "rm" (__base), "0" (__low), "1" (__upper));
  __asm__  ("": "=A" (tmp): "a" (__low), "d" (__high));
  return ((long )tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  clock_t_to_jiffies(unsigned long x ) 
{ 

  {
  if (x >= 429496729UL) {
    return ((unsigned long __attribute__((__always_inline__))  )(~ 0UL));
  }
  return ((unsigned long __attribute__((__always_inline__))  )(x * 10UL));
}
}
__inline static u64 __attribute__((__always_inline__))  jiffies_64_to_clock_t(u64 x ) 
{ unsigned long __upper ;
  unsigned long __low ;
  unsigned long __high ;
  unsigned long __mod ;
  unsigned long __base ;

  {
  x *= 999848ULL;
  __base = 10000000UL;
  __asm__  ("": "=a" (__low), "=d" (__high): "A" (x));
  __upper = __high;
  if (__high) {
    __upper = __high % __base;
    __high = __high / __base;
  }
  __asm__  ("divl %2": "=a" (__low), "=d" (__mod): "rm" (__base), "0" (__low), "1" (__upper));
  __asm__  ("": "=A" (x): "a" (__low), "d" (__high));
  return (x);
}
}
__inline static u64 __attribute__((__always_inline__))  nsec_to_clock_t(u64 x ) 
{ unsigned long __upper ;
  unsigned long __low ;
  unsigned long __high ;
  unsigned long __mod ;
  unsigned long __base ;

  {
  __base = 10000000UL;
  __asm__  ("": "=a" (__low), "=d" (__high): "A" (x));
  __upper = __high;
  if (__high) {
    __upper = __high % __base;
    __high = __high / __base;
  }
  __asm__  ("divl %2": "=a" (__low), "=d" (__mod): "rm" (__base), "0" (__low), "1" (__upper));
  __asm__  ("": "=A" (x): "a" (__low), "d" (__high));
  return (x);
}
}
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
extern struct rb_node *rb_next(struct rb_node * ) ;
extern struct rb_node *rb_prev(struct rb_node * ) ;
extern struct rb_node *rb_first(struct rb_root * ) ;
extern struct rb_node *rb_last(struct rb_root * ) ;
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
__inline static void __attribute__((__always_inline__))  rb_link_node(struct rb_node *node ,
                                                                      struct rb_node *parent ,
                                                                      struct rb_node **rb_link ) 
{ 

  {
  node->rb_parent = parent;
  node->rb_color = 0;
  node->rb_right = (struct rb_node *)((void *)0);
  node->rb_left = node->rb_right;
  (*rb_link) = node;
  return;
}
}
extern char *strpbrk(char const   * , char const   * ) ;
extern char *strsep(char ** , char const   * ) ;
extern __kernel_size_t strspn(char const   * , char const   * ) ;
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
__inline static char __attribute__((__always_inline__))  *strcpy(char *dest , char const   *src ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  __asm__  volatile   ("1:\tlodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b": "=&S" (d0), "=&D" (d1), "=&a" (d2): "0" (src), "1" (dest): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static char __attribute__((__always_inline__))  *strncpy(char *dest , char const   *src ,
                                                                  size_t count ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;

  {
  __asm__  volatile   ("1:\tdecl %2\n\t"
                       "js 2f\n\t"
                       "lodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n\t"
                       "rep\n\t"
                       "stosb\n"
                       "2:": "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3): "0" (src),
                       "1" (dest), "2" (count): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static char __attribute__((__always_inline__))  *strcat(char *dest , char const   *src ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;

  {
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "decl %1\n"
                       "1:\tlodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b": "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3): "0" (src),
                       "1" (dest), "2" (0), "3" (4294967295U): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static char __attribute__((__always_inline__))  *strncat(char *dest , char const   *src ,
                                                                  size_t count ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;

  {
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "decl %1\n\t"
                       "movl %8,%3\n"
                       "1:\tdecl %3\n\t"
                       "js 2f\n\t"
                       "lodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n"
                       "2:\txorl %2,%2\n\t"
                       "stosb": "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3): "0" (src),
                       "1" (dest), "2" (0), "3" (4294967295U), "g" (count): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static int __attribute__((__always_inline__))  strcmp(char const   *cs ,
                                                               char const   *ct ) 
{ int d0 ;
  int d1 ;
  register int __res ;

  {
  __asm__  volatile   ("1:\tlodsb\n\t"
                       "scasb\n\t"
                       "jne 2f\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n\t"
                       "xorl %%eax,%%eax\n\t"
                       "jmp 3f\n"
                       "2:\tsbbl %%eax,%%eax\n\t"
                       "orb $1,%%al\n"
                       "3:": "=a" (__res), "=&S" (d0), "=&D" (d1): "1" (cs), "2" (ct));
  return ((int __attribute__((__always_inline__))  )__res);
}
}
__inline static int __attribute__((__always_inline__))  strncmp(char const   *cs ,
                                                                char const   *ct ,
                                                                size_t count ) 
{ register int __res ;
  int d0 ;
  int d1 ;
  int d2 ;

  {
  __asm__  volatile   ("1:\tdecl %3\n\t"
                       "js 2f\n\t"
                       "lodsb\n\t"
                       "scasb\n\t"
                       "jne 3f\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n"
                       "2:\txorl %%eax,%%eax\n\t"
                       "jmp 4f\n"
                       "3:\tsbbl %%eax,%%eax\n\t"
                       "orb $1,%%al\n"
                       "4:": "=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2): "1" (cs),
                       "2" (ct), "3" (count));
  return ((int __attribute__((__always_inline__))  )__res);
}
}
__inline static char __attribute__((__always_inline__))  *strchr(char const   *s ,
                                                                 int c ) 
{ int d0 ;
  register char *__res ;

  {
  __asm__  volatile   ("movb %%al,%%ah\n"
                       "1:\tlodsb\n\t"
                       "cmpb %%ah,%%al\n\t"
                       "je 2f\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n\t"
                       "movl $1,%1\n"
                       "2:\tmovl %1,%0\n\t"
                       "decl %0": "=a" (__res), "=&S" (d0): "1" (s), "0" (c));
  return ((char __attribute__((__always_inline__))  *)__res);
}
}
__inline static char __attribute__((__always_inline__))  *strrchr(char const   *s ,
                                                                  int c ) 
{ int d0 ;
  int d1 ;
  register char *__res ;

  {
  __asm__  volatile   ("movb %%al,%%ah\n"
                       "1:\tlodsb\n\t"
                       "cmpb %%ah,%%al\n\t"
                       "jne 2f\n\t"
                       "leal -1(%%esi),%0\n"
                       "2:\ttestb %%al,%%al\n\t"
                       "jne 1b": "=g" (__res), "=&S" (d0), "=&a" (d1): "0" (0), "1" (s),
                       "2" (c));
  return ((char __attribute__((__always_inline__))  *)__res);
}
}
__inline static size_t __attribute__((__always_inline__))  strlen(char const   *s ) 
{ int d0 ;
  register int __res ;

  {
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "notl %0\n\t"
                       "decl %0": "=c" (__res), "=&D" (d0): "1" (s), "a" (0), "0" (4294967295U));
  return ((unsigned int )__res);
}
}
__inline static void __attribute__((__always_inline__))  *__memcpy(void *to , void const   *from ,
                                                                   size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
}
}
__inline static void __attribute__((__always_inline__))  *__constant_memcpy(void *to ,
                                                                            void const   *from ,
                                                                            size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
  if (! n) {
    return ((void __attribute__((__always_inline__))  *)to);
  }
  switch ((int )n) {
  case 1: 
  (*((char *)to)) = (*((char *)from));
  return ((void __attribute__((__always_inline__))  *)to);
  case 2: 
  (*((short *)to)) = (*((short *)from));
  return ((void __attribute__((__always_inline__))  *)to);
  case 4: 
  (*((int *)to)) = (*((int *)from));
  return ((void __attribute__((__always_inline__))  *)to);
  case 3: 
  (*((short *)to)) = (*((short *)from));
  (*((char *)to + 2)) = (*((char *)from + 2));
  return ((void __attribute__((__always_inline__))  *)to);
  case 5: 
  (*((int *)to)) = (*((int *)from));
  (*((char *)to + 4)) = (*((char *)from + 4));
  return ((void __attribute__((__always_inline__))  *)to);
  case 6: 
  (*((int *)to)) = (*((int *)from));
  (*((short *)to + 2)) = (*((short *)from + 2));
  return ((void __attribute__((__always_inline__))  *)to);
  case 8: 
  (*((int *)to)) = (*((int *)from));
  (*((int *)to + 1)) = (*((int *)from + 1));
  return ((void __attribute__((__always_inline__))  *)to);
  }
  esi = (long )from;
  edi = (long )to;
  if (n >= 20U) {
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n /
                                                                                    4U),
                         "1" (edi), "2" (esi): "memory");
  } else {
    if (n >= 16U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
    if (n >= 12U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
    if (n >= 8U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
    if (n >= 4U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
  }
  switch ((int )(n % 4U)) {
  case 0: ;
  return ((void __attribute__((__always_inline__))  *)to);
  case 1: 
  __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
  case 2: 
  __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
  default: 
  __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
  }
}
}
extern void *memmove(void *dest , void const   *src , size_t n ) ;
__inline static void __attribute__((__always_inline__))  *memchr(void const   *cs ,
                                                                 int c , size_t count ) 
{ int d0 ;
  register void *__res ;

  {
  if (! count) {
    return ((void __attribute__((__always_inline__))  *)((void *)0));
  }
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "je 1f\n\t"
                       "movl $1,%0\n"
                       "1:\tdecl %0": "=D" (__res), "=&c" (d0): "a" (c), "0" (cs),
                       "1" (count));
  return ((void __attribute__((__always_inline__))  *)__res);
}
}
__inline static void __attribute__((__always_inline__))  *__memset_generic(void *s ,
                                                                           char c ,
                                                                           size_t count ) 
{ int d0 ;
  int d1 ;

  {
  __asm__  volatile   ("rep\n\t"
                       "stosb": "=&c" (d0), "=&D" (d1): "a" (c), "1" (s), "0" (count): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
}
}
__inline static void __attribute__((__always_inline__))  *__constant_c_memset(void *s ,
                                                                              unsigned long c ,
                                                                              size_t count ) 
{ int d0 ;
  int d1 ;

  {
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count /
                                                                                4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
}
}
__inline static size_t __attribute__((__always_inline__))  strnlen(char const   *s ,
                                                                   size_t count ) 
{ int d0 ;
  register int __res ;

  {
  __asm__  volatile   ("movl %2,%0\n\t"
                       "jmp 2f\n"
                       "1:\tcmpb $0,(%0)\n\t"
                       "je 3f\n\t"
                       "incl %0\n"
                       "2:\tdecl %1\n\t"
                       "cmpl $-1,%1\n\t"
                       "jne 1b\n"
                       "3:\tsubl %2,%0": "=a" (__res), "=&d" (d0): "c" (s), "1" (count));
  return ((unsigned int )__res);
}
}
extern char *strstr(char const   *cs , char const   *ct ) ;
__inline static void __attribute__((__always_inline__))  *__constant_c_and_count_memset(void *s ,
                                                                                        unsigned long pattern ,
                                                                                        size_t count ) 
{ int d0 ;
  int d1 ;

  {
  switch ((int )count) {
  case 0: ;
  return ((void __attribute__((__always_inline__))  *)s);
  case 1: 
  (*((unsigned char *)s)) = (unsigned char )pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  case 2: 
  (*((unsigned short *)s)) = (unsigned short )pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  case 3: 
  (*((unsigned short *)s)) = (unsigned short )pattern;
  (*((unsigned char *)s + 2)) = (unsigned char )pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  case 4: 
  (*((unsigned long *)s)) = pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  }
  switch ((int )(count % 4U)) {
  case 0: 
  __asm__  volatile   ("rep ; stosl"
                       "": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count / 4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  case 1: 
  __asm__  volatile   ("rep ; stosl"
                       "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count /
                                                                                4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  case 2: 
  __asm__  volatile   ("rep ; stosl"
                       "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count /
                                                                                4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  default: 
  __asm__  volatile   ("rep ; stosl"
                       "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (pattern),
                       "0" (count / 4U), "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  }
}
}
__inline static void __attribute__((__always_inline__))  *memscan(void *addr , int c ,
                                                                  size_t size ) 
{ 

  {
  if (! size) {
    return ((void __attribute__((__always_inline__))  *)addr);
  }
  __asm__  ("repnz; scasb\n\t"
            "jnz 1f\n\t"
            "dec %%edi\n"
            "1:": "=D" (addr), "=c" (size): "0" (addr), "1" (size), "a" (c));
  return ((void __attribute__((__always_inline__))  *)addr);
}
}
extern size_t strlcpy(char * , char const   * , size_t  ) ;
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
extern char *strnchr(char const   * , size_t  , int  ) ;
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
extern int __bitmap_empty(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_full(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          int bits ) ;
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                int bits ) ;
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
extern void __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 ,
                            unsigned long const   *bitmap2 , int bits ) ;
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               int bits ) ;
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
extern int __bitmap_weight(unsigned long const   *bitmap , int bits ) ;
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
extern int bitmap_parse(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                        int nbits ) ;
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
extern int bitmap_find_free_region(unsigned long *bitmap , int bits , int order ) ;
extern void bitmap_release_region(unsigned long *bitmap , int pos , int order ) ;
extern int bitmap_allocate_region(unsigned long *bitmap , int pos , int order ) ;
__inline static void __attribute__((__always_inline__))  bitmap_zero(unsigned long *dst ,
                                                                     int nbits ) 
{ int len ;

  {
  if (nbits <= 32) {
    (*dst) = 0UL;
  } else {
    len = (int )((unsigned int )(((nbits + 32) - 1) / 32) * sizeof(unsigned long ));
    __constant_c_memset((void *)dst, 0UL, (unsigned int )len);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_fill(unsigned long *dst ,
                                                                     int nbits ) 
{ size_t nlongs ;
  int len ;

  {
  nlongs = (size_t )(((nbits + 32) - 1) / 32);
  if (nlongs > 1U) {
    len = (int )((nlongs - 1U) * sizeof(unsigned long ));
    __constant_c_memset((void *)dst, 4294967295UL, (unsigned int )len);
  }
  if (nbits % 32) {
    (*(dst + (nlongs - 1U))) = (1UL << nbits % 32) - 1UL;
  } else {
    (*(dst + (nlongs - 1U))) = ~ 0UL;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_copy(unsigned long *dst ,
                                                                     unsigned long const   *src ,
                                                                     int nbits ) 
{ int len ;

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )(*src);
  } else {
    len = (int )((unsigned int )(((nbits + 32) - 1) / 32) * sizeof(unsigned long ));
    __memcpy((void *)dst, (void const   *)src, (unsigned int )len);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_and(unsigned long *dst ,
                                                                    unsigned long const   *src1 ,
                                                                    unsigned long const   *src2 ,
                                                                    int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) & (*src2));
  } else {
    __bitmap_and(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_or(unsigned long *dst ,
                                                                   unsigned long const   *src1 ,
                                                                   unsigned long const   *src2 ,
                                                                   int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) | (*src2));
  } else {
    __bitmap_or(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_xor(unsigned long *dst ,
                                                                    unsigned long const   *src1 ,
                                                                    unsigned long const   *src2 ,
                                                                    int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) ^ (*src2));
  } else {
    __bitmap_xor(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_andnot(unsigned long *dst ,
                                                                       unsigned long const   *src1 ,
                                                                       unsigned long const   *src2 ,
                                                                       int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) & ~ (*src2));
  } else {
    __bitmap_andnot(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_complement(unsigned long *dst ,
                                                                           unsigned long const   *src ,
                                                                           int nbits ) 
{ unsigned long tmp ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    (*dst) = (unsigned long )(~ (*src) & (unsigned long const   )tmp);
  } else {
    __bitmap_complement(dst, src, nbits);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  bitmap_equal(unsigned long const   *src1 ,
                                                                     unsigned long const   *src2 ,
                                                                     int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if (((*src1) ^ (*src2)) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_equal(src1, src2,
                                                                       nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_intersects(unsigned long const   *src1 ,
                                                                          unsigned long const   *src2 ,
                                                                          int nbits ) 
{ unsigned long tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    return ((int __attribute__((__always_inline__))  )((((*src1) & (*src2)) & (unsigned long const   )tmp) !=
                                                       0UL));
  } else {
    tmp___0 = (int __attribute__((__always_inline__))  )__bitmap_intersects(src1,
                                                                            src2,
                                                                            nbits);
    return (tmp___0);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_subset(unsigned long const   *src1 ,
                                                                      unsigned long const   *src2 ,
                                                                      int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if (((*src1) & ~ (*src2)) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_subset(src1, src2,
                                                                        nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_empty(unsigned long const   *src ,
                                                                     int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if ((*src) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_empty(src, nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_full(unsigned long const   *src ,
                                                                    int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if (~ (*src) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_full(src, nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_weight(unsigned long const   *src ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )__bitmap_weight(src, nbits);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  bitmap_shift_right(unsigned long *dst ,
                                                                            unsigned long const   *src ,
                                                                            int n ,
                                                                            int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src) >> n);
  } else {
    __bitmap_shift_right(dst, src, n, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_shift_left(unsigned long *dst ,
                                                                           unsigned long const   *src ,
                                                                           int n ,
                                                                           int nbits ) 
{ unsigned long tmp ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    (*dst) = (unsigned long )(((*src) << n) & (unsigned long const   )tmp);
  } else {
    __bitmap_shift_left(dst, src, n, nbits);
  }
  return;
}
}
extern cpumask_t _unused_cpumask_arg_ ;
__inline static void __attribute__((__always_inline__))  __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  set_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  clear_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_setall(cpumask_t *dstp ,
                                                                       int nbits ) 
{ 

  {
  bitmap_fill(dstp->bits, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_clear(cpumask_t *dstp ,
                                                                      int nbits ) 
{ 

  {
  bitmap_zero(dstp->bits, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __cpu_test_and_set(int cpu ,
                                                                           cpumask_t *addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(cpu, (unsigned long volatile   *)(addr->bits));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __cpus_and(cpumask_t *dstp ,
                                                                    cpumask_t const   *src1p ,
                                                                    cpumask_t const   *src2p ,
                                                                    int nbits ) 
{ 

  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_or(cpumask_t *dstp ,
                                                                   cpumask_t const   *src1p ,
                                                                   cpumask_t const   *src2p ,
                                                                   int nbits ) 
{ 

  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_xor(cpumask_t *dstp ,
                                                                    cpumask_t const   *src1p ,
                                                                    cpumask_t const   *src2p ,
                                                                    int nbits ) 
{ 

  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_andnot(cpumask_t *dstp ,
                                                                       cpumask_t const   *src1p ,
                                                                       cpumask_t const   *src2p ,
                                                                       int nbits ) 
{ 

  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_complement(cpumask_t *dstp ,
                                                                           cpumask_t const   *srcp ,
                                                                           int nbits ) 
{ 

  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __cpus_equal(cpumask_t const   *src1p ,
                                                                     cpumask_t const   *src2p ,
                                                                     int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_intersects(cpumask_t const   *src1p ,
                                                                          cpumask_t const   *src2p ,
                                                                          int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_subset(cpumask_t const   *src1p ,
                                                                      cpumask_t const   *src2p ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_empty(cpumask_t const   *srcp ,
                                                                     int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_full(cpumask_t const   *srcp ,
                                                                    int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_weight(cpumask_t const   *srcp ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __cpus_shift_right(cpumask_t *dstp ,
                                                                            cpumask_t const   *srcp ,
                                                                            int n ,
                                                                            int nbits ) 
{ 

  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_shift_left(cpumask_t *dstp ,
                                                                           cpumask_t const   *srcp ,
                                                                           int n ,
                                                                           int nbits ) 
{ 

  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __first_cpu(cpumask_t const   *srcp ,
                                                                    int nbits ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = nbits;
  tmp = (int )find_first_bit((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __next_cpu(int n , cpumask_t const   *srcp ,
                                                                   int nbits ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = nbits;
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), nbits, n + 1);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __cpumask_scnprintf(char *buf ,
                                                                            int len ,
                                                                            cpumask_t const   *srcp ,
                                                                            int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnprintf(buf, (unsigned int )len,
                                                                   (unsigned long const   *)(srcp->bits),
                                                                   nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpumask_parse(char const   *buf ,
                                                                        int len ,
                                                                        cpumask_t *dstp ,
                                                                        int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parse(buf, (unsigned int )len,
                                                               dstp->bits, nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpulist_scnprintf(char *buf ,
                                                                            int len ,
                                                                            cpumask_t const   *srcp ,
                                                                            int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnlistprintf(buf, (unsigned int )len,
                                                                       (unsigned long const   *)(srcp->bits),
                                                                       nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpulist_parse(char const   *buf ,
                                                                        cpumask_t *dstp ,
                                                                        int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parselist(buf, dstp->bits,
                                                                   nbits);
  return (tmp);
}
}
extern cpumask_t cpu_possible_map ;
extern cpumask_t cpu_online_map ;
extern cpumask_t cpu_present_map ;
extern nodemask_t _unused_nodemask_arg_ ;
__inline static void __attribute__((__always_inline__))  __node_set(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  set_bit(node, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  clear_bit(node, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_setall(nodemask_t *dstp ,
                                                                        int nbits ) 
{ 

  {
  bitmap_fill(dstp->bits, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_clear(nodemask_t *dstp ,
                                                                       int nbits ) 
{ 

  {
  bitmap_zero(dstp->bits, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __node_test_and_set(int node ,
                                                                            nodemask_t *addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(node, (unsigned long volatile   *)(addr->bits));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __nodes_and(nodemask_t *dstp ,
                                                                     nodemask_t const   *src1p ,
                                                                     nodemask_t const   *src2p ,
                                                                     int nbits ) 
{ 

  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_or(nodemask_t *dstp ,
                                                                    nodemask_t const   *src1p ,
                                                                    nodemask_t const   *src2p ,
                                                                    int nbits ) 
{ 

  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_xor(nodemask_t *dstp ,
                                                                     nodemask_t const   *src1p ,
                                                                     nodemask_t const   *src2p ,
                                                                     int nbits ) 
{ 

  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_andnot(nodemask_t *dstp ,
                                                                        nodemask_t const   *src1p ,
                                                                        nodemask_t const   *src2p ,
                                                                        int nbits ) 
{ 

  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_complement(nodemask_t *dstp ,
                                                                            nodemask_t const   *srcp ,
                                                                            int nbits ) 
{ 

  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __nodes_equal(nodemask_t const   *src1p ,
                                                                      nodemask_t const   *src2p ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_intersects(nodemask_t const   *src1p ,
                                                                           nodemask_t const   *src2p ,
                                                                           int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_subset(nodemask_t const   *src1p ,
                                                                       nodemask_t const   *src2p ,
                                                                       int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_empty(nodemask_t const   *srcp ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_full(nodemask_t const   *srcp ,
                                                                     int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_weight(nodemask_t const   *srcp ,
                                                                       int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __nodes_shift_right(nodemask_t *dstp ,
                                                                             nodemask_t const   *srcp ,
                                                                             int n ,
                                                                             int nbits ) 
{ 

  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_shift_left(nodemask_t *dstp ,
                                                                            nodemask_t const   *srcp ,
                                                                            int n ,
                                                                            int nbits ) 
{ 

  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __first_node(nodemask_t const   *srcp ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = 1;
  tmp = (int )find_first_bit((unsigned long const   *)(srcp->bits), 1U);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __next_node(int n , nodemask_t const   *srcp ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = 1;
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 1, n + 1);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __first_unset_node(nodemask_t const   *maskp ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = 1;
  tmp = (int )find_first_zero_bit((unsigned long const   *)(maskp->bits), 1U);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __nodemask_scnprintf(char *buf ,
                                                                             int len ,
                                                                             nodemask_t const   *srcp ,
                                                                             int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnprintf(buf, (unsigned int )len,
                                                                   (unsigned long const   *)(srcp->bits),
                                                                   nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodemask_parse(char const   *buf ,
                                                                         int len ,
                                                                         nodemask_t *dstp ,
                                                                         int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parse(buf, (unsigned int )len,
                                                               dstp->bits, nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodelist_scnprintf(char *buf ,
                                                                             int len ,
                                                                             nodemask_t const   *srcp ,
                                                                             int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnlistprintf(buf, (unsigned int )len,
                                                                       (unsigned long const   *)(srcp->bits),
                                                                       nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodelist_parse(char const   *buf ,
                                                                         nodemask_t *dstp ,
                                                                         int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parselist(buf, dstp->bits,
                                                                   nbits);
  return (tmp);
}
}
extern nodemask_t node_online_map ;
extern nodemask_t node_possible_map ;
__inline static void __attribute__((__always_inline__))  prefetch_range(void *addr ,
                                                                        size_t len ) 
{ char *cp ;
  char *end ;

  {
  end = (char *)(addr + len);
  cp = (char *)addr;
  while ((unsigned int )cp < (unsigned int )end) {
    prefetch__extinline((void const   *)cp);
    cp += 128;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  __list_add(struct list_head *new ,
                                                                    struct list_head *prev ,
                                                                    struct list_head *next ) 
{ 

  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_add(struct list_head *new ,
                                                                  struct list_head *head ) 
{ 

  {
  __list_add(new, head, head->next);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_add_tail(struct list_head *new ,
                                                                       struct list_head *head ) 
{ 

  {
  __list_add(new, head->prev, head);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __list_add_rcu(struct list_head *new ,
                                                                        struct list_head *prev ,
                                                                        struct list_head *next ) 
{ 

  {
  new->next = next;
  new->prev = prev;
  __asm__  volatile   ("": : : "memory");
  next->prev = new;
  prev->next = new;
}
}
__inline static void __attribute__((__always_inline__))  list_add_rcu(struct list_head *new ,
                                                                      struct list_head *head ) 
{ 

  {
  __list_add_rcu(new, head, head->next);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_add_tail_rcu(struct list_head *new ,
                                                                           struct list_head *head ) 
{ 

  {
  __list_add_rcu(new, head->prev, head);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __list_del(struct list_head *prev ,
                                                                    struct list_head *next ) 
{ 

  {
  next->prev = prev;
  prev->next = next;
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_del(struct list_head *entry ) 
{ 

  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_del_rcu(struct list_head *entry ) 
{ 

  {
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_head *)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_replace_rcu(struct list_head *old ,
                                                                          struct list_head *new ) 
{ 

  {
  new->next = old->next;
  new->prev = old->prev;
  __asm__  volatile   ("": : : "memory");
  (new->next)->prev = new;
  (new->prev)->next = new;
}
}
__inline static void __attribute__((__always_inline__))  list_del_init(struct list_head *entry ) 
{ 

  {
  __list_del(entry->prev, entry->next);
  while (1) {
    entry->next = entry;
    entry->prev = entry;
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_move(struct list_head *list ,
                                                                   struct list_head *head ) 
{ 

  {
  __list_del(list->prev, list->next);
  list_add(list, head);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_move_tail(struct list_head *list ,
                                                                        struct list_head *head ) 
{ 

  {
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
  return;
}
}
__inline static int __attribute__((__always_inline__))  list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )head->next ==
                                                     (unsigned int )head));
}
}
__inline static int __attribute__((__always_inline__))  list_empty_careful(struct list_head  const  *head ) 
{ struct list_head *next ;
  int tmp ;

  {
  next = (struct list_head *)head->next;
  if ((unsigned int )next == (unsigned int )head) {
    if ((unsigned int )next == (unsigned int )head->prev) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static void __attribute__((__always_inline__))  __list_splice(struct list_head *list ,
                                                                       struct list_head *head ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;

  {
  first = list->next;
  last = list->prev;
  at = head->next;
  first->prev = head;
  head->next = first;
  last->next = at;
  at->prev = last;
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_splice(struct list_head *list ,
                                                                     struct list_head *head ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = list_empty((struct list_head  const  *)list);
  if (! tmp) {
    __list_splice(list, head);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_splice_init(struct list_head *list ,
                                                                          struct list_head *head ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = list_empty((struct list_head  const  *)list);
  if (! tmp) {
    __list_splice(list, head);
    while (1) {
      list->next = list;
      list->prev = list;
      break;
    }
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  hlist_unhashed(struct hlist_node  const  *h ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! h->pprev != 0));
}
}
__inline static int __attribute__((__always_inline__))  hlist_empty(struct hlist_head  const  *h ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! h->first != 0));
}
}
__inline static void __attribute__((__always_inline__))  __hlist_del(struct hlist_node *n ) 
{ struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  next = n->next;
  pprev = n->pprev;
  (*pprev) = next;
  if (next) {
    next->pprev = pprev;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_del(struct hlist_node *n ) 
{ 

  {
  __hlist_del(n);
  n->next = (struct hlist_node *)((void *)1048832);
  n->pprev = (struct hlist_node **)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_del_rcu(struct hlist_node *n ) 
{ 

  {
  __hlist_del(n);
  n->pprev = (struct hlist_node **)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_del_init(struct hlist_node *n ) 
{ 

  {
  if (n->pprev) {
    __hlist_del(n);
    n->next = (struct hlist_node *)((void *)0);
    n->pprev = (struct hlist_node **)((void *)0);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_head(struct hlist_node *n ,
                                                                        struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  first = h->first;
  n->next = first;
  if (first) {
    first->pprev = & n->next;
  }
  h->first = n;
  n->pprev = & h->first;
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_head_rcu(struct hlist_node *n ,
                                                                            struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  first = h->first;
  n->next = first;
  n->pprev = & h->first;
  __asm__  volatile   ("": : : "memory");
  if (first) {
    first->pprev = & n->next;
  }
  h->first = n;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_before(struct hlist_node *n ,
                                                                          struct hlist_node *next ) 
{ 

  {
  n->pprev = next->pprev;
  n->next = next;
  next->pprev = & n->next;
  (*(n->pprev)) = n;
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_after(struct hlist_node *n ,
                                                                         struct hlist_node *next ) 
{ 

  {
  next->next = n->next;
  n->next = next;
  next->pprev = & n->next;
  if (next->next) {
    (next->next)->pprev = & next->next;
  }
  return;
}
}
__inline static struct task_struct  __attribute__((__always_inline__)) *get_current(void) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = current_thread_info();
  return ((struct task_struct  __attribute__((__always_inline__)) *)tmp->task);
}
}
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
__inline static void __attribute__((__always_inline__))  init_waitqueue_head(wait_queue_head_t *q ) 
{ spinlock_t __constr_expr_0 ;

  {
  while (1) {
    spin_lock_init(&__constr_expr_0);
    q->lock = __constr_expr_0;
    break;
  }
  while (1) {
    q->task_list.next = & q->task_list;
    q->task_list.prev = & q->task_list;
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_waitqueue_entry(wait_queue_t *q ,
                                                                              struct task_struct *p ) 
{ 

  {
  q->flags = 0U;
  q->task = p;
  q->func = & default_wake_function;
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_waitqueue_func_entry(wait_queue_t *q ,
                                                                                   int (*func)(wait_queue_t *wait ,
                                                                                               unsigned int mode ,
                                                                                               int sync ,
                                                                                               void *key ) ) 
{ 

  {
  q->flags = 0U;
  q->task = (struct task_struct *)((void *)0);
  q->func = func;
  return;
}
}
__inline static int __attribute__((__always_inline__))  waitqueue_active(wait_queue_head_t *q ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
extern void ( __attribute__((__regparm__(3))) add_wait_queue)(wait_queue_head_t *q ,
                                                              wait_queue_t *wait ) ;
extern void ( __attribute__((__regparm__(3))) add_wait_queue_exclusive)(wait_queue_head_t *q ,
                                                                        wait_queue_t *wait ) ;
extern void ( __attribute__((__regparm__(3))) remove_wait_queue)(wait_queue_head_t *q ,
                                                                 wait_queue_t *wait ) ;
__inline static void __attribute__((__always_inline__))  __add_wait_queue(wait_queue_head_t *head ,
                                                                          wait_queue_t *new ) 
{ 

  {
  list_add(& new->task_list, & head->task_list);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __add_wait_queue_tail(wait_queue_head_t *head ,
                                                                               wait_queue_t *new ) 
{ 

  {
  list_add_tail(& new->task_list, & head->task_list);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __remove_wait_queue(wait_queue_head_t *head ,
                                                                             wait_queue_t *old ) 
{ 

  {
  list_del(& old->task_list);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __wake_up)(wait_queue_head_t *q , unsigned int mode ,
                                                         int nr , void *key ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up_locked)(wait_queue_head_t *q ,
                                                                unsigned int mode ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up_sync)(wait_queue_head_t *q ,
                                                              unsigned int mode ,
                                                              int nr ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up_bit)(wait_queue_head_t * ,
                                                             void * , int  ) ;
extern int ( __attribute__((__regparm__(3))) __wait_on_bit)(wait_queue_head_t * ,
                                                            struct wait_bit_queue * ,
                                                            int (*)(void * ) , unsigned int  ) ;
extern int ( __attribute__((__regparm__(3))) __wait_on_bit_lock)(wait_queue_head_t * ,
                                                                 struct wait_bit_queue * ,
                                                                 int (*)(void * ) ,
                                                                 unsigned int  ) ;
extern void ( __attribute__((__regparm__(3))) wake_up_bit)(void * , int  ) ;
extern int ( __attribute__((__regparm__(3))) out_of_line_wait_on_bit)(void * , int  ,
                                                                      int (*)(void * ) ,
                                                                      unsigned int  ) ;
extern int ( __attribute__((__regparm__(3))) out_of_line_wait_on_bit_lock)(void * ,
                                                                           int  ,
                                                                           int (*)(void * ) ,
                                                                           unsigned int  ) ;
extern wait_queue_head_t *( __attribute__((__regparm__(3))) bit_waitqueue)(void * ,
                                                                           int  ) ;
__inline static void __attribute__((__always_inline__))  add_wait_queue_exclusive_locked(wait_queue_head_t *q ,
                                                                                         wait_queue_t *wait ) 
{ 

  {
  wait->flags |= 1U;
  __add_wait_queue_tail(q, wait);
  return;
}
}
__inline static void __attribute__((__always_inline__))  remove_wait_queue_locked(wait_queue_head_t *q ,
                                                                                  wait_queue_t *wait ) 
{ 

  {
  __remove_wait_queue(q, wait);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) sleep_on)(wait_queue_head_t *q ) ;
extern long ( __attribute__((__regparm__(3))) sleep_on_timeout)(wait_queue_head_t *q ,
                                                                long timeout ) ;
extern void ( __attribute__((__regparm__(3))) interruptible_sleep_on)(wait_queue_head_t *q ) ;
extern long ( __attribute__((__regparm__(3))) interruptible_sleep_on_timeout)(wait_queue_head_t *q ,
                                                                              long timeout ) ;
extern void ( __attribute__((__regparm__(3))) prepare_to_wait)(wait_queue_head_t *q ,
                                                               wait_queue_t *wait ,
                                                               int state ) ;
extern void ( __attribute__((__regparm__(3))) prepare_to_wait_exclusive)(wait_queue_head_t *q ,
                                                                         wait_queue_t *wait ,
                                                                         int state ) ;
extern void ( __attribute__((__regparm__(3))) finish_wait)(wait_queue_head_t *q ,
                                                           wait_queue_t *wait ) ;
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
__inline static int __attribute__((__always_inline__))  wait_on_bit(void *word , int bit ,
                                                                    int (*action)(void * ) ,
                                                                    unsigned int mode ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)word);
  if (! tmp___0) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___1 = (int __attribute__((__always_inline__))  )out_of_line_wait_on_bit(word,
                                                                              bit,
                                                                              action,
                                                                              mode);
  return (tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  wait_on_bit_lock(void *word ,
                                                                         int bit ,
                                                                         int (*action)(void * ) ,
                                                                         unsigned int mode ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_set_bit(bit, (unsigned long volatile   *)word);
  if (! tmp) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___0 = (int __attribute__((__always_inline__))  )out_of_line_wait_on_bit_lock(word,
                                                                                   bit,
                                                                                   action,
                                                                                   mode);
  return (tmp___0);
}
}
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_read_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_write_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_wake)(struct rw_semaphore * ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_downgrade_wake)(struct rw_semaphore *sem ) ;
__inline static void __attribute__((__always_inline__))  init_rwsem(struct rw_semaphore *sem ) 
{ spinlock_t __constr_expr_0 ;

  {
  sem->count = 0L;
  while (1) {
    spin_lock_init(&__constr_expr_0);
    sem->wait_lock = __constr_expr_0;
    break;
  }
  while (1) {
    sem->wait_list.next = & sem->wait_list;
    sem->wait_list.prev = & sem->wait_list;
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  __down_read(struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# beginning down_read\n\t"
                       "lock ; "
                       "  incl      (%%eax)\n\t"
                       "  js        2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  pushl     %%ecx\n\t"
                       "  pushl     %%edx\n\t"
                       "  call      rwsem_down_read_failed\n\t"
                       "  popl      %%edx\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending down_read\n\t": "=m" (sem->count): "a" (sem), "m" (sem->count): "memory",
                       "cc");
}
}
__inline static int __attribute__((__always_inline__))  __down_read_trylock(struct rw_semaphore *sem ) 
{ __s32 result ;
  __s32 tmp ;
  int tmp___0 ;

  {
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  movl      %0,%1\n\t"
                       "1:\n\t"
                       "  movl\t     %1,%2\n\t"
                       "  addl      %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       "lock ; "
                       "  cmpxchgl  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1): "memory", "cc");
  if (result >= 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  __down_write(struct rw_semaphore *sem ) 
{ int tmp ;

  {
  tmp = -65535;
  __asm__  volatile   ("# beginning down_write\n\t"
                       "lock ; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  testl     %%edx,%%edx\n\t"
                       "  jnz       2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  pushl     %%ecx\n\t"
                       "  call      rwsem_down_write_failed\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending down_write": "=m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp), "m" (sem->count): "memory", "cc");
}
}
__inline static int __attribute__((__always_inline__))  __down_write_trylock(struct rw_semaphore *sem ) 
{ long ret ;
  long tmp ;

  {
  tmp = (long )__cmpxchg((void volatile   *)(& sem->count), 0UL, 4294901761UL, (int )sizeof(sem->count));
  ret = tmp;
  if (ret == 0L) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  __up_read(struct rw_semaphore *sem ) 
{ __s32 tmp ;

  {
  tmp = -1;
  __asm__  volatile   ("# beginning __up_read\n\t"
                       "lock ; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  js        2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  decw      %%dx\n\t"
                       "  jnz       1b\n\t"
                       "  pushl     %%ecx\n\t"
                       "  call      rwsem_wake\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending __up_read\n": "=m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp), "m" (sem->count): "memory", "cc");
}
}
__inline static void __attribute__((__always_inline__))  __up_write(struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# beginning __up_write\n\t"
                       "  movl      %2,%%edx\n\t"
                       "lock ; "
                       "  xaddl     %%edx,(%%eax)\n\t"
                       "  jnz       2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  decw      %%dx\n\t"
                       "  jnz       1b\n\t"
                       "  pushl     %%ecx\n\t"
                       "  call      rwsem_wake\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending __up_write\n": "=m" (sem->count): "a" (sem), "i" (65535),
                       "m" (sem->count): "memory", "cc", "edx");
}
}
__inline static void __attribute__((__always_inline__))  __downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       "lock ; "
                       "  addl      %2,(%%eax)\n\t"
                       "  js        2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  pushl     %%ecx\n\t"
                       "  pushl     %%edx\n\t"
                       "  call      rwsem_downgrade_wake\n\t"
                       "  popl      %%edx\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending __downgrade_write\n": "=m" (sem->count): "a" (sem),
                       "i" (65536), "m" (sem->count): "memory", "cc");
}
}
__inline static void __attribute__((__always_inline__))  rwsem_atomic_add(int delta ,
                                                                          struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "addl %1,%0": "=m" (sem->count): "ir" (delta), "m" (sem->count));
}
}
__inline static int __attribute__((__always_inline__))  rwsem_atomic_update(int delta ,
                                                                            struct rw_semaphore *sem ) 
{ int tmp ;

  {
  tmp = delta;
  __asm__  volatile   ("lock ; "
                       "xadd %0,(%2)": "+r" (tmp), "=m" (sem->count): "r" (sem), "m" (sem->count): "memory");
  return ((int __attribute__((__always_inline__))  )(tmp + delta));
}
}
__inline static void __attribute__((__always_inline__))  down_read(struct rw_semaphore *sem ) 
{ 

  {
  while (1) {
    break;
  }
  __down_read(sem);
  return;
}
}
__inline static int __attribute__((__always_inline__))  down_read_trylock(struct rw_semaphore *sem ) 
{ int ret ;

  {
  ret = (int )__down_read_trylock(sem);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static void __attribute__((__always_inline__))  down_write(struct rw_semaphore *sem ) 
{ 

  {
  while (1) {
    break;
  }
  __down_write(sem);
  return;
}
}
__inline static int __attribute__((__always_inline__))  down_write_trylock(struct rw_semaphore *sem ) 
{ int ret ;

  {
  ret = (int )__down_write_trylock(sem);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static void __attribute__((__always_inline__))  up_read(struct rw_semaphore *sem ) 
{ 

  {
  __up_read(sem);
  return;
}
}
__inline static void __attribute__((__always_inline__))  up_write(struct rw_semaphore *sem ) 
{ 

  {
  __up_write(sem);
  return;
}
}
__inline static void __attribute__((__always_inline__))  downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  __downgrade_write(sem);
  return;
}
}
__inline static void __attribute__((__always_inline__))  sema_init(struct semaphore *sem ,
                                                                   int val ) 
{ 

  {
  sem->count.counter = (int volatile   )val;
  sem->sleepers = 0;
  init_waitqueue_head(& sem->wait);
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_MUTEX(struct semaphore *sem ) 
{ 

  {
  sema_init(sem, 1);
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 

  {
  sema_init(sem, 0);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __down_failed)(void) ;
extern int ( __attribute__((__regparm__(3))) __down_failed_interruptible)(void) ;
extern int ( __attribute__((__regparm__(3))) __down_failed_trylock)(void) ;
extern void ( __attribute__((__regparm__(3))) __up_wakeup)(void) ;
__inline static void __attribute__((__always_inline__))  down(struct semaphore *sem ) 
{ 

  {
  while (1) {
    break;
  }
  __asm__  volatile   ("# atomic down operation\n\t"
                       "lock ; "
                       "decl %0\n\t"
                       "js 2f\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %0,%%eax\n\t"
                       "call __down_failed\n\t"
                       "jmp 1b\n"
                       ".previous\n\t": "=m" (sem->count): : "memory", "ax");
}
}
__inline static int __attribute__((__always_inline__))  down_interruptible(struct semaphore *sem ) 
{ int result ;

  {
  while (1) {
    break;
  }
  __asm__  volatile   ("# atomic interruptible down operation\n\t"
                       "lock ; "
                       "decl %1\n\t"
                       "js 2f\n\t"
                       "xorl %0,%0\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %1,%%eax\n\t"
                       "call __down_failed_interruptible\n\t"
                       "jmp 1b\n"
                       ".previous\n\t": "=a" (result), "=m" (sem->count): : "memory");
  return ((int __attribute__((__always_inline__))  )result);
}
}
__inline static int __attribute__((__always_inline__))  down_trylock(struct semaphore *sem ) 
{ int result ;

  {
  __asm__  volatile   ("# atomic interruptible down operation\n\t"
                       "lock ; "
                       "decl %1\n\t"
                       "js 2f\n\t"
                       "xorl %0,%0\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %1,%%eax\n\t"
                       "call __down_failed_trylock\n\t"
                       "jmp 1b\n"
                       ".previous\n\t": "=a" (result), "=m" (sem->count): : "memory");
  return ((int __attribute__((__always_inline__))  )result);
}
}
__inline static void __attribute__((__always_inline__))  up(struct semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# atomic up operation\n\t"
                       "lock ; "
                       "incl %0\n\t"
                       "jle 2f\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "wavelan"
                       "\n\t"
                       ".text.lock."
                       "wavelan"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %0,%%eax\n\t"
                       "call __up_wakeup\n\t"
                       "jmp 1b\n"
                       ".previous\n\t"
                       ".subsection 0\n": "=m" (sem->count): : "memory", "ax");
}
}
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ) ;
extern void cpu_idle(void) ;
__inline static int __attribute__((__always_inline__))  __acpi_acquire_global_lock(unsigned int *lock ) 
{ unsigned int old ;
  unsigned int new ;
  unsigned int val ;
  unsigned long __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    old = (*lock);
    new = ((old & 4294967292U) + 2U) + ((old >> 1) & 1U);
    val = (unsigned int )__cmpxchg((void volatile   *)lock, (unsigned long )old, (unsigned long )new,
                                   (int )sizeof((*lock)));
    tmp___0 = __builtin_expect((long )(! (! (val != old)) != 0), 0L);
    if (! tmp___0) {
      break;
    }
  }
  if (new < 3U) {
    tmp___1 = -1;
  } else {
    tmp___1 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  __acpi_release_global_lock(unsigned int *lock ) 
{ unsigned int old ;
  unsigned int new ;
  unsigned int val ;
  unsigned long __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;

  {
  while (1) {
    old = (*lock);
    new = old & 4294967292U;
    val = (unsigned int )__cmpxchg((void volatile   *)lock, (unsigned long )old, (unsigned long )new,
                                   (int )sizeof((*lock)));
    tmp___0 = __builtin_expect((long )(! (! (val != old)) != 0), 0L);
    if (! tmp___0) {
      break;
    }
  }
  return ((int __attribute__((__always_inline__))  )(old & 1U));
}
}
__inline static int __attribute__((__always_inline__))  acpi_irq_balance_set(char *str ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern u8 x86_acpiid_to_apicid[] ;
extern void __set_fixmap(enum fixed_addresses idx , unsigned long phys , pgprot_t flags ) ;
extern void __this_fixmap_does_not_exist(void) ;
__inline static unsigned long __attribute__((__always_inline__))  fix_to_virt(unsigned int idx ) 
{ 

  {
  if (idx >= 245U) {
    __this_fixmap_does_not_exist();
  }
  return ((unsigned long __attribute__((__always_inline__))  )(4294963200UL - (unsigned long )(idx <<
                                                                                               12)));
}
}
__inline static unsigned long __attribute__((__always_inline__))  virt_to_fix(unsigned long vaddr ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  while (1) {
    if (vaddr >= 4294963200UL) {
      tmp = 1;
    } else {
      if (vaddr < 4294029312UL) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    }
    if (tmp != 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    if (tmp___1) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (153), "i" ("include/asm/fixmap.h"));
    }
    break;
  }
  return ((unsigned long __attribute__((__always_inline__))  )((4294963200UL - (vaddr &
                                                                                4294963200UL)) >>
                                                               12));
}
}
extern int mp_bus_id_to_type[260] ;
extern int mp_bus_id_to_node[260] ;
extern int mp_bus_id_to_local[260] ;
extern int quad_local_to_mp_bus_id[2][4] ;
extern int mp_bus_id_to_pci_bus[260] ;
extern unsigned int boot_cpu_physical_apicid ;
extern int smp_found_config ;
extern void find_smp_config(void) ;
extern void get_smp_config(void) ;
extern int nr_ioapics ;
extern int apic_version[256] ;
extern int mp_irq_entries ;
extern struct mpc_config_intsrc mp_irqs[256] ;
extern int mpc_default_type ;
extern unsigned long mp_lapic_addr ;
extern int pic_mode ;
extern int using_apic_timer ;
extern physid_mask_t phys_cpu_present_map ;
__inline static int __attribute__((__always_inline__))  use_pci_vector(void) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  disable_edge_ioapic_irq(unsigned int irq___0 ) 
{ 

  {
  return;
}
}
extern int nr_ioapic_registers[8] ;
extern struct mpc_config_ioapic mp_ioapics[8] ;
__inline static unsigned int __attribute__((__always_inline__))  io_apic_read(unsigned int apic ,
                                                                              unsigned int reg ) 
{ 

  {
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)))) = (int volatile   )reg;
  return ((unsigned int __attribute__((__always_inline__))  )(*((int volatile   *)((4294963200UL -
                                                                                    (unsigned long )((3U +
                                                                                                      apic) <<
                                                                                                     12)) +
                                                                                   (mp_ioapics[apic].mpc_apicaddr &
                                                                                    4095UL)) +
                                                                4)));
}
}
__inline static void __attribute__((__always_inline__))  io_apic_write(unsigned int apic ,
                                                                       unsigned int reg ,
                                                                       unsigned int value ) 
{ 

  {
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)))) = (int volatile   )reg;
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)) +
     4)) = (int volatile   )value;
  return;
}
}
extern int sis_apic_bug ;
__inline static void __attribute__((__always_inline__))  io_apic_modify(unsigned int apic ,
                                                                        unsigned int reg ,
                                                                        unsigned int value ) 
{ 

  {
  if (sis_apic_bug) {
    (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                  4095UL)))) = (int volatile   )reg;
  }
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)) +
     4)) = (int volatile   )value;
  return;
}
}
extern int skip_ioapic_setup ;
extern int (*ioapic_renumber_irq)(int ioapic , int irq ) ;
extern int assign_irq_vector(int irq ) ;
extern int pm_active ;
extern struct pm_dev  __attribute__((__deprecated__)) *pm_register(pm_dev_t type ,
                                                                   unsigned long id ,
                                                                   int (*callback)(struct pm_dev *dev ,
                                                                                   pm_request_t rqst ,
                                                                                   void *data ) ) ;
extern void __attribute__((__deprecated__))  pm_unregister(struct pm_dev *dev ) ;
extern void __attribute__((__deprecated__))  pm_unregister_all(int (*callback)(struct pm_dev *dev ,
                                                                               pm_request_t rqst ,
                                                                               void *data ) ) ;
extern int __attribute__((__deprecated__))  pm_send_all(pm_request_t rqst , void *data ) ;
extern void (*pm_idle)(void) ;
extern void (*pm_power_off)(void) ;
extern void pm_set_ops(struct pm_ops * ) ;
extern int pm_suspend(suspend_state_t state ) ;
extern void device_pm_set_parent(struct device *dev , struct device *parent ) ;
extern int device_suspend(pm_message_t state ) ;
extern int device_power_down(pm_message_t state ) ;
extern void device_power_up(void) ;
extern void device_resume(void) ;
extern int apic_verbosity ;
__inline static void __attribute__((__always_inline__))  apic_write(unsigned long reg ,
                                                                    unsigned long v ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = fix_to_virt(2U);
  (*((unsigned long volatile   *)(tmp + (unsigned long __attribute__((__always_inline__))  )reg))) = (unsigned long volatile   )v;
  return;
}
}
__inline static void __attribute__((__always_inline__))  apic_write_atomic(unsigned long reg ,
                                                                           unsigned long v ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;
  unsigned long __attribute__((__always_inline__))  tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;
  unsigned long __attribute__((__always_inline__))  tmp___2 ;

  {
  tmp___2 = fix_to_virt(2U);
  __xchg(v, (void volatile   *)((unsigned long volatile   *)(tmp___2 + (unsigned long __attribute__((__always_inline__))  )reg)),
         (int )sizeof((*((unsigned long volatile   *)(tmp___1 + (unsigned long __attribute__((__always_inline__))  )reg)))));
  return;
}
}
__inline static unsigned long __attribute__((__always_inline__))  apic_read(unsigned long reg ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = fix_to_virt(2U);
  return ((unsigned long __attribute__((__always_inline__))  )(*((unsigned long volatile   *)(tmp +
                                                                                              (unsigned long __attribute__((__always_inline__))  )reg))));
}
}
__inline static void __attribute__((__always_inline__))  apic_wait_icr_idle(void) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    tmp = apic_read(768UL);
    if (! (tmp & 4096UL)) {
      break;
    }
    rep_nop();
  }
  return;
}
}
extern int get_physical_broadcast(void) ;
__inline static void __attribute__((__always_inline__))  ack_APIC_irq(void) 
{ 

  {
  apic_write(176UL, 0UL);
  return;
}
}
extern void (*wait_timer_tick)(void) ;
extern int get_maxlvt(void) ;
extern void clear_local_APIC(void) ;
extern void connect_bsp_APIC(void) ;
extern void disconnect_bsp_APIC(void) ;
extern void disable_local_APIC(void) ;
extern void lapic_shutdown(void) ;
extern int verify_local_APIC(void) ;
extern void cache_APIC_registers(void) ;
extern void sync_Arb_IDs(void) ;
extern void init_bsp_APIC(void) ;
extern void setup_local_APIC(void) ;
extern void init_apic_mappings(void) ;
extern void smp_local_timer_interrupt(struct pt_regs *regs ) ;
extern void setup_boot_APIC_clock(void) ;
extern void setup_secondary_APIC_clock(void) ;
extern void setup_apic_nmi_watchdog(void) ;
extern int reserve_lapic_nmi(void) ;
extern void release_lapic_nmi(void) ;
extern void disable_timer_nmi_watchdog(void) ;
extern void enable_timer_nmi_watchdog(void) ;
extern void nmi_watchdog_tick(struct pt_regs *regs ) ;
extern int APIC_init_uniprocessor(void) ;
extern void disable_APIC_timer(void) ;
extern void enable_APIC_timer(void) ;
extern void enable_NMI_through_LVT0(void *dummy ) ;
extern unsigned int nmi_watchdog ;
extern void smp_alloc_memory(void) ;
extern int smp_num_siblings ;
extern cpumask_t cpu_sibling_map[] ;
extern cpumask_t cpu_core_map[] ;
extern void smp_flush_tlb(void) ;
extern void smp_message_irq(int cpl , void *dev_id , struct pt_regs *regs ) ;
extern void smp_invalidate_rcv(void) ;
extern void (*mtrr_hook)(void) ;
extern void zap_low_mappings(void) ;
extern u8 x86_cpu_to_apicid[] ;
extern cpumask_t cpu_callout_map ;
extern cpumask_t cpu_callin_map ;
__inline static int __attribute__((__always_inline__))  num_booting_cpus(void) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = __cpus_weight((cpumask_t const   *)(& cpu_callout_map), 8);
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  get_apic_id(unsigned long x ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )((x >> 24) & 255UL));
}
}
__inline static int __attribute__((__always_inline__))  hard_smp_processor_id(void) 
{ unsigned long __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = fix_to_virt(2U);
  tmp___0 = (int __attribute__((__always_inline__))  )get_apic_id((*((unsigned long *)(tmp +
                                                                                       32UL))));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  logical_smp_processor_id(void) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = fix_to_virt(2U);
  return ((int __attribute__((__always_inline__))  )(((*((unsigned long *)(tmp + 208UL))) >>
                                                      24) & 255UL));
}
}
extern void smp_send_stop(void) ;
extern void smp_send_reschedule(int cpu ) ;
extern void smp_prepare_cpus(unsigned int max_cpus ) ;
extern int __cpu_up(unsigned int cpunum ) ;
extern void smp_cpus_done(unsigned int max_cpus ) ;
extern int smp_call_function(void (*func)(void *info ) , void *info , int retry ,
                             int wait ) ;
__inline static int __attribute__((__always_inline__))  on_each_cpu(void (*func)(void *info ) ,
                                                                    void *info , int retry ,
                                                                    int wait ) 
{ int ret ;

  {
  ret = 0;
  while (1) {
    break;
  }
  ret = smp_call_function(func, info, retry, wait);
  ((*func))(info);
  while (1) {
    break;
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
extern void smp_prepare_boot_cpu(void) ;
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
extern void exit_sem(struct task_struct *tsk ) ;
__inline static void __attribute__((__always_inline__))  sigaddset(sigset_t *set ,
                                                                   int _sig ) 
{ 

  {
  __asm__  ("btsl %1,%0": "=m" ((*set)): "Ir" (_sig - 1): "cc");
}
}
__inline static void __attribute__((__always_inline__))  sigdelset(sigset_t *set ,
                                                                   int _sig ) 
{ 

  {
  __asm__  ("btrl %1,%0": "=m" ((*set)): "Ir" (_sig - 1): "cc");
}
}
__inline static int __attribute__((__always_inline__))  __const_sigismember(sigset_t *set ,
                                                                            int _sig ) 
{ unsigned long sig ;

  {
  sig = (unsigned long )(_sig - 1);
  return ((int __attribute__((__always_inline__))  )(1UL & (set->sig[sig / 32UL] >>
                                                            sig % 32UL)));
}
}
__inline static int __attribute__((__always_inline__))  __gen_sigismember(sigset_t *set ,
                                                                          int _sig ) 
{ int ret ;

  {
  __asm__  ("btl %2,%1\n\tsbbl %0,%0": "=r" (ret): "m" ((*set)), "Ir" (_sig - 1): "cc");
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static int __attribute__((__always_inline__))  sigfindinword(unsigned long word ) 
{ 

  {
  __asm__  ("bsfl %1,%0": "=r" (word): "rm" (word): "cc");
  return ((int __attribute__((__always_inline__))  )word);
}
}
extern int ( __attribute__((__regparm__(3))) do_signal)(struct pt_regs *regs , sigset_t *oldset ) ;
extern void do_schedule_next_timer(struct siginfo *info ) ;
__inline static void __attribute__((__always_inline__))  copy_siginfo(struct siginfo *to ,
                                                                      struct siginfo *from ) 
{ 

  {
  if (from->si_code < 0) {
    __constant_memcpy((void *)to, (void const   *)from, sizeof((*to)));
  } else {
    __constant_memcpy((void *)to, (void const   *)from, 3U * sizeof(int ) + sizeof(from->_sifields._sigchld));
  }
  return;
}
}
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo *from ) ;
extern void _NSIG_WORDS_is_unsupported_size(void) ;
__inline static void __attribute__((__always_inline__))  sigorsets(sigset_t *r , sigset_t const   *a ,
                                                                   sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  switch (2) {
  case 4: 
  a3 = a->sig[3];
  a2 = a->sig[2];
  b3 = b->sig[3];
  b2 = b->sig[2];
  r->sig[3] = a3 | b3;
  r->sig[2] = a2 | b2;
  case 2: 
  a1 = a->sig[1];
  b1 = b->sig[1];
  r->sig[1] = a1 | b1;
  case 1: 
  a0 = a->sig[0];
  b0 = b->sig[0];
  r->sig[0] = a0 | b0;
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigandsets(sigset_t *r ,
                                                                    sigset_t const   *a ,
                                                                    sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  switch (2) {
  case 4: 
  a3 = a->sig[3];
  a2 = a->sig[2];
  b3 = b->sig[3];
  b2 = b->sig[2];
  r->sig[3] = a3 & b3;
  r->sig[2] = a2 & b2;
  case 2: 
  a1 = a->sig[1];
  b1 = b->sig[1];
  r->sig[1] = a1 & b1;
  case 1: 
  a0 = a->sig[0];
  b0 = b->sig[0];
  r->sig[0] = a0 & b0;
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  signandsets(sigset_t *r ,
                                                                     sigset_t const   *a ,
                                                                     sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  switch (2) {
  case 4: 
  a3 = a->sig[3];
  a2 = a->sig[2];
  b3 = b->sig[3];
  b2 = b->sig[2];
  r->sig[3] = a3 & ~ b3;
  r->sig[2] = a2 & ~ b2;
  case 2: 
  a1 = a->sig[1];
  b1 = b->sig[1];
  r->sig[1] = a1 & ~ b1;
  case 1: 
  a0 = a->sig[0];
  b0 = b->sig[0];
  r->sig[0] = a0 & ~ b0;
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  signotset(sigset_t *set ) 
{ 

  {
  switch (2) {
  case 4: 
  set->sig[3] = ~ set->sig[3];
  set->sig[2] = ~ set->sig[2];
  case 2: 
  set->sig[1] = ~ set->sig[1];
  case 1: 
  set->sig[0] = ~ set->sig[0];
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigemptyset(sigset_t *set ) 
{ 

  {
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)set, 0UL, sizeof(sigset_t ));
  break;
  case 2: 
  set->sig[1] = 0UL;
  case 1: 
  set->sig[0] = 0UL;
  break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigfillset(sigset_t *set ) 
{ 

  {
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)set, 4294967295UL, sizeof(sigset_t ));
  break;
  case 2: 
  set->sig[1] = 4294967295UL;
  case 1: 
  set->sig[0] = 4294967295UL;
  break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigaddsetmask(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  set->sig[0] |= mask;
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigdelsetmask(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  set->sig[0] &= ~ mask;
  return;
}
}
__inline static int __attribute__((__always_inline__))  sigtestsetmask(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((set->sig[0] & mask) != 0UL));
}
}
__inline static void __attribute__((__always_inline__))  siginitset(sigset_t *set ,
                                                                    unsigned long mask ) 
{ 

  {
  set->sig[0] = mask;
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)(& set->sig[1]), 0UL, sizeof(long ));
  break;
  case 2: 
  set->sig[1] = 0UL;
  case 1: ;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  siginitsetinv(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  set->sig[0] = ~ mask;
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)(& set->sig[1]), 4294967295UL, sizeof(long ));
  break;
  case 2: 
  set->sig[1] = 4294967295UL;
  case 1: ;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_sigpending(struct sigpending *sig ) 
{ 

  {
  sigemptyset(& sig->signal);
  while (1) {
    sig->list.next = & sig->list;
    sig->list.prev = & sig->list;
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  valid_signal(unsigned long sig ) 
{ int tmp ;

  {
  if (sig <= 64UL) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern long do_sigpending(void * , unsigned long  ) ;
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
extern int get_signal_to_deliver(siginfo_t *info , struct k_sigaction *return_ka ,
                                 struct pt_regs *regs , void *cookie ) ;
extern unsigned int securebits ;
extern void exit_fs(struct task_struct * ) ;
extern void set_fs_altroot(void) ;
extern void set_fs_root(struct fs_struct * , struct vfsmount * , struct dentry * ) ;
extern void set_fs_pwd(struct fs_struct * , struct vfsmount * , struct dentry * ) ;
extern struct fs_struct *copy_fs_struct(struct fs_struct * ) ;
extern void put_fs_struct(struct fs_struct * ) ;
__inline static void __attribute__((__always_inline__))  init_completion(struct completion *x ) 
{ 

  {
  x->done = 0U;
  init_waitqueue_head(& x->wait);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) wait_for_completion)(struct completion * ) ;
extern int ( __attribute__((__regparm__(3))) wait_for_completion_interruptible)(struct completion *x ) ;
extern unsigned long ( __attribute__((__regparm__(3))) wait_for_completion_timeout)(struct completion *x ,
                                                                                    unsigned long timeout ) ;
extern unsigned long ( __attribute__((__regparm__(3))) wait_for_completion_interruptible_timeout)(struct completion *x ,
                                                                                                  unsigned long timeout ) ;
extern void ( __attribute__((__regparm__(3))) complete)(struct completion * ) ;
extern void ( __attribute__((__regparm__(3))) complete_all)(struct completion * ) ;
extern int ( __attribute__((__regparm__(3))) attach_pid)(struct task_struct *task ,
                                                         enum pid_type type , int nr ) ;
extern void ( __attribute__((__regparm__(3))) detach_pid)(struct task_struct *task ,
                                                          enum pid_type  ) ;
extern struct pid *( __attribute__((__regparm__(3))) find_pid)(enum pid_type  , int  ) ;
extern int alloc_pidmap(void) ;
extern void ( __attribute__((__regparm__(3))) free_pidmap)(int  ) ;
extern void switch_exec_pids(struct task_struct *leader , struct task_struct *thread ) ;
extern initcall_t __con_initcall_start[] ;
extern initcall_t __con_initcall_end[] ;
extern initcall_t __security_initcall_start[] ;
extern initcall_t __security_initcall_end[] ;
extern char saved_command_line[] ;
extern struct pglist_data *pgdat_list ;
extern void __get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ,
                              struct pglist_data *pgdat ) ;
extern void get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ) ;
extern void build_all_zonelists(void) ;
extern void wakeup_kswapd(struct zone *zone , int order ) ;
extern int zone_watermark_ok(struct zone *z , int order , unsigned long mark , int alloc_type ,
                             int can_try_harder , int gfp_high ) ;
__inline static void __attribute__((__always_inline__))  memory_present(int nid ,
                                                                        unsigned long start ,
                                                                        unsigned long end ) 
{ 

  {
  return;
}
}
__inline static struct zone  __attribute__((__always_inline__)) *next_zone(struct zone *zone ) 
{ pg_data_t *pgdat ;

  {
  pgdat = zone->zone_pgdat;
  if ((unsigned int )zone < (unsigned int )((pgdat->node_zones + 3) - 1)) {
    zone ++;
  } else {
    if (pgdat->pgdat_next) {
      pgdat = pgdat->pgdat_next;
      zone = pgdat->node_zones;
    } else {
      zone = (struct zone *)((void *)0);
    }
  }
  return ((struct zone  __attribute__((__always_inline__)) *)zone);
}
}
__inline static int __attribute__((__always_inline__))  is_highmem_idx(int idx ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(idx == 2));
}
}
__inline static int __attribute__((__always_inline__))  is_normal_idx(int idx ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(idx == 1));
}
}
__inline static int __attribute__((__always_inline__))  is_highmem(struct zone *zone ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )zone == (unsigned int )((zone->zone_pgdat)->node_zones +
                                                                                            2)));
}
}
__inline static int __attribute__((__always_inline__))  is_normal(struct zone *zone ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )zone == (unsigned int )((zone->zone_pgdat)->node_zones +
                                                                                            1)));
}
}
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                          void * , size_t * , loff_t * ) ;
extern int sysctl_lowmem_reserve_ratio[2] ;
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                               void * , size_t * , loff_t * ) ;
extern struct pglist_data contig_page_data ;
__inline static void __attribute__((__always_inline__))  arch_free_page(struct page *page ,
                                                                        int order ) 
{ 

  {
  return;
}
}
extern struct page *( __attribute__((__regparm__(3))) __alloc_pages)(unsigned int  ,
                                                                     unsigned int  ,
                                                                     struct zonelist * ) ;
__inline static struct page  __attribute__((__always_inline__)) *alloc_pages_node(int nid ,
                                                                                  unsigned int gfp_mask ,
                                                                                  unsigned int order ) 
{ long tmp ;
  struct page  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp = __builtin_expect((long )(! (! (order >= 11U)) != 0), 0L);
  if (tmp) {
    return ((struct page  __attribute__((__always_inline__)) *)((void *)0));
  }
  tmp___0 = (struct page  __attribute__((__always_inline__)) *)__alloc_pages(gfp_mask,
                                                                             order,
                                                                             contig_page_data.node_zonelists +
                                                                             (gfp_mask &
                                                                              3U));
  return (tmp___0);
}
}
extern unsigned long ( __attribute__((__regparm__(3))) __get_free_pages)(unsigned int gfp_mask ,
                                                                         unsigned int order ) ;
extern unsigned long ( __attribute__((__regparm__(3))) get_zeroed_page)(unsigned int gfp_mask ) ;
extern void ( __attribute__((__regparm__(3))) __free_pages)(struct page *page , unsigned int order ) ;
extern void ( __attribute__((__regparm__(3))) free_pages)(unsigned long addr , unsigned int order ) ;
extern void ( __attribute__((__regparm__(3))) free_hot_page)(struct page *page ) ;
extern void ( __attribute__((__regparm__(3))) free_cold_page)(struct page *page ) ;
extern void page_alloc_init(void) ;
extern void kmem_cache_init(void)  __attribute__((__section__(".init.text"))) ;
extern kmem_cache_t *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                       void (*)(void * , kmem_cache_t * , unsigned long  ) ,
                                       void (*)(void * , kmem_cache_t * , unsigned long  ) ) ;
extern int kmem_cache_destroy(kmem_cache_t * ) ;
extern int kmem_cache_shrink(kmem_cache_t * ) ;
extern void *kmem_cache_alloc(kmem_cache_t * , unsigned int  ) ;
extern void kmem_cache_free(kmem_cache_t * , void * ) ;
extern unsigned int kmem_cache_size(kmem_cache_t * ) ;
extern kmem_cache_t *kmem_find_general_cachep(size_t size , int gfpflags ) ;
extern struct cache_sizes malloc_sizes[] ;
extern void *__kmalloc(size_t  , unsigned int  ) ;
extern void __you_cannot_kmalloc_that_much(void) ;
__inline static void __attribute__((__always_inline__))  *kmalloc(size_t size , unsigned int flags ) 
{ int i ;
  kmem_cache_t *tmp ;
  void __attribute__((__always_inline__))  *tmp___0 ;
  void __attribute__((__always_inline__))  *tmp___1 ;

  {
  if (0) {
    i = 0;
    if (size <= 32U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 64U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 96U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 128U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 192U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 256U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 512U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 1024U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 2048U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 4096U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 8192U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 16384U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 32768U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 65536U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 131072U) {
      goto found;
    } else {
      i ++;
    }
    __you_cannot_kmalloc_that_much();
    found: 
    if (flags & 1U) {
      tmp = malloc_sizes[i].cs_dmacachep;
    } else {
      tmp = malloc_sizes[i].cs_cachep;
    }
    tmp___0 = (void __attribute__((__always_inline__))  *)kmem_cache_alloc(tmp, flags);
    return (tmp___0);
  }
  tmp___1 = (void __attribute__((__always_inline__))  *)__kmalloc(size, flags);
  return (tmp___1);
}
}
extern void *kcalloc(size_t  , size_t  , unsigned int  ) ;
extern void kfree(void const   * ) ;
extern unsigned int ksize(void const   * ) ;
__inline static void __attribute__((__always_inline__))  *kmem_cache_alloc_node(kmem_cache_t *cachep ,
                                                                                int flags ,
                                                                                int node ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = (void __attribute__((__always_inline__))  *)kmem_cache_alloc(cachep, (unsigned int )flags);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  *kmalloc_node(size_t size ,
                                                                       int flags ,
                                                                       int node ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = kmalloc(size, (unsigned int )flags);
  return (tmp);
}
}
extern int ( __attribute__((__regparm__(3))) kmem_cache_reap)(int  ) ;
extern int ( __attribute__((__regparm__(3))) kmem_ptr_validate)(kmem_cache_t *cachep ,
                                                                void *ptr ) ;
extern kmem_cache_t *vm_area_cachep ;
extern kmem_cache_t *names_cachep ;
extern kmem_cache_t *files_cachep ;
extern kmem_cache_t *filp_cachep ;
extern kmem_cache_t *fs_cachep ;
extern kmem_cache_t *signal_cachep ;
extern kmem_cache_t *sighand_cachep ;
extern kmem_cache_t *bio_cachep ;
extern atomic_t slab_reclaim_pages ;
extern void *__alloc_percpu(size_t size , size_t align ) ;
extern void free_percpu(void const   * ) ;
extern int errno ;
extern void __secure_computing(int  ) ;
__inline static void __attribute__((__always_inline__))  secure_computing(int this_syscall ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = test_thread_flag(8);
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  if (tmp___1) {
    __secure_computing(this_syscall);
  }
  return;
}
}
extern unsigned long avenrun[] ;
extern unsigned long total_forks ;
extern int nr_threads ;
extern int last_pid ;
extern unsigned long per_cpu__process_counts ;
extern int nr_processes(void) ;
extern unsigned long nr_running(void) ;
extern unsigned long nr_uninterruptible(void) ;
extern unsigned long nr_iowait(void) ;
__inline static void __attribute__((__always_inline__))  init_timer(struct timer_list *timer ) 
{ spinlock_t __constr_expr_0 ;

  {
  timer->base = (struct tvec_t_base_s *)((void *)0);
  timer->magic = 1267182958UL;
  while (1) {
    spin_lock_init(&__constr_expr_0);
    timer->lock = __constr_expr_0;
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  timer_pending(struct timer_list  const  *timer ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )timer->base !=
                                                     (unsigned int )((void *)0)));
}
}
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
extern int del_timer(struct timer_list *timer ) ;
extern int __mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern unsigned long next_timer_interrupt(void) ;
__inline static void __attribute__((__always_inline__))  add_timer(struct timer_list *timer ) 
{ 

  {
  __mod_timer(timer, timer->expires);
  return;
}
}
extern int del_timer_sync(struct timer_list *timer ) ;
extern int del_singleshot_timer_sync(struct timer_list *timer ) ;
extern void init_timers(void) ;
extern void run_local_timers(void) ;
extern void it_real_fn(unsigned long  ) ;
extern rwlock_t tasklist_lock ;
extern spinlock_t mmlist_lock ;
extern void sched_init(void) ;
extern void sched_init_smp(void) ;
extern void init_idle(task_t *idle , int cpu ) ;
extern cpumask_t nohz_cpu_mask ;
extern void show_state(void) ;
extern void show_regs(struct pt_regs * ) ;
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
extern void io_schedule(void) ;
extern long io_schedule_timeout(long timeout ) ;
extern void cpu_init(void) ;
extern void trap_init(void) ;
extern void update_process_times(int user ) ;
extern void scheduler_tick(void) ;
extern int in_sched_functions(unsigned long addr ) ;
extern long ( __attribute__((__regparm__(3))) schedule_timeout)(long timeout ) ;
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
extern int sysctl_max_map_count ;
extern struct workqueue_struct *__create_workqueue(char const   *name , int singlethread ) ;
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
extern int ( __attribute__((__regparm__(3))) queue_work)(struct workqueue_struct *wq ,
                                                         struct work_struct *work ) ;
extern int ( __attribute__((__regparm__(3))) queue_delayed_work)(struct workqueue_struct *wq ,
                                                                 struct work_struct *work ,
                                                                 unsigned long delay ) ;
extern void ( __attribute__((__regparm__(3))) flush_workqueue)(struct workqueue_struct *wq ) ;
extern int ( __attribute__((__regparm__(3))) schedule_work)(struct work_struct *work ) ;
extern int ( __attribute__((__regparm__(3))) schedule_delayed_work)(struct work_struct *work ,
                                                                    unsigned long delay ) ;
extern int schedule_delayed_work_on(int cpu , struct work_struct *work , unsigned long delay ) ;
extern void flush_scheduled_work(void) ;
extern int current_is_keventd(void) ;
extern int keventd_up(void) ;
extern void init_workqueues(void) ;
extern void cancel_rearming_delayed_work(struct work_struct *work ) ;
extern void cancel_rearming_delayed_workqueue(struct workqueue_struct * , struct work_struct * ) ;
__inline static int __attribute__((__always_inline__))  cancel_delayed_work(struct work_struct *work ) 
{ int ret ;

  {
  ret = del_timer_sync(& work->timer);
  if (ret) {
    clear_bit(0, (unsigned long volatile   *)(& work->pending));
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
extern unsigned int aio_max_size ;
extern ssize_t ( __attribute__((__regparm__(3))) wait_on_sync_kiocb)(struct kiocb *iocb ) ;
extern int ( __attribute__((__regparm__(3))) aio_put_req)(struct kiocb *iocb ) ;
extern void ( __attribute__((__regparm__(3))) kick_iocb)(struct kiocb *iocb ) ;
extern int ( __attribute__((__regparm__(3))) aio_complete)(struct kiocb *iocb , long res ,
                                                           long res2 ) ;
extern void ( __attribute__((__regparm__(3))) __put_ioctx)(struct kioctx *ctx ) ;
extern void ( __attribute__((__regparm__(3))) exit_aio)(struct mm_struct *mm ) ;
extern struct kioctx *lookup_ioctx(unsigned long ctx_id ) ;
extern int ( __attribute__((__regparm__(3))) io_submit_one)(struct kioctx *ctx , struct iocb *user_iocb ,
                                                            struct iocb *iocb ) ;
__inline static struct kiocb  __attribute__((__always_inline__)) *list_kiocb(struct list_head *h ) 
{ struct list_head  const  *__mptr ;

  {
  __mptr = (struct list_head  const  *)h;
  return ((struct kiocb  __attribute__((__always_inline__)) *)((struct kiocb *)((char *)__mptr -
                                                                                (unsigned int )(& ((struct kiocb *)0)->ki_list))));
}
}
extern atomic_t aio_nr ;
extern unsigned int aio_max_nr ;
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
extern void arch_unmap_area(struct vm_area_struct *area ) ;
extern void arch_unmap_area_topdown(struct vm_area_struct *area ) ;
extern struct user_struct *find_user(uid_t  ) ;
extern struct user_struct root_user ;
extern void exit_io_context(void) ;
extern struct group_info *groups_alloc(int gidsetsize ) ;
extern void groups_free(struct group_info *group_info ) ;
extern int set_current_groups(struct group_info *group_info ) ;
__inline static pid_t __attribute__((__always_inline__))  process_group(struct task_struct *tsk ) 
{ 

  {
  return ((tsk->signal)->pgrp);
}
}
__inline static int __attribute__((__always_inline__))  pid_alive(struct task_struct *p ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(p->pids[0].nr != 0));
}
}
extern void free_task(struct task_struct *tsk ) ;
extern void __put_task_struct(struct task_struct *tsk ) ;
extern int set_cpus_allowed(task_t *p , cpumask_t new_mask ) ;
extern unsigned long long sched_clock(void) ;
extern unsigned long long current_sched_time(task_t const   *current_task ) ;
extern void sched_exec(void) ;
extern void sched_idle_next(void) ;
extern void set_user_nice(task_t *p , long nice ) ;
extern int task_prio(task_t const   *p ) ;
extern int task_nice(task_t const   *p ) ;
extern int can_nice(task_t const   *p , int nice ) ;
extern int task_curr(task_t const   *p ) ;
extern int idle_cpu(int cpu ) ;
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param * ) ;
extern task_t *idle_task(int cpu ) ;
extern void yield(void) ;
extern struct exec_domain default_exec_domain ;
__inline static int __attribute__((__always_inline__))  kstack_end(void *addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! ((((unsigned long )addr + (unsigned long )sizeof(void *)) -
                                                         1UL) & (unsigned long )(8192U -
                                                                                 sizeof(void *))) !=
                                                     0));
}
}
extern union thread_union init_thread_union ;
extern struct task_struct init_task ;
extern struct mm_struct init_mm ;
extern struct task_struct *find_task_by_pid_type(int type , int pid ) ;
extern void set_special_pids(pid_t session , pid_t pgrp ) ;
extern void __set_special_pids(pid_t session , pid_t pgrp ) ;
extern struct user_struct *alloc_uid(uid_t  ) ;
__inline static struct user_struct  __attribute__((__always_inline__)) *get_uid(struct user_struct *u ) 
{ 

  {
  atomic_inc(& u->__count);
  return ((struct user_struct  __attribute__((__always_inline__)) *)u);
}
}
extern void free_uid(struct user_struct * ) ;
extern void switch_uid(struct user_struct * ) ;
extern void do_timer(struct pt_regs * ) ;
extern int ( __attribute__((__regparm__(3))) wake_up_state)(struct task_struct *tsk ,
                                                            unsigned int state ) ;
extern int ( __attribute__((__regparm__(3))) wake_up_process)(struct task_struct *tsk ) ;
extern void ( __attribute__((__regparm__(3))) wake_up_new_task)(struct task_struct *tsk ,
                                                                unsigned long clone_flags ) ;
extern void kick_process(struct task_struct *tsk ) ;
extern void ( __attribute__((__regparm__(3))) sched_fork)(task_t *p ) ;
extern void ( __attribute__((__regparm__(3))) sched_exit)(task_t *p ) ;
extern int in_group_p(gid_t  ) ;
extern int in_egroup_p(gid_t  ) ;
extern void proc_caches_init(void) ;
extern void flush_signals(struct task_struct * ) ;
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
__inline static int __attribute__((__always_inline__))  dequeue_signal_lock(struct task_struct *tsk ,
                                                                            sigset_t *mask ,
                                                                            siginfo_t *info ) 
{ unsigned long flags ;
  int ret ;

  {
  flags = _spin_lock_irqsave(& (tsk->sighand)->siglock);
  ret = dequeue_signal(tsk, mask, info);
  _spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
extern void unblock_all_signals(void) ;
extern void release_task(struct task_struct *p ) ;
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int send_group_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int force_sigsegv(int  , struct task_struct * ) ;
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int __kill_pg_info(int sig , struct siginfo *info , pid_t pgrp ) ;
extern int kill_pg_info(int  , struct siginfo * , pid_t  ) ;
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
extern void do_notify_parent(struct task_struct * , int  ) ;
extern void force_sig(int  , struct task_struct * ) ;
extern void force_sig_specific(int  , struct task_struct * ) ;
extern int send_sig(int  , struct task_struct * , int  ) ;
extern void zap_other_threads(struct task_struct *p ) ;
extern int kill_pg(pid_t  , int  , int  ) ;
extern int kill_sl(pid_t  , int  , int  ) ;
extern int kill_proc(pid_t  , int  , int  ) ;
extern struct sigqueue *sigqueue_alloc(void) ;
extern void sigqueue_free(struct sigqueue * ) ;
extern int send_sigqueue(int  , struct sigqueue * , struct task_struct * ) ;
extern int send_group_sigqueue(int  , struct sigqueue * , struct task_struct * ) ;
extern int do_sigaction(int  , struct k_sigaction  const  * , struct k_sigaction * ) ;
extern int do_sigaltstack(stack_t const   * , stack_t * , unsigned long  ) ;
__inline static int __attribute__((__always_inline__))  on_sig_stack(unsigned long sp ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp = get_current();
  tmp___0 = get_current();
  return ((int __attribute__((__always_inline__))  )(sp - tmp->sas_ss_sp < (unsigned long )tmp___0->sas_ss_size));
}
}
__inline static int __attribute__((__always_inline__))  sas_ss_flags(unsigned long sp ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;
  int tmp___3 ;
  int __attribute__((__always_inline__))  tmp___4 ;
  int __attribute__((__always_inline__))  tmp___5 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___6 ;

  {
  tmp___6 = get_current();
  if (tmp___6->sas_ss_size == 0U) {
    tmp___3 = 2;
  } else {
    tmp___5 = on_sig_stack(sp);
    if (tmp___5) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___3);
}
}
__inline static int __attribute__((__always_inline__))  capable(int cap ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp___0 = get_current();
  if (tmp___0->cap_effective & (unsigned int )(1 << cap)) {
    tmp = get_current();
    tmp->flags |= 256UL;
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern struct mm_struct *mm_alloc(void) ;
extern void ( __attribute__((__regparm__(3))) __mmdrop)(struct mm_struct * ) ;
__inline static void __attribute__((__always_inline__))  mmdrop(struct mm_struct *mm ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = atomic_dec_and_test(& mm->mm_count);
  if (tmp) {
    __mmdrop(mm);
  }
  return;
}
}
extern void mmput(struct mm_struct * ) ;
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
extern int copy_thread(int  , unsigned long  , unsigned long  , unsigned long  , struct task_struct * ,
                       struct pt_regs * ) ;
extern void flush_thread(void) ;
extern void exit_thread(void) ;
extern void exit_files(struct task_struct * ) ;
extern void exit_signal(struct task_struct * ) ;
extern void __exit_signal(struct task_struct * ) ;
extern void exit_sighand(struct task_struct * ) ;
extern void __exit_sighand(struct task_struct * ) ;
extern void exit_itimers(struct signal_struct * ) ;
extern void do_group_exit(int  ) ;
extern void daemonize(char const   *  , ...) ;
extern int allow_signal(int  ) ;
extern int disallow_signal(int  ) ;
extern task_t *child_reaper ;
extern int do_execve(char * , char ** , char ** , struct pt_regs * ) ;
extern long do_fork(unsigned long  , unsigned long  , struct pt_regs * , unsigned long  ,
                    int * , int * ) ;
extern task_t *fork_idle(int  ) ;
extern void set_task_comm(struct task_struct *tsk , char *from ) ;
extern void get_task_comm(char *to , struct task_struct *tsk ) ;
extern void wait_task_inactive(task_t *p ) ;
extern task_t *( __attribute__((__regparm__(3))) next_thread)(task_t const   *p ) ;
__inline static int __attribute__((__always_inline__))  thread_group_empty(task_t *p ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = list_empty((struct list_head  const  *)(& p->pids[1].pid_list));
  return (tmp);
}
}
extern void unhash_process(struct task_struct *p ) ;
__inline static void __attribute__((__always_inline__))  task_lock(struct task_struct *p ) 
{ 

  {
  _spin_lock(& p->alloc_lock);
  return;
}
}
__inline static void __attribute__((__always_inline__))  task_unlock(struct task_struct *p ) 
{ 

  {
  _spin_unlock(& p->alloc_lock);
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_tsk_thread_flag(struct task_struct *tsk ,
                                                                             int flag ) 
{ 

  {
  set_ti_thread_flag(tsk->thread_info, flag);
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_tsk_thread_flag(struct task_struct *tsk ,
                                                                               int flag ) 
{ 

  {
  clear_ti_thread_flag(tsk->thread_info, flag);
  return;
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_tsk_thread_flag(struct task_struct *tsk ,
                                                                                     int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_ti_thread_flag(tsk->thread_info, flag);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_tsk_thread_flag(struct task_struct *tsk ,
                                                                                       int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_clear_ti_thread_flag(tsk->thread_info, flag);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_tsk_thread_flag(struct task_struct *tsk ,
                                                                             int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_ti_thread_flag(tsk->thread_info, flag);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  set_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  set_tsk_thread_flag(tsk, 3);
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  clear_tsk_thread_flag(tsk, 3);
  return;
}
}
__inline static int __attribute__((__always_inline__))  signal_pending(struct task_struct *p ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = test_tsk_thread_flag(p, 2);
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = (int __attribute__((__always_inline__))  )__builtin_expect((long )tmp___0,
                                                                       0L);
  return (tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  need_resched(void) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = test_thread_flag(3);
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = (int __attribute__((__always_inline__))  )__builtin_expect((long )tmp___0,
                                                                       0L);
  return (tmp___1);
}
}
extern int cond_resched(void) ;
extern int cond_resched_lock(spinlock_t *lock ) ;
extern int cond_resched_softirq(void) ;
__inline static int __attribute__((__always_inline__))  lock_need_resched(spinlock_t *lock ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = need_resched();
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern void ( __attribute__((__regparm__(3))) recalc_sigpending_tsk)(struct task_struct *t ) ;
extern void recalc_sigpending(void) ;
extern void signal_wake_up(struct task_struct *t , int resume_stopped ) ;
__inline static unsigned int __attribute__((__always_inline__))  task_cpu(struct task_struct  const  *p ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(p->thread_info)->cpu);
}
}
__inline static void __attribute__((__always_inline__))  set_task_cpu(struct task_struct *p ,
                                                                      unsigned int cpu ) 
{ 

  {
  (p->thread_info)->cpu = cpu;
  return;
}
}
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
extern long sched_setaffinity(pid_t pid , cpumask_t new_mask ) ;
extern long sched_getaffinity(pid_t pid , cpumask_t *mask ) ;
extern void normalize_rt_tasks(void) ;
extern void refrigerator(unsigned long  ) ;
extern int freeze_processes(void) ;
extern void thaw_processes(void) ;
__inline static int __attribute__((__always_inline__))  try_to_freeze(unsigned long refrigerator_flags ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = get_current();
  if (tmp->flags & 16384UL) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  if (tmp___1) {
    refrigerator(refrigerator_flags);
    return ((int __attribute__((__always_inline__))  )1);
  } else {
    return ((int __attribute__((__always_inline__))  )0);
  }
}
}
extern int ( /* format attribute */  request_module)(char const   *name  , ...) ;
extern int call_usermodehelper(char *path , char **argv , char **envp , int wait ) ;
extern void usermodehelper_init(void) ;
extern struct new_utsname system_utsname ;
extern struct rw_semaphore uts_sem ;
extern int dump_task_regs(struct task_struct * , elf_gregset_t * ) ;
extern int dump_task_fpu(struct task_struct * , elf_fpregset_t * ) ;
extern int dump_task_extended_fpu(struct task_struct * , struct user_fxsr_struct * ) ;
extern void __kernel_vsyscall ;
extern Elf32_Dyn _DYNAMIC[] ;
extern int sysfs_create_dir(struct kobject * ) ;
extern void sysfs_remove_dir(struct kobject * ) ;
extern int sysfs_rename_dir(struct kobject * , char const   *new_name ) ;
extern int sysfs_create_file(struct kobject * , struct attribute  const  * ) ;
extern int sysfs_update_file(struct kobject * , struct attribute  const  * ) ;
extern int sysfs_chmod_file(struct kobject *kobj , struct attribute *attr , mode_t mode ) ;
extern void sysfs_remove_file(struct kobject * , struct attribute  const  * ) ;
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char *name ) ;
extern void sysfs_remove_link(struct kobject * , char *name ) ;
extern int sysfs_create_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern int sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern int sysfs_create_group(struct kobject * , struct attribute_group  const  * ) ;
extern void sysfs_remove_group(struct kobject * , struct attribute_group  const  * ) ;
extern void kref_init(struct kref *kref ) ;
extern void kref_get(struct kref *kref ) ;
extern int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) ;
extern char hotplug_path[] ;
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action , struct attribute *attr ) ;
extern int kobject_uevent_atomic(struct kobject *kobj , enum kobject_action action ,
                                 struct attribute *attr ) ;
extern u64 hotplug_seqnum ;
extern int ( /* format attribute */  kobject_set_name)(struct kobject * , char const   * 
                                                       , ...) ;
__inline static char __attribute__((__always_inline__))  *kobject_name(struct kobject *kobj ) 
{ 

  {
  return ((char __attribute__((__always_inline__))  *)kobj->k_name);
}
}
extern void kobject_init(struct kobject * ) ;
extern void kobject_cleanup(struct kobject * ) ;
extern int kobject_add(struct kobject * ) ;
extern void kobject_del(struct kobject * ) ;
extern int kobject_rename(struct kobject * , char *new_name ) ;
extern int kobject_register(struct kobject * ) ;
extern void kobject_unregister(struct kobject * ) ;
extern struct kobject *kobject_get(struct kobject * ) ;
extern void kobject_put(struct kobject * ) ;
extern char *kobject_get_path(struct kobject * , int  ) ;
extern void kset_init(struct kset *k ) ;
extern int kset_add(struct kset *k ) ;
extern int kset_register(struct kset *k ) ;
extern void kset_unregister(struct kset *k ) ;
__inline static struct kset  __attribute__((__always_inline__)) *to_kset(struct kobject *kobj ) 
{ struct kobject  const  *__mptr ;
  struct kset *tmp ;
  struct kobject  const  *__mptr___0 ;

  {
  if (kobj) {
    __mptr___0 = (struct kobject  const  *)kobj;
    tmp = (struct kset *)((char *)__mptr___0 - (unsigned int )(& ((struct kset *)0)->kobj));
  } else {
    tmp = (struct kset *)((void *)0);
  }
  return ((struct kset  __attribute__((__always_inline__)) *)tmp);
}
}
__inline static struct kset  __attribute__((__always_inline__)) *kset_get(struct kset *k ) 
{ struct kobject *tmp ;
  struct kset  __attribute__((__always_inline__)) *tmp___0 ;
  struct kset  __attribute__((__always_inline__)) *tmp___1 ;
  struct kobject *tmp___2 ;

  {
  if (k) {
    tmp___2 = kobject_get(& k->kobj);
    tmp___1 = to_kset(tmp___2);
  } else {
    tmp___1 = (struct kset  __attribute__((__always_inline__)) *)((void *)0);
  }
  return (tmp___1);
}
}
__inline static void __attribute__((__always_inline__))  kset_put(struct kset *k ) 
{ 

  {
  kobject_put(& k->kobj);
  return;
}
}
__inline static struct kobj_type  __attribute__((__always_inline__)) *get_ktype(struct kobject *k ) 
{ 

  {
  if (k->kset) {
    if ((k->kset)->ktype) {
      return ((struct kobj_type  __attribute__((__always_inline__)) *)(k->kset)->ktype);
    } else {
      return ((struct kobj_type  __attribute__((__always_inline__)) *)k->ktype);
    }
  } else {
    return ((struct kobj_type  __attribute__((__always_inline__)) *)k->ktype);
  }
}
}
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
extern struct subsystem kernel_subsys ;
extern void subsystem_init(struct subsystem * ) ;
extern int subsystem_register(struct subsystem * ) ;
extern void subsystem_unregister(struct subsystem * ) ;
__inline static struct subsystem  __attribute__((__always_inline__)) *subsys_get(struct subsystem *s ) 
{ struct kset  const  *__mptr ;
  struct kset  const  *tmp ;
  struct subsystem *tmp___0 ;
  struct kset  const  *__mptr___0 ;
  struct kset  const  *tmp___1 ;

  {
  if (s) {
    tmp___1 = (struct kset  const  *)kset_get(& s->kset);
    __mptr___0 = tmp___1;
    tmp___0 = (struct subsystem *)((char *)__mptr___0 - (unsigned int )(& ((struct subsystem *)0)->kset));
  } else {
    tmp___0 = (struct subsystem *)((void *)0);
  }
  return ((struct subsystem  __attribute__((__always_inline__)) *)tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  subsys_put(struct subsystem *s ) 
{ 

  {
  kset_put(& s->kset);
  return;
}
}
extern int subsys_create_file(struct subsystem * , struct subsys_attribute * ) ;
extern void subsys_remove_file(struct subsystem * , struct subsys_attribute * ) ;
extern void kobject_hotplug(struct kobject *kobj , enum kobject_action action ) ;
extern int ( /* format attribute */  add_hotplug_env_var)(char **envp , int num_envp ,
                                                          int *cur_index , char *buffer ,
                                                          int buffer_size , int *cur_len ,
                                                          char const   *format  , ...) ;
extern int parse_args(char const   *name , char *args , struct kernel_param *params ,
                      unsigned int num , int (*unknown)(char *param , char *val ) ) ;
extern int param_set_byte(char const   *val , struct kernel_param *kp ) ;
extern int param_get_byte(char *buffer , struct kernel_param *kp ) ;
extern int param_set_short(char const   *val , struct kernel_param *kp ) ;
extern int param_get_short(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ushort(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ushort(char *buffer , struct kernel_param *kp ) ;
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ulong(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ulong(char *buffer , struct kernel_param *kp ) ;
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
extern int param_set_invbool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_invbool(char *buffer , struct kernel_param *kp ) ;
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
extern int param_set_copystring(char const   *val , struct kernel_param *kp ) ;
extern int param_get_string(char *buffer , struct kernel_param *kp ) ;
extern int param_array(char const   *name , char const   *val , unsigned int min ,
                       unsigned int max , void *elem , int elemsize , int (*set)(char const   * ,
                                                                                 struct kernel_param *kp ) ,
                       int *num ) ;
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param *kparam ,
                                    unsigned int num_params ) ;
extern void module_param_sysfs_remove(struct module *mod ) ;
__inline static void __attribute__((__always_inline__))  local_inc(local_t *v ) 
{ 

  {
  __asm__  volatile   ("incl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  local_dec(local_t *v ) 
{ 

  {
  __asm__  volatile   ("decl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  local_add(unsigned long i ,
                                                                   local_t *v ) 
{ 

  {
  __asm__  volatile   ("addl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  local_sub(unsigned long i ,
                                                                   local_t *v ) 
{ 

  {
  __asm__  volatile   ("subl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
int init_module(void) ;
void cleanup_module(void) ;
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
extern void sort_main_extable(void) ;
extern struct subsystem module_subsys ;
struct module __this_module  __attribute__((__section__(".gnu.linkonce.this_module"))) ;
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
extern void *__symbol_get(char const   *symbol ) ;
extern void *__symbol_get_gpl(char const   *symbol ) ;
__inline static int __attribute__((__always_inline__))  module_is_live(struct module *mod ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((int )mod->state != 2));
}
}
extern struct module *module_text_address(unsigned long addr ) ;
extern struct module *__module_text_address(unsigned long addr ) ;
extern struct module *module_get_kallsym(unsigned int symnum , unsigned long *value ,
                                         char *type , char *namebuf ) ;
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
extern int is_exported(char const   *name , struct module  const  *mod ) ;
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
__inline static int __attribute__((__always_inline__))  try_module_get(struct module *module ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  if (! module) {
    tmp___0 = 1;
  } else {
    tmp = module_is_live(module);
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  module_put(struct module *module ) 
{ 

  {
  return;
}
}
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ) ;
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
extern int register_module_notifier(struct notifier_block *nb ) ;
extern int unregister_module_notifier(struct notifier_block *nb ) ;
extern void print_modules(void) ;
extern void module_add_driver(struct module * , struct device_driver * ) ;
extern void module_remove_driver(struct device_driver * ) ;
extern void __attribute__((__deprecated__))  inter_module_register(char const   * ,
                                                                   struct module * ,
                                                                   void const   * ) ;
extern void __attribute__((__deprecated__))  inter_module_unregister(char const   * ) ;
extern void const   * __attribute__((__deprecated__)) inter_module_get_request(char const   * ,
                                                                               char const   * ) ;
extern void __attribute__((__deprecated__))  inter_module_put(char const   * ) ;
extern int ( __attribute__((__regparm__(3))) __reacquire_kernel_lock)(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) __release_kernel_lock)(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static int __attribute__((__always_inline__))  reacquire_kernel_lock(struct task_struct *task ) 
{ int __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;

  {
  tmp___0 = __builtin_expect((long )(! (! (task->lock_depth >= 0)) != 0), 0L);
  if (tmp___0) {
    tmp = (int __attribute__((__always_inline__))  )__reacquire_kernel_lock();
    return (tmp);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern void ( __attribute__((__regparm__(3))) lock_kernel)(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) unlock_kernel)(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static int __attribute__((__always_inline__))  irq_canonicalize(int irq___0 ) 
{ int tmp ;

  {
  if (irq___0 == 2) {
    tmp = 9;
  } else {
    tmp = irq___0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
extern void release_vm86_irqs(struct task_struct * ) ;
extern int irqbalance_disable(char *str ) ;
extern irq_desc_t irq_desc[224] ;
extern void profile_init(void)  __attribute__((__section__(".init.text"))) ;
extern void profile_tick(int  , struct pt_regs * ) ;
extern void profile_hit(int  , void * ) ;
extern void create_prof_cpu_mask(struct proc_dir_entry * ) ;
extern void profile_task_exit(struct task_struct *task ) ;
extern int profile_handoff_task(struct task_struct *task ) ;
extern void profile_munmap(unsigned long addr ) ;
extern int task_handoff_register(struct notifier_block *n ) ;
extern int task_handoff_unregister(struct notifier_block *n ) ;
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
extern int register_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern void unregister_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern int (*timer_hook)(struct pt_regs * ) ;
extern char _text[] ;
extern char _stext[] ;
extern char _etext[] ;
extern char _data[] ;
extern char _sdata[] ;
extern char _edata[] ;
extern char __bss_start[] ;
extern char __bss_stop[] ;
extern char __init_begin[] ;
extern char __init_end[] ;
extern char _sinittext[] ;
extern char _einittext[] ;
extern char _sextratext[]  __attribute__((__weak__)) ;
extern char _eextratext[]  __attribute__((__weak__)) ;
extern char _end[] ;
extern u8 irq_vector[256] ;
extern void (*interrupt[224])(void) ;
extern void ( __attribute__((__regparm__(3))) reschedule_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) invalidate_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) call_function_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) apic_timer_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) error_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) spurious_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) thermal_interrupt)(struct pt_regs * ) ;
extern void disable_8259A_irq(unsigned int irq ) ;
extern void enable_8259A_irq(unsigned int irq ) ;
extern int i8259A_irq_pending(unsigned int irq ) ;
extern void make_8259A_irq(unsigned int irq ) ;
extern void init_8259A(int aeoi ) ;
extern void ( __attribute__((__regparm__(3))) send_IPI_self)(int vector ) ;
extern void init_VISWS_APIC_irqs(void) ;
extern void setup_IO_APIC(void) ;
extern void disable_IO_APIC(void) ;
extern void print_IO_APIC(void) ;
extern int IO_APIC_get_PCI_irq_vector(int bus , int slot , int fn ) ;
extern void send_IPI(int dest , int vector ) ;
extern void setup_ioapic_dest(void) ;
extern unsigned long io_apic_irqs ;
extern atomic_t irq_err_count ;
extern atomic_t irq_mis_count ;
__inline static void __attribute__((__always_inline__))  hw_resend_irq(struct hw_interrupt_type *h ,
                                                                       unsigned int i ) 
{ 

  {
  if (i >= 16U) {
    send_IPI_self((int )irq_vector[i]);
  } else {
    if ((unsigned long )(1 << i) & io_apic_irqs) {
      send_IPI_self((int )irq_vector[i]);
    }
  }
  return;
}
}
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
extern cpumask_t irq_affinity[224] ;
extern int no_irq_affinity ;
extern int noirqdebug_setup(char *str ) ;
extern int ( __attribute__((__regparm__(3))) handle_IRQ_event)(unsigned int irq ,
                                                               struct pt_regs *regs ,
                                                               struct irqaction *action ) ;
extern unsigned int ( __attribute__((__regparm__(3))) __do_IRQ)(unsigned int irq ,
                                                                struct pt_regs *regs ) ;
extern void note_interrupt(unsigned int irq , irq_desc_t *desc , int action_ret ) ;
extern void report_bad_irq(unsigned int irq , irq_desc_t *desc , int action_ret ) ;
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
extern void init_irq_proc(void) ;
extern hw_irq_controller no_irq_type ;
extern irq_cpustat_t per_cpu__irq_stat ;
extern irq_cpustat_t irq_stat[] ;
extern void ack_bad_irq(unsigned int irq ) ;
extern void synchronize_irq(unsigned int irq ) ;
__inline static void __attribute__((__always_inline__))  account_user_vtime(struct task_struct *tsk ) 
{ 

  {
  return;
}
}
extern void irq_exit(void) ;
extern irqreturn_t no_action(int cpl , void *dev_id , struct pt_regs *regs ) ;
extern int request_irq(unsigned int  , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                       unsigned long  , char const   * , void * ) ;
extern void free_irq(unsigned int  , void * ) ;
extern void disable_irq_nosync(unsigned int irq ) ;
extern void disable_irq(unsigned int irq ) ;
extern void enable_irq(unsigned int irq ) ;
extern void local_bh_enable(void) ;
extern void ( __attribute__((__regparm__(0))) do_softirq)(void) ;
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) , void *data ) ;
extern void softirq_init(void) ;
extern void ( __attribute__((__regparm__(3))) raise_softirq_irqoff)(unsigned int nr ) ;
extern void ( __attribute__((__regparm__(3))) raise_softirq)(unsigned int nr ) ;
__inline static int __attribute__((__always_inline__))  tasklet_trylock(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  tmp = test_and_set_bit(1, (unsigned long volatile   *)(& t->state));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  tasklet_unlock(struct tasklet_struct *t ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  clear_bit(1, (unsigned long volatile   *)(& t->state));
}
}
__inline static void __attribute__((__always_inline__))  tasklet_unlock_wait(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    tmp = constant_test_bit(1, (unsigned long const volatile   *)(& t->state));
    if (! tmp) {
      break;
    }
    __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __tasklet_schedule)(struct tasklet_struct *t ) ;
__inline static void __attribute__((__always_inline__))  tasklet_schedule(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  if (! tmp) {
    __tasklet_schedule(t);
  }
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __tasklet_hi_schedule)(struct tasklet_struct *t ) ;
__inline static void __attribute__((__always_inline__))  tasklet_hi_schedule(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  if (! tmp) {
    __tasklet_hi_schedule(t);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 

  {
  atomic_inc(& t->count);
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  tasklet_disable(struct tasklet_struct *t ) 
{ 

  {
  tasklet_disable_nosync(t);
  tasklet_unlock_wait(t);
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
}
}
__inline static void __attribute__((__always_inline__))  tasklet_enable(struct tasklet_struct *t ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  atomic_dec(& t->count);
}
}
extern void tasklet_kill(struct tasklet_struct *t ) ;
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
extern unsigned long probe_irq_on(void) ;
extern int probe_irq_off(unsigned long  ) ;
extern unsigned int probe_irq_mask(unsigned long  ) ;
extern int ptrace_readdata(struct task_struct *tsk , unsigned long src , char *dst ,
                           int len ) ;
extern int ptrace_writedata(struct task_struct *tsk , char *src , unsigned long dst ,
                            int len ) ;
extern int ptrace_attach(struct task_struct *tsk ) ;
extern int ptrace_detach(struct task_struct * , unsigned int  ) ;
extern void ptrace_disable(struct task_struct * ) ;
extern int ptrace_check_attach(struct task_struct *task , int kill ) ;
extern int ptrace_request(struct task_struct *child , long request , long addr , long data ) ;
extern void ptrace_notify(int exit_code ) ;
extern void __ptrace_link(struct task_struct *child , struct task_struct *new_parent ) ;
extern void __ptrace_unlink(struct task_struct *child ) ;
extern void ptrace_untrace(struct task_struct *child ) ;
__inline static void __attribute__((__always_inline__))  ptrace_link(struct task_struct *child ,
                                                                     struct task_struct *new_parent ) 
{ long tmp ;

  {
  tmp = __builtin_expect((long )(! (! child->ptrace) != 0), 0L);
  if (tmp) {
    __ptrace_link(child, new_parent);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  ptrace_unlink(struct task_struct *child ) 
{ long tmp ;

  {
  tmp = __builtin_expect((long )(! (! child->ptrace) != 0), 0L);
  if (tmp) {
    __ptrace_unlink(child);
  }
  return;
}
}
extern struct resource ioport_resource ;
extern struct resource iomem_resource ;
extern int request_resource(struct resource *root , struct resource *new ) ;
extern struct resource *____request_resource(struct resource *root , struct resource *new ) ;
extern int release_resource(struct resource *new ) ;
extern int insert_resource(struct resource *parent , struct resource *new ) ;
extern int allocate_resource(struct resource *root , struct resource *new , unsigned long size ,
                             unsigned long min , unsigned long max , unsigned long align ,
                             void (*alignf)(void * , struct resource * , unsigned long  ,
                                            unsigned long  ) , void *alignf_data ) ;
extern int adjust_resource(struct resource *res , unsigned long start , unsigned long size ) ;
extern struct resource *__request_region(struct resource * , unsigned long start ,
                                         unsigned long n , char const   *name ) ;
extern int __check_region(struct resource * , unsigned long  , unsigned long  ) ;
extern void __release_region(struct resource * , unsigned long  , unsigned long  ) ;
__inline static int __attribute__((__deprecated__, __always_inline__))  check_region(unsigned long s ,
                                                                                     unsigned long n ) 
{ int __attribute__((__deprecated__, __always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__deprecated__, __always_inline__))  )__check_region(& ioport_resource,
                                                                                 s,
                                                                                 n);
  return (tmp);
}
}
__inline static size_t __attribute__((__always_inline__))  iov_length(struct iovec  const  *iov ,
                                                                      unsigned long nr_segs ) 
{ unsigned long seg ;
  size_t ret ;

  {
  ret = (size_t )0;
  seg = 0UL;
  while (seg < nr_segs) {
    ret += (size_t )(iov + seg)->iov_len;
    seg ++;
  }
  return (ret);
}
}
extern unsigned long iov_shorten(struct iovec *iov , unsigned long nr_segs , size_t to ) ;
__inline static struct cmsghdr  __attribute__((__always_inline__)) *__cmsg_nxthdr(void *__ctl ,
                                                                                  __kernel_size_t __size ,
                                                                                  struct cmsghdr *__cmsg ) 
{ struct cmsghdr *__ptr ;

  {
  __ptr = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(long )) -
                                                         1U) & ~ (sizeof(long ) -
                                                                  1U)));
  if ((unsigned long )((char *)(__ptr + 1) - (char *)__ctl) > (unsigned long )__size) {
    return ((struct cmsghdr  __attribute__((__always_inline__)) *)((struct cmsghdr *)0));
  }
  return ((struct cmsghdr  __attribute__((__always_inline__)) *)__ptr);
}
}
__inline static struct cmsghdr  __attribute__((__always_inline__)) *cmsg_nxthdr(struct msghdr *__msg ,
                                                                                struct cmsghdr *__cmsg ) 
{ struct cmsghdr  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
  return (tmp);
}
}
extern int memcpy_fromiovec(unsigned char *kdata , struct iovec *iov , int len ) ;
extern int memcpy_fromiovecend(unsigned char *kdata , struct iovec *iov , int offset ,
                               int len ) ;
extern int csum_partial_copy_fromiovecend(unsigned char *kdata , struct iovec *iov ,
                                          int offset , unsigned int len , int *csump ) ;
extern int verify_iovec(struct msghdr *m , struct iovec *iov , char *address , int mode ) ;
extern int memcpy_toiovec(struct iovec *v , unsigned char *kdata , int len ) ;
extern int move_addr_to_user(void *kaddr , int klen , void *uaddr , int *ulen ) ;
extern int move_addr_to_kernel(void *uaddr , int ulen , void *kaddr ) ;
extern int put_cmsg(struct msghdr * , int level , int type , int len , void *data ) ;
extern unsigned long loops_per_jiffy ;
extern void __bad_udelay(void) ;
extern void __bad_ndelay(void) ;
extern void __udelay(unsigned long usecs ) ;
extern void __ndelay(unsigned long nsecs ) ;
extern void __const_udelay(unsigned long usecs ) ;
extern void __delay(unsigned long loops ) ;
extern void calibrate_delay(void) ;
extern void msleep(unsigned int msecs ) ;
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
__inline static void __attribute__((__always_inline__))  ssleep(unsigned int seconds ) 
{ 

  {
  msleep(seconds * 1000U);
  return;
}
}
extern unsigned int ( __attribute__((__regparm__(3))) ioread8)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread16)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread16be)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread32)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread32be)(void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite8)(u8  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite16)(u16  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite16be)(u16  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite32)(u32  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite32be)(u32  , void * ) ;
extern void ( __attribute__((__regparm__(3))) ioread8_rep)(void *port , void *buf ,
                                                           unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) ioread16_rep)(void *port , void *buf ,
                                                            unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) ioread32_rep)(void *port , void *buf ,
                                                            unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) iowrite8_rep)(void *port , void const   *buf ,
                                                            unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) iowrite16_rep)(void *port , void const   *buf ,
                                                             unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) iowrite32_rep)(void *port , void const   *buf ,
                                                             unsigned long count ) ;
extern void *ioport_map(unsigned long port , unsigned int nr ) ;
extern void ioport_unmap(void * ) ;
extern void *pci_iomap(struct pci_dev *dev , int bar , unsigned long max ) ;
extern void pci_iounmap(struct pci_dev *dev , void * ) ;
extern void *vmalloc(unsigned long size ) ;
extern void *vmalloc_exec(unsigned long size ) ;
extern void *vmalloc_32(unsigned long size ) ;
extern void *__vmalloc(unsigned long size , unsigned int gfp_mask , pgprot_t prot ) ;
extern void *__vmalloc_area(struct vm_struct *area , unsigned int gfp_mask , pgprot_t prot ) ;
extern void vfree(void *addr ) ;
extern void *vmap(struct page **pages , unsigned int count , unsigned long flags ,
                  pgprot_t prot ) ;
extern void vunmap(void *addr ) ;
extern struct vm_struct *get_vm_area(unsigned long size , unsigned long flags ) ;
extern struct vm_struct *__get_vm_area(unsigned long size , unsigned long flags ,
                                       unsigned long start , unsigned long end ) ;
extern struct vm_struct *remove_vm_area(void *addr ) ;
extern struct vm_struct *__remove_vm_area(void *addr ) ;
extern int map_vm_area(struct vm_struct *area , pgprot_t prot , struct page ***pages ) ;
extern void unmap_vm_area(struct vm_struct *area ) ;
extern rwlock_t vmlist_lock ;
extern struct vm_struct *vmlist ;
__inline static unsigned long __attribute__((__always_inline__))  virt_to_phys(void volatile   *address ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((unsigned long )address -
                                                               3221225472UL));
}
}
__inline static void __attribute__((__always_inline__))  *phys_to_virt(unsigned long address ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((void *)(address + 3221225472UL)));
}
}
extern void *__ioremap(unsigned long offset , unsigned long size , unsigned long flags ) ;
__inline static void __attribute__((__always_inline__))  *ioremap(unsigned long offset ,
                                                                  unsigned long size ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = (void __attribute__((__always_inline__))  *)__ioremap(offset, size, 0UL);
  return (tmp);
}
}
extern void *ioremap_nocache(unsigned long offset , unsigned long size ) ;
extern void iounmap(void volatile   *addr ) ;
extern void *bt_ioremap(unsigned long offset , unsigned long size ) ;
extern void bt_iounmap(void *addr , unsigned long size ) ;
__inline static unsigned char __attribute__((__always_inline__))  readb(void const volatile   *addr ) 
{ 

  {
  return ((unsigned char __attribute__((__always_inline__))  )(*((unsigned char volatile   *)addr)));
}
}
__inline static unsigned short __attribute__((__always_inline__))  readw(void const volatile   *addr ) 
{ 

  {
  return ((unsigned short __attribute__((__always_inline__))  )(*((unsigned short volatile   *)addr)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  readl(void const volatile   *addr ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(*((unsigned int volatile   *)addr)));
}
}
__inline static void __attribute__((__always_inline__))  writeb(unsigned char b ,
                                                                void volatile   *addr ) 
{ 

  {
  (*((unsigned char volatile   *)addr)) = (unsigned char volatile   )b;
  return;
}
}
__inline static void __attribute__((__always_inline__))  writew(unsigned short b ,
                                                                void volatile   *addr ) 
{ 

  {
  (*((unsigned short volatile   *)addr)) = (unsigned short volatile   )b;
  return;
}
}
__inline static void __attribute__((__always_inline__))  writel(unsigned int b , void volatile   *addr ) 
{ 

  {
  (*((unsigned int volatile   *)addr)) = (unsigned int volatile   )b;
  return;
}
}
__inline static void __attribute__((__always_inline__))  memset_io(void volatile   *addr ,
                                                                   unsigned char val ,
                                                                   int count ) 
{ 

  {
  __memset_generic((void *)addr, (char )val, (unsigned int )count);
  return;
}
}
__inline static void __attribute__((__always_inline__))  memcpy_fromio(void *dst ,
                                                                       void const volatile   *src ,
                                                                       int count ) 
{ 

  {
  __memcpy(dst, (void const   *)((void *)src), (unsigned int )count);
  return;
}
}
__inline static void __attribute__((__always_inline__))  memcpy_toio(void volatile   *dst ,
                                                                     void const   *src ,
                                                                     int count ) 
{ 

  {
  __memcpy((void *)dst, src, (unsigned int )count);
  return;
}
}
__inline static int __attribute__((__always_inline__))  check_signature(void volatile   *io_addr ,
                                                                        unsigned char const   *signature ,
                                                                        int length ) 
{ int retval ;
  unsigned char __attribute__((__always_inline__))  tmp ;

  {
  retval = 0;
  while (1) {
    tmp = readb((void const volatile   *)io_addr);
    if ((int __attribute__((__always_inline__))  )tmp != (int __attribute__((__always_inline__))  )(*signature)) {
      goto out;
    }
    io_addr ++;
    signature ++;
    length --;
    if (! length) {
      break;
    }
  }
  retval = 1;
  out: 
  return ((int __attribute__((__always_inline__))  )retval);
}
}
__inline static void __attribute__((__always_inline__))  flush_write_buffers(void) 
{ 

  {
  __asm__  volatile   ("lock; addl $0,0(%%esp)": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  slow_down_io(void) 
{ 

  {
  __asm__  volatile   ("outb %%al,$0x80;":);
}
}
__inline static void __attribute__((__always_inline__))  outb_local(unsigned char value ,
                                                                    int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb_local(int port ) 
{ unsigned char value ;

  {
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  return ((unsigned char __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outb_local_p(unsigned char value ,
                                                                      int port ) 
{ 

  {
  outb_local(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb_local_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  tmp = (unsigned char )inb_local(port);
  value = tmp;
  slow_down_io();
  return ((unsigned char __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outb(unsigned char value ,
                                                              int port ) 
{ 

  {
  outb_local(value, port);
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb(int port ) 
{ unsigned char __attribute__((__always_inline__))  tmp ;

  {
  tmp = inb_local(port);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  outb_p(unsigned char value ,
                                                                int port ) 
{ 

  {
  outb(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  tmp = (unsigned char )inb(port);
  value = tmp;
  slow_down_io();
  return ((unsigned char __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outsb(int port , void const   *addr ,
                                                               unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  insb(int port , void *addr ,
                                                              unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  outw_local(unsigned short value ,
                                                                    int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw_local(int port ) 
{ unsigned short value ;

  {
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  return ((unsigned short __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outw_local_p(unsigned short value ,
                                                                      int port ) 
{ 

  {
  outw_local(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw_local_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  tmp = (unsigned short )inw_local(port);
  value = tmp;
  slow_down_io();
  return ((unsigned short __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outw(unsigned short value ,
                                                              int port ) 
{ 

  {
  outw_local(value, port);
  return;
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw(int port ) 
{ unsigned short __attribute__((__always_inline__))  tmp ;

  {
  tmp = inw_local(port);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  outw_p(unsigned short value ,
                                                                int port ) 
{ 

  {
  outw(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  tmp = (unsigned short )inw(port);
  value = tmp;
  slow_down_io();
  return ((unsigned short __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outsw(int port , void const   *addr ,
                                                               unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  insw(int port , void *addr ,
                                                              unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  outl_local(unsigned int value ,
                                                                    int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl_local(int port ) 
{ unsigned int value ;

  {
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  return ((unsigned int __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outl_local_p(unsigned int value ,
                                                                      int port ) 
{ 

  {
  outl_local(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl_local_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  tmp = (unsigned int )inl_local(port);
  value = tmp;
  slow_down_io();
  return ((unsigned int __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outl(unsigned int value ,
                                                              int port ) 
{ 

  {
  outl_local(value, port);
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl(int port ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = inl_local(port);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  outl_p(unsigned int value ,
                                                                int port ) 
{ 

  {
  outl(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  tmp = (unsigned int )inl(port);
  value = tmp;
  slow_down_io();
  return ((unsigned int __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outsl(int port , void const   *addr ,
                                                               unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; outs"
                       "l": "+S" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  insl(int port , void *addr ,
                                                              unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; ins"
                       "l": "+D" (addr), "+c" (count): "d" (port));
}
}
extern spinlock_t dma_spin_lock ;
__inline static unsigned long __attribute__((__always_inline__))  claim_dma_lock(void) 
{ unsigned long flags ;

  {
  flags = _spin_lock_irqsave(& dma_spin_lock);
  return ((unsigned long __attribute__((__always_inline__))  )flags);
}
}
__inline static void __attribute__((__always_inline__))  release_dma_lock(unsigned long flags ) 
{ 

  {
  _spin_unlock_irqrestore(& dma_spin_lock, flags);
  return;
}
}
__inline static void __attribute__((__always_inline__))  enable_dma(unsigned int dmanr ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char )dmanr, 10);
  } else {
    outb((unsigned char )(dmanr & 3U), 212);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  disable_dma(unsigned int dmanr ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char )(dmanr | 4U), 10);
  } else {
    outb((unsigned char )((dmanr & 3U) | 4U), 212);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_dma_ff(unsigned int dmanr ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char)0, 12);
  } else {
    outb((unsigned char)0, 216);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_mode(unsigned int dmanr ,
                                                                      char mode ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char )((unsigned int )mode | dmanr), 11);
  } else {
    outb((unsigned char )((unsigned int )mode | (dmanr & 3U)), 214);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_page(unsigned int dmanr ,
                                                                      char pagenr ) 
{ 

  {
  switch ((int )dmanr) {
  case 0: 
  outb((unsigned char )pagenr, 135);
  break;
  case 1: 
  outb((unsigned char )pagenr, 131);
  break;
  case 2: 
  outb((unsigned char )pagenr, 129);
  break;
  case 3: 
  outb((unsigned char )pagenr, 130);
  break;
  case 5: 
  outb((unsigned char )((int )pagenr & 254), 139);
  break;
  case 6: 
  outb((unsigned char )((int )pagenr & 254), 137);
  break;
  case 7: 
  outb((unsigned char )((int )pagenr & 254), 138);
  break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_addr(unsigned int dmanr ,
                                                                      unsigned int a ) 
{ 

  {
  set_dma_page(dmanr, (char )(a >> 16));
  if (dmanr <= 3U) {
    outb((unsigned char )(a & 255U), (int )((dmanr & 3U) << 1));
    outb((unsigned char )((a >> 8) & 255U), (int )((dmanr & 3U) << 1));
  } else {
    outb((unsigned char )((a >> 1) & 255U), (int )(((dmanr & 3U) << 2) + 192U));
    outb((unsigned char )((a >> 9) & 255U), (int )(((dmanr & 3U) << 2) + 192U));
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_count(unsigned int dmanr ,
                                                                       unsigned int count ) 
{ 

  {
  count --;
  if (dmanr <= 3U) {
    outb((unsigned char )(count & 255U), (int )(((dmanr & 3U) << 1) + 1U));
    outb((unsigned char )((count >> 8) & 255U), (int )(((dmanr & 3U) << 1) + 1U));
  } else {
    outb((unsigned char )((count >> 1) & 255U), (int )((((dmanr & 3U) << 2) + 2U) +
                                                       192U));
    outb((unsigned char )((count >> 9) & 255U), (int )((((dmanr & 3U) << 2) + 2U) +
                                                       192U));
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  get_dma_residue(unsigned int dmanr ) 
{ unsigned int io_port ;
  unsigned int tmp ;
  unsigned short count ;
  unsigned char __attribute__((__always_inline__))  tmp___0 ;
  unsigned char __attribute__((__always_inline__))  tmp___1 ;
  int tmp___2 ;

  {
  if (dmanr <= 3U) {
    tmp = ((dmanr & 3U) << 1) + 1U;
  } else {
    tmp = (((dmanr & 3U) << 2) + 2U) + 192U;
  }
  io_port = tmp;
  tmp___0 = inb((int )io_port);
  count = (unsigned short )(1 + (int )tmp___0);
  tmp___1 = inb((int )io_port);
  count = (unsigned short )((int )count + (int )((int __attribute__((__always_inline__))  )tmp___1 <<
                                                 8));
  if (dmanr <= 3U) {
    tmp___2 = (int )count;
  } else {
    tmp___2 = (int )count << 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___2);
}
}
extern int request_dma(unsigned int dmanr , char const   *device_id ) ;
extern void free_dma(unsigned int dmanr ) ;
extern int isa_dma_bridge_buggy ;
__inline static int __attribute__((__deprecated__, __always_inline__))  verify_area(int type ,
                                                                                    void const   *addr ,
                                                                                    unsigned long size ) 
{ unsigned long flag ;
  unsigned long sum ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned long flag___0 ;
  unsigned long sum___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  tmp___3 = current_thread_info();
  __asm__  ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag___0), "=r" (sum___0): "1" (addr),
            "g" ((int )size), "g" (tmp___3->addr_limit.seg));
  if (flag___0 == 0UL) {
    tmp___4 = 1;
  } else {
    tmp___4 = 0;
  }
  tmp___5 = __builtin_expect((long )tmp___4, 1L);
  if (tmp___5) {
    tmp___2 = 0;
  } else {
    tmp___2 = -14;
  }
  return ((int __attribute__((__deprecated__, __always_inline__))  )tmp___2);
}
}
extern int fixup_exception(struct pt_regs *regs ) ;
extern void __get_user_1(void) ;
extern void __get_user_2(void) ;
extern void __get_user_4(void) ;
extern void __put_user_bad(void) ;
extern void __put_user_1(void) ;
extern void __put_user_2(void) ;
extern void __put_user_4(void) ;
extern void __put_user_8(void) ;
extern long __get_user_bad(void) ;
extern unsigned long __copy_to_user_ll(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll(void *to , void const   *from , unsigned long n ) ;
__inline static unsigned long __attribute__((__always_inline__))  __copy_to_user_inatomic(void *to ,
                                                                                          void const   *from ,
                                                                                          unsigned long n ) 
{ unsigned long ret ;
  unsigned long __attribute__((__always_inline__))  tmp ;

  {
  if (0) {
    switch ((int )n) {
    case 1: ;
    while (1) {
      ret = 0UL;
      switch (1) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %"
                           "b"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "iq" ((*((u8 *)from))), "m" ((*((struct __large_struct *)((u8 *)to)))),
                           "i" (1), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %"
                           "w"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u8 *)from))), "m" ((*((struct __large_struct *)((u8 *)to)))),
                           "i" (1), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %"
                           ""
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u8 *)from))), "m" ((*((struct __large_struct *)((u8 *)to)))),
                           "i" (1), "0" (ret));
      break;
      case 8: 
      __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                           "2:\tmovl %%edx,4(%2)\n"
                           "3:\n"
                           ".section .fixup,\"ax\"\n"
                           "4:\tmovl %3,%0\n"
                           "\tjmp 3b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,4b\n"
                           "\t.long 2b,4b\n"
                           ".previous": "=r" (ret): "A" ((*((u8 *)from))), "r" ((u8 *)to),
                           "i" (-14), "0" (ret));
      break;
      default: 
      __put_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 2: ;
    while (1) {
      ret = 0UL;
      switch (2) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %"
                           "b"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "iq" ((*((u16 *)from))), "m" ((*((struct __large_struct *)((u16 *)to)))),
                           "i" (2), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %"
                           "w"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u16 *)from))), "m" ((*((struct __large_struct *)((u16 *)to)))),
                           "i" (2), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %"
                           ""
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u16 *)from))), "m" ((*((struct __large_struct *)((u16 *)to)))),
                           "i" (2), "0" (ret));
      break;
      case 8: 
      __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                           "2:\tmovl %%edx,4(%2)\n"
                           "3:\n"
                           ".section .fixup,\"ax\"\n"
                           "4:\tmovl %3,%0\n"
                           "\tjmp 3b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,4b\n"
                           "\t.long 2b,4b\n"
                           ".previous": "=r" (ret): "A" ((*((u16 *)from))), "r" ((u16 *)to),
                           "i" (-14), "0" (ret));
      break;
      default: 
      __put_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 4: ;
    while (1) {
      ret = 0UL;
      switch (4) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %"
                           "b"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "iq" ((*((u32 *)from))), "m" ((*((struct __large_struct *)((u32 *)to)))),
                           "i" (4), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %"
                           "w"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u32 *)from))), "m" ((*((struct __large_struct *)((u32 *)to)))),
                           "i" (4), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %"
                           ""
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u32 *)from))), "m" ((*((struct __large_struct *)((u32 *)to)))),
                           "i" (4), "0" (ret));
      break;
      case 8: 
      __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                           "2:\tmovl %%edx,4(%2)\n"
                           "3:\n"
                           ".section .fixup,\"ax\"\n"
                           "4:\tmovl %3,%0\n"
                           "\tjmp 3b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,4b\n"
                           "\t.long 2b,4b\n"
                           ".previous": "=r" (ret): "A" ((*((u32 *)from))), "r" ((u32 *)to),
                           "i" (-14), "0" (ret));
      break;
      default: 
      __put_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    }
  }
  tmp = (unsigned long __attribute__((__always_inline__))  )__copy_to_user_ll(to,
                                                                              from,
                                                                              n);
  return (tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __copy_to_user(void *to ,
                                                                                 void const   *from ,
                                                                                 unsigned long n ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = __copy_to_user_inatomic(to, from, n);
  return (tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __copy_from_user_inatomic(void *to ,
                                                                                            void const   *from ,
                                                                                            unsigned long n ) 
{ unsigned long ret ;
  unsigned long __attribute__((__always_inline__))  tmp ;

  {
  if (0) {
    switch ((int )n) {
    case 1: ;
    while (1) {
      ret = 0UL;
      switch (1) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %2,%"
                           "b"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "b"
                           " %"
                           "b"
                           "1,%"
                           "b"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=q" ((*((u8 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (1), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %2,%"
                           "w"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "w"
                           " %"
                           "w"
                           "1,%"
                           "w"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u8 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (1), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %2,%"
                           ""
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "l"
                           " %"
                           ""
                           "1,%"
                           ""
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u8 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (1), "0" (ret));
      break;
      default: 
      (*((u8 *)to)) = (u8 )__get_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 2: ;
    while (1) {
      ret = 0UL;
      switch (2) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %2,%"
                           "b"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "b"
                           " %"
                           "b"
                           "1,%"
                           "b"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=q" ((*((u16 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (2), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %2,%"
                           "w"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "w"
                           " %"
                           "w"
                           "1,%"
                           "w"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u16 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (2), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %2,%"
                           ""
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "l"
                           " %"
                           ""
                           "1,%"
                           ""
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u16 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (2), "0" (ret));
      break;
      default: 
      (*((u16 *)to)) = (u16 )__get_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 4: ;
    while (1) {
      ret = 0UL;
      switch (4) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %2,%"
                           "b"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "b"
                           " %"
                           "b"
                           "1,%"
                           "b"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=q" ((*((u32 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (4), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %2,%"
                           "w"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "w"
                           " %"
                           "w"
                           "1,%"
                           "w"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u32 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (4), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %2,%"
                           ""
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "l"
                           " %"
                           ""
                           "1,%"
                           ""
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u32 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (4), "0" (ret));
      break;
      default: 
      (*((u32 *)to)) = (u32 )__get_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    }
  }
  tmp = (unsigned long __attribute__((__always_inline__))  )__copy_from_user_ll(to,
                                                                                from,
                                                                                n);
  return (tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __copy_from_user(void *to ,
                                                                                   void const   *from ,
                                                                                   unsigned long n ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = __copy_from_user_inatomic(to, from, n);
  return (tmp);
}
}
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
extern long strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long __strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long strnlen_user(char const   *str , long n ) ;
extern unsigned long clear_user(void *mem , unsigned long len ) ;
extern unsigned long __clear_user(void *mem , unsigned long len ) ;
__inline static void __attribute__((__always_inline__))  prio_tree_iter_init(struct prio_tree_iter *iter ,
                                                                             struct prio_tree_root *root ,
                                                                             unsigned long r_index ,
                                                                             unsigned long h_index ) 
{ 

  {
  iter->root = root;
  iter->r_index = r_index;
  iter->h_index = h_index;
  iter->cur = (struct prio_tree_node *)((void *)0);
  return;
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_empty(struct prio_tree_root  const  *root ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )root->prio_tree_node ==
                                                     (unsigned int )((void *)0)));
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_root(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )node->parent ==
                                                     (unsigned int )node));
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_left_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )node->left ==
                                                     (unsigned int )node));
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_right_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )node->right ==
                                                     (unsigned int )node));
}
}
extern struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root , struct prio_tree_node *old ,
                                                struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern void prio_tree_remove(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter ) ;
extern unsigned int __invalid_size_argument_for_IOC ;
extern struct files_stat_struct files_stat ;
extern struct inodes_stat_t inodes_stat ;
extern int leases_enable ;
extern int lease_break_time ;
extern int dir_notify_enable ;
__inline static int __attribute__((__always_inline__))  old_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < 256U) {
    if ((dev & 1048575U) < 256U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static u16 __attribute__((__always_inline__))  old_encode_dev(dev_t dev ) 
{ 

  {
  return ((unsigned short )(((dev >> 20) << 8) | (dev & 1048575U)));
}
}
__inline static dev_t __attribute__((__always_inline__))  old_decode_dev(u16 val ) 
{ 

  {
  return ((unsigned int )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
__inline static int __attribute__((__always_inline__))  new_valid_dev(dev_t dev ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static u32 __attribute__((__always_inline__))  new_encode_dev(dev_t dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  major = dev >> 20;
  minor = dev & 1048575U;
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
__inline static dev_t __attribute__((__always_inline__))  new_decode_dev(u32 dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  major = (dev & 1048320U) >> 8;
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  return ((major << 20) | minor);
}
}
__inline static u64 __attribute__((__always_inline__))  huge_encode_dev(dev_t dev ) 
{ u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = (u64 __attribute__((__always_inline__))  )new_encode_dev(dev);
  return (tmp);
}
}
__inline static dev_t __attribute__((__always_inline__))  huge_decode_dev(u64 dev ) 
{ dev_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = new_decode_dev((unsigned int )dev);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  sysv_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < 16384U) {
    if ((dev & 1048575U) < 262144U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static u32 __attribute__((__always_inline__))  sysv_encode_dev(dev_t dev ) 
{ 

  {
  return ((dev & 1048575U) | ((dev >> 20) << 18));
}
}
__inline static unsigned int __attribute__((__always_inline__))  sysv_major(u32 dev ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )((dev >> 18) & 16383U));
}
}
__inline static unsigned int __attribute__((__always_inline__))  sysv_minor(u32 dev ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(dev & 262143U));
}
}
__inline static int __attribute__((__always_inline__))  rcu_batch_before(long a ,
                                                                         long b ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(a - b < 0L));
}
}
__inline static int __attribute__((__always_inline__))  rcu_batch_after(long a , long b ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(a - b > 0L));
}
}
extern struct rcu_data per_cpu__rcu_data ;
extern struct rcu_data per_cpu__rcu_bh_data ;
extern struct rcu_ctrlblk rcu_ctrlblk ;
extern struct rcu_ctrlblk rcu_bh_ctrlblk ;
__inline static void __attribute__((__always_inline__))  rcu_qsctr_inc(int cpu ) 
{ struct rcu_data *rdp ;
  unsigned long __ptr ;

  {
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__rcu_data));
  rdp = (struct rcu_data *)(__ptr + __per_cpu_offset[cpu]);
  rdp->passed_quiesc = 1;
}
}
__inline static void __attribute__((__always_inline__))  rcu_bh_qsctr_inc(int cpu ) 
{ struct rcu_data *rdp ;
  unsigned long __ptr ;

  {
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__rcu_bh_data));
  rdp = (struct rcu_data *)(__ptr + __per_cpu_offset[cpu]);
  rdp->passed_quiesc = 1;
}
}
__inline static int __attribute__((__always_inline__))  __rcu_pending(struct rcu_ctrlblk *rcp ,
                                                                      struct rcu_data *rdp ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (rdp->curlist) {
    tmp = rcu_batch_before(rcp->completed, rdp->batch);
    if (! tmp) {
      return ((int __attribute__((__always_inline__))  )1);
    }
  }
  if (! rdp->curlist) {
    if (rdp->nxtlist) {
      return ((int __attribute__((__always_inline__))  )1);
    }
  }
  if (rdp->donelist) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  if (rdp->quiescbatch != rcp->cur) {
    return ((int __attribute__((__always_inline__))  )1);
  } else {
    if (rdp->qs_pending) {
      return ((int __attribute__((__always_inline__))  )1);
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  rcu_pending(int cpu ) 
{ unsigned long __ptr ;
  int __attribute__((__always_inline__))  tmp ;
  unsigned long __ptr___0 ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__rcu_data));
  tmp = __rcu_pending(& rcu_ctrlblk, (struct rcu_data *)(__ptr + __per_cpu_offset[cpu]));
  if (tmp) {
    tmp___1 = 1;
  } else {
    __asm__  ("": "=g" (__ptr___0): "0" (& per_cpu__rcu_bh_data));
    tmp___0 = __rcu_pending(& rcu_bh_ctrlblk, (struct rcu_data *)(__ptr___0 + __per_cpu_offset[cpu]));
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
extern void rcu_init(void) ;
extern void rcu_check_callbacks(int cpu , int user ) ;
extern void rcu_restart_cpu(int cpu ) ;
extern void ( __attribute__((__regparm__(3))) call_rcu)(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
extern void ( __attribute__((__regparm__(3))) call_rcu_bh)(struct rcu_head *head ,
                                                           void (*func)(struct rcu_head *head ) ) ;
extern void __attribute__((__deprecated__))  synchronize_kernel(void) ;
extern void synchronize_rcu(void) ;
extern void synchronize_idle(void) ;
extern struct dentry_stat_t dentry_stat ;
__inline static unsigned long __attribute__((__always_inline__))  partial_name_hash(unsigned long c ,
                                                                                    unsigned long prevhash ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )(((prevhash + (c <<
                                                                             4)) +
                                                                (c >> 4)) * 11UL));
}
}
__inline static unsigned long __attribute__((__always_inline__))  end_name_hash(unsigned long hash ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((unsigned int )hash));
}
}
__inline static unsigned int __attribute__((__always_inline__))  full_name_hash(unsigned char const   *name___0 ,
                                                                                unsigned int len ) 
{ unsigned long hash ;
  unsigned char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned int __attribute__((__always_inline__))  tmp___1 ;

  {
  hash = 0UL;
  while (1) {
    tmp___0 = len;
    len --;
    if (! tmp___0) {
      break;
    }
    tmp = name___0;
    name___0 ++;
    hash = (unsigned long )partial_name_hash((unsigned long )(*tmp), hash);
  }
  tmp___1 = (unsigned int __attribute__((__always_inline__))  )end_name_hash(hash);
  return (tmp___1);
}
}
extern spinlock_t dcache_lock ;
__inline static void __attribute__((__always_inline__))  __d_drop(struct dentry *dentry ) 
{ 

  {
  if (! (dentry->d_flags & 16U)) {
    dentry->d_flags |= 16U;
    hlist_del_rcu(& dentry->d_hash);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  d_drop(struct dentry *dentry ) 
{ 

  {
  _spin_lock(& dcache_lock);
  _spin_lock(& dentry->d_lock);
  __d_drop(dentry);
  _spin_unlock(& dentry->d_lock);
  _spin_unlock(& dcache_lock);
  return;
}
}
__inline static int __attribute__((__always_inline__))  dname_external(struct dentry *dentry ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )dentry->d_name.name !=
                                                     (unsigned int )(dentry->d_iname)));
}
}
extern void d_instantiate(struct dentry * , struct inode * ) ;
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
extern void d_delete(struct dentry * ) ;
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
extern struct dentry *d_alloc_anon(struct inode * ) ;
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
extern void shrink_dcache_sb(struct super_block * ) ;
extern void shrink_dcache_parent(struct dentry * ) ;
extern void shrink_dcache_anon(struct hlist_head * ) ;
extern int d_invalidate(struct dentry * ) ;
extern struct dentry *d_alloc_root(struct inode * ) ;
extern void d_genocide(struct dentry * ) ;
extern struct dentry *d_find_alias(struct inode * ) ;
extern void d_prune_aliases(struct inode * ) ;
extern int have_submounts(struct dentry * ) ;
extern void d_rehash(struct dentry * ) ;
__inline static void __attribute__((__always_inline__))  d_add(struct dentry *entry ,
                                                               struct inode *inode ) 
{ 

  {
  d_instantiate(entry, inode);
  d_rehash(entry);
  return;
}
}
__inline static struct dentry  __attribute__((__always_inline__)) *d_add_unique(struct dentry *entry ,
                                                                                struct inode *inode ) 
{ struct dentry *res ;
  struct dentry *tmp ;

  {
  res = d_instantiate_unique(entry, inode);
  if ((unsigned int )res != (unsigned int )((void *)0)) {
    tmp = res;
  } else {
    tmp = entry;
  }
  d_rehash(tmp);
  return ((struct dentry  __attribute__((__always_inline__)) *)res);
}
}
extern void d_move(struct dentry * , struct dentry * ) ;
extern struct dentry *d_lookup(struct dentry * , struct qstr * ) ;
extern struct dentry *__d_lookup(struct dentry * , struct qstr * ) ;
extern int d_validate(struct dentry * , struct dentry * ) ;
extern char *d_path(struct dentry * , struct vfsmount * , char * , int  ) ;
__inline static struct dentry  __attribute__((__always_inline__)) *dget(struct dentry *dentry ) 
{ long tmp ;

  {
  if (dentry) {
    while (1) {
      tmp = __builtin_expect((long )(! (! ((! dentry->d_count.counter != 0) != 0)) !=
                                     0), 0L);
      if (tmp) {
        __asm__  volatile   ("ud2\n"
                             "\t.word %c0\n"
                             "\t.long %c1\n": : "i" (294), "i" ("include/linux/dcache.h"));
      }
      break;
    }
    atomic_inc(& dentry->d_count);
  }
  return ((struct dentry  __attribute__((__always_inline__)) *)dentry);
}
}
extern struct dentry *dget_locked(struct dentry * ) ;
__inline static int __attribute__((__always_inline__))  d_unhashed(struct dentry *dentry ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(dentry->d_flags & 16U));
}
}
__inline static struct dentry  __attribute__((__always_inline__)) *dget_parent(struct dentry *dentry ) 
{ struct dentry *ret ;

  {
  _spin_lock(& dentry->d_lock);
  ret = (struct dentry *)dget(dentry->d_parent);
  _spin_unlock(& dentry->d_lock);
  return ((struct dentry  __attribute__((__always_inline__)) *)ret);
}
}
extern void dput(struct dentry * ) ;
__inline static int __attribute__((__always_inline__))  d_mountpoint(struct dentry *dentry ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )dentry->d_mounted);
}
}
extern struct vfsmount *lookup_mnt(struct vfsmount * , struct dentry * ) ;
extern struct dentry *lookup_create(struct nameidata *nd , int is_dir ) ;
extern int sysctl_vfs_cache_pressure ;
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
extern int radix_tree_preload(int gfp_mask ) ;
extern void radix_tree_init(void) ;
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                int tag ) ;
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  int tag ) ;
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              int tag ) ;
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               int tag ) ;
extern int radix_tree_tagged(struct radix_tree_root *root , int tag ) ;
__inline static void __attribute__((__always_inline__))  radix_tree_preload_end(void) 
{ 

  {
  while (1) {
    break;
  }
  return;
}
}
extern void update_atime(struct inode * ) ;
extern void inode_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern void inode_init_early(void)  __attribute__((__section__(".init.text"))) ;
extern void mnt_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern void files_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern spinlock_t dq_data_lock ;
extern void mark_info_dirty(struct super_block *sb , int type ) ;
extern struct dqstats dqstats ;
extern int mark_dquot_dirty(struct dquot *dquot ) ;
extern int register_quota_format(struct quota_format_type *fmt ) ;
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
__inline static int __attribute__((__always_inline__))  mapping_mapped(struct address_space *mapping ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = prio_tree_empty((struct prio_tree_root  const  *)(& mapping->i_mmap));
  if (tmp) {
    tmp___0 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  mapping_writably_mapped(struct address_space *mapping ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(mapping->i_mmap_writable != 0U));
}
}
__inline static loff_t __attribute__((__always_inline__))  i_size_read(struct inode *inode ) 
{ loff_t i_size ;
  unsigned int seq ;
  int __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    seq = (unsigned int )read_seqcount_begin((seqcount_t const   *)(& inode->i_size_seqcount));
    i_size = inode->i_size;
    tmp = read_seqcount_retry((seqcount_t const   *)(& inode->i_size_seqcount), seq);
    if (! tmp) {
      break;
    }
  }
  return (i_size);
}
}
__inline static void __attribute__((__always_inline__))  i_size_write(struct inode *inode ,
                                                                      loff_t i_size ) 
{ 

  {
  write_seqcount_begin(& inode->i_size_seqcount);
  inode->i_size = i_size;
  write_seqcount_end(& inode->i_size_seqcount);
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  iminor(struct inode *inode ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(inode->i_rdev & 1048575U));
}
}
__inline static unsigned int __attribute__((__always_inline__))  imajor(struct inode *inode ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(inode->i_rdev >> 20));
}
}
extern struct block_device *I_BDEV(struct inode *inode ) ;
extern spinlock_t files_lock ;
__inline static int __attribute__((__always_inline__))  nfs_compare_fh(struct nfs_fh  const  *a ,
                                                                       struct nfs_fh  const  *b ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((int const   )a->size != (int const   )b->size) {
    tmp___0 = 1;
  } else {
    tmp = __builtin_memcmp((void const   *)(a->data), (void const   *)(b->data), (unsigned int )a->size);
    if (tmp != 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  nfs_copy_fh(struct nfs_fh *target ,
                                                                     struct nfs_fh  const  *source ) 
{ 

  {
  target->size = (unsigned short )source->size;
  __memcpy((void *)(target->data), (void const   *)(source->data), (unsigned int )source->size);
  return;
}
}
extern struct list_head file_lock_list ;
extern int fcntl_getlk(struct file * , struct flock * ) ;
extern int fcntl_setlk(struct file * , unsigned int  , struct flock * ) ;
extern int fcntl_getlk64(struct file * , struct flock64 * ) ;
extern int fcntl_setlk64(struct file * , unsigned int  , struct flock64 * ) ;
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
extern int fcntl_getlease(struct file *filp ) ;
extern void locks_init_lock(struct file_lock * ) ;
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
extern void locks_remove_flock(struct file * ) ;
extern struct file_lock *posix_test_lock(struct file * , struct file_lock * ) ;
extern int posix_lock_file(struct file * , struct file_lock * ) ;
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
extern void posix_block_lock(struct file_lock * , struct file_lock * ) ;
extern void posix_unblock_lock(struct file * , struct file_lock * ) ;
extern int posix_locks_deadlock(struct file_lock * , struct file_lock * ) ;
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
extern int __break_lease(struct inode *inode , unsigned int flags ) ;
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
extern int setlease(struct file * , long  , struct file_lock ** ) ;
extern int lease_modify(struct file_lock ** , int  ) ;
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
extern void steal_locks(fl_owner_t from ) ;
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
extern void __kill_fasync(struct fasync_struct * , int  , int  ) ;
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
extern void f_delown(struct file *filp ) ;
extern int send_sigurg(struct fown_struct *fown ) ;
extern struct list_head super_blocks ;
extern spinlock_t sb_lock ;
extern struct timespec current_fs_time(struct super_block *sb ) ;
__inline static void __attribute__((__always_inline__))  lock_super(struct super_block *sb ) 
{ 

  {
  down(& sb->s_lock);
  return;
}
}
__inline static void __attribute__((__always_inline__))  unlock_super(struct super_block *sb ) 
{ 

  {
  up(& sb->s_lock);
  return;
}
}
extern int vfs_create(struct inode * , struct dentry * , int  , struct nameidata * ) ;
extern int vfs_mkdir(struct inode * , struct dentry * , int  ) ;
extern int vfs_mknod(struct inode * , struct dentry * , int  , dev_t  ) ;
extern int vfs_symlink(struct inode * , struct dentry * , char const   * , int  ) ;
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
extern int vfs_unlink(struct inode * , struct dentry * ) ;
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern void dentry_unhash(struct dentry *dentry ) ;
extern int generic_osync_inode(struct inode * , struct address_space * , int  ) ;
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
extern void __mark_inode_dirty(struct inode * , int  ) ;
__inline static void __attribute__((__always_inline__))  mark_inode_dirty(struct inode *inode ) 
{ 

  {
  __mark_inode_dirty(inode, 7);
  return;
}
}
__inline static void __attribute__((__always_inline__))  mark_inode_dirty_sync(struct inode *inode ) 
{ 

  {
  __mark_inode_dirty(inode, 1);
  return;
}
}
__inline static void __attribute__((__always_inline__))  touch_atime(struct vfsmount *mnt ,
                                                                     struct dentry *dentry ) 
{ 

  {
  update_atime(dentry->d_inode);
  return;
}
}
__inline static void __attribute__((__always_inline__))  file_accessed(struct file *file ) 
{ 

  {
  if (! (file->f_flags & 262144U)) {
    touch_atime(file->f_vfsmnt, file->f_dentry);
  }
  return;
}
}
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
extern struct dentry *find_exported_dentry(struct super_block *sb , void *obj , void *parent ,
                                           int (*acceptable)(void *context , struct dentry *de ) ,
                                           void *context ) ;
extern struct super_block *get_sb_bdev(struct file_system_type *fs_type , int flags ,
                                       char const   *dev_name , void *data , int (*fill_super)(struct super_block * ,
                                                                                               void * ,
                                                                                               int  ) ) ;
extern struct super_block *get_sb_single(struct file_system_type *fs_type , int flags ,
                                         void *data , int (*fill_super)(struct super_block * ,
                                                                        void * , int  ) ) ;
extern struct super_block *get_sb_nodev(struct file_system_type *fs_type , int flags ,
                                        void *data , int (*fill_super)(struct super_block * ,
                                                                       void * , int  ) ) ;
extern void generic_shutdown_super(struct super_block *sb ) ;
extern void kill_block_super(struct super_block *sb ) ;
extern void kill_anon_super(struct super_block *sb ) ;
extern void kill_litter_super(struct super_block *sb ) ;
extern void deactivate_super(struct super_block *sb ) ;
extern int set_anon_super(struct super_block *s , void *data ) ;
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , void *data ) ;
extern struct super_block *get_sb_pseudo(struct file_system_type * , char * , struct super_operations *ops ,
                                         unsigned long  ) ;
extern int __put_super(struct super_block *sb ) ;
extern int __put_super_and_need_restart(struct super_block *sb ) ;
extern void unnamed_dev_init(void) ;
extern int register_filesystem(struct file_system_type * ) ;
extern int unregister_filesystem(struct file_system_type * ) ;
extern struct vfsmount *kern_mount(struct file_system_type * ) ;
extern int may_umount_tree(struct vfsmount * ) ;
extern int may_umount(struct vfsmount * ) ;
extern long do_mount(char * , char * , char * , unsigned long  , void * ) ;
extern int vfs_statfs(struct super_block * , struct kstatfs * ) ;
extern int locks_mandatory_locked(struct inode * ) ;
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
__inline static int __attribute__((__always_inline__))  locks_verify_locked(struct inode *inode ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if ((inode->i_sb)->s_flags & 64UL) {
    if (((int )inode->i_mode & 1032) == 1024) {
      tmp = (int __attribute__((__always_inline__))  )locks_mandatory_locked(inode);
      return (tmp);
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int rw_verify_area(int  , struct file * , loff_t * , size_t  ) ;
__inline static int __attribute__((__always_inline__))  locks_verify_truncate(struct inode *inode ,
                                                                              struct file *filp ,
                                                                              loff_t size ) 
{ loff_t tmp ;
  loff_t tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (inode->i_flock) {
    if ((inode->i_sb)->s_flags & 64UL) {
      if (((int )inode->i_mode & 1032) == 1024) {
        if (size < inode->i_size) {
          tmp = inode->i_size - size;
        } else {
          tmp = size - inode->i_size;
        }
        if (size < inode->i_size) {
          tmp___0 = size;
        } else {
          tmp___0 = inode->i_size;
        }
        tmp___1 = (int __attribute__((__always_inline__))  )locks_mandatory_area(2,
                                                                                 inode,
                                                                                 filp,
                                                                                 tmp___0,
                                                                                 (unsigned int )tmp);
        return (tmp___1);
      }
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  break_lease(struct inode *inode ,
                                                                    unsigned int mode ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (inode->i_flock) {
    tmp = (int __attribute__((__always_inline__))  )__break_lease(inode, mode);
    return (tmp);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int do_truncate(struct dentry * , loff_t start ) ;
extern struct file *filp_open(char const   * , int  , int  ) ;
extern struct file *dentry_open(struct dentry * , struct vfsmount * , int  ) ;
extern int filp_close(struct file * , fl_owner_t id ) ;
extern char *getname(char const   * ) ;
extern void vfs_caches_init_early(void)  __attribute__((__section__(".init.text"))) ;
extern void vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern int register_blkdev(unsigned int  , char const   * ) ;
extern int unregister_blkdev(unsigned int  , char const   * ) ;
extern struct block_device *bdget(dev_t  ) ;
extern void bd_set_size(struct block_device * , loff_t size ) ;
extern void bd_forget(struct inode *inode ) ;
extern void bdput(struct block_device * ) ;
extern struct block_device *open_by_devnum(dev_t  , unsigned int  ) ;
extern struct file_operations def_blk_fops ;
extern struct address_space_operations def_blk_aops ;
extern struct file_operations def_chr_fops ;
extern struct file_operations bad_sock_fops ;
extern struct file_operations def_fifo_fops ;
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
extern int blkdev_ioctl(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
extern int blkdev_get(struct block_device * , mode_t  , unsigned int  ) ;
extern int blkdev_put(struct block_device * ) ;
extern int bd_claim(struct block_device * , void * ) ;
extern void bd_release(struct block_device * ) ;
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
extern int register_chrdev(unsigned int  , char const   * , struct file_operations * ) ;
extern int unregister_chrdev(unsigned int  , char const   * ) ;
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
extern int chrdev_open(struct inode * , struct file * ) ;
extern char const   *__bdevname(dev_t  , char *buffer ) ;
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
extern struct block_device *lookup_bdev(char const   * ) ;
extern struct block_device *open_bdev_excl(char const   * , int  , void * ) ;
extern void close_bdev_excl(struct block_device * ) ;
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
extern void make_bad_inode(struct inode * ) ;
extern int is_bad_inode(struct inode * ) ;
extern struct file_operations read_fifo_fops ;
extern struct file_operations write_fifo_fops ;
extern struct file_operations rdwr_fifo_fops ;
extern struct file_operations read_pipe_fops ;
extern struct file_operations write_pipe_fops ;
extern struct file_operations rdwr_pipe_fops ;
extern int fs_may_remount_ro(struct super_block * ) ;
extern int check_disk_change(struct block_device * ) ;
extern int invalidate_inodes(struct super_block * ) ;
extern int __invalidate_device(struct block_device * ) ;
extern int invalidate_partition(struct gendisk * , int  ) ;
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
extern unsigned long invalidate_inode_pages(struct address_space *mapping ) ;
__inline static void __attribute__((__always_inline__))  invalidate_remote_inode(struct inode *inode ) 
{ 

  {
  if (((int )inode->i_mode & 61440) == 32768) {
    invalidate_inode_pages(inode->i_mapping);
  } else {
    if (((int )inode->i_mode & 61440) == 16384) {
      invalidate_inode_pages(inode->i_mapping);
    } else {
      if (((int )inode->i_mode & 61440) == 40960) {
        invalidate_inode_pages(inode->i_mapping);
      }
    }
  }
  return;
}
}
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
extern int write_inode_now(struct inode * , int  ) ;
extern int filemap_fdatawrite(struct address_space * ) ;
extern int filemap_flush(struct address_space * ) ;
extern int filemap_fdatawait(struct address_space * ) ;
extern int filemap_write_and_wait(struct address_space *mapping ) ;
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
extern void sync_supers(void) ;
extern void sync_filesystems(int wait ) ;
extern void emergency_sync(void) ;
extern void emergency_remount(void) ;
extern int do_remount_sb(struct super_block *sb , int flags , void *data , int force ) ;
extern sector_t bmap(struct inode * , sector_t  ) ;
extern int setattr_mask(unsigned int  ) ;
extern int notify_change(struct dentry * , struct iattr * ) ;
extern int permission(struct inode * , int  , struct nameidata * ) ;
extern int generic_permission(struct inode * , int  , int (*check_acl)(struct inode * ,
                                                                       int  ) ) ;
extern int get_write_access(struct inode * ) ;
extern int deny_write_access(struct file * ) ;
__inline static void __attribute__((__always_inline__))  put_write_access(struct inode *inode ) 
{ 

  {
  atomic_dec(& inode->i_writecount);
  return;
}
}
__inline static void __attribute__((__always_inline__))  allow_write_access(struct file *file ) 
{ 

  {
  if (file) {
    atomic_inc(& ((file->f_dentry)->d_inode)->i_writecount);
  }
  return;
}
}
extern int do_pipe(int * ) ;
extern int open_namei(char const   * , int  , int  , struct nameidata * ) ;
extern int may_open(struct nameidata * , int  , int  ) ;
extern int kernel_read(struct file * , unsigned long  , char * , unsigned long  ) ;
extern struct file *open_exec(char const   * ) ;
extern int is_subdir(struct dentry * , struct dentry * ) ;
extern ino_t find_inode_number(struct dentry * , struct qstr * ) ;
__inline static void __attribute__((__always_inline__))  *ERR_PTR(long error ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((void *)error));
}
}
__inline static long __attribute__((__always_inline__))  PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long __attribute__((__always_inline__))  )((long )ptr));
}
}
__inline static long __attribute__((__always_inline__))  IS_ERR(void const   *ptr ) 
{ long __attribute__((__always_inline__))  tmp ;

  {
  tmp = (long __attribute__((__always_inline__))  )__builtin_expect((long )(! (! ((unsigned long )ptr >
                                                                                  4294966296UL)) !=
                                                                            0), 0L);
  return (tmp);
}
}
extern loff_t default_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t vfs_llseek(struct file *file , loff_t offset , int origin ) ;
extern void inode_init_once(struct inode * ) ;
extern void iput(struct inode * ) ;
extern struct inode *igrab(struct inode * ) ;
extern ino_t iunique(struct super_block * , ino_t  ) ;
extern int inode_needs_sync(struct inode *inode ) ;
extern void generic_delete_inode(struct inode *inode ) ;
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
extern void unlock_new_inode(struct inode * ) ;
__inline static struct inode  __attribute__((__always_inline__)) *iget(struct super_block *sb ,
                                                                       unsigned long ino ) 
{ struct inode *inode ;
  struct inode *tmp ;

  {
  tmp = iget_locked(sb, ino);
  inode = tmp;
  if (inode) {
    if (inode->i_state & 64UL) {
      ((*((sb->s_op)->read_inode)))(inode);
      unlock_new_inode(inode);
    }
  }
  return ((struct inode  __attribute__((__always_inline__)) *)inode);
}
}
extern void __iget(struct inode *inode ) ;
extern void clear_inode(struct inode * ) ;
extern void destroy_inode(struct inode * ) ;
extern struct inode *new_inode(struct super_block * ) ;
extern int remove_suid(struct dentry * ) ;
extern void remove_dquot_ref(struct super_block * , int  , struct list_head * ) ;
extern struct semaphore iprune_sem ;
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
extern void remove_inode_hash(struct inode * ) ;
__inline static void __attribute__((__always_inline__))  insert_inode_hash(struct inode *inode ) 
{ 

  {
  __insert_inode_hash(inode, inode->i_ino);
  return;
}
}
extern struct file *get_empty_filp(void) ;
extern void file_move(struct file *f , struct list_head *list ) ;
extern void file_kill(struct file *f ) ;
extern void submit_bio(int  , struct bio * ) ;
extern int bdev_read_only(struct block_device * ) ;
extern int set_blocksize(struct block_device * , int  ) ;
extern int sb_set_blocksize(struct super_block * , int  ) ;
extern int sb_min_blocksize(struct super_block * , int  ) ;
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
extern int file_read_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
extern int file_send_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
extern ssize_t generic_file_read(struct file * , char * , size_t  , loff_t * ) ;
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
extern ssize_t generic_file_write(struct file * , char const   * , size_t  , loff_t * ) ;
extern ssize_t generic_file_aio_read(struct kiocb * , char * , size_t  , loff_t  ) ;
extern ssize_t __generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                       loff_t * ) ;
extern ssize_t generic_file_aio_write(struct kiocb * , char const   * , size_t  ,
                                      loff_t  ) ;
extern ssize_t generic_file_aio_write_nolock(struct kiocb * , struct iovec  const  * ,
                                             unsigned long  , loff_t * ) ;
extern ssize_t generic_file_direct_write(struct kiocb * , struct iovec  const  * ,
                                         unsigned long * , loff_t  , loff_t * , size_t  ,
                                         size_t  ) ;
extern ssize_t generic_file_buffered_write(struct kiocb * , struct iovec  const  * ,
                                           unsigned long  , loff_t  , loff_t * , size_t  ,
                                           ssize_t  ) ;
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
extern ssize_t generic_file_write_nolock(struct file *file , struct iovec  const  *iov ,
                                         unsigned long nr_segs , loff_t *ppos ) ;
extern ssize_t generic_file_sendfile(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                                  struct page * ,
                                                                                  unsigned long  ,
                                                                                  unsigned long  ) ,
                                     void * ) ;
extern void do_generic_mapping_read(struct address_space *mapping , struct file_ra_state * ,
                                    struct file * , loff_t * , read_descriptor_t * ,
                                    int (*)(read_descriptor_t * , struct page * ,
                                            unsigned long  , unsigned long  ) ) ;
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
extern ssize_t generic_file_direct_IO(int rw , struct kiocb *iocb , struct iovec  const  *iov ,
                                      loff_t offset , unsigned long nr_segs ) ;
extern ssize_t generic_file_readv(struct file *filp , struct iovec  const  *iov ,
                                  unsigned long nr_segs , loff_t *ppos ) ;
extern ssize_t generic_file_writev(struct file *filp , struct iovec  const  *iov ,
                                   unsigned long nr_segs , loff_t *ppos ) ;
extern loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t remote_llseek(struct file *file , loff_t offset , int origin ) ;
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
__inline static void __attribute__((__always_inline__))  do_generic_file_read(struct file *filp ,
                                                                              loff_t *ppos ,
                                                                              read_descriptor_t *desc ,
                                                                              int (*actor)(read_descriptor_t * ,
                                                                                           struct page * ,
                                                                                           unsigned long  ,
                                                                                           unsigned long  ) ) 
{ 

  {
  do_generic_mapping_read(filp->f_mapping, & filp->f_ra, filp, ppos, desc, actor);
  return;
}
}
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iovec  const  *iov ,
                                    loff_t offset , unsigned long nr_segs , get_blocks_t *get_blocks ,
                                    dio_iodone_t *end_io , int lock_type ) ;
__inline static ssize_t __attribute__((__always_inline__))  blockdev_direct_IO(int rw ,
                                                                               struct kiocb *iocb ,
                                                                               struct inode *inode ,
                                                                               struct block_device *bdev ,
                                                                               struct iovec  const  *iov ,
                                                                               loff_t offset ,
                                                                               unsigned long nr_segs ,
                                                                               get_blocks_t *get_blocks ,
                                                                               dio_iodone_t *end_io ) 
{ ssize_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = (ssize_t __attribute__((__always_inline__))  )__blockdev_direct_IO(rw, iocb,
                                                                           inode,
                                                                           bdev, iov,
                                                                           offset,
                                                                           nr_segs,
                                                                           get_blocks,
                                                                           end_io,
                                                                           1);
  return (tmp);
}
}
__inline static ssize_t __attribute__((__always_inline__))  blockdev_direct_IO_no_locking(int rw ,
                                                                                          struct kiocb *iocb ,
                                                                                          struct inode *inode ,
                                                                                          struct block_device *bdev ,
                                                                                          struct iovec  const  *iov ,
                                                                                          loff_t offset ,
                                                                                          unsigned long nr_segs ,
                                                                                          get_blocks_t *get_blocks ,
                                                                                          dio_iodone_t *end_io ) 
{ ssize_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = (ssize_t __attribute__((__always_inline__))  )__blockdev_direct_IO(rw, iocb,
                                                                           inode,
                                                                           bdev, iov,
                                                                           offset,
                                                                           nr_segs,
                                                                           get_blocks,
                                                                           end_io,
                                                                           2);
  return (tmp);
}
}
__inline static ssize_t __attribute__((__always_inline__))  blockdev_direct_IO_own_locking(int rw ,
                                                                                           struct kiocb *iocb ,
                                                                                           struct inode *inode ,
                                                                                           struct block_device *bdev ,
                                                                                           struct iovec  const  *iov ,
                                                                                           loff_t offset ,
                                                                                           unsigned long nr_segs ,
                                                                                           get_blocks_t *get_blocks ,
                                                                                           dio_iodone_t *end_io ) 
{ ssize_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = (ssize_t __attribute__((__always_inline__))  )__blockdev_direct_IO(rw, iocb,
                                                                           inode,
                                                                           bdev, iov,
                                                                           offset,
                                                                           nr_segs,
                                                                           get_blocks,
                                                                           end_io,
                                                                           3);
  return (tmp);
}
}
extern struct file_operations generic_ro_fops ;
extern int vfs_readlink(struct dentry * , char * , int  , char const   * ) ;
extern int vfs_follow_link(struct nameidata * , char const   * ) ;
extern int page_readlink(struct dentry * , char * , int  ) ;
extern int page_follow_link_light(struct dentry * , struct nameidata * ) ;
extern void page_put_link(struct dentry * , struct nameidata * ) ;
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
extern struct inode_operations page_symlink_inode_operations ;
extern int generic_readlink(struct dentry * , char * , int  ) ;
extern void generic_fillattr(struct inode * , struct kstat * ) ;
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
extern loff_t inode_get_bytes(struct inode *inode ) ;
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               ino_t  , unsigned int  ) , void * ) ;
extern int vfs_stat(char * , struct kstat * ) ;
extern int vfs_lstat(char * , struct kstat * ) ;
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
extern int vfs_ioctl(struct file * , unsigned int  , unsigned int  , unsigned long  ) ;
extern struct file_system_type *get_fs_type(char const   *name ) ;
extern struct super_block *get_super(struct block_device * ) ;
extern struct super_block *user_get_super(dev_t  ) ;
extern void drop_super(struct super_block *sb ) ;
extern int dcache_dir_open(struct inode * , struct file * ) ;
extern int dcache_dir_close(struct inode * , struct file * ) ;
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
extern int dcache_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                           int  , loff_t  , ino_t  ,
                                                           unsigned int  ) ) ;
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern int simple_statfs(struct super_block * , struct kstatfs * ) ;
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_unlink(struct inode * , struct dentry * ) ;
extern int simple_rmdir(struct inode * , struct dentry * ) ;
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_sync_file(struct file * , struct dentry * , int  ) ;
extern int simple_empty(struct dentry * ) ;
extern int simple_readpage(struct file *file , struct page *page ) ;
extern int simple_prepare_write(struct file *file , struct page *page , unsigned int offset ,
                                unsigned int to ) ;
extern int simple_commit_write(struct file *file , struct page *page , unsigned int offset ,
                               unsigned int to ) ;
extern struct dentry *simple_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
extern struct file_operations simple_dir_operations ;
extern struct inode_operations simple_dir_inode_operations ;
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
extern int simple_fill_super(struct super_block * , int  , struct tree_descr * ) ;
extern int simple_pin_fs(char *name , struct vfsmount **mount , int *count ) ;
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
extern int inode_change_ok(struct inode * , struct iattr * ) ;
extern int inode_setattr(struct inode * , struct iattr * ) ;
extern void inode_update_time(struct inode *inode , int ctime_too ) ;
__inline static ino_t __attribute__((__always_inline__))  parent_ino(struct dentry *dentry ) 
{ ino_t res ;

  {
  _spin_lock(& dentry->d_lock);
  res = ((dentry->d_parent)->d_inode)->i_ino;
  _spin_unlock(& dentry->d_lock);
  return (res);
}
}
extern int unshare_files(void) ;
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
__inline static void __attribute__((__always_inline__))  simple_transaction_set(struct file *file ,
                                                                                size_t n ) 
{ struct simple_transaction_argresp *ar ;
  long tmp ;

  {
  ar = (struct simple_transaction_argresp *)file->private_data;
  while (1) {
    tmp = __builtin_expect((long )(! (! (((unsigned long )n > 4096UL - (unsigned long )sizeof(struct simple_transaction_argresp )) !=
                                         0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (1650), "i" ("include/linux/fs.h"));
    }
    break;
  }
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  ar->size = (int )n;
}
}
__inline static char __attribute__((__always_inline__))  *alloc_secdata(void) 
{ 

  {
  return ((char __attribute__((__always_inline__))  *)((char *)1));
}
}
__inline static void __attribute__((__always_inline__))  free_secdata(void *secdata ) 
{ 

  {
  return;
}
}
extern unsigned long max_mapnr ;
extern unsigned long num_physpages ;
extern void *high_memory ;
extern unsigned long vmalloc_earlyreserve ;
extern int page_cluster ;
extern unsigned long empty_zero_page[1024] ;
extern pgd_t swapper_pg_dir[1024] ;
extern kmem_cache_t *pgd_cache ;
extern kmem_cache_t *pmd_cache ;
extern spinlock_t pgd_lock ;
extern struct page *pgd_list ;
extern void pmd_ctor(void * , kmem_cache_t * , unsigned long  ) ;
extern void pgd_ctor(void * , kmem_cache_t * , unsigned long  ) ;
extern void pgd_dtor(void * , kmem_cache_t * , unsigned long  ) ;
extern void pgtable_cache_init(void) ;
extern void paging_init(void) ;
extern unsigned long long __PAGE_KERNEL ;
extern unsigned long long __PAGE_KERNEL_EXEC ;
extern unsigned long pg0[] ;
__inline static int __attribute__((__always_inline__))  pte_user(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 4UL));
}
}
__inline static int __attribute__((__always_inline__))  pte_dirty(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 64UL));
}
}
__inline static int __attribute__((__always_inline__))  pte_young(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 32UL));
}
}
__inline static int __attribute__((__always_inline__))  pte_write(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 2UL));
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_rdprotect(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967291UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkclean(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967231UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkold(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967263UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_wrprotect(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967293UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkread(pte_t pte ) 
{ 

  {
  pte.pte_low |= 4UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkdirty(pte_t pte ) 
{ 

  {
  pte.pte_low |= 64UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkyoung(pte_t pte ) 
{ 

  {
  pte.pte_low |= 32UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkwrite(pte_t pte ) 
{ 

  {
  pte.pte_low |= 2UL;
  return (pte);
}
}
__inline static int __attribute__((__always_inline__))  pgd_none(pgd_t pgd ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  pgd_present(pgd_t pgd ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static void __attribute__((__always_inline__))  pgd_clear(pgd_t *pgd ) 
{ 

  {
  return;
}
}
__inline static pud_t __attribute__((__always_inline__))  *pud_offset(pgd_t *pgd ,
                                                                      unsigned long address ) 
{ 

  {
  return ((pud_t __attribute__((__always_inline__))  *)((pud_t *)pgd));
}
}
__inline static int __attribute__((__always_inline__))  pte_x(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! (((unsigned long long )pte.pte_low |
                                                         ((unsigned long long )pte.pte_high <<
                                                          32)) & 0x8000000000000000ULL) !=
                                                     0));
}
}
__inline static int __attribute__((__always_inline__))  pte_exec(pte_t pte ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = pte_user(pte);
  if (tmp) {
    tmp___0 = pte_x(pte);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  pte_exec_kernel(pte_t pte ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = pte_x(pte);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  set_pte(pte_t *ptep , pte_t pte ) 
{ 

  {
  ptep->pte_high = pte.pte_high;
  __asm__  volatile   ("": : : "memory");
  ptep->pte_low = pte.pte_low;
}
}
__inline static void __attribute__((__always_inline__))  pud_clear(pud_t *pud ) 
{ 

  {
  return;
}
}
__inline static pte_t __attribute__((__always_inline__))  ptep_get_and_clear(struct mm_struct *mm ,
                                                                             unsigned long addr ,
                                                                             pte_t *ptep ) 
{ pte_t res ;
  unsigned long __attribute__((__always_inline__))  tmp ;

  {
  res.pte_low = (unsigned long )__xchg(0UL, (void volatile   *)(& ptep->pte_low),
                                       (int )sizeof(ptep->pte_low));
  res.pte_high = ptep->pte_high;
  ptep->pte_high = 0UL;
  return (res);
}
}
__inline static int __attribute__((__always_inline__))  pte_same(pte_t a , pte_t b ) 
{ int tmp ;

  {
  if (a.pte_low == b.pte_low) {
    if (a.pte_high == b.pte_high) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static int __attribute__((__always_inline__))  pte_none(pte_t pte ) 
{ int tmp ;

  {
  if (! pte.pte_low) {
    if (! pte.pte_high) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  pte_pfn(pte_t pte ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((pte.pte_low >> 12) |
                                                               (pte.pte_high << 20)));
}
}
__inline static pte_t __attribute__((__always_inline__))  pfn_pte(unsigned long page_nr ,
                                                                  pgprot_t pgprot ) 
{ pte_t pte ;

  {
  pte.pte_high = (unsigned long )((unsigned long long )(page_nr >> 20) | (pgprot.pgprot >>
                                                                          32));
  pte.pte_high = (unsigned long )((unsigned long long )pte.pte_high & (__supported_pte_mask >>
                                                                       32));
  pte.pte_low = (unsigned long )(((unsigned long long )(page_nr << 12) | pgprot.pgprot) &
                                 __supported_pte_mask);
  return (pte);
}
}
__inline static pmd_t __attribute__((__always_inline__))  pfn_pmd(unsigned long page_nr ,
                                                                  pgprot_t pgprot ) 
{ pmd_t __constr_expr_0 ;

  {
  __constr_expr_0.pmd = (((unsigned long long )page_nr << 12) | pgprot.pgprot) & __supported_pte_mask;
  return (__constr_expr_0);
}
}
__inline static int __attribute__((__always_inline__))  ptep_test_and_clear_dirty(struct vm_area_struct *vma ,
                                                                                  unsigned long addr ,
                                                                                  pte_t *ptep ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = pte_dirty((*ptep));
  if (! tmp) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___0 = test_and_clear_bit(6, (unsigned long volatile   *)(& ptep->pte_low));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  ptep_test_and_clear_young(struct vm_area_struct *vma ,
                                                                                  unsigned long addr ,
                                                                                  pte_t *ptep ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = pte_young((*ptep));
  if (! tmp) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___0 = test_and_clear_bit(5, (unsigned long volatile   *)(& ptep->pte_low));
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  ptep_set_wrprotect(struct mm_struct *mm ,
                                                                            unsigned long addr ,
                                                                            pte_t *ptep ) 
{ 

  {
  clear_bit(1, (unsigned long volatile   *)(& ptep->pte_low));
  return;
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_modify(pte_t pte , pgprot_t newprot ) 
{ 

  {
  pte.pte_low &= 4294963296UL;
  pte.pte_low = (unsigned long )((unsigned long long )pte.pte_low | newprot.pgprot);
  pte.pte_high &= 2147483647UL;
  pte.pte_high = (unsigned long )((unsigned long long )pte.pte_high | ((newprot.pgprot >>
                                                                        32) & (__supported_pte_mask >>
                                                                               32)));
  return (pte);
}
}
extern pte_t *lookup_address(unsigned long address ) ;
extern int set_kernel_exec(unsigned long vaddr , int enable ) ;
extern void noexec_setup(char const   *str ) ;
extern void pgd_clear_bad(pgd_t * ) ;
extern void pud_clear_bad(pud_t * ) ;
extern void pmd_clear_bad(pmd_t * ) ;
__inline static int __attribute__((__always_inline__))  pgd_none_or_clear_bad(pgd_t *pgd ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = pgd_none((*pgd));
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp___0 = pgd_none((*pgd));
  if (tmp___0) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  if (tmp___2) {
    pgd_clear_bad(pgd);
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  pud_none_or_clear_bad(pud_t *pud ) 
{ long tmp ;

  {
  tmp = __builtin_expect(0L, 0L);
  if (tmp) {
    pud_clear_bad(pud);
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  pmd_none_or_clear_bad(pmd_t *pmd ) 
{ long tmp ;

  {
  if (! pmd->pmd) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp = __builtin_expect((long )(! (! ((pmd->pmd & 4091ULL) != 99ULL)) != 0), 0L);
  if (tmp) {
    pmd_clear_bad(pmd);
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern pgprot_t protection_map[16] ;
extern void get_page_state(struct page_state *ret ) ;
extern void get_full_page_state(struct page_state *ret ) ;
extern unsigned long __read_page_state(unsigned int offset ) ;
extern void __mod_page_state(unsigned int offset , unsigned long delta ) ;
extern int test_clear_page_dirty(struct page *page ) ;
extern int test_clear_page_writeback(struct page *page ) ;
extern int test_set_page_writeback(struct page *page ) ;
__inline static void __attribute__((__always_inline__))  clear_page_dirty(struct page *page ) 
{ 

  {
  test_clear_page_dirty(page);
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_page_writeback(struct page *page ) 
{ 

  {
  test_set_page_writeback(page);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __page_cache_release)(struct page * ) ;
__inline static int __attribute__((__always_inline__))  page_count(struct page *p ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(15, (unsigned long const volatile   *)(& p->flags));
  if (tmp) {
    p = (struct page *)p->private;
  }
  return ((int __attribute__((__always_inline__))  )(p->_count.counter + 1));
}
}
__inline static void __attribute__((__always_inline__))  get_page(struct page *page ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = constant_test_bit(15, (unsigned long const volatile   *)(& page->flags));
  if (tmp) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  if (tmp___2) {
    page = (struct page *)page->private;
  }
  atomic_inc(& page->_count);
  return;
}
}
extern void put_page(struct page *page ) ;
__inline static unsigned long __attribute__((__always_inline__))  page_zonenum(struct page *page ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((page->flags >> ((sizeof(page_flags_t ) *
                                                                                 8U -
                                                                                 1U) -
                                                                                2U)) &
                                                               3UL));
}
}
__inline static unsigned long __attribute__((__always_inline__))  page_to_nid(struct page *page ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )(page->flags >> (((sizeof(page_flags_t ) *
                                                                                 8U -
                                                                                 1U) -
                                                                                2U) +
                                                                               2U)));
}
}
extern struct zone *zone_table[] ;
__inline static struct zone  __attribute__((__always_inline__)) *page_zone(struct page *page ) 
{ 

  {
  return ((struct zone  __attribute__((__always_inline__)) *)zone_table[page->flags >>
                                                                        ((sizeof(page_flags_t ) *
                                                                          8U - 1U) -
                                                                         2U)]);
}
}
__inline static void __attribute__((__always_inline__))  set_page_zone(struct page *page ,
                                                                       unsigned long nodezone_num ) 
{ 

  {
  page->flags &= ~ (4294967295UL << ((sizeof(page_flags_t ) * 8U - 1U) - 2U));
  page->flags |= nodezone_num << ((sizeof(page_flags_t ) * 8U - 1U) - 2U);
  return;
}
}
extern struct page *mem_map ;
__inline static void __attribute__((__always_inline__))  *lowmem_page_address(struct page *page ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((void *)(((unsigned long )(page -
                                                                                  mem_map) <<
                                                                 12) + 3221225472UL)));
}
}
extern void *page_address(struct page *page ) ;
extern void set_page_address(struct page *page , void *virtual ) ;
extern void page_address_init(void) ;
extern struct address_space swapper_space ;
__inline static struct address_space  __attribute__((__always_inline__)) *page_mapping(struct page *page ) 
{ struct address_space *mapping ;
  long tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  mapping = page->mapping;
  tmp___0 = constant_test_bit(16, (unsigned long const volatile   *)(& page->flags));
  if (tmp___0) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  if (tmp___3) {
    mapping = & swapper_space;
  } else {
    tmp = __builtin_expect((long )(! (! ((unsigned long )mapping & 1UL)) != 0), 0L);
    if (tmp) {
      mapping = (struct address_space *)((void *)0);
    }
  }
  return ((struct address_space  __attribute__((__always_inline__)) *)mapping);
}
}
__inline static int __attribute__((__always_inline__))  PageAnon(struct page *page ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(((unsigned long )page->mapping &
                                                      1UL) != 0UL));
}
}
__inline static unsigned long __attribute__((__always_inline__))  page_index(struct page *page ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = constant_test_bit(16, (unsigned long const volatile   *)(& page->flags));
  if (tmp) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  if (tmp___2) {
    return ((unsigned long __attribute__((__always_inline__))  )page->private);
  }
  return ((unsigned long __attribute__((__always_inline__))  )page->index);
}
}
__inline static void __attribute__((__always_inline__))  reset_page_mapcount(struct page *page ) 
{ 

  {
  page->_mapcount.counter = (int volatile   )-1;
  return;
}
}
__inline static int __attribute__((__always_inline__))  page_mapcount(struct page *page ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(page->_mapcount.counter + 1));
}
}
__inline static int __attribute__((__always_inline__))  page_mapped(struct page *page ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(page->_mapcount.counter >= 0));
}
}
extern void show_free_areas(void) ;
extern struct page *shmem_nopage(struct vm_area_struct *vma , unsigned long address ,
                                 int *type ) ;
extern int shmem_set_policy(struct vm_area_struct *vma , struct mempolicy *new ) ;
extern struct mempolicy *shmem_get_policy(struct vm_area_struct *vma , unsigned long addr ) ;
extern int shmem_lock(struct file *file , int lock , struct user_struct *user ) ;
extern struct file *shmem_file_setup(char *name , loff_t size , unsigned long flags ) ;
extern int shmem_zero_setup(struct vm_area_struct * ) ;
__inline static int __attribute__((__always_inline__))  can_do_mlock(void) 
{ int __attribute__((__always_inline__))  tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp = capable(14);
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp___0 = get_current();
  if ((tmp___0->signal)->rlim[8].rlim_cur != 0UL) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int user_shm_lock(size_t  , struct user_struct * ) ;
extern void user_shm_unlock(size_t  , struct user_struct * ) ;
extern unsigned long zap_page_range(struct vm_area_struct *vma , unsigned long address ,
                                    unsigned long size , struct zap_details * ) ;
extern unsigned long unmap_vmas(struct mmu_gather **tlb , struct mm_struct *mm , struct vm_area_struct *start_vma ,
                                unsigned long start_addr , unsigned long end_addr ,
                                unsigned long *nr_accounted , struct zap_details * ) ;
extern void free_pgd_range(struct mmu_gather **tlb , unsigned long addr , unsigned long end ,
                           unsigned long floor , unsigned long ceiling ) ;
extern void free_pgtables(struct mmu_gather **tlb , struct vm_area_struct *start_vma ,
                          unsigned long floor , unsigned long ceiling ) ;
extern int copy_page_range(struct mm_struct *dst , struct mm_struct *src , struct vm_area_struct *vma ) ;
extern int zeromap_page_range(struct vm_area_struct *vma , unsigned long from , unsigned long size ,
                              pgprot_t prot ) ;
extern void unmap_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                loff_t holelen , int even_cows ) ;
__inline static void __attribute__((__always_inline__))  unmap_shared_mapping_range(struct address_space *mapping ,
                                                                                    loff_t holebegin ,
                                                                                    loff_t holelen ) 
{ 

  {
  unmap_mapping_range(mapping, holebegin, holelen, 0);
  return;
}
}
extern int vmtruncate(struct inode *inode , loff_t offset ) ;
extern pud_t *( __attribute__((__regparm__(3))) __pud_alloc)(struct mm_struct *mm ,
                                                             pgd_t *pgd , unsigned long address ) ;
extern pmd_t *( __attribute__((__regparm__(3))) __pmd_alloc)(struct mm_struct *mm ,
                                                             pud_t *pud , unsigned long address ) ;
extern pte_t *( __attribute__((__regparm__(3))) pte_alloc_kernel)(struct mm_struct *mm ,
                                                                  pmd_t *pmd , unsigned long address ) ;
extern pte_t *( __attribute__((__regparm__(3))) pte_alloc_map)(struct mm_struct *mm ,
                                                               pmd_t *pmd , unsigned long address ) ;
extern int install_page(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long addr ,
                        struct page *page , pgprot_t prot ) ;
extern int install_file_pte(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long addr ,
                            unsigned long pgoff , pgprot_t prot ) ;
extern int handle_mm_fault(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long address ,
                           int write_access ) ;
extern int make_pages_present(unsigned long addr , unsigned long end ) ;
extern int access_process_vm(struct task_struct *tsk , unsigned long addr , void *buf ,
                             int len , int write ) ;
extern void install_arg_page(struct vm_area_struct * , struct page * , unsigned long  ) ;
extern int get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                          int len , int write , int force , struct page **pages ,
                          struct vm_area_struct **vmas ) ;
extern int __set_page_dirty_buffers(struct page *page ) ;
extern int __set_page_dirty_nobuffers(struct page *page ) ;
extern int redirty_page_for_writepage(struct writeback_control *wbc , struct page *page ) ;
extern int ( __attribute__((__regparm__(3))) set_page_dirty)(struct page *page ) ;
extern int set_page_dirty_lock(struct page *page ) ;
extern int clear_page_dirty_for_io(struct page *page ) ;
extern unsigned long do_mremap(unsigned long addr , unsigned long old_len , unsigned long new_len ,
                               unsigned long flags , unsigned long new_addr ) ;
extern struct shrinker *set_shrinker(int  , int (*)(int nr_to_scan , unsigned int gfp_mask ) ) ;
extern void remove_shrinker(struct shrinker *shrinker ) ;
__inline static pud_t __attribute__((__always_inline__))  *pud_alloc(struct mm_struct *mm ,
                                                                     pgd_t *pgd ,
                                                                     unsigned long address ) 
{ pud_t __attribute__((__always_inline__))  *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  pud_t __attribute__((__always_inline__))  *tmp___1 ;

  {
  tmp___0 = pgd_none((*pgd));
  if (tmp___0) {
    tmp = (pud_t __attribute__((__always_inline__))  *)__pud_alloc(mm, pgd, address);
    return (tmp);
  }
  tmp___1 = pud_offset(pgd, address);
  return (tmp___1);
}
}
__inline static pmd_t __attribute__((__always_inline__))  *pmd_alloc(struct mm_struct *mm ,
                                                                     pud_t *pud ,
                                                                     unsigned long address ) 
{ pmd_t __attribute__((__always_inline__))  *tmp ;

  {
  return ((pmd_t __attribute__((__always_inline__))  *)((pmd_t *)((struct page *)((void *)((unsigned long )(pud->pgd.pgd &
                                                                                                            4294963200ULL) +
                                                                                           3221225472UL))) +
                                                        ((address >> 21) & 511UL)));
}
}
extern void free_area_init(unsigned long *zones_size ) ;
extern void free_area_init_node(int nid , pg_data_t *pgdat , unsigned long *zones_size ,
                                unsigned long zone_start_pfn , unsigned long *zholes_size ) ;
extern void memmap_init_zone(unsigned long  , int  , unsigned long  , unsigned long  ) ;
extern void mem_init(void) ;
extern void show_mem(void) ;
extern void si_meminfo(struct sysinfo *val ) ;
extern void si_meminfo_node(struct sysinfo *val , int nid ) ;
extern void vma_prio_tree_add(struct vm_area_struct * , struct vm_area_struct *old ) ;
extern void vma_prio_tree_insert(struct vm_area_struct * , struct prio_tree_root * ) ;
extern void vma_prio_tree_remove(struct vm_area_struct * , struct prio_tree_root * ) ;
extern struct vm_area_struct *vma_prio_tree_next(struct vm_area_struct *vma , struct prio_tree_iter *iter ) ;
__inline static void __attribute__((__always_inline__))  vma_nonlinear_insert(struct vm_area_struct *vma ,
                                                                              struct list_head *list ) 
{ 

  {
  vma->shared.vm_set.parent = (void *)0;
  list_add_tail(& vma->shared.vm_set.list, list);
  return;
}
}
extern int __vm_enough_memory(long pages , int cap_sys_admin ) ;
extern void vma_adjust(struct vm_area_struct *vma , unsigned long start , unsigned long end ,
                       unsigned long pgoff , struct vm_area_struct *insert ) ;
extern struct vm_area_struct *vma_merge(struct mm_struct * , struct vm_area_struct *prev ,
                                        unsigned long addr , unsigned long end , unsigned long vm_flags ,
                                        struct anon_vma * , struct file * , unsigned long  ,
                                        struct mempolicy * ) ;
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct * ) ;
extern int split_vma(struct mm_struct * , struct vm_area_struct * , unsigned long addr ,
                     int new_below ) ;
extern int insert_vm_struct(struct mm_struct * , struct vm_area_struct * ) ;
extern void __vma_link_rb(struct mm_struct * , struct vm_area_struct * , struct rb_node ** ,
                          struct rb_node * ) ;
extern struct vm_area_struct *copy_vma(struct vm_area_struct ** , unsigned long addr ,
                                       unsigned long len , unsigned long pgoff ) ;
extern void exit_mmap(struct mm_struct * ) ;
extern int may_expand_vm(struct mm_struct *mm , unsigned long npages ) ;
extern unsigned long get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                       unsigned long  , unsigned long  ) ;
extern unsigned long do_mmap_pgoff(struct file *file , unsigned long addr , unsigned long len ,
                                   unsigned long prot , unsigned long flag , unsigned long pgoff ) ;
__inline static unsigned long __attribute__((__always_inline__))  do_mmap(struct file *file ,
                                                                          unsigned long addr ,
                                                                          unsigned long len ,
                                                                          unsigned long prot ,
                                                                          unsigned long flag ,
                                                                          unsigned long offset ) 
{ unsigned long ret ;

  {
  ret = 4294967274UL;
  if (offset + (((len + 4096UL) - 1UL) & 4294963200UL) < offset) {
    goto out;
  }
  if (! (offset & 4095UL)) {
    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
  }
  out: 
  return ((unsigned long __attribute__((__always_inline__))  )ret);
}
}
extern int do_munmap(struct mm_struct * , unsigned long  , size_t  ) ;
extern unsigned long do_brk(unsigned long  , unsigned long  ) ;
extern unsigned long page_unuse(struct page * ) ;
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
extern struct page *filemap_nopage(struct vm_area_struct * , unsigned long  , int * ) ;
extern int filemap_populate(struct vm_area_struct * , unsigned long  , unsigned long  ,
                            pgprot_t  , unsigned long  , int  ) ;
extern int write_one_page(struct page *page , int wait ) ;
extern int do_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                   unsigned long offset , unsigned long nr_to_read ) ;
extern int force_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                      unsigned long offset , unsigned long nr_to_read ) ;
extern unsigned long page_cache_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                          struct file *filp , unsigned long offset ,
                                          unsigned long size ) ;
extern void handle_ra_miss(struct address_space *mapping , struct file_ra_state *ra ,
                           unsigned long offset ) ;
extern unsigned long max_sane_readahead(unsigned long nr ) ;
extern int expand_stack(struct vm_area_struct *vma , unsigned long address ) ;
extern struct vm_area_struct *find_vma(struct mm_struct *mm , unsigned long addr ) ;
extern struct vm_area_struct *find_vma_prev(struct mm_struct *mm , unsigned long addr ,
                                            struct vm_area_struct **pprev ) ;
__inline static struct vm_area_struct  __attribute__((__always_inline__)) *find_vma_intersection(struct mm_struct *mm ,
                                                                                                 unsigned long start_addr ,
                                                                                                 unsigned long end_addr ) 
{ struct vm_area_struct *vma ;
  struct vm_area_struct *tmp ;

  {
  tmp = find_vma(mm, start_addr);
  vma = tmp;
  if (vma) {
    if (end_addr <= vma->vm_start) {
      vma = (struct vm_area_struct *)((void *)0);
    }
  }
  return ((struct vm_area_struct  __attribute__((__always_inline__)) *)vma);
}
}
__inline static unsigned long __attribute__((__always_inline__))  vma_pages(struct vm_area_struct *vma ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((vma->vm_end - vma->vm_start) >>
                                                               12));
}
}
extern struct vm_area_struct *find_extend_vma(struct mm_struct *mm , unsigned long addr ) ;
extern struct page *vmalloc_to_page(void *addr ) ;
extern unsigned long vmalloc_to_pfn(void *addr ) ;
extern struct page *follow_page(struct mm_struct *mm , unsigned long address , int write ) ;
extern int check_user_page_readable(struct mm_struct *mm , unsigned long address ) ;
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
extern void __vm_stat_account(struct mm_struct * , unsigned long  , struct file * ,
                              long  ) ;
__inline static void __attribute__((__always_inline__))  vm_stat_account(struct vm_area_struct *vma ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = vma_pages(vma);
  __vm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file, (long )tmp);
  return;
}
}
__inline static void __attribute__((__always_inline__))  vm_stat_unaccount(struct vm_area_struct *vma ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = vma_pages(vma);
  __vm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file, (long )(- tmp));
  return;
}
}
extern void update_mem_hiwater(struct task_struct *tsk ) ;
__inline static void __attribute__((__always_inline__))  kernel_map_pages(struct page *page ,
                                                                          int numpages ,
                                                                          int enable ) 
{ 

  {
  return;
}
}
extern struct vm_area_struct *get_gate_vma(struct task_struct *tsk ) ;
extern int in_gate_area_no_task(unsigned long addr ) ;
extern void global_flush_tlb(void) ;
extern int change_page_attr(struct page *page , int numpages , pgprot_t prot ) ;
extern unsigned long pgkern_mask ;
extern void flush_tlb_all(void) ;
extern void flush_tlb_current_task(void) ;
extern void flush_tlb_mm(struct mm_struct * ) ;
extern void flush_tlb_page(struct vm_area_struct * , unsigned long  ) ;
__inline static void __attribute__((__always_inline__))  flush_tlb_range(struct vm_area_struct *vma ,
                                                                         unsigned long start ,
                                                                         unsigned long end ) 
{ 

  {
  flush_tlb_mm(vma->vm_mm);
  return;
}
}
extern struct tlb_state per_cpu__cpu_tlbstate ;
__inline static void __attribute__((__always_inline__))  flush_tlb_pgtables(struct mm_struct *mm ,
                                                                            unsigned long start ,
                                                                            unsigned long end ) 
{ 

  {
  return;
}
}
extern unsigned long highstart_pfn ;
extern unsigned long highend_pfn ;
extern pte_t *kmap_pte ;
extern pgprot_t kmap_prot ;
extern pte_t *pkmap_page_table ;
extern void *( __attribute__((__regparm__(3))) kmap_high)(struct page *page ) ;
extern void ( __attribute__((__regparm__(3))) kunmap_high)(struct page *page ) ;
extern void *kmap(struct page *page ) ;
extern void kunmap(struct page *page ) ;
extern void *kmap_atomic(struct page *page , enum km_type type ) ;
extern void kunmap_atomic(void *kvaddr , enum km_type type ) ;
extern struct page *kmap_atomic_to_page(void *ptr ) ;
extern unsigned int nr_free_highpages(void) ;
__inline static void __attribute__((__always_inline__))  clear_user_highpage(struct page *page ,
                                                                             unsigned long vaddr ) 
{ void *addr ;
  void *tmp ;

  {
  tmp = kmap_atomic(page, 7);
  addr = tmp;
  __constant_c_and_count_memset(addr, 0UL, 4096U);
  kunmap_atomic(addr, 7);
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  clear_highpage(struct page *page ) 
{ void *kaddr ;
  void *tmp ;

  {
  tmp = kmap_atomic(page, 7);
  kaddr = tmp;
  __constant_c_and_count_memset(kaddr, 0UL, 4096U);
  kunmap_atomic(kaddr, 7);
  return;
}
}
__inline static void __attribute__((__always_inline__))  memclear_highpage_flush(struct page *page ,
                                                                                 unsigned int offset ,
                                                                                 unsigned int size ) 
{ void *kaddr ;
  long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((unsigned long )(offset + size) > 4096UL) !=
                                         0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (72), "i" ("include/linux/highmem.h"));
    }
    break;
  }
  kaddr = kmap_atomic(page, 7);
  __constant_c_memset((void *)((char *)kaddr + offset), 0UL, size);
  while (1) {
    break;
  }
  kunmap_atomic(kaddr, 7);
  return;
}
}
__inline static void __attribute__((__always_inline__))  copy_user_highpage(struct page *to ,
                                                                            struct page *from ,
                                                                            unsigned long vaddr ) 
{ char *vfrom ;
  char *vto ;

  {
  vfrom = (char *)kmap_atomic(from, 7);
  vto = (char *)kmap_atomic(to, 9);
  __constant_memcpy((void *)vto, (void const   *)((void *)vfrom), 4096U);
  kunmap_atomic((void *)vfrom, 7);
  kunmap_atomic((void *)vto, 9);
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  copy_highpage(struct page *to ,
                                                                       struct page *from ) 
{ char *vfrom ;
  char *vto ;

  {
  vfrom = (char *)kmap_atomic(from, 7);
  vto = (char *)kmap_atomic(to, 9);
  __constant_memcpy((void *)vto, (void const   *)((void *)vfrom), 4096U);
  kunmap_atomic((void *)vfrom, 7);
  kunmap_atomic((void *)vto, 9);
  return;
}
}
__inline static void __attribute__((__always_inline__))  poll_wait(struct file *filp ,
                                                                   wait_queue_head_t *wait_address ,
                                                                   poll_table *p ) 
{ 

  {
  if (p) {
    if (wait_address) {
      ((*(p->qproc)))(filp, wait_address, p);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_poll_funcptr(poll_table *pt ,
                                                                           void (*qproc)(struct file * ,
                                                                                         wait_queue_head_t * ,
                                                                                         struct poll_table_struct * ) ) 
{ 

  {
  pt->qproc = qproc;
  return;
}
}
extern void poll_initwait(struct poll_wqueues *pwq ) ;
extern void poll_freewait(struct poll_wqueues *pwq ) ;
__inline static int __attribute__((__always_inline__))  get_fd_set(unsigned long nr ,
                                                                   void *ufdset ,
                                                                   unsigned long *fdset ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  nr = (((nr + (unsigned long )(8U * sizeof(long ))) - 1UL) / (unsigned long )(8U *
                                                                               sizeof(long ))) *
       (unsigned long )sizeof(long );
  if (ufdset) {
    tmp___1 = copy_from_user((void *)fdset, (void const   *)ufdset, nr);
    if (tmp___1) {
      tmp___0 = -14;
    } else {
      tmp___0 = 0;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  }
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )nr);
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static unsigned long __attribute__((__always_inline__))  set_fd_set(unsigned long nr ,
                                                                             void *ufdset ,
                                                                             unsigned long *fdset ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  if (ufdset) {
    tmp = __copy_to_user(ufdset, (void const   *)fdset, (((nr + (unsigned long )(8U *
                                                                                 sizeof(long ))) -
                                                          1UL) / (unsigned long )(8U *
                                                                                  sizeof(long ))) *
                                                        (unsigned long )sizeof(long ));
    return (tmp);
  }
  return ((unsigned long __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  zero_fd_set(unsigned long nr ,
                                                                     unsigned long *fdset ) 
{ 

  {
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )((((nr + (unsigned long )(8U *
                                                                                   sizeof(long ))) -
                                                            1UL) / (unsigned long )(8U *
                                                                                    sizeof(long ))) *
                                                          (unsigned long )sizeof(long )));
  return;
}
}
extern int do_select(int n , fd_set_bits *fds , long *timeout ) ;
extern int sock_wake_async(struct socket *sk , int how , int band ) ;
extern int sock_register(struct net_proto_family *fam ) ;
extern int sock_unregister(int family ) ;
extern int sock_create(int family , int type , int proto , struct socket **res ) ;
extern int sock_create_kern(int family , int type , int proto , struct socket **res ) ;
extern int sock_create_lite(int family , int type , int proto , struct socket **res ) ;
extern void sock_release(struct socket *sock ) ;
extern int sock_sendmsg(struct socket *sock , struct msghdr *msg , size_t len ) ;
extern int sock_recvmsg(struct socket *sock , struct msghdr *msg , size_t size , int flags ) ;
extern int sock_map_fd(struct socket *sock ) ;
extern struct socket *sockfd_lookup(int fd , int *err ) ;
extern int net_ratelimit(void) ;
extern unsigned long net_random(void) ;
extern void net_srandom(unsigned long  ) ;
extern void net_random_init(void) ;
extern int kernel_sendmsg(struct socket *sock , struct msghdr *msg , struct kvec *vec ,
                          size_t num , size_t len ) ;
extern int kernel_recvmsg(struct socket *sock , struct msghdr *msg , struct kvec *vec ,
                          size_t num , size_t len , int flags ) ;
extern struct in6_addr  const  in6addr_loopback ;
extern unsigned int ( __attribute__((__regparm__(0))) csum_partial)(unsigned char const   *buff ,
                                                                    int len , unsigned int sum ) ;
extern unsigned int ( __attribute__((__regparm__(0))) csum_partial_copy_generic)(unsigned char const   *src ,
                                                                                 unsigned char *dst ,
                                                                                 int len ,
                                                                                 int sum ,
                                                                                 int *src_err_ptr ,
                                                                                 int *dst_err_ptr ) ;
__inline static unsigned int __attribute__((__always_inline__))  csum_partial_copy_nocheck(unsigned char const   *src ,
                                                                                           unsigned char *dst ,
                                                                                           int len ,
                                                                                           int sum ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (unsigned int __attribute__((__always_inline__))  )csum_partial_copy_generic(src,
                                                                                     dst,
                                                                                     len,
                                                                                     sum,
                                                                                     (int *)((void *)0),
                                                                                     (int *)((void *)0));
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_partial_copy_from_user(unsigned char const   *src ,
                                                                                             unsigned char *dst ,
                                                                                             int len ,
                                                                                             int sum ,
                                                                                             int *err_ptr ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = (unsigned int __attribute__((__always_inline__))  )csum_partial_copy_generic((unsigned char const   *)((unsigned char *)src),
                                                                                     dst,
                                                                                     len,
                                                                                     sum,
                                                                                     err_ptr,
                                                                                     (int *)((void *)0));
  return (tmp);
}
}
__inline static unsigned short __attribute__((__always_inline__))  ip_fast_csum(unsigned char *iph ,
                                                                                unsigned int ihl ) 
{ unsigned int sum ;

  {
  __asm__  volatile   ("movl (%1), %0\t;\n"
                       "subl $4, %2\t;\n"
                       "jbe 2f\t\t;\n"
                       "addl 4(%1), %0\t;\n"
                       "adcl 8(%1), %0\t;\n"
                       "adcl 12(%1), %0\t;\n"
                       "1:\t    adcl 16(%1), %0\t;\n"
                       "lea 4(%1), %1\t;\n"
                       "decl %2\t\t;\n"
                       "jne 1b\t\t;\n"
                       "adcl $0, %0\t;\n"
                       "movl %0, %2\t;\n"
                       "shrl $16, %0\t;\n"
                       "addw %w2, %w0\t;\n"
                       "adcl $0, %0\t;\n"
                       "notl %0\t\t;\n"
                       "2:\t\t\t\t;\n": "=r" (sum), "=r" (iph), "=r" (ihl): "1" (iph),
                       "2" (ihl): "memory");
  return ((unsigned short __attribute__((__always_inline__))  )sum);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_fold(unsigned int sum ) 
{ 

  {
  __asm__  ("addl %1, %0\t\t;\n"
            "adcl $0xffff, %0\t;\n": "=r" (sum): "r" (sum << 16), "0" (sum & 4294901760U));
  return ((unsigned int __attribute__((__always_inline__))  )(~ sum >> 16));
}
}
__inline static unsigned long __attribute__((__always_inline__))  csum_tcpudp_nofold(unsigned long saddr ,
                                                                                     unsigned long daddr ,
                                                                                     unsigned short len ,
                                                                                     unsigned short proto ,
                                                                                     unsigned int sum ) 
{ __u16 __x ;
  __u16 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __fswab16(len);
  __asm__  ("addl %1, %0\t;\n"
            "adcl %2, %0\t;\n"
            "adcl %3, %0\t;\n"
            "adcl $0, %0\t;\n": "=r" (sum): "g" (daddr), "g" (saddr), "g" (((int )tmp <<
                                                                            16) +
                                                                           (int )proto *
                                                                           256), "0" (sum));
  return ((unsigned long __attribute__((__always_inline__))  )sum);
}
}
__inline static unsigned short __attribute__((__always_inline__))  csum_tcpudp_magic(unsigned long saddr ,
                                                                                     unsigned long daddr ,
                                                                                     unsigned short len ,
                                                                                     unsigned short proto ,
                                                                                     unsigned int sum ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = csum_tcpudp_nofold(saddr, daddr, len, proto, sum);
  tmp___0 = (unsigned short __attribute__((__always_inline__))  )csum_fold((unsigned int )tmp);
  return (tmp___0);
}
}
__inline static unsigned short __attribute__((__always_inline__))  ip_compute_csum(unsigned char *buff ,
                                                                                   int len ) 
{ unsigned int tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = csum_partial((unsigned char const   *)buff, len, 0U);
  tmp___0 = (unsigned short __attribute__((__always_inline__))  )csum_fold(tmp);
  return (tmp___0);
}
}
__inline static unsigned short __attribute__((__always_inline__))  csum_ipv6_magic(struct in6_addr *saddr ,
                                                                                   struct in6_addr *daddr ,
                                                                                   __u32 len ,
                                                                                   unsigned short proto ,
                                                                                   unsigned int sum ) 
{ __u32 __x ;
  __u32 __attribute__((__always_inline__))  tmp ;
  __u32 __x___0 ;
  __u32 __attribute__((__always_inline__))  tmp___0 ;
  unsigned short __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = __fswab32(len);
  tmp___0 = __fswab32((unsigned int )proto);
  __asm__  ("addl 0(%1), %0\t\t;\n"
            "adcl 4(%1), %0\t\t;\n"
            "adcl 8(%1), %0\t\t;\n"
            "adcl 12(%1), %0\t;\n"
            "adcl 0(%2), %0\t\t;\n"
            "adcl 4(%2), %0\t\t;\n"
            "adcl 8(%2), %0\t\t;\n"
            "adcl 12(%2), %0\t;\n"
            "adcl %3, %0\t\t;\n"
            "adcl %4, %0\t\t;\n"
            "adcl $0, %0\t\t;\n": "=&r" (sum): "r" (saddr), "r" (daddr), "r" (tmp),
            "r" (tmp___0), "0" (sum));
  tmp___1 = (unsigned short __attribute__((__always_inline__))  )csum_fold(sum);
  return (tmp___1);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_and_copy_to_user(unsigned char const   *src ,
                                                                                       unsigned char *dst ,
                                                                                       int len ,
                                                                                       int sum ,
                                                                                       int *err_ptr ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned long flag ;
  unsigned long sum___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  while (1) {
    break;
  }
  tmp___0 = current_thread_info();
  __asm__  ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum___0): "1" (dst),
            "g" (len), "g" (tmp___0->addr_limit.seg));
  if (flag == 0UL) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {
    tmp = (unsigned int __attribute__((__always_inline__))  )csum_partial_copy_generic(src,
                                                                                       dst,
                                                                                       len,
                                                                                       sum,
                                                                                       (int *)((void *)0),
                                                                                       err_ptr);
    return (tmp);
  }
  if (len) {
    (*err_ptr) = -14;
  }
  return ((unsigned int __attribute__((__always_inline__))  )-1);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_and_copy_from_user(unsigned char const   *src ,
                                                                                         unsigned char *dst ,
                                                                                         int len ,
                                                                                         int sum ,
                                                                                         int *err_ptr ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned long flag ;
  unsigned long sum___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp___0 = current_thread_info();
  __asm__  ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum___0): "1" (src),
            "g" (len), "g" (tmp___0->addr_limit.seg));
  if (flag == 0UL) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {
    tmp = csum_partial_copy_from_user(src, dst, len, sum, err_ptr);
    return (tmp);
  }
  if (len) {
    (*err_ptr) = -14;
  }
  return ((unsigned int __attribute__((__always_inline__))  )sum);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_add(unsigned int csum ,
                                                                          unsigned int addend ) 
{ 

  {
  csum += addend;
  return ((unsigned int __attribute__((__always_inline__))  )(csum + (unsigned int )(csum <
                                                                                     addend)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_sub(unsigned int csum ,
                                                                          unsigned int addend ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = csum_add(csum, ~ addend);
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_block_add(unsigned int csum ,
                                                                                unsigned int csum2 ,
                                                                                int offset ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  if (offset & 1) {
    csum2 = ((csum2 & 16711935U) << 8) + ((csum2 >> 8) & 16711935U);
  }
  tmp = csum_add(csum, csum2);
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_block_sub(unsigned int csum ,
                                                                                unsigned int csum2 ,
                                                                                int offset ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  if (offset & 1) {
    csum2 = ((csum2 & 16711935U) << 8) + ((csum2 >> 8) & 16711935U);
  }
  tmp = csum_sub(csum, csum2);
  return (tmp);
}
}
extern void __kfree_skb(struct sk_buff *skb ) ;
extern struct sk_buff *alloc_skb(unsigned int size , int priority ) ;
extern struct sk_buff *alloc_skb_from_cache(kmem_cache_t *cp , unsigned int size ,
                                            int priority ) ;
extern void kfree_skbmem(struct sk_buff *skb ) ;
extern struct sk_buff *skb_clone(struct sk_buff *skb , int priority ) ;
extern struct sk_buff *skb_copy(struct sk_buff  const  *skb , int priority ) ;
extern struct sk_buff *pskb_copy(struct sk_buff *skb , int gfp_mask ) ;
extern int pskb_expand_head(struct sk_buff *skb , int nhead , int ntail , int gfp_mask ) ;
extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb , unsigned int headroom ) ;
extern struct sk_buff *skb_copy_expand(struct sk_buff  const  *skb , int newheadroom ,
                                       int newtailroom , int priority ) ;
extern struct sk_buff *skb_pad(struct sk_buff *skb , int pad ) ;
extern void skb_over_panic(struct sk_buff *skb , int len , void *here ) ;
extern void skb_under_panic(struct sk_buff *skb , int len , void *here ) ;
__inline static int __attribute__((__always_inline__))  skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )list->next ==
                                                     (unsigned int )((struct sk_buff *)list)));
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_get(struct sk_buff *skb ) 
{ 

  {
  atomic_inc(& skb->users);
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static void __attribute__((__always_inline__))  kfree_skb(struct sk_buff *skb ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  tmp___2 = __builtin_expect((long )(! (! (skb->users.counter == 1)) != 0), 1L);
  if (tmp___2) {
    __asm__  volatile   ("661:\n\t"
                         "lock; addl $0,0(%%esp)"
                         "\n662:\n"
                         ".section .altinstructions,\"a\"\n"
                         "  .align 4\n"
                         "  .long 661b\n"
                         "  .long 663f\n"
                         "  .byte %c0\n"
                         "  .byte 662b-661b\n"
                         "  .byte 664f-663f\n"
                         ".previous\n"
                         ".section .altinstr_replacement,\"ax\"\n"
                         "663:\n\t"
                         "lfence"
                         "\n664:\n"
                         ".previous": : "i" (26): "memory");
  } else {
    tmp = atomic_dec_and_test(& skb->users);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    tmp___1 = __builtin_expect((long )tmp___0, 1L);
    if (tmp___1) {
      return;
    }
  }
  __kfree_skb(skb);
  return;
}
}
__inline static int __attribute__((__always_inline__))  skb_cloned(struct sk_buff  const  *skb ) 
{ int tmp ;

  {
  if (skb->cloned) {
    if ((((struct skb_shared_info *)skb->end)->dataref.counter & 65535) != 1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static int __attribute__((__always_inline__))  skb_header_cloned(struct sk_buff  const  *skb ) 
{ int dataref ;

  {
  if (! skb->cloned) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  dataref = (int )((struct skb_shared_info *)skb->end)->dataref.counter;
  dataref = (dataref & 65535) - (dataref >> 16);
  return ((int __attribute__((__always_inline__))  )(dataref != 1));
}
}
__inline static void __attribute__((__always_inline__))  skb_header_release(struct sk_buff *skb ) 
{ long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! ((int )skb->nohdr != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (419), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->nohdr = (unsigned char)1;
  atomic_add(65536, & ((struct skb_shared_info *)skb->end)->dataref);
  return;
}
}
__inline static int __attribute__((__always_inline__))  skb_shared(struct sk_buff  const  *skb ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(skb->users.counter != 1));
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_share_check(struct sk_buff *skb ,
                                                                                    int pri ) 
{ struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    break;
  }
  tmp___0 = skb_shared((struct sk_buff  const  *)skb);
  if (tmp___0) {
    tmp = skb_clone(skb, pri);
    nskb = tmp;
    kfree_skb(skb);
    skb = nskb;
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_unshare(struct sk_buff *skb ,
                                                                                int pri ) 
{ struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    break;
  }
  tmp___0 = skb_cloned((struct sk_buff  const  *)skb);
  if (tmp___0) {
    tmp = skb_copy((struct sk_buff  const  *)skb, pri);
    nskb = tmp;
    kfree_skb(skb);
    skb = nskb;
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_peek(struct sk_buff_head *list_ ) 
{ struct sk_buff *list ;

  {
  list = ((struct sk_buff *)list_)->next;
  if ((unsigned int )list == (unsigned int )((struct sk_buff *)list_)) {
    list = (struct sk_buff *)((void *)0);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)list);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_peek_tail(struct sk_buff_head *list_ ) 
{ struct sk_buff *list ;

  {
  list = ((struct sk_buff *)list_)->prev;
  if ((unsigned int )list == (unsigned int )((struct sk_buff *)list_)) {
    list = (struct sk_buff *)((void *)0);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)list);
}
}
__inline static __u32 __attribute__((__always_inline__))  skb_queue_len(struct sk_buff_head  const  *list_ ) 
{ 

  {
  return (list_->qlen);
}
}
__inline static void __attribute__((__always_inline__))  skb_queue_head_init(struct sk_buff_head *list ) 
{ spinlock_t __constr_expr_0 ;

  {
  while (1) {
    spin_lock_init(&__constr_expr_0);
    list->lock = __constr_expr_0;
    break;
  }
  list->next = (struct sk_buff *)list;
  list->prev = list->next;
  list->qlen = 0U;
  return;
}
}
extern void skb_queue_head(struct sk_buff_head *list , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_queue_head(struct sk_buff_head *list ,
                                                                          struct sk_buff *newsk ) 
{ struct sk_buff *prev ;
  struct sk_buff *next ;

  {
  newsk->list = list;
  list->qlen ++;
  prev = (struct sk_buff *)list;
  next = prev->next;
  newsk->next = next;
  newsk->prev = prev;
  prev->next = newsk;
  next->prev = prev->next;
  return;
}
}
extern void skb_queue_tail(struct sk_buff_head *list , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_queue_tail(struct sk_buff_head *list ,
                                                                          struct sk_buff *newsk ) 
{ struct sk_buff *prev ;
  struct sk_buff *next ;

  {
  newsk->list = list;
  list->qlen ++;
  next = (struct sk_buff *)list;
  prev = next->prev;
  newsk->next = next;
  newsk->prev = prev;
  prev->next = newsk;
  next->prev = prev->next;
  return;
}
}
extern struct sk_buff *skb_dequeue(struct sk_buff_head *list ) ;
__inline static struct sk_buff  __attribute__((__always_inline__)) *__skb_dequeue(struct sk_buff_head *list ) 
{ struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *result ;

  {
  prev = (struct sk_buff *)list;
  next = prev->next;
  result = (struct sk_buff *)((void *)0);
  if ((unsigned int )next != (unsigned int )prev) {
    result = next;
    next = next->next;
    list->qlen --;
    next->prev = prev;
    prev->next = next;
    result->prev = (struct sk_buff *)((void *)0);
    result->next = result->prev;
    result->list = (struct sk_buff_head *)((void *)0);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)result);
}
}
extern void skb_insert(struct sk_buff *old , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_insert(struct sk_buff *newsk ,
                                                                      struct sk_buff *prev ,
                                                                      struct sk_buff *next ,
                                                                      struct sk_buff_head *list ) 
{ 

  {
  newsk->next = next;
  newsk->prev = prev;
  prev->next = newsk;
  next->prev = prev->next;
  newsk->list = list;
  list->qlen ++;
  return;
}
}
extern void skb_append(struct sk_buff *old , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_append(struct sk_buff *old ,
                                                                      struct sk_buff *newsk ) 
{ 

  {
  __skb_insert(newsk, old, old->next, old->list);
  return;
}
}
extern void skb_unlink(struct sk_buff *skb ) ;
__inline static void __attribute__((__always_inline__))  __skb_unlink(struct sk_buff *skb ,
                                                                      struct sk_buff_head *list ) 
{ struct sk_buff *next ;
  struct sk_buff *prev ;

  {
  list->qlen --;
  next = skb->next;
  prev = skb->prev;
  skb->prev = (struct sk_buff *)((void *)0);
  skb->next = skb->prev;
  skb->list = (struct sk_buff_head *)((void *)0);
  next->prev = prev;
  prev->next = next;
  return;
}
}
extern struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list ) ;
__inline static struct sk_buff  __attribute__((__always_inline__)) *__skb_dequeue_tail(struct sk_buff_head *list ) 
{ struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  tmp = (struct sk_buff *)skb_peek_tail(list);
  skb = tmp;
  if (skb) {
    __skb_unlink(skb, list);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static int __attribute__((__always_inline__))  skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )skb->data_len);
}
}
__inline static unsigned int __attribute__((__always_inline__))  skb_headlen(struct sk_buff  const  *skb ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(skb->len - skb->data_len));
}
}
__inline static int __attribute__((__always_inline__))  skb_pagelen(struct sk_buff  const  *skb ) 
{ int i ;
  int len ;
  unsigned int __attribute__((__always_inline__))  tmp ;

  {
  len = 0;
  i = (int )((struct skb_shared_info *)skb->end)->nr_frags - 1;
  while (i >= 0) {
    len += (int )((struct skb_shared_info *)skb->end)->frags[i].size;
    i --;
  }
  tmp = skb_headlen(skb);
  return ((int __attribute__((__always_inline__))  )((unsigned int __attribute__((__always_inline__))  )len +
                                                     tmp));
}
}
__inline static void __attribute__((__always_inline__))  skb_fill_page_desc(struct sk_buff *skb ,
                                                                            int i ,
                                                                            struct page *page ,
                                                                            int off ,
                                                                            int size ) 
{ skb_frag_t *frag ;

  {
  frag = & ((struct skb_shared_info *)skb->end)->frags[i];
  frag->page = page;
  frag->page_offset = (unsigned short )off;
  frag->size = (unsigned short )size;
  ((struct skb_shared_info *)skb->end)->nr_frags = (unsigned int )(i + 1);
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  *__skb_put(struct sk_buff *skb ,
                                                                             unsigned int len ) 
{ unsigned char *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = skb->tail;
  while (1) {
    tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    if (tmp___2) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (741), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->tail += len;
  skb->len += len;
  return ((unsigned char __attribute__((__always_inline__))  *)tmp);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *skb_put(struct sk_buff *skb ,
                                                                           unsigned int len ) 
{ unsigned char *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  void *pc ;
  long tmp___3 ;

  {
  tmp = skb->tail;
  while (1) {
    tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    if (tmp___2) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (759), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->tail += len;
  skb->len += len;
  tmp___3 = __builtin_expect((long )(! (! ((unsigned int )skb->tail > (unsigned int )skb->end)) !=
                                     0), 0L);
  if (tmp___3) {
    __asm__  ("movl $1f,%0\n1:": "=g" (pc));
    skb_over_panic(skb, (int )len, pc);
  }
  return ((unsigned char __attribute__((__always_inline__))  *)tmp);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *__skb_push(struct sk_buff *skb ,
                                                                              unsigned int len ) 
{ 

  {
  skb->data -= len;
  skb->len += len;
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *skb_push(struct sk_buff *skb ,
                                                                            unsigned int len ) 
{ void *pc ;
  long tmp ;

  {
  skb->data -= len;
  skb->len += len;
  tmp = __builtin_expect((long )(! (! ((unsigned int )skb->data < (unsigned int )skb->head)) !=
                                 0), 0L);
  if (tmp) {
    __asm__  ("movl $1f,%0\n1:": "=g" (pc));
    skb_under_panic(skb, (int )len, pc);
  }
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *__skb_pull(struct sk_buff *skb ,
                                                                              unsigned int len ) 
{ long tmp ;

  {
  skb->len -= len;
  while (1) {
    tmp = __builtin_expect((long )(! (! ((skb->len < skb->data_len) != 0)) != 0),
                           0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (795), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->data += len;
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *skb_pull(struct sk_buff *skb ,
                                                                            unsigned int len ) 
{ long tmp ;
  unsigned char __attribute__((__always_inline__))  *tmp___0 ;
  unsigned char __attribute__((__always_inline__))  *tmp___1 ;
  long tmp___2 ;

  {
  tmp___2 = __builtin_expect((long )(! (! (len > skb->len)) != 0), 0L);
  if (tmp___2) {
    tmp___1 = (unsigned char __attribute__((__always_inline__))  *)((void *)0);
  } else {
    tmp___1 = __skb_pull(skb, len);
  }
  return (tmp___1);
}
}
extern unsigned char *__pskb_pull_tail(struct sk_buff *skb , int delta ) ;
__inline static unsigned char __attribute__((__always_inline__))  *__pskb_pull(struct sk_buff *skb ,
                                                                               unsigned int len ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned int __attribute__((__always_inline__))  tmp___0 ;
  unsigned char *tmp___1 ;

  {
  tmp = skb_headlen((struct sk_buff  const  *)skb);
  if (len > (unsigned int )tmp) {
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
    tmp___1 = __pskb_pull_tail(skb, (int )(len - (unsigned int )tmp___0));
    if (! tmp___1) {
      return ((unsigned char __attribute__((__always_inline__))  *)((void *)0));
    }
  }
  skb->len -= len;
  skb->data += len;
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *pskb_pull(struct sk_buff *skb ,
                                                                             unsigned int len ) 
{ long tmp ;
  unsigned char __attribute__((__always_inline__))  *tmp___0 ;
  unsigned char __attribute__((__always_inline__))  *tmp___1 ;
  long tmp___2 ;

  {
  tmp___2 = __builtin_expect((long )(! (! (len > skb->len)) != 0), 0L);
  if (tmp___2) {
    tmp___1 = (unsigned char __attribute__((__always_inline__))  *)((void *)0);
  } else {
    tmp___1 = __pskb_pull(skb, len);
  }
  return (tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  pskb_may_pull(struct sk_buff *skb ,
                                                                      unsigned int len ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned int __attribute__((__always_inline__))  tmp___3 ;
  unsigned char *tmp___4 ;

  {
  tmp = skb_headlen((struct sk_buff  const  *)skb);
  if (len <= (unsigned int )tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp___2 = __builtin_expect((long )(! (! (len > skb->len)) != 0), 0L);
  if (tmp___2) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___3 = skb_headlen((struct sk_buff  const  *)skb);
  tmp___4 = __pskb_pull_tail(skb, (int )(len - (unsigned int )tmp___3));
  return ((int __attribute__((__always_inline__))  )((unsigned int )tmp___4 != (unsigned int )((void *)0)));
}
}
__inline static int __attribute__((__always_inline__))  skb_headroom(struct sk_buff  const  *skb ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(skb->data - skb->head));
}
}
__inline static int __attribute__((__always_inline__))  skb_tailroom(struct sk_buff  const  *skb ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp___1 = skb_is_nonlinear(skb);
  if (tmp___1) {
    tmp___0 = 0;
  } else {
    tmp___0 = skb->end - skb->tail;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  skb_reserve(struct sk_buff *skb ,
                                                                     unsigned int len ) 
{ 

  {
  skb->data += len;
  skb->tail += len;
  return;
}
}
extern int ___pskb_trim(struct sk_buff *skb , unsigned int len , int realloc ) ;
__inline static void __attribute__((__always_inline__))  __skb_trim(struct sk_buff *skb ,
                                                                    unsigned int len ) 
{ 

  {
  if (! skb->data_len) {
    skb->len = len;
    skb->tail = skb->data + len;
  } else {
    ___pskb_trim(skb, len, 0);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  skb_trim(struct sk_buff *skb ,
                                                                  unsigned int len ) 
{ 

  {
  if (skb->len > len) {
    __skb_trim(skb, len);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  __pskb_trim(struct sk_buff *skb ,
                                                                    unsigned int len ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (! skb->data_len) {
    skb->len = len;
    skb->tail = skb->data + len;
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp = (int __attribute__((__always_inline__))  )___pskb_trim(skb, len, 1);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pskb_trim(struct sk_buff *skb ,
                                                                  unsigned int len ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  if (len < skb->len) {
    tmp___0 = __pskb_trim(skb, len);
  } else {
    tmp___0 = (int __attribute__((__always_inline__))  )0;
  }
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  skb_orphan(struct sk_buff *skb ) 
{ 

  {
  if (skb->destructor) {
    ((*(skb->destructor)))(skb);
  }
  skb->destructor = (void (*)(struct sk_buff *skb ))((void *)0);
  skb->sk = (struct sock *)((void *)0);
  return;
}
}
extern void skb_queue_purge(struct sk_buff_head *list ) ;
__inline static void __attribute__((__always_inline__))  __skb_queue_purge(struct sk_buff_head *list ) 
{ struct sk_buff *skb ;

  {
  while (1) {
    skb = (struct sk_buff *)__skb_dequeue(list);
    if (! ((unsigned int )skb != (unsigned int )((void *)0))) {
      break;
    }
    kfree_skb(skb);
  }
  return;
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *__dev_alloc_skb(unsigned int length ,
                                                                                    int gfp_mask ) 
{ struct sk_buff *skb ;
  struct sk_buff *tmp ;
  long tmp___0 ;

  {
  tmp = alloc_skb(length + 16U, gfp_mask);
  skb = tmp;
  tmp___0 = __builtin_expect((long )(! (! skb) != 0), 1L);
  if (tmp___0) {
    skb_reserve(skb, 16U);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *dev_alloc_skb(unsigned int length ) 
{ struct sk_buff  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = __dev_alloc_skb(length, 32);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  skb_cow(struct sk_buff *skb ,
                                                                unsigned int headroom ) 
{ int delta ;
  unsigned int tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;

  {
  if (headroom > 16U) {
    tmp = headroom;
  } else {
    tmp = 16U;
  }
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
  delta = (int )(tmp - (unsigned int )tmp___0);
  if (delta < 0) {
    delta = 0;
  }
  if (delta) {
    tmp___1 = (int __attribute__((__always_inline__))  )pskb_expand_head(skb, (delta +
                                                                               15) &
                                                                              -16,
                                                                         0, 32);
    return (tmp___1);
  } else {
    tmp___2 = skb_cloned((struct sk_buff  const  *)skb);
    if (tmp___2) {
      tmp___1 = (int __attribute__((__always_inline__))  )pskb_expand_head(skb, (delta +
                                                                                 15) &
                                                                                -16,
                                                                           0, 32);
      return (tmp___1);
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_padto(struct sk_buff *skb ,
                                                                              unsigned int len ) 
{ unsigned int size ;
  long tmp ;
  struct sk_buff  __attribute__((__always_inline__)) *tmp___0 ;

  {
  size = skb->len;
  tmp = __builtin_expect((long )(! (! (size >= len)) != 0), 1L);
  if (tmp) {
    return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
  }
  tmp___0 = (struct sk_buff  __attribute__((__always_inline__)) *)skb_pad(skb, (int )(len -
                                                                                      size));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  skb_add_data(struct sk_buff *skb ,
                                                                     char *from ,
                                                                     int copy ) 
{ int off ;
  int err ;
  unsigned int csum ;
  unsigned char __attribute__((__always_inline__))  *tmp ;
  unsigned int tmp___0 ;
  unsigned char __attribute__((__always_inline__))  *tmp___1 ;
  unsigned long tmp___2 ;

  {
  off = (int )skb->len;
  if ((int )skb->ip_summed == 0) {
    err = 0;
    tmp = skb_put(skb, (unsigned int )copy);
    tmp___0 = (unsigned int )csum_and_copy_from_user((unsigned char const   *)from,
                                                     (unsigned char *)tmp, copy, 0,
                                                     & err);
    csum = tmp___0;
    if (! err) {
      skb->csum = (unsigned int )csum_block_add(skb->csum, csum, off);
      return ((int __attribute__((__always_inline__))  )0);
    }
  } else {
    tmp___1 = skb_put(skb, (unsigned int )copy);
    tmp___2 = copy_from_user((void *)tmp___1, (void const   *)from, (unsigned long )copy);
    if (! tmp___2) {
      return ((int __attribute__((__always_inline__))  )0);
    }
  }
  __skb_trim(skb, (unsigned int )off);
  return ((int __attribute__((__always_inline__))  )-14);
}
}
__inline static int __attribute__((__always_inline__))  skb_can_coalesce(struct sk_buff *skb ,
                                                                         int i , struct page *page ,
                                                                         int off ) 
{ struct skb_frag_struct *frag ;
  int tmp ;

  {
  if (i) {
    frag = & ((struct skb_shared_info *)skb->end)->frags[i - 1];
    if ((unsigned int )page == (unsigned int )frag->page) {
      if (off == (int )frag->page_offset + (int )frag->size) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    return ((int __attribute__((__always_inline__))  )tmp);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int __skb_linearize(struct sk_buff *skb , int gfp ) ;
__inline static int __attribute__((__always_inline__))  skb_linearize(struct sk_buff *skb ,
                                                                      int gfp ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )__skb_linearize(skb, gfp);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  skb_postpull_rcsum(struct sk_buff *skb ,
                                                                            void const   *start ,
                                                                            int len ) 
{ unsigned int tmp ;

  {
  if ((int )skb->ip_summed == 1) {
    tmp = csum_partial((unsigned char const   *)start, len, 0U);
    skb->csum = (unsigned int )csum_sub(skb->csum, tmp);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  pskb_trim_rcsum(struct sk_buff *skb ,
                                                                        unsigned int len ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (len >= skb->len) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  if ((int )skb->ip_summed == 1) {
    skb->ip_summed = (unsigned char)0;
  }
  tmp = __pskb_trim(skb, len);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  *kmap_skb_frag(skb_frag_t const   *frag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___2 ;
  void __attribute__((__always_inline__))  *tmp___3 ;

  {
  while (1) {
    tmp = current_thread_info();
    if (((unsigned long )tmp->preempt_count & 268369920UL) != 0UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    if (tmp___1) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (1144), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___2 = current_thread_info();
      tmp___2->preempt_count = (int )((unsigned long )tmp___2->preempt_count + 256UL);
      break;
    }
    __asm__  volatile   ("": : : "memory");
    break;
  }
  tmp___3 = (void __attribute__((__always_inline__))  *)kmap_atomic((struct page *)frag->page,
                                                                    5);
  return (tmp___3);
}
}
__inline static void __attribute__((__always_inline__))  kunmap_skb_frag(void *vaddr ) 
{ 

  {
  kunmap_atomic(vaddr, 5);
  local_bh_enable();
  return;
}
}
extern struct sk_buff *skb_recv_datagram(struct sock *sk , unsigned int flags , int noblock ,
                                         int *err ) ;
extern unsigned int datagram_poll(struct file *file , struct socket *sock , struct poll_table_struct *wait ) ;
extern int skb_copy_datagram_iovec(struct sk_buff  const  *from , int offset , struct iovec *to ,
                                   int size ) ;
extern int skb_copy_and_csum_datagram_iovec(struct sk_buff  const  *skb , int hlen ,
                                            struct iovec *iov ) ;
extern void skb_free_datagram(struct sock *sk , struct sk_buff *skb ) ;
extern unsigned int skb_checksum(struct sk_buff  const  *skb , int offset , int len ,
                                 unsigned int csum ) ;
extern int skb_copy_bits(struct sk_buff  const  *skb , int offset , void *to , int len ) ;
extern int skb_store_bits(struct sk_buff  const  *skb , int offset , void *from ,
                          int len ) ;
extern unsigned int skb_copy_and_csum_bits(struct sk_buff  const  *skb , int offset ,
                                           u8 *to , int len , unsigned int csum ) ;
extern void skb_copy_and_csum_dev(struct sk_buff  const  *skb , u8 *to ) ;
extern void skb_split(struct sk_buff *skb , struct sk_buff *skb1 , u32 len ) ;
__inline static void __attribute__((__always_inline__))  *skb_header_pointer(struct sk_buff  const  *skb ,
                                                                             int offset ,
                                                                             int len ,
                                                                             void *buffer ) 
{ int hlen ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = (int )skb_headlen(skb);
  hlen = tmp;
  if (offset + len <= hlen) {
    return ((void __attribute__((__always_inline__))  *)(skb->data + offset));
  }
  tmp___0 = skb_copy_bits(skb, offset, buffer, len);
  if (tmp___0 < 0) {
    return ((void __attribute__((__always_inline__))  *)((void *)0));
  }
  return ((void __attribute__((__always_inline__))  *)buffer);
}
}
extern void skb_init(void) ;
extern void skb_add_mtu(int mtu ) ;
__inline static void __attribute__((__always_inline__))  nf_conntrack_put(struct nf_conntrack *nfct ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (nfct) {
    tmp = atomic_dec_and_test(& nfct->use);
    if (tmp) {
      ((*(nfct->destroy)))(nfct);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_conntrack_get(struct nf_conntrack *nfct ) 
{ 

  {
  if (nfct) {
    atomic_inc(& nfct->use);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_reset(struct sk_buff *skb ) 
{ 

  {
  nf_conntrack_put(skb->nfct);
  skb->nfct = (struct nf_conntrack *)((void *)0);
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_reset_debug(struct sk_buff *skb ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_bridge_put(struct nf_bridge_info *nf_bridge ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (nf_bridge) {
    tmp = atomic_dec_and_test(& nf_bridge->use);
    if (tmp) {
      kfree((void const   *)nf_bridge);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_bridge_get(struct nf_bridge_info *nf_bridge ) 
{ 

  {
  if (nf_bridge) {
    atomic_inc(& nf_bridge->use);
  }
  return;
}
}
__inline static struct ethhdr  __attribute__((__always_inline__)) *eth_hdr(struct sk_buff  const  *skb ) 
{ 

  {
  return ((struct ethhdr  __attribute__((__always_inline__)) *)((struct ethhdr *)skb->mac.raw));
}
}
extern int bus_register(struct bus_type *bus ) ;
extern void bus_unregister(struct bus_type *bus ) ;
extern int bus_rescan_devices(struct bus_type *bus ) ;
extern struct bus_type *get_bus(struct bus_type *bus ) ;
extern void put_bus(struct bus_type *bus ) ;
extern struct bus_type *find_bus(char *name ) ;
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device * , void * ) ) ;
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
extern int bus_create_file(struct bus_type * , struct bus_attribute * ) ;
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
extern int driver_register(struct device_driver *drv ) ;
extern void driver_unregister(struct device_driver *drv ) ;
extern struct device_driver *get_driver(struct device_driver *drv ) ;
extern void put_driver(struct device_driver *drv ) ;
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
extern int driver_create_file(struct device_driver * , struct driver_attribute * ) ;
extern void driver_remove_file(struct device_driver * , struct driver_attribute * ) ;
extern int class_register(struct class * ) ;
extern void class_unregister(struct class * ) ;
extern struct class *class_get(struct class * ) ;
extern void class_put(struct class * ) ;
extern int class_create_file(struct class * , struct class_attribute  const  * ) ;
extern void class_remove_file(struct class * , struct class_attribute  const  * ) ;
__inline static void __attribute__((__always_inline__))  *class_get_devdata(struct class_device *dev ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)dev->class_data);
}
}
__inline static void __attribute__((__always_inline__))  class_set_devdata(struct class_device *dev ,
                                                                           void *data ) 
{ 

  {
  dev->class_data = data;
  return;
}
}
extern int class_device_register(struct class_device * ) ;
extern void class_device_unregister(struct class_device * ) ;
extern void class_device_initialize(struct class_device * ) ;
extern int class_device_add(struct class_device * ) ;
extern void class_device_del(struct class_device * ) ;
extern int class_device_rename(struct class_device * , char * ) ;
extern struct class_device *class_device_get(struct class_device * ) ;
extern void class_device_put(struct class_device * ) ;
extern int class_device_create_file(struct class_device * , struct class_device_attribute  const  * ) ;
extern void class_device_remove_file(struct class_device * , struct class_device_attribute  const  * ) ;
extern int class_device_create_bin_file(struct class_device * , struct bin_attribute * ) ;
extern void class_device_remove_bin_file(struct class_device * , struct bin_attribute * ) ;
extern int class_interface_register(struct class_interface * ) ;
extern void class_interface_unregister(struct class_interface * ) ;
extern struct class_simple *class_simple_create(struct module *owner , char *name ) ;
extern void class_simple_destroy(struct class_simple *cs ) ;
extern struct class_device *( /* format attribute */  class_simple_device_add)(struct class_simple *cs ,
                                                                               dev_t dev ,
                                                                               struct device *device ,
                                                                               char const   *fmt 
                                                                               , ...) ;
extern int class_simple_set_hotplug(struct class_simple * , int (*hotplug)(struct class_device *dev ,
                                                                           char **envp ,
                                                                           int num_envp ,
                                                                           char *buffer ,
                                                                           int buffer_size ) ) ;
extern void class_simple_device_remove(dev_t dev ) ;
__inline static struct device  __attribute__((__always_inline__)) *list_to_dev(struct list_head *node ) 
{ struct list_head  const  *__mptr ;

  {
  __mptr = (struct list_head  const  *)node;
  return ((struct device  __attribute__((__always_inline__)) *)((struct device *)((char *)__mptr -
                                                                                  (unsigned int )(& ((struct device *)0)->node))));
}
}
__inline static void __attribute__((__always_inline__))  *dev_get_drvdata(struct device *dev ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)dev->driver_data);
}
}
__inline static void __attribute__((__always_inline__))  dev_set_drvdata(struct device *dev ,
                                                                         void *data ) 
{ 

  {
  dev->driver_data = data;
  return;
}
}
extern int device_register(struct device *dev ) ;
extern void device_unregister(struct device *dev ) ;
extern void device_initialize(struct device *dev ) ;
extern int device_add(struct device *dev ) ;
extern void device_del(struct device *dev ) ;
extern int device_for_each_child(struct device * , void * , int (*fn)(struct device * ,
                                                                      void * ) ) ;
extern int driver_probe_device(struct device_driver *drv , struct device *dev ) ;
extern void device_bind_driver(struct device *dev ) ;
extern void device_release_driver(struct device *dev ) ;
extern int device_attach(struct device *dev ) ;
extern void driver_attach(struct device_driver *drv ) ;
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
extern int (*platform_notify)(struct device *dev ) ;
extern int (*platform_notify_remove)(struct device *dev ) ;
extern struct device *get_device(struct device *dev ) ;
extern void put_device(struct device *dev ) ;
extern struct device *device_find(char const   *name , struct bus_type *bus ) ;
extern int platform_device_register(struct platform_device * ) ;
extern void platform_device_unregister(struct platform_device * ) ;
extern struct bus_type platform_bus_type ;
extern struct device platform_bus ;
extern struct resource *platform_get_resource(struct platform_device * , unsigned int  ,
                                              unsigned int  ) ;
extern int platform_get_irq(struct platform_device * , unsigned int  ) ;
extern struct resource *platform_get_resource_byname(struct platform_device * , unsigned int  ,
                                                     char * ) ;
extern int platform_get_irq_byname(struct platform_device * , char * ) ;
extern int platform_add_devices(struct platform_device ** , int  ) ;
extern struct platform_device *platform_device_register_simple(char * , unsigned int  ,
                                                               struct resource * ,
                                                               unsigned int  ) ;
extern void device_shutdown(void) ;
extern int firmware_register(struct subsystem * ) ;
extern void firmware_unregister(struct subsystem * ) ;
extern struct netif_rx_stats per_cpu__netdev_rx_stat ;
__inline static void __attribute__((__always_inline__))  *netdev_priv(struct net_device *dev ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((char *)dev + ((sizeof(struct net_device ) +
                                                                       31U) & 4294967264U)));
}
}
extern int notifier_chain_register(struct notifier_block **list , struct notifier_block *n ) ;
extern int notifier_chain_unregister(struct notifier_block **nl , struct notifier_block *n ) ;
extern int notifier_call_chain(struct notifier_block **n , unsigned long val , void *v ) ;
extern struct net_device loopback_dev ;
extern struct net_device *dev_base ;
extern rwlock_t dev_base_lock ;
extern int netdev_boot_setup_check(struct net_device *dev ) ;
extern unsigned long netdev_boot_base(char const   *prefix , int unit ) ;
extern struct net_device *dev_getbyhwaddr(unsigned short type , char *hwaddr ) ;
extern struct net_device *dev_getfirstbyhwtype(unsigned short type ) ;
extern void dev_add_pack(struct packet_type *pt ) ;
extern void dev_remove_pack(struct packet_type *pt ) ;
extern void __dev_remove_pack(struct packet_type *pt ) ;
extern struct net_device *dev_get_by_flags(unsigned short flags , unsigned short mask ) ;
extern struct net_device *dev_get_by_name(char const   *name ) ;
extern struct net_device *__dev_get_by_name(char const   *name ) ;
extern int dev_alloc_name(struct net_device *dev , char const   *name ) ;
extern int dev_open(struct net_device *dev ) ;
extern int dev_close(struct net_device *dev ) ;
extern int dev_queue_xmit(struct sk_buff *skb ) ;
extern int register_netdevice(struct net_device *dev ) ;
extern int unregister_netdevice(struct net_device *dev ) ;
extern void free_netdev(struct net_device *dev ) ;
extern void synchronize_net(void) ;
extern int register_netdevice_notifier(struct notifier_block *nb ) ;
extern int unregister_netdevice_notifier(struct notifier_block *nb ) ;
extern int call_netdevice_notifiers(unsigned long val , void *v ) ;
extern struct net_device *dev_get_by_index(int ifindex ) ;
extern struct net_device *__dev_get_by_index(int ifindex ) ;
extern int dev_restart(struct net_device *dev ) ;
extern int register_gifconf(unsigned int family , gifconf_func_t *gifconf ) ;
__inline static int __attribute__((__always_inline__))  unregister_gifconf(unsigned int family ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )register_gifconf(family, (gifconf_func_t *)((void *)0));
  return (tmp);
}
}
extern struct softnet_data per_cpu__softnet_data ;
__inline static void __attribute__((__always_inline__))  __netif_schedule(struct net_device *dev ) 
{ unsigned long flags ;
  struct softnet_data *sd ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = test_and_set_bit(3, (unsigned long volatile   *)(& dev->state));
  if (! tmp___0) {
    __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
    __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
    tmp = current_thread_info();
    sd = (struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]);
    dev->next_sched = sd->output_queue;
    sd->output_queue = dev;
    raise_softirq_irqoff(2U);
    while (1) {
      __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
      break;
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_schedule(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(0, (unsigned long const volatile   *)(& dev->state));
  if (! tmp) {
    __netif_schedule(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_start_queue(struct net_device *dev ) 
{ 

  {
  clear_bit(0, (unsigned long volatile   *)(& dev->state));
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_wake_queue(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_clear_bit(0, (unsigned long volatile   *)(& dev->state));
  if (tmp) {
    __netif_schedule(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_stop_queue(struct net_device *dev ) 
{ 

  {
  set_bit(0, (unsigned long volatile   *)(& dev->state));
  return;
}
}
__inline static int __attribute__((__always_inline__))  netif_queue_stopped(struct net_device  const  *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(0, (unsigned long const volatile   *)(& dev->state));
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  netif_running(struct net_device  const  *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(1, (unsigned long const volatile   *)(& dev->state));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  dev_kfree_skb_irq(struct sk_buff *skb ) 
{ struct softnet_data *sd ;
  unsigned long flags ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = atomic_dec_and_test(& skb->users);
  if (tmp___0) {
    __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
    __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
    tmp = current_thread_info();
    sd = (struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]);
    skb->next = sd->completion_queue;
    sd->completion_queue = skb;
    raise_softirq_irqoff(2U);
    while (1) {
      __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
      break;
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  dev_kfree_skb_any(struct sk_buff *skb ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  tmp = current_thread_info();
  if ((unsigned long )tmp->preempt_count & 268369920UL) {
    dev_kfree_skb_irq(skb);
  } else {
    while (1) {
      __asm__  volatile   ("pushfl ; popl %0": "=g" (flags));
      break;
    }
    if (! (flags & 512UL) != 0) {
      dev_kfree_skb_irq(skb);
    } else {
      kfree_skb(skb);
    }
  }
  return;
}
}
extern int netif_rx(struct sk_buff *skb ) ;
extern int netif_rx_ni(struct sk_buff *skb ) ;
extern int netif_receive_skb(struct sk_buff *skb ) ;
extern int dev_ioctl(unsigned int cmd , void * ) ;
extern int dev_ethtool(struct ifreq * ) ;
extern unsigned int dev_get_flags(struct net_device  const  * ) ;
extern int dev_change_flags(struct net_device * , unsigned int  ) ;
extern int dev_change_name(struct net_device * , char * ) ;
extern int dev_set_mtu(struct net_device * , int  ) ;
extern int dev_set_mac_address(struct net_device * , struct sockaddr * ) ;
extern void dev_queue_xmit_nit(struct sk_buff *skb , struct net_device *dev ) ;
extern void dev_init(void) ;
extern int netdev_nit ;
extern void netdev_run_todo(void) ;
__inline static void __attribute__((__always_inline__))  dev_put(struct net_device *dev ) 
{ 

  {
  atomic_dec(& dev->refcnt);
  return;
}
}
extern void linkwatch_fire_event(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  netif_carrier_ok(struct net_device  const  *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = constant_test_bit(4, (unsigned long const volatile   *)(& dev->state));
  if (tmp) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
extern void __netdev_watchdog_up(struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  netif_carrier_on(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_clear_bit(4, (unsigned long volatile   *)(& dev->state));
  if (tmp) {
    linkwatch_fire_event(dev);
  }
  tmp___0 = netif_running((struct net_device  const  *)dev);
  if (tmp___0) {
    __netdev_watchdog_up(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_carrier_off(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(4, (unsigned long volatile   *)(& dev->state));
  if (! tmp) {
    linkwatch_fire_event(dev);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  netif_device_present(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(2, (unsigned long const volatile   *)(& dev->state));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  netif_device_detach(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_clear_bit(2, (unsigned long volatile   *)(& dev->state));
  if (tmp) {
    tmp___0 = netif_running((struct net_device  const  *)dev);
    if (tmp___0) {
      netif_stop_queue(dev);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_device_attach(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_set_bit(2, (unsigned long volatile   *)(& dev->state));
  if (! tmp) {
    tmp___0 = netif_running((struct net_device  const  *)dev);
    if (tmp___0) {
      netif_wake_queue(dev);
      __netdev_watchdog_up(dev);
    }
  }
  return;
}
}
__inline static u32 __attribute__((__always_inline__))  netif_msg_init(int debug_value ,
                                                                       int default_msg_enable_bits ) 
{ 

  {
  if (debug_value < 0) {
    return ((unsigned int )default_msg_enable_bits);
  } else {
    if ((unsigned int )debug_value >= sizeof(u32 ) * 8U) {
      return ((unsigned int )default_msg_enable_bits);
    }
  }
  if (debug_value == 0) {
    return (0U);
  }
  return ((unsigned int )((1 << debug_value) - 1));
}
}
__inline static int __attribute__((__always_inline__))  netif_rx_schedule_prep(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = netif_running((struct net_device  const  *)dev);
  if (tmp) {
    tmp___0 = test_and_set_bit(5, (unsigned long volatile   *)(& dev->state));
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static void __attribute__((__always_inline__))  __netif_rx_schedule(struct net_device *dev ) 
{ unsigned long flags ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __ptr___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
  atomic_inc(& dev->refcnt);
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
  tmp = current_thread_info();
  list_add_tail(& dev->poll_list, & ((struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]))->poll_list);
  if (dev->quota < 0) {
    dev->quota += dev->weight;
  } else {
    dev->quota = dev->weight;
  }
  while (1) {
    __asm__  ("": "=g" (__ptr___0): "0" (& per_cpu__irq_stat));
    tmp___0 = current_thread_info();
    ((irq_cpustat_t *)(__ptr___0 + __per_cpu_offset[tmp___0->cpu]))->__softirq_pending = (unsigned int )((unsigned long )((irq_cpustat_t *)(__ptr___0 +
                                                                                                                                            __per_cpu_offset[tmp___0->cpu]))->__softirq_pending |
                                                                                                         8UL);
    break;
  }
  while (1) {
    __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
    break;
  }
}
}
__inline static void __attribute__((__always_inline__))  netif_rx_schedule(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = netif_rx_schedule_prep(dev);
  if (tmp) {
    __netif_rx_schedule(dev);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  netif_rx_reschedule(struct net_device *dev ,
                                                                            int undo ) 
{ unsigned long flags ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __ptr___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp___1 = netif_rx_schedule_prep(dev);
  if (tmp___1) {
    dev->quota += undo;
    __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
    __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
    tmp = current_thread_info();
    list_add_tail(& dev->poll_list, & ((struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]))->poll_list);
    while (1) {
      __asm__  ("": "=g" (__ptr___0): "0" (& per_cpu__irq_stat));
      tmp___0 = current_thread_info();
      ((irq_cpustat_t *)(__ptr___0 + __per_cpu_offset[tmp___0->cpu]))->__softirq_pending = (unsigned int )((unsigned long )((irq_cpustat_t *)(__ptr___0 +
                                                                                                                                              __per_cpu_offset[tmp___0->cpu]))->__softirq_pending |
                                                                                                           8UL);
      break;
    }
    while (1) {
      __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
      break;
    }
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  netif_rx_complete(struct net_device *dev ) 
{ unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
  while (1) {
    tmp = constant_test_bit(5, (unsigned long const volatile   *)(& dev->state));
    if (tmp) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1 != 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    if (tmp___3) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (860), "i" ("include/linux/netdevice.h"));
    }
    break;
  }
  list_del(& dev->poll_list);
  __asm__  volatile   ("": : : "memory");
  clear_bit(5, (unsigned long volatile   *)(& dev->state));
  while (1) {
    __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
    break;
  }
}
}
__inline static void __attribute__((__always_inline__))  netif_poll_disable(struct net_device *dev ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    tmp___0 = test_and_set_bit(5, (unsigned long volatile   *)(& dev->state));
    if (! tmp___0) {
      break;
    }
    tmp = get_current();
    tmp->state = (long volatile   )1;
    schedule_timeout(1L);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_poll_enable(struct net_device *dev ) 
{ 

  {
  clear_bit(5, (unsigned long volatile   *)(& dev->state));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __netif_rx_complete(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  while (1) {
    tmp = constant_test_bit(5, (unsigned long const volatile   *)(& dev->state));
    if (tmp) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1 != 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    if (tmp___3) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (886), "i" ("include/linux/netdevice.h"));
    }
    break;
  }
  list_del(& dev->poll_list);
  __asm__  volatile   ("": : : "memory");
  clear_bit(5, (unsigned long volatile   *)(& dev->state));
}
}
__inline static void __attribute__((__always_inline__))  netif_tx_disable(struct net_device *dev ) 
{ 

  {
  _spin_lock_bh(& dev->xmit_lock);
  netif_stop_queue(dev);
  _spin_unlock_bh(& dev->xmit_lock);
  return;
}
}
extern void ether_setup(struct net_device *dev ) ;
extern struct net_device *alloc_netdev(int sizeof_priv , char const   *name , void (*setup)(struct net_device * ) ) ;
extern int register_netdev(struct net_device *dev ) ;
extern void unregister_netdev(struct net_device *dev ) ;
extern void dev_mc_upload(struct net_device *dev ) ;
extern int dev_mc_delete(struct net_device *dev , void *addr , int alen , int all ) ;
extern int dev_mc_add(struct net_device *dev , void *addr , int alen , int newonly ) ;
extern void dev_mc_discard(struct net_device *dev ) ;
extern void dev_set_promiscuity(struct net_device *dev , int inc ) ;
extern void dev_set_allmulti(struct net_device *dev , int inc ) ;
extern void netdev_state_change(struct net_device *dev ) ;
extern void netdev_features_change(struct net_device *dev ) ;
extern void dev_load(char const   *name ) ;
extern void dev_mcast_init(void) ;
extern int netdev_max_backlog ;
extern int weight_p ;
extern int netdev_set_master(struct net_device *dev , struct net_device *master ) ;
extern int skb_checksum_help(struct sk_buff *skb , int inward ) ;
extern void net_enable_timestamp(void) ;
extern void net_disable_timestamp(void) ;
extern char *net_sysctl_strdup(char const   *s ) ;
extern void rand_initialize_irq(int irq ) ;
extern void add_input_randomness(unsigned int type , unsigned int code , unsigned int value ) ;
extern void add_interrupt_randomness(int irq ) ;
extern void get_random_bytes(void *buf , int nbytes ) ;
extern void generate_random_uuid(unsigned char *uuid_out ) ;
extern __u32 secure_ip_id(__u32 daddr ) ;
extern u32 secure_tcp_port_ephemeral(__u32 saddr , __u32 daddr , __u16 dport ) ;
extern u32 secure_tcpv6_port_ephemeral(__u32 const   *saddr , __u32 const   *daddr ,
                                       __u16 dport ) ;
extern __u32 secure_tcp_sequence_number(__u32 saddr , __u32 daddr , __u16 sport ,
                                        __u16 dport ) ;
extern __u32 secure_tcpv6_sequence_number(__u32 *saddr , __u32 *daddr , __u16 sport ,
                                          __u16 dport ) ;
extern unsigned int get_random_int(void) ;
extern unsigned long randomize_range(unsigned long start , unsigned long end , unsigned long len ) ;
extern int eth_header(struct sk_buff *skb , struct net_device *dev , unsigned short type ,
                      void *daddr , void *saddr , unsigned int len ) ;
extern int eth_rebuild_header(struct sk_buff *skb ) ;
extern unsigned short eth_type_trans(struct sk_buff *skb , struct net_device *dev ) ;
extern void eth_header_cache_update(struct hh_cache *hh , struct net_device *dev ,
                                    unsigned char *haddr ) ;
extern int eth_header_cache(struct neighbour *neigh , struct hh_cache *hh ) ;
extern struct net_device *alloc_etherdev(int sizeof_priv ) ;
__inline static void __attribute__((__always_inline__))  eth_copy_and_sum(struct sk_buff *dest ,
                                                                          unsigned char const   *src ,
                                                                          int len ,
                                                                          int base ) 
{ 

  {
  __memcpy((void *)dest->data, (void const   *)src, (unsigned int )len);
  return;
}
}
__inline static int __attribute__((__always_inline__))  is_zero_ether_addr(u8 const   *addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! ((((((int const   )(*(addr +
                                                                             0)) |
                                                            (int const   )(*(addr +
                                                                             1))) |
                                                           (int const   )(*(addr +
                                                                            2))) |
                                                          (int const   )(*(addr +
                                                                           3))) |
                                                         (int const   )(*(addr + 4))) |
                                                        (int const   )(*(addr + 5))) !=
                                                     0));
}
}
__inline static int __attribute__((__always_inline__))  is_multicast_ether_addr(u8 const   *addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((int const   )(*(addr + 0)) &
                                                     1));
}
}
__inline static int __attribute__((__always_inline__))  is_valid_ether_addr(u8 const   *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = is_multicast_ether_addr(addr);
  if (tmp) {
    tmp___1 = 0;
  } else {
    tmp___0 = is_zero_ether_addr(addr);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static void __attribute__((__always_inline__))  random_ether_addr(u8 *addr ) 
{ 

  {
  get_random_bytes((void *)addr, 6);
  (*(addr + 0)) = (unsigned char )((int )(*(addr + 0)) & 254);
  (*(addr + 0)) = (unsigned char )((int )(*(addr + 0)) | 2);
  return;
}
}
extern int dev_get_wireless_info(char *buffer , char **start , off_t offset , int length ) ;
extern int wireless_process_ioctl(struct ifreq *ifr , unsigned int cmd ) ;
extern void wireless_send_event(struct net_device *dev , unsigned int cmd , union iwreq_data *wrqu ,
                                char *extra ) ;
extern int iw_handler_set_spy(struct net_device *dev , struct iw_request_info *info ,
                              union iwreq_data *wrqu , char *extra ) ;
extern int iw_handler_get_spy(struct net_device *dev , struct iw_request_info *info ,
                              union iwreq_data *wrqu , char *extra ) ;
extern int iw_handler_set_thrspy(struct net_device *dev , struct iw_request_info *info ,
                                 union iwreq_data *wrqu , char *extra ) ;
extern int iw_handler_get_thrspy(struct net_device *dev , struct iw_request_info *info ,
                                 union iwreq_data *wrqu , char *extra ) ;
extern void wireless_spy_update(struct net_device *dev , unsigned char *address ,
                                struct iw_quality *wstats ) ;
__inline static char __attribute__((__always_inline__))  *iwe_stream_add_event(char *stream ,
                                                                               char *ends ,
                                                                               struct iw_event *iwe ,
                                                                               int event_len ) 
{ 

  {
  if ((unsigned int )(stream + event_len) < (unsigned int )ends) {
    iwe->len = (unsigned short )event_len;
    __memcpy((void *)stream, (void const   *)((char *)iwe), (unsigned int )event_len);
    stream += event_len;
  }
  return ((char __attribute__((__always_inline__))  *)stream);
}
}
__inline static char __attribute__((__always_inline__))  *iwe_stream_add_point(char *stream ,
                                                                               char *ends ,
                                                                               struct iw_event *iwe ,
                                                                               char *extra ) 
{ int event_len ;

  {
  event_len = (int )(((sizeof(struct iw_event ) - sizeof(union iwreq_data )) + sizeof(struct iw_point )) +
                     (unsigned int )iwe->u.data.length);
  if ((unsigned int )(stream + event_len) < (unsigned int )ends) {
    iwe->len = (unsigned short )event_len;
    __constant_memcpy((void *)stream, (void const   *)((char *)iwe), (sizeof(struct iw_event ) -
                                                                      sizeof(union iwreq_data )) +
                                                                     sizeof(struct iw_point ));
    __memcpy((void *)(stream + ((sizeof(struct iw_event ) - sizeof(union iwreq_data )) +
                                sizeof(struct iw_point ))), (void const   *)extra,
             (unsigned int )iwe->u.data.length);
    stream += event_len;
  }
  return ((char __attribute__((__always_inline__))  *)stream);
}
}
__inline static char __attribute__((__always_inline__))  *iwe_stream_add_value(char *event ,
                                                                               char *value ,
                                                                               char *ends ,
                                                                               struct iw_event *iwe ,
                                                                               int event_len ) 
{ 

  {
  event_len = (int )((unsigned int )event_len - (sizeof(struct iw_event ) - sizeof(union iwreq_data )));
  if ((unsigned int )(value + event_len) < (unsigned int )ends) {
    __memcpy((void *)value, (void const   *)((char *)iwe + (sizeof(struct iw_event ) -
                                                            sizeof(union iwreq_data ))),
             (unsigned int )event_len);
    value += event_len;
    iwe->len = (unsigned short )(value - event);
    __constant_memcpy((void *)event, (void const   *)((char *)iwe), sizeof(struct iw_event ) -
                                                                    sizeof(union iwreq_data ));
  }
  return ((char __attribute__((__always_inline__))  *)value);
}
}
static char const   MAC_ADDRESSES[4][3]  = { {        (char const   )8,        (char const   )0,        (char const   )14}, 
   {        (char const   )8,        (char const   )0,        (char const   )106}, 
   {        (char const   )0,        (char const   )0,        (char const   )225}, 
   {        (char const   )0,        (char const   )96,        (char const   )29}};
static short const   channel_bands[10]  = 
  {      (short const   )48,      (short const   )88,      (short const   )100,      (short const   )122, 
        (short const   )128,      (short const   )168,      (short const   )208,      (short const   )240, 
        (short const   )248,      (short const   )336};
static int const   fixed_bands[5]  = {      (int const   )915e6,      (int const   )2.425e8,      (int const   )2.46e8,      (int const   )2.484e8, 
        (int const   )2.4305e8};
static unsigned char wv_irq_to_psa(int irq___0 ) ;
static int wv_psa_to_irq(unsigned char irqval )  __attribute__((__section__(".init.text"))) ;
__inline static unsigned short __attribute__((__always_inline__))  hasr_read(unsigned long ioaddr ) ;
__inline static void __attribute__((__always_inline__))  hacr_write(unsigned long ioaddr ,
                                                                    unsigned short hacr ) ;
__inline static void __attribute__((__always_inline__))  hacr_write_slow(unsigned long ioaddr ,
                                                                         unsigned short hacr ) ;
__inline static void __attribute__((__always_inline__))  set_chan_attn(unsigned long ioaddr ,
                                                                       unsigned short hacr ) ;
__inline static void __attribute__((__always_inline__))  wv_hacr_reset(unsigned long ioaddr ) ;
__inline static void __attribute__((__always_inline__))  wv_16_off(unsigned long ioaddr ,
                                                                   unsigned short hacr ) ;
__inline static void __attribute__((__always_inline__))  wv_16_on(unsigned long ioaddr ,
                                                                  unsigned short hacr ) ;
__inline static void __attribute__((__always_inline__))  wv_ints_off(struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  wv_ints_on(struct net_device *dev ) ;
static void psa_read(unsigned long ioaddr , unsigned short hacr , int o , unsigned char *b ,
                     int n ) ;
static void psa_write(unsigned long ioaddr , unsigned short hacr , int o , unsigned char *b ,
                      int n ) ;
__inline static void __attribute__((__always_inline__))  mmc_out(unsigned long ioaddr ,
                                                                 unsigned short o ,
                                                                 unsigned char d ) ;
__inline static void __attribute__((__always_inline__))  mmc_write(unsigned long ioaddr ,
                                                                   unsigned char o ,
                                                                   unsigned char *b ,
                                                                   int n ) ;
__inline static unsigned char __attribute__((__always_inline__))  mmc_in(unsigned long ioaddr ,
                                                                         unsigned short o ) ;
__inline static void __attribute__((__always_inline__))  mmc_read(unsigned long ioaddr ,
                                                                  unsigned char o ,
                                                                  unsigned char *b ,
                                                                  int n ) ;
__inline static void __attribute__((__always_inline__))  fee_wait(unsigned long ioaddr ,
                                                                  int delay , int number ) ;
static void fee_read(unsigned long ioaddr , unsigned short o , unsigned short *b ,
                     int n ) ;
static void obram_read(unsigned long ioaddr , unsigned short o , unsigned char *b ,
                       int n ) ;
__inline static void __attribute__((__always_inline__))  obram_write(unsigned long ioaddr ,
                                                                     unsigned short o ,
                                                                     unsigned char *b ,
                                                                     int n ) ;
static void wv_ack(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  wv_synchronous_cmd(struct net_device *dev ,
                                                                           char const   *str ) ;
__inline static int __attribute__((__always_inline__))  wv_config_complete(struct net_device *dev ,
                                                                           unsigned long ioaddr ,
                                                                           net_local *lp ) ;
static int wv_complete(struct net_device *dev , unsigned long ioaddr , net_local *lp ) ;
__inline static void __attribute__((__always_inline__))  wv_82586_reconfig(struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  wv_init_info(struct net_device *dev ) ;
static en_stats *wavelan_get_stats(struct net_device *dev ) ;
static iw_stats *wavelan_get_wireless_stats(struct net_device *dev ) ;
static void wavelan_set_multicast_list(struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  wv_packet_read(struct net_device *dev ,
                                                                        unsigned short buf_off ,
                                                                        int sksize ) ;
__inline static void __attribute__((__always_inline__))  wv_receive(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  wv_packet_write(struct net_device *dev ,
                                                                        void *buf ,
                                                                        short length ) ;
static int wavelan_packet_xmit(struct sk_buff *skb , struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  wv_mmc_init(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  wv_ru_start(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  wv_cu_start(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  wv_82586_start(struct net_device *dev ) ;
static void wv_82586_config(struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  wv_82586_stop(struct net_device *dev ) ;
static int wv_hw_reset(struct net_device *dev ) ;
static int wv_check_ioaddr(unsigned long ioaddr , unsigned char *mac ) ;
static irqreturn_t wavelan_interrupt(int irq___0 , void *dev_id , struct pt_regs *regs ) ;
static void wavelan_watchdog(struct net_device *dev ) ;
static int wavelan_open(struct net_device *dev ) ;
static int wavelan_close(struct net_device *dev ) ;
static int wavelan_config(struct net_device *dev , unsigned short ioaddr )  __attribute__((__section__(".init.text"))) ;
struct net_device *wavelan_probe(int unit )  __attribute__((__section__(".init.text"))) ;
static net_local *wavelan_list  =    (net_local *)((void *)0);
static u_char irqvals[16]  = 
  {      (u_char )0,      (u_char )0,      (u_char )0,      (u_char )1, 
        (u_char )2,      (u_char )4,      (u_char )0,      (u_char )8, 
        (u_char )0,      (u_char )0,      (u_char )16,      (u_char )32, 
        (u_char )64,      (u_char )0,      (u_char )0,      (u_char )128};
static unsigned short iobase[2]  = {      (unsigned short)912,      (unsigned short)992};
static int io[4]  ;
static int irq[4]  ;
static char *name[4]  ;
static struct kparam_array __param_arr_io  =    {sizeof(io) / sizeof(io[0]), (unsigned int *)((void *)0), & param_set_int, & param_get_int,
    sizeof(io[0]), (void *)(io)};
static char __param_str_io[3]  = {      (char )'i',      (char )'o',      (char )'\000'};
static struct kernel_param  const  __param_io  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_io), 0U, & param_array_set, & param_array_get, (void *)(& __param_arr_io)};
static char const   __mod_iotype707[25]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'o',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static struct kparam_array __param_arr_irq  =    {sizeof(irq) / sizeof(irq[0]), (unsigned int *)((void *)0), & param_set_int, & param_get_int,
    sizeof(irq[0]), (void *)(irq)};
static char __param_str_irq[4]  = {      (char )'i',      (char )'r',      (char )'q',      (char )'\000'};
static struct kernel_param  const  __param_irq  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_irq), 0U, & param_array_set, & param_array_get, (void *)(& __param_arr_irq)};
static char const   __mod_irqtype708[26]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'r',      (char const   )'q', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
static struct kparam_array __param_arr_name  =    {sizeof(name) / sizeof(name[0]), (unsigned int *)((void *)0), & param_set_charp,
    & param_get_charp, sizeof(name[0]), (void *)(name)};
static char __param_str_name[5]  = {      (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'\000'};
static struct kernel_param  const  __param_name  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_name), 0U, & param_array_set, & param_array_get,
    (void *)(& __param_arr_name)};
static char const   __mod_nametype709[29]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'n',      (char const   )'a',      (char const   )'m', 
        (char const   )'e',      (char const   )':',      (char const   )'a',      (char const   )'r', 
        (char const   )'r',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'p', 
        (char const   )'\000'};
static char const   __mod_io711[46]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'o',      (char const   )':', 
        (char const   )'W',      (char const   )'a',      (char const   )'v',      (char const   )'e', 
        (char const   )'L',      (char const   )'A',      (char const   )'N',      (char const   )' ', 
        (char const   )'I',      (char const   )'/',      (char const   )'O',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'(',      (char const   )'e',      (char const   )'s',      (char const   )')', 
        (char const   )',',      (char const   )'r',      (char const   )'e',      (char const   )'q', 
        (char const   )'u',      (char const   )'i',      (char const   )'r',      (char const   )'e', 
        (char const   )'d',      (char const   )'\000'};
static char const   __mod_irq712[31]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'r',      (char const   )'q', 
        (char const   )':',      (char const   )'W',      (char const   )'a',      (char const   )'v', 
        (char const   )'e',      (char const   )'L',      (char const   )'A',      (char const   )'N', 
        (char const   )' ',      (char const   )'I',      (char const   )'R',      (char const   )'Q', 
        (char const   )' ',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )'(', 
        (char const   )'s',      (char const   )')',      (char const   )'\000'};
static char const   __mod_name713[36]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'n',      (char const   )'a',      (char const   )'m', 
        (char const   )'e',      (char const   )':',      (char const   )'W',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )'L',      (char const   )'A', 
        (char const   )'N',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'f', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'m',      (char const   )'e', 
        (char const   )'(',      (char const   )'s',      (char const   )')',      (char const   )'\000'};
static unsigned char wv_irq_to_psa(int irq___0 ) 
{ 

  {
  if (irq___0 < 0) {
    return ((unsigned char)0);
  } else {
    if ((unsigned int )irq___0 >= sizeof(irqvals) / sizeof(irqvals[0])) {
      return ((unsigned char)0);
    }
  }
  return (irqvals[irq___0]);
}
}
static int wv_psa_to_irq(unsigned char irqval )  __attribute__((__section__(".init.text"))) ;
static int wv_psa_to_irq(unsigned char irqval ) 
{ int irq___0 ;

  {
  irq___0 = 0;
  while ((unsigned int )irq___0 < sizeof(irqvals) / sizeof(irqvals[0])) {
    if ((int )irqvals[irq___0] == (int )irqval) {
      return (irq___0);
    }
    irq___0 ++;
  }
  return (-1);
}
}
__inline static unsigned short __attribute__((__always_inline__))  hasr_read(unsigned long ioaddr ) 
{ unsigned short __attribute__((__always_inline__))  tmp ;

  {
  tmp = inw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_cs.hu_status) -
                                     (void *)0)));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  hacr_write(unsigned long ioaddr ,
                                                                    unsigned short hacr ) 
{ 

  {
  outw(hacr, (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_cs.hu_command) -
                                      (void *)0)));
  return;
}
}
__inline static void __attribute__((__always_inline__))  hacr_write_slow(unsigned long ioaddr ,
                                                                         unsigned short hacr ) 
{ unsigned long __ms ;
  unsigned long tmp ;

  {
  hacr_write(ioaddr, hacr);
  __const_udelay(4295000UL);
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_chan_attn(unsigned long ioaddr ,
                                                                       unsigned short hacr ) 
{ 

  {
  hacr_write(ioaddr, (unsigned short )((int )hacr | 2));
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_hacr_reset(unsigned long ioaddr ) 
{ 

  {
  hacr_write_slow(ioaddr, (unsigned short)1);
  hacr_write(ioaddr, (unsigned short)53276);
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_16_off(unsigned long ioaddr ,
                                                                   unsigned short hacr ) 
{ 

  {
  hacr = (unsigned short )((int )hacr & -5);
  hacr_write(ioaddr, hacr);
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_16_on(unsigned long ioaddr ,
                                                                  unsigned short hacr ) 
{ 

  {
  hacr = (unsigned short )((int )hacr | 4);
  hacr_write(ioaddr, hacr);
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_ints_off(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  lp->hacr = (unsigned short )((int )lp->hacr & -225);
  hacr_write(ioaddr, lp->hacr);
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_ints_on(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  lp->hacr = (unsigned short )((int )lp->hacr | 224);
  hacr_write(ioaddr, lp->hacr);
  return;
}
}
static void psa_read(unsigned long ioaddr , unsigned short hacr , int o , unsigned char *b ,
                     int n ) 
{ unsigned char *tmp ;
  int tmp___0 ;

  {
  wv_16_off(ioaddr, hacr);
  while (1) {
    tmp___0 = n;
    n --;
    if (! (tmp___0 > 0)) {
      break;
    }
    outw((unsigned short )o, (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 +
                                                                           ioaddr))->ha_pior2) -
                                                      (void *)0)));
    o ++;
    tmp = b;
    b ++;
    (*tmp) = (unsigned char )inb((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 +
                                                                               ioaddr))->ha_piop2) -
                                                          (void *)0)));
  }
  wv_16_on(ioaddr, hacr);
  return;
}
}
static void psa_write(unsigned long ioaddr , unsigned short hacr , int o , unsigned char *b ,
                      int n ) 
{ int count ;
  unsigned long __ms ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned short __attribute__((__always_inline__))  tmp___1 ;
  int tmp___2 ;

  {
  count = 0;
  wv_16_off(ioaddr, hacr);
  while (1) {
    tmp___2 = n;
    n --;
    if (! (tmp___2 > 0)) {
      break;
    }
    outw((unsigned short )o, (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 +
                                                                           ioaddr))->ha_pior2) -
                                                      (void *)0)));
    o ++;
    outb((*b), (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_piop2) -
                                        (void *)0)));
    b ++;
    count = 0;
    while (1) {
      tmp___0 = count;
      count ++;
      if (tmp___0 < 100) {
        tmp___1 = hasr_read(ioaddr);
        if (! ((int __attribute__((__always_inline__))  )tmp___1 & 8)) {
          break;
        }
      } else {
        break;
      }
      __const_udelay(4295000UL);
    }
  }
  wv_16_on(ioaddr, hacr);
  return;
}
}
static void update_psa_checksum(struct net_device *dev , unsigned long ioaddr , u16 hacr ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  mmc_out(unsigned long ioaddr ,
                                                                 unsigned short o ,
                                                                 unsigned char d ) 
{ int count ;
  int tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;

  {
  count = 0;
  while (1) {
    tmp = count;
    count ++;
    if (tmp < 100) {
      tmp___0 = inw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_cs.hu_status) -
                                             (void *)0)));
      if (! ((int __attribute__((__always_inline__))  )tmp___0 & 4)) {
        break;
      }
    } else {
      break;
    }
    __const_udelay(42950UL);
  }
  outw((unsigned short )((((int )((unsigned short )d) << 8) | ((int )o << 1)) | 1),
       (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_mmcr) -
                                (void *)0)));
  return;
}
}
__inline static void __attribute__((__always_inline__))  mmc_write(unsigned long ioaddr ,
                                                                   unsigned char o ,
                                                                   unsigned char *b ,
                                                                   int n ) 
{ int tmp ;

  {
  o = (unsigned char )((int )o + n);
  b += n;
  while (1) {
    tmp = n;
    n --;
    if (! (tmp > 0)) {
      break;
    }
    b --;
    o = (unsigned char )((int )o - 1);
    mmc_out(ioaddr, (unsigned short )o, (*b));
  }
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  mmc_in(unsigned long ioaddr ,
                                                                         unsigned short o ) 
{ int count ;
  int tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  unsigned short __attribute__((__always_inline__))  tmp___2 ;
  unsigned short __attribute__((__always_inline__))  tmp___3 ;

  {
  count = 0;
  while (1) {
    tmp = count;
    count ++;
    if (tmp < 100) {
      tmp___0 = inw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_cs.hu_status) -
                                             (void *)0)));
      if (! ((int __attribute__((__always_inline__))  )tmp___0 & 4)) {
        break;
      }
    } else {
      break;
    }
    __const_udelay(42950UL);
  }
  outw((unsigned short )((int )o << 1), (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 +
                                                                                      ioaddr))->ha_mmcr) -
                                                                 (void *)0)));
  while (1) {
    tmp___1 = count;
    count ++;
    if (tmp___1 < 100) {
      tmp___2 = inw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_cs.hu_status) -
                                             (void *)0)));
      if (! ((int __attribute__((__always_inline__))  )tmp___2 & 4)) {
        break;
      }
    } else {
      break;
    }
    __const_udelay(42950UL);
  }
  tmp___3 = inw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_mmcr) -
                                         (void *)0)));
  return ((unsigned char __attribute__((__always_inline__))  )((unsigned char )((int __attribute__((__always_inline__))  )tmp___3 >>
                                                                                8)));
}
}
__inline static void __attribute__((__always_inline__))  mmc_read(unsigned long ioaddr ,
                                                                  unsigned char o ,
                                                                  unsigned char *b ,
                                                                  int n ) 
{ int tmp ;

  {
  o = (unsigned char )((int )o + n);
  b += n;
  while (1) {
    tmp = n;
    n --;
    if (! (tmp > 0)) {
      break;
    }
    b --;
    o = (unsigned char )((int )o - 1);
    (*b) = (unsigned char )mmc_in(ioaddr, (unsigned short )o);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  mmc_encr(unsigned long ioaddr ) 
{ int temp ;

  {
  temp = (int )mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                      0))->mmr_des_avail) -
                                                (void *)0));
  if (temp != 85) {
    if (temp != 51) {
      return ((int __attribute__((__always_inline__))  )0);
    } else {
      return ((int __attribute__((__always_inline__))  )temp);
    }
  } else {
    return ((int __attribute__((__always_inline__))  )temp);
  }
}
}
__inline static void __attribute__((__always_inline__))  fee_wait(unsigned long ioaddr ,
                                                                  int delay , int number ) 
{ int count ;
  int tmp ;
  unsigned char __attribute__((__always_inline__))  tmp___0 ;

  {
  count = 0;
  while (1) {
    tmp = count;
    count ++;
    if (tmp < number) {
      tmp___0 = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                       0))->mmr_fee_status) -
                                                 (void *)0));
      if (! ((int __attribute__((__always_inline__))  )tmp___0 & 4)) {
        break;
      }
    } else {
      break;
    }
    __udelay((unsigned long )delay);
  }
  return;
}
}
static void fee_read(unsigned long ioaddr , unsigned short o , unsigned short *b ,
                     int n ) 
{ unsigned char __attribute__((__always_inline__))  tmp ;
  unsigned char __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  b += n;
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_addr) -
                                    (void *)0), (unsigned char )(((int )o + n) - 1));
  while (1) {
    tmp___1 = n;
    n --;
    if (! (tmp___1 > 0)) {
      break;
    }
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_ctrl) -
                                      (void *)0), (unsigned char)6);
    fee_wait(ioaddr, 10, 100);
    b --;
    tmp = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 + 0))->mmr_fee_data_h) -
                                           (void *)0));
    tmp___0 = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 + 0))->mmr_fee_data_l) -
                                               (void *)0));
    (*b) = (unsigned short )(((int __attribute__((__always_inline__))  )tmp << 8) |
                             (int __attribute__((__always_inline__))  )tmp___0);
  }
  return;
}
}
static void fee_write(unsigned long ioaddr , u16 o , u16 *b , int n ) 
{ unsigned long __ms ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  b += n;
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_addr) -
                                    (void *)0), (unsigned char)192);
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_ctrl) -
                                    (void *)0), (unsigned char)4);
  fee_wait(ioaddr, 10, 100);
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_addr) -
                                    (void *)0), (unsigned char )(((int )o + n) - 1));
  while (1) {
    tmp___0 = n;
    n --;
    if (! (tmp___0 > 0)) {
      break;
    }
    b --;
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_data_h) -
                                      (void *)0), (unsigned char )((int )(*b) >> 8));
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_data_l) -
                                      (void *)0), (unsigned char )((int )(*b) & 255));
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_ctrl) -
                                      (void *)0), (unsigned char)5);
    __ms = 10UL;
    while (1) {
      tmp = __ms;
      __ms --;
      if (! tmp) {
        break;
      }
      __const_udelay(4295000UL);
    }
    fee_wait(ioaddr, 10, 100);
  }
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_addr) -
                                    (void *)0), (unsigned char)0);
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_ctrl) -
                                    (void *)0), (unsigned char)4);
  fee_wait(ioaddr, 10, 100);
  return;
}
}
static void obram_read(unsigned long ioaddr , unsigned short o , unsigned char *b ,
                       int n ) 
{ 

  {
  outw(o, (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_pior1) -
                                   (void *)0)));
  insw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_piop1) -
                                (void *)0)), (void *)((unsigned short *)b), (unsigned long )((n +
                                                                                              1) >>
                                                                                             1));
  return;
}
}
__inline static void __attribute__((__always_inline__))  obram_write(unsigned long ioaddr ,
                                                                     unsigned short o ,
                                                                     unsigned char *b ,
                                                                     int n ) 
{ 

  {
  outw(o, (int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_pior1) -
                                   (void *)0)));
  outsw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_piop1) -
                                 (void *)0)), (void const   *)((unsigned short *)b),
        (unsigned long )((n + 1) >> 1));
  return;
}
}
static void wv_ack(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  u16 scb_cs ;
  int i ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  obram_read(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                            sizeof(scp_t )) -
                                                                           sizeof(iscp_t )) -
                                                                          sizeof(scb_t ))))->scb_status) -
                                       (void *)0), (unsigned char *)(& scb_cs), (int )sizeof(scb_cs));
  scb_cs = (unsigned short )((int )scb_cs & 61440);
  if ((int )scb_cs == 0) {
    return;
  }
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_command) -
                                        (void *)0), (unsigned char *)(& scb_cs), (int )sizeof(scb_cs));
  set_chan_attn(ioaddr, lp->hacr);
  i = 1000;
  while (i > 0) {
    obram_read(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                              sizeof(scp_t )) -
                                                                             sizeof(iscp_t )) -
                                                                            sizeof(scb_t ))))->scb_command) -
                                         (void *)0), (unsigned char *)(& scb_cs),
               (int )sizeof(scb_cs));
    if ((int )scb_cs == 0) {
      break;
    }
    __const_udelay(42950UL);
    i --;
  }
  __const_udelay(429500UL);
  if (i <= 0) {
    printk("<6>%s: wv_ack(): board not accepting command.\n", dev->name);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  wv_synchronous_cmd(struct net_device *dev ,
                                                                           char const   *str ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  u16 scb_cmd ;
  ach_t cb ;
  int i ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  scb_cmd = (unsigned short)256;
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_command) -
                                        (void *)0), (unsigned char *)(& scb_cmd),
              (int )sizeof(scb_cmd));
  set_chan_attn(ioaddr, lp->hacr);
  i = 1000;
  while (i > 0) {
    obram_read(ioaddr, (unsigned short)49152, (unsigned char *)(& cb), (int )sizeof(cb));
    if ((int )cb.ac_status & 32768) {
      break;
    }
    __const_udelay(42950UL);
    i --;
  }
  __const_udelay(429500UL);
  if (i <= 0) {
    printk("<6>%s: %s failed; status = 0x%x\n", dev->name, str, cb.ac_status);
    return ((int __attribute__((__always_inline__))  )-1);
  } else {
    if (! ((int )cb.ac_status & 8192)) {
      printk("<6>%s: %s failed; status = 0x%x\n", dev->name, str, cb.ac_status);
      return ((int __attribute__((__always_inline__))  )-1);
    }
  }
  wv_ack(dev);
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  wv_config_complete(struct net_device *dev ,
                                                                           unsigned long ioaddr ,
                                                                           net_local *lp ) 
{ unsigned short mcs_addr ;
  unsigned short status ;
  int ret ;
  unsigned short cfg_addr ;
  unsigned short ias_addr ;

  {
  mcs_addr = (unsigned short )((((((unsigned int )lp->tx_first_in_use + sizeof(ac_tx_t )) +
                                  sizeof(ac_nop_t )) + sizeof(tbd_t )) + sizeof(ac_cfg_t )) +
                               sizeof(ac_ias_t ));
  obram_read(ioaddr, (unsigned short )((void *)(& ((ach_t *)((void *)0 + (int )mcs_addr))->ac_status) -
                                       (void *)0), (unsigned char *)(& status), (int )sizeof(status));
  if (((int )status & 32768) == 0) {
    ret = 0;
  } else {
    if (((int )status & 8192) != 8192) {
      printk("<6>%s: wv_config_complete(): set_multicast_address failed; status = 0x%x\n",
             dev->name, status);
    }
    ias_addr = (unsigned short )((unsigned int )mcs_addr - sizeof(ac_ias_t ));
    obram_read(ioaddr, (unsigned short )((void *)(& ((ach_t *)((void *)0 + (int )ias_addr))->ac_status) -
                                         (void *)0), (unsigned char *)(& status),
               (int )sizeof(status));
    if (((int )status & 8192) != 8192) {
      printk("<6>%s: wv_config_complete(): set_MAC_address failed; status = 0x%x\n",
             dev->name, status);
    }
    cfg_addr = (unsigned short )((unsigned int )ias_addr - sizeof(ac_cfg_t ));
    obram_read(ioaddr, (unsigned short )((void *)(& ((ach_t *)((void *)0 + (int )cfg_addr))->ac_status) -
                                         (void *)0), (unsigned char *)(& status),
               (int )sizeof(status));
    if (((int )status & 8192) != 8192) {
      printk("<6>%s: wv_config_complete(): configure failed; status = 0x%x\n", dev->name,
             status);
    }
    ret = 1;
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
static int wv_complete(struct net_device *dev , unsigned long ioaddr , net_local *lp ) 
{ int nreaped ;
  unsigned short tx_status ;
  int __attribute__((__always_inline__))  tmp ;
  int ncollisions ;

  {
  nreaped = 0;
  while ((int )lp->tx_first_in_use != 65535) {
    obram_read(ioaddr, (unsigned short )((void *)(& ((ach_t *)((void *)0 + (int )lp->tx_first_in_use))->ac_status) -
                                         (void *)0), (unsigned char *)(& tx_status),
               (int )sizeof(tx_status));
    if (((int )tx_status & 32768) == 0) {
      break;
    }
    if ((int )tx_status == 65535) {
      tmp = wv_config_complete(dev, ioaddr, lp);
      if (! tmp) {
        break;
      }
    }
    nreaped ++;
    lp->tx_n_in_use --;
    if (lp->tx_n_in_use <= 0) {
      lp->tx_first_in_use = (unsigned short)65535;
    } else {
      lp->tx_first_in_use = (unsigned short )((unsigned int )lp->tx_first_in_use +
                                              (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                                sizeof(tbd_t )) + 1514U));
      if ((unsigned int )lp->tx_first_in_use >= 49152U + (((((65536U - sizeof(scp_t )) -
                                                             sizeof(iscp_t )) - sizeof(scb_t )) -
                                                           49152U) / (((sizeof(ac_tx_t ) +
                                                                        sizeof(ac_nop_t )) +
                                                                       sizeof(tbd_t )) +
                                                                      1514U)) * (((sizeof(ac_tx_t ) +
                                                                                   sizeof(ac_nop_t )) +
                                                                                  sizeof(tbd_t )) +
                                                                                 1514U)) {
        lp->tx_first_in_use = (unsigned short )((unsigned int )lp->tx_first_in_use -
                                                (((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                                   sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                                  sizeof(ac_nop_t )) +
                                                                                 sizeof(tbd_t )) +
                                                                                1514U)) *
                                                (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                                  sizeof(tbd_t )) + 1514U));
      }
    }
    if ((int )tx_status == 65535) {
      continue;
    }
    if ((int )tx_status & 8192) {
      lp->stats.tx_packets ++;
      ncollisions = (int )tx_status & 15;
      lp->stats.collisions += (unsigned long )ncollisions;
    } else {
      lp->stats.tx_errors ++;
      if ((int )tx_status & 1024) {
        lp->stats.tx_carrier_errors ++;
      }
      if ((int )tx_status & 512) {
        lp->stats.tx_carrier_errors ++;
      }
      if ((int )tx_status & 256) {
        lp->stats.tx_fifo_errors ++;
      }
      if ((int )tx_status & 64) {
        lp->stats.tx_heartbeat_errors ++;
      }
      if ((int )tx_status & 32) {
        lp->stats.tx_aborted_errors ++;
      }
    }
  }
  if ((unsigned int )lp->tx_n_in_use < ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                         sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                        sizeof(ac_nop_t )) +
                                                                       sizeof(tbd_t )) +
                                                                      1514U) - 1U) {
    netif_wake_queue(dev);
  }
  return (nreaped);
}
}
__inline static void __attribute__((__always_inline__))  wv_82586_reconfig(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  lp = (net_local *)dev->priv;
  lp->reconfig_82586 = (unsigned char)1;
  tmp = netif_running((struct net_device  const  *)dev);
  if (tmp) {
    tmp___0 = netif_queue_stopped((struct net_device  const  *)dev);
    if (! tmp___0) {
      flags = _spin_lock_irqsave(& lp->spinlock);
      wv_82586_config(dev);
      _spin_unlock_irqrestore(& lp->spinlock, flags);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_init_info(struct net_device *dev ) 
{ short ioaddr ;
  net_local *lp ;
  psa_t psa ;
  int i ;
  char const   *tmp ;
  unsigned short freq ;
  unsigned char __attribute__((__always_inline__))  tmp___0 ;

  {
  ioaddr = (short )dev->base_addr;
  lp = (net_local *)dev->priv;
  psa_read((unsigned long )ioaddr, lp->hacr, 0, (unsigned char *)(& psa), (int )sizeof(psa));
  printk("<5>%s: WaveLAN at %#x,", dev->name, ioaddr);
  i = 0;
  while (i < 6) {
    if (i == 0) {
      tmp = " ";
    } else {
      tmp = ":";
    }
    printk("%s%02X", tmp, dev->dev_addr[i]);
    i ++;
  }
  printk(", IRQ %d", dev->irq);
  if (psa.psa_nwid_select) {
    printk(", nwid 0x%02X-%02X", psa.psa_nwid[0], psa.psa_nwid[1]);
  } else {
    printk(", nwid off");
  }
  tmp___0 = mmc_in((unsigned long )ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                                   0))->mmr_fee_status) -
                                                             (void *)0));
  if ((int __attribute__((__always_inline__))  )tmp___0 & 12) {
    printk(", PC");
    switch ((int )psa.psa_comp_number) {
    case 0: ;
    case 2: 
    printk("-AT");
    break;
    case 1: ;
    case 3: 
    printk("-MC");
    break;
    case 4: 
    printk("MCIA");
    break;
    default: 
    printk("?");
    }
    printk(", ");
    switch ((int )psa.psa_subband) {
    case 0: 
    printk("915");
    break;
    case 1: 
    printk("2425");
    break;
    case 2: 
    printk("2460");
    break;
    case 3: 
    printk("2484");
    break;
    case 4: 
    printk("2430.5");
    break;
    default: 
    printk("?");
    }
  } else {
    fee_read((unsigned long )ioaddr, (unsigned short)0, & freq, 1);
    printk(", 2.00, %ld", (long )((int )freq >> 6) + 2400L);
    if ((int )freq & 32) {
      printk(".5");
    }
  }
  printk(" MHz\n");
  return;
}
}
static en_stats *wavelan_get_stats(struct net_device *dev ) 
{ 

  {
  return (& ((net_local *)dev->priv)->stats);
}
}
static void wavelan_set_multicast_list(struct net_device *dev ) 
{ net_local *lp ;

  {
  lp = (net_local *)dev->priv;
  if ((int )dev->flags & 256) {
    goto _L;
  } else {
    if ((int )dev->flags & 512) {
      goto _L;
    } else {
      if (dev->mc_count > 128) {
        _L: /* CIL Label */ 
        if (! lp->promiscuous) {
          lp->promiscuous = (unsigned char)1;
          lp->mc_count = 0;
          wv_82586_reconfig(dev);
          dev->flags = (unsigned short )((int )dev->flags | 256);
        }
      } else {
        if ((unsigned int )dev->mc_list != (unsigned int )((struct dev_mc_list *)((void *)0))) {
          if (lp->promiscuous) {
            lp->promiscuous = (unsigned char)0;
            lp->mc_count = dev->mc_count;
            wv_82586_reconfig(dev);
          } else {
            if (dev->mc_count != lp->mc_count) {
              lp->promiscuous = (unsigned char)0;
              lp->mc_count = dev->mc_count;
              wv_82586_reconfig(dev);
            }
          }
        } else {
          if (lp->promiscuous) {
            lp->promiscuous = (unsigned char)0;
            lp->mc_count = 0;
            wv_82586_reconfig(dev);
          } else {
            if (lp->mc_count == 0) {
              lp->promiscuous = (unsigned char)0;
              lp->mc_count = 0;
              wv_82586_reconfig(dev);
            }
          }
        }
      }
    }
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  wv_set_frequency(unsigned long ioaddr ,
                                                                         iw_freq *frequency ) 
{ int BAND_NUM ;
  long freq ;
  u16 table[10] ;
  unsigned short area[16] ;
  unsigned short dac[2] ;
  unsigned short area_verify[16] ;
  unsigned short dac_verify[2] ;
  unsigned short power_limit[5] ;
  int power_band ;
  unsigned short power_adjust ;
  int tmp ;
  int tmp___0 ;

  {
  BAND_NUM = 10;
  freq = 0L;
  if ((int )frequency->e == 1) {
    if (frequency->m >= (int )2.412e8) {
      if (frequency->m <= (int )2.487e8) {
        freq = ((long )(frequency->m / 10000) - 24000L) / 5L;
      }
    }
  }
  if ((int )frequency->e == 0) {
    if (frequency->m < BAND_NUM) {
      freq = (long )((int const   )channel_bands[frequency->m] >> 1);
    }
  }
  if (freq != 0L) {
    fee_read(ioaddr, (unsigned short)113, table, 10);
    if (! ((int )table[9L - (freq - 24L) / 16L] & (1 << (freq - 24L) % 16L))) {
      return ((int __attribute__((__always_inline__))  )-22);
    }
  } else {
    return ((int __attribute__((__always_inline__))  )-22);
  }
  if (freq != 0L) {
    power_limit[0] = (unsigned short)40;
    power_limit[1] = (unsigned short)80;
    power_limit[2] = (unsigned short)120;
    power_limit[3] = (unsigned short)160;
    power_limit[4] = (unsigned short)0;
    power_band = 0;
    power_band = 0;
    while (1) {
      if (freq > (long )power_limit[power_band]) {
        power_band ++;
        if (! ((int )power_limit[power_band] != 0)) {
          break;
        }
      } else {
        break;
      }
    }
    fee_read(ioaddr, (unsigned short)0, area, 16);
    fee_read(ioaddr, (unsigned short)96, dac, 2);
    fee_read(ioaddr, (unsigned short )(107 - (power_band >> 1)), & power_adjust, 1);
    if (power_band & 1) {
      power_adjust = (unsigned short )((int )power_adjust >> 8);
    } else {
      power_adjust = (unsigned short )((int )power_adjust & 255);
    }
    area[0] = (unsigned short )(((freq << 5) & 65504L) | (long )((int )area[0] & 31));
    area[3] = (unsigned short )(((freq >> 1) + 2400L) - 352L);
    area[2] = (unsigned short )(((freq & 1L) << 4) | (long )((int )area[2] & 65519));
    area[13] = (unsigned short )((freq >> 1) + 2400L);
    area[12] = (unsigned short )(((freq & 1L) << 4) | (long )((int )area[2] & 65519));
    dac[1] = (unsigned short )((((int )power_adjust >> 1) & 127) | ((int )dac[1] &
                                                                    65408));
    dac[0] = (unsigned short )((((int )power_adjust & 1) << 4) | ((int )dac[0] & 65519));
    fee_write(ioaddr, (unsigned short)0, area, 16);
    fee_write(ioaddr, (unsigned short)96, dac, 2);
    fee_read(ioaddr, (unsigned short)0, area_verify, 16);
    fee_read(ioaddr, (unsigned short)96, dac_verify, 2);
    tmp = __builtin_memcmp((void const   *)(area), (void const   *)(area_verify),
                           32U);
    if (tmp) {
      printk("<6>WaveLAN: wv_set_frequency: unable to write new frequency to EEPROM(?).\n");
      return ((int __attribute__((__always_inline__))  )-95);
    } else {
      tmp___0 = __builtin_memcmp((void const   *)(dac), (void const   *)(dac_verify),
                                 4U);
      if (tmp___0) {
        printk("<6>WaveLAN: wv_set_frequency: unable to write new frequency to EEPROM(?).\n");
        return ((int __attribute__((__always_inline__))  )-95);
      }
    }
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_addr) -
                                      (void *)0), (unsigned char)15);
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_ctrl) -
                                      (void *)0), (unsigned char)14);
    fee_wait(ioaddr, 100, 100);
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_addr) -
                                      (void *)0), (unsigned char)97);
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_fee_ctrl) -
                                      (void *)0), (unsigned char)14);
    fee_wait(ioaddr, 100, 100);
    return ((int __attribute__((__always_inline__))  )0);
  } else {
    return ((int __attribute__((__always_inline__))  )-22);
  }
}
}
__inline static int __attribute__((__always_inline__))  wv_frequency_list(unsigned long ioaddr ,
                                                                          iw_freq *list ,
                                                                          int max ) 
{ u16 table[10] ;
  long freq ;
  int i ;
  int c ;
  int tmp ;

  {
  freq = 0L;
  c = 0;
  fee_read(ioaddr, (unsigned short)113, table, 10);
  i = 0;
  freq = 0L;
  while (freq < 150L) {
    if ((int )table[9L - freq / 16L] & (1 << freq % 16L)) {
      while (1) {
        if ((long )(((int const   )channel_bands[c] >> 1) - 24) < freq) {
          if (! ((unsigned int )c < sizeof(channel_bands) / sizeof(channel_bands[0]))) {
            break;
          }
        } else {
          break;
        }
        c ++;
      }
      (list + i)->i = (unsigned char )c;
      (list + i)->m = (int )(((freq + 24L) * 5L + 24000L) * 10000L);
      tmp = i;
      i ++;
      (list + tmp)->e = (short)1;
      if (i >= max) {
        return ((int __attribute__((__always_inline__))  )i);
      }
    }
    freq ++;
  }
  return ((int __attribute__((__always_inline__))  )i);
}
}
__inline static void __attribute__((__always_inline__))  wl_spy_gather(struct net_device *dev ,
                                                                       u8 *mac , u8 *stats ) 
{ struct iw_quality wstats ;

  {
  wstats.qual = (unsigned char )((int )(*(stats + 2)) & 15);
  wstats.level = (unsigned char )((int )(*(stats + 0)) & 63);
  wstats.noise = (unsigned char )((int )(*(stats + 1)) & 63);
  wstats.updated = (unsigned char)7;
  wireless_spy_update(dev, mac, & wstats);
  return;
}
}
static int wavelan_get_name(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ 

  {
  strcpy(wrqu->name, "WaveLAN");
  return (0);
}
}
static int wavelan_set_nwid(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  mm_t m ;
  unsigned long flags ;
  int ret ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  if (! wrqu->nwid.disabled) {
    psa.psa_nwid[0] = (unsigned char )((wrqu->nwid.value & 65280) >> 8);
    psa.psa_nwid[1] = (unsigned char )(wrqu->nwid.value & 255);
    psa.psa_nwid_select = (unsigned char)1;
    psa_write(ioaddr, lp->hacr, (char *)(psa.psa_nwid) - (char *)(& psa), psa.psa_nwid,
              3);
    m.w.mmw_netw_id_l = psa.psa_nwid[1];
    m.w.mmw_netw_id_h = psa.psa_nwid[0];
    mmc_write(ioaddr, (unsigned char )((char *)(& m.w.mmw_netw_id_l) - (char *)(& m)),
              & m.w.mmw_netw_id_l, 2);
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_loopt_sel) -
                                      (void *)0), (unsigned char)0);
  } else {
    psa.psa_nwid_select = (unsigned char)0;
    psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_nwid_select) - (char *)(& psa),
              & psa.psa_nwid_select, 1);
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_loopt_sel) -
                                      (void *)0), (unsigned char)64);
  }
  update_psa_checksum(dev, ioaddr, lp->hacr);
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_get_nwid(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;
  int ret ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  psa_read(ioaddr, lp->hacr, (char *)(psa.psa_nwid) - (char *)(& psa), psa.psa_nwid,
           3);
  wrqu->nwid.value = ((int )psa.psa_nwid[0] << 8) + (int )psa.psa_nwid[1];
  wrqu->nwid.disabled = (unsigned char )(! psa.psa_nwid_select != 0);
  wrqu->nwid.fixed = (unsigned char)1;
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_set_freq(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  unsigned long flags ;
  int ret ;
  unsigned char __attribute__((__always_inline__))  tmp ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  flags = _spin_lock_irqsave(& lp->spinlock);
  tmp = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 + 0))->mmr_fee_status) -
                                         (void *)0));
  if ((int __attribute__((__always_inline__))  )tmp & 12) {
    ret = -95;
  } else {
    ret = (int )wv_set_frequency(ioaddr, & wrqu->freq);
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_get_freq(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;
  int ret ;
  unsigned short freq ;
  unsigned char __attribute__((__always_inline__))  tmp ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  tmp = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 + 0))->mmr_fee_status) -
                                         (void *)0));
  if ((int __attribute__((__always_inline__))  )tmp & 12) {
    psa_read(ioaddr, lp->hacr, (char *)(& psa.psa_subband) - (char *)(& psa), & psa.psa_subband,
             1);
    if ((int )psa.psa_subband <= 4) {
      wrqu->freq.m = (int )fixed_bands[psa.psa_subband];
      wrqu->freq.e = (short )((int )psa.psa_subband != 0);
    } else {
      ret = -95;
    }
  } else {
    fee_read(ioaddr, (unsigned short)0, & freq, 1);
    wrqu->freq.m = (int )(((long )(((int )freq >> 5) * 5) + 24000L) * 10000L);
    wrqu->freq.e = (short)1;
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_set_sens(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;
  int ret ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  psa.psa_thr_pre_set = (unsigned char )(wrqu->sens.value & 63);
  psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_thr_pre_set) - (char *)(& psa), & psa.psa_thr_pre_set,
            1);
  update_psa_checksum(dev, ioaddr, lp->hacr);
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_thr_pre_set) -
                                    (void *)0), psa.psa_thr_pre_set);
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_get_sens(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;
  int ret ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  psa_read(ioaddr, lp->hacr, (char *)(& psa.psa_thr_pre_set) - (char *)(& psa), & psa.psa_thr_pre_set,
           1);
  wrqu->sens.value = (int )psa.psa_thr_pre_set & 63;
  wrqu->sens.fixed = (unsigned char)1;
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_set_encode(struct net_device *dev , struct iw_request_info *info ,
                              union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  unsigned long flags ;
  psa_t psa ;
  int ret ;
  int __attribute__((__always_inline__))  tmp ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  tmp = mmc_encr(ioaddr);
  if (! tmp) {
    ret = -95;
  }
  if ((int )wrqu->encoding.length != 8) {
    if ((int )wrqu->encoding.length != 0) {
      ret = -22;
    }
  }
  if (! ret) {
    if ((int )wrqu->encoding.length == 8) {
      __memcpy((void *)(psa.psa_encryption_key), (void const   *)extra, (unsigned int )wrqu->encoding.length);
      psa.psa_encryption_select = (unsigned char)1;
      psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_encryption_select) - (char *)(& psa),
                & psa.psa_encryption_select, 9);
      mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_encr_enable) -
                                        (void *)0), (unsigned char)3);
      mmc_write(ioaddr, (unsigned char )((unsigned short )((void *)(& ((mmw_t *)((void *)0 +
                                                                                 0))->mmw_encr_key) -
                                                           (void *)0)), (unsigned char *)(& psa.psa_encryption_key),
                8);
    }
    if ((int )wrqu->encoding.flags & 32768) {
      psa.psa_encryption_select = (unsigned char)0;
      psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_encryption_select) - (char *)(& psa),
                & psa.psa_encryption_select, 1);
      mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_encr_enable) -
                                        (void *)0), (unsigned char)0);
    }
    update_psa_checksum(dev, ioaddr, lp->hacr);
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_get_encode(struct net_device *dev , struct iw_request_info *info ,
                              union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;
  int ret ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  ret = 0;
  flags = _spin_lock_irqsave(& lp->spinlock);
  tmp___0 = mmc_encr(ioaddr);
  if (tmp___0) {
    psa_read(ioaddr, lp->hacr, (char *)(& psa.psa_encryption_select) - (char *)(& psa),
             & psa.psa_encryption_select, 9);
    if (psa.psa_encryption_select) {
      wrqu->encoding.flags = (unsigned short)0;
    } else {
      wrqu->encoding.flags = (unsigned short)32768;
    }
    tmp = mmc_encr(ioaddr);
    wrqu->encoding.flags = (unsigned short )((int )wrqu->encoding.flags | (int )tmp);
    wrqu->encoding.length = (unsigned short)8;
    __memcpy((void *)extra, (void const   *)(psa.psa_encryption_key), (unsigned int )wrqu->encoding.length);
  } else {
    ret = -95;
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_get_range(struct net_device *dev , struct iw_request_info *info ,
                             union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  struct iw_range *range ;
  unsigned long flags ;
  int ret ;
  unsigned char __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  range = (struct iw_range *)extra;
  ret = 0;
  wrqu->data.length = (unsigned short )sizeof(struct iw_range );
  __constant_c_and_count_memset((void *)range, 0UL, sizeof(struct iw_range ));
  range->we_version_compiled = (unsigned char)17;
  range->we_version_source = (unsigned char)9;
  range->throughput = (unsigned int )((1.6 * (double )1000) * (double )1000);
  range->min_nwid = 0U;
  range->max_nwid = 65535U;
  range->sensitivity = 63;
  range->max_qual.qual = (unsigned char)15;
  range->max_qual.level = (unsigned char)63;
  range->max_qual.noise = (unsigned char)63;
  range->avg_qual.qual = (unsigned char)15;
  range->avg_qual.level = (unsigned char)30;
  range->avg_qual.noise = (unsigned char)8;
  range->num_bitrates = (unsigned char)1;
  range->bitrate[0] = 2000000;
  range->event_capa[0] = 20U;
  range->event_capa[1] = 1024U;
  flags = _spin_lock_irqsave(& lp->spinlock);
  tmp = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 + 0))->mmr_fee_status) -
                                         (void *)0));
  if ((int __attribute__((__always_inline__))  )tmp & 12) {
    range->num_frequency = (unsigned char)0;
    range->num_channels = (unsigned short )range->num_frequency;
  } else {
    range->num_channels = (unsigned short)10;
    range->num_frequency = (__u8 )wv_frequency_list(ioaddr, range->freq, 32);
  }
  tmp___0 = mmc_encr(ioaddr);
  if (tmp___0) {
    range->encoding_size[0] = (unsigned short)8;
    range->num_encoding_sizes = (unsigned char)1;
    range->max_encoding_tokens = (unsigned char)1;
  } else {
    range->num_encoding_sizes = (unsigned char)0;
    range->max_encoding_tokens = (unsigned char)0;
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (ret);
}
}
static int wavelan_set_qthr(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  flags = _spin_lock_irqsave(& lp->spinlock);
  psa.psa_quality_thr = (unsigned char )((int )(*extra) & 15);
  psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_quality_thr) - (char *)(& psa), & psa.psa_quality_thr,
            1);
  update_psa_checksum(dev, ioaddr, lp->hacr);
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_quality_thr) -
                                    (void *)0), psa.psa_quality_thr);
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (0);
}
}
static int wavelan_get_qthr(struct net_device *dev , struct iw_request_info *info ,
                            union iwreq_data *wrqu , char *extra ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  unsigned long flags ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  flags = _spin_lock_irqsave(& lp->spinlock);
  psa_read(ioaddr, lp->hacr, (char *)(& psa.psa_quality_thr) - (char *)(& psa), & psa.psa_quality_thr,
           1);
  (*extra) = (char )((int )psa.psa_quality_thr & 15);
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (0);
}
}
static iw_handler const   wavelan_handler[44]  = 
  {      (iw_handler const   )((void *)0),      (iw_handler const   )(& wavelan_get_name),      (iw_handler const   )(& wavelan_set_nwid),      (iw_handler const   )(& wavelan_get_nwid), 
        (iw_handler const   )(& wavelan_set_freq),      (iw_handler const   )(& wavelan_get_freq),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )(& wavelan_set_sens),      (iw_handler const   )(& wavelan_get_sens),      (iw_handler const   )((void *)0),      (iw_handler const   )(& wavelan_get_range), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )(& iw_handler_set_spy),      (iw_handler const   )(& iw_handler_get_spy),      (iw_handler const   )(& iw_handler_set_thrspy),      (iw_handler const   )(& iw_handler_get_thrspy), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0), 
        (iw_handler const   )((void *)0),      (iw_handler const   )((void *)0),      (iw_handler const   )(& wavelan_set_encode),      (iw_handler const   )(& wavelan_get_encode)};
static iw_handler const   wavelan_private_handler[2]  = {      (iw_handler const   )(& wavelan_set_qthr),      (iw_handler const   )(& wavelan_get_qthr)};
static struct iw_priv_args  const  wavelan_private_args[4]  = {      {(__u32 )35808, (__u16 )6145, (__u16 )0, {(char )'s', (char )'e', (char )'t',
                                               (char )'q', (char )'u', (char )'a',
                                               (char )'l', (char )'t', (char )'h',
                                               (char )'r', (char )'\000', (char)0,
                                               (char)0, (char)0, (char)0, (char)0}}, 
        {(__u32 )35809,
      (__u16 )0, (__u16 )6145, {(char )'g', (char )'e', (char )'t', (char )'q', (char )'u',
                                (char )'a', (char )'l', (char )'t', (char )'h', (char )'r',
                                (char )'\000', (char)0, (char)0, (char)0, (char)0,
                                (char)0}}, 
        {(__u32 )35810, (__u16 )4112, (__u16 )0, {(char )'s', (char )'e', (char )'t',
                                               (char )'h', (char )'i', (char )'s',
                                               (char )'t', (char )'o', (char )'\000',
                                               (char)0, (char)0, (char)0, (char)0,
                                               (char)0, (char)0, (char)0}}, 
        {(__u32 )35811, (__u16 )0, (__u16 )16400, {(char )'g', (char )'e', (char )'t',
                                                (char )'h', (char )'i', (char )'s',
                                                (char )'t', (char )'o', (char )'\000',
                                                (char)0, (char)0, (char)0, (char)0,
                                                (char)0, (char)0, (char)0}}};
static struct iw_handler_def  const  wavelan_handler_def  = 
     {(__u16 )(sizeof(wavelan_handler) / sizeof(int (*)(struct net_device *dev , struct iw_request_info *info ,
                                                      union iwreq_data *wrqu , char *extra ))),
    (__u16 )(sizeof(wavelan_private_handler) / sizeof(int (*)(struct net_device *dev ,
                                                              struct iw_request_info *info ,
                                                              union iwreq_data *wrqu ,
                                                              char *extra ))), (__u16 )(sizeof(wavelan_private_args) /
                                                                                        sizeof(struct iw_priv_args )),
    wavelan_handler, wavelan_private_handler, wavelan_private_args, 0L, & wavelan_get_wireless_stats};
static iw_stats *wavelan_get_wireless_stats(struct net_device *dev ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  mmr_t m ;
  iw_stats *wstats ;
  unsigned long flags ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  if ((unsigned int )lp == (unsigned int )((net_local *)((void *)0))) {
    return ((iw_stats *)((void *)0));
  }
  flags = _spin_lock_irqsave(& lp->spinlock);
  wstats = & lp->wstats;
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_freeze) -
                                    (void *)0), (unsigned char)1);
  mmc_read(ioaddr, (unsigned char )((unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                            0))->mmr_dce_status) -
                                                      (void *)0)), & m.mmr_dce_status,
           1);
  mmc_read(ioaddr, (unsigned char )((unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                            0))->mmr_wrong_nwid_l) -
                                                      (void *)0)), & m.mmr_wrong_nwid_l,
           2);
  mmc_read(ioaddr, (unsigned char )((unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                            0))->mmr_thr_pre_set) -
                                                      (void *)0)), & m.mmr_thr_pre_set,
           4);
  mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_freeze) -
                                    (void *)0), (unsigned char)0);
  wstats->status = (unsigned short )((int )m.mmr_dce_status & 15);
  wstats->qual.qual = (unsigned char )((int )m.mmr_sgnl_qual & 15);
  wstats->qual.level = (unsigned char )((int )m.mmr_signal_lvl & 63);
  wstats->qual.noise = (unsigned char )((int )m.mmr_silence_lvl & 63);
  wstats->qual.updated = (unsigned char )(((((int )m.mmr_signal_lvl & 128) >> 7) |
                                           (((int )m.mmr_signal_lvl & 128) >> 6)) |
                                          (((int )m.mmr_silence_lvl & 128) >> 5));
  wstats->discard.nwid += (__u32 )(((int )m.mmr_wrong_nwid_h << 8) | (int )m.mmr_wrong_nwid_l);
  wstats->discard.code = 0U;
  wstats->discard.misc = 0U;
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (& lp->wstats);
}
}
__inline static void __attribute__((__always_inline__))  wv_packet_read(struct net_device *dev ,
                                                                        unsigned short buf_off ,
                                                                        int sksize ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  struct sk_buff *skb ;
  unsigned char __attribute__((__always_inline__))  *tmp ;
  u8 stats[3] ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  skb = (struct sk_buff *)dev_alloc_skb((unsigned int )sksize);
  if ((unsigned int )skb == (unsigned int )((struct sk_buff *)((void *)0))) {
    printk("<6>%s: wv_packet_read(): could not alloc_skb(%d, GFP_ATOMIC).\n", dev->name,
           sksize);
    lp->stats.rx_dropped ++;
    return;
  }
  skb->dev = dev;
  tmp = skb_put(skb, (unsigned int )sksize);
  obram_read(ioaddr, buf_off, (unsigned char *)tmp, sksize);
  skb->protocol = eth_type_trans(skb, dev);
  if (lp->spy_data.spy_number > 0) {
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_freeze) -
                                      (void *)0), (unsigned char)1);
    mmc_read(ioaddr, (unsigned char )((unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                              0))->mmr_signal_lvl) -
                                                        (void *)0)), stats, 3);
    mmc_out(ioaddr, (unsigned short )((void *)(& ((mmw_t *)((void *)0 + 0))->mmw_freeze) -
                                      (void *)0), (unsigned char)0);
    wl_spy_gather(dev, skb->mac.raw + 6, stats);
  }
  netif_rx(skb);
  dev->last_rx = (unsigned long )jiffies;
  lp->stats.rx_packets ++;
  lp->stats.rx_bytes += (unsigned long )sksize;
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_receive(struct net_device *dev ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  fd_t fd ;
  rbd_t rbd ;
  int nreaped ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  nreaped = 0;
  while (1) {
    obram_read(ioaddr, lp->rx_head, (unsigned char *)(& fd), (int )sizeof(fd));
    if (((int )fd.fd_status & 32768) != 32768) {
      break;
    }
    nreaped ++;
    if (((int )fd.fd_status & 8192) == 8192) {
      if ((int )fd.fd_rbd_offset != 65535) {
        obram_read(ioaddr, fd.fd_rbd_offset, (unsigned char *)(& rbd), (int )sizeof(rbd));
        if (((int )rbd.rbd_status & 32768) != 32768) {
          printk("<6>%s: wv_receive(): missing EOF flag.\n", dev->name);
        }
        if (((int )rbd.rbd_status & 16384) != 16384) {
          printk("<6>%s: wv_receive(): missing F flag.\n", dev->name);
        }
        wv_packet_read(dev, rbd.rbd_bufl, (int )rbd.rbd_status & 16383);
      } else {
        printk("<6>%s: wv_receive(): frame has no data.\n", dev->name);
      }
    } else {
      lp->stats.rx_errors ++;
      if (((int )fd.fd_status & 64) != 0) {
        printk("<6>%s: wv_receive(): no EOF flag.\n", dev->name);
      }
      if (((int )fd.fd_status & 128) != 0) {
        lp->stats.rx_length_errors ++;
      }
      if (((int )fd.fd_status & 256) != 0) {
        lp->stats.rx_over_errors ++;
      }
      if (((int )fd.fd_status & 512) != 0) {
        lp->stats.rx_fifo_errors ++;
      }
      if (((int )fd.fd_status & 1024) != 0) {
        lp->stats.rx_frame_errors ++;
      }
      if (((int )fd.fd_status & 2048) != 0) {
        lp->stats.rx_crc_errors ++;
      }
    }
    fd.fd_status = (unsigned short)0;
    obram_write(ioaddr, (unsigned short )((void *)(& ((fd_t *)((void *)0 + (int )lp->rx_head))->fd_status) -
                                          (void *)0), (unsigned char *)(& fd.fd_status),
                (int )sizeof(fd.fd_status));
    fd.fd_command = (unsigned short)32768;
    obram_write(ioaddr, (unsigned short )((void *)(& ((fd_t *)((void *)0 + (int )lp->rx_head))->fd_command) -
                                          (void *)0), (unsigned char *)(& fd.fd_command),
                (int )sizeof(fd.fd_command));
    fd.fd_command = (unsigned short)0;
    obram_write(ioaddr, (unsigned short )((void *)(& ((fd_t *)((void *)0 + (int )lp->rx_last))->fd_command) -
                                          (void *)0), (unsigned char *)(& fd.fd_command),
                (int )sizeof(fd.fd_command));
    lp->rx_last = lp->rx_head;
    lp->rx_head = fd.fd_link_offset;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  wv_packet_write(struct net_device *dev ,
                                                                        void *buf ,
                                                                        short length ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  unsigned short txblock ;
  unsigned short txpred ;
  unsigned short tx_addr ;
  unsigned short nop_addr ;
  unsigned short tbd_addr ;
  unsigned short buf_addr ;
  ac_tx_t tx ;
  ac_nop_t nop ;
  tbd_t tbd ;
  int clen ;
  unsigned long flags ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  clen = (int )length;
  flags = _spin_lock_irqsave(& lp->spinlock);
  if ((unsigned int )lp->tx_n_in_use == ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                          sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                         sizeof(ac_nop_t )) +
                                                                        sizeof(tbd_t )) +
                                                                       1514U) - 1U) {
    printk("<6>%s: wv_packet_write(): Tx queue full.\n", dev->name);
    _spin_unlock_irqrestore(& lp->spinlock, flags);
    return ((int __attribute__((__always_inline__))  )1);
  }
  txblock = lp->tx_first_free;
  txpred = (unsigned short )((unsigned int )txblock - (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                                        sizeof(tbd_t )) + 1514U));
  if ((int )txpred < 49152) {
    txpred = (unsigned short )((unsigned int )txpred + (((((65536U - sizeof(scp_t )) -
                                                           sizeof(iscp_t )) - sizeof(scb_t )) -
                                                         49152U) / (((sizeof(ac_tx_t ) +
                                                                      sizeof(ac_nop_t )) +
                                                                     sizeof(tbd_t )) +
                                                                    1514U)) * (((sizeof(ac_tx_t ) +
                                                                                 sizeof(ac_nop_t )) +
                                                                                sizeof(tbd_t )) +
                                                                               1514U));
  }
  lp->tx_first_free = (unsigned short )((unsigned int )lp->tx_first_free + (((sizeof(ac_tx_t ) +
                                                                              sizeof(ac_nop_t )) +
                                                                             sizeof(tbd_t )) +
                                                                            1514U));
  if ((unsigned int )lp->tx_first_free >= 49152U + (((((65536U - sizeof(scp_t )) -
                                                       sizeof(iscp_t )) - sizeof(scb_t )) -
                                                     49152U) / (((sizeof(ac_tx_t ) +
                                                                  sizeof(ac_nop_t )) +
                                                                 sizeof(tbd_t )) +
                                                                1514U)) * (((sizeof(ac_tx_t ) +
                                                                             sizeof(ac_nop_t )) +
                                                                            sizeof(tbd_t )) +
                                                                           1514U)) {
    lp->tx_first_free = (unsigned short )((unsigned int )lp->tx_first_free - (((((65536U -
                                                                                  sizeof(scp_t )) -
                                                                                 sizeof(iscp_t )) -
                                                                                sizeof(scb_t )) -
                                                                               49152U) /
                                                                              (((sizeof(ac_tx_t ) +
                                                                                 sizeof(ac_nop_t )) +
                                                                                sizeof(tbd_t )) +
                                                                               1514U)) *
                                                                             (((sizeof(ac_tx_t ) +
                                                                                sizeof(ac_nop_t )) +
                                                                               sizeof(tbd_t )) +
                                                                              1514U));
  }
  lp->tx_n_in_use ++;
  tx_addr = txblock;
  nop_addr = (unsigned short )((unsigned int )tx_addr + sizeof(tx));
  tbd_addr = (unsigned short )((unsigned int )nop_addr + sizeof(nop));
  buf_addr = (unsigned short )((unsigned int )tbd_addr + sizeof(tbd));
  tx.tx_h.ac_status = (unsigned short)0;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_tx_t *)((void *)0 + (int )tx_addr))->tx_h.ac_status) -
                                        (void *)0), (unsigned char *)(& tx.tx_h.ac_status),
              (int )sizeof(tx.tx_h.ac_status));
  nop.nop_h.ac_status = (unsigned short)0;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_status) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_status),
              (int )sizeof(nop.nop_h.ac_status));
  nop.nop_h.ac_link = nop_addr;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_link) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_link),
              (int )sizeof(nop.nop_h.ac_link));
  tbd.tbd_status = (unsigned short )(32768 | (16383 & clen));
  tbd.tbd_next_bd_offset = (unsigned short)65535;
  tbd.tbd_bufl = buf_addr;
  tbd.tbd_bufh = (unsigned short)0;
  obram_write(ioaddr, tbd_addr, (unsigned char *)(& tbd), (int )sizeof(tbd));
  obram_write(ioaddr, buf_addr, (unsigned char *)buf, (int )length);
  nop_addr = (unsigned short )((unsigned int )txpred + sizeof(tx));
  nop.nop_h.ac_status = (unsigned short)0;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_status) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_status),
              (int )sizeof(nop.nop_h.ac_status));
  nop.nop_h.ac_link = txblock;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_link) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_link),
              (int )sizeof(nop.nop_h.ac_link));
  dev->trans_start = (unsigned long )jiffies;
  lp->stats.tx_bytes += (unsigned long )length;
  if ((int )lp->tx_first_in_use == 65535) {
    lp->tx_first_in_use = txblock;
  }
  if ((unsigned int )lp->tx_n_in_use < ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                         sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                        sizeof(ac_nop_t )) +
                                                                       sizeof(tbd_t )) +
                                                                      1514U) - 1U) {
    netif_wake_queue(dev);
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return ((int __attribute__((__always_inline__))  )0);
}
}
static int wavelan_packet_xmit(struct sk_buff *skb , struct net_device *dev ) 
{ net_local *lp ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  lp = (net_local *)dev->priv;
  netif_stop_queue(dev);
  if (lp->reconfig_82586) {
    flags = _spin_lock_irqsave(& lp->spinlock);
    wv_82586_config(dev);
    _spin_unlock_irqrestore(& lp->spinlock, flags);
    if ((unsigned int )lp->tx_n_in_use == ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                            sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                           sizeof(ac_nop_t )) +
                                                                          sizeof(tbd_t )) +
                                                                         1514U) -
                                          1U) {
      return (1);
    }
  }
  if (skb->next) {
    printk("<6>skb has next\n");
  }
  if (skb->len < 60U) {
    skb = (struct sk_buff *)skb_padto(skb, 60U);
    if ((unsigned int )skb == (unsigned int )((void *)0)) {
      return (0);
    }
  }
  tmp = wv_packet_write(dev, (void *)skb->data, (short )skb->len);
  if (tmp) {
    return (1);
  }
  kfree_skb(skb);
  return (0);
}
}
__inline static int __attribute__((__always_inline__))  wv_mmc_init(struct net_device *dev ) 
{ unsigned long ioaddr ;
  net_local *lp ;
  psa_t psa ;
  mmw_t m ;
  int configured ;
  unsigned char __attribute__((__always_inline__))  tmp ;

  {
  ioaddr = dev->base_addr;
  lp = (net_local *)dev->priv;
  psa_read(ioaddr, lp->hacr, 0, (unsigned char *)(& psa), (int )sizeof(psa));
  configured = (int )psa.psa_conf_status & 1;
  if (! configured) {
    psa.psa_nwid[0] = (unsigned char)0;
    psa.psa_nwid[1] = (unsigned char)0;
    psa.psa_nwid_select = (unsigned char)0;
    psa.psa_encryption_select = (unsigned char)0;
    if ((int )psa.psa_comp_number & 1) {
      psa.psa_thr_pre_set = (unsigned char)1;
    } else {
      psa.psa_thr_pre_set = (unsigned char)4;
    }
    psa.psa_quality_thr = (unsigned char)3;
    psa.psa_conf_status = (unsigned char )((int )psa.psa_conf_status | 1);
    psa_write(ioaddr, lp->hacr, (char *)(psa.psa_nwid) - (char *)(& psa), psa.psa_nwid,
              4);
    psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_thr_pre_set) - (char *)(& psa),
              & psa.psa_thr_pre_set, 1);
    psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_quality_thr) - (char *)(& psa),
              & psa.psa_quality_thr, 1);
    psa_write(ioaddr, lp->hacr, (char *)(& psa.psa_conf_status) - (char *)(& psa),
              & psa.psa_conf_status, 1);
    update_psa_checksum(dev, ioaddr, lp->hacr);
  }
  __constant_c_and_count_memset((void *)(& m), 0UL, sizeof(m));
  m.mmw_netw_id_l = psa.psa_nwid[1];
  m.mmw_netw_id_h = psa.psa_nwid[0];
  if ((int )psa.psa_nwid_select & 1) {
    m.mmw_loopt_sel = (unsigned char)0;
  } else {
    m.mmw_loopt_sel = (unsigned char)64;
  }
  __constant_memcpy((void *)(& m.mmw_encr_key), (void const   *)(& psa.psa_encryption_key),
                    sizeof(m.mmw_encr_key));
  if (psa.psa_encryption_select) {
    m.mmw_encr_enable = (unsigned char)3;
  } else {
    m.mmw_encr_enable = (unsigned char)0;
  }
  m.mmw_thr_pre_set = (unsigned char )((int )psa.psa_thr_pre_set & 63);
  m.mmw_quality_thr = (unsigned char )((int )psa.psa_quality_thr & 15);
  m.mmw_jabber_enable = (unsigned char)1;
  m.mmw_freeze = (unsigned char)0;
  m.mmw_anten_sel = (unsigned char)2;
  m.mmw_ifs = (unsigned char)32;
  m.mmw_mod_delay = (unsigned char)4;
  m.mmw_jam_time = (unsigned char)56;
  m.mmw_des_io_invert = (unsigned char)0;
  m.mmw_decay_prm = (unsigned char)0;
  m.mmw_decay_updat_prm = (unsigned char)0;
  mmc_write(ioaddr, (unsigned char)0, (u8 *)(& m), (int )sizeof(m));
  tmp = mmc_in(ioaddr, (unsigned short )((void *)(& ((mmr_t *)((void *)0 + 0))->mmr_fee_status) -
                                         (void *)0));
  if (! ((int __attribute__((__always_inline__))  )tmp & 12)) {
    m.mmw_fee_addr = (unsigned char)15;
    m.mmw_fee_ctrl = (unsigned char)14;
    mmc_write(ioaddr, (unsigned char )((char *)(& m.mmw_fee_ctrl) - (char *)(& m)),
              & m.mmw_fee_ctrl, 2);
    fee_wait(ioaddr, 100, 100);
    m.mmw_fee_addr = (unsigned char)97;
    m.mmw_fee_ctrl = (unsigned char)14;
    mmc_write(ioaddr, (unsigned char )((char *)(& m.mmw_fee_ctrl) - (char *)(& m)),
              & m.mmw_fee_ctrl, 2);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  wv_ru_start(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  u16 scb_cs ;
  fd_t fd ;
  rbd_t rbd ;
  u16 rx ;
  u16 rx_next ;
  int i ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  obram_read(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                            sizeof(scp_t )) -
                                                                           sizeof(iscp_t )) -
                                                                          sizeof(scb_t ))))->scb_status) -
                                       (void *)0), (unsigned char *)(& scb_cs), (int )sizeof(scb_cs));
  if (((int )scb_cs & 112) == 64) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  lp->rx_head = (unsigned short)0;
  i = 0;
  rx = lp->rx_head;
  while ((unsigned int )i < 49152U / ((sizeof(fd_t ) + sizeof(rbd_t )) + 1514U)) {
    if ((unsigned int )i == 49152U / ((sizeof(fd_t ) + sizeof(rbd_t )) + 1514U) -
                            1U) {
      rx_next = lp->rx_head;
    } else {
      rx_next = (unsigned short )((unsigned int )rx + ((sizeof(fd_t ) + sizeof(rbd_t )) +
                                                       1514U));
    }
    fd.fd_status = (unsigned short)0;
    if ((unsigned int )i == 49152U / ((sizeof(fd_t ) + sizeof(rbd_t )) + 1514U) -
                            1U) {
      fd.fd_command = (unsigned short)32768;
    } else {
      fd.fd_command = (unsigned short)0;
    }
    fd.fd_link_offset = rx_next;
    fd.fd_rbd_offset = (unsigned short )((unsigned int )rx + sizeof(fd));
    obram_write(ioaddr, rx, (unsigned char *)(& fd), (int )sizeof(fd));
    rbd.rbd_status = (unsigned short)0;
    rbd.rbd_next_rbd_offset = (unsigned short)65535;
    rbd.rbd_bufl = (unsigned short )(((unsigned int )rx + sizeof(fd)) + sizeof(rbd));
    rbd.rbd_bufh = (unsigned short)0;
    rbd.rbd_el_size = (unsigned short)34282;
    obram_write(ioaddr, (unsigned short )((unsigned int )rx + sizeof(fd)), (unsigned char *)(& rbd),
                (int )sizeof(rbd));
    lp->rx_last = rx;
    i ++;
    rx = rx_next;
  }
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_rfa_offset) -
                                        (void *)0), (unsigned char *)(& lp->rx_head),
              (int )sizeof(lp->rx_head));
  scb_cs = (unsigned short)16;
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_command) -
                                        (void *)0), (unsigned char *)(& scb_cs), (int )sizeof(scb_cs));
  set_chan_attn(ioaddr, lp->hacr);
  i = 1000;
  while (i > 0) {
    obram_read(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                              sizeof(scp_t )) -
                                                                             sizeof(iscp_t )) -
                                                                            sizeof(scb_t ))))->scb_command) -
                                         (void *)0), (unsigned char *)(& scb_cs),
               (int )sizeof(scb_cs));
    if ((int )scb_cs == 0) {
      break;
    }
    __const_udelay(42950UL);
    i --;
  }
  if (i <= 0) {
    printk("<6>%s: wavelan_ru_start(): board not accepting command.\n", dev->name);
    return ((int __attribute__((__always_inline__))  )-1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  wv_cu_start(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  int i ;
  u16 txblock ;
  u16 first_nop ;
  u16 scb_cs ;
  ac_tx_t tx ;
  ac_nop_t nop ;
  tbd_t tbd ;
  unsigned short tx_addr ;
  unsigned short nop_addr ;
  unsigned short tbd_addr ;
  unsigned short buf_addr ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  lp->tx_first_free = (unsigned short)49152;
  lp->tx_first_in_use = (unsigned short)65535;
  i = 0;
  txblock = (unsigned short)49152;
  while ((unsigned int )i < ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) - sizeof(scb_t )) -
                             49152U) / (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                         sizeof(tbd_t )) + 1514U)) {
    tx_addr = txblock;
    nop_addr = (unsigned short )((unsigned int )tx_addr + sizeof(tx));
    tbd_addr = (unsigned short )((unsigned int )nop_addr + sizeof(nop));
    buf_addr = (unsigned short )((unsigned int )tbd_addr + sizeof(tbd));
    tx.tx_h.ac_status = (unsigned short)0;
    tx.tx_h.ac_command = (unsigned short)8196;
    tx.tx_h.ac_link = nop_addr;
    tx.tx_tbd_offset = tbd_addr;
    obram_write(ioaddr, tx_addr, (unsigned char *)(& tx), (int )sizeof(tx));
    nop.nop_h.ac_status = (unsigned short)0;
    nop.nop_h.ac_command = (unsigned short)0;
    nop.nop_h.ac_link = nop_addr;
    obram_write(ioaddr, nop_addr, (unsigned char *)(& nop), (int )sizeof(nop));
    tbd.tbd_status = (unsigned short)32768;
    tbd.tbd_next_bd_offset = (unsigned short)65535;
    tbd.tbd_bufl = buf_addr;
    tbd.tbd_bufh = (unsigned short)0;
    obram_write(ioaddr, tbd_addr, (unsigned char *)(& tbd), (int )sizeof(tbd));
    i ++;
    txblock = (unsigned short )((unsigned int )txblock + (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                                           sizeof(tbd_t )) + 1514U));
  }
  first_nop = (unsigned short )((49152U + (((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                             sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                            sizeof(ac_nop_t )) +
                                                                           sizeof(tbd_t )) +
                                                                          1514U) -
                                           1U) * (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                                   sizeof(tbd_t )) + 1514U)) + sizeof(ac_tx_t ));
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_cbl_offset) -
                                        (void *)0), (unsigned char *)(& first_nop),
              (int )sizeof(first_nop));
  scb_cs = (unsigned short)256;
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_command) -
                                        (void *)0), (unsigned char *)(& scb_cs), (int )sizeof(scb_cs));
  set_chan_attn(ioaddr, lp->hacr);
  i = 1000;
  while (i > 0) {
    obram_read(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                              sizeof(scp_t )) -
                                                                             sizeof(iscp_t )) -
                                                                            sizeof(scb_t ))))->scb_command) -
                                         (void *)0), (unsigned char *)(& scb_cs),
               (int )sizeof(scb_cs));
    if ((int )scb_cs == 0) {
      break;
    }
    __const_udelay(42950UL);
    i --;
  }
  if (i <= 0) {
    printk("<6>%s: wavelan_cu_start(): board not accepting command.\n", dev->name);
    return ((int __attribute__((__always_inline__))  )-1);
  }
  lp->tx_n_in_use = 0;
  netif_start_queue(dev);
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  wv_82586_start(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  scp_t scp ;
  iscp_t iscp ;
  scb_t scb ;
  ach_t cb ;
  u8 zeroes[512] ;
  int i ;
  int __attribute__((__always_inline__))  tmp ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  __constant_c_and_count_memset((void *)(zeroes), 0UL, sizeof(zeroes));
  i = 0;
  while (i < 65536) {
    obram_write(ioaddr, (unsigned short )i, zeroes, (int )sizeof(zeroes));
    i = (int )((unsigned int )i + sizeof(zeroes));
  }
  __constant_c_and_count_memset((void *)(& scp), 0UL, sizeof(scp));
  scp.scp_sysbus = (unsigned short)0;
  scp.scp_iscpl = (unsigned short )((65536U - sizeof(scp_t )) - sizeof(iscp_t ));
  obram_write(ioaddr, (unsigned short )(65536U - sizeof(scp_t )), (unsigned char *)(& scp),
              (int )sizeof(scp));
  __constant_c_and_count_memset((void *)(& iscp), 0UL, sizeof(iscp));
  iscp.iscp_busy = (unsigned short)1;
  iscp.iscp_offset = (unsigned short )(((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                       sizeof(scb_t ));
  obram_write(ioaddr, (unsigned short )((65536U - sizeof(scp_t )) - sizeof(iscp_t )),
              (unsigned char *)(& iscp), (int )sizeof(iscp));
  __constant_c_and_count_memset((void *)(& scb), 0UL, sizeof(scb));
  scb.scb_command = (unsigned short)128;
  scb.scb_cbl_offset = (unsigned short)49152;
  scb.scb_rfa_offset = (unsigned short)0;
  obram_write(ioaddr, (unsigned short )(((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                        sizeof(scb_t )), (unsigned char *)(& scb),
              (int )sizeof(scb));
  set_chan_attn(ioaddr, lp->hacr);
  i = 1000;
  while (i > 0) {
    obram_read(ioaddr, (unsigned short )((65536U - sizeof(scp_t )) - sizeof(iscp_t )),
               (unsigned char *)(& iscp), (int )sizeof(iscp));
    if ((int )iscp.iscp_busy == 0) {
      break;
    }
    __const_udelay(42950UL);
    i --;
  }
  if (i <= 0) {
    printk("<6>%s: wv_82586_start(): iscp_busy timeout.\n", dev->name);
    return ((int __attribute__((__always_inline__))  )-1);
  }
  i = 15;
  while (i > 0) {
    obram_read(ioaddr, (unsigned short )(((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                         sizeof(scb_t )), (unsigned char *)(& scb),
               (int )sizeof(scb));
    if ((int )scb.scb_status == 40960) {
      break;
    }
    __const_udelay(42950UL);
    i --;
  }
  if (i <= 0) {
    printk("<6>%s: wv_82586_start(): status: expected 0x%02x, got 0x%02x.\n", dev->name,
           40960, scb.scb_status);
    return ((int __attribute__((__always_inline__))  )-1);
  }
  wv_ack(dev);
  __constant_c_and_count_memset((void *)(& cb), 0UL, sizeof(cb));
  cb.ac_command = (unsigned short)32775;
  cb.ac_link = (unsigned short)49152;
  obram_write(ioaddr, (unsigned short)49152, (unsigned char *)(& cb), (int )sizeof(cb));
  tmp = wv_synchronous_cmd(dev, "diag()");
  if (tmp == -1) {
    return ((int __attribute__((__always_inline__))  )-1);
  }
  obram_read(ioaddr, (unsigned short)49152, (unsigned char *)(& cb), (int )sizeof(cb));
  if ((int )cb.ac_status & 2048) {
    printk("<6>%s: wv_82586_start(): i82586 Self Test failed.\n", dev->name);
    return ((int __attribute__((__always_inline__))  )-1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
static void wv_82586_config(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  unsigned short txblock ;
  unsigned short txpred ;
  unsigned short tx_addr ;
  unsigned short nop_addr ;
  unsigned short tbd_addr ;
  unsigned short cfg_addr ;
  unsigned short ias_addr ;
  unsigned short mcs_addr ;
  ac_tx_t tx ;
  ac_nop_t nop ;
  ac_cfg_t cfg ;
  ac_ias_t ias ;
  ac_mcs_t mcs ;
  struct dev_mc_list *dmi ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  if ((unsigned int )lp->tx_n_in_use == ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                          sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                         sizeof(ac_nop_t )) +
                                                                        sizeof(tbd_t )) +
                                                                       1514U) - 1U) {
    printk("<6>%s: wv_82586_config(): Tx queue full.\n", dev->name);
    return;
  }
  txblock = lp->tx_first_free;
  txpred = (unsigned short )((unsigned int )txblock - (((sizeof(ac_tx_t ) + sizeof(ac_nop_t )) +
                                                        sizeof(tbd_t )) + 1514U));
  if ((int )txpred < 49152) {
    txpred = (unsigned short )((unsigned int )txpred + (((((65536U - sizeof(scp_t )) -
                                                           sizeof(iscp_t )) - sizeof(scb_t )) -
                                                         49152U) / (((sizeof(ac_tx_t ) +
                                                                      sizeof(ac_nop_t )) +
                                                                     sizeof(tbd_t )) +
                                                                    1514U)) * (((sizeof(ac_tx_t ) +
                                                                                 sizeof(ac_nop_t )) +
                                                                                sizeof(tbd_t )) +
                                                                               1514U));
  }
  lp->tx_first_free = (unsigned short )((unsigned int )lp->tx_first_free + (((sizeof(ac_tx_t ) +
                                                                              sizeof(ac_nop_t )) +
                                                                             sizeof(tbd_t )) +
                                                                            1514U));
  if ((unsigned int )lp->tx_first_free >= 49152U + (((((65536U - sizeof(scp_t )) -
                                                       sizeof(iscp_t )) - sizeof(scb_t )) -
                                                     49152U) / (((sizeof(ac_tx_t ) +
                                                                  sizeof(ac_nop_t )) +
                                                                 sizeof(tbd_t )) +
                                                                1514U)) * (((sizeof(ac_tx_t ) +
                                                                             sizeof(ac_nop_t )) +
                                                                            sizeof(tbd_t )) +
                                                                           1514U)) {
    lp->tx_first_free = (unsigned short )((unsigned int )lp->tx_first_free - (((((65536U -
                                                                                  sizeof(scp_t )) -
                                                                                 sizeof(iscp_t )) -
                                                                                sizeof(scb_t )) -
                                                                               49152U) /
                                                                              (((sizeof(ac_tx_t ) +
                                                                                 sizeof(ac_nop_t )) +
                                                                                sizeof(tbd_t )) +
                                                                               1514U)) *
                                                                             (((sizeof(ac_tx_t ) +
                                                                                sizeof(ac_nop_t )) +
                                                                               sizeof(tbd_t )) +
                                                                              1514U));
  }
  lp->tx_n_in_use ++;
  tx_addr = txblock;
  nop_addr = (unsigned short )((unsigned int )tx_addr + sizeof(tx));
  tbd_addr = (unsigned short )((unsigned int )nop_addr + sizeof(nop));
  cfg_addr = (unsigned short )((unsigned int )tbd_addr + sizeof(tbd_t ));
  ias_addr = (unsigned short )((unsigned int )cfg_addr + sizeof(cfg));
  mcs_addr = (unsigned short )((unsigned int )ias_addr + sizeof(ias));
  tx.tx_h.ac_status = (unsigned short)65535;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_tx_t *)((void *)0 + (int )tx_addr))->tx_h.ac_status) -
                                        (void *)0), (unsigned char *)(& tx.tx_h.ac_status),
              (int )sizeof(tx.tx_h.ac_status));
  nop.nop_h.ac_status = (unsigned short)0;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_status) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_status),
              (int )sizeof(nop.nop_h.ac_status));
  nop.nop_h.ac_link = nop_addr;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_link) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_link),
              (int )sizeof(nop.nop_h.ac_link));
  __constant_c_and_count_memset((void *)(& cfg), 0UL, sizeof(cfg));
  cfg.cfg_byte_cnt = (unsigned char )((sizeof(ac_cfg_t ) - sizeof(ach_t )) & 15U);
  cfg.cfg_fifolim = (unsigned char)4;
  cfg.cfg_byte8 = (unsigned char)128;
  cfg.cfg_byte9 = (unsigned char)14;
  cfg.cfg_byte10 = (unsigned char)224;
  cfg.cfg_ifs = (unsigned char)32;
  cfg.cfg_slotl = (unsigned char)12;
  cfg.cfg_byte13 = (unsigned char)240;
  cfg.cfg_byte14 = (unsigned char )(8 | ((int )lp->promiscuous & 1));
  cfg.cfg_byte15 = (unsigned char)0;
  cfg.cfg_min_frm_len = (unsigned short)8;
  cfg.cfg_h.ac_command = (unsigned short)2;
  cfg.cfg_h.ac_link = ias_addr;
  obram_write(ioaddr, cfg_addr, (unsigned char *)(& cfg), (int )sizeof(cfg));
  __constant_c_and_count_memset((void *)(& ias), 0UL, sizeof(ias));
  ias.ias_h.ac_command = (unsigned short)1;
  ias.ias_h.ac_link = mcs_addr;
  __constant_memcpy((void *)(& ias.ias_addr[0]), (void const   *)(& dev->dev_addr[0]),
                    sizeof(ias.ias_addr));
  obram_write(ioaddr, ias_addr, (unsigned char *)(& ias), (int )sizeof(ias));
  __constant_c_and_count_memset((void *)(& mcs), 0UL, sizeof(mcs));
  mcs.mcs_h.ac_command = (unsigned short)8195;
  mcs.mcs_h.ac_link = nop_addr;
  mcs.mcs_cnt = (unsigned short )(6 * lp->mc_count);
  obram_write(ioaddr, mcs_addr, (unsigned char *)(& mcs), (int )sizeof(mcs));
  if (lp->mc_count) {
    dmi = dev->mc_list;
    while (dmi) {
      outsw((int )((unsigned short )((void *)(& ((ha_t *)((void *)0 + ioaddr))->ha_piop1) -
                                     (void *)0)), (void const   *)((u16 *)(dmi->dmi_addr)),
            3UL);
      dmi = dmi->next;
    }
  }
  nop_addr = (unsigned short )((unsigned int )txpred + sizeof(tx));
  nop.nop_h.ac_status = (unsigned short)0;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_status) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_status),
              (int )sizeof(nop.nop_h.ac_status));
  nop.nop_h.ac_link = cfg_addr;
  obram_write(ioaddr, (unsigned short )((void *)(& ((ac_nop_t *)((void *)0 + (int )nop_addr))->nop_h.ac_link) -
                                        (void *)0), (unsigned char *)(& nop.nop_h.ac_link),
              (int )sizeof(nop.nop_h.ac_link));
  lp->reconfig_82586 = (unsigned char)0;
  if ((int )lp->tx_first_in_use == 65535) {
    lp->tx_first_in_use = txblock;
  }
  if ((unsigned int )lp->tx_n_in_use == ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                          sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                         sizeof(ac_nop_t )) +
                                                                        sizeof(tbd_t )) +
                                                                       1514U) - 1U) {
    netif_stop_queue(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  wv_82586_stop(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  u16 scb_cmd ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  scb_cmd = (unsigned short)816;
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_command) -
                                        (void *)0), (unsigned char *)(& scb_cmd),
              (int )sizeof(scb_cmd));
  set_chan_attn(ioaddr, lp->hacr);
  wv_ints_off(dev);
  return;
}
}
static int wv_hw_reset(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long ioaddr ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  lp->nresets ++;
  wv_hacr_reset(ioaddr);
  lp->hacr = (unsigned short)53276;
  tmp = wv_mmc_init(dev);
  if (tmp < 0) {
    return (-1);
  } else {
    tmp___0 = wv_82586_start(dev);
    if (tmp___0 < 0) {
      return (-1);
    }
  }
  wv_ints_on(dev);
  tmp___1 = wv_cu_start(dev);
  if (tmp___1 < 0) {
    return (-1);
  }
  wv_82586_config(dev);
  tmp___2 = wv_ru_start(dev);
  if (tmp___2 < 0) {
    return (-1);
  }
  return (0);
}
}
static int wv_check_ioaddr(unsigned long ioaddr , unsigned char *mac ) 
{ int i ;
  struct resource *tmp ;

  {
  tmp = __request_region(& ioport_resource, ioaddr, (unsigned long )sizeof(ha_t ),
                         "wavelan probe");
  if (! tmp) {
    return (-16);
  }
  wv_hacr_reset(ioaddr);
  psa_read(ioaddr, (unsigned short)53276, (int )((unsigned short )((void *)(& ((psa_t *)((void *)0 +
                                                                                         0))->psa_univ_mac_addr) -
                                                                   (void *)0)), mac,
           6);
  __release_region(& ioport_resource, ioaddr, (unsigned long )sizeof(ha_t ));
  i = 0;
  while ((unsigned int )i < (sizeof(MAC_ADDRESSES) / sizeof(char )) / 3U) {
    if ((int )(*(mac + 0)) == (int )MAC_ADDRESSES[i][0]) {
      if ((int )(*(mac + 1)) == (int )MAC_ADDRESSES[i][1]) {
        if ((int )(*(mac + 2)) == (int )MAC_ADDRESSES[i][2]) {
          return (0);
        }
      }
    }
    i ++;
  }
  return (-19);
}
}
static irqreturn_t wavelan_interrupt(int irq___0 , void *dev_id , struct pt_regs *regs ) 
{ struct net_device *dev ;
  unsigned long ioaddr ;
  net_local *lp ;
  u16 hasr ;
  u16 status ;
  u16 ack_cmd ;
  u8 dce_status ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  dev = (struct net_device *)dev_id;
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  _spin_lock(& lp->spinlock);
  hasr = (u16 )hasr_read(ioaddr);
  if ((int )hasr & 2) {
    if ((int )lp->hacr & 64) {
      mmc_read(ioaddr, (unsigned char )((unsigned short )((void *)(& ((mmr_t *)((void *)0 +
                                                                                0))->mmr_dce_status) -
                                                          (void *)0)), & dce_status,
               (int )sizeof(dce_status));
      printk("<6>%s: wavelan_interrupt(): unexpected mmc interrupt: status 0x%04x.\n",
             dev->name, dce_status);
    }
  }
  if (((int )hasr & 1) == 0) {
    printk("<6>%s: wavelan_interrupt(): interrupt not coming from i82586 - hasr 0x%04x.\n",
           dev->name, hasr);
    _spin_unlock(& lp->spinlock);
    return (0);
  } else {
    if (((int )lp->hacr & 32) == 0) {
      printk("<6>%s: wavelan_interrupt(): interrupt not coming from i82586 - hasr 0x%04x.\n",
             dev->name, hasr);
      _spin_unlock(& lp->spinlock);
      return (0);
    }
  }
  obram_read(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                            sizeof(scp_t )) -
                                                                           sizeof(iscp_t )) -
                                                                          sizeof(scb_t ))))->scb_status) -
                                       (void *)0), (unsigned char *)(& status), (int )sizeof(status));
  ack_cmd = (unsigned short )((int )status & 61440);
  obram_write(ioaddr, (unsigned short )((void *)(& ((scb_t *)((void *)0 + (((65536U -
                                                                             sizeof(scp_t )) -
                                                                            sizeof(iscp_t )) -
                                                                           sizeof(scb_t ))))->scb_command) -
                                        (void *)0), (unsigned char *)(& ack_cmd),
              (int )sizeof(ack_cmd));
  set_chan_attn(ioaddr, lp->hacr);
  if (((int )status & 32768) == 32768) {
    wv_complete(dev, ioaddr, lp);
  }
  if (((int )status & 16384) == 16384) {
    wv_receive(dev);
  }
  if (((int )status & 8192) == 8192) {
    printk("<6>%s: wavelan_interrupt(): CU inactive -- restarting\n", dev->name);
    wv_hw_reset(dev);
  } else {
    if (((int )status & 1792) != 512) {
      tmp = netif_running((struct net_device  const  *)dev);
      if (tmp) {
        printk("<6>%s: wavelan_interrupt(): CU inactive -- restarting\n", dev->name);
        wv_hw_reset(dev);
      }
    }
  }
  if (((int )status & 4096) == 4096) {
    printk("<6>%s: wavelan_interrupt(): RU not ready -- restarting\n", dev->name);
    wv_hw_reset(dev);
  } else {
    if (((int )status & 112) != 64) {
      tmp___0 = netif_running((struct net_device  const  *)dev);
      if (tmp___0) {
        printk("<6>%s: wavelan_interrupt(): RU not ready -- restarting\n", dev->name);
        wv_hw_reset(dev);
      }
    }
  }
  _spin_unlock(& lp->spinlock);
  return (1);
}
}
static void wavelan_watchdog(struct net_device *dev ) 
{ net_local *lp ;
  u_long ioaddr ;
  unsigned long flags ;
  unsigned int nreaped ;

  {
  lp = (net_local *)dev->priv;
  ioaddr = dev->base_addr;
  printk("<6>%s: wavelan_watchdog: watchdog timer expired\n", dev->name);
  if (lp->tx_n_in_use <= 0) {
    return;
  }
  flags = _spin_lock_irqsave(& lp->spinlock);
  nreaped = (unsigned int )wv_complete(dev, ioaddr, lp);
  if (nreaped == 0U) {
    printk("<6>%s: wavelan_watchdog(): cleanup failed, trying reset\n", dev->name);
    wv_hw_reset(dev);
  }
  if ((unsigned int )lp->tx_n_in_use < ((((65536U - sizeof(scp_t )) - sizeof(iscp_t )) -
                                         sizeof(scb_t )) - 49152U) / (((sizeof(ac_tx_t ) +
                                                                        sizeof(ac_nop_t )) +
                                                                       sizeof(tbd_t )) +
                                                                      1514U) - 1U) {
    netif_wake_queue(dev);
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return;
}
}
static int wavelan_open(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;

  {
  lp = (net_local *)dev->priv;
  if (dev->irq == 0U) {
    printk("<4>%s: wavelan_open(): no IRQ\n", dev->name);
    return (-6);
  }
  tmp = request_irq(dev->irq, & wavelan_interrupt, 0UL, "WaveLAN", (void *)dev);
  if (tmp != 0) {
    printk("<4>%s: wavelan_open(): invalid IRQ\n", dev->name);
    return (-11);
  }
  flags = _spin_lock_irqsave(& lp->spinlock);
  tmp___0 = wv_hw_reset(dev);
  if (tmp___0 != -1) {
    netif_start_queue(dev);
  } else {
    free_irq(dev->irq, (void *)dev);
    printk("<6>%s: wavelan_open(): impossible to start the card\n", dev->name);
    _spin_unlock_irqrestore(& lp->spinlock, flags);
    return (-11);
  }
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  return (0);
}
}
static int wavelan_close(struct net_device *dev ) 
{ net_local *lp ;
  unsigned long flags ;

  {
  lp = (net_local *)dev->priv;
  netif_stop_queue(dev);
  flags = _spin_lock_irqsave(& lp->spinlock);
  wv_82586_stop(dev);
  _spin_unlock_irqrestore(& lp->spinlock, flags);
  free_irq(dev->irq, (void *)dev);
  return (0);
}
}
static int wavelan_config(struct net_device *dev , unsigned short ioaddr )  __attribute__((__section__(".init.text"))) ;
static int wavelan_config(struct net_device *dev , unsigned short ioaddr ) 
{ u8 irq_mask ;
  int irq___0 ;
  net_local *lp ;
  mac_addr mac ;
  int err ;
  struct resource *tmp ;
  spinlock_t __constr_expr_0 ;

  {
  tmp = __request_region(& ioport_resource, (unsigned long )ioaddr, (unsigned long )sizeof(ha_t ),
                         "wavelan");
  if (! tmp) {
    return (-98);
  }
  err = wv_check_ioaddr((unsigned long )ioaddr, mac);
  if (err) {
    goto out;
  }
  __constant_memcpy((void *)(dev->dev_addr), (void const   *)(mac), 6U);
  dev->base_addr = (unsigned long )ioaddr;
  if (dev->irq != 0U) {
    irq_mask = wv_irq_to_psa((int )dev->irq);
    if ((int )irq_mask == 0) {
      printk("<4>%s: wavelan_config(): invalid IRQ %d ignored.\n", dev->name, dev->irq);
      dev->irq = 0U;
    } else {
      psa_write((unsigned long )ioaddr, (unsigned short)53276, (int )((unsigned short )((void *)(& ((psa_t *)((void *)0 +
                                                                                                              0))->psa_int_req_no) -
                                                                                        (void *)0)),
                & irq_mask, 1);
      update_psa_checksum(dev, (unsigned long )ioaddr, (unsigned short)53276);
      wv_hacr_reset((unsigned long )ioaddr);
    }
  }
  psa_read((unsigned long )ioaddr, (unsigned short)53276, (int )((unsigned short )((void *)(& ((psa_t *)((void *)0 +
                                                                                                         0))->psa_int_req_no) -
                                                                                   (void *)0)),
           & irq_mask, 1);
  irq___0 = wv_psa_to_irq(irq_mask);
  if (irq___0 == -1) {
    printk("<6>%s: wavelan_config(): could not wavelan_map_irq(%d).\n", dev->name,
           irq_mask);
    err = -11;
    goto out;
  }
  dev->irq = (unsigned int )irq___0;
  dev->mem_start = 0UL;
  dev->mem_end = 0UL;
  dev->if_port = (unsigned char)0;
  __constant_c_and_count_memset(dev->priv, 0UL, sizeof(net_local ));
  lp = (net_local *)dev->priv;
  lp->dev = dev;
  lp->next = wavelan_list;
  wavelan_list = lp;
  lp->hacr = (unsigned short)53276;
  lp->promiscuous = (unsigned char)0;
  lp->mc_count = 0;
  while (1) {
    spin_lock_init(&__constr_expr_0);
    lp->spinlock = __constr_expr_0;
    break;
  }
  while (1) {
    break;
  }
  dev->open = & wavelan_open;
  dev->stop = & wavelan_close;
  dev->hard_start_xmit = & wavelan_packet_xmit;
  dev->get_stats = & wavelan_get_stats;
  dev->set_multicast_list = & wavelan_set_multicast_list;
  dev->tx_timeout = & wavelan_watchdog;
  dev->watchdog_timeo = 5120;
  dev->wireless_handlers = & wavelan_handler_def;
  lp->wireless_data.spy_data = & lp->spy_data;
  dev->wireless_data = & lp->wireless_data;
  dev->mtu = 1500U;
  wv_init_info(dev);
  return (0);
  out: 
  __release_region(& ioport_resource, (unsigned long )ioaddr, (unsigned long )sizeof(ha_t ));
  return (err);
}
}
struct net_device *wavelan_probe(int unit )  __attribute__((__section__(".init.text"))) ;
struct net_device *wavelan_probe(int unit ) 
{ struct net_device *dev ;
  short base_addr ;
  int def_irq ;
  int i ;
  int r ;
  struct net_device *tmp ;
  int tmp___0 ;
  struct net_device *tmp___1 ;

  {
  r = 0;
  dev = alloc_etherdev((int )sizeof(net_local ));
  if (! dev) {
    tmp = (struct net_device *)ERR_PTR(-12L);
    return (tmp);
  }
  sprintf(dev->name, "eth%d", unit);
  netdev_boot_setup_check(dev);
  base_addr = (short )dev->base_addr;
  def_irq = (int )dev->irq;
  if ((int )base_addr < 0) {
    printk("<4>%s: wavelan_probe(): invalid base address\n", dev->name);
    r = -6;
  } else {
    if ((int )base_addr > 256) {
      r = wavelan_config(dev, (unsigned short )base_addr);
    } else {
      i = 0;
      while ((unsigned int )i < sizeof(iobase) / sizeof(iobase[0])) {
        dev->irq = (unsigned int )def_irq;
        tmp___0 = wavelan_config(dev, iobase[i]);
        if (tmp___0 == 0) {
          break;
        }
        i ++;
      }
      if ((unsigned int )i == sizeof(iobase) / sizeof(iobase[0])) {
        r = -19;
      }
    }
  }
  if (r) {
    goto out;
  }
  r = register_netdev(dev);
  if (r) {
    goto out1;
  }
  return (dev);
  out1: 
  __release_region(& ioport_resource, dev->base_addr, (unsigned long )sizeof(ha_t ));
  wavelan_list = wavelan_list->next;
  out: 
  free_netdev(dev);
  tmp___1 = (struct net_device *)ERR_PTR((long )r);
  return (tmp___1);
}
}
int init_module(void) 
{ int ret ;
  int i ;
  struct net_device *dev ;
  struct net_device *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ret = -5;
  if (io[0] == 0) {
    printk("<4>WaveLAN init_module(): doing device probing (bad !)\n");
    printk("<4>Specify base addresses while loading module to correct the problem\n");
    i = 0;
    while ((unsigned int )i < sizeof(iobase) / sizeof(iobase[0])) {
      io[i] = (int )iobase[i];
      i ++;
    }
  }
  i = -1;
  while (1) {
    i ++;
    if (io[i] != 0) {
      if (! ((unsigned int )i < sizeof(io) / sizeof(io[0]))) {
        break;
      }
    } else {
      break;
    }
    tmp = alloc_etherdev((int )sizeof(net_local ));
    dev = tmp;
    if (! dev) {
      break;
    }
    if (name[i]) {
      strcpy(dev->name, (char const   *)name[i]);
    }
    dev->base_addr = (unsigned long )io[i];
    dev->irq = (unsigned int )irq[i];
    tmp___1 = wavelan_config(dev, (unsigned short )io[i]);
    if (tmp___1 == 0) {
      tmp___0 = register_netdev(dev);
      if (tmp___0 != 0) {
        __release_region(& ioport_resource, dev->base_addr, (unsigned long )sizeof(ha_t ));
        wavelan_list = wavelan_list->next;
      } else {
        ret = 0;
        continue;
      }
    }
    free_netdev(dev);
  }
  if (! wavelan_list) {
    printk("<4>WaveLAN init_module(): no device found\n");
  }
  return (ret);
}
}
void cleanup_module(void) 
{ struct net_device *dev ;

  {
  while (wavelan_list) {
    dev = wavelan_list->dev;
    unregister_netdev(dev);
    __release_region(& ioport_resource, dev->base_addr, (unsigned long )sizeof(ha_t ));
    wavelan_list = wavelan_list->next;
    free_netdev(dev);
  }
  return;
}
}
static char const   __mod_license4409[12]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
#pragma merger(0,"/tmp/cil-ZoHPKVqs.i","")
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64___0(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64___0(__u64 val ) 
{ union __anonunion_v_7___0 v ;

  {
  v.u = val;
  __asm__  ("bswapl %0 ; bswapl %1 ; xchgl %0,%1": "=r" (v.s.a), "=r" (v.s.b): "0" (v.s.a),
            "1" (v.s.b));
  return (v.u);
}
}
__inline static __u64 __attribute__((__always_inline__))  __fswab64___0(__u64 x )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  __fswab64___0(__u64 x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64___0(x);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __swab64p___0(__u64 const   *x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64___0((*x));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __swab64s___0(__u64 *addr ) 
{ 

  {
  while (1) {
    (*addr) = (__u64 )___arch__swab64___0((*addr));
    break;
  }
  return;
}
}
__inline static __be64 __attribute__((__always_inline__))  __cpu_to_be64p___0(__u64 const   *p ) 
{ __be64 tmp ;

  {
  tmp = (__be64 )__swab64p___0(p);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __be64_to_cpup___0(__be64 const   *p ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab64p___0((__u64 const   *)((__u64 *)p));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  set_in_cr4___0(unsigned long mask ) 
{ 

  {
  mmu_cr4_features = mmu_cr4_features | mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "orl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  clear_in_cr4___0(unsigned long mask ) 
{ 

  {
  mmu_cr4_features = mmu_cr4_features & ~ mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "andl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (~ mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  write_seqlock___0(seqlock_t *sl ) 
{ 

  {
  _spin_lock(& sl->lock);
  sl->sequence = sl->sequence + 1U;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_sequnlock___0(seqlock_t *sl ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  sl->sequence = sl->sequence + 1U;
  _spin_unlock(& sl->lock);
}
}
__inline static int __attribute__((__always_inline__))  write_tryseqlock___0(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  tmp = _spin_trylock(& sl->lock);
  ret = tmp;
  if (ret) {
    sl->sequence = sl->sequence + 1U;
    __asm__  volatile   ("": : : "memory");
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_begin___0(seqcount_t *s ) 
{ 

  {
  s->sequence = s->sequence + 1U;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_end___0(seqcount_t *s ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  s->sequence = s->sequence + 1U;
}
}
__inline static void __attribute__((__always_inline__))  jiffies_to_timeval___0(unsigned long jiffies___0 ,
                                                                                struct timeval *value ) 
{ u64 nsec ;

  {
  nsec = (unsigned long long )jiffies___0 * 999848ULL;
  value->tv_sec = (time_t )div_ll_X_l_rem__extinline((long long )nsec, 1000000000L,
                                                     & value->tv_usec);
  value->tv_usec = value->tv_usec / 1000L;
  return;
}
}
__inline static void __attribute__((__always_inline__))  add_wait_queue_exclusive_locked___0(wait_queue_head_t *q ,
                                                                                             wait_queue_t *wait ) 
{ 

  {
  wait->flags = wait->flags | 1U;
  __add_wait_queue_tail(q, wait);
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigaddsetmask___0(sigset_t *set ,
                                                                           unsigned long mask ) 
{ 

  {
  set->sig[0] = set->sig[0] | mask;
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigdelsetmask___0(sigset_t *set ,
                                                                           unsigned long mask ) 
{ 

  {
  set->sig[0] = set->sig[0] & ~ mask;
  return;
}
}
__inline static int __attribute__((__always_inline__))  capable___0(int cap ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp___0 = get_current();
  if (tmp___0->cap_effective & (unsigned int )(1 << cap)) {
    tmp = get_current();
    tmp->flags = tmp->flags | 256UL;
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
static char const   __mod_vermagic5[32]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'g',      (char const   )'i',      (char const   )'c', 
        (char const   )'=',      (char const   )'2',      (char const   )'.',      (char const   )'6', 
        (char const   )'.',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'S',      (char const   )'M',      (char const   )'P',      (char const   )' ', 
        (char const   )'6',      (char const   )'8',      (char const   )'6',      (char const   )' ', 
        (char const   )'g',      (char const   )'c',      (char const   )'c',      (char const   )'-', 
        (char const   )'3',      (char const   )'.',      (char const   )'2',      (char const   )'\000'};
struct module __this_module  __attribute__((__section__(".gnu.linkonce.this_module")))  = 
     {0, {(struct list_head *)0, (struct list_head *)0}, {(char )'w', (char )'a', (char )'v',
                                                        (char )'e', (char )'l', (char )'a',
                                                        (char )'n', (char )'\000'},
    {{(char *)0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                  (char)0, (char)0, (char)0, (char)0}, {{0}}, {(struct list_head *)0,
                                                               (struct list_head *)0},
      (struct kobject *)0, (struct kset *)0, (struct kobj_type *)0, (struct dentry *)0},
     (struct module *)0}, (struct module_param_attrs *)0, (struct kernel_symbol  const  *)0,
    0U, (unsigned long const   *)0, (struct kernel_symbol  const  *)0, 0U, (unsigned long const   *)0,
    0U, (struct exception_table_entry  const  *)0, & init_module, (void *)0, (void *)0,
    0UL, 0UL, 0UL, 0UL, {}, 0, 0, (Elf32_Sym *)0, 0UL, (char *)0, (struct module_sect_attrs *)0,
    (void *)0, (char *)0};
static struct modversion_info  const  ____versions[]  __attribute__((__unused__, __section__("__versions")))  = { };
static char const   __module_depends[9]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'s',      (char const   )'=', 
        (char const   )'\000'};

/* ---------------------------------------------------------------------- */

/* SAMPLE MAIN() function to "drive the driver" based on reading of
   Linux kernel code (2.6.11).  Pseudo-main() uses three functions:
   module initialization in module_loaded (single-threaded), usage in
   module_activity (multi-threaded), and cleanup in module_cleanup
   (multi-threaded). */

/* ---------------------------------------------------------------------- */

/* This is code that pretends to be the kernel. */

/* As far as I can tell, net_device objects are shared, so that 
   multiple driver calls might access them at once (or even
   elsewhere in the kernel), but that the saving grace is
   many fields are immutable.  So: no lock for this. */
struct net_device *dummydev;

/* Dummy version of kernel function needed to initialize
   the spin locks in the net_device struct */
int register_netdev(struct net_device *dev)
{
  spin_lock_init(&dev->queue_lock);
  spin_lock_init(&dev->xmit_lock);
  dummydev = dev;
  return 0;
}

/* Dummy version of kernel function to allocate the device struct.
   In reality, this is one chunk of memory with the private data
   adjacent to the net_device struct, but we're faking it here. */
struct net_device * __attribute__((unique)) alloc_etherdev(int ign) {
  struct net_device *dev = kmalloc(sizeof(struct net_device),0);
  struct net_local *priv = kmalloc(sizeof(struct net_local),0);
  dev->priv = (void *)priv;
  return dev;
}

/* Code that's called once the module is known to the system;
   could occur in multiple threads.  Simulates the call from
   dev_queue_xmit in net/core/dev.c. */

static void xmit_packet() {
  struct sk_buff *skb = kmalloc(sizeof(struct sk_buff),0); /* thread-local */
  skb->dev = dummydev;
  spin_lock(dummydev->xmit_lock);
  wavelan_packet_xmit(skb,dummydev);
  spin_unlock(dummydev->xmit_lock);
  /* Simulates a timer expiring */
  wavelan_watchdog(dummydev);
} 

static void get_stats() {
  struct net_device_stats *stats;
  stats = wavelan_get_wireless_stats(dummydev);
  /* TODO: print the stats here, so that the fields are dereffed?
     If bug arises due to this, is it a problem with the driver
     or the kernel? */
}

static void recv_packet() {
  wavelan_interrupt(0,dummydev,0);
  wavelan_watchdog(dummydev);
}

static void module_activity() {
  wv_hw_reset(dummydev);
  wavelan_open(dummydev);
  xmit_packet();
  recv_packet(); /* simulates interrupt handler */
  get_stats();
  wavelan_close(dummydev);
}

typedef int pthread_t;

int main() {
  pthread_t t;
  init_module();
  /* NOTE: I'm not calling wavelan_probe; I don't think it gets
     used when the driver is a module, but I'm not sure. */
  pthread_create(&t, (void*)0, module_activity, (void*)0);
  pthread_create(&t, (void*)0, module_activity, (void*)0);
  /* TODO: make this a join()? */
  cleanup_module();
}
