/* Generated by CIL v. 1.3.2 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.5-20050130/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 136 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.5-20050130/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
#line 105 "/usr/lib/gcc-lib/i686-pc-linux-gnu/3.3.5-20050130/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 26 "/usr/include/bits/pthreadtypes.h"
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
#line 35
struct _pthread_descr_struct;
#line 35 "/usr/include/bits/pthreadtypes.h"
typedef struct _pthread_descr_struct *_pthread_descr;
#line 86 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct_pthread_mutex_t_16 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
#line 86 "/usr/include/bits/pthreadtypes.h"
typedef struct __anonstruct_pthread_mutex_t_16 pthread_mutex_t;
#line 138 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 301 "../shared/output.c"
struct facstruct {
   char const   *name ;
   int code ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 32 "../shared/cfgparser.h"
struct cfgoption {
   char const   *name ;
   int argtype ;
};
#line 37 "../shared/cfgparser.h"
struct cfgstruct {
   char *optname ;
   char *strarg ;
   int numarg ;
   struct cfgstruct *nextarg ;
   struct cfgstruct *next ;
};
#line 173 "../libclamav/clamav.h"
struct cl_cvd {
   char *time ;
   int version ;
   int sigs ;
   short fl ;
   char *md5 ;
   char *dsig ;
   char *builder ;
   int stime ;
};
#line 153 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 56 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 22 "../clamscan/options.h"
struct optnode {
   char optchar ;
   char *optarg ;
   char *optname ;
   struct optnode *next ;
};
#line 29 "../clamscan/options.h"
struct optstruct {
   struct optnode *optlist ;
   char *filename ;
};
#line 194 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 243 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) -
                                  sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 94 "../shared/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 91 "clamav.h"
struct cli_bm_patt {
   char *pattern ;
   char *virname ;
   char *offset ;
   char const   *viralias ;
   unsigned int length ;
   unsigned short target ;
   struct cli_bm_patt *next ;
};
#line 99 "clamav.h"
struct cli_ac_patt {
   short *pattern ;
   unsigned int length ;
   unsigned int mindist ;
   unsigned int maxdist ;
   char *virname ;
   char *offset ;
   char const   *viralias ;
   unsigned short sigid ;
   unsigned short parts ;
   unsigned short partno ;
   unsigned short alt ;
   unsigned short *altn ;
   unsigned short type ;
   unsigned short target ;
   char **altc ;
   struct cli_ac_patt *next ;
};
#line 110 "clamav.h"
struct cli_ac_node {
   char islast ;
   struct cli_ac_patt *list ;
   struct cli_ac_node *trans[256] ;
   struct cli_ac_node *fail ;
};
#line 116 "clamav.h"
struct cli_md5_node {
   char *virname ;
   char *viralias ;
   unsigned char *md5 ;
   unsigned int size ;
   unsigned short fp ;
   struct cli_md5_node *next ;
};
#line 124 "clamav.h"
struct cli_meta_node {
   int csize ;
   int size ;
   int method ;
   unsigned int crc32 ;
   unsigned int fileno ;
   unsigned int encrypted ;
   unsigned int maxdepth ;
   char *filename ;
   char *virname ;
   struct cli_meta_node *next ;
};
#line 131 "clamav.h"
struct cl_node {
   unsigned int refcount ;
   unsigned int maxpatlen ;
   int *bm_shift ;
   struct cli_bm_patt **bm_suffix ;
   struct cli_ac_node *ac_root ;
   struct cli_ac_node **ac_nodetable ;
   unsigned int ac_partsigs ;
   unsigned int ac_nodes ;
   struct cli_md5_node **md5_hlist ;
   struct cli_meta_node *zip_mlist ;
   struct cli_meta_node *rar_mlist ;
};
#line 42 "matcher-ac.c"
struct nodelist {
   struct cli_ac_node *node ;
   struct nodelist *next ;
};
#line 13 "md5.h"
typedef unsigned long MD5_u32plus;
#line 15 "md5.h"
struct __anonstruct_MD5_CTX_22 {
   MD5_u32plus lo ;
   MD5_u32plus hi ;
   MD5_u32plus a ;
   MD5_u32plus b ;
   MD5_u32plus c ;
   MD5_u32plus d ;
   unsigned char buffer[64] ;
   MD5_u32plus block[16] ;
};
#line 15 "md5.h"
typedef struct __anonstruct_MD5_CTX_22 MD5_CTX;
#line 24 "rebuildpe.h"
struct SECTION {
   uint32_t rva ;
   uint32_t vsz ;
   uint32_t raw ;
   uint32_t rsz ;
};
#line 97 "pe.h"
struct cli_pe_info {
   uint32_t ep ;
   uint16_t nsections ;
   struct SECTION *section ;
};
#line 147 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 193 "/usr/include/sys/types.h"
typedef int int32_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 166 "clamav.h"
struct cl_stat {
   char *dir ;
   int no ;
   struct stat *stattab ;
   char **statdname ;
};
#line 274 "/usr/include/zconf.h"
typedef void *voidp;
#line 933 "/usr/include/zlib.h"
typedef voidp gzFile;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 242 "mspack/mspack.h"
struct mspack_file;
#line 242 "mspack/mspack.h"
struct mspack_system {
   struct mspack_file *(*open)(struct mspack_system *this , char *filename , int mode ) ;
   struct mspack_file *(*dopen)(struct mspack_system *this , int desc , int mode ) ;
   void (*close)(struct mspack_file *file ) ;
   int (*read)(struct mspack_file *file , void *buffer , int bytes ) ;
   int (*write)(struct mspack_file *file , void *buffer , int bytes ) ;
   int (*seek)(struct mspack_file *file , off_t offset , int mode ) ;
   off_t (*tell)(struct mspack_file *file ) ;
   void (*message)(struct mspack_file *file , char *format  , ...) ;
   void *(*alloc)(struct mspack_system *this , size_t bytes ) ;
   void (*free)(void *ptr ) ;
   void (*copy)(void *src , void *dest , size_t bytes ) ;
   void *null_ptr ;
};
#line 436 "mspack/mspack.h"
struct mspack_file {
   int dummy ;
};
#line 480
struct mscab_decompressor;
#line 632
struct mscabd_file;
#line 632
struct mscabd_folder;
#line 632 "mspack/mspack.h"
struct mscabd_cabinet {
   struct mscabd_cabinet *next ;
   char *filename ;
   int desc ;
   off_t base_offset ;
   unsigned int length ;
   struct mscabd_cabinet *prevcab ;
   struct mscabd_cabinet *nextcab ;
   char *prevname ;
   char *nextname ;
   char *previnfo ;
   char *nextinfo ;
   struct mscabd_file *files ;
   struct mscabd_folder *folders ;
   unsigned short set_id ;
   unsigned short set_index ;
   unsigned short header_resv ;
   int flags ;
};
#line 742 "mspack/mspack.h"
struct mscabd_folder {
   struct mscabd_folder *next ;
   int comp_type ;
   unsigned int num_blocks ;
};
#line 799 "mspack/mspack.h"
struct mscabd_file {
   struct mscabd_file *next ;
   char *filename ;
   unsigned int length ;
   int attribs ;
   char time_h ;
   char time_m ;
   char time_s ;
   char date_d ;
   char date_m ;
   int date_y ;
   struct mscabd_folder *folder ;
   unsigned int offset ;
};
#line 886 "mspack/mspack.h"
struct mscab_decompressor {
   struct mscabd_cabinet *(*open)(struct mscab_decompressor *this , char *filename ) ;
   struct mscabd_cabinet *(*dopen)(struct mscab_decompressor *this , int desc ) ;
   void (*close)(struct mscab_decompressor *this , struct mscabd_cabinet *cab ) ;
   struct mscabd_cabinet *(*search)(struct mscab_decompressor *this , char *filename ) ;
   struct mscabd_cabinet *(*dsearch)(struct mscab_decompressor *this , int desc ) ;
   int (*append)(struct mscab_decompressor *this , struct mscabd_cabinet *cab , struct mscabd_cabinet *nextcab ) ;
   int (*prepend)(struct mscab_decompressor *this , struct mscabd_cabinet *cab , struct mscabd_cabinet *prevcab ) ;
   int (*extract)(struct mscab_decompressor *this , struct mscabd_file *file , char *filename ) ;
   int (*set_param)(struct mscab_decompressor *this , int param , int value ) ;
   int (*last_error)(struct mscab_decompressor * ) ;
};
#line 131 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 154 "clamav.h"
struct cl_limits {
   unsigned int maxreclevel ;
   unsigned int maxfiles ;
   unsigned int maxratio ;
   unsigned short archivememlim ;
   unsigned long maxfilesize ;
};
#line 103 "unrarlib.h"
typedef unsigned char UBYTE;
#line 104 "unrarlib.h"
typedef unsigned short UWORD;
#line 105 "unrarlib.h"
typedef unsigned long UDWORD;
#line 111 "unrarlib.h"
struct RAR20_archive_entry {
   char *Name ;
   UWORD NameSize ;
   UDWORD PackSize ;
   UDWORD UnpSize ;
   UBYTE HostOS ;
   UDWORD FileCRC ;
   UDWORD FileTime ;
   UBYTE UnpVer ;
   UBYTE Method ;
   UDWORD FileAttr ;
   UWORD Flags ;
};
#line 126 "unrarlib.h"
struct archivelist {
   struct RAR20_archive_entry item ;
   struct archivelist *next ;
};
#line 126 "unrarlib.h"
typedef struct archivelist ArchiveList_struct;
#line 28 "vba_extract.h"
struct vba_project_tag {
   int count ;
   char **name ;
   uint32_t *offset ;
   uint32_t *length ;
   unsigned char *key ;
   char *dir ;
};
#line 28 "vba_extract.h"
typedef struct vba_project_tag vba_project_t;
#line 26 "filetypes.h"
enum __anonenum_cli_file_t_36 {
    CL_TYPE_UNKNOWN_TEXT = 500,
    CL_TYPE_UNKNOWN_DATA = 501,
    CL_TYPE_MSEXE = 502,
    CL_TYPE_DATA = 503,
    CL_TYPE_POSIX_TAR = 504,
    CL_TYPE_OLD_TAR = 505,
    CL_TYPE_GZ = 506,
    CL_TYPE_ZIP = 507,
    CL_TYPE_BZ = 508,
    CL_TYPE_RAR = 509,
    CL_TYPE_MSSZDD = 510,
    CL_TYPE_MSOLE2 = 511,
    CL_TYPE_MSCAB = 512,
    CL_TYPE_MSCHM = 513,
    CL_TYPE_SCRENC = 514,
    CL_TYPE_GRAPHICS = 515,
    CL_TYPE_RIFF = 516,
    CL_TYPE_BINHEX = 517,
    CL_TYPE_TNEF = 518,
    CL_TYPE_HTML = 519,
    CL_TYPE_MAIL = 520
};
#line 26 "filetypes.h"
typedef enum __anonenum_cli_file_t_36 cli_file_t;
#line 22 "htmlnorm.h"
struct tag_arguments_tag {
   int count ;
   unsigned char **tag ;
   unsigned char **value ;
};
#line 22 "htmlnorm.h"
typedef struct tag_arguments_tag tag_arguments_t;
#line 43 "zziplib/zziplib.h"
enum __anonenum_zzip_error_t_37 {
    ZZIP_NO_ERROR = 0,
    ZZIP_OUTOFMEM = -4116,
    ZZIP_DIR_OPEN = -4117,
    ZZIP_DIR_STAT = -4118,
    ZZIP_DIR_SEEK = -4119,
    ZZIP_DIR_READ = -4120,
    ZZIP_DIR_TOO_SHORT = -4121,
    ZZIP_DIR_EDH_MISSING = -4122,
    ZZIP_DIRSIZE = -4123,
    ZZIP_ENOENT = -4124,
    ZZIP_UNSUPP_COMPR = -4125,
    ZZIP_CORRUPTED = -4127,
    ZZIP_UNDEF = -4128
};
#line 43 "zziplib/zziplib.h"
typedef enum __anonenum_zzip_error_t_37 zzip_error_t;
#line 87 "zziplib/zziplib.h"
typedef char const   * const  zzip_strings_t;
#line 88 "zziplib/zziplib.h"
typedef char const   zzip_char_t;
#line 89 "zziplib/zziplib.h"
typedef off_t zzip_off_t;
#line 90 "zziplib/zziplib.h"
typedef size_t zzip_size_t;
#line 91 "zziplib/zziplib.h"
typedef ssize_t zzip_ssize_t;
#line 92
struct zzip_dir;
#line 92 "zziplib/zziplib.h"
typedef struct zzip_dir ZZIP_DIR;
#line 93
struct zzip_file;
#line 93 "zziplib/zziplib.h"
typedef struct zzip_file ZZIP_FILE;
#line 94
struct zzip_dirent;
#line 94 "zziplib/zziplib.h"
typedef struct zzip_dirent ZZIP_DIRENT;
#line 97 "zziplib/zziplib.h"
struct zzip_dirent {
   int d_compr ;
   int d_csize ;
   int st_size ;
   unsigned short d_flags ;
   char *d_name ;
   int d_crc32 ;
};
#line 247
struct zzip_plugin_io;
#line 247 "zziplib/zziplib.h"
typedef struct zzip_plugin_io  const  *zzip_plugin_io_t;
#line 42 "zziplib/zzip-io.h"
struct zzip_plugin_io {
   int (*open)(zzip_char_t *name , int flags  , ...) ;
   int (*close)(int fd ) ;
   int (*read)(int fd , void *buf , unsigned int len ) ;
   zzip_off_t (*seeks)(int fd , zzip_off_t offset , int whence ) ;
   zzip_off_t (*filesize)(int fd ) ;
   long use_mmap ;
};
#line 28 "zziplib/zzip.h"
struct zzip_dir_hdr {
   uint32_t d_usize ;
   uint32_t d_csize ;
   uint32_t d_crc32 ;
   uint32_t d_off ;
   uint16_t d_reclen ;
   uint16_t d_namlen ;
   uint8_t d_compr ;
   uint16_t d_flags ;
   char d_name[1] ;
};
#line 47 "zziplib/zzip.h"
struct __anonstruct_cache_38 {
   struct zzip_file *fp ;
   char *buf32k ;
};
#line 47 "zziplib/zzip.h"
struct zzip_dir {
   int fd ;
   int errcode ;
   long refcount ;
   struct __anonstruct_cache_38 cache ;
   struct zzip_dir_hdr *hdr0 ;
   struct zzip_dir_hdr *hdr ;
   struct zzip_file *currentfp ;
   struct zzip_dirent dirent ;
   void *realdir ;
   char *realname ;
   zzip_strings_t *fileext ;
   zzip_plugin_io_t io ;
};
#line 177 "/usr/include/bzlib.h"
typedef void BZFILE;
#line 34 "filetypes.c"
struct cli_magic_s {
   int offset ;
   char const   *magic ;
   size_t length ;
   char const   *descr ;
   cli_file_t type ;
};
#line 42 "filetypes.c"
struct cli_smagic_s {
   char const   *sig ;
   char const   *descr ;
   cli_file_t type ;
};
#line 140 "unrarlib.c"
typedef long DWORD;
#line 141 "unrarlib.c"
typedef short BOOL;
#line 247 "unrarlib.c"
struct MarkHeader {
   UBYTE Mark[7] ;
};
#line 253 "unrarlib.c"
struct NewMainArchiveHeader {
   UWORD HeadCRC ;
   UBYTE HeadType ;
   UWORD Flags ;
   UWORD HeadSize ;
   UWORD Reserved ;
   UDWORD Reserved1 ;
};
#line 264 "unrarlib.c"
struct NewFileHeader {
   UWORD HeadCRC ;
   UBYTE HeadType ;
   UWORD Flags ;
   UWORD HeadSize ;
   UDWORD PackSize ;
   UDWORD UnpSize ;
   UBYTE HostOS ;
   UDWORD FileCRC ;
   UDWORD FileTime ;
   UBYTE UnpVer ;
   UBYTE Method ;
   UWORD NameSize ;
   UDWORD FileAttr ;
};
#line 282 "unrarlib.c"
struct BlockHeader {
   UWORD HeadCRC ;
   UBYTE HeadType ;
   UWORD Flags ;
   UWORD HeadSize ;
   UDWORD DataSize ;
};
#line 292 "unrarlib.c"
struct Decode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[2] ;
};
#line 1281 "unrarlib.c"
struct AudioVariables {
   int K1 ;
   int K2 ;
   int K3 ;
   int K4 ;
   int K5 ;
   int D1 ;
   int D2 ;
   int D3 ;
   int D4 ;
   int LastDelta ;
   unsigned int Dif[11] ;
   unsigned int ByteCount ;
   int LastChar ;
};
#line 1328 "unrarlib.c"
struct LitDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[298] ;
};
#line 1336 "unrarlib.c"
struct DistDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[48] ;
};
#line 1344 "unrarlib.c"
struct RepDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[28] ;
};
#line 1352 "unrarlib.c"
struct MultDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[257] ;
};
#line 1360 "unrarlib.c"
struct BitDecode {
   unsigned int MaxNum ;
   unsigned int DecodeLen[16] ;
   unsigned int DecodePos[16] ;
   unsigned int DecodeNum[19] ;
};
#line 255 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 257 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 258 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 264 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 273 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 1189 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 63 "zziplib/zzip-file.h"
struct zzip_file {
   struct zzip_dir *dir ;
   int fd ;
   int method ;
   zzip_size_t restlen ;
   zzip_size_t crestlen ;
   zzip_size_t usize ;
   zzip_size_t csize ;
   zzip_off_t dataoffset ;
   char *buf32k ;
   zzip_off_t offset ;
   z_stream d_stream ;
   zzip_plugin_io_t io ;
};
#line 26 "zziplib/zzip-err.c"
struct errlistentry {
   int code ;
   char const   *mesg ;
};
#line 92 "zziplib/zzip-err.c"
struct errnolistentry {
   int code ;
   int e_no ;
};
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 29 "zziplib/zzipformat.h"
struct zzip_version {
   char version[1] ;
   char ostype[1] ;
} __attribute__((__packed__)) ;
#line 35 "zziplib/zzipformat.h"
struct zzip_dostime {
   char time[2] ;
   char date[2] ;
} __attribute__((__packed__)) ;
#line 48 "zziplib/zzipformat.h"
struct zzip_file_header {
   char z_magic[4] ;
   struct zzip_version z_extract ;
   char z_flags[2] ;
   char z_compr[2] ;
   struct zzip_dostime z_dostime ;
   char z_crc32[4] ;
   char z_csize[4] ;
   char z_usize[4] ;
   char z_namlen[2] ;
   char z_extras[2] ;
} __attribute__((__packed__)) ;
#line 95 "zziplib/zziplib.h"
typedef struct zzip_dirent ZZIP_STAT;
#line 89 "zziplib/zzipformat.h"
struct zzip_root_dirent {
   char z_magic[4] ;
   struct zzip_version z_encoder ;
   struct zzip_version z_extract ;
   char z_flags[2] ;
   char z_compr[2] ;
   struct zzip_dostime z_dostime ;
   char z_crc32[4] ;
   char z_csize[4] ;
   char z_usize[4] ;
   char z_namlen[2] ;
   char z_extras[2] ;
   char z_comment[2] ;
   char z_diskstart[2] ;
   char z_filetype[2] ;
   char z_filemode[4] ;
   char z_off[4] ;
} __attribute__((__packed__)) ;
#line 115 "zziplib/zzipformat.h"
struct zzip_disk_trailer {
   char z_magic[4] ;
   char z_disk[2] ;
   char z_finaldisk[2] ;
   char z_entries[2] ;
   char z_finalentries[2] ;
   char z_rootsize[4] ;
   char z_rootseek[4] ;
   char z_comment[2] ;
} __attribute__((__packed__)) ;
#line 27 "blob.h"
struct blob {
   char *name ;
   unsigned char *data ;
   unsigned long len ;
   unsigned long size ;
   int isClosed ;
};
#line 27 "blob.h"
typedef struct blob blob;
#line 53 "blob.h"
struct fileblob {
   FILE *fp ;
   blob b ;
   int isNotEmpty ;
};
#line 53 "blob.h"
typedef struct fileblob fileblob;
#line 331 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 83 "/usr/include/bits/sched.h"
struct __sched_param {
   int __sched_priority ;
};
#line 41 "/usr/include/bits/pthreadtypes.h"
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
#line 41 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_attr_s pthread_attr_t;
#line 150 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 22 "table.h"
struct tableEntry {
   char *key ;
   int value ;
   struct tableEntry *next ;
};
#line 22 "table.h"
typedef struct tableEntry tableEntry;
#line 28 "table.h"
struct table {
   tableEntry *tableHead ;
   tableEntry *tableLast ;
};
#line 28 "table.h"
typedef struct table table_t;
#line 20 "mbox.h"
enum __anonenum_mime_type_31 {
    NOMIME = 0,
    APPLICATION = 1,
    AUDIO = 2,
    IMAGE = 3,
    MESSAGE = 4,
    MULTIPART = 5,
    TEXT = 6,
    VIDEO = 7,
    MEXTENSION = 8
};
#line 20 "mbox.h"
typedef enum __anonenum_mime_type_31 mime_type;
#line 24
enum __anonenum_encoding_type_32 {
    NOENCODING = 0,
    QUOTEDPRINTABLE = 1,
    BASE64 = 2,
    EIGHTBIT = 3,
    BINARY = 4,
    UUENCODE = 5,
    YENCODE = 6,
    EEXTENSION = 7,
    BINHEX = 8
};
#line 24 "mbox.h"
typedef enum __anonenum_encoding_type_32 encoding_type;
#line 44 "line.h"
typedef char line_t;
#line 36 "text.h"
struct text {
   line_t *t_line ;
   struct text *t_next ;
};
#line 36 "text.h"
typedef struct text text;
#line 22 "message.h"
struct message {
   mime_type mimeType ;
   encoding_type *encodingTypes ;
   int numberOfEncTypes ;
   char *mimeSubtype ;
   int numberOfArguments ;
   char **mimeArguments ;
   char *mimeDispositionType ;
   text *body_first ;
   text *body_last ;
   char base64_1 ;
   char base64_2 ;
   char base64_3 ;
   int base64chars ;
   text const   *bounce ;
   text const   *binhex ;
   text const   *uuencode ;
   text const   *yenc ;
   text const   *encoding ;
   text const   *dedupedThisFar ;
};
#line 22 "message.h"
typedef struct message message;
#line 99 "mbox.c"
enum __anonenum_bool_35 {
    FALSE = 0,
    TRUE = 1
};
#line 99 "mbox.c"
typedef enum __anonenum_bool_35 bool;
#line 44 "/usr/include/curl/curl.h"
typedef void CURL;
#line 123
struct curl_slist;
#line 238
enum __anonenum_CURLcode_39 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_URL_MALFORMAT_USER = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_FTP_WEIRD_SERVER_REPLY = 8,
    CURLE_FTP_ACCESS_DENIED = 9,
    CURLE_FTP_USER_PASSWORD_INCORRECT = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_WEIRD_USER_REPLY = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_FTP_CANT_RECONNECT = 16,
    CURLE_FTP_COULDNT_SET_BINARY = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_FTP_WRITE_ERROR = 20,
    CURLE_FTP_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_MALFORMAT_USER = 24,
    CURLE_FTP_COULDNT_STOR_FILE = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEOUTED = 28,
    CURLE_FTP_COULDNT_SET_ASCII = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_FTP_COULDNT_GET_SIZE = 32,
    CURLE_HTTP_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_LIBRARY_NOT_FOUND = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_BAD_CALLING_ORDER = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_BAD_PASSWORD_ENTERED = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_TELNET_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE = 50,
    CURLE_SSL_PEER_CERTIFICATE = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_SHARE_IN_USE = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_SSL_CACERT = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_FTP_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURL_LAST = 68
};
#line 238 "/usr/include/curl/curl.h"
typedef enum __anonenum_CURLcode_39 CURLcode;
#line 421
enum __anonenum_CURLoption_43 {
    CURLOPT_FILE = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_INFILE = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_SSLCERTPASSWD = 10026,
    CURLOPT_SSLKEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_WRITEHEADER = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_WRITEINFO = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_FTPLISTONLY = 48,
    CURLOPT_FTPAPPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRB4LEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_CLOSEPOLICY = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_FTP_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_SOURCE_USERPWD = 10123,
    CURLOPT_SOURCE_PREQUOTE = 10127,
    CURLOPT_SOURCE_POSTQUOTE = 10128,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_SOURCE_URL = 10132,
    CURLOPT_SOURCE_QUOTE = 10133,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_LASTENTRY = 10135
};
#line 421 "/usr/include/curl/curl.h"
typedef enum __anonenum_CURLoption_43 CURLoption;
#line 1174 "/usr/include/curl/curl.h"
struct curl_slist {
   char *data ;
   struct curl_slist *next ;
};
#line 198 "mbox.c"
struct arg {
   char const   *url ;
   char const   *dir ;
   char *filename ;
};
#line 258 "mbox.c"
struct tableinit {
   char const   *key ;
   int value ;
};
#line 87 "message.c"
struct encoding_map {
   char const   *string ;
   encoding_type type ;
};
#line 106 "message.c"
struct mime_map {
   char const   *string ;
   mime_type type ;
};
#line 2382
enum __anonenum_field_35 {
    LANGUAGE = 0,
    CHARSET = 1,
    CONTENTS = 2
};
#line 2464 "message.c"
struct pstr_list {
   char *d1 ;
   struct pstr_list *next ;
};
#line 2473 "message.c"
typedef struct pstr_list ELEMENT1;
#line 2474 "message.c"
typedef ELEMENT1 *LINK1;
#line 192 "/usr/include/sys/types.h"
typedef short int16_t;
#line 84 "ole2_extract.c"
struct ole2_header_tag {
   unsigned char magic[8]  __attribute__((__packed__)) ;
   unsigned char clsid[16]  __attribute__((__packed__)) ;
   uint16_t minor_version  __attribute__((__packed__)) ;
   uint16_t dll_version  __attribute__((__packed__)) ;
   int16_t byte_order  __attribute__((__packed__)) ;
   uint16_t log2_big_block_size  __attribute__((__packed__)) ;
   uint32_t log2_small_block_size  __attribute__((__packed__)) ;
   int32_t reserved[2]  __attribute__((__packed__)) ;
   int32_t bat_count  __attribute__((__packed__)) ;
   int32_t prop_start  __attribute__((__packed__)) ;
   uint32_t signature  __attribute__((__packed__)) ;
   uint32_t sbat_cutoff  __attribute__((__packed__)) ;
   int32_t sbat_start  __attribute__((__packed__)) ;
   int32_t sbat_block_count  __attribute__((__packed__)) ;
   int32_t xbat_start  __attribute__((__packed__)) ;
   int32_t xbat_count  __attribute__((__packed__)) ;
   int32_t bat_array[109]  __attribute__((__packed__)) ;
   int32_t sbat_root_start  __attribute__((__packed__)) ;
   unsigned char *m_area ;
   off_t m_length ;
};
#line 84 "ole2_extract.c"
typedef struct ole2_header_tag ole2_header_t;
#line 116 "ole2_extract.c"
struct property_tag {
   unsigned char name[64]  __attribute__((__packed__)) ;
   int16_t name_size  __attribute__((__packed__)) ;
   unsigned char type  __attribute__((__packed__)) ;
   unsigned char color  __attribute__((__packed__)) ;
   int32_t prev  __attribute__((__packed__)) ;
   int32_t next  __attribute__((__packed__)) ;
   int32_t child  __attribute__((__packed__)) ;
   unsigned char clsid[16]  __attribute__((__packed__)) ;
   uint32_t user_flags  __attribute__((__packed__)) ;
   uint32_t create_lowdate  __attribute__((__packed__)) ;
   uint32_t create_highdate  __attribute__((__packed__)) ;
   uint32_t mod_lowdate  __attribute__((__packed__)) ;
   uint32_t mod_highdate  __attribute__((__packed__)) ;
   int32_t start_block  __attribute__((__packed__)) ;
   int32_t size  __attribute__((__packed__)) ;
   unsigned char reserved[4]  __attribute__((__packed__)) ;
};
#line 116 "ole2_extract.c"
typedef struct property_tag property_t;
#line 45 "vba_extract.c"
struct vba_version_tag {
   unsigned char signature[4] ;
   char const   *name ;
   int vba_version ;
   int is_mac ;
};
#line 45 "vba_extract.c"
typedef struct vba_version_tag vba_version_t;
#line 89 "vba_extract.c"
struct byte_array_tag {
   unsigned int length ;
   unsigned char *data ;
};
#line 89 "vba_extract.c"
typedef struct byte_array_tag byte_array_t;
#line 694 "vba_extract.c"
struct atom_header_tag {
   off_t foffset ;
   uint16_t ver_inst ;
   uint8_t version ;
   uint16_t instance ;
   uint16_t type ;
   uint32_t length ;
};
#line 694 "vba_extract.c"
typedef struct atom_header_tag atom_header_t;
#line 899 "vba_extract.c"
struct mso_fib_tag {
   uint16_t magic ;
   uint16_t version ;
   uint16_t product ;
   uint16_t lid ;
   uint16_t next ;
   uint16_t status ;
   uint32_t macro_offset ;
   uint32_t macro_len ;
};
#line 899 "vba_extract.c"
typedef struct mso_fib_tag mso_fib_t;
#line 911 "vba_extract.c"
struct macro_entry_tag {
   unsigned char version ;
   unsigned char key ;
   uint16_t intname_i ;
   uint16_t extname_i ;
   uint16_t xname_i ;
   uint32_t unknown ;
   uint32_t len ;
   uint32_t state ;
   uint32_t offset ;
};
#line 911 "vba_extract.c"
typedef struct macro_entry_tag macro_entry_t;
#line 923 "vba_extract.c"
struct macro_info_tag {
   uint16_t count ;
   struct macro_entry_tag *macro_entry ;
};
#line 923 "vba_extract.c"
typedef struct macro_info_tag macro_info_t;
#line 928 "vba_extract.c"
struct macro_extname_tag {
   uint8_t length ;
   unsigned char *extname ;
   uint16_t numref ;
};
#line 928 "vba_extract.c"
typedef struct macro_extname_tag macro_extname_t;
#line 934 "vba_extract.c"
struct macro_extnames_tag {
   uint16_t count ;
   struct macro_extname_tag *macro_extname ;
};
#line 934 "vba_extract.c"
typedef struct macro_extnames_tag macro_extnames_t;
#line 939
struct macro_intname_tag;
#line 939 "vba_extract.c"
struct macro_intnames_tag {
   uint16_t count ;
   struct macro_intname_tag *macro_intname ;
};
#line 939 "vba_extract.c"
typedef struct macro_intnames_tag macro_intnames_t;
#line 944 "vba_extract.c"
struct macro_intname_tag {
   uint16_t id ;
   uint8_t length ;
   unsigned char *intname ;
};
#line 944 "vba_extract.c"
typedef struct macro_intname_tag macro_intname_t;
#line 950 "vba_extract.c"
struct menu_entry_tag {
   uint16_t context ;
   uint16_t menu ;
   uint16_t extname_i ;
   uint16_t unknown ;
   uint16_t intname_i ;
   uint16_t pos ;
};
#line 950 "vba_extract.c"
typedef struct menu_entry_tag menu_entry_t;
#line 959 "vba_extract.c"
struct menu_info_tag {
   uint16_t count ;
   struct menu_entry_tag *menu_entry ;
};
#line 959 "vba_extract.c"
typedef struct menu_info_tag menu_info_t;
#line 28 "pe.h"
struct pe_image_file_hdr {
   uint32_t Magic ;
   uint16_t Machine ;
   uint16_t NumberOfSections ;
   uint32_t TimeDateStamp ;
   uint32_t PointerToSymbolTable ;
   uint32_t NumberOfSymbols ;
   uint16_t SizeOfOptionalHeader ;
   uint16_t Characteristics ;
};
#line 39 "pe.h"
struct pe_image_data_dir {
   uint32_t VirtualAddress ;
   uint32_t Size ;
};
#line 44 "pe.h"
struct pe_image_optional_hdr {
   uint16_t Magic ;
   uint8_t MajorLinkerVersion ;
   uint8_t MinorLinkerVersion ;
   uint32_t SizeOfCode ;
   uint32_t SizeOfInitializedData ;
   uint32_t SizeOfUninitializedData ;
   uint32_t AddressOfEntryPoint ;
   uint32_t BaseOfCode ;
   uint32_t BaseOfData ;
   uint32_t ImageBase ;
   uint32_t SectionAlignment ;
   uint32_t FileAlignment ;
   uint16_t MajorOperatingSystemVersion ;
   uint16_t MinorOperatingSystemVersion ;
   uint16_t MajorImageVersion ;
   uint16_t MinorImageVersion ;
   uint16_t MajorSubsystemVersion ;
   uint16_t MinorSubsystemVersion ;
   uint32_t Win32VersionValue ;
   uint32_t SizeOfImage ;
   uint32_t SizeOfHeaders ;
   uint32_t CheckSum ;
   uint16_t Subsystem ;
   uint16_t DllCharacteristics ;
   uint32_t SizeOfStackReserve ;
   uint32_t SizeOfStackCommit ;
   uint32_t SizeOfHeapReserve ;
   uint32_t SizeOfHeapCommit ;
   uint32_t LoaderFlags ;
   uint32_t NumberOfRvaAndSizes ;
   struct pe_image_data_dir DataDirectory[16] ;
};
#line 78 "pe.h"
struct pe_image_section_hdr {
   uint8_t Name[8] ;
   uint32_t VirtualSize ;
   uint32_t VirtualAddress ;
   uint32_t SizeOfRawData ;
   uint32_t PointerToRawData ;
   uint32_t PointerToRelocations ;
   uint32_t PointerToLinenumbers ;
   uint16_t NumberOfRelocations ;
   uint16_t NumberOfLinenumbers ;
   uint32_t Characteristics ;
};
#line 42 "mspack/mszip.h"
struct mszipd_stream {
   struct mspack_system *sys ;
   struct mspack_file *input ;
   struct mspack_file *output ;
   unsigned int window_posn ;
   int (*flush_window)(struct mszipd_stream * , unsigned int  ) ;
   int error ;
   int repair_mode ;
   int bytes_output ;
   unsigned char *inbuf ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char *o_ptr ;
   unsigned char *o_end ;
   unsigned int bit_buffer ;
   unsigned int bits_left ;
   unsigned int inbuf_size ;
   unsigned char LITERAL_len[288] ;
   unsigned char DISTANCE_len[32] ;
   unsigned short LITERAL_table[1152] ;
   unsigned short DISTANCE_table[128] ;
   unsigned char window[32768] ;
};
#line 20 "mspack/qtm.h"
struct qtmd_modelsym {
   unsigned short sym ;
   unsigned short cumfreq ;
};
#line 24 "mspack/qtm.h"
struct qtmd_model {
   int shiftsleft ;
   int entries ;
   struct qtmd_modelsym *syms ;
};
#line 29 "mspack/qtm.h"
struct qtmd_stream {
   struct mspack_system *sys ;
   struct mspack_file *input ;
   struct mspack_file *output ;
   unsigned char *window ;
   unsigned int window_size ;
   unsigned int window_posn ;
   unsigned int frame_start ;
   unsigned short H ;
   unsigned short L ;
   unsigned short C ;
   unsigned char header_read ;
   int error ;
   unsigned char *inbuf ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char *o_ptr ;
   unsigned char *o_end ;
   unsigned int bit_buffer ;
   unsigned int inbuf_size ;
   unsigned char bits_left ;
   struct qtmd_model model0 ;
   struct qtmd_model model1 ;
   struct qtmd_model model2 ;
   struct qtmd_model model3 ;
   struct qtmd_model model4 ;
   struct qtmd_model model5 ;
   struct qtmd_model model6 ;
   struct qtmd_model model6len ;
   struct qtmd_model model7 ;
   struct qtmd_modelsym m0sym[65] ;
   struct qtmd_modelsym m1sym[65] ;
   struct qtmd_modelsym m2sym[65] ;
   struct qtmd_modelsym m3sym[65] ;
   struct qtmd_modelsym m4sym[25] ;
   struct qtmd_modelsym m5sym[37] ;
   struct qtmd_modelsym m6sym[43] ;
   struct qtmd_modelsym m6lsym[28] ;
   struct qtmd_modelsym m7sym[8] ;
};
#line 44 "mspack/lzx.h"
struct lzxd_stream {
   struct mspack_system *sys ;
   struct mspack_file *input ;
   struct mspack_file *output ;
   off_t offset ;
   off_t length ;
   unsigned char *window ;
   unsigned int window_size ;
   unsigned int window_posn ;
   unsigned int frame_posn ;
   unsigned int frame ;
   unsigned int reset_interval ;
   unsigned int R0 ;
   unsigned int R1 ;
   unsigned int R2 ;
   unsigned int block_length ;
   unsigned int block_remaining ;
   int intel_filesize ;
   int intel_curpos ;
   unsigned char intel_started ;
   unsigned char block_type ;
   unsigned char header_read ;
   unsigned char posn_slots ;
   unsigned char input_end ;
   int error ;
   unsigned char *inbuf ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char *o_ptr ;
   unsigned char *o_end ;
   unsigned int bit_buffer ;
   unsigned int bits_left ;
   unsigned int inbuf_size ;
   unsigned char PRETREE_len[84] ;
   unsigned char MAINTREE_len[720] ;
   unsigned char LENGTH_len[314] ;
   unsigned char ALIGNED_len[72] ;
   unsigned short PRETREE_table[104] ;
   unsigned short MAINTREE_table[5408] ;
   unsigned short LENGTH_table[4596] ;
   unsigned short ALIGNED_table[144] ;
   unsigned char e8_buf[32768] ;
};
#line 83 "mspack/cab.h"
struct mscabd_folder_p;
#line 83
struct mscabd_folder_data;
#line 83
struct mscabd_cabinet_p;
#line 83 "mspack/cab.h"
struct mscabd_decompress_state {
   struct mscabd_folder_p *folder ;
   struct mscabd_folder_data *data ;
   unsigned int offset ;
   unsigned int block ;
   struct mspack_system sys ;
   int comp_type ;
   int (*decompress)(void * , off_t  ) ;
   void *state ;
   struct mscabd_cabinet_p *incab ;
   struct mspack_file *infh ;
   struct mspack_file *outfh ;
   unsigned char *i_ptr ;
   unsigned char *i_end ;
   unsigned char input[38912] ;
};
#line 99 "mspack/cab.h"
struct mscab_decompressor_p {
   struct mscab_decompressor base ;
   struct mscabd_decompress_state *d ;
   struct mspack_system *system ;
   int param[3] ;
   int error ;
};
#line 107 "mspack/cab.h"
struct mscabd_cabinet_p {
   struct mscabd_cabinet base ;
   off_t blocks_off ;
   int block_resv ;
};
#line 114 "mspack/cab.h"
struct mscabd_folder_data {
   struct mscabd_folder_data *next ;
   struct mscabd_cabinet_p *cab ;
   off_t offset ;
};
#line 120 "mspack/cab.h"
struct mscabd_folder_p {
   struct mscabd_folder base ;
   struct mscabd_folder_data data ;
   struct mscabd_file *merge_prev ;
   struct mscabd_file *merge_next ;
};
#line 128 "mspack/cabd.c"
struct noned_state;
#line 1437 "mspack/cabd.c"
struct noned_state {
   struct mspack_system *sys ;
   struct mspack_file *i ;
   struct mspack_file *o ;
   unsigned char *buf ;
   int bufsize ;
};
#line 97 "mspack/system.c"
struct mspack_file_p {
   FILE *fh ;
   char const   *name ;
   int desc ;
};
#line 53 "htmlnorm.c"
enum __anonenum_html_state_22 {
    HTML_BAD_STATE = 0,
    HTML_NORM = 1,
    HTML_COMMENT = 2,
    HTML_CHAR_REF = 3,
    HTML_SKIP_WS = 4,
    HTML_TRIM_WS = 5,
    HTML_TAG = 6,
    HTML_TAG_ARG = 7,
    HTML_TAG_ARG_VAL = 8,
    HTML_TAG_ARG_EQUAL = 9,
    HTML_PROCESS_TAG = 10,
    HTML_CHAR_REF_DECODE = 11,
    HTML_SKIP_LENGTH = 12,
    HTML_JSDECODE = 13,
    HTML_JSDECODE_LENGTH = 14,
    HTML_JSDECODE_DECRYPT = 15,
    HTML_SPECIAL_CHAR = 16,
    HTML_RFC2397_TYPE = 17,
    HTML_RFC2397_INIT = 18,
    HTML_RFC2397_DATA = 19,
    HTML_RFC2397_FINISH = 20,
    HTML_RFC2397_ESC = 21,
    HTML_ESCAPE_CHAR = 22
};
#line 53 "htmlnorm.c"
typedef enum __anonenum_html_state_22 html_state;
#line 79
enum __anonenum_quoted_state_23 {
    SINGLE_QUOTED = 0,
    DOUBLE_QUOTED = 1,
    NOT_QUOTED = 2
};
#line 79 "htmlnorm.c"
typedef enum __anonenum_quoted_state_23 quoted_state;
#line 85 "htmlnorm.c"
struct m_area_tag {
   unsigned char *buffer ;
   off_t length ;
   off_t offset ;
};
#line 85 "htmlnorm.c"
typedef struct m_area_tag m_area_t;
#line 93 "htmlnorm.c"
struct file_buff_tag {
   int fd ;
   unsigned char buffer[8192] ;
   int length ;
};
#line 93 "htmlnorm.c"
typedef struct file_buff_tag file_buff_t;
#line 59 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 63 "chmunpack.c"
struct itsf_header_tag {
   unsigned char signature[4]  __attribute__((__packed__)) ;
   int32_t version  __attribute__((__packed__)) ;
   int32_t header_len  __attribute__((__packed__)) ;
   uint32_t unknown  __attribute__((__packed__)) ;
   uint32_t last_modified  __attribute__((__packed__)) ;
   uint32_t lang_id  __attribute__((__packed__)) ;
   unsigned char dir_clsid[16]  __attribute__((__packed__)) ;
   unsigned char stream_clsid[16]  __attribute__((__packed__)) ;
   uint64_t sec0_offset  __attribute__((__packed__)) ;
   uint64_t sec0_len  __attribute__((__packed__)) ;
   uint64_t dir_offset  __attribute__((__packed__)) ;
   uint64_t dir_len  __attribute__((__packed__)) ;
   uint64_t data_offset  __attribute__((__packed__)) ;
};
#line 63 "chmunpack.c"
typedef struct itsf_header_tag itsf_header_t;
#line 81 "chmunpack.c"
struct itsp_header_tag {
   unsigned char signature[4]  __attribute__((__packed__)) ;
   int32_t version  __attribute__((__packed__)) ;
   int32_t header_len  __attribute__((__packed__)) ;
   int32_t unknown1  __attribute__((__packed__)) ;
   uint32_t block_len  __attribute__((__packed__)) ;
   int32_t blockidx_intvl  __attribute__((__packed__)) ;
   int32_t index_depth  __attribute__((__packed__)) ;
   int32_t index_root  __attribute__((__packed__)) ;
   int32_t index_head  __attribute__((__packed__)) ;
   int32_t index_tail  __attribute__((__packed__)) ;
   int32_t unknown2  __attribute__((__packed__)) ;
   uint32_t num_blocks  __attribute__((__packed__)) ;
   uint32_t lang_id  __attribute__((__packed__)) ;
   unsigned char system_clsid[16]  __attribute__((__packed__)) ;
   unsigned char unknown4[16]  __attribute__((__packed__)) ;
};
#line 81 "chmunpack.c"
typedef struct itsp_header_tag itsp_header_t;
#line 101 "chmunpack.c"
struct chunk_header_tag {
   unsigned char signature[4]  __attribute__((__packed__)) ;
   uint32_t free_space  __attribute__((__packed__)) ;
   uint32_t unknown  __attribute__((__packed__)) ;
   int32_t block_prev  __attribute__((__packed__)) ;
   int32_t block_next  __attribute__((__packed__)) ;
   unsigned char *chunk_data ;
   uint16_t num_entries ;
};
#line 101 "chmunpack.c"
typedef struct chunk_header_tag chunk_header_t;
#line 112 "chmunpack.c"
struct file_list_tag {
   unsigned char *name ;
   uint64_t section ;
   uint64_t offset ;
   uint64_t length ;
   struct file_list_tag *next ;
};
#line 112 "chmunpack.c"
typedef struct file_list_tag file_list_t;
#line 122 "chmunpack.c"
struct lzx_control_tag {
   uint32_t length  __attribute__((__packed__)) ;
   unsigned char signature[4]  __attribute__((__packed__)) ;
   uint32_t version  __attribute__((__packed__)) ;
   uint32_t reset_interval  __attribute__((__packed__)) ;
   uint32_t window_size  __attribute__((__packed__)) ;
   uint32_t cache_size  __attribute__((__packed__)) ;
};
#line 122 "chmunpack.c"
typedef struct lzx_control_tag lzx_control_t;
#line 133 "chmunpack.c"
struct lzx_reset_table_tag {
   uint32_t num_entries  __attribute__((__packed__)) ;
   uint32_t entry_size  __attribute__((__packed__)) ;
   uint32_t table_offset  __attribute__((__packed__)) ;
   uint64_t uncom_len  __attribute__((__packed__)) ;
   uint64_t com_len  __attribute__((__packed__)) ;
   uint64_t frame_len  __attribute__((__packed__)) ;
   off_t rt_offset  __attribute__((__packed__)) ;
};
#line 133 "chmunpack.c"
typedef struct lzx_reset_table_tag lzx_reset_table_t;
#line 143 "chmunpack.c"
struct lzx_content_tag {
   uint64_t offset ;
   uint64_t length ;
};
#line 143 "chmunpack.c"
typedef struct lzx_content_tag lzx_content_t;
#line 62 "rebuildpe.c"
struct IMAGE_PE_HEADER {
   uint32_t Signature ;
   uint16_t Machine ;
   uint16_t NumberOfSections ;
   uint32_t TimeDateStamp ;
   uint32_t PointerToSymbolTable ;
   uint32_t NumberOfSymbols ;
   uint16_t SizeOfOptionalHeader ;
   uint16_t Characteristics ;
   uint16_t Magic ;
   uint8_t MajorLinkerVersion ;
   uint8_t MinorLinkerVersion ;
   uint32_t SizeOfCode ;
   uint32_t SizeOfInitializedData ;
   uint32_t SizeOfUninitializedData ;
   uint32_t AddressOfEntryPoint ;
   uint32_t BaseOfCode ;
   uint32_t BaseOfData ;
   uint32_t ImageBase ;
   uint32_t SectionAlignment ;
   uint32_t FileAlignment ;
   uint16_t MajorOperatingSystemVersion ;
   uint16_t MinorOperatingSystemVersion ;
   uint16_t MajorImageVersion ;
   uint16_t MinorImageVersion ;
   uint16_t MajorSubsystemVersion ;
   uint16_t MinorSubsystemVersion ;
   uint32_t Win32VersionValue ;
   uint32_t SizeOfImage ;
   uint32_t SizeOfHeaders ;
   uint32_t CheckSum ;
   uint16_t Subsystem ;
   uint16_t DllCharacteristics ;
   uint32_t SizeOfStackReserve ;
   uint32_t SizeOfStackCommit ;
   uint32_t SizeOfHeapReserve ;
   uint32_t SizeOfHeapCommit ;
   uint32_t LoaderFlags ;
   uint32_t NumberOfRvaAndSizes ;
};
#line 24 "is_tar.h"
struct header {
   char name[100] ;
   char mode[8] ;
   char uid[8] ;
   char gid[8] ;
   char size[12] ;
   char mtime[12] ;
   char chksum[8] ;
   char linkflag ;
   char linkname[100] ;
   char magic[8] ;
   char uname[32] ;
   char gname[32] ;
   char devmajor[8] ;
   char devminor[8] ;
};
#line 24 "is_tar.h"
union record {
   char charptr[512] ;
   struct header header ;
};
#line 1 "output.o"
#pragma merger(0,"/tmp/cil-5YjzNKqD.i","-g -O2")
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 208
extern int fclose(FILE *__stream ) ;
#line 213
extern int fflush(FILE *__stream ) ;
#line 243
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 323
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 329
extern int printf(char const   * __restrict  __format  , ...) ;
#line 338
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 754
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 597 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 1228 "/usr/include/bits/string2.h"
extern int __builtin_strchr() ;
#line 318 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 63 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 184 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 275 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 326
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 363
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
#line 363 "/usr/include/sys/stat.h"
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 366
  tmp = __xstat(3, __path, __statbuf);
#line 366
  return (tmp);
}
}
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 29 "../shared/output.h"
int mdprintf(int desc , char const   *str  , ...) ;
#line 31
int logg(char const   *str  , ...) ;
#line 32
void logg_close(void) ;
#line 33
short logg_verbose ;
#line 33
short logg_lock ;
#line 33
short logg_time ;
#line 34
int logg_size ;
#line 35
char const   *logg_file ;
#line 38
short logg_syslog ;
#line 39
int logg_facility(char const   *name ) ;
#line 42
void mprintf(char const   *str  , ...) ;
#line 43
short mprintf_disabled ;
#line 43
short mprintf_verbose ;
#line 43
short mprintf_quiet ;
#line 43
short mprintf_stdout ;
#line 25 "../shared/memory.h"
void *mcalloc(size_t nmemb , size_t size ) ;
#line 343 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 52 "../shared/output.c"
struct __anonstruct_pthread_mutex_t_16 logg_mutex  =    {0, 0, (_pthread_descr )0, 0, {0L, 0}};
#line 55 "../shared/output.c"
FILE *logg_fd  =    (FILE *)((void *)0);
#line 57 "../shared/output.c"
short logg_verbose  =    (short)0;
#line 57 "../shared/output.c"
short logg_lock  =    (short)0;
#line 57 "../shared/output.c"
short logg_time  =    (short)0;
#line 58 "../shared/output.c"
int logg_size  =    0;
#line 59 "../shared/output.c"
char const   *logg_file  =    (char const   *)((void *)0);
#line 61 "../shared/output.c"
short logg_syslog  =    (short)0;
#line 64 "../shared/output.c"
short mprintf_disabled  =    (short)0;
#line 64 "../shared/output.c"
short mprintf_verbose  =    (short)0;
#line 64 "../shared/output.c"
short mprintf_quiet  =    (short)0;
#line 64 "../shared/output.c"
short mprintf_stdout  =    (short)0;
#line 67 "../shared/output.c"
int mdprintf(int desc , char const   *str  , ...) 
{ va_list args ;
  char buff[512] ;
  int bytes ;

  {
#line 73
  __builtin_va_start(args, str);
#line 74
  bytes = vsnprintf((char * __restrict  )(buff), 512U, (char const   * __restrict  )str,
                    args);
#line 75
  __builtin_va_end(args);
#line 76
  write(desc, (void const   *)(buff), (unsigned int )bytes);
#line 77
  return (bytes);
}
}
#line 80 "../shared/output.c"
void logg_close(void) 
{ 

  {
#line 83
  pthread_mutex_lock(& logg_mutex);
#line 85
  if (logg_fd) {
#line 86
    fclose(logg_fd);
#line 87
    logg_fd = (FILE *)((void *)0);
  }
#line 90
  pthread_mutex_unlock(& logg_mutex);
#line 94
  if (logg_syslog) {
#line 95
    closelog();
  }
#line 98
  return;
}
}
#line 148
extern int __builtin_strncpy() ;
#line 100 "../shared/output.c"
int logg(char const   *str  , ...) 
{ va_list args ;
  va_list argscpy ;
  struct flock fl ;
  char *pt ;
  char *timestr ;
  char vbuff[1025] ;
  time_t currtime ;
  struct stat sb ;
  mode_t old_umask ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___8 ;

  {
#line 110
  __builtin_va_start(args, str);
#line 112
  __builtin_va_start(argscpy, str);
#line 114
  if (logg_file) {
#line 116
    pthread_mutex_lock(& logg_mutex);
#line 118
    if (! logg_fd) {
#line 119
      old_umask = umask(31U);
#line 120
      logg_fd = fopen((char const   * __restrict  )logg_file, (char const   * __restrict  )"a");
#line 120
      if ((unsigned int )logg_fd == (unsigned int )((void *)0)) {
#line 121
        umask(old_umask);
#line 123
        pthread_mutex_unlock(& logg_mutex);
#line 125
        printf((char const   * __restrict  )"ERROR: Can\'t open %s in append mode (check permissions!).\n",
               logg_file);
#line 126
        return (-1);
      } else {
#line 127
        umask(old_umask);
      }
#line 129
      if (logg_lock) {
#line 130
        memset((void *)(& fl), 0, sizeof(fl));
#line 131
        fl.l_type = (short)1;
#line 132
        tmp = fileno(logg_fd);
#line 132
        tmp___0 = fcntl(tmp, 6, & fl);
#line 132
        if (tmp___0 == -1) {
#line 134
          pthread_mutex_unlock(& logg_mutex);
#line 136
          return (-1);
        }
      }
    }
#line 144
    if (logg_time) {
#line 144
      if ((int const   )(*str) != 42) {
        goto _L;
      } else {
#line 144
        if (logg_verbose) {
          _L: /* CIL Label */ 
#line 145
          time(& currtime);
#line 146
          pt = ctime((time_t const   *)(& currtime));
#line 147
          tmp___1 = strlen((char const   *)pt);
#line 147
          timestr = (char *)mcalloc(tmp___1, sizeof(char ));
#line 148
          tmp___2 = strlen((char const   *)pt);
#line 148
          __builtin_strncpy(timestr, pt, tmp___2 - 1U);
#line 149
          fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"%s -> ",
                  timestr);
#line 150
          free((void *)timestr);
        }
      }
    }
#line 153
    if (logg_size) {
#line 154
      tmp___3 = stat__extinline(logg_file, & sb);
#line 154
      if (tmp___3 != -1) {
#line 155
        if (sb.st_size > (__off_t )logg_size) {
#line 156
          logg_file = (char const   *)((void *)0);
#line 157
          fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"Log size = %d, maximal = %d\n",
                  (int )sb.st_size, logg_size);
#line 158
          fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"LOGGING DISABLED (Maximal log file size exceeded).\n");
#line 159
          fclose(logg_fd);
#line 160
          logg_fd = (FILE *)((void *)0);
#line 162
          pthread_mutex_unlock(& logg_mutex);
#line 164
          return (0);
        }
      }
    }
#line 170
    if ((int const   )(*str) == 33) {
#line 171
      fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"ERROR: ");
#line 172
      vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )(str + 1),
               args);
    } else {
#line 173
      if ((int const   )(*str) == 94) {
#line 174
        fprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )"WARNING: ");
#line 175
        vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )(str +
                                                                             1), args);
      } else {
#line 176
        if ((int const   )(*str) == 42) {
#line 177
          if (logg_verbose) {
#line 178
            vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )(str +
                                                                                 1),
                     args);
          }
        } else {
#line 179
          vfprintf((FILE * __restrict  )logg_fd, (char const   * __restrict  )str,
                   args);
        }
      }
    }
#line 182
    fflush(logg_fd);
#line 185
    pthread_mutex_unlock(& logg_mutex);
  }
#line 190
  if (logg_syslog) {
#line 198
    vsnprintf((char * __restrict  )(vbuff), 1024U, (char const   * __restrict  )str,
              argscpy);
#line 199
    vbuff[1024] = (char)0;
#line 201
    while (1) {
#line 201
      tmp___8 = __builtin_constant_p((int )(vbuff));
#line 201
      if (tmp___8) {
#line 201
        pt = (char *)__builtin_strchr(vbuff, '%');
      } else {
#line 201
        pt = (char *)__builtin_strchr(vbuff, '%');
      }
#line 201
      if (! pt) {
#line 201
        break;
      }
#line 202
      (*pt) = (char )'_';
    }
#line 204
    if ((int )vbuff[0] == 33) {
#line 205
      syslog(3, (char const   *)(vbuff + 1));
    } else {
#line 206
      if ((int )vbuff[0] == 94) {
#line 207
        syslog(4, (char const   *)(vbuff + 1));
      } else {
#line 208
        if ((int )vbuff[0] == 42) {
#line 209
          if (logg_verbose) {
#line 210
            syslog(7, (char const   *)(vbuff + 1));
          }
        } else {
#line 212
          syslog(6, (char const   *)(vbuff));
        }
      }
    }
  }
#line 217
  __builtin_va_end(args);
#line 218
  __builtin_va_end(argscpy);
#line 219
  return (0);
}
}
#line 222 "../shared/output.c"
void mprintf(char const   *str  , ...) 
{ va_list args ;
  va_list argscpy ;
  FILE *fd ;
  char logbuf[512] ;

  {
#line 229
  if (mprintf_disabled) {
#line 230
    if ((int const   )(*str) == 64) {
#line 231
      __builtin_va_start(args, str);
#line 235
      str ++;
#line 235
      vsnprintf((char * __restrict  )(logbuf), sizeof(logbuf), (char const   * __restrict  )str,
                args);
#line 237
      __builtin_va_end(args);
#line 238
      logg("ERROR: %s", logbuf);
    }
#line 240
    return;
  }
#line 243
  fd = stdout;
#line 261
  __builtin_va_start(args, str);
#line 263
  __builtin_va_start(argscpy, str);
#line 265
  if ((int const   )(*str) == 33) {
#line 266
    if (! mprintf_stdout) {
#line 267
      fd = stderr;
    }
#line 268
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"ERROR: ");
#line 269
    str ++;
#line 269
    vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
  } else {
#line 270
    if ((int const   )(*str) == 64) {
#line 271
      if (! mprintf_stdout) {
#line 272
        fd = stderr;
      }
#line 273
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"ERROR: ");
#line 274
      str ++;
#line 274
      vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
#line 278
      vsnprintf((char * __restrict  )(logbuf), sizeof(logbuf), (char const   * __restrict  )str,
                argscpy);
#line 280
      logg("ERROR: %s", logbuf);
    } else {
#line 281
      if (! mprintf_quiet) {
#line 282
        if ((int const   )(*str) == 94) {
#line 283
          if (! mprintf_stdout) {
#line 284
            fd = stderr;
          }
#line 285
          fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"WARNING: ");
#line 286
          str ++;
#line 286
          vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
        } else {
#line 287
          if ((int const   )(*str) == 42) {
#line 288
            if (mprintf_verbose) {
#line 289
              str ++;
#line 289
              vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str,
                       args);
            }
          } else {
#line 290
            vfprintf((FILE * __restrict  )fd, (char const   * __restrict  )str, args);
          }
        }
      }
    }
  }
#line 293
  __builtin_va_end(args);
#line 294
  __builtin_va_end(argscpy);
#line 296
  if ((unsigned int )fd == (unsigned int )stdout) {
#line 297
    fflush(stdout);
  }
#line 299
  return;
}
}
#line 307 "../shared/output.c"
static struct facstruct  const  facilitymap[22]  = 
#line 307
  {      {"LOG_AUTH", 32}, 
        {"LOG_AUTHPRIV", 80}, 
        {"LOG_CRON", 72}, 
        {"LOG_DAEMON", 24}, 
        {"LOG_FTP", 88}, 
        {"LOG_KERN", 0}, 
        {"LOG_LPR", 48}, 
        {"LOG_MAIL", 16}, 
        {"LOG_NEWS", 56}, 
        {"LOG_AUTH", 32}, 
        {"LOG_SYSLOG", 40}, 
        {"LOG_USER", 8}, 
        {"LOG_UUCP", 64}, 
        {"LOG_LOCAL0", 128}, 
        {"LOG_LOCAL1", 136}, 
        {"LOG_LOCAL2", 144}, 
        {"LOG_LOCAL3", 152}, 
        {"LOG_LOCAL4", 160}, 
        {"LOG_LOCAL5", 168}, 
        {"LOG_LOCAL6", 176}, 
        {"LOG_LOCAL7", 184}, 
        {(char const   *)((void *)0), -1}};
#line 379
extern int __builtin_strcmp() ;
#line 374 "../shared/output.c"
int logg_facility(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 378
  i = 0;
#line 378
  while (facilitymap[i].name) {
#line 379
    tmp___65 = __builtin_constant_p((int )facilitymap[i].name);
#line 379
    if (tmp___65) {
#line 379
      tmp___66 = __builtin_constant_p((int )name);
#line 379
      if (tmp___66) {
#line 379
        __s1_len = strlen(facilitymap[i].name);
#line 379
        __s2_len = strlen(name);
#line 379
        if (! ((unsigned int )((void const   *)(facilitymap[i].name + 1)) - (unsigned int )((void const   *)facilitymap[i].name) ==
               1U)) {
          goto _L___16;
        } else {
#line 379
          if (__s1_len >= 4U) {
            _L___16: /* CIL Label */ 
#line 379
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                   1U)) {
#line 379
              tmp___67 = 1;
            } else {
#line 379
              if (__s2_len >= 4U) {
#line 379
                tmp___67 = 1;
              } else {
#line 379
                tmp___67 = 0;
              }
            }
          } else {
#line 379
            tmp___67 = 0;
          }
        }
#line 379
        if (tmp___67) {
#line 379
          tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: /* CIL Label */ 
#line 379
      tmp___64 = __builtin_constant_p((int )facilitymap[i].name);
#line 379
      if (tmp___64) {
#line 379
        if ((unsigned int )((void const   *)(facilitymap[i].name + 1)) - (unsigned int )((void const   *)facilitymap[i].name) ==
            1U) {
#line 379
          __s1_len = strlen(facilitymap[i].name);
#line 379
          if (__s1_len < 4U) {
#line 379
            tmp___53 = __builtin_constant_p((int )name);
#line 379
            if (tmp___53) {
#line 379
              if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                  1U) {
#line 379
                tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: /* CIL Label */ 
#line 379
              __s2___6 = (unsigned char const   *)name;
#line 379
              __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
#line 379
              if (__s1_len > 0U) {
#line 379
                if (__result___18 == 0) {
#line 379
                  __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
#line 379
                  if (__s1_len > 1U) {
#line 379
                    if (__result___18 == 0) {
#line 379
                      __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
#line 379
                      if (__s1_len > 2U) {
#line 379
                        if (__result___18 == 0) {
#line 379
                          __result___18 = (int )((int const   )(*((unsigned char const   *)facilitymap[i].name +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
#line 379
              tmp___34 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: /* CIL Label */ 
#line 379
        tmp___63 = __builtin_constant_p((int )name);
#line 379
        if (tmp___63) {
#line 379
          if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
              1U) {
#line 379
            __s2_len = strlen(name);
#line 379
            if (__s2_len < 4U) {
#line 379
              tmp___62 = __builtin_constant_p((int )facilitymap[i].name);
#line 379
              if (tmp___62) {
#line 379
                if ((unsigned int )((void const   *)(facilitymap[i].name + 1)) - (unsigned int )((void const   *)facilitymap[i].name) ==
                    1U) {
#line 379
                  tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: /* CIL Label */ 
#line 379
                __s1___14 = (unsigned char const   *)facilitymap[i].name;
#line 379
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)name +
                                                                                           0)));
#line 379
                if (__s2_len > 0U) {
#line 379
                  if (__result___22 == 0) {
#line 379
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)name +
                                                                                               1)));
#line 379
                    if (__s2_len > 1U) {
#line 379
                      if (__result___22 == 0) {
#line 379
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)name +
                                                                2)));
#line 379
                        if (__s2_len > 2U) {
#line 379
                          if (__result___22 == 0) {
#line 379
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)name +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 379
                tmp___34 = __result___22;
              }
            } else {
#line 379
              tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
            }
          } else {
#line 379
            tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
          }
        } else {
#line 379
          tmp___34 = __builtin_strcmp(facilitymap[i].name, name);
        }
      }
    }
#line 379
    if (! tmp___34) {
#line 380
      return (facilitymap[i].code);
    }
#line 378
    i ++;
  }
#line 382
  return (-1);
}
}
#line 1 "cfgparser.o"
#pragma merger(0,"/tmp/cil-dXtqdcj6.i","-g -O2")
#line 528 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 287 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 329
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
#line 329 "/usr/include/stdlib.h"
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
#line 333
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 333
  return (tmp);
}
}
#line 396
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 396 "/usr/include/stdlib.h"
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
#line 399
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
#line 399
  return (tmp);
}
}
#line 584
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 586
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower__extinline(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = (*((*tmp___1) + __c));
    } else {
#line 193
      tmp___0 = __c;
    }
  } else {
#line 193
    tmp___0 = __c;
  }
#line 193
  return (tmp___0);
}
}
#line 46 "../shared/cfgparser.h"
struct cfgstruct *parsecfg(char const   *cfgfile , int messages ) ;
#line 48
struct cfgstruct *regcfg(struct cfgstruct *copt , char *optname , char *strarg , int numarg ) ;
#line 50
struct cfgstruct *cfgopt(struct cfgstruct  const  *copt , char const   *optname ) ;
#line 52
void freecfg(struct cfgstruct *copt ) ;
#line 24 "../libclamav/str.h"
char *cli_strtok(char const   *line , int fieldno , char const   *delim ) ;
#line 24 "../shared/memory.h"
void *mmalloc(size_t size ) ;
#line 27 "../shared/misc.h"
int isnumb(char const   *str ) ;
#line 35 "../shared/cfgparser.c"
struct cfgstruct *parsecfg(char const   *cfgfile , int messages ) 
{ char buff[1024] ;
  char *name ;
  char *arg ;
  FILE *fs ;
  int line ;
  int i ;
  int found ;
  int ctype ;
  int calc ;
  struct cfgstruct *copt ;
  struct cfgoption *pt ;
  struct cfgoption cfg_options[74] ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___109 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___128 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;
  size_t __len___2 ;
  size_t tmp___163 ;
  char *__retval___2 ;
  char *tmp___164 ;
  int tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;
  int __res ;
  int __c ;
  size_t tmp___169 ;
  __int32_t const   **tmp___171 ;
  size_t tmp___172 ;
  size_t tmp___173 ;
  int tmp___174 ;
  __int32_t const   **tmp___175 ;
  size_t tmp___176 ;
  size_t tmp___177 ;
  char *cpy ;
  size_t tmp___178 ;
  char *tmp___179 ;
  size_t tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___220 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___239 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___253 ;
  char *tmp___254 ;

  {
#line 39
  line = 0;
#line 40
  copt = (struct cfgstruct *)((void *)0);
#line 43
  cfg_options[0].name = "LogFile";
#line 43
  cfg_options[0].argtype = 1;
#line 43
  cfg_options[1].name = "LogFileUnlock";
#line 43
  cfg_options[1].argtype = 4;
#line 43
  cfg_options[2].name = "LogFileMaxSize";
#line 43
  cfg_options[2].argtype = 3;
#line 43
  cfg_options[3].name = "LogTime";
#line 43
  cfg_options[3].argtype = 4;
#line 43
  cfg_options[4].name = "LogClean";
#line 43
  cfg_options[4].argtype = 4;
#line 43
  cfg_options[5].name = "LogVerbose";
#line 43
  cfg_options[5].argtype = 4;
#line 43
  cfg_options[6].name = "LogSyslog";
#line 43
  cfg_options[6].argtype = 4;
#line 43
  cfg_options[7].name = "LogFacility";
#line 43
  cfg_options[7].argtype = 1;
#line 43
  cfg_options[8].name = "PidFile";
#line 43
  cfg_options[8].argtype = 1;
#line 43
  cfg_options[9].name = "TemporaryDirectory";
#line 43
  cfg_options[9].argtype = 1;
#line 43
  cfg_options[10].name = "DisableDefaultScanOptions";
#line 43
  cfg_options[10].argtype = 4;
#line 43
  cfg_options[11].name = "ScanPE";
#line 43
  cfg_options[11].argtype = 4;
#line 43
  cfg_options[12].name = "DetectBrokenExecutables";
#line 43
  cfg_options[12].argtype = 4;
#line 43
  cfg_options[13].name = "ScanMail";
#line 43
  cfg_options[13].argtype = 4;
#line 43
  cfg_options[14].name = "MailFollowURLs";
#line 43
  cfg_options[14].argtype = 4;
#line 43
  cfg_options[15].name = "ScanHTML";
#line 43
  cfg_options[15].argtype = 4;
#line 43
  cfg_options[16].name = "ScanOLE2";
#line 43
  cfg_options[16].argtype = 4;
#line 43
  cfg_options[17].name = "ScanArchive";
#line 43
  cfg_options[17].argtype = 4;
#line 43
  cfg_options[18].name = "ScanRAR";
#line 43
  cfg_options[18].argtype = 4;
#line 43
  cfg_options[19].name = "ArchiveMaxFileSize";
#line 43
  cfg_options[19].argtype = 3;
#line 43
  cfg_options[20].name = "ArchiveMaxRecursion";
#line 43
  cfg_options[20].argtype = 2;
#line 43
  cfg_options[21].name = "ArchiveMaxFiles";
#line 43
  cfg_options[21].argtype = 2;
#line 43
  cfg_options[22].name = "ArchiveMaxCompressionRatio";
#line 43
  cfg_options[22].argtype = 2;
#line 43
  cfg_options[23].name = "ArchiveLimitMemoryUsage";
#line 43
  cfg_options[23].argtype = 4;
#line 43
  cfg_options[24].name = "ArchiveBlockEncrypted";
#line 43
  cfg_options[24].argtype = 4;
#line 43
  cfg_options[25].name = "ArchiveBlockMax";
#line 43
  cfg_options[25].argtype = 4;
#line 43
  cfg_options[26].name = "DataDirectory";
#line 43
  cfg_options[26].argtype = 1;
#line 43
  cfg_options[27].name = "DatabaseDirectory";
#line 43
  cfg_options[27].argtype = 1;
#line 43
  cfg_options[28].name = "TCPAddr";
#line 43
  cfg_options[28].argtype = 1;
#line 43
  cfg_options[29].name = "TCPSocket";
#line 43
  cfg_options[29].argtype = 2;
#line 43
  cfg_options[30].name = "LocalSocket";
#line 43
  cfg_options[30].argtype = 1;
#line 43
  cfg_options[31].name = "MaxConnectionQueueLength";
#line 43
  cfg_options[31].argtype = 2;
#line 43
  cfg_options[32].name = "StreamMaxLength";
#line 43
  cfg_options[32].argtype = 3;
#line 43
  cfg_options[33].name = "StreamMinPort";
#line 43
  cfg_options[33].argtype = 2;
#line 43
  cfg_options[34].name = "StreamMaxPort";
#line 43
  cfg_options[34].argtype = 2;
#line 43
  cfg_options[35].name = "MaxThreads";
#line 43
  cfg_options[35].argtype = 2;
#line 43
  cfg_options[36].name = "ReadTimeout";
#line 43
  cfg_options[36].argtype = 2;
#line 43
  cfg_options[37].name = "IdleTimeout";
#line 43
  cfg_options[37].argtype = 2;
#line 43
  cfg_options[38].name = "MaxDirectoryRecursion";
#line 43
  cfg_options[38].argtype = 2;
#line 43
  cfg_options[39].name = "FollowDirectorySymlinks";
#line 43
  cfg_options[39].argtype = 4;
#line 43
  cfg_options[40].name = "FollowFileSymlinks";
#line 43
  cfg_options[40].argtype = 4;
#line 43
  cfg_options[41].name = "ExitOnOOM";
#line 43
  cfg_options[41].argtype = 4;
#line 43
  cfg_options[42].name = "Foreground";
#line 43
  cfg_options[42].argtype = 4;
#line 43
  cfg_options[43].name = "Debug";
#line 43
  cfg_options[43].argtype = 4;
#line 43
  cfg_options[44].name = "LeaveTemporaryFiles";
#line 43
  cfg_options[44].argtype = 4;
#line 43
  cfg_options[45].name = "FixStaleSocket";
#line 43
  cfg_options[45].argtype = 4;
#line 43
  cfg_options[46].name = "User";
#line 43
  cfg_options[46].argtype = 1;
#line 43
  cfg_options[47].name = "AllowSupplementaryGroups";
#line 43
  cfg_options[47].argtype = 4;
#line 43
  cfg_options[48].name = "SelfCheck";
#line 43
  cfg_options[48].argtype = 2;
#line 43
  cfg_options[49].name = "VirusEvent";
#line 43
  cfg_options[49].argtype = 6;
#line 43
  cfg_options[50].name = "ClamukoScanOnLine";
#line 43
  cfg_options[50].argtype = 4;
#line 43
  cfg_options[51].name = "ClamukoScanOnAccess";
#line 43
  cfg_options[51].argtype = 4;
#line 43
  cfg_options[52].name = "ClamukoScanOnOpen";
#line 43
  cfg_options[52].argtype = 4;
#line 43
  cfg_options[53].name = "ClamukoScanOnClose";
#line 43
  cfg_options[53].argtype = 4;
#line 43
  cfg_options[54].name = "ClamukoScanOnExec";
#line 43
  cfg_options[54].argtype = 4;
#line 43
  cfg_options[55].name = "ClamukoIncludePath";
#line 43
  cfg_options[55].argtype = 1;
#line 43
  cfg_options[56].name = "ClamukoExcludePath";
#line 43
  cfg_options[56].argtype = 1;
#line 43
  cfg_options[57].name = "ClamukoMaxFileSize";
#line 43
  cfg_options[57].argtype = 3;
#line 43
  cfg_options[58].name = "ClamukoScanArchive";
#line 43
  cfg_options[58].argtype = 4;
#line 43
  cfg_options[59].name = "DatabaseOwner";
#line 43
  cfg_options[59].argtype = 1;
#line 43
  cfg_options[60].name = "Checks";
#line 43
  cfg_options[60].argtype = 2;
#line 43
  cfg_options[61].name = "UpdateLogFile";
#line 43
  cfg_options[61].argtype = 1;
#line 43
  cfg_options[62].name = "DNSDatabaseInfo";
#line 43
  cfg_options[62].argtype = 1;
#line 43
  cfg_options[63].name = "DatabaseMirror";
#line 43
  cfg_options[63].argtype = 1;
#line 43
  cfg_options[64].name = "MaxAttempts";
#line 43
  cfg_options[64].argtype = 2;
#line 43
  cfg_options[65].name = "HTTPProxyServer";
#line 43
  cfg_options[65].argtype = 1;
#line 43
  cfg_options[66].name = "HTTPProxyPort";
#line 43
  cfg_options[66].argtype = 2;
#line 43
  cfg_options[67].name = "HTTPProxyUsername";
#line 43
  cfg_options[67].argtype = 1;
#line 43
  cfg_options[68].name = "HTTPProxyPassword";
#line 43
  cfg_options[68].argtype = 1;
#line 43
  cfg_options[69].name = "NotifyClamd";
#line 43
  cfg_options[69].argtype = 5;
#line 43
  cfg_options[70].name = "OnUpdateExecute";
#line 43
  cfg_options[70].argtype = 6;
#line 43
  cfg_options[71].name = "OnErrorExecute";
#line 43
  cfg_options[71].argtype = 6;
#line 43
  cfg_options[72].name = "LocalIPAddress";
#line 43
  cfg_options[72].argtype = 1;
#line 43
  cfg_options[73].name = (char const   *)0;
#line 43
  cfg_options[73].argtype = 0;
#line 121
  fs = fopen((char const   * __restrict  )cfgfile, (char const   * __restrict  )"r");
#line 121
  if ((unsigned int )fs == (unsigned int )((void *)0)) {
#line 122
    return ((struct cfgstruct *)((void *)0));
  }
#line 124
  while (1) {
#line 124
    tmp___254 = fgets((char * __restrict  )(buff), 1024, (FILE * __restrict  )fs);
#line 124
    if (! tmp___254) {
#line 124
      break;
    }
#line 126
    line ++;
#line 128
    if ((int )buff[0] == 35) {
#line 129
      continue;
    }
#line 131
    tmp___143 = __builtin_constant_p((int )"Example");
#line 131
    if (tmp___143) {
#line 131
      tmp___144 = strlen("Example");
#line 131
      if (tmp___144 < 7U) {
        goto _L___39;
      } else {
        goto _L___40;
      }
    } else {
      _L___40: /* CIL Label */ 
#line 131
      tmp___145 = __builtin_constant_p((int )(buff));
#line 131
      if (tmp___145) {
#line 131
        tmp___146 = strlen((char const   *)(buff));
#line 131
        if (tmp___146 < 7U) {
          _L___39: /* CIL Label */ 
#line 131
          tmp___140 = __builtin_constant_p((int )"Example");
#line 131
          if (tmp___140) {
#line 131
            tmp___141 = __builtin_constant_p((int )(buff));
#line 131
            if (tmp___141) {
#line 131
              __s1_len___0 = strlen("Example");
#line 131
              __s2_len___0 = strlen((char const   *)(buff));
#line 131
              if (! ((unsigned int )((void const   *)("Example" + 1)) - (unsigned int )((void const   *)"Example") ==
                     1U)) {
                goto _L___36;
              } else {
#line 131
                if (__s1_len___0 >= 4U) {
                  _L___36: /* CIL Label */ 
#line 131
                  if (! ((unsigned int )((void const   *)(buff + 1)) - (unsigned int )((void const   *)(buff)) ==
                         1U)) {
#line 131
                    tmp___142 = 1;
                  } else {
#line 131
                    if (__s2_len___0 >= 4U) {
#line 131
                      tmp___142 = 1;
                    } else {
#line 131
                      tmp___142 = 0;
                    }
                  }
                } else {
#line 131
                  tmp___142 = 0;
                }
              }
#line 131
              if (tmp___142) {
#line 131
                tmp___109 = __builtin_strcmp("Example", buff);
              } else {
                goto _L___38;
              }
            } else {
              goto _L___38;
            }
          } else {
            _L___38: /* CIL Label */ 
#line 131
            tmp___139 = __builtin_constant_p((int )"Example");
#line 131
            if (tmp___139) {
#line 131
              if ((unsigned int )((void const   *)("Example" + 1)) - (unsigned int )((void const   *)"Example") ==
                  1U) {
#line 131
                __s1_len___0 = strlen("Example");
#line 131
                if (__s1_len___0 < 4U) {
#line 131
                  tmp___128 = __builtin_constant_p((int )(buff));
#line 131
                  if (tmp___128) {
#line 131
                    if ((unsigned int )((void const   *)(buff + 1)) - (unsigned int )((void const   *)(buff)) ==
                        1U) {
#line 131
                      tmp___109 = __builtin_strcmp("Example", buff);
                    } else {
                      goto _L___31;
                    }
                  } else {
                    _L___31: /* CIL Label */ 
#line 131
                    __s2___14 = (unsigned char const   *)((char const   *)(buff));
#line 131
                    __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
#line 131
                    if (__s1_len___0 > 0U) {
#line 131
                      if (__result___42 == 0) {
#line 131
                        __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
#line 131
                        if (__s1_len___0 > 1U) {
#line 131
                          if (__result___42 == 0) {
#line 131
                            __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
#line 131
                            if (__s1_len___0 > 2U) {
#line 131
                              if (__result___42 == 0) {
#line 131
                                __result___42 = (int )((int const   )(*((unsigned char const   *)"Example" +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 131
                    tmp___109 = __result___42;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                goto _L___35;
              }
            } else {
              _L___35: /* CIL Label */ 
#line 131
              tmp___138 = __builtin_constant_p((int )(buff));
#line 131
              if (tmp___138) {
#line 131
                if ((unsigned int )((void const   *)(buff + 1)) - (unsigned int )((void const   *)(buff)) ==
                    1U) {
#line 131
                  __s2_len___0 = strlen((char const   *)(buff));
#line 131
                  if (__s2_len___0 < 4U) {
#line 131
                    tmp___137 = __builtin_constant_p((int )"Example");
#line 131
                    if (tmp___137) {
#line 131
                      if ((unsigned int )((void const   *)("Example" + 1)) - (unsigned int )((void const   *)"Example") ==
                          1U) {
#line 131
                        tmp___109 = __builtin_strcmp("Example", buff);
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: /* CIL Label */ 
#line 131
                      __s1___30 = (unsigned char const   *)"Example";
#line 131
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                                                 0)));
#line 131
                      if (__s2_len___0 > 0U) {
#line 131
                        if (__result___46 == 0) {
#line 131
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                  1)));
#line 131
                          if (__s2_len___0 > 1U) {
#line 131
                            if (__result___46 == 0) {
#line 131
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                                             2)));
#line 131
                              if (__s2_len___0 > 2U) {
#line 131
                                if (__result___46 == 0) {
#line 131
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)((char const   *)(buff)) +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 131
                      tmp___109 = __result___46;
                    }
                  } else {
#line 131
                    tmp___109 = __builtin_strcmp("Example", buff);
                  }
                } else {
#line 131
                  tmp___109 = __builtin_strcmp("Example", buff);
                }
              } else {
#line 131
                tmp___109 = __builtin_strcmp("Example", buff);
              }
            }
          }
#line 131
          tmp___73 = tmp___109;
        } else {
#line 131
          tmp___73 = strncmp("Example", (char const   *)(buff), 7U);
        }
      } else {
#line 131
        tmp___73 = strncmp("Example", (char const   *)(buff), 7U);
      }
    }
#line 131
    if (! tmp___73) {
#line 132
      if (messages) {
#line 133
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Please edit the example config file %s.\n",
                cfgfile);
      }
#line 134
      fclose(fs);
#line 135
      return ((struct cfgstruct *)((void *)0));
    }
#line 139
    name = cli_strtok((char const   *)(buff), 0, " \r\n");
#line 139
    if (name) {
#line 140
      arg = cli_strtok((char const   *)(buff), 1, " \r\n");
#line 141
      found = 0;
#line 142
      i = 0;
#line 142
      while (1) {
#line 143
        pt = & cfg_options[i];
#line 144
        if (pt->name) {
#line 145
          tmp___251 = __builtin_constant_p((int )name);
#line 145
          if (tmp___251) {
#line 145
            tmp___252 = __builtin_constant_p((int )pt->name);
#line 145
            if (tmp___252) {
#line 145
              __s1_len___1 = strlen((char const   *)name);
#line 145
              __s2_len___1 = strlen(pt->name);
#line 145
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                     1U)) {
                goto _L___60;
              } else {
#line 145
                if (__s1_len___1 >= 4U) {
                  _L___60: /* CIL Label */ 
#line 145
                  if (! ((unsigned int )((void const   *)(pt->name + 1)) - (unsigned int )((void const   *)pt->name) ==
                         1U)) {
#line 145
                    tmp___253 = 1;
                  } else {
#line 145
                    if (__s2_len___1 >= 4U) {
#line 145
                      tmp___253 = 1;
                    } else {
#line 145
                      tmp___253 = 0;
                    }
                  }
                } else {
#line 145
                  tmp___253 = 0;
                }
              }
#line 145
              if (tmp___253) {
#line 145
                tmp___220 = __builtin_strcmp(name, pt->name);
              } else {
                goto _L___62;
              }
            } else {
              goto _L___62;
            }
          } else {
            _L___62: /* CIL Label */ 
#line 145
            tmp___250 = __builtin_constant_p((int )name);
#line 145
            if (tmp___250) {
#line 145
              if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                  1U) {
#line 145
                __s1_len___1 = strlen((char const   *)name);
#line 145
                if (__s1_len___1 < 4U) {
#line 145
                  tmp___239 = __builtin_constant_p((int )pt->name);
#line 145
                  if (tmp___239) {
#line 145
                    if ((unsigned int )((void const   *)(pt->name + 1)) - (unsigned int )((void const   *)pt->name) ==
                        1U) {
#line 145
                      tmp___220 = __builtin_strcmp(name, pt->name);
                    } else {
                      goto _L___55;
                    }
                  } else {
                    _L___55: /* CIL Label */ 
#line 145
                    __s2___22 = (unsigned char const   *)pt->name;
#line 145
                    __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                            0)) - (int const   )(*(__s2___22 +
                                                                                   0)));
#line 145
                    if (__s1_len___1 > 0U) {
#line 145
                      if (__result___66 == 0) {
#line 145
                        __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                1)) - (int const   )(*(__s2___22 +
                                                                                       1)));
#line 145
                        if (__s1_len___1 > 1U) {
#line 145
                          if (__result___66 == 0) {
#line 145
                            __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                    2)) - (int const   )(*(__s2___22 +
                                                                                           2)));
#line 145
                            if (__s1_len___1 > 2U) {
#line 145
                              if (__result___66 == 0) {
#line 145
                                __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                        3)) - (int const   )(*(__s2___22 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 145
                    tmp___220 = __result___66;
                  }
                } else {
                  goto _L___59;
                }
              } else {
                goto _L___59;
              }
            } else {
              _L___59: /* CIL Label */ 
#line 145
              tmp___249 = __builtin_constant_p((int )pt->name);
#line 145
              if (tmp___249) {
#line 145
                if ((unsigned int )((void const   *)(pt->name + 1)) - (unsigned int )((void const   *)pt->name) ==
                    1U) {
#line 145
                  __s2_len___1 = strlen(pt->name);
#line 145
                  if (__s2_len___1 < 4U) {
#line 145
                    tmp___248 = __builtin_constant_p((int )name);
#line 145
                    if (tmp___248) {
#line 145
                      if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                          1U) {
#line 145
                        tmp___220 = __builtin_strcmp(name, pt->name);
                      } else {
                        goto _L___57;
                      }
                    } else {
                      _L___57: /* CIL Label */ 
#line 145
                      __s1___46 = (unsigned char const   *)((char const   *)name);
#line 145
                      __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)pt->name +
                                                                                                 0)));
#line 145
                      if (__s2_len___1 > 0U) {
#line 145
                        if (__result___70 == 0) {
#line 145
                          __result___70 = (int )((int const   )(*(__s1___46 + 1)) -
                                                 (int const   )(*((unsigned char const   *)pt->name +
                                                                  1)));
#line 145
                          if (__s2_len___1 > 1U) {
#line 145
                            if (__result___70 == 0) {
#line 145
                              __result___70 = (int )((int const   )(*(__s1___46 +
                                                                      2)) - (int const   )(*((unsigned char const   *)pt->name +
                                                                                             2)));
#line 145
                              if (__s2_len___1 > 2U) {
#line 145
                                if (__result___70 == 0) {
#line 145
                                  __result___70 = (int )((int const   )(*(__s1___46 +
                                                                          3)) - (int const   )(*((unsigned char const   *)pt->name +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 145
                      tmp___220 = __result___70;
                    }
                  } else {
#line 145
                    tmp___220 = __builtin_strcmp(name, pt->name);
                  }
                } else {
#line 145
                  tmp___220 = __builtin_strcmp(name, pt->name);
                }
              } else {
#line 145
                tmp___220 = __builtin_strcmp(name, pt->name);
              }
            }
          }
#line 145
          if (! tmp___220) {
#line 146
            found = 1;
#line 147
            switch (pt->argtype) {
            case 1: ;
#line 149
            if (! arg) {
#line 150
              if (messages) {
#line 151
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires string as argument.\n",
                        line, name);
              }
#line 152
              fclose(fs);
#line 153
              return ((struct cfgstruct *)((void *)0));
            }
#line 155
            copt = regcfg(copt, name, arg, 0);
#line 156
            break;
            case 6: ;
#line 158
            if (! arg) {
#line 159
              if (messages) {
#line 160
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires string as argument.\n",
                        line, name);
              }
#line 161
              fclose(fs);
#line 162
              return ((struct cfgstruct *)((void *)0));
            }
#line 165
            free((void *)arg);
#line 166
            arg = strstr((char const   *)(buff), " ");
#line 167
            arg ++;
#line 167
            tmp___166 = __builtin_constant_p((int )arg);
#line 167
            if (tmp___166) {
#line 167
              arg ++;
#line 167
              arg ++;
#line 167
              if ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) ==
                  1U) {
#line 167
                arg ++;
#line 167
                if ((int const   )(*((char const   *)arg + 0)) == 0) {
#line 167
                  arg = (char *)calloc(1U, 1U);
                } else {
#line 167
                  arg ++;
#line 167
                  tmp___163 = strlen((char const   *)arg);
#line 167
                  __len___2 = tmp___163 + 1U;
#line 167
                  tmp___164 = (char *)malloc(__len___2);
#line 167
                  __retval___2 = tmp___164;
#line 167
                  if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 167
                    arg ++;
#line 167
                    __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                  (void const   * __restrict  )arg,
                                                  __len___2);
                  }
#line 167
                  arg = __retval___2;
                }
              } else {
#line 167
                arg ++;
#line 167
                arg = __strdup((char const   *)arg);
              }
            } else {
#line 167
              arg ++;
#line 167
              arg = __strdup((char const   *)arg);
            }
#line 168
            copt = regcfg(copt, name, arg, 0);
#line 169
            break;
            case 2: ;
#line 171
            if (! arg) {
              goto _L___41;
            } else {
#line 171
              tmp___167 = isnumb((char const   *)arg);
#line 171
              if (! tmp___167) {
                _L___41: /* CIL Label */ 
#line 172
                if (messages) {
#line 173
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires numerical argument.\n",
                          line, name);
                }
#line 174
                fclose(fs);
#line 175
                return ((struct cfgstruct *)((void *)0));
              }
            }
#line 177
            tmp___168 = atoi__extinline((char const   *)arg);
#line 177
            copt = regcfg(copt, name, (char *)((void *)0), tmp___168);
#line 178
            free((void *)arg);
#line 179
            break;
            case 3: ;
#line 181
            if (! arg) {
#line 182
              if (messages) {
#line 183
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires argument.\n",
                        line, name);
              }
#line 184
              fclose(fs);
#line 185
              return ((struct cfgstruct *)((void *)0));
            }
#line 187
            if (sizeof((*(arg + (tmp___177 - 1U)))) > 1U) {
#line 187
              tmp___173 = strlen((char const   *)arg);
#line 187
              tmp___174 = __builtin_constant_p((int )(*(arg + (tmp___173 - 1U))));
#line 187
              if (tmp___174) {
#line 187
                tmp___169 = strlen((char const   *)arg);
#line 187
                __c = (int )(*(arg + (tmp___169 - 1U)));
#line 187
                if (__c < -128) {
#line 187
                  __res = __c;
                } else {
#line 187
                  if (__c > 255) {
#line 187
                    __res = __c;
                  } else {
#line 187
                    tmp___171 = __ctype_tolower_loc();
#line 187
                    __res = (*((*tmp___171) + __c));
                  }
                }
              } else {
#line 187
                tmp___172 = strlen((char const   *)arg);
#line 187
                __res = tolower__extinline((int )(*(arg + (tmp___172 - 1U))));
              }
            } else {
#line 187
              tmp___175 = __ctype_tolower_loc();
#line 187
              tmp___176 = strlen((char const   *)arg);
#line 187
              __res = (*((*tmp___175) + (int )(*(arg + (tmp___176 - 1U)))));
            }
#line 187
            ctype = __res;
#line 188
            if (ctype == 109) {
              goto _L___42;
            } else {
#line 188
              if (ctype == 107) {
                _L___42: /* CIL Label */ 
#line 189
                tmp___178 = strlen((char const   *)arg);
#line 189
                tmp___179 = (char *)mcalloc(tmp___178, sizeof(char ));
#line 189
                cpy = tmp___179;
#line 190
                tmp___180 = strlen((char const   *)arg);
#line 190
                __builtin_strncpy(cpy, arg, tmp___180 - 1U);
#line 191
                tmp___181 = isnumb((char const   *)cpy);
#line 191
                if (! tmp___181) {
#line 192
                  if (messages) {
#line 193
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires numerical (raw/K/M) argument.\n",
                            line, name);
                  }
#line 194
                  fclose(fs);
#line 195
                  return ((struct cfgstruct *)((void *)0));
                }
#line 197
                if (ctype == 109) {
#line 198
                  tmp___182 = atoi__extinline((char const   *)cpy);
#line 198
                  calc = (tmp___182 * 1024) * 1024;
                } else {
#line 200
                  tmp___183 = atoi__extinline((char const   *)cpy);
#line 200
                  calc = tmp___183 * 1024;
                }
#line 201
                free((void *)cpy);
              } else {
#line 203
                tmp___184 = isnumb((char const   *)arg);
#line 203
                if (! tmp___184) {
#line 204
                  if (messages) {
#line 205
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s requires numerical (raw/K/M) argument.\n",
                            line, name);
                  }
#line 206
                  fclose(fs);
#line 207
                  return ((struct cfgstruct *)((void *)0));
                }
#line 209
                calc = atoi__extinline((char const   *)arg);
              }
            }
#line 211
            copt = regcfg(copt, name, (char *)((void *)0), calc);
#line 212
            free((void *)arg);
#line 213
            break;
            case 4: ;
#line 215
            if (arg) {
#line 216
              if (messages) {
#line 217
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s doesn\'t support arguments (got \'%s\').\n",
                        line, name, arg);
              }
#line 218
              fclose(fs);
#line 219
              return ((struct cfgstruct *)((void *)0));
            }
#line 221
            copt = regcfg(copt, name, (char *)((void *)0), 0);
#line 222
            break;
            case 5: 
#line 224
            copt = regcfg(copt, name, arg, 0);
#line 225
            break;
            default: ;
#line 227
            if (messages) {
#line 228
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Option %s is of unknown type %d\n",
                      line, name, pt->argtype);
            }
#line 229
            free((void *)name);
#line 230
            free((void *)arg);
#line 231
            break;
            }
          }
        } else {
#line 235
          break;
        }
#line 142
        i ++;
      }
#line 238
      if (! found) {
#line 239
        if (messages) {
#line 240
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: Parse error at line %d: Unknown option %s.\n",
                  line, name);
        }
#line 241
        fclose(fs);
#line 242
        return ((struct cfgstruct *)((void *)0));
      }
    }
  }
#line 247
  fclose(fs);
#line 248
  return (copt);
}
}
#line 251 "../shared/cfgparser.c"
void freecfg(struct cfgstruct *copt ) 
{ struct cfgstruct *handler ;
  struct cfgstruct *arg ;

  {
#line 256
  while (copt) {
#line 257
    arg = copt->nextarg;
#line 258
    while (arg) {
#line 259
      if (arg->strarg) {
#line 260
        free((void *)arg->optname);
#line 261
        free((void *)arg->strarg);
#line 262
        handler = arg;
#line 263
        arg = arg->nextarg;
#line 264
        free((void *)handler);
      } else {
#line 266
        arg = arg->nextarg;
      }
    }
#line 268
    if (copt->optname) {
#line 269
      free((void *)copt->optname);
    }
#line 271
    if (copt->strarg) {
#line 272
      free((void *)copt->strarg);
    }
#line 274
    handler = copt;
#line 275
    copt = copt->next;
#line 276
    free((void *)handler);
  }
#line 278
  return;
}
}
#line 281 "../shared/cfgparser.c"
struct cfgstruct *regcfg(struct cfgstruct *copt , char *optname , char *strarg , int numarg ) 
{ struct cfgstruct *newnode ;
  struct cfgstruct *pt ;

  {
#line 285
  newnode = (struct cfgstruct *)mmalloc(sizeof(struct cfgstruct ));
#line 286
  newnode->optname = optname;
#line 287
  newnode->nextarg = (struct cfgstruct *)((void *)0);
#line 288
  newnode->next = (struct cfgstruct *)((void *)0);
#line 290
  if (strarg) {
#line 291
    newnode->strarg = strarg;
  } else {
#line 293
    newnode->strarg = (char *)((void *)0);
#line 294
    newnode->numarg = numarg;
  }
#line 297
  pt = cfgopt((struct cfgstruct  const  *)copt, (char const   *)optname);
#line 297
  if (pt) {
#line 298
    while (pt->nextarg) {
#line 299
      pt = pt->nextarg;
    }
#line 301
    pt->nextarg = newnode;
#line 302
    return (copt);
  } else {
#line 304
    newnode->next = copt;
#line 305
    return (newnode);
  }
}
}
#line 309 "../shared/cfgparser.c"
struct cfgstruct *cfgopt(struct cfgstruct  const  *copt , char const   *optname ) 
{ struct cfgstruct *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 313
  handler = (struct cfgstruct *)copt;
#line 315
  while (1) {
#line 316
    if (handler) {
#line 317
      if (handler->optname) {
#line 318
        tmp___65 = __builtin_constant_p((int )handler->optname);
#line 318
        if (tmp___65) {
#line 318
          tmp___66 = __builtin_constant_p((int )optname);
#line 318
          if (tmp___66) {
#line 318
            __s1_len = strlen((char const   *)handler->optname);
#line 318
            __s2_len = strlen(optname);
#line 318
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
#line 318
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
#line 318
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
#line 318
                  tmp___67 = 1;
                } else {
#line 318
                  if (__s2_len >= 4U) {
#line 318
                    tmp___67 = 1;
                  } else {
#line 318
                    tmp___67 = 0;
                  }
                }
              } else {
#line 318
                tmp___67 = 0;
              }
            }
#line 318
            if (tmp___67) {
#line 318
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 318
          tmp___64 = __builtin_constant_p((int )handler->optname);
#line 318
          if (tmp___64) {
#line 318
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
#line 318
              __s1_len = strlen((char const   *)handler->optname);
#line 318
              if (__s1_len < 4U) {
#line 318
                tmp___53 = __builtin_constant_p((int )optname);
#line 318
                if (tmp___53) {
#line 318
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
#line 318
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
#line 318
                  __s2___6 = (unsigned char const   *)optname;
#line 318
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 318
                  if (__s1_len > 0U) {
#line 318
                    if (__result___18 == 0) {
#line 318
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 318
                      if (__s1_len > 1U) {
#line 318
                        if (__result___18 == 0) {
#line 318
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 318
                          if (__s1_len > 2U) {
#line 318
                            if (__result___18 == 0) {
#line 318
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 318
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
#line 318
            tmp___63 = __builtin_constant_p((int )optname);
#line 318
            if (tmp___63) {
#line 318
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
#line 318
                __s2_len = strlen(optname);
#line 318
                if (__s2_len < 4U) {
#line 318
                  tmp___62 = __builtin_constant_p((int )handler->optname);
#line 318
                  if (tmp___62) {
#line 318
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
#line 318
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
#line 318
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
#line 318
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
#line 318
                    if (__s2_len > 0U) {
#line 318
                      if (__result___22 == 0) {
#line 318
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
#line 318
                        if (__s2_len > 1U) {
#line 318
                          if (__result___22 == 0) {
#line 318
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
#line 318
                            if (__s2_len > 2U) {
#line 318
                              if (__result___22 == 0) {
#line 318
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 318
                    tmp___34 = __result___22;
                  }
                } else {
#line 318
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
#line 318
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
#line 318
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
#line 318
        if (! tmp___34) {
#line 319
          return (handler);
        }
      }
    } else {
#line 320
      break;
    }
#line 321
    handler = handler->next;
  }
#line 324
  return ((struct cfgstruct *)((void *)0));
}
}
#line 1 "memory.o"
#pragma merger(0,"/tmp/cil-IMcqo3FL.i","-g -O2")
#line 524 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 23 "../shared/memory.c"
void *mmalloc(size_t size ) 
{ void *alloc ;

  {
#line 27
  alloc = malloc(size);
#line 29
  if (! alloc) {
#line 30
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CRITICAL: Can\'t allocate memory (%ld bytes).\n",
            (long )size);
#line 31
    _exit(71);
#line 32
    return ((void *)0);
  } else {
#line 33
    return (alloc);
  }
}
}
#line 36 "../shared/memory.c"
void *mcalloc(size_t nmemb , size_t size ) 
{ void *alloc ;

  {
#line 40
  alloc = calloc(nmemb, size);
#line 42
  if (! alloc) {
#line 43
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CRITICAL: Can\'t allocate memory (%ld bytes).\n",
            (unsigned long )((long )nmemb) * (unsigned long )size);
#line 44
    _exit(70);
#line 45
    return ((void *)0);
  } else {
#line 46
    return (alloc);
  }
}
}
#line 1 "misc.o"
#pragma merger(0,"/tmp/cil-TGlxKGS7.i","-g -O2")
#line 331 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 312
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 198 "../libclamav/clamav.h"
char const   *cl_retdbdir(void) ;
#line 202
struct cl_cvd *cl_cvdhead(char const   *file ) ;
#line 205
void cl_cvdfree(struct cl_cvd *cvd ) ;
#line 38 "../shared/misc.c"
char *freshdbdir(void) 
{ struct cl_cvd *d1 ;
  struct cl_cvd *d2 ;
  struct cfgstruct *copt ;
  struct cfgstruct *cpt ;
  char const   *dbdir ;
  char *retdir ;
  char *daily ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __len___2 ;
  size_t tmp___87 ;
  char *__retval___2 ;
  char *tmp___88 ;
  int tmp___90 ;

  {
#line 41
  copt = (struct cfgstruct *)((void *)0);
#line 46
  dbdir = cl_retdbdir();
#line 47
  copt = parsecfg("/usr/local/etc/clamd.conf", 0);
#line 47
  if (copt) {
#line 48
    cpt = cfgopt((struct cfgstruct  const  *)copt, "DatabaseDirectory");
#line 48
    if (cpt) {
      goto _L___19;
    } else {
#line 48
      cpt = cfgopt((struct cfgstruct  const  *)copt, "DataDirectory");
#line 48
      if (cpt) {
        _L___19: /* CIL Label */ 
#line 49
        tmp___68 = __builtin_constant_p((int )dbdir);
#line 49
        if (tmp___68) {
#line 49
          tmp___69 = __builtin_constant_p((int )cpt->strarg);
#line 49
          if (tmp___69) {
#line 49
            __s1_len = strlen(dbdir);
#line 49
            __s2_len = strlen((char const   *)cpt->strarg);
#line 49
            if (! ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
                   1U)) {
              goto _L___16;
            } else {
#line 49
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
#line 49
                if (! ((unsigned int )((void const   *)(cpt->strarg + 1)) - (unsigned int )((void const   *)cpt->strarg) ==
                       1U)) {
#line 49
                  tmp___70 = 1;
                } else {
#line 49
                  if (__s2_len >= 4U) {
#line 49
                    tmp___70 = 1;
                  } else {
#line 49
                    tmp___70 = 0;
                  }
                }
              } else {
#line 49
                tmp___70 = 0;
              }
            }
#line 49
            if (tmp___70) {
#line 49
              tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 49
          tmp___67 = __builtin_constant_p((int )dbdir);
#line 49
          if (tmp___67) {
#line 49
            if ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
                1U) {
#line 49
              __s1_len = strlen(dbdir);
#line 49
              if (__s1_len < 4U) {
#line 49
                tmp___56 = __builtin_constant_p((int )cpt->strarg);
#line 49
                if (tmp___56) {
#line 49
                  if ((unsigned int )((void const   *)(cpt->strarg + 1)) - (unsigned int )((void const   *)cpt->strarg) ==
                      1U) {
#line 49
                    tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
#line 49
                  __s2___6 = (unsigned char const   *)((char const   *)cpt->strarg);
#line 49
                  __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 49
                  if (__s1_len > 0U) {
#line 49
                    if (__result___18 == 0) {
#line 49
                      __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 49
                      if (__s1_len > 1U) {
#line 49
                        if (__result___18 == 0) {
#line 49
                          __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 49
                          if (__s1_len > 2U) {
#line 49
                            if (__result___18 == 0) {
#line 49
                              __result___18 = (int )((int const   )(*((unsigned char const   *)dbdir +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 49
                  tmp___37 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
#line 49
            tmp___66 = __builtin_constant_p((int )cpt->strarg);
#line 49
            if (tmp___66) {
#line 49
              if ((unsigned int )((void const   *)(cpt->strarg + 1)) - (unsigned int )((void const   *)cpt->strarg) ==
                  1U) {
#line 49
                __s2_len = strlen((char const   *)cpt->strarg);
#line 49
                if (__s2_len < 4U) {
#line 49
                  tmp___65 = __builtin_constant_p((int )dbdir);
#line 49
                  if (tmp___65) {
#line 49
                    if ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
                        1U) {
#line 49
                      tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
#line 49
                    __s1___14 = (unsigned char const   *)dbdir;
#line 49
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                                               0)));
#line 49
                    if (__s2_len > 0U) {
#line 49
                      if (__result___22 == 0) {
#line 49
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                1)));
#line 49
                        if (__s2_len > 1U) {
#line 49
                          if (__result___22 == 0) {
#line 49
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                    2)));
#line 49
                            if (__s2_len > 2U) {
#line 49
                              if (__result___22 == 0) {
#line 49
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)cpt->strarg) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 49
                    tmp___37 = __result___22;
                  }
                } else {
#line 49
                  tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
                }
              } else {
#line 49
                tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
              }
            } else {
#line 49
              tmp___37 = __builtin_strcmp(dbdir, cpt->strarg);
            }
          }
        }
#line 49
        if (tmp___37) {
#line 50
          tmp = strlen((char const   *)cpt->strarg);
#line 50
          tmp___0 = strlen(dbdir);
#line 50
          tmp___1 = (char *)mmalloc((tmp + tmp___0) + 15U);
#line 50
          daily = tmp___1;
#line 51
          sprintf((char * __restrict  )daily, (char const   * __restrict  )"%s/daily.cvd",
                  cpt->strarg);
#line 52
          d1 = cl_cvdhead((char const   *)daily);
#line 52
          if (d1) {
#line 53
            sprintf((char * __restrict  )daily, (char const   * __restrict  )"%s/daily.cvd",
                    dbdir);
#line 54
            d2 = cl_cvdhead((char const   *)daily);
#line 54
            if (d2) {
#line 55
              free((void *)daily);
#line 56
              if (d1->version > d2->version) {
#line 57
                dbdir = (char const   *)cpt->strarg;
              }
#line 58
              cl_cvdfree(d2);
            } else {
#line 60
              free((void *)daily);
#line 61
              dbdir = (char const   *)cpt->strarg;
            }
#line 63
            cl_cvdfree(d1);
          } else {
#line 65
            free((void *)daily);
          }
        }
      }
    }
  }
#line 71
  tmp___90 = __builtin_constant_p((int )dbdir);
#line 71
  if (tmp___90) {
#line 71
    if ((unsigned int )((void const   *)(dbdir + 1)) - (unsigned int )((void const   *)dbdir) ==
        1U) {
#line 71
      if ((int const   )(*(dbdir + 0)) == 0) {
#line 71
        retdir = (char *)calloc(1U, 1U);
      } else {
#line 71
        tmp___87 = strlen(dbdir);
#line 71
        __len___2 = tmp___87 + 1U;
#line 71
        tmp___88 = (char *)malloc(__len___2);
#line 71
        __retval___2 = tmp___88;
#line 71
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 71
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dbdir,
                                        __len___2);
        }
#line 71
        retdir = __retval___2;
      }
    } else {
#line 71
      retdir = __strdup(dbdir);
    }
  } else {
#line 71
    retdir = __strdup(dbdir);
  }
#line 73
  if (copt) {
#line 74
    freecfg(copt);
  }
#line 76
  return (retdir);
}
}
#line 79 "../shared/misc.c"
void print_version(void) 
{ char *dbdir ;
  char *path ;
  struct cl_cvd *daily ;
  size_t tmp ;
  time_t t ;
  char *tmp___0 ;

  {
#line 86
  dbdir = freshdbdir();
#line 87
  tmp = strlen((char const   *)dbdir);
#line 87
  path = (char *)mmalloc(tmp + 11U);
#line 87
  if (! path) {
#line 88
    free((void *)dbdir);
#line 89
    return;
  }
#line 92
  sprintf((char * __restrict  )path, (char const   * __restrict  )"%s/daily.cvd",
          dbdir);
#line 93
  free((void *)dbdir);
#line 95
  daily = cl_cvdhead((char const   *)path);
#line 95
  if (daily) {
#line 96
    t = (long )daily->stime;
#line 97
    tmp___0 = ctime((time_t const   *)(& t));
#line 97
    printf((char const   * __restrict  )"ClamAV 0.85.1/%d/%s", daily->version, tmp___0);
#line 98
    cl_cvdfree(daily);
  } else {
#line 100
    printf((char const   * __restrict  )"ClamAV 0.85.1\n");
  }
#line 103
  free((void *)path);
#line 104
  return;
}
}
#line 106 "../shared/misc.c"
int filecopy(char const   *src , char const   *dest ) 
{ char buffer[8192] ;
  int s ;
  int d ;
  int bytes ;
  int tmp ;

  {
#line 131
  s = open(src, 0);
#line 131
  if (s == -1) {
#line 132
    return (-1);
  }
#line 134
  d = open(dest, 577);
#line 134
  if (d == -1) {
#line 135
    close(s);
#line 136
    return (-1);
  }
#line 139
  while (1) {
#line 139
    bytes = read(s, (void *)(buffer), 8192U);
#line 139
    if (! (bytes > 0)) {
#line 139
      break;
    }
#line 140
    write(d, (void const   *)(buffer), (unsigned int )bytes);
  }
#line 142
  close(s);
#line 145
  tmp = close(d);
#line 145
  return (tmp);
}
}
#line 154
extern int ( /* missing proto */  isdigit)() ;
#line 151 "../shared/misc.c"
int isnumb(char const   *str ) 
{ int tmp ;

  {
#line 153
  while ((*str)) {
#line 154
    tmp = isdigit((*str));
#line 154
    if (! tmp) {
#line 155
      return (0);
    }
#line 156
    str ++;
  }
#line 159
  return (1);
}
}
#line 1 "clamdscan.o"
#pragma merger(0,"/tmp/cil-TMGweDqx.i","-g -O2")
#line 640 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 72 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
#line 34 "../clamscan/options.h"
int optc(struct optstruct  const  *opt , char ch ) ;
#line 35
int optl(struct optstruct  const  *opt , char const   *optname ) ;
#line 38
char *getargc(struct optstruct  const  *opt , char ch ) ;
#line 44
void free_opt(struct optstruct *opt ) ;
#line 34 "../clamscan/shared.h"
short printinfected ;
#line 24 "client.h"
int client(struct optstruct  const  *opt , int *infected ) ;
#line 39 "clamdscan.c"
void help(void) ;
#line 41 "clamdscan.c"
short printinfected  =    (short)0;
#line 43
int notremoved ;
#line 43
int notmoved ;
#line 45 "clamdscan.c"
int clamscan(struct optstruct *opt ) 
{ int ds ;
  int dms ;
  int ret ;
  int infected ;
  struct timeval t1 ;
  struct timeval t2 ;
  struct timezone tz ;
  time_t starttime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 55
  tmp = optc((struct optstruct  const  *)opt, (char )'v');
#line 55
  if (tmp) {
#line 56
    mprintf_verbose = (short)1;
#line 57
    logg_verbose = (short)1;
  }
#line 60
  tmp___0 = optl((struct optstruct  const  *)opt, "quiet");
#line 60
  if (tmp___0) {
#line 61
    mprintf_quiet = (short)1;
  }
#line 63
  tmp___1 = optl((struct optstruct  const  *)opt, "stdout");
#line 63
  if (tmp___1) {
#line 64
    mprintf_stdout = (short)1;
  }
#line 66
  tmp___2 = optc((struct optstruct  const  *)opt, (char )'V');
#line 66
  if (tmp___2) {
#line 67
    print_version();
#line 68
    exit(0);
  }
#line 71
  tmp___3 = optc((struct optstruct  const  *)opt, (char )'h');
#line 71
  if (tmp___3) {
#line 72
    free_opt(opt);
#line 73
    help();
  }
#line 76
  tmp___4 = optc((struct optstruct  const  *)opt, (char )'i');
#line 76
  if (tmp___4) {
#line 77
    printinfected = (short)1;
  }
#line 81
  tmp___6 = optc((struct optstruct  const  *)opt, (char )'l');
#line 81
  if (tmp___6) {
#line 82
    logg_file = getargc((struct optstruct  const  *)opt, (char )'l');
#line 83
    tmp___5 = logg("--------------------------------------\n");
#line 83
    if (tmp___5) {
#line 84
      mprintf("!Problem with internal logger.\n");
#line 85
      exit(2);
    }
  } else {
#line 88
    logg_file = (char const   *)((void *)0);
  }
#line 91
  time(& starttime);
#line 93
  tmp___7 = ctime((time_t const   *)(& starttime));
#line 93
  logg("Scan started: %s\n", tmp___7);
#line 95
  gettimeofday((struct timeval * __restrict  )(& t1), (struct timezone * __restrict  )(& tz));
#line 97
  ret = client((struct optstruct  const  *)opt, & infected);
#line 100
  tmp___10 = optl((struct optstruct  const  *)opt, "disable-summary");
#line 100
  if (! tmp___10) {
#line 100
    tmp___11 = optl((struct optstruct  const  *)opt, "no-summary");
#line 100
    if (! tmp___11) {
#line 101
      gettimeofday((struct timeval * __restrict  )(& t2), (struct timezone * __restrict  )(& tz));
#line 102
      ds = (int )(t2.tv_sec - t1.tv_sec);
#line 103
      dms = (int )(t2.tv_usec - t1.tv_usec);
#line 104
      if (dms < 0) {
#line 104
        tmp___8 = 1;
      } else {
#line 104
        tmp___8 = 0;
      }
#line 104
      ds -= tmp___8;
#line 105
      if (dms < 0) {
#line 105
        tmp___9 = 1000000;
      } else {
#line 105
        tmp___9 = 0;
      }
#line 105
      dms += tmp___9;
#line 106
      mprintf("\n----------- SCAN SUMMARY -----------\n");
#line 107
      logg("\n-- summary --\n");
#line 108
      mprintf("Infected files: %d\n", infected);
#line 109
      logg("Infected files: %d\n", infected);
#line 110
      if (notremoved) {
#line 111
        mprintf("Not removed: %d\n", notremoved);
#line 112
        logg("Not removed: %d\n", notremoved);
      }
#line 114
      if (notmoved) {
#line 115
        mprintf("Not moved: %d\n", notmoved);
#line 116
        logg("Not moved: %d\n", notmoved);
      }
#line 118
      mprintf("Time: %d.%3.3d sec (%d m %d s)\n", ds, dms / 1000, ds / 60, ds % 60);
#line 119
      logg("Time: %d.%3.3d sec (%d m %d s)\n", ds, dms / 1000, ds / 60, ds % 60);
    }
  }
#line 122
  exit(ret);
}
}
#line 125 "clamdscan.c"
void help(void) 
{ 

  {
#line 128
  mprintf_stdout = (short)1;
#line 130
  mprintf("\n");
#line 131
  mprintf("                       ClamAV Daemon Client 0.85.1\n");
#line 132
  mprintf("     (C) 2002 - 2005 ClamAV Team - http://www.clamav.net/team.html\n\n");
#line 134
  mprintf("    --help              -h             Show help\n");
#line 135
  mprintf("    --version           -V             Print version number and exit\n");
#line 136
  mprintf("    --verbose           -v             Be verbose\n");
#line 137
  mprintf("    --quiet                            Be quiet, only output error messages\n");
#line 138
  mprintf("    --stdout                           Write to stdout instead of stderr\n");
#line 139
  mprintf("                                       (this help is always written to stdout)\n");
#line 140
  mprintf("    --log=FILE          -l FILE        Save scan report in FILE\n");
#line 141
  mprintf("    --remove                           Remove infected files. Be careful!\n");
#line 142
  mprintf("    --move=DIRECTORY                   Move infected files into DIRECTORY\n");
#line 143
  mprintf("    --config-file=FILE                 Read configuration from FILE.\n");
#line 144
  mprintf("    --no-summary                       Disable summary at end of scanning\n");
#line 145
  mprintf("\n");
#line 147
  exit(0);
}
}
#line 1 "client.o"
#pragma merger(0,"/tmp/cil-PXO2Dd2v.i","-g -O2")
#line 156 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 275
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 403
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 742
extern void perror(char const   *__s ) ;
#line 256 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 418
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 448
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 466
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 744
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 92 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 256 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 138 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 46 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int utime(char const   *__file , struct utimbuf  const  *__file_times )  __attribute__((__nonnull__(1))) ;
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 41 "../clamscan/options.h"
char *getargl(struct optstruct  const  *opt , char const   *optname ) ;
#line 24 "../libclamav/strrcpy.h"
char *strrcpy(char *dest , char const   *source ) ;
#line 59 "client.c"
void move_infected(char const   *filename , struct optstruct  const  *opt ) ;
#line 60 "client.c"
int notremoved  =    0;
#line 60 "client.c"
int notmoved  =    0;
#line 62 "client.c"
int dsresult(int sockd , struct optstruct  const  *opt ) 
{ int infected ;
  int waserror ;
  char buff[4096] ;
  char *pt ;
  FILE *fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___7 ;

  {
#line 64
  infected = 0;
#line 64
  waserror = 0;
#line 70
  tmp = dup(sockd);
#line 70
  fd = fdopen(tmp, "r");
#line 70
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
#line 74
    mprintf("@Can\'t open descriptor for reading.\n");
#line 75
    return (-1);
  }
#line 78
  while (1) {
#line 78
    tmp___5 = fgets((char * __restrict  )(buff), (int )sizeof(buff), (FILE * __restrict  )fd);
#line 78
    if (! tmp___5) {
#line 78
      break;
    }
#line 79
    tmp___3 = strstr((char const   *)(buff), "FOUND\n");
#line 79
    if (tmp___3) {
#line 80
      infected ++;
#line 81
      logg("%s", buff);
#line 82
      mprintf("%s", buff);
#line 83
      tmp___2 = optl(opt, "move");
#line 83
      if (tmp___2) {
#line 84
        pt = strrchr((char const   *)(buff), ':');
#line 85
        (*pt) = (char)0;
#line 86
        move_infected((char const   *)(buff), opt);
      } else {
#line 88
        tmp___1 = optl(opt, "remove");
#line 88
        if (tmp___1) {
#line 89
          pt = strrchr((char const   *)(buff), ':');
#line 90
          (*pt) = (char)0;
#line 91
          tmp___0 = unlink((char const   *)(buff));
#line 91
          if (tmp___0) {
#line 92
            mprintf("%s: Can\'t remove.\n", buff);
#line 93
            logg("%s: Can\'t remove.\n", buff);
#line 94
            notremoved = notremoved + 1;
          } else {
#line 96
            mprintf("%s: Removed.\n", buff);
#line 97
            logg("%s: Removed.\n", buff);
          }
        }
      }
    }
#line 102
    tmp___4 = strstr((char const   *)(buff), "ERROR\n");
#line 102
    if (tmp___4) {
#line 103
      logg("%s", buff);
#line 104
      mprintf("%s", buff);
#line 105
      waserror = 1;
    }
  }
#line 110
  fclose(fd);
#line 113
  if (infected) {
#line 113
    tmp___7 = infected;
  } else {
#line 113
    if (waserror) {
#line 113
      tmp___7 = -1;
    } else {
#line 113
      tmp___7 = 0;
    }
  }
#line 113
  return (tmp___7);
}
}
#line 116 "client.c"
int dsfile(int sockd , char const   *filename , struct optstruct  const  *opt ) 
{ int ret ;
  char *scancmd ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 122
  tmp = strlen(filename);
#line 122
  scancmd = (char *)mcalloc(tmp + 20U, sizeof(char ));
#line 123
  sprintf((char * __restrict  )scancmd, (char const   * __restrict  )"CONTSCAN %s",
          filename);
#line 125
  tmp___0 = strlen((char const   *)scancmd);
#line 125
  tmp___1 = write(sockd, (void const   *)scancmd, tmp___0);
#line 125
  if (tmp___1 <= 0) {
#line 126
    mprintf("@Can\'t write to the socket.\n");
#line 127
    free((void *)scancmd);
#line 128
    return (-1);
  }
#line 131
  free((void *)scancmd);
#line 133
  ret = dsresult(sockd, opt);
#line 135
  if (! ret) {
#line 136
    mprintf("%s: OK\n", filename);
  }
#line 138
  return (ret);
}
}
#line 184 "client.c"
int dsfd(int sockfd , int fd , struct optstruct  const  *opt ) 
{ 

  {
#line 186
  return (-1);
}
}
#line 190 "client.c"
int dsstream(int sockd , struct optstruct  const  *opt ) 
{ int wsockd ;
  int loopw ;
  int bread ;
  int port ;
  int infected ;
  struct sockaddr_in server ;
  struct sockaddr_in peer ;
  int peer_size ;
  char buff[4096] ;
  char *pt ;
  ssize_t tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 192
  loopw = 60;
#line 192
  infected = 0;
#line 199
  tmp = write(sockd, (void const   *)"STREAM", 6U);
#line 199
  if (tmp <= 0) {
#line 200
    mprintf("@Can\'t write to the socket.\n");
#line 201
    return (2);
  }
#line 204
  memset((void *)(buff), 0, sizeof(buff));
#line 205
  while (loopw) {
#line 206
    read(sockd, (void *)(buff), sizeof(buff));
#line 207
    pt = strstr((char const   *)(buff), "PORT");
#line 207
    if (pt) {
#line 208
      pt += 5;
#line 209
      sscanf((char const   * __restrict  )pt, (char const   * __restrict  )"%d", & port);
#line 210
      break;
    }
#line 212
    loopw --;
  }
#line 215
  if (! loopw) {
#line 216
    mprintf("@Daemon not ready for stream scanning.\n");
#line 217
    return (-1);
  }
#line 222
  wsockd = socket(2, 1, 0);
#line 222
  if (wsockd < 0) {
#line 223
    perror("socket()");
#line 224
    mprintf("@Can\'t create the socket.\n");
#line 225
    return (-1);
  }
#line 228
  server.sin_family = (unsigned short)2;
#line 229
  __x = (unsigned short )port;
#line 229
  tmp___0 = __builtin_constant_p((int )__x);
#line 229
  if (tmp___0) {
#line 229
    __v = (unsigned short )((((int )__x >> 8) & 255) | (((int )__x & 255) << 8));
  } else {
#line 229
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
  }
#line 229
  server.sin_port = __v;
#line 231
  peer_size = (int )sizeof(peer);
#line 232
  tmp___1 = getpeername(sockd, (struct sockaddr * __restrict  )((struct sockaddr *)(& peer)),
                        (socklen_t * __restrict  )(& peer_size));
#line 232
  if (tmp___1 < 0) {
#line 233
    perror("getpeername()");
#line 234
    mprintf("@Can\'t get socket peer name.\n");
#line 235
    return (-1);
  }
#line 238
  switch ((int )peer.sin_family) {
  case 1: 
#line 240
  server.sin_addr.s_addr = inet_addr("127.0.0.1");
#line 241
  break;
  case 2: 
#line 243
  server.sin_addr.s_addr = peer.sin_addr.s_addr;
#line 244
  break;
  default: 
#line 246
  mprintf("@Unexpected socket type: %d.\n", peer.sin_family);
#line 247
  return (-1);
  }
#line 250
  tmp___2 = connect(wsockd, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                    sizeof(struct sockaddr_in ));
#line 250
  if (tmp___2 < 0) {
#line 251
    close(wsockd);
#line 252
    perror("connect()");
#line 253
    mprintf("@Can\'t connect to clamd [port: %d].\n", port);
#line 254
    return (-1);
  }
#line 257
  while (1) {
#line 257
    bread = read(0, (void *)(buff), sizeof(buff));
#line 257
    if (! (bread > 0)) {
#line 257
      break;
    }
#line 258
    tmp___3 = write(wsockd, (void const   *)(buff), (unsigned int )bread);
#line 258
    if (tmp___3 <= 0) {
#line 259
      mprintf("@Can\'t write to the socket.\n");
#line 260
      close(wsockd);
#line 261
      return (-1);
    }
  }
#line 264
  close(wsockd);
#line 266
  memset((void *)(buff), 0, sizeof(buff));
#line 267
  while (1) {
#line 267
    bread = read(sockd, (void *)(buff), sizeof(buff));
#line 267
    if (! (bread > 0)) {
#line 267
      break;
    }
#line 268
    mprintf("%s", buff);
#line 269
    tmp___5 = strstr((char const   *)(buff), "FOUND\n");
#line 269
    if (tmp___5) {
#line 270
      infected ++;
#line 271
      logg("%s", buff);
    } else {
#line 273
      tmp___4 = strstr((char const   *)(buff), "ERROR\n");
#line 273
      if (tmp___4) {
#line 274
        logg("%s", buff);
#line 275
        return (-1);
      }
    }
#line 277
    memset((void *)(buff), 0, sizeof(buff));
  }
#line 280
  return (infected);
}
}
#line 283 "client.c"
char *abpath(char const   *filename ) 
{ struct stat foo ;
  char *fullpath ;
  char cwd[200] ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 288
  tmp___1 = stat__extinline(filename, & foo);
#line 288
  if (tmp___1 == -1) {
#line 289
    mprintf("@Can\'t access file %s\n", filename);
#line 290
    perror(filename);
#line 291
    return ((char *)((void *)0));
  } else {
#line 293
    tmp = strlen(filename);
#line 293
    fullpath = (char *)mcalloc((200U + tmp) + 10U, sizeof(char ));
#line 297
    tmp___0 = getcwd(cwd, 200U);
#line 297
    if (! tmp___0) {
#line 298
      mprintf("@Can\'t get absolute pathname of current working directory.\n");
#line 299
      return ((char *)((void *)0));
    }
#line 301
    sprintf((char * __restrict  )fullpath, (char const   * __restrict  )"%s/%s", cwd,
            filename);
  }
#line 305
  return (fullpath);
}
}
#line 308 "client.c"
int dconnect(struct optstruct  const  *opt ) 
{ struct sockaddr_un server ;
  struct sockaddr_in server2 ;
  struct hostent *he ;
  struct cfgstruct *copt ;
  struct cfgstruct *cpt ;
  char const   *clamav_conf ;
  char const   *tmp ;
  int sockd ;
  int tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___1 ;
  int tmp___2 ;
  struct cfgstruct *tmp___3 ;
  struct cfgstruct *tmp___4 ;

  {
#line 314
  tmp = getargl(opt, "config-file");
#line 314
  clamav_conf = tmp;
#line 318
  if (! clamav_conf) {
#line 319
    clamav_conf = "/usr/local/etc/clamd.conf";
  }
#line 321
  copt = parsecfg(clamav_conf, 1);
#line 321
  if ((unsigned int )copt == (unsigned int )((void *)0)) {
#line 322
    mprintf("@Can\'t parse the configuration file.\n");
#line 323
    return (-1);
  }
#line 326
  memset((void *)((char *)(& server)), 0, sizeof(server));
#line 327
  memset((void *)((char *)(& server2)), 0, sizeof(server2));
#line 330
  server2.sin_addr.s_addr = inet_addr("127.0.0.1");
#line 332
  tmp___3 = cfgopt((struct cfgstruct  const  *)copt, "TCPSocket");
#line 332
  if (tmp___3) {
#line 332
    tmp___4 = cfgopt((struct cfgstruct  const  *)copt, "LocalSocket");
#line 332
    if (tmp___4) {
#line 333
      mprintf("@Clamd is not configured properly.\n");
#line 334
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 335
    cpt = cfgopt((struct cfgstruct  const  *)copt, "LocalSocket");
#line 335
    if (cpt) {
#line 337
      server.sun_family = (unsigned short)1;
#line 338
      __builtin_strncpy(server.sun_path, cpt->strarg, sizeof(server.sun_path));
#line 340
      sockd = socket(1, 1, 0);
#line 340
      if (sockd < 0) {
#line 341
        perror("socket()");
#line 342
        mprintf("@Can\'t create the socket.\n");
#line 343
        return (-1);
      }
#line 346
      tmp___0 = connect(sockd, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                        sizeof(struct sockaddr_un ));
#line 346
      if (tmp___0 < 0) {
#line 347
        close(sockd);
#line 348
        perror("connect()");
#line 349
        mprintf("@Can\'t connect to clamd.\n");
#line 350
        return (-1);
      }
    } else {
#line 353
      cpt = cfgopt((struct cfgstruct  const  *)copt, "TCPSocket");
#line 353
      if (cpt) {
#line 355
        sockd = socket(2, 1, 0);
#line 355
        if (sockd < 0) {
#line 356
          perror("socket()");
#line 357
          mprintf("@Can\'t create the socket.\n");
#line 358
          return (-1);
        }
#line 361
        server2.sin_family = (unsigned short)2;
#line 362
        __x = (unsigned short )cpt->numarg;
#line 362
        tmp___1 = __builtin_constant_p((int )__x);
#line 362
        if (tmp___1) {
#line 362
          __v = (unsigned short )((((int )__x >> 8) & 255) | (((int )__x & 255) <<
                                                              8));
        } else {
#line 362
          __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
        }
#line 362
        server2.sin_port = __v;
#line 364
        cpt = cfgopt((struct cfgstruct  const  *)copt, "TCPAddr");
#line 364
        if (cpt) {
#line 365
          he = gethostbyname((char const   *)cpt->strarg);
#line 365
          if ((unsigned int )he == (unsigned int )((struct hostent *)0)) {
#line 366
            close(sockd);
#line 367
            perror("gethostbyname()");
#line 368
            mprintf("@Can\'t lookup clamd hostname.\n");
#line 369
            return (-1);
          }
#line 371
          server2.sin_addr = (*((struct in_addr *)(*(he->h_addr_list + 0))));
        }
#line 374
        tmp___2 = connect(sockd, (struct sockaddr  const  *)((struct sockaddr *)(& server2)),
                          sizeof(struct sockaddr_in ));
#line 374
        if (tmp___2 < 0) {
#line 375
          close(sockd);
#line 376
          perror("connect()");
#line 377
          mprintf("@Can\'t connect to clamd.\n");
#line 378
          return (-1);
        }
      } else {
#line 382
        mprintf("@Clamd is not configured properly.\n");
#line 383
        return (-1);
      }
    }
  }
#line 386
  return (sockd);
}
}
#line 389 "client.c"
int client(struct optstruct  const  *opt , int *infected ) 
{ char cwd[200] ;
  char *fullpath ;
  int sockd ;
  int ret ;
  int errors ;
  struct stat sb ;
  char *tmp ;
  int x ;
  char *thefilename ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  int tmp___73 ;

  {
#line 392
  errors = 0;
#line 396
  (*infected) = 0;
#line 400
  if ((unsigned int )opt->filename == (unsigned int )((void *)0)) {
    goto _L___20;
  } else {
#line 400
    tmp___71 = strlen((char const   *)opt->filename);
#line 400
    if (tmp___71 == 0U) {
      _L___20: /* CIL Label */ 
#line 402
      tmp = getcwd(cwd, 200U);
#line 402
      if (! tmp) {
#line 403
        mprintf("@Can\'t get absolute pathname of current working directory.\n");
#line 404
        return (2);
      }
#line 407
      sockd = dconnect(opt);
#line 407
      if (sockd < 0) {
#line 408
        return (2);
      }
#line 410
      ret = dsfile(sockd, (char const   *)(cwd), opt);
#line 410
      if (ret >= 0) {
#line 411
        (*infected) += ret;
      } else {
#line 413
        errors ++;
      }
#line 415
      close(sockd);
    } else {
#line 429
      tmp___68 = __builtin_constant_p((int )opt->filename);
#line 429
      if (tmp___68) {
#line 429
        tmp___69 = __builtin_constant_p((int )"-");
#line 429
        if (tmp___69) {
#line 429
          __s1_len = strlen((char const   *)opt->filename);
#line 429
          __s2_len = strlen("-");
#line 429
          if (! ((unsigned int )((void const   *)(opt->filename + 1)) - (unsigned int )((void const   *)opt->filename) ==
                 1U)) {
            goto _L___17;
          } else {
#line 429
            if (__s1_len >= 4U) {
              _L___17: /* CIL Label */ 
#line 429
              if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
                     1U)) {
#line 429
                tmp___70 = 1;
              } else {
#line 429
                if (__s2_len >= 4U) {
#line 429
                  tmp___70 = 1;
                } else {
#line 429
                  tmp___70 = 0;
                }
              }
            } else {
#line 429
              tmp___70 = 0;
            }
          }
#line 429
          if (tmp___70) {
#line 429
            tmp___37 = __builtin_strcmp(opt->filename, "-");
          } else {
            goto _L___19;
          }
        } else {
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
#line 429
        tmp___67 = __builtin_constant_p((int )opt->filename);
#line 429
        if (tmp___67) {
#line 429
          if ((unsigned int )((void const   *)(opt->filename + 1)) - (unsigned int )((void const   *)opt->filename) ==
              1U) {
#line 429
            __s1_len = strlen((char const   *)opt->filename);
#line 429
            if (__s1_len < 4U) {
#line 429
              tmp___56 = __builtin_constant_p((int )"-");
#line 429
              if (tmp___56) {
#line 429
                if ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
                    1U) {
#line 429
                  tmp___37 = __builtin_strcmp(opt->filename, "-");
                } else {
                  goto _L___12;
                }
              } else {
                _L___12: /* CIL Label */ 
#line 429
                __s2___6 = (unsigned char const   *)"-";
#line 429
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)opt->filename) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 429
                if (__s1_len > 0U) {
#line 429
                  if (__result___18 == 0) {
#line 429
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)opt->filename) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 429
                    if (__s1_len > 1U) {
#line 429
                      if (__result___18 == 0) {
#line 429
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)opt->filename) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 429
                        if (__s1_len > 2U) {
#line 429
                          if (__result___18 == 0) {
#line 429
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)opt->filename) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 429
                tmp___37 = __result___18;
              }
            } else {
              goto _L___16;
            }
          } else {
            goto _L___16;
          }
        } else {
          _L___16: /* CIL Label */ 
#line 429
          tmp___66 = __builtin_constant_p((int )"-");
#line 429
          if (tmp___66) {
#line 429
            if ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") ==
                1U) {
#line 429
              __s2_len = strlen("-");
#line 429
              if (__s2_len < 4U) {
#line 429
                tmp___65 = __builtin_constant_p((int )opt->filename);
#line 429
                if (tmp___65) {
#line 429
                  if ((unsigned int )((void const   *)(opt->filename + 1)) - (unsigned int )((void const   *)opt->filename) ==
                      1U) {
#line 429
                    tmp___37 = __builtin_strcmp(opt->filename, "-");
                  } else {
                    goto _L___14;
                  }
                } else {
                  _L___14: /* CIL Label */ 
#line 429
                  __s1___14 = (unsigned char const   *)((char const   *)opt->filename);
#line 429
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"-" +
                                                                                             0)));
#line 429
                  if (__s2_len > 0U) {
#line 429
                    if (__result___22 == 0) {
#line 429
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"-" +
                                                                                                 1)));
#line 429
                      if (__s2_len > 1U) {
#line 429
                        if (__result___22 == 0) {
#line 429
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"-" +
                                                                  2)));
#line 429
                          if (__s2_len > 2U) {
#line 429
                            if (__result___22 == 0) {
#line 429
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"-" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 429
                  tmp___37 = __result___22;
                }
              } else {
#line 429
                tmp___37 = __builtin_strcmp(opt->filename, "-");
              }
            } else {
#line 429
              tmp___37 = __builtin_strcmp(opt->filename, "-");
            }
          } else {
#line 429
            tmp___37 = __builtin_strcmp(opt->filename, "-");
          }
        }
      }
#line 429
      if (tmp___37) {
#line 444
        x = 0;
#line 444
        while (1) {
#line 444
          thefilename = cli_strtok((char const   *)opt->filename, x, "\t");
#line 444
          if (! ((unsigned int )thefilename != (unsigned int )((void *)0))) {
#line 444
            break;
          }
#line 445
          fullpath = thefilename;
#line 447
          tmp___1 = stat__extinline((char const   *)fullpath, & sb);
#line 447
          if (tmp___1 == -1) {
#line 448
            mprintf("@Can\'t access file %s\n", fullpath);
#line 449
            perror((char const   *)fullpath);
#line 450
            errors ++;
          } else {
#line 452
            tmp___0 = strlen((char const   *)fullpath);
#line 452
            if (tmp___0 < 2U) {
              goto _L;
            } else {
#line 452
              if ((int )(*(fullpath + 0)) != 47) {
#line 452
                if ((int )(*(fullpath + 0)) != 92) {
#line 452
                  if ((int )(*(fullpath + 1)) != 58) {
                    _L: /* CIL Label */ 
#line 453
                    fullpath = abpath((char const   *)thefilename);
#line 454
                    free((void *)thefilename);
#line 456
                    if (! fullpath) {
#line 457
                      mprintf("@Can\'t determine absolute path.\n");
#line 458
                      return (2);
                    }
                  }
                }
              }
            }
#line 462
            switch ((int )(sb.st_mode & 61440U)) {
            case 32768: ;
            case 16384: 
#line 465
            sockd = dconnect(opt);
#line 465
            if (sockd < 0) {
#line 466
              return (2);
            }
#line 468
            ret = dsfile(sockd, (char const   *)fullpath, opt);
#line 468
            if (ret >= 0) {
#line 469
              (*infected) += ret;
            } else {
#line 471
              errors ++;
            }
#line 473
            close(sockd);
#line 474
            break;
            default: 
#line 477
            mprintf("@Not supported file type (%s)\n", fullpath);
#line 478
            errors ++;
            }
          }
#line 482
          free((void *)fullpath);
#line 444
          x ++;
        }
      } else {
#line 430
        sockd = dconnect(opt);
#line 430
        if (sockd < 0) {
#line 431
          return (2);
        }
#line 433
        ret = dsstream(sockd, opt);
#line 433
        if (ret >= 0) {
#line 434
          (*infected) += ret;
        } else {
#line 436
          errors ++;
        }
#line 438
        close(sockd);
      }
    }
  }
#line 486
  if ((*infected)) {
#line 486
    tmp___73 = 1;
  } else {
#line 486
    if (errors) {
#line 486
      tmp___73 = 2;
    } else {
#line 486
      tmp___73 = 0;
    }
  }
#line 486
  return (tmp___73);
}
}
#line 489 "client.c"
void move_infected(char const   *filename , struct optstruct  const  *opt ) 
{ char *movedir ;
  char *movefilename ;
  char *tmp ;
  char numext[5] ;
  struct stat fstat___0 ;
  struct stat mfstat ;
  int n ;
  int len ;
  int movefilename_size ;
  struct utimbuf ubuf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 497
  movedir = getargl(opt, "move");
#line 497
  if (! movedir) {
#line 499
    mprintf("@getargc() returned NULL\n", filename);
#line 500
    notmoved = notmoved + 1;
#line 501
    return;
  }
#line 504
  tmp___2 = access((char const   *)movedir, 3);
#line 504
  if (tmp___2 == -1) {
#line 505
    tmp___0 = __errno_location();
#line 505
    tmp___1 = strerror((*tmp___0));
#line 505
    mprintf("@error moving file \'%s\': cannot write to \'%s\': %s\n", filename, movedir,
            tmp___1);
#line 506
    notmoved = notmoved + 1;
#line 507
    return;
  }
#line 510
  tmp___3 = stat__extinline(filename, & fstat___0);
#line 510
  if (tmp___3 == -1) {
#line 511
    mprintf("@Can\'t stat file %s\n", filename);
#line 512
    mprintf("Try to run clamdscan with clamd privileges\n");
#line 513
    notmoved = notmoved + 1;
#line 514
    return;
  }
#line 517
  tmp = strrchr(filename, '/');
#line 517
  if (! tmp) {
#line 518
    tmp = (char *)filename;
  }
#line 520
  tmp___4 = strlen((char const   *)movedir);
#line 520
  tmp___5 = strlen((char const   *)tmp);
#line 520
  movefilename_size = (int )(sizeof(char ) * (((tmp___4 + tmp___5) + sizeof(numext)) +
                                              2U));
#line 522
  movefilename = (char *)mmalloc((unsigned int )movefilename_size);
#line 522
  if (! movefilename) {
#line 523
    mprintf("@Memory allocation error\n");
#line 524
    exit(2);
  }
#line 527
  tmp___6 = strrcpy(movefilename, (char const   *)movedir);
#line 527
  if (! tmp___6) {
#line 528
    mprintf("@strrcpy() returned NULL\n");
#line 529
    notmoved = notmoved + 1;
#line 530
    free((void *)movefilename);
#line 531
    return;
  }
#line 534
  strcat((char * __restrict  )movefilename, (char const   * __restrict  )"/");
#line 536
  tmp___7 = strcat((char * __restrict  )movefilename, (char const   * __restrict  )tmp);
#line 536
  if (! tmp___7) {
#line 537
    mprintf("@strcat() returned NULL\n");
#line 538
    notmoved = notmoved + 1;
#line 539
    free((void *)movefilename);
#line 540
    return;
  }
#line 543
  tmp___10 = stat__extinline((char const   *)movefilename, & mfstat);
#line 543
  if (! tmp___10) {
#line 544
    if (fstat___0.st_ino == mfstat.st_ino) {
#line 545
      mprintf("File excluded \'%s\'\n", filename);
#line 546
      logg("File excluded \'%s\'\n", filename);
#line 547
      notmoved = notmoved + 1;
#line 548
      free((void *)movefilename);
#line 549
      return;
    } else {
#line 555
      len = (int )strlen((char const   *)movefilename);
#line 556
      n = 0;
#line 557
      while (1) {
#line 561
        (*(movefilename + len)) = (char)0;
#line 563
        tmp___8 = n;
#line 563
        n ++;
#line 563
        sprintf((char * __restrict  )(numext), (char const   * __restrict  )".%03d",
                tmp___8);
#line 564
        strcat((char * __restrict  )movefilename, (char const   * __restrict  )(numext));
#line 557
        tmp___9 = stat__extinline((char const   *)movefilename, & mfstat);
#line 557
        if (tmp___9) {
#line 557
          break;
        } else {
#line 557
          if (! (n < 1000)) {
#line 557
            break;
          }
        }
      }
    }
  }
#line 569
  tmp___17 = rename(filename, (char const   *)movefilename);
#line 569
  if (tmp___17 == -1) {
#line 570
    tmp___13 = filecopy(filename, (char const   *)movefilename);
#line 570
    if (tmp___13 == -1) {
#line 571
      tmp___11 = __errno_location();
#line 571
      tmp___12 = strerror((*tmp___11));
#line 571
      mprintf("@cannot move \'%s\' to \'%s\': %s\n", filename, movefilename, tmp___12);
#line 572
      notmoved = notmoved + 1;
#line 573
      free((void *)movefilename);
#line 574
      return;
    }
#line 577
    chmod((char const   *)movefilename, fstat___0.st_mode);
#line 578
    chown((char const   *)movefilename, fstat___0.st_uid, fstat___0.st_gid);
#line 580
    ubuf.actime = fstat___0.st_atim.tv_sec;
#line 581
    ubuf.modtime = fstat___0.st_mtim.tv_sec;
#line 582
    utime((char const   *)movefilename, (struct utimbuf  const  *)(& ubuf));
#line 584
    tmp___16 = unlink(filename);
#line 584
    if (tmp___16) {
#line 585
      tmp___14 = __errno_location();
#line 585
      tmp___15 = strerror((*tmp___14));
#line 585
      mprintf("@cannot unlink \'%s\': %s\n", filename, tmp___15);
#line 586
      notremoved = notremoved + 1;
#line 587
      free((void *)movefilename);
#line 588
      return;
    }
  }
#line 592
  mprintf("%s: moved to \'%s\'\n", filename, movefilename);
#line 593
  logg("%s: moved to \'%s\'\n", filename, movefilename);
#line 595
  free((void *)movefilename);
#line 596
  return;
}
}
#line 1 "options.o"
#pragma merger(0,"/tmp/cil-WqYW3VBu.i","-g -O2")
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 394 "/usr/include/bits/string2.h"
extern void *__rawmemchr(void const   *__s , int __c ) ;
#line 47 "../shared/getopt.h"
extern char *optarg ;
#line 61
extern int optind ;
#line 151
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 36 "options.h"
void register_char_option(struct optstruct *opt , char ch , char const   *longname ) ;
#line 37
void register_long_option(struct optstruct *opt , char const   *optname ) ;
#line 39
char *getfirstargc(struct optstruct  const  *opt , char ch , struct optnode **optnode ) ;
#line 40
char *getnextargc(struct optnode **optnode , char ch ) ;
#line 42
char *getfirstargl(struct optstruct  const  *opt , char const   *optname , struct optnode **optnode ) ;
#line 43
char *getnextargl(struct optnode **optnode , char const   *optname ) ;
#line 41 "options.c"
static char *clamdscan_long[12]  = 
#line 41
  {      (char *)"help",      (char *)"version",      (char *)"verbose",      (char *)"quiet", 
        (char *)"stdout",      (char *)"log",      (char *)"move",      (char *)"remove", 
        (char *)"config-file",      (char *)"no-summary",      (char *)"disable-summary",      (char *)((void *)0)};
#line 46 "options.c"
static char clamdscan_short[5]  = {      (char )'h',      (char )'V',      (char )'v',      (char )'l', 
        (char)0};
#line 48 "options.c"
int clamdscan_mode  =    0;
#line 57
int main(int argc , char **argv ) ;
#line 57 "options.c"
static struct option long_options[56]  = 
#line 57
  {      {"help", 0, (int *)0, 'h'}, 
        {"quiet", 0, (int *)0, 0}, 
        {"stdout", 0, (int *)0, 0}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"debug", 0, (int *)0, 0}, 
        {"version", 0, (int *)0, 'V'}, 
        {"tempdir", 1, (int *)0, 0}, 
        {"leave-temps", 0, (int *)0, 0}, 
        {"config-file", 1, (int *)0, 0}, 
        {"database", 1, (int *)0, 'd'}, 
        {"whole-file", 0, (int *)0, 'w'}, 
        {"force", 0, (int *)0, 0}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"bell", 0, (int *)0, 0}, 
        {"disable-summary", 0, (int *)0, 0}, 
        {"no-summary", 0, (int *)0, 0}, 
        {"infected", 0, (int *)0, 'i'}, 
        {"log", 1, (int *)0, 'l'}, 
        {"log-verbose", 0, (int *)0, 0}, 
        {"threads", 1, (int *)0, 0}, 
        {"one-virus", 0, (int *)0, 0}, 
        {"move", 1, (int *)0, 0}, 
        {"remove", 0, (int *)0, 0}, 
        {"exclude", 1, (int *)0, 0}, 
        {"exclude-dir", 1, (int *)0, 0}, 
        {"include", 1, (int *)0, 0}, 
        {"include-dir", 1, (int *)0, 0}, 
        {"max-files", 1, (int *)0, 0}, 
        {"max-space", 1, (int *)0, 0}, 
        {"max-ratio", 1, (int *)0, 0}, 
        {"max-recursion", 1, (int *)0, 0}, 
        {"max-dir-recursion", 1, (int *)0, 0}, 
        {"disable-archive", 0, (int *)0, 0}, 
        {"no-archive", 0, (int *)0, 0}, 
        {"detect-broken", 0, (int *)0, 0}, 
        {"block-encrypted", 0, (int *)0, 0}, 
        {"block-max", 0, (int *)0, 0}, 
        {"no-pe", 0, (int *)0, 0}, 
        {"no-ole2", 0, (int *)0, 0}, 
        {"no-html", 0, (int *)0, 0}, 
        {"mbox", 0, (int *)0, 'm'}, 
        {"no-mail", 0, (int *)0, 0}, 
        {"mail-follow-urls", 0, (int *)0, 0}, 
        {"unzip", 2, (int *)0, 0}, 
        {"unrar", 2, (int *)0, 0}, 
        {"unace", 2, (int *)0, 0}, 
        {"unarj", 2, (int *)0, 0}, 
        {"arj", 2, (int *)0, 0}, 
        {"zoo", 2, (int *)0, 0}, 
        {"unzoo", 2, (int *)0, 0}, 
        {"lha", 2, (int *)0, 0}, 
        {"jar", 2, (int *)0, 0}, 
        {"tar", 2, (int *)0, 0}, 
        {"tgz", 2, (int *)0, 0}, 
        {"deb", 2, (int *)0, 0}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 171
extern int __builtin_strncat() ;
#line 50 "options.c"
int main(int argc , char **argv ) 
{ int ret ;
  int opt_index ;
  int i ;
  int len ;
  struct optstruct *opt ;
  char const   *getopt_parameters ;
  char *tmp___0 ;
  char *tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___11 ;

  {
#line 55
  getopt_parameters = "hvd:wriVl:m";
#line 121
  opt = (struct optstruct *)mcalloc(1U, sizeof(struct optstruct ));
#line 122
  opt->optlist = (struct optnode *)((void *)0);
#line 124
  tmp___0 = strstr((char const   *)(*(argv + 0)), "clamdscan");
#line 124
  if (tmp___0) {
#line 125
    clamdscan_mode = 1;
  }
#line 127
  while (1) {
#line 129
    opt_index = 0;
#line 130
    ret = getopt_long(argc, (char * const  *)argv, getopt_parameters, (struct option  const  *)(long_options),
                      & opt_index);
#line 132
    if (ret == -1) {
#line 133
      break;
    }
#line 135
    switch (ret) {
    case 0: 
#line 137
    register_long_option(opt, long_options[opt_index].name);
#line 138
    break;
    default: 
#line 141
    tmp___7 = __builtin_constant_p(ret);
#line 141
    if (tmp___7) {
#line 141
      tmp___8 = __builtin_constant_p((int )getopt_parameters);
#line 141
      if (tmp___8) {
#line 141
        tmp___5 = (char *)__builtin_strchr(getopt_parameters, ret);
      } else {
#line 141
        if (ret == 0) {
#line 141
          tmp___5 = (char *)__rawmemchr((void const   *)getopt_parameters, ret);
        } else {
#line 141
          tmp___5 = (char *)__builtin_strchr(getopt_parameters, ret);
        }
      }
    } else {
#line 141
      tmp___5 = (char *)__builtin_strchr(getopt_parameters, ret);
    }
#line 141
    if (tmp___5) {
#line 142
      if (opt_index) {
#line 143
        register_char_option(opt, (char )ret, long_options[opt_index].name);
      } else {
#line 145
        register_char_option(opt, (char )ret, (char const   *)((void *)0));
      }
    } else {
#line 148
      mprintf("!Unknown option passed.\n");
#line 149
      free_opt(opt);
#line 150
      if (clamdscan_mode) {
#line 151
        exit(2);
      } else {
#line 153
        exit(40);
      }
    }
    }
  }
#line 158
  if (optind < argc) {
#line 160
    len = 0;
#line 164
    i = optind;
#line 164
    while (i < argc) {
#line 165
      tmp___9 = strlen((char const   *)(*(argv + i)));
#line 165
      len = (int )((size_t )len + tmp___9);
#line 164
      i ++;
    }
#line 167
    len = ((len + argc) - optind) - 1;
#line 168
    opt->filename = (char *)mcalloc((unsigned int )(len + 256), sizeof(char ));
#line 170
    i = optind;
#line 170
    while (i < argc) {
#line 171
      tmp___11 = strlen((char const   *)(*(argv + i)));
#line 171
      __builtin_strncat(opt->filename, (*(argv + i)), tmp___11);
#line 172
      if (i != argc - 1) {
#line 173
        __builtin_strncat(opt->filename, "\t", 1);
      }
#line 170
      i ++;
    }
  }
#line 177
  ret = clamscan(opt);
#line 179
  free_opt(opt);
#line 181
  return (ret);
}
}
#line 184 "options.c"
void register_char_option(struct optstruct *opt , char ch , char const   *longname ) 
{ struct optnode *newnode ;
  int i ;
  int found ;
  size_t tmp___0 ;

  {
#line 187
  found = 0;
#line 190
  if (clamdscan_mode) {
#line 191
    i = 0;
#line 191
    while (clamdscan_short[i]) {
#line 192
      if ((int )clamdscan_short[i] == (int )ch) {
#line 193
        found = 1;
      }
#line 191
      i ++;
    }
#line 195
    if (! found) {
#line 196
      if (longname) {
#line 197
        mprintf("WARNING: Ignoring option -%c (--%s): please edit clamd.conf instead.\n",
                ch, longname);
      } else {
#line 199
        mprintf("WARNING: Ignoring option -%c: please edit clamd.conf instead.\n",
                ch);
      }
#line 201
      return;
    }
  }
#line 205
  newnode = (struct optnode *)mmalloc(sizeof(struct optnode ));
#line 206
  newnode->optchar = ch;
#line 207
  if ((unsigned int )optarg != (unsigned int )((void *)0)) {
#line 208
    tmp___0 = strlen((char const   *)optarg);
#line 208
    newnode->optarg = (char *)mcalloc(tmp___0 + 1U, sizeof(char ));
#line 209
    strcpy((char * __restrict  )newnode->optarg, (char const   * __restrict  )optarg);
  } else {
#line 210
    newnode->optarg = (char *)((void *)0);
  }
#line 212
  newnode->optname = (char *)((void *)0);
#line 213
  newnode->next = opt->optlist;
#line 214
  opt->optlist = newnode;
#line 215
  return;
}
}
#line 217 "options.c"
void register_long_option(struct optstruct *opt , char const   *optname ) 
{ struct optnode *newnode ;
  int i ;
  int found ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  size_t tmp___69 ;
  size_t tmp___71 ;

  {
#line 220
  found = 0;
#line 223
  if (clamdscan_mode) {
#line 224
    i = 0;
#line 224
    while (clamdscan_long[i]) {
#line 225
      tmp___65 = __builtin_constant_p((int )clamdscan_long[i]);
#line 225
      if (tmp___65) {
#line 225
        tmp___66 = __builtin_constant_p((int )optname);
#line 225
        if (tmp___66) {
#line 225
          __s1_len = strlen((char const   *)clamdscan_long[i]);
#line 225
          __s2_len = strlen(optname);
#line 225
          if (! ((unsigned int )((void const   *)(clamdscan_long[i] + 1)) - (unsigned int )((void const   *)clamdscan_long[i]) ==
                 1U)) {
            goto _L___16;
          } else {
#line 225
            if (__s1_len >= 4U) {
              _L___16: /* CIL Label */ 
#line 225
              if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                     1U)) {
#line 225
                tmp___67 = 1;
              } else {
#line 225
                if (__s2_len >= 4U) {
#line 225
                  tmp___67 = 1;
                } else {
#line 225
                  tmp___67 = 0;
                }
              }
            } else {
#line 225
              tmp___67 = 0;
            }
          }
#line 225
          if (tmp___67) {
#line 225
            tmp___34 = __builtin_strcmp(clamdscan_long[i], optname);
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: /* CIL Label */ 
#line 225
        tmp___64 = __builtin_constant_p((int )clamdscan_long[i]);
#line 225
        if (tmp___64) {
#line 225
          if ((unsigned int )((void const   *)(clamdscan_long[i] + 1)) - (unsigned int )((void const   *)clamdscan_long[i]) ==
              1U) {
#line 225
            __s1_len = strlen((char const   *)clamdscan_long[i]);
#line 225
            if (__s1_len < 4U) {
#line 225
              tmp___53 = __builtin_constant_p((int )optname);
#line 225
              if (tmp___53) {
#line 225
                if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                    1U) {
#line 225
                  tmp___34 = __builtin_strcmp(clamdscan_long[i], optname);
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: /* CIL Label */ 
#line 225
                __s2___6 = (unsigned char const   *)optname;
#line 225
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)clamdscan_long[i]) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 225
                if (__s1_len > 0U) {
#line 225
                  if (__result___18 == 0) {
#line 225
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)clamdscan_long[i]) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 225
                    if (__s1_len > 1U) {
#line 225
                      if (__result___18 == 0) {
#line 225
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)clamdscan_long[i]) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 225
                        if (__s1_len > 2U) {
#line 225
                          if (__result___18 == 0) {
#line 225
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)clamdscan_long[i]) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 225
                tmp___34 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: /* CIL Label */ 
#line 225
          tmp___63 = __builtin_constant_p((int )optname);
#line 225
          if (tmp___63) {
#line 225
            if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                1U) {
#line 225
              __s2_len = strlen(optname);
#line 225
              if (__s2_len < 4U) {
#line 225
                tmp___62 = __builtin_constant_p((int )clamdscan_long[i]);
#line 225
                if (tmp___62) {
#line 225
                  if ((unsigned int )((void const   *)(clamdscan_long[i] + 1)) - (unsigned int )((void const   *)clamdscan_long[i]) ==
                      1U) {
#line 225
                    tmp___34 = __builtin_strcmp(clamdscan_long[i], optname);
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: /* CIL Label */ 
#line 225
                  __s1___14 = (unsigned char const   *)((char const   *)clamdscan_long[i]);
#line 225
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                             0)));
#line 225
                  if (__s2_len > 0U) {
#line 225
                    if (__result___22 == 0) {
#line 225
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)optname +
                                                                                                 1)));
#line 225
                      if (__s2_len > 1U) {
#line 225
                        if (__result___22 == 0) {
#line 225
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)optname +
                                                                  2)));
#line 225
                          if (__s2_len > 2U) {
#line 225
                            if (__result___22 == 0) {
#line 225
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 225
                  tmp___34 = __result___22;
                }
              } else {
#line 225
                tmp___34 = __builtin_strcmp(clamdscan_long[i], optname);
              }
            } else {
#line 225
              tmp___34 = __builtin_strcmp(clamdscan_long[i], optname);
            }
          } else {
#line 225
            tmp___34 = __builtin_strcmp(clamdscan_long[i], optname);
          }
        }
      }
#line 225
      if (! tmp___34) {
#line 226
        found = 1;
      }
#line 224
      i ++;
    }
#line 228
    if (! found) {
#line 229
      mprintf("WARNING: Ignoring option --%s: please edit clamd.conf instead.\n",
              optname);
#line 230
      return;
    }
  }
#line 234
  newnode = (struct optnode *)mmalloc(sizeof(struct optnode ));
#line 235
  newnode->optchar = (char)0;
#line 236
  if ((unsigned int )optarg != (unsigned int )((void *)0)) {
#line 237
    tmp___69 = strlen((char const   *)optarg);
#line 237
    newnode->optarg = (char *)mcalloc(tmp___69 + 1U, sizeof(char ));
#line 238
    strcpy((char * __restrict  )newnode->optarg, (char const   * __restrict  )optarg);
  } else {
#line 239
    newnode->optarg = (char *)((void *)0);
  }
#line 241
  tmp___71 = strlen(optname);
#line 241
  newnode->optname = (char *)mcalloc(tmp___71 + 1U, sizeof(char ));
#line 242
  strcpy((char * __restrict  )newnode->optname, (char const   * __restrict  )optname);
#line 243
  newnode->next = opt->optlist;
#line 244
  opt->optlist = newnode;
#line 245
  return;
}
}
#line 247 "options.c"
int optc(struct optstruct  const  *opt , char ch ) 
{ struct optnode *handler ;

  {
#line 251
  handler = opt->optlist;
#line 253
  while (1) {
#line 254
    if (handler) {
#line 255
      if ((int )handler->optchar == (int )ch) {
#line 255
        return (1);
      }
    } else {
#line 256
      break;
    }
#line 257
    handler = handler->next;
  }
#line 260
  return (0);
}
}
#line 263 "options.c"
int optl(struct optstruct  const  *opt , char const   *optname ) 
{ struct optnode *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 267
  handler = opt->optlist;
#line 269
  while (1) {
#line 270
    if (handler) {
#line 271
      if (handler->optname) {
#line 272
        tmp___65 = __builtin_constant_p((int )handler->optname);
#line 272
        if (tmp___65) {
#line 272
          tmp___66 = __builtin_constant_p((int )optname);
#line 272
          if (tmp___66) {
#line 272
            __s1_len = strlen((char const   *)handler->optname);
#line 272
            __s2_len = strlen(optname);
#line 272
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
#line 272
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
#line 272
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
#line 272
                  tmp___67 = 1;
                } else {
#line 272
                  if (__s2_len >= 4U) {
#line 272
                    tmp___67 = 1;
                  } else {
#line 272
                    tmp___67 = 0;
                  }
                }
              } else {
#line 272
                tmp___67 = 0;
              }
            }
#line 272
            if (tmp___67) {
#line 272
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 272
          tmp___64 = __builtin_constant_p((int )handler->optname);
#line 272
          if (tmp___64) {
#line 272
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
#line 272
              __s1_len = strlen((char const   *)handler->optname);
#line 272
              if (__s1_len < 4U) {
#line 272
                tmp___53 = __builtin_constant_p((int )optname);
#line 272
                if (tmp___53) {
#line 272
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
#line 272
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
#line 272
                  __s2___6 = (unsigned char const   *)optname;
#line 272
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 272
                  if (__s1_len > 0U) {
#line 272
                    if (__result___18 == 0) {
#line 272
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 272
                      if (__s1_len > 1U) {
#line 272
                        if (__result___18 == 0) {
#line 272
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 272
                          if (__s1_len > 2U) {
#line 272
                            if (__result___18 == 0) {
#line 272
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 272
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
#line 272
            tmp___63 = __builtin_constant_p((int )optname);
#line 272
            if (tmp___63) {
#line 272
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
#line 272
                __s2_len = strlen(optname);
#line 272
                if (__s2_len < 4U) {
#line 272
                  tmp___62 = __builtin_constant_p((int )handler->optname);
#line 272
                  if (tmp___62) {
#line 272
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
#line 272
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
#line 272
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
#line 272
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
#line 272
                    if (__s2_len > 0U) {
#line 272
                      if (__result___22 == 0) {
#line 272
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
#line 272
                        if (__s2_len > 1U) {
#line 272
                          if (__result___22 == 0) {
#line 272
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
#line 272
                            if (__s2_len > 2U) {
#line 272
                              if (__result___22 == 0) {
#line 272
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 272
                    tmp___34 = __result___22;
                  }
                } else {
#line 272
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
#line 272
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
#line 272
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
#line 272
        if (! tmp___34) {
#line 272
          return (1);
        }
      }
    } else {
#line 273
      break;
    }
#line 274
    handler = handler->next;
  }
#line 277
  return (0);
}
}
#line 280 "options.c"
char *getargc(struct optstruct  const  *opt , char ch ) 
{ struct optnode *handler ;

  {
#line 284
  handler = opt->optlist;
#line 286
  while (1) {
#line 287
    if (handler) {
#line 288
      if ((int )handler->optchar == (int )ch) {
#line 288
        return (handler->optarg);
      }
    } else {
#line 289
      break;
    }
#line 290
    handler = handler->next;
  }
#line 293
  return ((char *)((void *)0));
}
}
#line 296 "options.c"
char *getfirstargc(struct optstruct  const  *opt , char ch , struct optnode **optnode ) 
{ struct optnode *handler ;

  {
#line 300
  handler = opt->optlist;
#line 302
  while (1) {
#line 303
    if (handler) {
#line 304
      if ((int )handler->optchar == (int )ch) {
#line 305
        (*optnode) = handler;
#line 306
        return (handler->optarg);
      }
    } else {
#line 308
      break;
    }
#line 309
    handler = handler->next;
  }
#line 311
  (*optnode) = (struct optnode *)((void *)0);
#line 312
  return ((char *)((void *)0));
}
}
#line 315 "options.c"
char *getnextargc(struct optnode **optnode , char ch ) 
{ struct optnode *handler ;

  {
#line 319
  handler = ((*optnode))->next;
#line 321
  while (1) {
#line 322
    if (handler) {
#line 323
      if ((int )handler->optchar == (int )ch) {
#line 324
        (*optnode) = handler;
#line 325
        return (handler->optarg);
      }
    } else {
#line 327
      break;
    }
#line 328
    handler = handler->next;
  }
#line 330
  (*optnode) = (struct optnode *)((void *)0);
#line 331
  return ((char *)((void *)0));
}
}
#line 334 "options.c"
char *getargl(struct optstruct  const  *opt , char const   *optname ) 
{ struct optnode *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 338
  handler = opt->optlist;
#line 340
  while (1) {
#line 341
    if (handler) {
#line 342
      if (handler->optname) {
#line 343
        tmp___65 = __builtin_constant_p((int )handler->optname);
#line 343
        if (tmp___65) {
#line 343
          tmp___66 = __builtin_constant_p((int )optname);
#line 343
          if (tmp___66) {
#line 343
            __s1_len = strlen((char const   *)handler->optname);
#line 343
            __s2_len = strlen(optname);
#line 343
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
#line 343
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
#line 343
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
#line 343
                  tmp___67 = 1;
                } else {
#line 343
                  if (__s2_len >= 4U) {
#line 343
                    tmp___67 = 1;
                  } else {
#line 343
                    tmp___67 = 0;
                  }
                }
              } else {
#line 343
                tmp___67 = 0;
              }
            }
#line 343
            if (tmp___67) {
#line 343
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 343
          tmp___64 = __builtin_constant_p((int )handler->optname);
#line 343
          if (tmp___64) {
#line 343
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
#line 343
              __s1_len = strlen((char const   *)handler->optname);
#line 343
              if (__s1_len < 4U) {
#line 343
                tmp___53 = __builtin_constant_p((int )optname);
#line 343
                if (tmp___53) {
#line 343
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
#line 343
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
#line 343
                  __s2___6 = (unsigned char const   *)optname;
#line 343
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 343
                  if (__s1_len > 0U) {
#line 343
                    if (__result___18 == 0) {
#line 343
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 343
                      if (__s1_len > 1U) {
#line 343
                        if (__result___18 == 0) {
#line 343
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 343
                          if (__s1_len > 2U) {
#line 343
                            if (__result___18 == 0) {
#line 343
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 343
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
#line 343
            tmp___63 = __builtin_constant_p((int )optname);
#line 343
            if (tmp___63) {
#line 343
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
#line 343
                __s2_len = strlen(optname);
#line 343
                if (__s2_len < 4U) {
#line 343
                  tmp___62 = __builtin_constant_p((int )handler->optname);
#line 343
                  if (tmp___62) {
#line 343
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
#line 343
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
#line 343
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
#line 343
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
#line 343
                    if (__s2_len > 0U) {
#line 343
                      if (__result___22 == 0) {
#line 343
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
#line 343
                        if (__s2_len > 1U) {
#line 343
                          if (__result___22 == 0) {
#line 343
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
#line 343
                            if (__s2_len > 2U) {
#line 343
                              if (__result___22 == 0) {
#line 343
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 343
                    tmp___34 = __result___22;
                  }
                } else {
#line 343
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
#line 343
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
#line 343
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
#line 343
        if (! tmp___34) {
#line 343
          return (handler->optarg);
        }
      }
    } else {
#line 344
      break;
    }
#line 345
    handler = handler->next;
  }
#line 348
  return ((char *)((void *)0));
}
}
#line 351 "options.c"
char *getfirstargl(struct optstruct  const  *opt , char const   *optname , struct optnode **optnode ) 
{ struct optnode *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 355
  handler = opt->optlist;
#line 357
  while (1) {
#line 358
    if (handler) {
#line 359
      if (handler->optname) {
#line 360
        tmp___65 = __builtin_constant_p((int )handler->optname);
#line 360
        if (tmp___65) {
#line 360
          tmp___66 = __builtin_constant_p((int )optname);
#line 360
          if (tmp___66) {
#line 360
            __s1_len = strlen((char const   *)handler->optname);
#line 360
            __s2_len = strlen(optname);
#line 360
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
#line 360
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
#line 360
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
#line 360
                  tmp___67 = 1;
                } else {
#line 360
                  if (__s2_len >= 4U) {
#line 360
                    tmp___67 = 1;
                  } else {
#line 360
                    tmp___67 = 0;
                  }
                }
              } else {
#line 360
                tmp___67 = 0;
              }
            }
#line 360
            if (tmp___67) {
#line 360
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 360
          tmp___64 = __builtin_constant_p((int )handler->optname);
#line 360
          if (tmp___64) {
#line 360
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
#line 360
              __s1_len = strlen((char const   *)handler->optname);
#line 360
              if (__s1_len < 4U) {
#line 360
                tmp___53 = __builtin_constant_p((int )optname);
#line 360
                if (tmp___53) {
#line 360
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
#line 360
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
#line 360
                  __s2___6 = (unsigned char const   *)optname;
#line 360
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 360
                  if (__s1_len > 0U) {
#line 360
                    if (__result___18 == 0) {
#line 360
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 360
                      if (__s1_len > 1U) {
#line 360
                        if (__result___18 == 0) {
#line 360
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 360
                          if (__s1_len > 2U) {
#line 360
                            if (__result___18 == 0) {
#line 360
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 360
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
#line 360
            tmp___63 = __builtin_constant_p((int )optname);
#line 360
            if (tmp___63) {
#line 360
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
#line 360
                __s2_len = strlen(optname);
#line 360
                if (__s2_len < 4U) {
#line 360
                  tmp___62 = __builtin_constant_p((int )handler->optname);
#line 360
                  if (tmp___62) {
#line 360
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
#line 360
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
#line 360
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
#line 360
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
#line 360
                    if (__s2_len > 0U) {
#line 360
                      if (__result___22 == 0) {
#line 360
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
#line 360
                        if (__s2_len > 1U) {
#line 360
                          if (__result___22 == 0) {
#line 360
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
#line 360
                            if (__s2_len > 2U) {
#line 360
                              if (__result___22 == 0) {
#line 360
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 360
                    tmp___34 = __result___22;
                  }
                } else {
#line 360
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
#line 360
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
#line 360
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
#line 360
        if (! tmp___34) {
#line 361
          (*optnode) = handler;
#line 362
          return (handler->optarg);
        }
      }
    } else {
#line 364
      break;
    }
#line 365
    handler = handler->next;
  }
#line 368
  (*optnode) = (struct optnode *)((void *)0);
#line 369
  return ((char *)((void *)0));
}
}
#line 372 "options.c"
char *getnextargl(struct optnode **optnode , char const   *optname ) 
{ struct optnode *handler ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 376
  handler = ((*optnode))->next;
#line 378
  while (1) {
#line 379
    if (handler) {
#line 380
      if (handler->optname) {
#line 381
        tmp___65 = __builtin_constant_p((int )handler->optname);
#line 381
        if (tmp___65) {
#line 381
          tmp___66 = __builtin_constant_p((int )optname);
#line 381
          if (tmp___66) {
#line 381
            __s1_len = strlen((char const   *)handler->optname);
#line 381
            __s2_len = strlen(optname);
#line 381
            if (! ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                   1U)) {
              goto _L___16;
            } else {
#line 381
              if (__s1_len >= 4U) {
                _L___16: /* CIL Label */ 
#line 381
                if (! ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                       1U)) {
#line 381
                  tmp___67 = 1;
                } else {
#line 381
                  if (__s2_len >= 4U) {
#line 381
                    tmp___67 = 1;
                  } else {
#line 381
                    tmp___67 = 0;
                  }
                }
              } else {
#line 381
                tmp___67 = 0;
              }
            }
#line 381
            if (tmp___67) {
#line 381
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: /* CIL Label */ 
#line 381
          tmp___64 = __builtin_constant_p((int )handler->optname);
#line 381
          if (tmp___64) {
#line 381
            if ((unsigned int )((void const   *)(handler->optname + 1)) - (unsigned int )((void const   *)handler->optname) ==
                1U) {
#line 381
              __s1_len = strlen((char const   *)handler->optname);
#line 381
              if (__s1_len < 4U) {
#line 381
                tmp___53 = __builtin_constant_p((int )optname);
#line 381
                if (tmp___53) {
#line 381
                  if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                      1U) {
#line 381
                    tmp___34 = __builtin_strcmp(handler->optname, optname);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: /* CIL Label */ 
#line 381
                  __s2___6 = (unsigned char const   *)optname;
#line 381
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 381
                  if (__s1_len > 0U) {
#line 381
                    if (__result___18 == 0) {
#line 381
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 381
                      if (__s1_len > 1U) {
#line 381
                        if (__result___18 == 0) {
#line 381
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 381
                          if (__s1_len > 2U) {
#line 381
                            if (__result___18 == 0) {
#line 381
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)handler->optname) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 381
                  tmp___34 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: /* CIL Label */ 
#line 381
            tmp___63 = __builtin_constant_p((int )optname);
#line 381
            if (tmp___63) {
#line 381
              if ((unsigned int )((void const   *)(optname + 1)) - (unsigned int )((void const   *)optname) ==
                  1U) {
#line 381
                __s2_len = strlen(optname);
#line 381
                if (__s2_len < 4U) {
#line 381
                  tmp___62 = __builtin_constant_p((int )handler->optname);
#line 381
                  if (tmp___62) {
#line 381
                    if ((unsigned int )((void const   *)(handler->optname + 1)) -
                        (unsigned int )((void const   *)handler->optname) == 1U) {
#line 381
                      tmp___34 = __builtin_strcmp(handler->optname, optname);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: /* CIL Label */ 
#line 381
                    __s1___14 = (unsigned char const   *)((char const   *)handler->optname);
#line 381
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               0)));
#line 381
                    if (__s2_len > 0U) {
#line 381
                      if (__result___22 == 0) {
#line 381
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)optname +
                                                                1)));
#line 381
                        if (__s2_len > 1U) {
#line 381
                          if (__result___22 == 0) {
#line 381
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)optname +
                                                                    2)));
#line 381
                            if (__s2_len > 2U) {
#line 381
                              if (__result___22 == 0) {
#line 381
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)optname +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 381
                    tmp___34 = __result___22;
                  }
                } else {
#line 381
                  tmp___34 = __builtin_strcmp(handler->optname, optname);
                }
              } else {
#line 381
                tmp___34 = __builtin_strcmp(handler->optname, optname);
              }
            } else {
#line 381
              tmp___34 = __builtin_strcmp(handler->optname, optname);
            }
          }
        }
#line 381
        if (! tmp___34) {
#line 382
          (*optnode) = handler;
#line 383
          return (handler->optarg);
        }
      }
    } else {
#line 385
      break;
    }
#line 386
    handler = handler->next;
  }
#line 389
  (*optnode) = (struct optnode *)((void *)0);
#line 390
  return ((char *)((void *)0));
}
}
#line 393 "options.c"
void free_opt(struct optstruct *opt ) 
{ struct optnode *handler ;
  struct optnode *prev ;

  {
#line 397
  if (! opt) {
#line 398
    return;
  }
#line 400
  handler = opt->optlist;
#line 402
  while ((unsigned int )handler != (unsigned int )((void *)0)) {
#line 403
    handler->optchar = (char)0;
#line 404
    if (handler->optarg) {
#line 404
      free((void *)handler->optarg);
    }
#line 405
    if (handler->optname) {
#line 405
      free((void *)handler->optname);
    }
#line 406
    prev = handler;
#line 407
    handler = handler->next;
#line 408
    free((void *)prev);
  }
#line 411
  if (opt->filename) {
#line 412
    free((void *)opt->filename);
  }
#line 413
  free((void *)opt);
#line 414
  return;
}
}
#line 1 "getopt.o"
#pragma merger(0,"/tmp/cil-OHqCO3DF.i","-g -O2")
#line 1 "matcher-ac.lo"
#pragma merger(0,"/tmp/cil-39hsQXnz.i","-g -O2 -fPIC")
#line 28 "others.h"
void cli_dbgmsg(char const   *str  , ...) ;
#line 30
void *cli_calloc(size_t nmemb , size_t size ) ;
#line 31
void *cli_realloc(void *ptr , size_t size ) ;
#line 28 "matcher.h"
int cli_validatesig(unsigned short target , unsigned short ftype , char const   *offstr ,
                    unsigned long fileoff , int desc , char const   *virname ) ;
#line 25 "matcher-ac.h"
int cli_ac_addpatt(struct cl_node *root , struct cli_ac_patt *pattern ) ;
#line 26
int cli_ac_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , int *partcnt , short otfrec , unsigned long offset ,
                    unsigned long *partoff , unsigned short ftype , int fd ) ;
#line 27
int cli_ac_buildtrie(struct cl_node *root ) ;
#line 28
void cli_ac_free(struct cl_node *root ) ;
#line 55 "filetypes.h"
int cli_addtypesigs(struct cl_node *root ) ;
#line 47 "matcher-ac.c"
int cli_ac_addpatt(struct cl_node *root , struct cli_ac_patt *pattern ) 
{ struct cli_ac_node *pos ;
  struct cli_ac_node *next ;
  int i ;

  {
#line 52
  if (pattern->length < 2U) {
#line 53
    return (-6);
  }
#line 55
  pos = root->ac_root;
#line 57
  i = 0;
#line 57
  while (i < 2) {
#line 58
    next = pos->trans[(int )((unsigned char )(*(pattern->pattern + i))) & 255];
#line 60
    if (! next) {
#line 61
      next = (struct cli_ac_node *)cli_calloc(1U, sizeof(struct cli_ac_node ));
#line 62
      if (! next) {
#line 63
        cli_dbgmsg("Unable to allocate pattern node (%d)\n", sizeof(struct cl_node ));
#line 64
        return (-3);
      }
#line 67
      root->ac_nodes ++;
#line 68
      root->ac_nodetable = (struct cli_ac_node **)cli_realloc((void *)root->ac_nodetable,
                                                              root->ac_nodes * sizeof(struct cli_ac_node *));
#line 69
      if ((unsigned int )root->ac_nodetable == (unsigned int )((void *)0)) {
#line 70
        cli_dbgmsg("Unable to realloc nodetable (%d)\n", root->ac_nodes * sizeof(struct cl_node *));
#line 71
        return (-3);
      }
#line 73
      (*(root->ac_nodetable + (root->ac_nodes - 1U))) = next;
#line 75
      pos->trans[(int )((unsigned char )(*(pattern->pattern + i))) & 255] = next;
    }
#line 78
    pos = next;
#line 57
    i ++;
  }
#line 81
  pos->islast = (char)1;
#line 83
  pattern->next = pos->list;
#line 84
  pos->list = pattern;
#line 86
  return (0);
}
}
#line 89 "matcher-ac.c"
static int cli_enqueue(struct nodelist **bfs , struct cli_ac_node *n ) 
{ struct nodelist *new ;

  {
#line 93
  new = (struct nodelist *)cli_calloc(1U, sizeof(struct nodelist ));
#line 94
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 95
    cli_dbgmsg("Unable to allocate node list (%d)\n", sizeof(struct nodelist ));
#line 96
    return (-3);
  }
#line 99
  new->next = (*bfs);
#line 100
  new->node = n;
#line 101
  (*bfs) = new;
#line 102
  return (0);
}
}
#line 105 "matcher-ac.c"
static struct cli_ac_node *cli_dequeue(struct nodelist **bfs ) 
{ struct nodelist *handler ;
  struct nodelist *prev ;
  struct cli_ac_node *pt ;

  {
#line 107
  prev = (struct nodelist *)((void *)0);
#line 110
  handler = (*bfs);
#line 112
  while (1) {
#line 112
    if (handler) {
#line 112
      if (! handler->next) {
#line 112
        break;
      }
    } else {
#line 112
      break;
    }
#line 113
    prev = handler;
#line 114
    handler = handler->next;
  }
#line 117
  if (! handler) {
#line 118
    return ((struct cli_ac_node *)((void *)0));
  } else {
#line 120
    pt = handler->node;
#line 121
    free((void *)handler);
#line 122
    if (prev) {
#line 123
      prev->next = (struct nodelist *)((void *)0);
    } else {
#line 125
      (*bfs) = (struct nodelist *)((void *)0);
    }
#line 127
    return (pt);
  }
}
}
#line 131 "matcher-ac.c"
static int cli_maketrans(struct cl_node *root ) 
{ struct nodelist *bfs ;
  struct cli_ac_node *ac_root ;
  struct cli_ac_node *child ;
  struct cli_ac_node *node ;
  int i ;
  int ret ;

  {
#line 133
  bfs = (struct nodelist *)((void *)0);
#line 134
  ac_root = root->ac_root;
#line 138
  ac_root->fail = (struct cli_ac_node *)((void *)0);
#line 139
  ret = cli_enqueue(& bfs, ac_root);
#line 139
  if (ret != 0) {
#line 140
    return (ret);
  }
#line 143
  while (1) {
#line 143
    node = cli_dequeue(& bfs);
#line 143
    if (! node) {
#line 143
      break;
    }
#line 144
    if (node->islast) {
#line 145
      continue;
    }
#line 147
    i = 0;
#line 147
    while (i < 256) {
#line 148
      child = node->trans[i];
#line 149
      if (! child) {
#line 150
        if (node->fail) {
#line 151
          node->trans[i] = (node->fail)->trans[i];
        } else {
#line 153
          node->trans[i] = ac_root;
        }
      } else {
#line 155
        if (node->fail) {
#line 156
          child->fail = (node->fail)->trans[i];
        } else {
#line 158
          child->fail = ac_root;
        }
#line 160
        ret = cli_enqueue(& bfs, child);
#line 160
        if (ret != 0) {
#line 161
          return (ret);
        }
      }
#line 147
      i ++;
    }
  }
#line 166
  return (0);
}
}
#line 169 "matcher-ac.c"
int cli_ac_buildtrie(struct cl_node *root ) 
{ int ret ;
  int tmp ;

  {
#line 173
  if (! root) {
#line 174
    return (-5);
  }
#line 176
  if (! root->ac_root) {
#line 177
    cli_dbgmsg("Pattern matcher not initialised\n");
#line 178
    return (0);
  }
#line 181
  ret = cli_addtypesigs(root);
#line 181
  if (ret) {
#line 182
    return (ret);
  }
#line 184
  tmp = cli_maketrans(root);
#line 184
  return (tmp);
}
}
#line 187 "matcher-ac.c"
static void cli_freepatt(struct cli_ac_patt *list ) 
{ struct cli_ac_patt *handler ;
  struct cli_ac_patt *prev ;
  int i ;

  {
#line 193
  handler = list;
#line 195
  while (handler) {
#line 196
    free((void *)handler->pattern);
#line 197
    free((void *)handler->virname);
#line 198
    if (handler->offset) {
#line 198
      if (! handler->sigid) {
#line 199
        free((void *)handler->offset);
      } else {
#line 198
        if ((int )handler->partno == 1) {
#line 199
          free((void *)handler->offset);
        }
      }
    }
#line 200
    if (handler->alt) {
#line 201
      free((void *)handler->altn);
#line 202
      i = 0;
#line 202
      while (i < (int )handler->alt) {
#line 203
        free((void *)(*(handler->altc + i)));
#line 202
        i ++;
      }
#line 204
      free((void *)handler->altc);
    }
#line 206
    prev = handler;
#line 207
    handler = handler->next;
#line 208
    free((void *)prev);
  }
#line 210
  return;
}
}
#line 212 "matcher-ac.c"
void cli_ac_free(struct cl_node *root ) 
{ unsigned int i ;

  {
#line 217
  i = 0U;
#line 217
  while (i < root->ac_nodes) {
#line 218
    cli_freepatt(((*(root->ac_nodetable + i)))->list);
#line 219
    free((void *)(*(root->ac_nodetable + i)));
#line 217
    i ++;
  }
#line 222
  if (root->ac_nodetable) {
#line 223
    free((void *)root->ac_nodetable);
  }
#line 225
  if (root->ac_root) {
#line 226
    free((void *)root->ac_root);
  }
#line 227
  return;
}
}
#line 229 "matcher-ac.c"
__inline static int cli_findpos(char const   *buffer , int offset , int length , struct cli_ac_patt  const  *pattern ) 
{ int bufferpos ;
  int postfixend ;
  unsigned int i ;
  unsigned int j ;
  unsigned int alt ;
  unsigned int found ;

  {
#line 231
  bufferpos = offset + 2;
#line 232
  postfixend = offset + length;
#line 233
  alt = 0U;
#line 233
  found = 0U;
#line 236
  if (bufferpos >= length) {
#line 237
    bufferpos %= length;
  }
#line 239
  i = 2U;
#line 239
  while (i < pattern->length) {
#line 241
    if (bufferpos == postfixend) {
#line 242
      return (0);
    }
#line 244
    if ((int )(*(pattern->pattern + i)) == -201) {
#line 245
      j = 0U;
#line 245
      while (j < (unsigned int )(*(pattern->altn + alt))) {
#line 246
        if ((int )(*((*(pattern->altc + alt)) + j)) == (int )(*(buffer + bufferpos))) {
#line 247
          found = 1U;
        }
#line 245
        j ++;
      }
#line 250
      if (! found) {
#line 251
        return (0);
      }
#line 252
      alt ++;
    } else {
#line 254
      if ((int )(*(pattern->pattern + i)) != -200) {
#line 254
        if ((int )((char )(*(pattern->pattern + i))) != (int )(*(buffer + bufferpos))) {
#line 255
          return (0);
        }
      }
    }
#line 257
    bufferpos ++;
#line 259
    if (bufferpos == length) {
#line 260
      bufferpos = 0;
    }
#line 239
    i ++;
  }
#line 263
  return (1);
}
}
#line 266 "matcher-ac.c"
int cli_ac_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , int *partcnt , short otfrec , unsigned long offset ,
                    unsigned long *partoff , unsigned short ftype , int fd ) 
{ struct cli_ac_node *current ;
  struct cli_ac_patt *pt ;
  int position ;
  int type ;
  int dist ;
  int t ;
  unsigned int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 270
  type = 0;
#line 274
  if (! root->ac_root) {
#line 275
    return (0);
  }
#line 277
  if (! partcnt) {
#line 278
    cli_dbgmsg("cli_ac_scanbuff(): partcnt == NULL || partoff == NULL\n");
#line 279
    return (300);
  } else {
#line 277
    if (! partoff) {
#line 278
      cli_dbgmsg("cli_ac_scanbuff(): partcnt == NULL || partoff == NULL\n");
#line 279
      return (300);
    }
  }
#line 282
  current = root->ac_root;
#line 284
  i = 0U;
#line 284
  while (i < length) {
#line 285
    current = current->trans[(int )((unsigned char )(*(buffer + i))) & 255];
#line 287
    if (current->islast) {
#line 288
      position = (int )((i - 2U) + 1U);
#line 290
      pt = current->list;
#line 291
      while (pt) {
#line 292
        tmp___0 = cli_findpos(buffer, position, (int )length, (struct cli_ac_patt  const  *)pt);
#line 292
        if (tmp___0) {
#line 293
          if (pt->offset) {
            goto _L___1;
          } else {
#line 293
            if (pt->target) {
              _L___1: 
#line 293
              if (! pt->sigid) {
                goto _L___0;
              } else {
#line 293
                if ((int )pt->partno == 1) {
                  _L___0: 
#line 294
                  if ((int )ftype == 500) {
#line 295
                    t = type;
                  } else {
#line 297
                    t = (int )ftype;
                  }
#line 299
                  if (fd == -1) {
#line 299
                    if (! t) {
#line 300
                      pt = pt->next;
#line 301
                      continue;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: 
#line 299
                    tmp = cli_validatesig(pt->target, (unsigned short )t, (char const   *)pt->offset,
                                          offset + (unsigned long )position, fd, (char const   *)pt->virname);
#line 299
                    if (! tmp) {
#line 300
                      pt = pt->next;
#line 301
                      continue;
                    }
                  }
                }
              }
            }
          }
#line 305
          if (pt->sigid) {
#line 306
            if ((*(partcnt + (int )pt->sigid)) + 1 == (int )pt->partno) {
#line 307
              dist = 1;
#line 308
              if (pt->maxdist) {
#line 309
                if ((offset + (unsigned long )i) - (*(partoff + (int )pt->sigid)) >
                    (unsigned long )pt->maxdist) {
#line 310
                  dist = 0;
                }
              }
#line 312
              if (dist) {
#line 312
                if (pt->mindist) {
#line 313
                  if ((offset + (unsigned long )i) - (*(partoff + (int )pt->sigid)) <
                      (unsigned long )pt->mindist) {
#line 314
                    dist = 0;
                  }
                }
              }
#line 316
              if (dist) {
#line 317
                (*(partoff + (int )pt->sigid)) = (offset + (unsigned long )i) + (unsigned long )pt->length;
#line 319
                (*(partcnt + (int )pt->sigid)) = (*(partcnt + (int )pt->sigid)) +
                                                 1;
#line 319
                if ((*(partcnt + (int )pt->sigid)) == (int )pt->parts) {
#line 320
                  if (pt->type) {
#line 321
                    if (otfrec) {
#line 322
                      if ((int )pt->type > type) {
#line 323
                        cli_dbgmsg("Matched signature for file type: %s\n", pt->virname);
#line 324
                        type = (int )pt->type;
                      }
                    }
                  } else {
#line 328
                    if (virname) {
#line 329
                      (*virname) = (char const   *)pt->virname;
                    }
#line 331
                    return (1);
                  }
                }
              }
            }
          } else {
#line 338
            if (pt->type) {
#line 339
              if (otfrec) {
#line 340
                if ((int )pt->type > type) {
#line 341
                  cli_dbgmsg("Matched signature for file type: %s\n", pt->virname);
#line 343
                  type = (int )pt->type;
                }
              }
            } else {
#line 347
              if (virname) {
#line 348
                (*virname) = (char const   *)pt->virname;
              }
#line 350
              return (1);
            }
          }
        }
#line 355
        pt = pt->next;
      }
#line 358
      current = current->fail;
    }
#line 284
    i ++;
  }
#line 362
  if (otfrec) {
#line 362
    tmp___1 = type;
  } else {
#line 362
    tmp___1 = 0;
  }
#line 362
  return (tmp___1);
}
}
#line 1 "matcher-bm.lo"
#pragma merger(0,"/tmp/cil-x4TWP8ug.i","-g -O2 -fPIC")
#line 27 "others.h"
void cli_errmsg(char const   *str  , ...) ;
#line 29
void *cli_malloc(size_t size ) ;
#line 38 "matcher-bm.c"
int cli_bm_addpatt(struct cl_node *root , struct cli_bm_patt *pattern ) 
{ int i ;
  uint16_t idx ;
  char const   *pt ;
  struct cli_bm_patt *prev ;
  struct cli_bm_patt *next ;

  {
#line 42
  pt = (char const   *)pattern->pattern;
#line 43
  next = (struct cli_bm_patt *)((void *)0);
#line 46
  if (pattern->length < 3U) {
#line 47
    cli_errmsg("Signature for %s is too short\n", pattern->virname);
#line 48
    return (-6);
  }
#line 51
  i = 0;
#line 51
  while (i >= 0) {
#line 52
    idx = (unsigned short )((211 * (int )((unsigned char )(*(pt + i))) + 37 * (int )((unsigned char )(*(pt +
                                                                                                        (i +
                                                                                                         1))))) +
                            (int )((unsigned char )(*(pt + (i + 2)))));
#line 53
    if ((*(root->bm_shift + (int )idx)) < 0 - i) {
#line 53
      (*(root->bm_shift + (int )idx)) = (*(root->bm_shift + (int )idx));
    } else {
#line 53
      (*(root->bm_shift + (int )idx)) = 0 - i;
    }
#line 51
    i --;
  }
#line 56
  i = 0;
#line 57
  idx = (unsigned short )((211 * (int )((unsigned char )(*(pt + i))) + 37 * (int )((unsigned char )(*(pt +
                                                                                                      (i +
                                                                                                       1))))) +
                          (int )((unsigned char )(*(pt + (i + 2)))));
#line 59
  next = (*(root->bm_suffix + (int )idx));
#line 59
  prev = next;
#line 61
  while (next) {
#line 62
    if ((int const   )(*(pt + 0)) >= (int const   )(*(next->pattern + 0))) {
#line 63
      break;
    }
#line 64
    prev = next;
#line 65
    next = next->next;
  }
#line 68
  if ((unsigned int )next == (unsigned int )(*(root->bm_suffix + (int )idx))) {
#line 69
    pattern->next = (*(root->bm_suffix + (int )idx));
#line 70
    (*(root->bm_suffix + (int )idx)) = pattern;
  } else {
#line 72
    pattern->next = prev->next;
#line 73
    prev->next = pattern;
  }
#line 76
  return (0);
}
}
#line 79 "matcher-bm.c"
int cli_bm_init(struct cl_node *root ) 
{ unsigned int i ;
  unsigned int size ;

  {
#line 82
  size = 63744U;
#line 85
  cli_dbgmsg("in cli_bm_init()\n");
#line 86
  cli_dbgmsg("BM: Number of indexes = %d\n", size);
#line 88
  root->bm_shift = (int *)cli_malloc(size * sizeof(int ));
#line 88
  if (! root->bm_shift) {
#line 89
    return (-3);
  }
#line 91
  root->bm_suffix = (struct cli_bm_patt **)cli_calloc(size, sizeof(struct cli_bm_patt *));
#line 91
  if (! root->bm_suffix) {
#line 92
    free((void *)root->bm_shift);
#line 93
    return (-3);
  }
#line 96
  i = 0U;
#line 96
  while (i < size) {
#line 97
    (*(root->bm_shift + i)) = 1;
#line 96
    i ++;
  }
#line 99
  return (0);
}
}
#line 102 "matcher-bm.c"
void cli_bm_free(struct cl_node *root ) 
{ struct cli_bm_patt *b1 ;
  struct cli_bm_patt *b2 ;
  unsigned int i ;
  unsigned int size ;

  {
#line 106
  size = 63744U;
#line 109
  if (root->bm_shift) {
#line 110
    free((void *)root->bm_shift);
  }
#line 112
  if (root->bm_suffix) {
#line 113
    i = 0U;
#line 113
    while (i < size) {
#line 114
      b1 = (*(root->bm_suffix + i));
#line 115
      while (b1) {
#line 116
        b2 = b1;
#line 117
        b1 = b1->next;
#line 118
        if (b2->virname) {
#line 119
          free((void *)b2->virname);
        }
#line 120
        if (b2->offset) {
#line 121
          free((void *)b2->offset);
        }
#line 122
        if (b2->pattern) {
#line 123
          free((void *)b2->pattern);
        }
#line 124
        free((void *)b2);
      }
#line 113
      i ++;
    }
#line 127
    free((void *)root->bm_suffix);
  }
#line 129
  return;
}
}
#line 131 "matcher-bm.c"
int cli_bm_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , unsigned long offset , unsigned short ftype ,
                    int fd ) 
{ unsigned int i ;
  unsigned int j ;
  unsigned int shift ;
  unsigned int off ;
  unsigned int found ;
  uint16_t idx ;
  struct cli_bm_patt *p ;
  char const   *bp ;
  char prefix ;
  int tmp ;

  {
#line 133
  found = 0U;
#line 140
  if (! root->bm_shift) {
#line 141
    return (0);
  }
#line 143
  if (length < 3U) {
#line 144
    return (0);
  }
#line 146
  i = 0U;
#line 146
  while (i < (length - 3U) + 1U) {
#line 147
    idx = (unsigned short )((211 * (int )((unsigned char )(*(buffer + i))) + 37 *
                                                                             (int )((unsigned char )(*(buffer +
                                                                                                       (i +
                                                                                                        1U))))) +
                            (int )((unsigned char )(*(buffer + (i + 2U)))));
#line 149
    shift = (unsigned int )(*(root->bm_shift + (int )idx));
#line 151
    if (shift == 0U) {
#line 153
      prefix = (char )(*(buffer + ((i - 3U) + 3U)));
#line 154
      p = (*(root->bm_suffix + (int )idx));
#line 156
      while (1) {
#line 156
        if (p) {
#line 156
          if (! ((int )(*(p->pattern + 0)) != (int )prefix)) {
#line 156
            break;
          }
        } else {
#line 156
          break;
        }
#line 157
        p = p->next;
      }
#line 159
      while (1) {
#line 159
        if (p) {
#line 159
          if (! ((int )(*(p->pattern + 0)) == (int )prefix)) {
#line 159
            break;
          }
        } else {
#line 159
          break;
        }
#line 160
        off = (i - 3U) + 3U;
#line 161
        bp = buffer + off;
#line 170
        found = 1U;
#line 171
        j = 0U;
#line 171
        while (1) {
#line 171
          if (j < p->length) {
#line 171
            if (! (off < length)) {
#line 171
              break;
            }
          } else {
#line 171
            break;
          }
#line 172
          if ((int const   )(*(bp + j)) != (int const   )(*(p->pattern + j))) {
#line 173
            found = 0U;
#line 174
            break;
          }
#line 171
          j ++;
#line 171
          off ++;
        }
#line 178
        if (found) {
#line 178
          if (p->length == j) {
#line 180
            if (p->target) {
              goto _L___0;
            } else {
#line 180
              if (p->offset) {
                _L___0: 
#line 181
                off = (unsigned int )(((offset + (unsigned long )i) - 3UL) + 3UL);
#line 183
                if (fd == -1) {
#line 183
                  if (! ftype) {
#line 184
                    p = p->next;
#line 185
                    continue;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: 
#line 183
                  tmp = cli_validatesig(p->target, ftype, (char const   *)p->offset,
                                        (unsigned long )off, fd, (char const   *)p->virname);
#line 183
                  if (! tmp) {
#line 184
                    p = p->next;
#line 185
                    continue;
                  }
                }
              }
            }
#line 189
            if (virname) {
#line 190
              (*virname) = (char const   *)p->virname;
            }
#line 192
            return (1);
          }
        }
#line 195
        p = p->next;
      }
#line 198
      shift = 1U;
    }
#line 201
    i += shift;
  }
#line 204
  return (0);
}
}
#line 1 "matcher.lo"
#pragma merger(0,"/tmp/cil-T9yrNQ4L.i","-g -O2 -fPIC")
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 62
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 324 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 377
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
#line 377
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
#line 377 "/usr/include/sys/stat.h"
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 380
  tmp = __fxstat(3, __fd, __statbuf);
#line 380
  return (tmp);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 185 "clamav.h"
int cl_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                struct cl_node  const  *root ) ;
#line 199
struct cl_node *cl_dup(struct cl_node *root ) ;
#line 217
int cl_build(struct cl_node *root ) ;
#line 218
void cl_free(struct cl_node *root ) ;
#line 329 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
#line 396
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
#line 26 "others.h"
void cli_warnmsg(char const   *str  , ...) ;
#line 33
unsigned char *cli_md5digest(int desc ) ;
#line 24 "matcher.h"
int cli_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                 short otfrec , unsigned short ftype ) ;
#line 26
int cli_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                 struct cl_node  const  *root , unsigned short ftype ) ;
#line 30
int cli_checkfp(int fd , struct cl_node  const  *root ) ;
#line 22 "md5.h"
void MD5_Init(MD5_CTX *ctx ) ;
#line 23
void MD5_Update(MD5_CTX *ctx , void *data , unsigned long size ) ;
#line 24
void MD5_Final(unsigned char *result , MD5_CTX *ctx ) ;
#line 105 "pe.h"
int cli_peheader(int desc , struct cli_pe_info *peinfo ) ;
#line 42 "matcher.c"
static int targettab[6]  = {      0,      502,      511,      519, 
        520,      515};
#line 44
short cli_debug_flag ;
#line 48 "matcher.c"
struct __anonstruct_pthread_mutex_t_16 cli_ref_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
#line 51 "matcher.c"
int cli_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                 struct cl_node  const  *root , unsigned short ftype ) 
{ int ret ;
  int *partcnt ;
  unsigned long *partoff ;

  {
#line 57
  partcnt = (int *)cli_calloc(root->ac_partsigs + 1U, sizeof(int ));
#line 57
  if ((unsigned int )partcnt == (unsigned int )((void *)0)) {
#line 58
    cli_dbgmsg("cl_scanbuff(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                1U, sizeof(int ));
#line 59
    return (-3);
  }
#line 62
  partoff = (unsigned long *)cli_calloc(root->ac_partsigs + 1U, sizeof(unsigned long ));
#line 62
  if ((unsigned int )partoff == (unsigned int )((void *)0)) {
#line 63
    cli_dbgmsg("cl_scanbuff(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                1U, sizeof(unsigned long ));
#line 64
    free((void *)partcnt);
#line 65
    return (-3);
  }
#line 68
  ret = cli_bm_scanbuff(buffer, length, virname, root, 0UL, ftype, -1);
#line 68
  if (ret != 1) {
#line 69
    ret = cli_ac_scanbuff(buffer, length, virname, root, partcnt, (short)0, 0UL, partoff,
                          ftype, -1);
  }
#line 71
  free((void *)partcnt);
#line 72
  free((void *)partoff);
#line 73
  return (ret);
}
}
#line 76 "matcher.c"
int cl_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                struct cl_node  const  *root ) 
{ int tmp ;

  {
#line 78
  tmp = cli_scanbuff(buffer, length, virname, root, (unsigned short)0);
#line 78
  return (tmp);
}
}
#line 81 "matcher.c"
static struct cli_md5_node *cli_vermd5(unsigned char const   *md5 , struct cl_node  const  *root ) 
{ struct cli_md5_node *pt ;
  int tmp ;

  {
#line 86
  pt = (*(root->md5_hlist + ((int const   )(*(md5 + 0)) & 255)));
#line 86
  if (! pt) {
#line 87
    return ((struct cli_md5_node *)((void *)0));
  }
#line 89
  while (pt) {
#line 90
    tmp = memcmp((void const   *)pt->md5, (void const   *)md5, 16U);
#line 90
    if (! tmp) {
#line 91
      return (pt);
    }
#line 93
    pt = pt->next;
  }
#line 96
  return ((struct cli_md5_node *)((void *)0));
}
}
#line 99 "matcher.c"
static long cli_caloff(char const   *offstr , int fd ) 
{ struct cli_pe_info peinfo ;
  long offset ;
  int n ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___80 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___116 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___135 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  int tmp___152 ;
  size_t tmp___153 ;
  struct stat sb ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___230 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___266 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___285 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___299 ;
  int tmp___300 ;
  size_t tmp___301 ;
  int tmp___302 ;
  size_t tmp___303 ;
  int tmp___378 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___414 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___433 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___448 ;
  size_t tmp___449 ;
  int tmp___450 ;
  size_t tmp___451 ;

  {
#line 102
  offset = -1L;
#line 106
  tmp___0 = __ctype_b_loc();
#line 106
  if ((int const   )(*((*tmp___0) + (int )(*(offstr + 0)))) & 2048) {
#line 107
    tmp = (long )atoi__extinline(offstr);
#line 107
    return (tmp);
  }
#line 108
  tmp___448 = __builtin_constant_p((int )offstr);
#line 108
  if (tmp___448) {
#line 108
    tmp___449 = strlen(offstr);
#line 108
    if (tmp___449 < 3U) {
      goto _L___123;
    } else {
      goto _L___124;
    }
  } else {
    _L___124: 
#line 108
    tmp___450 = __builtin_constant_p((int )"EP+");
#line 108
    if (tmp___450) {
#line 108
      tmp___451 = strlen("EP+");
#line 108
      if (tmp___451 < 3U) {
        _L___123: 
#line 108
        tmp___445 = __builtin_constant_p((int )offstr);
#line 108
        if (tmp___445) {
#line 108
          tmp___446 = __builtin_constant_p((int )"EP+");
#line 108
          if (tmp___446) {
#line 108
            __s1_len___4 = strlen(offstr);
#line 108
            __s2_len___4 = strlen("EP+");
#line 108
            if (! ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                   1U)) {
              goto _L___120;
            } else {
#line 108
              if (__s1_len___4 >= 4U) {
                _L___120: 
#line 108
                if (! ((unsigned int )((void const   *)("EP+" + 1)) - (unsigned int )((void const   *)"EP+") ==
                       1U)) {
#line 108
                  tmp___447 = 1;
                } else {
#line 108
                  if (__s2_len___4 >= 4U) {
#line 108
                    tmp___447 = 1;
                  } else {
#line 108
                    tmp___447 = 0;
                  }
                }
              } else {
#line 108
                tmp___447 = 0;
              }
            }
#line 108
            if (tmp___447) {
#line 108
              tmp___414 = __builtin_strcmp(offstr, "EP+");
            } else {
              goto _L___122;
            }
          } else {
            goto _L___122;
          }
        } else {
          _L___122: 
#line 108
          tmp___444 = __builtin_constant_p((int )offstr);
#line 108
          if (tmp___444) {
#line 108
            if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                1U) {
#line 108
              __s1_len___4 = strlen(offstr);
#line 108
              if (__s1_len___4 < 4U) {
#line 108
                tmp___433 = __builtin_constant_p((int )"EP+");
#line 108
                if (tmp___433) {
#line 108
                  if ((unsigned int )((void const   *)("EP+" + 1)) - (unsigned int )((void const   *)"EP+") ==
                      1U) {
#line 108
                    tmp___414 = __builtin_strcmp(offstr, "EP+");
                  } else {
                    goto _L___115;
                  }
                } else {
                  _L___115: 
#line 108
                  __s2___46 = (unsigned char const   *)"EP+";
#line 108
                  __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                           0)) - (int const   )(*(__s2___46 +
                                                                                  0)));
#line 108
                  if (__s1_len___4 > 0U) {
#line 108
                    if (__result___138 == 0) {
#line 108
                      __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                               1)) - (int const   )(*(__s2___46 +
                                                                                      1)));
#line 108
                      if (__s1_len___4 > 1U) {
#line 108
                        if (__result___138 == 0) {
#line 108
                          __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                   2)) - (int const   )(*(__s2___46 +
                                                                                          2)));
#line 108
                          if (__s1_len___4 > 2U) {
#line 108
                            if (__result___138 == 0) {
#line 108
                              __result___138 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                       3)) - (int const   )(*(__s2___46 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 108
                  tmp___414 = __result___138;
                }
              } else {
                goto _L___119;
              }
            } else {
              goto _L___119;
            }
          } else {
            _L___119: 
#line 108
            tmp___443 = __builtin_constant_p((int )"EP+");
#line 108
            if (tmp___443) {
#line 108
              if ((unsigned int )((void const   *)("EP+" + 1)) - (unsigned int )((void const   *)"EP+") ==
                  1U) {
#line 108
                __s2_len___4 = strlen("EP+");
#line 108
                if (__s2_len___4 < 4U) {
#line 108
                  tmp___442 = __builtin_constant_p((int )offstr);
#line 108
                  if (tmp___442) {
#line 108
                    if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                        1U) {
#line 108
                      tmp___414 = __builtin_strcmp(offstr, "EP+");
                    } else {
                      goto _L___117;
                    }
                  } else {
                    _L___117: 
#line 108
                    __s1___94 = (unsigned char const   *)offstr;
#line 108
                    __result___142 = (int )((int const   )(*(__s1___94 + 0)) - (int const   )(*((unsigned char const   *)"EP+" +
                                                                                                0)));
#line 108
                    if (__s2_len___4 > 0U) {
#line 108
                      if (__result___142 == 0) {
#line 108
                        __result___142 = (int )((int const   )(*(__s1___94 + 1)) -
                                                (int const   )(*((unsigned char const   *)"EP+" +
                                                                 1)));
#line 108
                        if (__s2_len___4 > 1U) {
#line 108
                          if (__result___142 == 0) {
#line 108
                            __result___142 = (int )((int const   )(*(__s1___94 + 2)) -
                                                    (int const   )(*((unsigned char const   *)"EP+" +
                                                                     2)));
#line 108
                            if (__s2_len___4 > 2U) {
#line 108
                              if (__result___142 == 0) {
#line 108
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"EP+" +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 108
                    tmp___414 = __result___142;
                  }
                } else {
#line 108
                  tmp___414 = __builtin_strcmp(offstr, "EP+");
                }
              } else {
#line 108
                tmp___414 = __builtin_strcmp(offstr, "EP+");
              }
            } else {
#line 108
              tmp___414 = __builtin_strcmp(offstr, "EP+");
            }
          }
        }
#line 108
        tmp___378 = tmp___414;
      } else {
#line 108
        tmp___378 = strncmp(offstr, "EP+", 3U);
      }
    } else {
#line 108
      tmp___378 = strncmp(offstr, "EP+", 3U);
    }
  }
#line 108
  if (tmp___378) {
#line 121
    if ((int const   )(*(offstr + 0)) == 83) {
#line 122
      n = (int )lseek(fd, 0L, 1);
#line 122
      if (n == -1) {
#line 123
        cli_dbgmsg("Invalid descriptor\n");
#line 124
        return (-1L);
      }
#line 126
      lseek(fd, 0L, 0);
#line 127
      tmp___3 = cli_peheader(fd, & peinfo);
#line 127
      if (tmp___3) {
#line 128
        lseek(fd, (long )n, 0);
#line 129
        return (-1L);
      }
#line 131
      lseek(fd, (long )n, 0);
#line 133
      tmp___150 = __builtin_constant_p((int )offstr);
#line 133
      if (tmp___150) {
#line 133
        tmp___151 = strlen(offstr);
#line 133
        if (tmp___151 < 2U) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
#line 133
        tmp___152 = __builtin_constant_p((int )"SL");
#line 133
        if (tmp___152) {
#line 133
          tmp___153 = strlen("SL");
#line 133
          if (tmp___153 < 2U) {
            _L___39: 
#line 133
            tmp___147 = __builtin_constant_p((int )offstr);
#line 133
            if (tmp___147) {
#line 133
              tmp___148 = __builtin_constant_p((int )"SL");
#line 133
              if (tmp___148) {
#line 133
                __s1_len___0 = strlen(offstr);
#line 133
                __s2_len___0 = strlen("SL");
#line 133
                if (! ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                       1U)) {
                  goto _L___36;
                } else {
#line 133
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
#line 133
                    if (! ((unsigned int )((void const   *)("SL" + 1)) - (unsigned int )((void const   *)"SL") ==
                           1U)) {
#line 133
                      tmp___149 = 1;
                    } else {
#line 133
                      if (__s2_len___0 >= 4U) {
#line 133
                        tmp___149 = 1;
                      } else {
#line 133
                        tmp___149 = 0;
                      }
                    }
                  } else {
#line 133
                    tmp___149 = 0;
                  }
                }
#line 133
                if (tmp___149) {
#line 133
                  tmp___116 = __builtin_strcmp(offstr, "SL");
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
#line 133
              tmp___146 = __builtin_constant_p((int )offstr);
#line 133
              if (tmp___146) {
#line 133
                if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                    1U) {
#line 133
                  __s1_len___0 = strlen(offstr);
#line 133
                  if (__s1_len___0 < 4U) {
#line 133
                    tmp___135 = __builtin_constant_p((int )"SL");
#line 133
                    if (tmp___135) {
#line 133
                      if ((unsigned int )((void const   *)("SL" + 1)) - (unsigned int )((void const   *)"SL") ==
                          1U) {
#line 133
                        tmp___116 = __builtin_strcmp(offstr, "SL");
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
#line 133
                      __s2___14 = (unsigned char const   *)"SL";
#line 133
                      __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
#line 133
                      if (__s1_len___0 > 0U) {
#line 133
                        if (__result___42 == 0) {
#line 133
                          __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
#line 133
                          if (__s1_len___0 > 1U) {
#line 133
                            if (__result___42 == 0) {
#line 133
                              __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
#line 133
                              if (__s1_len___0 > 2U) {
#line 133
                                if (__result___42 == 0) {
#line 133
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 133
                      tmp___116 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
#line 133
                tmp___145 = __builtin_constant_p((int )"SL");
#line 133
                if (tmp___145) {
#line 133
                  if ((unsigned int )((void const   *)("SL" + 1)) - (unsigned int )((void const   *)"SL") ==
                      1U) {
#line 133
                    __s2_len___0 = strlen("SL");
#line 133
                    if (__s2_len___0 < 4U) {
#line 133
                      tmp___144 = __builtin_constant_p((int )offstr);
#line 133
                      if (tmp___144) {
#line 133
                        if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                            1U) {
#line 133
                          tmp___116 = __builtin_strcmp(offstr, "SL");
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
#line 133
                        __s1___30 = (unsigned char const   *)offstr;
#line 133
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)"SL" +
                                                                0)));
#line 133
                        if (__s2_len___0 > 0U) {
#line 133
                          if (__result___46 == 0) {
#line 133
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"SL" +
                                                                    1)));
#line 133
                            if (__s2_len___0 > 1U) {
#line 133
                              if (__result___46 == 0) {
#line 133
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"SL" +
                                                                                               2)));
#line 133
                                if (__s2_len___0 > 2U) {
#line 133
                                  if (__result___46 == 0) {
#line 133
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"SL" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 133
                        tmp___116 = __result___46;
                      }
                    } else {
#line 133
                      tmp___116 = __builtin_strcmp(offstr, "SL");
                    }
                  } else {
#line 133
                    tmp___116 = __builtin_strcmp(offstr, "SL");
                  }
                } else {
#line 133
                  tmp___116 = __builtin_strcmp(offstr, "SL");
                }
              }
            }
#line 133
            tmp___80 = tmp___116;
          } else {
#line 133
            tmp___80 = strncmp(offstr, "SL", 2U);
          }
        } else {
#line 133
          tmp___80 = strncmp(offstr, "SL", 2U);
        }
      }
#line 133
      if (tmp___80) {
#line 144
        tmp___5 = sscanf((char const   * __restrict  )offstr, (char const   * __restrict  )"S%d+%ld",
                         & n, & offset);
#line 144
        if (tmp___5 != 2) {
#line 145
          free((void *)peinfo.section);
#line 146
          return (-1L);
        }
#line 149
        if (n >= (int )peinfo.nsections) {
#line 150
          free((void *)peinfo.section);
#line 151
          return (-1L);
        }
#line 154
        offset = (long )((unsigned long )offset + (unsigned long )(peinfo.section +
                                                                   n)->raw);
      } else {
#line 135
        tmp___4 = sscanf((char const   * __restrict  )offstr, (char const   * __restrict  )"SL+%ld",
                         & offset);
#line 135
        if (tmp___4 != 1) {
#line 136
          free((void *)peinfo.section);
#line 137
          return (-1L);
        }
#line 140
        offset = (long )((unsigned long )offset + (unsigned long )(peinfo.section +
                                                                   ((int )peinfo.nsections -
                                                                    1))->raw);
      }
#line 157
      free((void *)peinfo.section);
#line 158
      return (offset);
    } else {
#line 160
      tmp___300 = __builtin_constant_p((int )offstr);
#line 160
      if (tmp___300) {
#line 160
        tmp___301 = strlen(offstr);
#line 160
        if (tmp___301 < 4U) {
          goto _L___81;
        } else {
          goto _L___82;
        }
      } else {
        _L___82: 
#line 160
        tmp___302 = __builtin_constant_p((int )"EOF-");
#line 160
        if (tmp___302) {
#line 160
          tmp___303 = strlen("EOF-");
#line 160
          if (tmp___303 < 4U) {
            _L___81: 
#line 160
            tmp___297 = __builtin_constant_p((int )offstr);
#line 160
            if (tmp___297) {
#line 160
              tmp___298 = __builtin_constant_p((int )"EOF-");
#line 160
              if (tmp___298) {
#line 160
                __s1_len___2 = strlen(offstr);
#line 160
                __s2_len___2 = strlen("EOF-");
#line 160
                if (! ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                       1U)) {
                  goto _L___78;
                } else {
#line 160
                  if (__s1_len___2 >= 4U) {
                    _L___78: 
#line 160
                    if (! ((unsigned int )((void const   *)("EOF-" + 1)) - (unsigned int )((void const   *)"EOF-") ==
                           1U)) {
#line 160
                      tmp___299 = 1;
                    } else {
#line 160
                      if (__s2_len___2 >= 4U) {
#line 160
                        tmp___299 = 1;
                      } else {
#line 160
                        tmp___299 = 0;
                      }
                    }
                  } else {
#line 160
                    tmp___299 = 0;
                  }
                }
#line 160
                if (tmp___299) {
#line 160
                  tmp___266 = __builtin_strcmp(offstr, "EOF-");
                } else {
                  goto _L___80;
                }
              } else {
                goto _L___80;
              }
            } else {
              _L___80: 
#line 160
              tmp___296 = __builtin_constant_p((int )offstr);
#line 160
              if (tmp___296) {
#line 160
                if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                    1U) {
#line 160
                  __s1_len___2 = strlen(offstr);
#line 160
                  if (__s1_len___2 < 4U) {
#line 160
                    tmp___285 = __builtin_constant_p((int )"EOF-");
#line 160
                    if (tmp___285) {
#line 160
                      if ((unsigned int )((void const   *)("EOF-" + 1)) - (unsigned int )((void const   *)"EOF-") ==
                          1U) {
#line 160
                        tmp___266 = __builtin_strcmp(offstr, "EOF-");
                      } else {
                        goto _L___73;
                      }
                    } else {
                      _L___73: 
#line 160
                      __s2___30 = (unsigned char const   *)"EOF-";
#line 160
                      __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                              0)) - (int const   )(*(__s2___30 +
                                                                                     0)));
#line 160
                      if (__s1_len___2 > 0U) {
#line 160
                        if (__result___90 == 0) {
#line 160
                          __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                  1)) - (int const   )(*(__s2___30 +
                                                                                         1)));
#line 160
                          if (__s1_len___2 > 1U) {
#line 160
                            if (__result___90 == 0) {
#line 160
                              __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                      2)) - (int const   )(*(__s2___30 +
                                                                                             2)));
#line 160
                              if (__s1_len___2 > 2U) {
#line 160
                                if (__result___90 == 0) {
#line 160
                                  __result___90 = (int )((int const   )(*((unsigned char const   *)offstr +
                                                                          3)) - (int const   )(*(__s2___30 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 160
                      tmp___266 = __result___90;
                    }
                  } else {
                    goto _L___77;
                  }
                } else {
                  goto _L___77;
                }
              } else {
                _L___77: 
#line 160
                tmp___295 = __builtin_constant_p((int )"EOF-");
#line 160
                if (tmp___295) {
#line 160
                  if ((unsigned int )((void const   *)("EOF-" + 1)) - (unsigned int )((void const   *)"EOF-") ==
                      1U) {
#line 160
                    __s2_len___2 = strlen("EOF-");
#line 160
                    if (__s2_len___2 < 4U) {
#line 160
                      tmp___294 = __builtin_constant_p((int )offstr);
#line 160
                      if (tmp___294) {
#line 160
                        if ((unsigned int )((void const   *)(offstr + 1)) - (unsigned int )((void const   *)offstr) ==
                            1U) {
#line 160
                          tmp___266 = __builtin_strcmp(offstr, "EOF-");
                        } else {
                          goto _L___75;
                        }
                      } else {
                        _L___75: 
#line 160
                        __s1___62 = (unsigned char const   *)offstr;
#line 160
                        __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                               (int const   )(*((unsigned char const   *)"EOF-" +
                                                                0)));
#line 160
                        if (__s2_len___2 > 0U) {
#line 160
                          if (__result___94 == 0) {
#line 160
                            __result___94 = (int )((int const   )(*(__s1___62 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"EOF-" +
                                                                    1)));
#line 160
                            if (__s2_len___2 > 1U) {
#line 160
                              if (__result___94 == 0) {
#line 160
                                __result___94 = (int )((int const   )(*(__s1___62 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"EOF-" +
                                                                                               2)));
#line 160
                                if (__s2_len___2 > 2U) {
#line 160
                                  if (__result___94 == 0) {
#line 160
                                    __result___94 = (int )((int const   )(*(__s1___62 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"EOF-" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 160
                        tmp___266 = __result___94;
                      }
                    } else {
#line 160
                      tmp___266 = __builtin_strcmp(offstr, "EOF-");
                    }
                  } else {
#line 160
                    tmp___266 = __builtin_strcmp(offstr, "EOF-");
                  }
                } else {
#line 160
                  tmp___266 = __builtin_strcmp(offstr, "EOF-");
                }
              }
            }
#line 160
            tmp___230 = tmp___266;
          } else {
#line 160
            tmp___230 = strncmp(offstr, "EOF-", 4U);
          }
        } else {
#line 160
          tmp___230 = strncmp(offstr, "EOF-", 4U);
        }
      }
#line 160
      if (! tmp___230) {
#line 163
        tmp___154 = fstat__extinline(fd, & sb);
#line 163
        if (tmp___154 == -1) {
#line 164
          return (-1L);
        }
#line 166
        tmp___155 = atoi__extinline(offstr + 4);
#line 166
        return (sb.st_size - (long )tmp___155);
      }
    }
  } else {
#line 109
    n = (int )lseek(fd, 0L, 1);
#line 109
    if (n == -1) {
#line 110
      cli_dbgmsg("Invalid descriptor\n");
#line 111
      return (-1L);
    }
#line 113
    lseek(fd, 0L, 0);
#line 114
    tmp___1 = cli_peheader(fd, & peinfo);
#line 114
    if (tmp___1) {
#line 115
      lseek(fd, (long )n, 0);
#line 116
      return (-1L);
    }
#line 118
    free((void *)peinfo.section);
#line 119
    lseek(fd, (long )n, 0);
#line 120
    tmp___2 = atoi__extinline(offstr + 3);
#line 120
    return ((long )(peinfo.ep + (unsigned int )tmp___2));
  }
#line 169
  return (-1L);
}
}
#line 172 "matcher.c"
int cli_checkfp(int fd , struct cl_node  const  *root ) 
{ struct cli_md5_node *md5_node ;
  char *digest ;
  struct stat sb ;
  int tmp ;

  {
#line 178
  if (root->md5_hlist) {
#line 180
    digest = (char *)cli_md5digest(fd);
#line 180
    if (! digest) {
#line 181
      cli_errmsg("cli_checkfp(): Can\'t generate MD5 checksum\n");
#line 182
      return (0);
    }
#line 185
    md5_node = cli_vermd5((unsigned char const   *)digest, root);
#line 185
    if (md5_node) {
#line 185
      if (md5_node->fp) {
#line 188
        tmp = fstat__extinline(fd, & sb);
#line 188
        if (tmp) {
#line 189
          return (-12);
        }
#line 191
        if ((unsigned int )sb.st_size != md5_node->size) {
#line 192
          cli_warnmsg("Detected false positive MD5 match. Please report.\n");
        } else {
#line 194
          cli_dbgmsg("Eliminated false positive match (fp sig: %s)\n", md5_node->virname);
#line 195
          free((void *)digest);
#line 196
          return (1);
        }
      }
    }
#line 200
    free((void *)digest);
  }
#line 203
  return (0);
}
}
#line 206 "matcher.c"
int cli_validatesig(unsigned short target , unsigned short ftype , char const   *offstr ,
                    unsigned long fileoff , int desc , char const   *virname ) 
{ long off ;
  long tmp ;

  {
#line 210
  if (target) {
#line 211
    if ((int )target >= 6) {
#line 212
      cli_errmsg("Bad target in signature (%s)\n", virname);
#line 213
      return (0);
    } else {
#line 215
      if (targettab[target] != (int )ftype) {
#line 216
        cli_dbgmsg("Type: %d, expected: %d (%s)\n", ftype, targettab[target], virname);
#line 217
        return (0);
      }
    }
  }
#line 223
  if (offstr) {
#line 223
    if (desc != -1) {
#line 224
      tmp = cli_caloff(offstr, desc);
#line 224
      off = tmp;
#line 226
      if (off == -1L) {
#line 227
        cli_dbgmsg("Bad offset in signature (%s)\n", virname);
#line 228
        return (0);
      }
#line 231
      if (fileoff != (unsigned long )off) {
#line 232
        cli_dbgmsg("Virus offset: %d, expected: %d (%s)\n", fileoff, off, virname);
#line 233
        return (0);
      }
    }
  }
#line 237
  return (1);
}
}
#line 240 "matcher.c"
int cli_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                 short otfrec , unsigned short ftype ) 
{ char *buffer ;
  char *buff ;
  char *endbl ;
  char *pt ;
  int bytes ;
  int buffsize ;
  int length ;
  int ret ;
  int *partcnt ;
  int type ;
  unsigned long *partoff ;
  unsigned long offset ;
  MD5_CTX ctx ;
  unsigned char digest[16] ;
  struct cli_md5_node *md5_node ;
  int tmp___2 ;
  int tmp___3 ;
  char md5str[33] ;
  int i ;
  struct stat sb ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 243
  type = 0;
#line 244
  offset = 0UL;
#line 250
  if (! root) {
#line 251
    cli_errmsg("cli_scandesc: root == NULL\n");
#line 252
    return (300);
  }
#line 256
  buffsize = (int )(root->maxpatlen + 131072U);
#line 257
  buffer = (char *)cli_calloc((unsigned int )buffsize, sizeof(char ));
#line 257
  if (! buffer) {
#line 258
    cli_dbgmsg("cli_scandesc(): unable to cli_calloc(%d)\n", buffsize);
#line 259
    return (-3);
  }
#line 262
  partcnt = (int *)cli_calloc(root->ac_partsigs + 1U, sizeof(int ));
#line 262
  if ((unsigned int )partcnt == (unsigned int )((void *)0)) {
#line 263
    cli_dbgmsg("cli_scandesc(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                 1U, sizeof(int ));
#line 264
    free((void *)buffer);
#line 265
    return (-3);
  }
#line 268
  partoff = (unsigned long *)cli_calloc(root->ac_partsigs + 1U, sizeof(unsigned long ));
#line 268
  if ((unsigned int )partoff == (unsigned int )((void *)0)) {
#line 269
    cli_dbgmsg("cli_scandesc(): unable to cli_calloc(%d, %d)\n", root->ac_partsigs +
                                                                 1U, sizeof(unsigned long ));
#line 270
    free((void *)buffer);
#line 271
    free((void *)partcnt);
#line 272
    return (-3);
  }
#line 275
  if (root->md5_hlist) {
#line 276
    MD5_Init(& ctx);
  }
#line 279
  buff = buffer;
#line 280
  buff += root->maxpatlen;
#line 281
  endbl = (buff + 131072) - root->maxpatlen;
#line 285
  pt = buff;
#line 286
  length = 131072;
#line 287
  while (1) {
#line 287
    bytes = read(desc, (void *)buff, 131072U);
#line 287
    if (! (bytes > 0)) {
#line 287
      break;
    }
#line 289
    if (scanned) {
#line 290
      (*scanned) += (long )(bytes / 4096);
    }
#line 292
    if (bytes < 131072) {
#line 293
      length -= 131072 - bytes;
    }
#line 295
    tmp___3 = cli_bm_scanbuff((char const   *)pt, (unsigned int )length, virname,
                              root, offset, ftype, desc);
#line 295
    if (tmp___3 == 1) {
      goto _L;
    } else {
#line 295
      ret = cli_ac_scanbuff((char const   *)pt, (unsigned int )length, virname, root,
                            partcnt, otfrec, offset, partoff, ftype, desc);
#line 295
      if (ret == 1) {
        _L: 
#line 297
        free((void *)buffer);
#line 298
        free((void *)partcnt);
#line 299
        free((void *)partoff);
#line 301
        lseek(desc, 0L, 0);
#line 302
        tmp___2 = cli_checkfp(desc, root);
#line 302
        if (tmp___2) {
#line 303
          return (0);
        } else {
#line 305
          return (1);
        }
      } else {
#line 307
        if (otfrec) {
#line 307
          if (ret >= 500) {
#line 308
            if (ret >= type) {
#line 309
              type = ret;
            }
          }
        }
      }
    }
#line 312
    if (bytes == 131072) {
#line 313
      memmove((void *)buffer, (void const   *)endbl, root->maxpatlen);
#line 315
      if ((unsigned int )pt == (unsigned int )buffer) {
#line 316
        offset += 131072UL;
      } else {
#line 318
        offset += (unsigned long )(131072U - root->maxpatlen);
#line 319
        pt = buffer;
#line 320
        length = buffsize;
      }
    }
#line 324
    if (root->md5_hlist) {
#line 325
      MD5_Update(& ctx, (void *)buff, (unsigned long )bytes);
    }
  }
#line 328
  free((void *)buffer);
#line 329
  free((void *)partcnt);
#line 330
  free((void *)partoff);
#line 332
  if (root->md5_hlist) {
#line 333
    MD5_Final(digest, & ctx);
#line 335
    if (cli_debug_flag) {
#line 339
      pt = md5str;
#line 340
      i = 0;
#line 340
      while (i < 16) {
#line 341
        sprintf((char * __restrict  )pt, (char const   * __restrict  )"%02x", digest[i]);
#line 342
        pt += 2;
#line 340
        i ++;
      }
#line 344
      md5str[32] = (char)0;
#line 345
      cli_dbgmsg("Calculated MD5 checksum: %s\n", md5str);
    }
#line 348
    md5_node = cli_vermd5((unsigned char const   *)(digest), root);
#line 348
    if (md5_node) {
#line 348
      if (! md5_node->fp) {
#line 351
        tmp___4 = fstat__extinline(desc, & sb);
#line 351
        if (tmp___4) {
#line 352
          return (-12);
        }
#line 354
        if ((unsigned int )sb.st_size != md5_node->size) {
#line 355
          cli_warnmsg("Detected false positive MD5 match. Please report.\n");
        } else {
#line 357
          if (virname) {
#line 358
            (*virname) = (char const   *)md5_node->virname;
          }
#line 360
          return (1);
        }
      }
    }
  }
#line 365
  if (otfrec) {
#line 365
    tmp___5 = type;
  } else {
#line 365
    tmp___5 = 0;
  }
#line 365
  return (tmp___5);
}
}
#line 368 "matcher.c"
int cl_build(struct cl_node *root ) 
{ int tmp ;

  {
#line 370
  tmp = cli_ac_buildtrie(root);
#line 370
  return (tmp);
}
}
#line 373 "matcher.c"
struct cl_node *cl_dup(struct cl_node *root ) 
{ 

  {
#line 375
  if (! root) {
#line 376
    cli_errmsg("cl_dup: root == NULL\n");
#line 377
    return ((struct cl_node *)((void *)0));
  }
#line 381
  pthread_mutex_lock(& cli_ref_mutex);
#line 384
  root->refcount = root->refcount + 1U;
#line 387
  pthread_mutex_unlock(& cli_ref_mutex);
#line 390
  return (root);
}
}
#line 393 "matcher.c"
void cl_free(struct cl_node *root ) 
{ int i ;
  struct cli_md5_node *md5pt ;
  struct cli_md5_node *md5h ;
  struct cli_meta_node *metapt ;
  struct cli_meta_node *metah ;

  {
#line 399
  if (! root) {
#line 400
    cli_errmsg("cl_free: root == NULL\n");
#line 401
    return;
  }
#line 405
  pthread_mutex_lock(& cli_ref_mutex);
#line 408
  root->refcount = root->refcount - 1U;
#line 409
  if (root->refcount) {
#line 411
    pthread_mutex_unlock(& cli_ref_mutex);
#line 413
    return;
  }
#line 417
  pthread_mutex_unlock(& cli_ref_mutex);
#line 420
  cli_ac_free(root);
#line 421
  cli_bm_free(root);
#line 423
  if (root->md5_hlist) {
#line 424
    i = 0;
#line 424
    while (i < 256) {
#line 425
      md5pt = (*(root->md5_hlist + i));
#line 426
      while (md5pt) {
#line 427
        md5h = md5pt;
#line 428
        md5pt = md5pt->next;
#line 429
        free((void *)md5h->md5);
#line 430
        free((void *)md5h->virname);
#line 431
        if (md5h->viralias) {
#line 432
          free((void *)md5h->viralias);
        }
#line 433
        free((void *)md5h);
      }
#line 424
      i ++;
    }
#line 436
    free((void *)root->md5_hlist);
  }
#line 439
  metapt = root->zip_mlist;
#line 440
  while (metapt) {
#line 441
    metah = metapt;
#line 442
    metapt = metapt->next;
#line 443
    free((void *)metah->virname);
#line 444
    if (metah->filename) {
#line 445
      free((void *)metah->filename);
    }
#line 446
    free((void *)metah);
  }
#line 449
  metapt = root->rar_mlist;
#line 450
  while (metapt) {
#line 451
    metah = metapt;
#line 452
    metapt = metapt->next;
#line 453
    free((void *)metah->virname);
#line 454
    if (metah->filename) {
#line 455
      free((void *)metah->filename);
    }
#line 456
    free((void *)metah);
  }
#line 459
  free((void *)root);
#line 460
  return;
}
}
#line 462 "matcher.c"
int cl_buildtrie(struct cl_node *root ) 
{ int tmp ;

  {
#line 464
  tmp = cl_build(root);
#line 464
  return (tmp);
}
}
#line 467 "matcher.c"
void cl_freetrie(struct cl_node *root ) 
{ 

  {
#line 469
  cl_free(root);
#line 470
  return;
}
}
#line 1 "md5.lo"
#pragma merger(0,"/tmp/cil-dLi3voFN.i","-g -O2 -fPIC")
#line 72 "md5.c"
static void *body(MD5_CTX *ctx , void *data , unsigned long size ) 
{ unsigned char *ptr ;
  MD5_u32plus a ;
  MD5_u32plus b ;
  MD5_u32plus c ;
  MD5_u32plus d ;
  MD5_u32plus saved_a ;
  MD5_u32plus saved_b ;
  MD5_u32plus saved_c ;
  MD5_u32plus saved_d ;

  {
#line 78
  ptr = (unsigned char *)data;
#line 80
  a = ctx->a;
#line 81
  b = ctx->b;
#line 82
  c = ctx->c;
#line 83
  d = ctx->d;
#line 85
  while (1) {
#line 86
    saved_a = a;
#line 87
    saved_b = b;
#line 88
    saved_c = c;
#line 89
    saved_d = d;
#line 92
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 0)))) + 3614090360UL;
#line 92
    a = (a << 7) | ((a & 4294967295UL) >> 25);
#line 92
    a += b;
#line 93
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 4)))) + 3905402710UL;
#line 93
    d = (d << 12) | ((d & 4294967295UL) >> 20);
#line 93
    d += a;
#line 94
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 8)))) + 606105819UL;
#line 94
    c = (c << 17) | ((c & 4294967295UL) >> 15);
#line 94
    c += d;
#line 95
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 12)))) + 3250441966UL;
#line 95
    b = (b << 22) | ((b & 4294967295UL) >> 10);
#line 95
    b += c;
#line 96
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 16)))) + 4118548399UL;
#line 96
    a = (a << 7) | ((a & 4294967295UL) >> 25);
#line 96
    a += b;
#line 97
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 20)))) + 1200080426UL;
#line 97
    d = (d << 12) | ((d & 4294967295UL) >> 20);
#line 97
    d += a;
#line 98
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 24)))) + 2821735955UL;
#line 98
    c = (c << 17) | ((c & 4294967295UL) >> 15);
#line 98
    c += d;
#line 99
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 28)))) + 4249261313UL;
#line 99
    b = (b << 22) | ((b & 4294967295UL) >> 10);
#line 99
    b += c;
#line 100
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 32)))) + 1770035416UL;
#line 100
    a = (a << 7) | ((a & 4294967295UL) >> 25);
#line 100
    a += b;
#line 101
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 36)))) + 2336552879UL;
#line 101
    d = (d << 12) | ((d & 4294967295UL) >> 20);
#line 101
    d += a;
#line 102
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 40)))) + 4294925233UL;
#line 102
    c = (c << 17) | ((c & 4294967295UL) >> 15);
#line 102
    c += d;
#line 103
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 44)))) + 2304563134UL;
#line 103
    b = (b << 22) | ((b & 4294967295UL) >> 10);
#line 103
    b += c;
#line 104
    a += ((d ^ (b & (c ^ d))) + (*((MD5_u32plus *)(ptr + 48)))) + 1804603682UL;
#line 104
    a = (a << 7) | ((a & 4294967295UL) >> 25);
#line 104
    a += b;
#line 105
    d += ((c ^ (a & (b ^ c))) + (*((MD5_u32plus *)(ptr + 52)))) + 4254626195UL;
#line 105
    d = (d << 12) | ((d & 4294967295UL) >> 20);
#line 105
    d += a;
#line 106
    c += ((b ^ (d & (a ^ b))) + (*((MD5_u32plus *)(ptr + 56)))) + 2792965006UL;
#line 106
    c = (c << 17) | ((c & 4294967295UL) >> 15);
#line 106
    c += d;
#line 107
    b += ((a ^ (c & (d ^ a))) + (*((MD5_u32plus *)(ptr + 60)))) + 1236535329UL;
#line 107
    b = (b << 22) | ((b & 4294967295UL) >> 10);
#line 107
    b += c;
#line 110
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 4)))) + 4129170786UL;
#line 110
    a = (a << 5) | ((a & 4294967295UL) >> 27);
#line 110
    a += b;
#line 111
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 24)))) + 3225465664UL;
#line 111
    d = (d << 9) | ((d & 4294967295UL) >> 23);
#line 111
    d += a;
#line 112
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 44)))) + 643717713UL;
#line 112
    c = (c << 14) | ((c & 4294967295UL) >> 18);
#line 112
    c += d;
#line 113
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 0)))) + 3921069994UL;
#line 113
    b = (b << 20) | ((b & 4294967295UL) >> 12);
#line 113
    b += c;
#line 114
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 20)))) + 3593408605UL;
#line 114
    a = (a << 5) | ((a & 4294967295UL) >> 27);
#line 114
    a += b;
#line 115
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 40)))) + 38016083UL;
#line 115
    d = (d << 9) | ((d & 4294967295UL) >> 23);
#line 115
    d += a;
#line 116
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 60)))) + 3634488961UL;
#line 116
    c = (c << 14) | ((c & 4294967295UL) >> 18);
#line 116
    c += d;
#line 117
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 16)))) + 3889429448UL;
#line 117
    b = (b << 20) | ((b & 4294967295UL) >> 12);
#line 117
    b += c;
#line 118
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 36)))) + 568446438UL;
#line 118
    a = (a << 5) | ((a & 4294967295UL) >> 27);
#line 118
    a += b;
#line 119
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 56)))) + 3275163606UL;
#line 119
    d = (d << 9) | ((d & 4294967295UL) >> 23);
#line 119
    d += a;
#line 120
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 12)))) + 4107603335UL;
#line 120
    c = (c << 14) | ((c & 4294967295UL) >> 18);
#line 120
    c += d;
#line 121
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 32)))) + 1163531501UL;
#line 121
    b = (b << 20) | ((b & 4294967295UL) >> 12);
#line 121
    b += c;
#line 122
    a += ((c ^ (d & (b ^ c))) + (*((MD5_u32plus *)(ptr + 52)))) + 2850285829UL;
#line 122
    a = (a << 5) | ((a & 4294967295UL) >> 27);
#line 122
    a += b;
#line 123
    d += ((b ^ (c & (a ^ b))) + (*((MD5_u32plus *)(ptr + 8)))) + 4243563512UL;
#line 123
    d = (d << 9) | ((d & 4294967295UL) >> 23);
#line 123
    d += a;
#line 124
    c += ((a ^ (b & (d ^ a))) + (*((MD5_u32plus *)(ptr + 28)))) + 1735328473UL;
#line 124
    c = (c << 14) | ((c & 4294967295UL) >> 18);
#line 124
    c += d;
#line 125
    b += ((d ^ (a & (c ^ d))) + (*((MD5_u32plus *)(ptr + 48)))) + 2368359562UL;
#line 125
    b = (b << 20) | ((b & 4294967295UL) >> 12);
#line 125
    b += c;
#line 128
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 20)))) + 4294588738UL;
#line 128
    a = (a << 4) | ((a & 4294967295UL) >> 28);
#line 128
    a += b;
#line 129
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 32)))) + 2272392833UL;
#line 129
    d = (d << 11) | ((d & 4294967295UL) >> 21);
#line 129
    d += a;
#line 130
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 44)))) + 1839030562UL;
#line 130
    c = (c << 16) | ((c & 4294967295UL) >> 16);
#line 130
    c += d;
#line 131
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 56)))) + 4259657740UL;
#line 131
    b = (b << 23) | ((b & 4294967295UL) >> 9);
#line 131
    b += c;
#line 132
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 4)))) + 2763975236UL;
#line 132
    a = (a << 4) | ((a & 4294967295UL) >> 28);
#line 132
    a += b;
#line 133
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 16)))) + 1272893353UL;
#line 133
    d = (d << 11) | ((d & 4294967295UL) >> 21);
#line 133
    d += a;
#line 134
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 28)))) + 4139469664UL;
#line 134
    c = (c << 16) | ((c & 4294967295UL) >> 16);
#line 134
    c += d;
#line 135
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 40)))) + 3200236656UL;
#line 135
    b = (b << 23) | ((b & 4294967295UL) >> 9);
#line 135
    b += c;
#line 136
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 52)))) + 681279174UL;
#line 136
    a = (a << 4) | ((a & 4294967295UL) >> 28);
#line 136
    a += b;
#line 137
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 0)))) + 3936430074UL;
#line 137
    d = (d << 11) | ((d & 4294967295UL) >> 21);
#line 137
    d += a;
#line 138
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 12)))) + 3572445317UL;
#line 138
    c = (c << 16) | ((c & 4294967295UL) >> 16);
#line 138
    c += d;
#line 139
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 24)))) + 76029189UL;
#line 139
    b = (b << 23) | ((b & 4294967295UL) >> 9);
#line 139
    b += c;
#line 140
    a += (((b ^ c) ^ d) + (*((MD5_u32plus *)(ptr + 36)))) + 3654602809UL;
#line 140
    a = (a << 4) | ((a & 4294967295UL) >> 28);
#line 140
    a += b;
#line 141
    d += (((a ^ b) ^ c) + (*((MD5_u32plus *)(ptr + 48)))) + 3873151461UL;
#line 141
    d = (d << 11) | ((d & 4294967295UL) >> 21);
#line 141
    d += a;
#line 142
    c += (((d ^ a) ^ b) + (*((MD5_u32plus *)(ptr + 60)))) + 530742520UL;
#line 142
    c = (c << 16) | ((c & 4294967295UL) >> 16);
#line 142
    c += d;
#line 143
    b += (((c ^ d) ^ a) + (*((MD5_u32plus *)(ptr + 8)))) + 3299628645UL;
#line 143
    b = (b << 23) | ((b & 4294967295UL) >> 9);
#line 143
    b += c;
#line 146
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 0)))) + 4096336452UL;
#line 146
    a = (a << 6) | ((a & 4294967295UL) >> 26);
#line 146
    a += b;
#line 147
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 28)))) + 1126891415UL;
#line 147
    d = (d << 10) | ((d & 4294967295UL) >> 22);
#line 147
    d += a;
#line 148
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 56)))) + 2878612391UL;
#line 148
    c = (c << 15) | ((c & 4294967295UL) >> 17);
#line 148
    c += d;
#line 149
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 20)))) + 4237533241UL;
#line 149
    b = (b << 21) | ((b & 4294967295UL) >> 11);
#line 149
    b += c;
#line 150
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 48)))) + 1700485571UL;
#line 150
    a = (a << 6) | ((a & 4294967295UL) >> 26);
#line 150
    a += b;
#line 151
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 12)))) + 2399980690UL;
#line 151
    d = (d << 10) | ((d & 4294967295UL) >> 22);
#line 151
    d += a;
#line 152
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 40)))) + 4293915773UL;
#line 152
    c = (c << 15) | ((c & 4294967295UL) >> 17);
#line 152
    c += d;
#line 153
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 4)))) + 2240044497UL;
#line 153
    b = (b << 21) | ((b & 4294967295UL) >> 11);
#line 153
    b += c;
#line 154
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 32)))) + 1873313359UL;
#line 154
    a = (a << 6) | ((a & 4294967295UL) >> 26);
#line 154
    a += b;
#line 155
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 60)))) + 4264355552UL;
#line 155
    d = (d << 10) | ((d & 4294967295UL) >> 22);
#line 155
    d += a;
#line 156
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 24)))) + 2734768916UL;
#line 156
    c = (c << 15) | ((c & 4294967295UL) >> 17);
#line 156
    c += d;
#line 157
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 52)))) + 1309151649UL;
#line 157
    b = (b << 21) | ((b & 4294967295UL) >> 11);
#line 157
    b += c;
#line 158
    a += ((c ^ (b | ~ d)) + (*((MD5_u32plus *)(ptr + 16)))) + 4149444226UL;
#line 158
    a = (a << 6) | ((a & 4294967295UL) >> 26);
#line 158
    a += b;
#line 159
    d += ((b ^ (a | ~ c)) + (*((MD5_u32plus *)(ptr + 44)))) + 3174756917UL;
#line 159
    d = (d << 10) | ((d & 4294967295UL) >> 22);
#line 159
    d += a;
#line 160
    c += ((a ^ (d | ~ b)) + (*((MD5_u32plus *)(ptr + 8)))) + 718787259UL;
#line 160
    c = (c << 15) | ((c & 4294967295UL) >> 17);
#line 160
    c += d;
#line 161
    b += ((d ^ (c | ~ a)) + (*((MD5_u32plus *)(ptr + 36)))) + 3951481745UL;
#line 161
    b = (b << 21) | ((b & 4294967295UL) >> 11);
#line 161
    b += c;
#line 163
    a += saved_a;
#line 164
    b += saved_b;
#line 165
    c += saved_c;
#line 166
    d += saved_d;
#line 168
    ptr += 64;
#line 85
    size -= 64UL;
#line 85
    if (! size) {
#line 85
      break;
    }
  }
#line 171
  ctx->a = a;
#line 172
  ctx->b = b;
#line 173
  ctx->c = c;
#line 174
  ctx->d = d;
#line 176
  return ((void *)ptr);
}
}
#line 179 "md5.c"
void MD5_Init(MD5_CTX *ctx ) 
{ 

  {
#line 181
  ctx->a = 1732584193UL;
#line 182
  ctx->b = 4023233417UL;
#line 183
  ctx->c = 2562383102UL;
#line 184
  ctx->d = 271733878UL;
#line 186
  ctx->lo = 0UL;
#line 187
  ctx->hi = 0UL;
#line 188
  return;
}
}
#line 190 "md5.c"
void MD5_Update(MD5_CTX *ctx , void *data , unsigned long size ) 
{ MD5_u32plus saved_lo ;
  unsigned long used ;
  unsigned long free___0 ;

  {
#line 195
  saved_lo = ctx->lo;
#line 196
  ctx->lo = (saved_lo + size) & 536870911UL;
#line 196
  if (ctx->lo < saved_lo) {
#line 197
    ctx->hi = ctx->hi + 1UL;
  }
#line 198
  ctx->hi = ctx->hi + (size >> 29);
#line 200
  used = saved_lo & 63UL;
#line 202
  if (used) {
#line 203
    free___0 = 64UL - used;
#line 205
    if (size < free___0) {
#line 206
      memcpy((void * __restrict  )(& ctx->buffer[used]), (void const   * __restrict  )data,
             (unsigned int )size);
#line 207
      return;
    }
#line 210
    memcpy((void * __restrict  )(& ctx->buffer[used]), (void const   * __restrict  )data,
           (unsigned int )free___0);
#line 211
    data = (void *)((unsigned char *)data + free___0);
#line 212
    size -= free___0;
#line 213
    body(ctx, (void *)(ctx->buffer), 64UL);
  }
#line 216
  if (size >= 64UL) {
#line 217
    data = body(ctx, data, size & 4294967232UL);
#line 218
    size &= 63UL;
  }
#line 221
  memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )data, (unsigned int )size);
#line 222
  return;
}
}
#line 224 "md5.c"
void MD5_Final(unsigned char *result , MD5_CTX *ctx ) 
{ unsigned long used ;
  unsigned long free___0 ;
  unsigned long tmp ;

  {
#line 228
  used = ctx->lo & 63UL;
#line 230
  tmp = used;
#line 230
  used ++;
#line 230
  ctx->buffer[tmp] = (unsigned char)128;
#line 232
  free___0 = 64UL - used;
#line 234
  if (free___0 < 8UL) {
#line 235
    memset((void *)(& ctx->buffer[used]), 0, (unsigned int )free___0);
#line 236
    body(ctx, (void *)(ctx->buffer), 64UL);
#line 237
    used = 0UL;
#line 238
    free___0 = 64UL;
  }
#line 241
  memset((void *)(& ctx->buffer[used]), 0, (unsigned int )(free___0 - 8UL));
#line 243
  ctx->lo = ctx->lo << 3;
#line 244
  ctx->buffer[56] = (unsigned char )ctx->lo;
#line 245
  ctx->buffer[57] = (unsigned char )(ctx->lo >> 8);
#line 246
  ctx->buffer[58] = (unsigned char )(ctx->lo >> 16);
#line 247
  ctx->buffer[59] = (unsigned char )(ctx->lo >> 24);
#line 248
  ctx->buffer[60] = (unsigned char )ctx->hi;
#line 249
  ctx->buffer[61] = (unsigned char )(ctx->hi >> 8);
#line 250
  ctx->buffer[62] = (unsigned char )(ctx->hi >> 16);
#line 251
  ctx->buffer[63] = (unsigned char )(ctx->hi >> 24);
#line 253
  body(ctx, (void *)(ctx->buffer), 64UL);
#line 255
  (*(result + 0)) = (unsigned char )ctx->a;
#line 256
  (*(result + 1)) = (unsigned char )(ctx->a >> 8);
#line 257
  (*(result + 2)) = (unsigned char )(ctx->a >> 16);
#line 258
  (*(result + 3)) = (unsigned char )(ctx->a >> 24);
#line 259
  (*(result + 4)) = (unsigned char )ctx->b;
#line 260
  (*(result + 5)) = (unsigned char )(ctx->b >> 8);
#line 261
  (*(result + 6)) = (unsigned char )(ctx->b >> 16);
#line 262
  (*(result + 7)) = (unsigned char )(ctx->b >> 24);
#line 263
  (*(result + 8)) = (unsigned char )ctx->c;
#line 264
  (*(result + 9)) = (unsigned char )(ctx->c >> 8);
#line 265
  (*(result + 10)) = (unsigned char )(ctx->c >> 16);
#line 266
  (*(result + 11)) = (unsigned char )(ctx->c >> 24);
#line 267
  (*(result + 12)) = (unsigned char )ctx->d;
#line 268
  (*(result + 13)) = (unsigned char )(ctx->d >> 8);
#line 269
  (*(result + 14)) = (unsigned char )(ctx->d >> 16);
#line 270
  (*(result + 15)) = (unsigned char )(ctx->d >> 24);
#line 272
  memset((void *)ctx, 0, sizeof((*ctx)));
#line 273
  return;
}
}
#line 1 "others.lo"
#pragma merger(0,"/tmp/cil-fhHHk4Tl.i","-g -O2 -fPIC")
#line 605 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 493 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 495
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 595
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 654
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 665
extern  __attribute__((__nothrow__)) int putenv(char *__string )  __attribute__((__nonnull__(1))) ;
#line 747 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 328 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 363
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
#line 370
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
#line 370
__inline static  __attribute__((__nothrow__)) int lstat__extinline(char const   *__path ,
                                                                   struct stat *__statbuf ) ;
#line 370 "/usr/include/sys/stat.h"
__inline static int lstat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 373
  tmp = __lxstat(3, __path, __statbuf);
#line 373
  return (tmp);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 142
extern int closedir(DIR *__dirp ) ;
#line 155
extern struct dirent *readdir(DIR *__dirp ) ;
#line 198
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 181 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 45 "others.c"
struct __anonstruct_pthread_mutex_t_16 cli_gentemp_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
#line 192 "clamav.h"
int cl_retflevel(void) ;
#line 193
char const   *cl_retver(void) ;
#line 213
void cl_debug(void) ;
#line 215
void cl_settempdir(char const   *dir , short leavetemps ) ;
#line 220
char const   *cl_strerror(int clerror ) ;
#line 221
char const   *cl_perror(int clerror ) ;
#line 32 "others.h"
int cli_rmdirs(char const   *dirname ) ;
#line 34
char *cli_md5stream(FILE *fs , unsigned char *digcpy ) ;
#line 35
char *cli_md5file(char const   *filename ) ;
#line 36
int cli_readn(int fd , void *buff , unsigned int count ) ;
#line 37
int cli_writen(int fd , void *buff , unsigned int count ) ;
#line 38
int32_t cli_readint32(char const   *buff ) ;
#line 39
void cli_writeint32(char *offset , uint32_t value ) ;
#line 40
char *cli_gentemp(char const   *dir ) ;
#line 41
unsigned int cli_rndnum(unsigned int max ) ;
#line 42
int cli_filecopy(char const   *src , char const   *dest ) ;
#line 79 "others.c"
short cli_debug_flag  =    (short)0;
#line 79 "others.c"
short cli_leavetemps_flag  =    (short)0;
#line 81 "others.c"
static unsigned char oldmd5buff[16]  = 
#line 81
  {      (unsigned char)16,      (unsigned char)38,      (unsigned char)97,      (unsigned char)12, 
        (unsigned char)8,      (unsigned char)4,      (unsigned char)72,      (unsigned char)196, 
        (unsigned char)217,      (unsigned char)144,      (unsigned char)33,      (unsigned char)124, 
        (unsigned char)18,      (unsigned char)11,      (unsigned char)17,      (unsigned char)253};
#line 83 "others.c"
void cli_warnmsg(char const   *str  , ...) 
{ va_list args ;

  {
#line 87
  __builtin_va_start(args, str);
#line 88
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"LibClamAV Warning: ");
#line 89
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )str, args);
#line 90
  __builtin_va_end(args);
#line 91
  return;
}
}
#line 93 "others.c"
void cli_errmsg(char const   *str  , ...) 
{ va_list args ;

  {
#line 97
  __builtin_va_start(args, str);
#line 98
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"LibClamAV Error: ");
#line 99
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )str, args);
#line 100
  __builtin_va_end(args);
#line 101
  return;
}
}
#line 103 "others.c"
void cli_dbgmsg(char const   *str  , ...) 
{ va_list args ;

  {
#line 107
  if (cli_debug_flag) {
#line 108
    __builtin_va_start(args, str);
#line 109
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"LibClamAV debug: ");
#line 110
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )str, args);
#line 111
    __builtin_va_end(args);
  } else {
#line 113
    return;
  }
#line 115
  return;
}
}
#line 117 "others.c"
void cl_debug(void) 
{ 

  {
#line 119
  cli_debug_flag = (short)1;
#line 120
  return;
}
}
#line 122 "others.c"
int cl_retflevel(void) 
{ 

  {
#line 124
  return (5);
}
}
#line 127 "others.c"
char const   *cl_retver(void) 
{ 

  {
#line 129
  return ("0.85.1");
}
}
#line 132 "others.c"
char const   *cl_strerror(int clerror ) 
{ 

  {
#line 134
  switch (clerror) {
  case 0: ;
#line 136
  return ("No viruses detected");
  case 1: ;
#line 138
  return ("Virus(es) detected");
  case 10: ;
#line 140
  return ("Recursion limit exceeded");
  case 11: ;
#line 142
  return ("File size limit exceeded");
  case 12: ;
#line 144
  return ("Files number limit exceeded");
  case 100: ;
#line 146
  return ("RAR module failure");
  case 101: ;
#line 148
  return ("Zip module failure");
  case 102: ;
#line 150
  return ("Malformed Zip detected");
  case 103: ;
#line 152
  return ("GZip module failure");
  case 106: ;
#line 154
  return ("MS Expand module failure");
  case 107: ;
#line 156
  return ("MS CAB module failure");
  case 105: ;
#line 158
  return ("OLE2 module failure");
  case -1: ;
#line 160
  return ("Unable to create temporary file");
  case -7: ;
#line 162
  return ("Unable to create temporary directory");
  case -2: ;
#line 164
  return ("Unable to synchronize file <-> disk");
  case -3: ;
#line 166
  return ("Unable to allocate memory");
  case -4: ;
#line 168
  return ("Unable to open file or directory");
  case -5: ;
#line 170
  return ("Malformed database");
  case -6: ;
#line 172
  return ("Too short pattern detected");
  case -8: ;
#line 174
  return ("Broken or not a CVD file");
  case -9: ;
#line 176
  return ("CVD extraction failure");
  case -10: ;
#line 178
  return ("MD5 verification error");
  case -11: ;
#line 180
  return ("Digital signature verification error");
  case 300: ;
#line 182
  return ("Null argument passed while initialized is required");
  case -12: ;
#line 184
  return ("Input/Output error");
  case -13: ;
#line 186
  return ("Bad format or broken data");
  default: ;
#line 188
  return ("Unknown error code");
  }
}
}
#line 192 "others.c"
char const   *cl_perror(int clerror ) 
{ char const   *tmp ;

  {
#line 194
  tmp = cl_strerror(clerror);
#line 194
  return (tmp);
}
}
#line 197 "others.c"
unsigned char *cli_md5digest(int desc ) 
{ unsigned char *digest ;
  char buff[8192] ;
  MD5_CTX ctx ;
  int bytes ;

  {
#line 205
  digest = (unsigned char *)cli_malloc(16U);
#line 205
  if (! digest) {
#line 206
    return ((unsigned char *)((void *)0));
  }
#line 208
  MD5_Init(& ctx);
#line 210
  while (1) {
#line 210
    bytes = cli_readn(desc, (void *)(buff), 8192U);
#line 210
    if (! bytes) {
#line 210
      break;
    }
#line 211
    MD5_Update(& ctx, (void *)(buff), (unsigned long )bytes);
  }
#line 213
  MD5_Final(digest, & ctx);
#line 215
  return (digest);
}
}
#line 218 "others.c"
char *cli_md5stream(FILE *fs , unsigned char *digcpy ) 
{ unsigned char digest[16] ;
  char buff[8192] ;
  MD5_CTX ctx ;
  char *md5str ;
  char *pt ;
  int i ;
  int bytes ;

  {
#line 227
  MD5_Init(& ctx);
#line 229
  while (1) {
#line 229
    bytes = (int )fread((void * __restrict  )(buff), 1U, 8192U, (FILE * __restrict  )fs);
#line 229
    if (! bytes) {
#line 229
      break;
    }
#line 230
    MD5_Update(& ctx, (void *)(buff), (unsigned long )bytes);
  }
#line 232
  MD5_Final(digest, & ctx);
#line 234
  md5str = (char *)cli_calloc(33U, sizeof(char ));
#line 234
  if (! md5str) {
#line 235
    return ((char *)((void *)0));
  }
#line 237
  pt = md5str;
#line 238
  i = 0;
#line 238
  while (i < 16) {
#line 239
    sprintf((char * __restrict  )pt, (char const   * __restrict  )"%02x", digest[i]);
#line 240
    pt += 2;
#line 238
    i ++;
  }
#line 243
  if (digcpy) {
#line 244
    memcpy((void * __restrict  )digcpy, (void const   * __restrict  )(digest), 16U);
  }
#line 246
  return (md5str);
}
}
#line 249 "others.c"
char *cli_md5file(char const   *filename ) 
{ FILE *fs ;
  char *md5str ;

  {
#line 255
  fs = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 255
  if ((unsigned int )fs == (unsigned int )((void *)0)) {
#line 256
    cli_errmsg("cli_md5file(): Can\'t read file %s\n", filename);
#line 257
    return ((char *)((void *)0));
  }
#line 260
  md5str = cli_md5stream(fs, (unsigned char *)((void *)0));
#line 261
  fclose(fs);
#line 263
  return (md5str);
}
}
#line 266 "others.c"
static char *cli_md5buff(char const   *buffer , unsigned int len ) 
{ unsigned char digest[16] ;
  char *md5str ;
  char *pt ;
  MD5_CTX ctx ;
  int i ;

  {
#line 274
  MD5_Init(& ctx);
#line 275
  MD5_Update(& ctx, (void *)((unsigned char *)buffer), (unsigned long )len);
#line 276
  MD5_Final(digest, & ctx);
#line 277
  memcpy((void * __restrict  )(oldmd5buff), (void const   * __restrict  )(digest),
         16U);
#line 279
  md5str = (char *)cli_calloc(33U, sizeof(char ));
#line 279
  if (! md5str) {
#line 280
    return ((char *)((void *)0));
  }
#line 282
  pt = md5str;
#line 283
  i = 0;
#line 283
  while (i < 16) {
#line 284
    sprintf((char * __restrict  )pt, (char const   * __restrict  )"%02x", digest[i]);
#line 285
    pt += 2;
#line 283
    i ++;
  }
#line 288
  return (md5str);
}
}
#line 291 "others.c"
void *cli_malloc(size_t size ) 
{ void *alloc ;

  {
#line 296
  if (size > 134217728U) {
#line 297
    cli_errmsg("Attempt to allocate %d bytes. Please report to bugs@clamav.net\n",
               size);
#line 298
    return ((void *)0);
  }
#line 301
  alloc = malloc(size);
#line 303
  if (! alloc) {
#line 304
    cli_errmsg("cli_malloc(): Can\'t allocate memory (%d bytes).\n", size);
#line 305
    perror("malloc_problem");
#line 307
    return ((void *)0);
  } else {
#line 308
    return (alloc);
  }
}
}
#line 311 "others.c"
void *cli_calloc(size_t nmemb , size_t size ) 
{ void *alloc ;

  {
#line 316
  if (size > 134217728U) {
#line 317
    cli_errmsg("Attempt to allocate %d bytes. Please report to bugs@clamav.net\n",
               size);
#line 318
    return ((void *)0);
  }
#line 321
  alloc = calloc(nmemb, size);
#line 323
  if (! alloc) {
#line 324
    cli_errmsg("cli_calloc(): Can\'t allocate memory (%d bytes).\n", nmemb * size);
#line 325
    perror("calloc_problem");
#line 327
    return ((void *)0);
  } else {
#line 328
    return (alloc);
  }
}
}
#line 331 "others.c"
void *cli_realloc(void *ptr , size_t size ) 
{ void *alloc ;

  {
#line 336
  alloc = realloc(ptr, size);
#line 338
  if (! alloc) {
#line 339
    cli_errmsg("cli_realloc(): Can\'t re-allocate memory to %d byte.\n", size);
#line 340
    perror("realloc_problem");
#line 341
    return ((void *)0);
  } else {
#line 342
    return (alloc);
  }
}
}
#line 345 "others.c"
unsigned int cli_rndnum(unsigned int max ) 
{ struct timeval tv ;
  clock_t tmp ;
  int tmp___0 ;

  {
#line 349
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((struct timezone *)0));
#line 350
  tmp = clock();
#line 350
  srand((unsigned int )(tv.tv_usec + tmp));
#line 352
  tmp___0 = rand();
#line 352
  return ((unsigned int )tmp___0 % max);
}
}
#line 355 "others.c"
void cl_settempdir(char const   *dir , short leavetemps ) 
{ char *var ;
  size_t tmp ;
  int tmp___1 ;

  {
#line 359
  if (dir) {
#line 360
    tmp = strlen(dir);
#line 360
    var = (char *)cli_malloc(8U + tmp);
#line 361
    sprintf((char * __restrict  )var, (char const   * __restrict  )"TMPDIR=%s", dir);
#line 362
    tmp___1 = putenv(var);
#line 362
    if (tmp___1) {
#line 365
      cli_warnmsg("Can\'t set TMPDIR variable - insufficient space in the environment.\n");
    } else {
#line 363
      cli_dbgmsg("Setting %s as global temporary directory\n", dir);
    }
  }
#line 370
  cli_leavetemps_flag = leavetemps;
#line 371
  return;
}
}
#line 373 "others.c"
char *cli_gentemp(char const   *dir ) 
{ char *name ;
  char *tmp ;
  char const   *mdir ;
  unsigned char salt[48] ;
  int i ;
  struct stat foo ;
  size_t tmp___0 ;
  int tmp___2 ;

  {
#line 382
  if (! dir) {
#line 383
    mdir = getenv("TMPDIR");
#line 383
    if ((unsigned int )mdir == (unsigned int )((void *)0)) {
#line 385
      mdir = "/tmp";
    }
  } else {
#line 390
    mdir = dir;
  }
#line 392
  tmp___0 = strlen(mdir);
#line 392
  name = (char *)cli_calloc((((tmp___0 + 1U) + 16U) + 1U) + 7U, sizeof(char ));
#line 393
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 394
    cli_dbgmsg("cli_gentemp(\'%s\'): out of memory\n", dir);
#line 395
    return ((char *)((void *)0));
  }
#line 399
  pthread_mutex_lock(& cli_gentemp_mutex);
#line 402
  memcpy((void * __restrict  )(salt), (void const   * __restrict  )(oldmd5buff), 16U);
#line 404
  while (1) {
#line 405
    i = 16;
#line 405
    while (i < 48) {
#line 406
      salt[i] = (unsigned char )cli_rndnum(255U);
#line 405
      i ++;
    }
#line 408
    tmp = cli_md5buff((char const   *)((char *)(salt)), 48U);
#line 409
    sprintf((char * __restrict  )name, (char const   * __restrict  )"%s/clamav-",
            mdir);
#line 410
    __builtin_strncat(name, tmp, 16);
#line 411
    free((void *)tmp);
#line 404
    tmp___2 = stat__extinline((char const   *)name, & foo);
#line 404
    if (! (tmp___2 != -1)) {
#line 404
      break;
    }
  }
#line 415
  pthread_mutex_unlock(& cli_gentemp_mutex);
#line 418
  return (name);
}
}
#line 421 "others.c"
int cli_rmdirs(char const   *dirname ) 
{ DIR *dd ;
  struct dirent *dent ;
  struct stat maind ;
  struct stat statbuf ;
  char *fname ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___40 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___59 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___109 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___128 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;

  {
#line 435
  chmod(dirname, 448U);
#line 436
  dd = opendir(dirname);
#line 436
  if ((unsigned int )dd != (unsigned int )((void *)0)) {
#line 437
    while (1) {
#line 437
      tmp___143 = stat__extinline(dirname, & maind);
#line 437
      if (! (tmp___143 != -1)) {
#line 437
        break;
      }
#line 438
      tmp = rmdir(dirname);
#line 438
      if (! tmp) {
#line 438
        break;
      }
#line 445
      while (1) {
#line 445
        dent = readdir(dd);
#line 445
        if (! dent) {
#line 445
          break;
        }
#line 448
        if (dent->d_ino) {
#line 451
          tmp___71 = __builtin_constant_p((int )(dent->d_name));
#line 451
          if (tmp___71) {
#line 451
            tmp___72 = __builtin_constant_p((int )".");
#line 451
            if (tmp___72) {
#line 451
              __s1_len = strlen((char const   *)(dent->d_name));
#line 451
              __s2_len = strlen(".");
#line 451
              if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                     1U)) {
                goto _L___16;
              } else {
#line 451
                if (__s1_len >= 4U) {
                  _L___16: 
#line 451
                  if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                         1U)) {
#line 451
                    tmp___73 = 1;
                  } else {
#line 451
                    if (__s2_len >= 4U) {
#line 451
                      tmp___73 = 1;
                    } else {
#line 451
                      tmp___73 = 0;
                    }
                  }
                } else {
#line 451
                  tmp___73 = 0;
                }
              }
#line 451
              if (tmp___73) {
#line 451
                tmp___40 = __builtin_strcmp(dent->d_name, ".");
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
#line 451
            tmp___70 = __builtin_constant_p((int )(dent->d_name));
#line 451
            if (tmp___70) {
#line 451
              if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                  1U) {
#line 451
                __s1_len = strlen((char const   *)(dent->d_name));
#line 451
                if (__s1_len < 4U) {
#line 451
                  tmp___59 = __builtin_constant_p((int )".");
#line 451
                  if (tmp___59) {
#line 451
                    if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                        1U) {
#line 451
                      tmp___40 = __builtin_strcmp(dent->d_name, ".");
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
#line 451
                    __s2___6 = (unsigned char const   *)".";
#line 451
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
#line 451
                    if (__s1_len > 0U) {
#line 451
                      if (__result___18 == 0) {
#line 451
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
#line 451
                        if (__s1_len > 1U) {
#line 451
                          if (__result___18 == 0) {
#line 451
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
#line 451
                            if (__s1_len > 2U) {
#line 451
                              if (__result___18 == 0) {
#line 451
                                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 451
                    tmp___40 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
#line 451
              tmp___69 = __builtin_constant_p((int )".");
#line 451
              if (tmp___69) {
#line 451
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
#line 451
                  __s2_len = strlen(".");
#line 451
                  if (__s2_len < 4U) {
#line 451
                    tmp___68 = __builtin_constant_p((int )(dent->d_name));
#line 451
                    if (tmp___68) {
#line 451
                      if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                          1U) {
#line 451
                        tmp___40 = __builtin_strcmp(dent->d_name, ".");
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
#line 451
                      __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 451
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 0)));
#line 451
                      if (__s2_len > 0U) {
#line 451
                        if (__result___22 == 0) {
#line 451
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  1)));
#line 451
                          if (__s2_len > 1U) {
#line 451
                            if (__result___22 == 0) {
#line 451
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             2)));
#line 451
                              if (__s2_len > 2U) {
#line 451
                                if (__result___22 == 0) {
#line 451
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 451
                      tmp___40 = __result___22;
                    }
                  } else {
#line 451
                    tmp___40 = __builtin_strcmp(dent->d_name, ".");
                  }
                } else {
#line 451
                  tmp___40 = __builtin_strcmp(dent->d_name, ".");
                }
              } else {
#line 451
                tmp___40 = __builtin_strcmp(dent->d_name, ".");
              }
            }
          }
#line 451
          if (tmp___40) {
#line 451
            tmp___140 = __builtin_constant_p((int )(dent->d_name));
#line 451
            if (tmp___140) {
#line 451
              tmp___141 = __builtin_constant_p((int )"..");
#line 451
              if (tmp___141) {
#line 451
                __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 451
                __s2_len___0 = strlen("..");
#line 451
                if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                       1U)) {
                  goto _L___36;
                } else {
#line 451
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
#line 451
                    if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                           1U)) {
#line 451
                      tmp___142 = 1;
                    } else {
#line 451
                      if (__s2_len___0 >= 4U) {
#line 451
                        tmp___142 = 1;
                      } else {
#line 451
                        tmp___142 = 0;
                      }
                    }
                  } else {
#line 451
                    tmp___142 = 0;
                  }
                }
#line 451
                if (tmp___142) {
#line 451
                  tmp___109 = __builtin_strcmp(dent->d_name, "..");
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
#line 451
              tmp___139 = __builtin_constant_p((int )(dent->d_name));
#line 451
              if (tmp___139) {
#line 451
                if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                    1U) {
#line 451
                  __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 451
                  if (__s1_len___0 < 4U) {
#line 451
                    tmp___128 = __builtin_constant_p((int )"..");
#line 451
                    if (tmp___128) {
#line 451
                      if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                          1U) {
#line 451
                        tmp___109 = __builtin_strcmp(dent->d_name, "..");
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
#line 451
                      __s2___14 = (unsigned char const   *)"..";
#line 451
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
#line 451
                      if (__s1_len___0 > 0U) {
#line 451
                        if (__result___42 == 0) {
#line 451
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
#line 451
                          if (__s1_len___0 > 1U) {
#line 451
                            if (__result___42 == 0) {
#line 451
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
#line 451
                              if (__s1_len___0 > 2U) {
#line 451
                                if (__result___42 == 0) {
#line 451
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 451
                      tmp___109 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
#line 451
                tmp___138 = __builtin_constant_p((int )"..");
#line 451
                if (tmp___138) {
#line 451
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
#line 451
                    __s2_len___0 = strlen("..");
#line 451
                    if (__s2_len___0 < 4U) {
#line 451
                      tmp___137 = __builtin_constant_p((int )(dent->d_name));
#line 451
                      if (tmp___137) {
#line 451
                        if ((unsigned int )((void const   *)(dent->d_name + 1)) -
                            (unsigned int )((void const   *)(dent->d_name)) == 1U) {
#line 451
                          tmp___109 = __builtin_strcmp(dent->d_name, "..");
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
#line 451
                        __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 451
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                0)));
#line 451
                        if (__s2_len___0 > 0U) {
#line 451
                          if (__result___46 == 0) {
#line 451
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    1)));
#line 451
                            if (__s2_len___0 > 1U) {
#line 451
                              if (__result___46 == 0) {
#line 451
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               2)));
#line 451
                                if (__s2_len___0 > 2U) {
#line 451
                                  if (__result___46 == 0) {
#line 451
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)".." +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 451
                        tmp___109 = __result___46;
                      }
                    } else {
#line 451
                      tmp___109 = __builtin_strcmp(dent->d_name, "..");
                    }
                  } else {
#line 451
                    tmp___109 = __builtin_strcmp(dent->d_name, "..");
                  }
                } else {
#line 451
                  tmp___109 = __builtin_strcmp(dent->d_name, "..");
                }
              }
            }
#line 451
            if (tmp___109) {
#line 452
              tmp___0 = strlen(dirname);
#line 452
              tmp___1 = strlen((char const   *)(dent->d_name));
#line 452
              fname = (char *)cli_calloc((tmp___0 + tmp___1) + 2U, sizeof(char ));
#line 453
              sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                      dirname, dent->d_name);
#line 456
              tmp___4 = lstat__extinline((char const   *)fname, & statbuf);
#line 456
              if (tmp___4 != -1) {
#line 457
                if ((statbuf.st_mode & 61440U) == 16384U) {
#line 457
                  if (! ((statbuf.st_mode & 61440U) == 40960U)) {
#line 458
                    tmp___3 = rmdir((char const   *)fname);
#line 458
                    if (tmp___3 == -1) {
#line 459
                      tmp___2 = __errno_location();
#line 459
                      if ((*tmp___2) == 13) {
#line 460
                        cli_errmsg("Can\'t remove some temporary directories due to access problem.\n");
#line 461
                        closedir(dd);
#line 462
                        free((void *)fname);
#line 463
                        return (0);
                      }
#line 465
                      cli_rmdirs((char const   *)fname);
                    }
                  } else {
#line 468
                    unlink((char const   *)fname);
                  }
                } else {
#line 468
                  unlink((char const   *)fname);
                }
              }
#line 471
              free((void *)fname);
            }
          }
        }
      }
#line 476
      rewinddir(dd);
    }
  } else {
#line 481
    return (53);
  }
#line 484
  closedir(dd);
#line 485
  return (0);
}
}
#line 491 "others.c"
int cli_readn(int fd , void *buff , unsigned int count ) 
{ int retval ;
  unsigned int todo ;
  unsigned char *current ;
  int *tmp ;

  {
#line 498
  todo = count;
#line 499
  current = (unsigned char *)buff;
#line 501
  while (1) {
#line 502
    retval = read(fd, (void *)current, todo);
#line 503
    if (retval == 0) {
#line 504
      return ((int )(count - todo));
    }
#line 506
    if (retval < 0) {
#line 507
      tmp = __errno_location();
#line 507
      if ((*tmp) == 4) {
        goto __Cont;
      }
#line 510
      return (-1);
    }
#line 512
    todo -= (unsigned int )retval;
#line 513
    current += retval;
    __Cont: 
#line 501
    if (! (todo > 0U)) {
#line 501
      break;
    }
  }
#line 517
  return ((int )count);
}
}
#line 523 "others.c"
int cli_writen(int fd , void *buff , unsigned int count ) 
{ int retval ;
  unsigned int todo ;
  unsigned char *current ;
  int *tmp ;

  {
#line 530
  todo = count;
#line 531
  current = (unsigned char *)buff;
#line 533
  while (1) {
#line 534
    retval = write(fd, (void const   *)current, todo);
#line 535
    if (retval < 0) {
#line 536
      tmp = __errno_location();
#line 536
      if ((*tmp) == 4) {
        goto __Cont;
      }
#line 539
      return (-1);
    }
#line 541
    todo -= (unsigned int )retval;
#line 542
    current += retval;
    __Cont: 
#line 533
    if (! (todo > 0U)) {
#line 533
      break;
    }
  }
#line 546
  return ((int )count);
}
}
#line 549 "others.c"
int32_t cli_readint32(char const   *buff ) 
{ int32_t ret ;

  {
#line 556
  ret = (int )((int const   )(*(buff + 0)) & 255);
#line 557
  ret |= (int )(((int const   )(*(buff + 1)) & 255) << 8);
#line 558
  ret |= (int )(((int const   )(*(buff + 2)) & 255) << 16);
#line 559
  ret |= (int )(((int const   )(*(buff + 3)) & 255) << 24);
#line 562
  return (ret);
}
}
#line 565 "others.c"
void cli_writeint32(char *offset , uint32_t value ) 
{ 

  {
#line 567
  (*(offset + 0)) = (char )(value & 255U);
#line 568
  (*(offset + 1)) = (char )((value & 65280U) >> 8);
#line 569
  (*(offset + 2)) = (char )((value & 16711680U) >> 16);
#line 570
  (*(offset + 3)) = (char )((value & 4278190080U) >> 24);
#line 571
  return;
}
}
#line 573 "others.c"
int cli_filecopy(char const   *src , char const   *dest ) 
{ char *buffer ;
  int s ;
  int d ;
  int bytes ;
  int tmp ;

  {
#line 579
  s = open(src, 0);
#line 579
  if (s == -1) {
#line 580
    return (-1);
  }
#line 582
  d = open(dest, 577);
#line 582
  if (d == -1) {
#line 583
    close(s);
#line 584
    return (-1);
  }
#line 587
  buffer = (char *)cli_malloc(8192U);
#line 587
  if (! buffer) {
#line 588
    return (-1);
  }
#line 590
  while (1) {
#line 590
    bytes = cli_readn(s, (void *)buffer, 8192U);
#line 590
    if (! (bytes > 0)) {
#line 590
      break;
    }
#line 591
    cli_writen(d, (void *)buffer, (unsigned int )bytes);
  }
#line 593
  free((void *)buffer);
#line 594
  close(s);
#line 596
  tmp = close(d);
#line 596
  return (tmp);
}
}
#line 1 "readdb.lo"
#pragma merger(0,"/tmp/cil-qnyPwq5y.i","-g -O2 -fPIC")
#line 1123 "/usr/include/bits/string2.h"
__inline static char *__strpbrk_c2__extinline(char const   *__s , int __accept1 ,
                                              int __accept2 ) 
{ char *tmp ;

  {
#line 1127
  while (1) {
#line 1127
    if ((int const   )(*__s) != 0) {
#line 1127
      if ((int const   )(*__s) != (int const   )__accept1) {
#line 1127
        if (! ((int const   )(*__s) != (int const   )__accept2)) {
#line 1127
          break;
        }
      } else {
#line 1127
        break;
      }
    } else {
#line 1127
      break;
    }
#line 1128
    __s ++;
  }
#line 1129
  if ((int const   )(*__s) == 0) {
#line 1129
    tmp = (char *)((void *)0);
  } else {
#line 1129
    tmp = (char *)((unsigned int )__s);
  }
#line 1129
  return (tmp);
}
}
#line 1134 "/usr/include/bits/string2.h"
__inline static char *__strpbrk_c3__extinline(char const   *__s , int __accept1 ,
                                              int __accept2 , int __accept3 ) 
{ char *tmp ;

  {
#line 1139
  while (1) {
#line 1139
    if ((int const   )(*__s) != 0) {
#line 1139
      if ((int const   )(*__s) != (int const   )__accept1) {
#line 1139
        if ((int const   )(*__s) != (int const   )__accept2) {
#line 1139
          if (! ((int const   )(*__s) != (int const   )__accept3)) {
#line 1139
            break;
          }
        } else {
#line 1139
          break;
        }
      } else {
#line 1139
        break;
      }
    } else {
#line 1139
      break;
    }
#line 1141
    __s ++;
  }
#line 1142
  if ((int const   )(*__s) == 0) {
#line 1142
    tmp = (char *)((void *)0);
  } else {
#line 1142
    tmp = (char *)((unsigned int )__s);
  }
#line 1142
  return (tmp);
}
}
#line 196 "clamav.h"
int cl_loaddb(char const   *filename , struct cl_node **root , unsigned int *signo ) ;
#line 197
int cl_loaddbdir(char const   *dirname , struct cl_node **root , unsigned int *signo ) ;
#line 208
int cl_statinidir(char const   *dirname , struct cl_stat *dbstat ) ;
#line 209
int cl_statchkdir(struct cl_stat  const  *dbstat ) ;
#line 210
int cl_statfree(struct cl_stat *dbstat ) ;
#line 25 "cvd.h"
int cli_cvdload(FILE *fd , struct cl_node **root , unsigned int *signo , short warn ) ;
#line 22 "str.h"
int cli_strbcasestr(char const   *haystack , char const   *needle ) ;
#line 23
int cli_chomp(char *string ) ;
#line 25
short *cli_hex2si(char const   *hex___0 ) ;
#line 26
char *cli_hex2str(char const   *hex___0 ) ;
#line 27
int cli_hex2num(char const   *hex___0 ) ;
#line 63 "readdb.c"
static int cli_ac_addsig(struct cl_node *root , char const   *virname , char const   *hexsig ,
                         int sigid , int parts , int partno , unsigned short type ,
                         unsigned int mindist , unsigned int maxdist , char *offset ,
                         unsigned short target ) 
{ struct cli_ac_patt *new ;
  char *pt ;
  char *hex___0 ;
  int virlen ;
  int ret ;
  int error ;
  unsigned int i ;
  char *hexcpy ;
  char *hexnew ;
  char *start ;
  char *h ;
  char *c ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *tmp___22 ;
  int tmp___27 ;
  char *tmp___28 ;
  size_t tmp___31 ;
  int tmp___37 ;
  char *tmp___41 ;
  int tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;

  {
#line 67
  error = 0;
#line 71
  new = (struct cli_ac_patt *)cli_calloc(1U, sizeof(struct cli_ac_patt ));
#line 71
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 72
    return (-3);
  }
#line 74
  new->type = type;
#line 75
  new->sigid = (unsigned short )sigid;
#line 76
  new->parts = (unsigned short )parts;
#line 77
  new->partno = (unsigned short )partno;
#line 78
  new->mindist = mindist;
#line 79
  new->maxdist = maxdist;
#line 80
  new->target = target;
#line 81
  new->offset = offset;
#line 83
  tmp___43 = __builtin_constant_p((int )hexsig);
#line 83
  if (tmp___43) {
#line 83
    tmp___41 = (char *)__builtin_strchr(hexsig, '(');
  } else {
#line 83
    tmp___41 = (char *)__builtin_strchr(hexsig, '(');
  }
#line 83
  if (tmp___41) {
#line 86
    tmp___19 = __builtin_constant_p((int )hexsig);
#line 86
    if (tmp___19) {
#line 86
      if ((unsigned int )((void const   *)(hexsig + 1)) - (unsigned int )((void const   *)hexsig) ==
          1U) {
#line 86
        if ((int const   )(*(hexsig + 0)) == 0) {
#line 86
          hexcpy = (char *)calloc(1U, 1U);
        } else {
#line 86
          tmp___16 = strlen(hexsig);
#line 86
          __len___2 = tmp___16 + 1U;
#line 86
          tmp___17 = (char *)malloc(__len___2);
#line 86
          __retval___2 = tmp___17;
#line 86
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 86
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )hexsig,
                                          __len___2);
          }
#line 86
          hexcpy = __retval___2;
        }
      } else {
#line 86
        hexcpy = __strdup(hexsig);
      }
    } else {
#line 86
      hexcpy = __strdup(hexsig);
    }
#line 86
    if (! hexcpy) {
#line 87
      free((void *)new);
#line 88
      return (-3);
    }
#line 91
    tmp___20 = strlen(hexsig);
#line 91
    hexnew = (char *)cli_calloc(tmp___20 + 1U, 1U);
#line 91
    if (! hexnew) {
#line 92
      free((void *)hexcpy);
#line 93
      free((void *)new);
#line 94
      return (-3);
    }
#line 97
    pt = hexcpy;
#line 97
    start = pt;
#line 98
    while (1) {
#line 98
      tmp___37 = __builtin_constant_p((int )start);
#line 98
      if (tmp___37) {
#line 98
        pt = (char *)__builtin_strchr(start, '(');
      } else {
#line 98
        pt = (char *)__builtin_strchr(start, '(');
      }
#line 98
      if (! pt) {
#line 98
        break;
      }
#line 99
      tmp___22 = pt;
#line 99
      pt ++;
#line 99
      (*tmp___22) = (char)0;
#line 101
      if (! start) {
#line 102
        error = 1;
#line 103
        break;
      }
#line 106
      strcat((char * __restrict  )hexnew, (char const   * __restrict  )start);
#line 107
      strcat((char * __restrict  )hexnew, (char const   * __restrict  )"@@");
#line 109
      tmp___27 = __builtin_constant_p((int )pt);
#line 109
      if (tmp___27) {
#line 109
        start = (char *)__builtin_strchr(pt, ')');
      } else {
#line 109
        start = (char *)__builtin_strchr(pt, ')');
      }
#line 109
      if (! start) {
#line 110
        error = 1;
#line 111
        break;
      }
#line 113
      tmp___28 = start;
#line 113
      start ++;
#line 113
      (*tmp___28) = (char)0;
#line 115
      new->alt = (unsigned short )((int )new->alt + 1);
#line 116
      new->altn = (unsigned short *)realloc((void *)new->altn, (unsigned int )new->alt *
                                                               sizeof(unsigned short ));
#line 117
      (*(new->altn + ((int )new->alt - 1))) = (unsigned short)0;
#line 118
      new->altc = (char **)realloc((void *)new->altc, (unsigned int )new->alt * sizeof(char *));
#line 119
      (*(new->altc + ((int )new->alt - 1))) = (char *)((void *)0);
#line 121
      i = 0U;
#line 121
      while (1) {
#line 121
        tmp___31 = strlen((char const   *)pt);
#line 121
        if (! (i < tmp___31)) {
#line 121
          break;
        }
#line 122
        if ((int )(*(pt + i)) == 124) {
#line 123
          (*(new->altn + ((int )new->alt - 1))) = (unsigned short )((int )(*(new->altn +
                                                                             ((int )new->alt -
                                                                              1))) +
                                                                    1);
        }
#line 121
        i ++;
      }
#line 125
      if (! (*(new->altn + ((int )new->alt - 1)))) {
#line 126
        error = 1;
#line 127
        break;
      } else {
#line 129
        (*(new->altn + ((int )new->alt - 1))) = (unsigned short )((int )(*(new->altn +
                                                                           ((int )new->alt -
                                                                            1))) +
                                                                  1);
      }
#line 131
      (*(new->altc + ((int )new->alt - 1))) = (char *)cli_calloc((unsigned int )(*(new->altn +
                                                                                   ((int )new->alt -
                                                                                    1))),
                                                                 1U);
#line 131
      if (! (*(new->altc + ((int )new->alt - 1)))) {
#line 132
        error = 1;
#line 133
        break;
      }
#line 136
      i = 0U;
#line 136
      while (i < (unsigned int )(*(new->altn + ((int )new->alt - 1)))) {
#line 137
        h = cli_strtok((char const   *)pt, (int )i, "|");
#line 137
        if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 138
          error = 1;
#line 139
          break;
        }
#line 142
        c = cli_hex2str((char const   *)h);
#line 142
        if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 143
          free((void *)h);
#line 144
          error = 1;
#line 145
          break;
        }
#line 148
        (*((*(new->altc + ((int )new->alt - 1))) + i)) = (*c);
#line 149
        free((void *)c);
#line 150
        free((void *)h);
#line 136
        i ++;
      }
#line 153
      if (error) {
#line 154
        break;
      }
    }
#line 157
    if (start) {
#line 158
      strcat((char * __restrict  )hexnew, (char const   * __restrict  )start);
    }
#line 160
    hex___0 = hexnew;
#line 161
    free((void *)hexcpy);
#line 163
    if (error) {
#line 164
      free((void *)hexnew);
#line 165
      if (new->alt) {
#line 166
        free((void *)new->altn);
#line 167
        i = 0U;
#line 167
        while (i < (unsigned int )new->alt) {
#line 168
          if ((*(new->altc + i))) {
#line 169
            free((void *)(*(new->altc + i)));
          }
#line 167
          i ++;
        }
#line 170
        free((void *)new->altc);
      }
#line 172
      free((void *)new);
#line 173
      return (-5);
    }
  } else {
#line 177
    hex___0 = (char *)hexsig;
  }
#line 180
  tmp___44 = strlen((char const   *)hex___0);
#line 180
  new->length = tmp___44 / 2U;
#line 182
  if (new->length > root->maxpatlen) {
#line 183
    root->maxpatlen = new->length;
  }
#line 185
  new->pattern = cli_hex2si((char const   *)hex___0);
#line 185
  if ((unsigned int )new->pattern == (unsigned int )((void *)0)) {
#line 186
    if (new->alt) {
#line 187
      free((void *)new->altn);
#line 188
      i = 0U;
#line 188
      while (i < (unsigned int )new->alt) {
#line 189
        free((void *)(*(new->altc + i)));
#line 188
        i ++;
      }
#line 190
      free((void *)new->altc);
#line 191
      free((void *)hex___0);
    }
#line 193
    free((void *)new);
#line 194
    return (-5);
  }
#line 197
  pt = strstr(virname, "(Clam)");
#line 197
  if (pt) {
#line 198
    tmp___45 = strlen(virname);
#line 198
    tmp___46 = strlen((char const   *)pt);
#line 198
    virlen = (int )((tmp___45 - tmp___46) - 1U);
  } else {
#line 200
    virlen = (int )strlen(virname);
  }
#line 202
  if (virlen <= 0) {
#line 203
    free((void *)new->pattern);
#line 204
    if (new->alt) {
#line 205
      free((void *)new->altn);
#line 206
      i = 0U;
#line 206
      while (i < (unsigned int )new->alt) {
#line 207
        free((void *)(*(new->altc + i)));
#line 206
        i ++;
      }
#line 208
      free((void *)new->altc);
#line 209
      free((void *)hex___0);
    }
#line 211
    free((void *)new);
#line 212
    return (-5);
  }
#line 215
  new->virname = (char *)cli_calloc((unsigned int )(virlen + 1), sizeof(char ));
#line 215
  if ((unsigned int )new->virname == (unsigned int )((void *)0)) {
#line 216
    free((void *)new->pattern);
#line 217
    if (new->alt) {
#line 218
      free((void *)new->altn);
#line 219
      i = 0U;
#line 219
      while (i < (unsigned int )new->alt) {
#line 220
        free((void *)(*(new->altc + i)));
#line 219
        i ++;
      }
#line 221
      free((void *)new->altc);
#line 222
      free((void *)hex___0);
    }
#line 224
    free((void *)new);
#line 225
    return (-3);
  }
#line 228
  __builtin_strncpy(new->virname, virname, virlen);
#line 230
  ret = cli_ac_addpatt(root, new);
#line 230
  if (ret) {
#line 231
    free((void *)new->pattern);
#line 232
    free((void *)new->virname);
#line 233
    if (new->alt) {
#line 234
      free((void *)new->altn);
#line 235
      i = 0U;
#line 235
      while (i < (unsigned int )new->alt) {
#line 236
        free((void *)(*(new->altc + i)));
#line 235
        i ++;
      }
#line 237
      free((void *)new->altc);
#line 238
      free((void *)hex___0);
    }
#line 240
    free((void *)new);
#line 241
    return (ret);
  }
#line 244
  if (new->alt) {
#line 245
    free((void *)hex___0);
  }
#line 247
  return (0);
}
}
#line 376
extern int __builtin_strpbrk() ;
#line 250 "readdb.c"
int cli_parse_add(struct cl_node *root , char const   *virname , char const   *hexsig ,
                  unsigned short type , char *offset , unsigned short target ) 
{ struct cli_bm_patt *bm_new ;
  char *pt ;
  char *hexcpy ;
  char *start ;
  char *n ;
  int ret ;
  int virlen ;
  int asterisk ;
  unsigned int i ;
  unsigned int j ;
  unsigned int len ;
  unsigned int parts ;
  int mindist ;
  int maxdist ;
  int error ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___30 ;
  int tmp___32 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  char __a0 ;
  char __a1 ;
  char __a2 ;
  char *tmp___102 ;
  int tmp___164 ;
  int tmp___165 ;
  char *tmp___169 ;
  int tmp___171 ;
  char *tmp___175 ;
  int tmp___177 ;

  {
#line 254
  asterisk = 0;
#line 255
  parts = 0U;
#line 256
  mindist = 0;
#line 256
  maxdist = 0;
#line 256
  error = 0;
#line 259
  tmp___177 = __builtin_constant_p((int )hexsig);
#line 259
  if (tmp___177) {
#line 259
    tmp___175 = (char *)__builtin_strchr(hexsig, '{');
  } else {
#line 259
    tmp___175 = (char *)__builtin_strchr(hexsig, '{');
  }
#line 259
  if (tmp___175) {
#line 261
    root->ac_partsigs = root->ac_partsigs + 1U;
#line 263
    tmp___18 = __builtin_constant_p((int )hexsig);
#line 263
    if (tmp___18) {
#line 263
      if ((unsigned int )((void const   *)(hexsig + 1)) - (unsigned int )((void const   *)hexsig) ==
          1U) {
#line 263
        if ((int const   )(*(hexsig + 0)) == 0) {
#line 263
          hexcpy = (char *)calloc(1U, 1U);
        } else {
#line 263
          tmp___15 = strlen(hexsig);
#line 263
          __len___2 = tmp___15 + 1U;
#line 263
          tmp___16 = (char *)malloc(__len___2);
#line 263
          __retval___2 = tmp___16;
#line 263
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 263
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )hexsig,
                                          __len___2);
          }
#line 263
          hexcpy = __retval___2;
        }
      } else {
#line 263
        hexcpy = __strdup(hexsig);
      }
    } else {
#line 263
      hexcpy = __strdup(hexsig);
    }
#line 263
    if (! hexcpy) {
#line 264
      return (-3);
    }
#line 266
    len = strlen(hexsig);
#line 267
    i = 0U;
#line 267
    while (i < len) {
#line 268
      if ((int const   )(*(hexsig + i)) == 123) {
#line 269
        parts ++;
      } else {
#line 268
        if ((int const   )(*(hexsig + i)) == 42) {
#line 269
          parts ++;
        }
      }
#line 267
      i ++;
    }
#line 271
    if (parts) {
#line 272
      parts ++;
    }
#line 274
    pt = hexcpy;
#line 274
    start = pt;
#line 275
    i = 1U;
#line 275
    while (i <= parts) {
#line 277
      if (i != parts) {
#line 278
        j = 0U;
#line 278
        while (1) {
#line 278
          tmp___19 = strlen((char const   *)start);
#line 278
          if (! (j < tmp___19)) {
#line 278
            break;
          }
#line 279
          if ((int )(*(start + j)) == 123) {
#line 280
            asterisk = 0;
#line 281
            pt = start + j;
#line 282
            break;
          }
#line 284
          if ((int )(*(start + j)) == 42) {
#line 285
            asterisk = 1;
#line 286
            pt = start + j;
#line 287
            break;
          }
#line 278
          j ++;
        }
#line 290
        tmp___20 = pt;
#line 290
        pt ++;
#line 290
        (*tmp___20) = (char)0;
      }
#line 293
      ret = cli_ac_addsig(root, virname, (char const   *)start, (int )root->ac_partsigs,
                          (int )parts, (int )i, type, (unsigned int )mindist, (unsigned int )maxdist,
                          offset, target);
#line 293
      if (ret) {
#line 294
        cli_errmsg("cli_parse_add(): Problem adding signature (1).\n");
#line 295
        error = 1;
#line 296
        break;
      }
#line 299
      if (i == parts) {
#line 300
        break;
      }
#line 302
      maxdist = 0;
#line 302
      mindist = maxdist;
#line 304
      if (asterisk) {
#line 305
        start = pt;
        goto __Cont;
      }
#line 309
      tmp___25 = __builtin_constant_p((int )pt);
#line 309
      if (tmp___25) {
#line 309
        start = (char *)__builtin_strchr(pt, '}');
      } else {
#line 309
        start = (char *)__builtin_strchr(pt, '}');
      }
#line 309
      if (! start) {
#line 310
        error = 1;
#line 311
        break;
      }
#line 313
      tmp___26 = start;
#line 313
      start ++;
#line 313
      (*tmp___26) = (char)0;
#line 315
      if (! pt) {
#line 316
        error = 1;
#line 317
        break;
      }
#line 320
      tmp___32 = __builtin_constant_p((int )pt);
#line 320
      if (tmp___32) {
#line 320
        tmp___30 = (char *)__builtin_strchr(pt, '-');
      } else {
#line 320
        tmp___30 = (char *)__builtin_strchr(pt, '-');
      }
#line 320
      if (tmp___30) {
#line 326
        n = cli_strtok((char const   *)pt, 0, "-");
#line 326
        if (n) {
#line 327
          mindist = atoi__extinline((char const   *)n);
#line 327
          if (mindist < 0) {
#line 328
            error = 1;
#line 329
            free((void *)n);
#line 330
            break;
          }
#line 332
          free((void *)n);
        }
#line 335
        n = cli_strtok((char const   *)pt, 1, "-");
#line 335
        if (n) {
#line 336
          maxdist = atoi__extinline((char const   *)n);
#line 336
          if (maxdist < 0) {
#line 337
            error = 1;
#line 338
            free((void *)n);
#line 339
            break;
          }
#line 341
          free((void *)n);
        }
      } else {
#line 321
        maxdist = atoi__extinline((char const   *)pt);
#line 321
        mindist = maxdist;
#line 321
        if (mindist < 0) {
#line 322
          error = 1;
#line 323
          break;
        }
      }
      __Cont: 
#line 275
      i ++;
    }
#line 346
    free((void *)hexcpy);
#line 347
    if (error) {
#line 348
      return (-5);
    }
  } else {
#line 350
    tmp___171 = __builtin_constant_p((int )hexsig);
#line 350
    if (tmp___171) {
#line 350
      tmp___169 = (char *)__builtin_strchr(hexsig, '*');
    } else {
#line 350
      tmp___169 = (char *)__builtin_strchr(hexsig, '*');
    }
#line 350
    if (tmp___169) {
#line 351
      root->ac_partsigs = root->ac_partsigs + 1U;
#line 353
      len = strlen(hexsig);
#line 354
      i = 0U;
#line 354
      while (i < len) {
#line 355
        if ((int const   )(*(hexsig + i)) == 42) {
#line 356
          parts ++;
        }
#line 354
        i ++;
      }
#line 358
      if (parts) {
#line 359
        parts ++;
      }
#line 361
      i = 1U;
#line 361
      while (i <= parts) {
#line 362
        pt = cli_strtok(hexsig, (int )(i - 1U), "*");
#line 362
        if ((unsigned int )pt == (unsigned int )((void *)0)) {
#line 363
          cli_errmsg("Can\'t extract part %d of partial signature.\n", i + 1U);
#line 364
          return (-5);
        }
#line 367
        ret = cli_ac_addsig(root, virname, (char const   *)pt, (int )root->ac_partsigs,
                            (int )parts, (int )i, type, 0U, 0U, offset, target);
#line 367
        if (ret) {
#line 368
          cli_errmsg("cli_parse_add(): Problem adding signature (2).\n");
#line 369
          free((void *)pt);
#line 370
          return (ret);
        }
#line 373
        free((void *)pt);
#line 361
        i ++;
      }
    } else {
#line 376
      tmp___165 = __builtin_constant_p((int )"?(");
#line 376
      if (tmp___165) {
#line 376
        if ((unsigned int )((void const   *)("?(" + 1)) - (unsigned int )((void const   *)"?(") ==
            1U) {
#line 376
          tmp___164 = __builtin_constant_p((int )hexsig);
#line 376
          if (tmp___164) {
#line 376
            if ((unsigned int )((void const   *)(hexsig + 1)) - (unsigned int )((void const   *)hexsig) ==
                1U) {
#line 376
              tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
#line 376
            __a0 = (char )(*("?(" + 0));
#line 376
            if ((int )__a0 == 0) {
#line 376
              tmp___102 = (char *)((void *)0);
            } else {
#line 376
              __a1 = (char )(*("?(" + 1));
#line 376
              if ((int )__a1 == 0) {
#line 376
                tmp___102 = (char *)__builtin_strchr(hexsig, __a0);
              } else {
#line 376
                __a2 = (char )(*("?(" + 2));
#line 376
                if ((int )__a2 == 0) {
#line 376
                  tmp___102 = __strpbrk_c2__extinline(hexsig, (int )__a0, (int )__a1);
                } else {
#line 376
                  if ((int const   )(*("?(" + 3)) == 0) {
#line 376
                    tmp___102 = __strpbrk_c3__extinline(hexsig, (int )__a0, (int )__a1,
                                                        (int )__a2);
                  } else {
#line 376
                    tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
                  }
                }
              }
            }
          }
        } else {
#line 376
          tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
        }
      } else {
#line 376
        tmp___102 = (char *)__builtin_strpbrk(hexsig, "?(");
      }
#line 376
      if (tmp___102) {
        goto _L___1;
      } else {
#line 376
        if (type) {
          _L___1: 
#line 377
          ret = cli_ac_addsig(root, virname, hexsig, 0, 0, 0, type, 0U, 0U, offset,
                              target);
#line 377
          if (ret) {
#line 378
            cli_errmsg("cli_parse_add(): Problem adding signature (3).\n");
#line 379
            return (ret);
          }
        } else {
#line 383
          bm_new = (struct cli_bm_patt *)calloc(1U, sizeof(struct cli_bm_patt ));
#line 384
          if (! bm_new) {
#line 385
            return (-3);
          }
#line 387
          bm_new->pattern = cli_hex2str(hexsig);
#line 387
          if (! bm_new->pattern) {
#line 388
            free((void *)bm_new);
#line 389
            return (-5);
          }
#line 392
          tmp___34 = strlen(hexsig);
#line 392
          bm_new->length = tmp___34 / 2U;
#line 394
          pt = strstr(virname, "(Clam)");
#line 394
          if (pt) {
#line 395
            tmp___35 = strlen(virname);
#line 395
            tmp___36 = strlen((char const   *)pt);
#line 395
            virlen = (int )((tmp___35 - tmp___36) - 1U);
          } else {
#line 397
            virlen = (int )strlen(virname);
          }
#line 399
          if (virlen <= 0) {
#line 400
            free((void *)bm_new->pattern);
#line 401
            free((void *)bm_new);
#line 402
            return (-5);
          }
#line 405
          bm_new->virname = (char *)cli_calloc((unsigned int )(virlen + 1), sizeof(char ));
#line 405
          if ((unsigned int )bm_new->virname == (unsigned int )((void *)0)) {
#line 406
            free((void *)bm_new->pattern);
#line 407
            free((void *)bm_new);
#line 408
            return (-3);
          }
#line 411
          __builtin_strncpy(bm_new->virname, virname, virlen);
#line 413
          bm_new->offset = offset;
#line 414
          bm_new->target = target;
#line 416
          if (bm_new->length > root->maxpatlen) {
#line 417
            root->maxpatlen = bm_new->length;
          }
#line 419
          ret = cli_bm_addpatt(root, bm_new);
#line 419
          if (ret) {
#line 420
            cli_errmsg("cli_parse_add(): Problem adding signature (4).\n");
#line 421
            free((void *)bm_new->pattern);
#line 422
            free((void *)bm_new->virname);
#line 423
            free((void *)bm_new);
#line 424
            return (ret);
          }
        }
      }
    }
  }
#line 428
  return (0);
}
}
#line 431 "readdb.c"
static int cli_loaddb(FILE *fd , struct cl_node **root , unsigned int *signo ) 
{ char buffer[8192] ;
  char *pt ;
  char *start ;
  int line ;
  int ret ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 434
  line = 0;
#line 434
  ret = 0;
#line 437
  if (! (*root)) {
#line 438
    cli_dbgmsg("Initializing main node\n");
#line 439
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
#line 440
    if (! (*root)) {
#line 441
      return (-3);
    }
#line 442
    ((*root))->refcount = 1U;
  }
#line 445
  if (! ((*root))->ac_root) {
#line 446
    cli_dbgmsg("Initializing trie\n");
#line 447
    ((*root))->ac_root = (struct cli_ac_node *)cli_calloc(1U, sizeof(struct cli_ac_node ));
#line 448
    if (! ((*root))->ac_root) {
#line 449
      free((void *)(*root));
#line 450
      cli_errmsg("Can\'t initialise AC pattern matcher\n");
#line 451
      return (-3);
    }
  }
#line 455
  if (! ((*root))->bm_shift) {
#line 456
    cli_dbgmsg("Initializing BM tables\n");
#line 457
    ret = cli_bm_init((*root));
#line 457
    if (ret) {
#line 458
      cli_errmsg("Can\'t initialise BM pattern matcher\n");
#line 459
      return (ret);
    }
  }
#line 463
  while (1) {
#line 463
    tmp___7 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
#line 463
    if (! tmp___7) {
#line 463
      break;
    }
#line 464
    line ++;
#line 465
    cli_chomp(buffer);
#line 467
    tmp___5 = __builtin_constant_p((int )(buffer));
#line 467
    if (tmp___5) {
#line 467
      pt = (char *)__builtin_strchr(buffer, '=');
    } else {
#line 467
      pt = (char *)__builtin_strchr(buffer, '=');
    }
#line 468
    if (! pt) {
#line 469
      cli_errmsg("Malformed pattern line %d\n", line);
#line 470
      ret = -5;
#line 471
      break;
    }
#line 474
    start = buffer;
#line 475
    tmp___6 = pt;
#line 475
    pt ++;
#line 475
    (*tmp___6) = (char)0;
#line 477
    if ((int )(*pt) == 61) {
#line 477
      continue;
    }
#line 479
    ret = cli_parse_add((*root), (char const   *)start, (char const   *)pt, (unsigned short)0,
                        (char *)((void *)0), (unsigned short)0);
#line 479
    if (ret) {
#line 480
      cli_errmsg("Problem parsing signature at line %d\n", line);
#line 481
      ret = -5;
#line 482
      break;
    }
  }
#line 486
  if (! line) {
#line 487
    cli_errmsg("Empty database file\n");
#line 488
    cl_free((*root));
#line 489
    return (-5);
  }
#line 492
  if (ret) {
#line 493
    cli_errmsg("Problem parsing database at line %d\n", line);
#line 494
    cl_free((*root));
#line 495
    return (ret);
  }
#line 498
  if (signo) {
#line 499
    (*signo) += (unsigned int )line;
  }
#line 501
  return (0);
}
}
#line 504 "readdb.c"
static int cli_loadndb(FILE *fd , struct cl_node **root , unsigned int *signo ) 
{ char buffer[8192] ;
  char *sig ;
  char *virname ;
  char *offset ;
  char *pt ;
  int line ;
  int sigs ;
  int ret ;
  unsigned short target ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;
  int tmp___147 ;
  size_t tmp___148 ;
  unsigned short const   **tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  unsigned short const   **tmp___152 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___189 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___208 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___217 ;
  int tmp___218 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  int tmp___222 ;
  char *tmp___223 ;

  {
#line 507
  line = 0;
#line 507
  sigs = 0;
#line 507
  ret = 0;
#line 511
  if (! (*root)) {
#line 512
    cli_dbgmsg("Initializing main node\n");
#line 513
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
#line 514
    if (! (*root)) {
#line 515
      return (-3);
    }
#line 516
    ((*root))->refcount = 1U;
  }
#line 519
  if (! ((*root))->ac_root) {
#line 520
    cli_dbgmsg("Initializing trie\n");
#line 521
    ((*root))->ac_root = (struct cli_ac_node *)cli_calloc(1U, sizeof(struct cli_ac_node ));
#line 522
    if (! ((*root))->ac_root) {
#line 523
      free((void *)(*root));
#line 524
      cli_errmsg("Can\'t initialise AC pattern matcher\n");
#line 525
      return (-3);
    }
  }
#line 529
  if (! ((*root))->bm_shift) {
#line 530
    cli_dbgmsg("Initializing BM tables\n");
#line 531
    ret = cli_bm_init((*root));
#line 531
    if (ret) {
#line 532
      cli_errmsg("Can\'t initialise BM pattern matcher\n");
#line 533
      return (ret);
    }
  }
#line 537
  while (1) {
#line 537
    tmp___223 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
#line 537
    if (! tmp___223) {
#line 537
      break;
    }
#line 538
    line ++;
#line 540
    tmp___145 = __builtin_constant_p((int )(buffer));
#line 540
    if (tmp___145) {
#line 540
      tmp___146 = strlen((char const   *)(buffer));
#line 540
      if (tmp___146 < 20U) {
        goto _L___39;
      } else {
        goto _L___40;
      }
    } else {
      _L___40: 
#line 540
      tmp___147 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
#line 540
      if (tmp___147) {
#line 540
        tmp___148 = strlen("Exploit.JPEG.Comment");
#line 540
        if (tmp___148 < 20U) {
          _L___39: 
#line 540
          tmp___142 = __builtin_constant_p((int )(buffer));
#line 540
          if (tmp___142) {
#line 540
            tmp___143 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
#line 540
            if (tmp___143) {
#line 540
              __s1_len___0 = strlen((char const   *)(buffer));
#line 540
              __s2_len___0 = strlen("Exploit.JPEG.Comment");
#line 540
              if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                     1U)) {
                goto _L___36;
              } else {
#line 540
                if (__s1_len___0 >= 4U) {
                  _L___36: 
#line 540
                  if (! ((unsigned int )((void const   *)("Exploit.JPEG.Comment" +
                                                          1)) - (unsigned int )((void const   *)"Exploit.JPEG.Comment") ==
                         1U)) {
#line 540
                    tmp___144 = 1;
                  } else {
#line 540
                    if (__s2_len___0 >= 4U) {
#line 540
                      tmp___144 = 1;
                    } else {
#line 540
                      tmp___144 = 0;
                    }
                  }
                } else {
#line 540
                  tmp___144 = 0;
                }
              }
#line 540
              if (tmp___144) {
#line 540
                tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
              } else {
                goto _L___38;
              }
            } else {
              goto _L___38;
            }
          } else {
            _L___38: 
#line 540
            tmp___141 = __builtin_constant_p((int )(buffer));
#line 540
            if (tmp___141) {
#line 540
              if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                  1U) {
#line 540
                __s1_len___0 = strlen((char const   *)(buffer));
#line 540
                if (__s1_len___0 < 4U) {
#line 540
                  tmp___130 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
#line 540
                  if (tmp___130) {
#line 540
                    if ((unsigned int )((void const   *)("Exploit.JPEG.Comment" +
                                                         1)) - (unsigned int )((void const   *)"Exploit.JPEG.Comment") ==
                        1U) {
#line 540
                      tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                    } else {
                      goto _L___31;
                    }
                  } else {
                    _L___31: 
#line 540
                    __s2___14 = (unsigned char const   *)"Exploit.JPEG.Comment";
#line 540
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
#line 540
                    if (__s1_len___0 > 0U) {
#line 540
                      if (__result___42 == 0) {
#line 540
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
#line 540
                        if (__s1_len___0 > 1U) {
#line 540
                          if (__result___42 == 0) {
#line 540
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
#line 540
                            if (__s1_len___0 > 2U) {
#line 540
                              if (__result___42 == 0) {
#line 540
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 540
                    tmp___111 = __result___42;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                goto _L___35;
              }
            } else {
              _L___35: 
#line 540
              tmp___140 = __builtin_constant_p((int )"Exploit.JPEG.Comment");
#line 540
              if (tmp___140) {
#line 540
                if ((unsigned int )((void const   *)("Exploit.JPEG.Comment" + 1)) -
                    (unsigned int )((void const   *)"Exploit.JPEG.Comment") == 1U) {
#line 540
                  __s2_len___0 = strlen("Exploit.JPEG.Comment");
#line 540
                  if (__s2_len___0 < 4U) {
#line 540
                    tmp___139 = __builtin_constant_p((int )(buffer));
#line 540
                    if (tmp___139) {
#line 540
                      if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                          1U) {
#line 540
                        tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: 
#line 540
                      __s1___30 = (unsigned char const   *)((char const   *)(buffer));
#line 540
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                                                 0)));
#line 540
                      if (__s2_len___0 > 0U) {
#line 540
                        if (__result___46 == 0) {
#line 540
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                  1)));
#line 540
                          if (__s2_len___0 > 1U) {
#line 540
                            if (__result___46 == 0) {
#line 540
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                                             2)));
#line 540
                              if (__s2_len___0 > 2U) {
#line 540
                                if (__result___46 == 0) {
#line 540
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"Exploit.JPEG.Comment" +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 540
                      tmp___111 = __result___46;
                    }
                  } else {
#line 540
                    tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                  }
                } else {
#line 540
                  tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
                }
              } else {
#line 540
                tmp___111 = __builtin_strcmp(buffer, "Exploit.JPEG.Comment");
              }
            }
          }
#line 540
          tmp___75 = tmp___111;
        } else {
#line 540
          tmp___75 = strncmp((char const   *)(buffer), "Exploit.JPEG.Comment", 20U);
        }
      } else {
#line 540
        tmp___75 = strncmp((char const   *)(buffer), "Exploit.JPEG.Comment", 20U);
      }
    }
#line 540
    if (! tmp___75) {
#line 541
      continue;
    }
#line 543
    sigs ++;
#line 544
    cli_chomp(buffer);
#line 546
    virname = cli_strtok((char const   *)(buffer), 0, ":");
#line 546
    if (! virname) {
#line 547
      ret = -5;
#line 548
      break;
    }
#line 551
    pt = cli_strtok((char const   *)(buffer), 4, ":");
#line 551
    if (pt) {
#line 552
      tmp___149 = __ctype_b_loc();
#line 552
      if (! ((int const   )(*((*tmp___149) + (int )(*pt))) & 2048)) {
#line 553
        free((void *)virname);
#line 554
        free((void *)pt);
#line 555
        ret = -5;
#line 556
        break;
      }
#line 559
      tmp___150 = atoi__extinline((char const   *)pt);
#line 559
      tmp___151 = cl_retflevel();
#line 559
      if (tmp___150 > tmp___151) {
#line 560
        cli_warnmsg("Signature for %s requires new ClamAV version. Please update!\n",
                    virname);
#line 561
        sigs --;
#line 562
        free((void *)virname);
#line 563
        free((void *)pt);
#line 564
        continue;
      }
#line 567
      free((void *)pt);
    }
#line 570
    pt = cli_strtok((char const   *)(buffer), 1, ":");
#line 570
    if (pt) {
#line 570
      tmp___152 = __ctype_b_loc();
#line 570
      if (! ((int const   )(*((*tmp___152) + (int )(*pt))) & 2048)) {
        _L___41: 
#line 571
        free((void *)virname);
#line 572
        if (pt) {
#line 573
          free((void *)pt);
        }
#line 574
        ret = -5;
#line 575
        break;
      }
    } else {
      goto _L___41;
    }
#line 577
    target = (unsigned short )atoi__extinline((char const   *)pt);
#line 578
    free((void *)pt);
#line 580
    offset = cli_strtok((char const   *)(buffer), 2, ":");
#line 580
    if (offset) {
#line 584
      tmp___220 = __builtin_constant_p((int )offset);
#line 584
      if (tmp___220) {
#line 584
        tmp___221 = __builtin_constant_p((int )"*");
#line 584
        if (tmp___221) {
#line 584
          __s1_len___1 = strlen((char const   *)offset);
#line 584
          __s2_len___1 = strlen("*");
#line 584
          if (! ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) ==
                 1U)) {
            goto _L___59;
          } else {
#line 584
            if (__s1_len___1 >= 4U) {
              _L___59: 
#line 584
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 584
                tmp___222 = 1;
              } else {
#line 584
                if (__s2_len___1 >= 4U) {
#line 584
                  tmp___222 = 1;
                } else {
#line 584
                  tmp___222 = 0;
                }
              }
            } else {
#line 584
              tmp___222 = 0;
            }
          }
#line 584
          if (tmp___222) {
#line 584
            tmp___189 = __builtin_strcmp(offset, "*");
          } else {
            goto _L___61;
          }
        } else {
          goto _L___61;
        }
      } else {
        _L___61: 
#line 584
        tmp___219 = __builtin_constant_p((int )offset);
#line 584
        if (tmp___219) {
#line 584
          if ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) ==
              1U) {
#line 584
            __s1_len___1 = strlen((char const   *)offset);
#line 584
            if (__s1_len___1 < 4U) {
#line 584
              tmp___208 = __builtin_constant_p((int )"*");
#line 584
              if (tmp___208) {
#line 584
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 584
                  tmp___189 = __builtin_strcmp(offset, "*");
                } else {
                  goto _L___54;
                }
              } else {
                _L___54: 
#line 584
                __s2___22 = (unsigned char const   *)"*";
#line 584
                __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                        0)) - (int const   )(*(__s2___22 +
                                                                               0)));
#line 584
                if (__s1_len___1 > 0U) {
#line 584
                  if (__result___66 == 0) {
#line 584
                    __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                            1)) - (int const   )(*(__s2___22 +
                                                                                   1)));
#line 584
                    if (__s1_len___1 > 1U) {
#line 584
                      if (__result___66 == 0) {
#line 584
                        __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                                2)) - (int const   )(*(__s2___22 +
                                                                                       2)));
#line 584
                        if (__s1_len___1 > 2U) {
#line 584
                          if (__result___66 == 0) {
#line 584
                            __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)offset) +
                                                                    3)) - (int const   )(*(__s2___22 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 584
                tmp___189 = __result___66;
              }
            } else {
              goto _L___58;
            }
          } else {
            goto _L___58;
          }
        } else {
          _L___58: 
#line 584
          tmp___218 = __builtin_constant_p((int )"*");
#line 584
          if (tmp___218) {
#line 584
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 584
              __s2_len___1 = strlen("*");
#line 584
              if (__s2_len___1 < 4U) {
#line 584
                tmp___217 = __builtin_constant_p((int )offset);
#line 584
                if (tmp___217) {
#line 584
                  if ((unsigned int )((void const   *)(offset + 1)) - (unsigned int )((void const   *)offset) ==
                      1U) {
#line 584
                    tmp___189 = __builtin_strcmp(offset, "*");
                  } else {
                    goto _L___56;
                  }
                } else {
                  _L___56: 
#line 584
                  __s1___46 = (unsigned char const   *)((char const   *)offset);
#line 584
                  __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
#line 584
                  if (__s2_len___1 > 0U) {
#line 584
                    if (__result___70 == 0) {
#line 584
                      __result___70 = (int )((int const   )(*(__s1___46 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
#line 584
                      if (__s2_len___1 > 1U) {
#line 584
                        if (__result___70 == 0) {
#line 584
                          __result___70 = (int )((int const   )(*(__s1___46 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
#line 584
                          if (__s2_len___1 > 2U) {
#line 584
                            if (__result___70 == 0) {
#line 584
                              __result___70 = (int )((int const   )(*(__s1___46 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 584
                  tmp___189 = __result___70;
                }
              } else {
#line 584
                tmp___189 = __builtin_strcmp(offset, "*");
              }
            } else {
#line 584
              tmp___189 = __builtin_strcmp(offset, "*");
            }
          } else {
#line 584
            tmp___189 = __builtin_strcmp(offset, "*");
          }
        }
      }
#line 584
      if (! tmp___189) {
#line 585
        free((void *)offset);
#line 586
        offset = (char *)((void *)0);
      }
    } else {
#line 581
      free((void *)virname);
#line 582
      ret = -5;
#line 583
      break;
    }
#line 589
    sig = cli_strtok((char const   *)(buffer), 3, ":");
#line 589
    if (! sig) {
#line 590
      free((void *)virname);
#line 591
      free((void *)offset);
#line 592
      ret = -5;
#line 593
      break;
    }
#line 596
    ret = cli_parse_add((*root), (char const   *)virname, (char const   *)sig, (unsigned short)0,
                        offset, target);
#line 596
    if (ret) {
#line 597
      cli_errmsg("Problem parsing signature at line %d\n", line);
#line 598
      free((void *)virname);
#line 599
      free((void *)offset);
#line 600
      free((void *)sig);
#line 601
      ret = -5;
#line 602
      break;
    }
#line 605
    free((void *)virname);
#line 606
    free((void *)sig);
  }
#line 609
  if (! line) {
#line 610
    cli_errmsg("Empty database file\n");
#line 611
    cl_free((*root));
#line 612
    return (-5);
  }
#line 615
  if (ret) {
#line 616
    cli_errmsg("Problem parsing database at line %d\n", line);
#line 617
    cl_free((*root));
#line 618
    return (ret);
  }
#line 621
  if (signo) {
#line 622
    (*signo) += (unsigned int )sigs;
  }
#line 624
  return (0);
}
}
#line 627 "readdb.c"
static int cli_loadhdb(FILE *fd , struct cl_node **root , unsigned int *signo , unsigned short fp ) 
{ char buffer[8192] ;
  char *pt ;
  int line ;
  int ret ;
  struct cli_md5_node *new ;
  char *tmp___3 ;

  {
#line 630
  line = 0;
#line 630
  ret = 0;
#line 634
  if (! (*root)) {
#line 635
    cli_dbgmsg("Initializing main node\n");
#line 636
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
#line 637
    if (! (*root)) {
#line 638
      return (-3);
    }
#line 639
    ((*root))->refcount = 1U;
  }
#line 642
  while (1) {
#line 642
    tmp___3 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
#line 642
    if (! tmp___3) {
#line 642
      break;
    }
#line 643
    line ++;
#line 644
    cli_chomp(buffer);
#line 646
    new = (struct cli_md5_node *)cli_calloc(1U, sizeof(struct cli_md5_node ));
#line 647
    if (! new) {
#line 648
      ret = -3;
#line 649
      break;
    }
#line 652
    new->fp = fp;
#line 654
    pt = cli_strtok((char const   *)(buffer), 0, ":");
#line 654
    if (! pt) {
#line 655
      free((void *)new);
#line 656
      ret = -5;
#line 657
      break;
    }
#line 660
    new->md5 = (unsigned char *)cli_hex2str((char const   *)pt);
#line 660
    if (! new->md5) {
#line 661
      cli_errmsg("Malformed MD5 string at line %d\n", line);
#line 662
      free((void *)pt);
#line 663
      free((void *)new);
#line 664
      ret = -5;
#line 665
      break;
    }
#line 667
    free((void *)pt);
#line 669
    pt = cli_strtok((char const   *)(buffer), 1, ":");
#line 669
    if (! pt) {
#line 670
      free((void *)new->md5);
#line 671
      free((void *)new);
#line 672
      ret = -5;
#line 673
      break;
    }
#line 675
    new->size = (unsigned int )atoi__extinline((char const   *)pt);
#line 676
    free((void *)pt);
#line 678
    new->virname = cli_strtok((char const   *)(buffer), 2, ":");
#line 678
    if (! new->virname) {
#line 679
      free((void *)new->md5);
#line 680
      free((void *)new);
#line 681
      ret = -5;
#line 682
      break;
    }
#line 685
    new->viralias = cli_strtok((char const   *)(buffer), 3, ":");
#line 687
    if (! ((*root))->md5_hlist) {
#line 688
      cli_dbgmsg("Initializing md5 list structure\n");
#line 689
      ((*root))->md5_hlist = (struct cli_md5_node **)cli_calloc(256U, sizeof(struct cli_md5_node *));
#line 690
      if (! ((*root))->md5_hlist) {
#line 691
        ret = -3;
#line 692
        break;
      }
    }
#line 696
    new->next = (*(((*root))->md5_hlist + ((int )(*(new->md5 + 0)) & 255)));
#line 697
    (*(((*root))->md5_hlist + ((int )(*(new->md5 + 0)) & 255))) = new;
  }
#line 700
  if (! line) {
#line 701
    cli_errmsg("Empty database file\n");
#line 702
    cl_free((*root));
#line 703
    return (-5);
  }
#line 706
  if (ret) {
#line 707
    cli_errmsg("Problem parsing database at line %d\n", line);
#line 708
    cl_free((*root));
#line 709
    return (ret);
  }
#line 712
  if (signo) {
#line 713
    (*signo) += (unsigned int )line;
  }
#line 715
  return (0);
}
}
#line 718 "readdb.c"
static int cli_loadmd(FILE *fd , struct cl_node **root , unsigned int *signo , int type ) 
{ char buffer[8192] ;
  char *pt ;
  int line ;
  int comments ;
  int ret ;
  struct cli_meta_node *new ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___55 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___105 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___124 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___174 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___193 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___202 ;
  int tmp___203 ;
  int tmp___204 ;
  int tmp___205 ;
  int tmp___206 ;
  int tmp___207 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___243 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___262 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___276 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___312 ;
  unsigned char const   *__s2___38 ;
  register int __result___114 ;
  int tmp___331 ;
  unsigned char const   *__s1___78 ;
  register int __result___118 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___381 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___400 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___414 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___450 ;
  unsigned char const   *__s2___54 ;
  register int __result___162 ;
  int tmp___469 ;
  unsigned char const   *__s1___110 ;
  register int __result___166 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___483 ;
  char *tmp___484 ;

  {
#line 721
  line = 0;
#line 721
  comments = 0;
#line 721
  ret = 0;
#line 725
  if (! (*root)) {
#line 726
    cli_dbgmsg("Initializing main node\n");
#line 727
    (*root) = (struct cl_node *)cli_calloc(1U, sizeof(struct cl_node ));
#line 728
    if (! (*root)) {
#line 729
      return (-3);
    }
#line 730
    ((*root))->refcount = 1U;
  }
#line 733
  while (1) {
#line 733
    tmp___484 = fgets((char * __restrict  )(buffer), 8192, (FILE * __restrict  )fd);
#line 733
    if (! tmp___484) {
#line 733
      break;
    }
#line 734
    line ++;
#line 735
    if ((int )buffer[0] == 35) {
#line 736
      comments ++;
#line 737
      continue;
    }
#line 740
    cli_chomp(buffer);
#line 742
    new = (struct cli_meta_node *)cli_calloc(1U, sizeof(struct cli_meta_node ));
#line 743
    if (! new) {
#line 744
      ret = -3;
#line 745
      break;
    }
#line 748
    new->virname = cli_strtok((char const   *)(buffer), 0, ":");
#line 748
    if (! new->virname) {
#line 749
      free((void *)new);
#line 750
      ret = -5;
#line 751
      break;
    }
#line 754
    pt = cli_strtok((char const   *)(buffer), 1, ":");
#line 754
    if (pt) {
#line 760
      new->encrypted = (unsigned int )atoi__extinline((char const   *)pt);
#line 761
      free((void *)pt);
    } else {
#line 755
      free((void *)new->virname);
#line 756
      free((void *)new);
#line 757
      ret = -5;
#line 758
      break;
    }
#line 764
    new->filename = cli_strtok((char const   *)(buffer), 2, ":");
#line 764
    if (new->filename) {
#line 770
      tmp___67 = __builtin_constant_p((int )new->filename);
#line 770
      if (tmp___67) {
#line 770
        tmp___68 = __builtin_constant_p((int )"*");
#line 770
        if (tmp___68) {
#line 770
          __s1_len = strlen((char const   *)new->filename);
#line 770
          __s2_len = strlen("*");
#line 770
          if (! ((unsigned int )((void const   *)(new->filename + 1)) - (unsigned int )((void const   *)new->filename) ==
                 1U)) {
            goto _L___16;
          } else {
#line 770
            if (__s1_len >= 4U) {
              _L___16: 
#line 770
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 770
                tmp___69 = 1;
              } else {
#line 770
                if (__s2_len >= 4U) {
#line 770
                  tmp___69 = 1;
                } else {
#line 770
                  tmp___69 = 0;
                }
              }
            } else {
#line 770
              tmp___69 = 0;
            }
          }
#line 770
          if (tmp___69) {
#line 770
            tmp___36 = __builtin_strcmp(new->filename, "*");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
#line 770
        tmp___66 = __builtin_constant_p((int )new->filename);
#line 770
        if (tmp___66) {
#line 770
          if ((unsigned int )((void const   *)(new->filename + 1)) - (unsigned int )((void const   *)new->filename) ==
              1U) {
#line 770
            __s1_len = strlen((char const   *)new->filename);
#line 770
            if (__s1_len < 4U) {
#line 770
              tmp___55 = __builtin_constant_p((int )"*");
#line 770
              if (tmp___55) {
#line 770
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 770
                  tmp___36 = __builtin_strcmp(new->filename, "*");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
#line 770
                __s2___6 = (unsigned char const   *)"*";
#line 770
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 770
                if (__s1_len > 0U) {
#line 770
                  if (__result___18 == 0) {
#line 770
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 770
                    if (__s1_len > 1U) {
#line 770
                      if (__result___18 == 0) {
#line 770
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 770
                        if (__s1_len > 2U) {
#line 770
                          if (__result___18 == 0) {
#line 770
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)new->filename) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 770
                tmp___36 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
#line 770
          tmp___65 = __builtin_constant_p((int )"*");
#line 770
          if (tmp___65) {
#line 770
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 770
              __s2_len = strlen("*");
#line 770
              if (__s2_len < 4U) {
#line 770
                tmp___64 = __builtin_constant_p((int )new->filename);
#line 770
                if (tmp___64) {
#line 770
                  if ((unsigned int )((void const   *)(new->filename + 1)) - (unsigned int )((void const   *)new->filename) ==
                      1U) {
#line 770
                    tmp___36 = __builtin_strcmp(new->filename, "*");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
#line 770
                  __s1___14 = (unsigned char const   *)((char const   *)new->filename);
#line 770
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
#line 770
                  if (__s2_len > 0U) {
#line 770
                    if (__result___22 == 0) {
#line 770
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
#line 770
                      if (__s2_len > 1U) {
#line 770
                        if (__result___22 == 0) {
#line 770
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
#line 770
                          if (__s2_len > 2U) {
#line 770
                            if (__result___22 == 0) {
#line 770
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 770
                  tmp___36 = __result___22;
                }
              } else {
#line 770
                tmp___36 = __builtin_strcmp(new->filename, "*");
              }
            } else {
#line 770
              tmp___36 = __builtin_strcmp(new->filename, "*");
            }
          } else {
#line 770
            tmp___36 = __builtin_strcmp(new->filename, "*");
          }
        }
      }
#line 770
      if (! tmp___36) {
#line 771
        free((void *)new->filename);
#line 772
        new->filename = (char *)((void *)0);
      }
    } else {
#line 765
      free((void *)new->virname);
#line 766
      free((void *)new);
#line 767
      ret = -5;
#line 768
      break;
    }
#line 776
    pt = cli_strtok((char const   *)(buffer), 3, ":");
#line 776
    if (pt) {
#line 783
      tmp___136 = __builtin_constant_p((int )pt);
#line 783
      if (tmp___136) {
#line 783
        tmp___137 = __builtin_constant_p((int )"*");
#line 783
        if (tmp___137) {
#line 783
          __s1_len___0 = strlen((char const   *)pt);
#line 783
          __s2_len___0 = strlen("*");
#line 783
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___36;
          } else {
#line 783
            if (__s1_len___0 >= 4U) {
              _L___36: 
#line 783
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 783
                tmp___138 = 1;
              } else {
#line 783
                if (__s2_len___0 >= 4U) {
#line 783
                  tmp___138 = 1;
                } else {
#line 783
                  tmp___138 = 0;
                }
              }
            } else {
#line 783
              tmp___138 = 0;
            }
          }
#line 783
          if (tmp___138) {
#line 783
            tmp___105 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___38;
          }
        } else {
          goto _L___38;
        }
      } else {
        _L___38: 
#line 783
        tmp___135 = __builtin_constant_p((int )pt);
#line 783
        if (tmp___135) {
#line 783
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
#line 783
            __s1_len___0 = strlen((char const   *)pt);
#line 783
            if (__s1_len___0 < 4U) {
#line 783
              tmp___124 = __builtin_constant_p((int )"*");
#line 783
              if (tmp___124) {
#line 783
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 783
                  tmp___105 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___31;
                }
              } else {
                _L___31: 
#line 783
                __s2___14 = (unsigned char const   *)"*";
#line 783
                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                        0)) - (int const   )(*(__s2___14 +
                                                                               0)));
#line 783
                if (__s1_len___0 > 0U) {
#line 783
                  if (__result___42 == 0) {
#line 783
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                            1)) - (int const   )(*(__s2___14 +
                                                                                   1)));
#line 783
                    if (__s1_len___0 > 1U) {
#line 783
                      if (__result___42 == 0) {
#line 783
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                2)) - (int const   )(*(__s2___14 +
                                                                                       2)));
#line 783
                        if (__s1_len___0 > 2U) {
#line 783
                          if (__result___42 == 0) {
#line 783
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    3)) - (int const   )(*(__s2___14 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 783
                tmp___105 = __result___42;
              }
            } else {
              goto _L___35;
            }
          } else {
            goto _L___35;
          }
        } else {
          _L___35: 
#line 783
          tmp___134 = __builtin_constant_p((int )"*");
#line 783
          if (tmp___134) {
#line 783
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 783
              __s2_len___0 = strlen("*");
#line 783
              if (__s2_len___0 < 4U) {
#line 783
                tmp___133 = __builtin_constant_p((int )pt);
#line 783
                if (tmp___133) {
#line 783
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
#line 783
                    tmp___105 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___33;
                  }
                } else {
                  _L___33: 
#line 783
                  __s1___30 = (unsigned char const   *)((char const   *)pt);
#line 783
                  __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
#line 783
                  if (__s2_len___0 > 0U) {
#line 783
                    if (__result___46 == 0) {
#line 783
                      __result___46 = (int )((int const   )(*(__s1___30 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
#line 783
                      if (__s2_len___0 > 1U) {
#line 783
                        if (__result___46 == 0) {
#line 783
                          __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
#line 783
                          if (__s2_len___0 > 2U) {
#line 783
                            if (__result___46 == 0) {
#line 783
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 783
                  tmp___105 = __result___46;
                }
              } else {
#line 783
                tmp___105 = __builtin_strcmp(pt, "*");
              }
            } else {
#line 783
              tmp___105 = __builtin_strcmp(pt, "*");
            }
          } else {
#line 783
            tmp___105 = __builtin_strcmp(pt, "*");
          }
        }
      }
#line 783
      if (tmp___105) {
#line 786
        new->size = atoi__extinline((char const   *)pt);
      } else {
#line 784
        new->size = -1;
      }
#line 787
      free((void *)pt);
    } else {
#line 777
      free((void *)new->filename);
#line 778
      free((void *)new->virname);
#line 779
      free((void *)new);
#line 780
      ret = -5;
#line 781
      break;
    }
#line 790
    pt = cli_strtok((char const   *)(buffer), 4, ":");
#line 790
    if (pt) {
#line 797
      tmp___205 = __builtin_constant_p((int )pt);
#line 797
      if (tmp___205) {
#line 797
        tmp___206 = __builtin_constant_p((int )"*");
#line 797
        if (tmp___206) {
#line 797
          __s1_len___1 = strlen((char const   *)pt);
#line 797
          __s2_len___1 = strlen("*");
#line 797
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___56;
          } else {
#line 797
            if (__s1_len___1 >= 4U) {
              _L___56: 
#line 797
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 797
                tmp___207 = 1;
              } else {
#line 797
                if (__s2_len___1 >= 4U) {
#line 797
                  tmp___207 = 1;
                } else {
#line 797
                  tmp___207 = 0;
                }
              }
            } else {
#line 797
              tmp___207 = 0;
            }
          }
#line 797
          if (tmp___207) {
#line 797
            tmp___174 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___58;
          }
        } else {
          goto _L___58;
        }
      } else {
        _L___58: 
#line 797
        tmp___204 = __builtin_constant_p((int )pt);
#line 797
        if (tmp___204) {
#line 797
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
#line 797
            __s1_len___1 = strlen((char const   *)pt);
#line 797
            if (__s1_len___1 < 4U) {
#line 797
              tmp___193 = __builtin_constant_p((int )"*");
#line 797
              if (tmp___193) {
#line 797
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 797
                  tmp___174 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___51;
                }
              } else {
                _L___51: 
#line 797
                __s2___22 = (unsigned char const   *)"*";
#line 797
                __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                        0)) - (int const   )(*(__s2___22 +
                                                                               0)));
#line 797
                if (__s1_len___1 > 0U) {
#line 797
                  if (__result___66 == 0) {
#line 797
                    __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                            1)) - (int const   )(*(__s2___22 +
                                                                                   1)));
#line 797
                    if (__s1_len___1 > 1U) {
#line 797
                      if (__result___66 == 0) {
#line 797
                        __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                2)) - (int const   )(*(__s2___22 +
                                                                                       2)));
#line 797
                        if (__s1_len___1 > 2U) {
#line 797
                          if (__result___66 == 0) {
#line 797
                            __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    3)) - (int const   )(*(__s2___22 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 797
                tmp___174 = __result___66;
              }
            } else {
              goto _L___55;
            }
          } else {
            goto _L___55;
          }
        } else {
          _L___55: 
#line 797
          tmp___203 = __builtin_constant_p((int )"*");
#line 797
          if (tmp___203) {
#line 797
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 797
              __s2_len___1 = strlen("*");
#line 797
              if (__s2_len___1 < 4U) {
#line 797
                tmp___202 = __builtin_constant_p((int )pt);
#line 797
                if (tmp___202) {
#line 797
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
#line 797
                    tmp___174 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___53;
                  }
                } else {
                  _L___53: 
#line 797
                  __s1___46 = (unsigned char const   *)((char const   *)pt);
#line 797
                  __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
#line 797
                  if (__s2_len___1 > 0U) {
#line 797
                    if (__result___70 == 0) {
#line 797
                      __result___70 = (int )((int const   )(*(__s1___46 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
#line 797
                      if (__s2_len___1 > 1U) {
#line 797
                        if (__result___70 == 0) {
#line 797
                          __result___70 = (int )((int const   )(*(__s1___46 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
#line 797
                          if (__s2_len___1 > 2U) {
#line 797
                            if (__result___70 == 0) {
#line 797
                              __result___70 = (int )((int const   )(*(__s1___46 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 797
                  tmp___174 = __result___70;
                }
              } else {
#line 797
                tmp___174 = __builtin_strcmp(pt, "*");
              }
            } else {
#line 797
              tmp___174 = __builtin_strcmp(pt, "*");
            }
          } else {
#line 797
            tmp___174 = __builtin_strcmp(pt, "*");
          }
        }
      }
#line 797
      if (tmp___174) {
#line 800
        new->csize = atoi__extinline((char const   *)pt);
      } else {
#line 798
        new->csize = -1;
      }
#line 801
      free((void *)pt);
    } else {
#line 791
      free((void *)new->filename);
#line 792
      free((void *)new->virname);
#line 793
      free((void *)new);
#line 794
      ret = -5;
#line 795
      break;
    }
#line 804
    pt = cli_strtok((char const   *)(buffer), 5, ":");
#line 804
    if (pt) {
#line 811
      tmp___274 = __builtin_constant_p((int )pt);
#line 811
      if (tmp___274) {
#line 811
        tmp___275 = __builtin_constant_p((int )"*");
#line 811
        if (tmp___275) {
#line 811
          __s1_len___2 = strlen((char const   *)pt);
#line 811
          __s2_len___2 = strlen("*");
#line 811
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___76;
          } else {
#line 811
            if (__s1_len___2 >= 4U) {
              _L___76: 
#line 811
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 811
                tmp___276 = 1;
              } else {
#line 811
                if (__s2_len___2 >= 4U) {
#line 811
                  tmp___276 = 1;
                } else {
#line 811
                  tmp___276 = 0;
                }
              }
            } else {
#line 811
              tmp___276 = 0;
            }
          }
#line 811
          if (tmp___276) {
#line 811
            tmp___243 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___78;
          }
        } else {
          goto _L___78;
        }
      } else {
        _L___78: 
#line 811
        tmp___273 = __builtin_constant_p((int )pt);
#line 811
        if (tmp___273) {
#line 811
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
#line 811
            __s1_len___2 = strlen((char const   *)pt);
#line 811
            if (__s1_len___2 < 4U) {
#line 811
              tmp___262 = __builtin_constant_p((int )"*");
#line 811
              if (tmp___262) {
#line 811
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 811
                  tmp___243 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___71;
                }
              } else {
                _L___71: 
#line 811
                __s2___30 = (unsigned char const   *)"*";
#line 811
                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                        0)) - (int const   )(*(__s2___30 +
                                                                               0)));
#line 811
                if (__s1_len___2 > 0U) {
#line 811
                  if (__result___90 == 0) {
#line 811
                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                            1)) - (int const   )(*(__s2___30 +
                                                                                   1)));
#line 811
                    if (__s1_len___2 > 1U) {
#line 811
                      if (__result___90 == 0) {
#line 811
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                2)) - (int const   )(*(__s2___30 +
                                                                                       2)));
#line 811
                        if (__s1_len___2 > 2U) {
#line 811
                          if (__result___90 == 0) {
#line 811
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                    3)) - (int const   )(*(__s2___30 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 811
                tmp___243 = __result___90;
              }
            } else {
              goto _L___75;
            }
          } else {
            goto _L___75;
          }
        } else {
          _L___75: 
#line 811
          tmp___272 = __builtin_constant_p((int )"*");
#line 811
          if (tmp___272) {
#line 811
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 811
              __s2_len___2 = strlen("*");
#line 811
              if (__s2_len___2 < 4U) {
#line 811
                tmp___271 = __builtin_constant_p((int )pt);
#line 811
                if (tmp___271) {
#line 811
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
#line 811
                    tmp___243 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___73;
                  }
                } else {
                  _L___73: 
#line 811
                  __s1___62 = (unsigned char const   *)((char const   *)pt);
#line 811
                  __result___94 = (int )((int const   )(*(__s1___62 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             0)));
#line 811
                  if (__s2_len___2 > 0U) {
#line 811
                    if (__result___94 == 0) {
#line 811
                      __result___94 = (int )((int const   )(*(__s1___62 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                 1)));
#line 811
                      if (__s2_len___2 > 1U) {
#line 811
                        if (__result___94 == 0) {
#line 811
                          __result___94 = (int )((int const   )(*(__s1___62 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"*" +
                                                                  2)));
#line 811
                          if (__s2_len___2 > 2U) {
#line 811
                            if (__result___94 == 0) {
#line 811
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 811
                  tmp___243 = __result___94;
                }
              } else {
#line 811
                tmp___243 = __builtin_strcmp(pt, "*");
              }
            } else {
#line 811
              tmp___243 = __builtin_strcmp(pt, "*");
            }
          } else {
#line 811
            tmp___243 = __builtin_strcmp(pt, "*");
          }
        }
      }
#line 811
      if (tmp___243) {
#line 814
        new->crc32 = (unsigned int )cli_hex2num((char const   *)pt);
#line 815
        if (new->crc32 == 4294967295U) {
#line 816
          ret = -5;
#line 817
          break;
        }
      } else {
#line 812
        new->crc32 = 0U;
      }
#line 820
      free((void *)pt);
    } else {
#line 805
      free((void *)new->filename);
#line 806
      free((void *)new->virname);
#line 807
      free((void *)new);
#line 808
      ret = -5;
#line 809
      break;
    }
#line 823
    pt = cli_strtok((char const   *)(buffer), 6, ":");
#line 823
    if (pt) {
#line 830
      tmp___343 = __builtin_constant_p((int )pt);
#line 830
      if (tmp___343) {
#line 830
        tmp___344 = __builtin_constant_p((int )"*");
#line 830
        if (tmp___344) {
#line 830
          __s1_len___3 = strlen((char const   *)pt);
#line 830
          __s2_len___3 = strlen("*");
#line 830
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___96;
          } else {
#line 830
            if (__s1_len___3 >= 4U) {
              _L___96: 
#line 830
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 830
                tmp___345 = 1;
              } else {
#line 830
                if (__s2_len___3 >= 4U) {
#line 830
                  tmp___345 = 1;
                } else {
#line 830
                  tmp___345 = 0;
                }
              }
            } else {
#line 830
              tmp___345 = 0;
            }
          }
#line 830
          if (tmp___345) {
#line 830
            tmp___312 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___98;
          }
        } else {
          goto _L___98;
        }
      } else {
        _L___98: 
#line 830
        tmp___342 = __builtin_constant_p((int )pt);
#line 830
        if (tmp___342) {
#line 830
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
#line 830
            __s1_len___3 = strlen((char const   *)pt);
#line 830
            if (__s1_len___3 < 4U) {
#line 830
              tmp___331 = __builtin_constant_p((int )"*");
#line 830
              if (tmp___331) {
#line 830
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 830
                  tmp___312 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___91;
                }
              } else {
                _L___91: 
#line 830
                __s2___38 = (unsigned char const   *)"*";
#line 830
                __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                         0)) - (int const   )(*(__s2___38 +
                                                                                0)));
#line 830
                if (__s1_len___3 > 0U) {
#line 830
                  if (__result___114 == 0) {
#line 830
                    __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                             1)) - (int const   )(*(__s2___38 +
                                                                                    1)));
#line 830
                    if (__s1_len___3 > 1U) {
#line 830
                      if (__result___114 == 0) {
#line 830
                        __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                 2)) - (int const   )(*(__s2___38 +
                                                                                        2)));
#line 830
                        if (__s1_len___3 > 2U) {
#line 830
                          if (__result___114 == 0) {
#line 830
                            __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                     3)) - (int const   )(*(__s2___38 +
                                                                                            3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 830
                tmp___312 = __result___114;
              }
            } else {
              goto _L___95;
            }
          } else {
            goto _L___95;
          }
        } else {
          _L___95: 
#line 830
          tmp___341 = __builtin_constant_p((int )"*");
#line 830
          if (tmp___341) {
#line 830
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 830
              __s2_len___3 = strlen("*");
#line 830
              if (__s2_len___3 < 4U) {
#line 830
                tmp___340 = __builtin_constant_p((int )pt);
#line 830
                if (tmp___340) {
#line 830
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
#line 830
                    tmp___312 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___93;
                  }
                } else {
                  _L___93: 
#line 830
                  __s1___78 = (unsigned char const   *)((char const   *)pt);
#line 830
                  __result___118 = (int )((int const   )(*(__s1___78 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              0)));
#line 830
                  if (__s2_len___3 > 0U) {
#line 830
                    if (__result___118 == 0) {
#line 830
                      __result___118 = (int )((int const   )(*(__s1___78 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                  1)));
#line 830
                      if (__s2_len___3 > 1U) {
#line 830
                        if (__result___118 == 0) {
#line 830
                          __result___118 = (int )((int const   )(*(__s1___78 + 2)) -
                                                  (int const   )(*((unsigned char const   *)"*" +
                                                                   2)));
#line 830
                          if (__s2_len___3 > 2U) {
#line 830
                            if (__result___118 == 0) {
#line 830
                              __result___118 = (int )((int const   )(*(__s1___78 +
                                                                       3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 830
                  tmp___312 = __result___118;
                }
              } else {
#line 830
                tmp___312 = __builtin_strcmp(pt, "*");
              }
            } else {
#line 830
              tmp___312 = __builtin_strcmp(pt, "*");
            }
          } else {
#line 830
            tmp___312 = __builtin_strcmp(pt, "*");
          }
        }
      }
#line 830
      if (tmp___312) {
#line 833
        new->method = atoi__extinline((char const   *)pt);
      } else {
#line 831
        new->method = -1;
      }
#line 834
      free((void *)pt);
    } else {
#line 824
      free((void *)new->filename);
#line 825
      free((void *)new->virname);
#line 826
      free((void *)new);
#line 827
      ret = -5;
#line 828
      break;
    }
#line 837
    pt = cli_strtok((char const   *)(buffer), 7, ":");
#line 837
    if (pt) {
#line 844
      tmp___412 = __builtin_constant_p((int )pt);
#line 844
      if (tmp___412) {
#line 844
        tmp___413 = __builtin_constant_p((int )"*");
#line 844
        if (tmp___413) {
#line 844
          __s1_len___4 = strlen((char const   *)pt);
#line 844
          __s2_len___4 = strlen("*");
#line 844
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___116;
          } else {
#line 844
            if (__s1_len___4 >= 4U) {
              _L___116: 
#line 844
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 844
                tmp___414 = 1;
              } else {
#line 844
                if (__s2_len___4 >= 4U) {
#line 844
                  tmp___414 = 1;
                } else {
#line 844
                  tmp___414 = 0;
                }
              }
            } else {
#line 844
              tmp___414 = 0;
            }
          }
#line 844
          if (tmp___414) {
#line 844
            tmp___381 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___118;
          }
        } else {
          goto _L___118;
        }
      } else {
        _L___118: 
#line 844
        tmp___411 = __builtin_constant_p((int )pt);
#line 844
        if (tmp___411) {
#line 844
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
#line 844
            __s1_len___4 = strlen((char const   *)pt);
#line 844
            if (__s1_len___4 < 4U) {
#line 844
              tmp___400 = __builtin_constant_p((int )"*");
#line 844
              if (tmp___400) {
#line 844
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 844
                  tmp___381 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___111;
                }
              } else {
                _L___111: 
#line 844
                __s2___46 = (unsigned char const   *)"*";
#line 844
                __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                         0)) - (int const   )(*(__s2___46 +
                                                                                0)));
#line 844
                if (__s1_len___4 > 0U) {
#line 844
                  if (__result___138 == 0) {
#line 844
                    __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                             1)) - (int const   )(*(__s2___46 +
                                                                                    1)));
#line 844
                    if (__s1_len___4 > 1U) {
#line 844
                      if (__result___138 == 0) {
#line 844
                        __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                 2)) - (int const   )(*(__s2___46 +
                                                                                        2)));
#line 844
                        if (__s1_len___4 > 2U) {
#line 844
                          if (__result___138 == 0) {
#line 844
                            __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                     3)) - (int const   )(*(__s2___46 +
                                                                                            3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 844
                tmp___381 = __result___138;
              }
            } else {
              goto _L___115;
            }
          } else {
            goto _L___115;
          }
        } else {
          _L___115: 
#line 844
          tmp___410 = __builtin_constant_p((int )"*");
#line 844
          if (tmp___410) {
#line 844
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 844
              __s2_len___4 = strlen("*");
#line 844
              if (__s2_len___4 < 4U) {
#line 844
                tmp___409 = __builtin_constant_p((int )pt);
#line 844
                if (tmp___409) {
#line 844
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
#line 844
                    tmp___381 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___113;
                  }
                } else {
                  _L___113: 
#line 844
                  __s1___94 = (unsigned char const   *)((char const   *)pt);
#line 844
                  __result___142 = (int )((int const   )(*(__s1___94 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              0)));
#line 844
                  if (__s2_len___4 > 0U) {
#line 844
                    if (__result___142 == 0) {
#line 844
                      __result___142 = (int )((int const   )(*(__s1___94 + 1)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                                  1)));
#line 844
                      if (__s2_len___4 > 1U) {
#line 844
                        if (__result___142 == 0) {
#line 844
                          __result___142 = (int )((int const   )(*(__s1___94 + 2)) -
                                                  (int const   )(*((unsigned char const   *)"*" +
                                                                   2)));
#line 844
                          if (__s2_len___4 > 2U) {
#line 844
                            if (__result___142 == 0) {
#line 844
                              __result___142 = (int )((int const   )(*(__s1___94 +
                                                                       3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 844
                  tmp___381 = __result___142;
                }
              } else {
#line 844
                tmp___381 = __builtin_strcmp(pt, "*");
              }
            } else {
#line 844
              tmp___381 = __builtin_strcmp(pt, "*");
            }
          } else {
#line 844
            tmp___381 = __builtin_strcmp(pt, "*");
          }
        }
      }
#line 844
      if (tmp___381) {
#line 847
        new->fileno = (unsigned int )atoi__extinline((char const   *)pt);
      } else {
#line 845
        new->fileno = 0U;
      }
#line 848
      free((void *)pt);
    } else {
#line 838
      free((void *)new->filename);
#line 839
      free((void *)new->virname);
#line 840
      free((void *)new);
#line 841
      ret = -5;
#line 842
      break;
    }
#line 851
    pt = cli_strtok((char const   *)(buffer), 8, ":");
#line 851
    if (pt) {
#line 858
      tmp___481 = __builtin_constant_p((int )pt);
#line 858
      if (tmp___481) {
#line 858
        tmp___482 = __builtin_constant_p((int )"*");
#line 858
        if (tmp___482) {
#line 858
          __s1_len___5 = strlen((char const   *)pt);
#line 858
          __s2_len___5 = strlen("*");
#line 858
          if (! ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                 1U)) {
            goto _L___136;
          } else {
#line 858
            if (__s1_len___5 >= 4U) {
              _L___136: 
#line 858
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                     1U)) {
#line 858
                tmp___483 = 1;
              } else {
#line 858
                if (__s2_len___5 >= 4U) {
#line 858
                  tmp___483 = 1;
                } else {
#line 858
                  tmp___483 = 0;
                }
              }
            } else {
#line 858
              tmp___483 = 0;
            }
          }
#line 858
          if (tmp___483) {
#line 858
            tmp___450 = __builtin_strcmp(pt, "*");
          } else {
            goto _L___138;
          }
        } else {
          goto _L___138;
        }
      } else {
        _L___138: 
#line 858
        tmp___480 = __builtin_constant_p((int )pt);
#line 858
        if (tmp___480) {
#line 858
          if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
              1U) {
#line 858
            __s1_len___5 = strlen((char const   *)pt);
#line 858
            if (__s1_len___5 < 4U) {
#line 858
              tmp___469 = __builtin_constant_p((int )"*");
#line 858
              if (tmp___469) {
#line 858
                if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                    1U) {
#line 858
                  tmp___450 = __builtin_strcmp(pt, "*");
                } else {
                  goto _L___131;
                }
              } else {
                _L___131: 
#line 858
                __s2___54 = (unsigned char const   *)"*";
#line 858
                __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                         0)) - (int const   )(*(__s2___54 +
                                                                                0)));
#line 858
                if (__s1_len___5 > 0U) {
#line 858
                  if (__result___162 == 0) {
#line 858
                    __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                             1)) - (int const   )(*(__s2___54 +
                                                                                    1)));
#line 858
                    if (__s1_len___5 > 1U) {
#line 858
                      if (__result___162 == 0) {
#line 858
                        __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                 2)) - (int const   )(*(__s2___54 +
                                                                                        2)));
#line 858
                        if (__s1_len___5 > 2U) {
#line 858
                          if (__result___162 == 0) {
#line 858
                            __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)pt) +
                                                                     3)) - (int const   )(*(__s2___54 +
                                                                                            3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 858
                tmp___450 = __result___162;
              }
            } else {
              goto _L___135;
            }
          } else {
            goto _L___135;
          }
        } else {
          _L___135: 
#line 858
          tmp___479 = __builtin_constant_p((int )"*");
#line 858
          if (tmp___479) {
#line 858
            if ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") ==
                1U) {
#line 858
              __s2_len___5 = strlen("*");
#line 858
              if (__s2_len___5 < 4U) {
#line 858
                tmp___478 = __builtin_constant_p((int )pt);
#line 858
                if (tmp___478) {
#line 858
                  if ((unsigned int )((void const   *)(pt + 1)) - (unsigned int )((void const   *)pt) ==
                      1U) {
#line 858
                    tmp___450 = __builtin_strcmp(pt, "*");
                  } else {
                    goto _L___133;
                  }
                } else {
                  _L___133: 
#line 858
                  __s1___110 = (unsigned char const   *)((char const   *)pt);
#line 858
                  __result___166 = (int )((int const   )(*(__s1___110 + 0)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                               0)));
#line 858
                  if (__s2_len___5 > 0U) {
#line 858
                    if (__result___166 == 0) {
#line 858
                      __result___166 = (int )((int const   )(*(__s1___110 + 1)) -
                                              (int const   )(*((unsigned char const   *)"*" +
                                                               1)));
#line 858
                      if (__s2_len___5 > 1U) {
#line 858
                        if (__result___166 == 0) {
#line 858
                          __result___166 = (int )((int const   )(*(__s1___110 + 2)) -
                                                  (int const   )(*((unsigned char const   *)"*" +
                                                                   2)));
#line 858
                          if (__s2_len___5 > 2U) {
#line 858
                            if (__result___166 == 0) {
#line 858
                              __result___166 = (int )((int const   )(*(__s1___110 +
                                                                       3)) - (int const   )(*((unsigned char const   *)"*" +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 858
                  tmp___450 = __result___166;
                }
              } else {
#line 858
                tmp___450 = __builtin_strcmp(pt, "*");
              }
            } else {
#line 858
              tmp___450 = __builtin_strcmp(pt, "*");
            }
          } else {
#line 858
            tmp___450 = __builtin_strcmp(pt, "*");
          }
        }
      }
#line 858
      if (tmp___450) {
#line 861
        new->maxdepth = (unsigned int )atoi__extinline((char const   *)pt);
      } else {
#line 859
        new->maxdepth = 0U;
      }
#line 862
      free((void *)pt);
    } else {
#line 852
      free((void *)new->filename);
#line 853
      free((void *)new->virname);
#line 854
      free((void *)new);
#line 855
      ret = -5;
#line 856
      break;
    }
#line 865
    if (type == 1) {
#line 866
      new->next = ((*root))->zip_mlist;
#line 867
      ((*root))->zip_mlist = new;
    } else {
#line 869
      new->next = ((*root))->rar_mlist;
#line 870
      ((*root))->rar_mlist = new;
    }
  }
#line 874
  if (! line) {
#line 875
    cli_errmsg("Empty database file\n");
#line 876
    cl_free((*root));
#line 877
    return (-5);
  }
#line 880
  if (ret) {
#line 881
    cli_errmsg("Problem parsing database at line %d\n", line);
#line 882
    cl_free((*root));
#line 883
    return (ret);
  }
#line 886
  if (signo) {
#line 887
    (*signo) += (unsigned int )(line - comments);
  }
#line 889
  return (0);
}
}
#line 892 "readdb.c"
int cl_loaddb(char const   *filename , struct cl_node **root , unsigned int *signo ) 
{ FILE *fd ;
  int ret ;
  int warn ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  char const   *tmp___77 ;

  {
#line 898
  fd = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 898
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
#line 899
    cli_errmsg("cl_loaddb(): Can\'t open file %s\n", filename);
#line 900
    return (-4);
  }
#line 903
  cli_dbgmsg("Loading %s\n", filename);
#line 905
  tmp___74 = cli_strbcasestr(filename, ".db");
#line 905
  if (tmp___74) {
#line 906
    ret = cli_loaddb(fd, root, signo);
  } else {
#line 905
    tmp___75 = cli_strbcasestr(filename, ".db2");
#line 905
    if (tmp___75) {
#line 906
      ret = cli_loaddb(fd, root, signo);
    } else {
#line 905
      tmp___76 = cli_strbcasestr(filename, ".db3");
#line 905
      if (tmp___76) {
#line 906
        ret = cli_loaddb(fd, root, signo);
      } else {
#line 908
        tmp___73 = cli_strbcasestr(filename, ".cvd");
#line 908
        if (tmp___73) {
#line 909
          warn = 0;
#line 911
          tmp___65 = __builtin_constant_p((int )filename);
#line 911
          if (tmp___65) {
#line 911
            tmp___66 = __builtin_constant_p((int )"daily.cvd");
#line 911
            if (tmp___66) {
#line 911
              __s1_len = strlen(filename);
#line 911
              __s2_len = strlen("daily.cvd");
#line 911
              if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
                     1U)) {
                goto _L___16;
              } else {
#line 911
                if (__s1_len >= 4U) {
                  _L___16: 
#line 911
                  if (! ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                         1U)) {
#line 911
                    tmp___67 = 1;
                  } else {
#line 911
                    if (__s2_len >= 4U) {
#line 911
                      tmp___67 = 1;
                    } else {
#line 911
                      tmp___67 = 0;
                    }
                  }
                } else {
#line 911
                  tmp___67 = 0;
                }
              }
#line 911
              if (tmp___67) {
#line 911
                tmp___34 = __builtin_strcmp(filename, "daily.cvd");
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
#line 911
            tmp___64 = __builtin_constant_p((int )filename);
#line 911
            if (tmp___64) {
#line 911
              if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
                  1U) {
#line 911
                __s1_len = strlen(filename);
#line 911
                if (__s1_len < 4U) {
#line 911
                  tmp___53 = __builtin_constant_p((int )"daily.cvd");
#line 911
                  if (tmp___53) {
#line 911
                    if ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                        1U) {
#line 911
                      tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
#line 911
                    __s2___6 = (unsigned char const   *)"daily.cvd";
#line 911
                    __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
#line 911
                    if (__s1_len > 0U) {
#line 911
                      if (__result___18 == 0) {
#line 911
                        __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
#line 911
                        if (__s1_len > 1U) {
#line 911
                          if (__result___18 == 0) {
#line 911
                            __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
#line 911
                            if (__s1_len > 2U) {
#line 911
                              if (__result___18 == 0) {
#line 911
                                __result___18 = (int )((int const   )(*((unsigned char const   *)filename +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 911
                    tmp___34 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
#line 911
              tmp___63 = __builtin_constant_p((int )"daily.cvd");
#line 911
              if (tmp___63) {
#line 911
                if ((unsigned int )((void const   *)("daily.cvd" + 1)) - (unsigned int )((void const   *)"daily.cvd") ==
                    1U) {
#line 911
                  __s2_len = strlen("daily.cvd");
#line 911
                  if (__s2_len < 4U) {
#line 911
                    tmp___62 = __builtin_constant_p((int )filename);
#line 911
                    if (tmp___62) {
#line 911
                      if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
                          1U) {
#line 911
                        tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
#line 911
                      __s1___14 = (unsigned char const   *)filename;
#line 911
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                                 0)));
#line 911
                      if (__s2_len > 0U) {
#line 911
                        if (__result___22 == 0) {
#line 911
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                  1)));
#line 911
                          if (__s2_len > 1U) {
#line 911
                            if (__result___22 == 0) {
#line 911
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                             2)));
#line 911
                              if (__s2_len > 2U) {
#line 911
                                if (__result___22 == 0) {
#line 911
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"daily.cvd" +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 911
                      tmp___34 = __result___22;
                    }
                  } else {
#line 911
                    tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                  }
                } else {
#line 911
                  tmp___34 = __builtin_strcmp(filename, "daily.cvd");
                }
              } else {
#line 911
                tmp___34 = __builtin_strcmp(filename, "daily.cvd");
              }
            }
          }
#line 911
          if (! tmp___34) {
#line 912
            warn = 1;
          }
#line 914
          ret = cli_cvdload(fd, root, signo, (short )warn);
        } else {
#line 916
          tmp___72 = cli_strbcasestr(filename, ".hdb");
#line 916
          if (tmp___72) {
#line 917
            ret = cli_loadhdb(fd, root, signo, (unsigned short)0);
          } else {
#line 919
            tmp___71 = cli_strbcasestr(filename, ".fp");
#line 919
            if (tmp___71) {
#line 920
              ret = cli_loadhdb(fd, root, signo, (unsigned short)1);
            } else {
#line 922
              tmp___70 = cli_strbcasestr(filename, ".ndb");
#line 922
              if (tmp___70) {
#line 923
                ret = cli_loadndb(fd, root, signo);
              } else {
#line 925
                tmp___69 = cli_strbcasestr(filename, ".zmd");
#line 925
                if (tmp___69) {
#line 926
                  ret = cli_loadmd(fd, root, signo, 1);
                } else {
#line 928
                  tmp___68 = cli_strbcasestr(filename, ".rmd");
#line 928
                  if (tmp___68) {
#line 929
                    ret = cli_loadmd(fd, root, signo, 2);
                  } else {
#line 932
                    cli_dbgmsg("cl_loaddb: unknown extension - assuming old database format\n");
#line 933
                    ret = cli_loaddb(fd, root, signo);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 936
  if (ret) {
#line 937
    tmp___77 = cl_strerror(ret);
#line 937
    cli_errmsg("Can\'t load %s: %s\n", filename, tmp___77);
  }
#line 939
  fclose(fd);
#line 940
  return (ret);
}
}
#line 943 "readdb.c"
int cl_loaddbdir(char const   *dirname , struct cl_node **root , unsigned int *signo ) 
{ DIR *dd ;
  struct dirent *dent ;
  char *dbfile ;
  int ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___106 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___125 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;

  {
#line 957
  dd = opendir(dirname);
#line 957
  if ((unsigned int )dd == (unsigned int )((void *)0)) {
#line 958
    cli_errmsg("cl_loaddbdir(): Can\'t open directory %s\n", dirname);
#line 959
    return (-4);
  }
#line 962
  cli_dbgmsg("Loading databases from %s\n", dirname);
#line 969
  while (1) {
#line 969
    dent = readdir(dd);
#line 969
    if (! dent) {
#line 969
      break;
    }
#line 972
    if (dent->d_ino) {
#line 975
      tmp___68 = __builtin_constant_p((int )(dent->d_name));
#line 975
      if (tmp___68) {
#line 975
        tmp___69 = __builtin_constant_p((int )".");
#line 975
        if (tmp___69) {
#line 975
          __s1_len = strlen((char const   *)(dent->d_name));
#line 975
          __s2_len = strlen(".");
#line 975
          if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                 1U)) {
            goto _L___16;
          } else {
#line 975
            if (__s1_len >= 4U) {
              _L___16: 
#line 975
              if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                     1U)) {
#line 975
                tmp___70 = 1;
              } else {
#line 975
                if (__s2_len >= 4U) {
#line 975
                  tmp___70 = 1;
                } else {
#line 975
                  tmp___70 = 0;
                }
              }
            } else {
#line 975
              tmp___70 = 0;
            }
          }
#line 975
          if (tmp___70) {
#line 975
            tmp___37 = __builtin_strcmp(dent->d_name, ".");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
#line 975
        tmp___67 = __builtin_constant_p((int )(dent->d_name));
#line 975
        if (tmp___67) {
#line 975
          if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
              1U) {
#line 975
            __s1_len = strlen((char const   *)(dent->d_name));
#line 975
            if (__s1_len < 4U) {
#line 975
              tmp___56 = __builtin_constant_p((int )".");
#line 975
              if (tmp___56) {
#line 975
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
#line 975
                  tmp___37 = __builtin_strcmp(dent->d_name, ".");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
#line 975
                __s2___6 = (unsigned char const   *)".";
#line 975
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 975
                if (__s1_len > 0U) {
#line 975
                  if (__result___18 == 0) {
#line 975
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 975
                    if (__s1_len > 1U) {
#line 975
                      if (__result___18 == 0) {
#line 975
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 975
                        if (__s1_len > 2U) {
#line 975
                          if (__result___18 == 0) {
#line 975
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 975
                tmp___37 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
#line 975
          tmp___66 = __builtin_constant_p((int )".");
#line 975
          if (tmp___66) {
#line 975
            if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                1U) {
#line 975
              __s2_len = strlen(".");
#line 975
              if (__s2_len < 4U) {
#line 975
                tmp___65 = __builtin_constant_p((int )(dent->d_name));
#line 975
                if (tmp___65) {
#line 975
                  if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                      1U) {
#line 975
                    tmp___37 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
#line 975
                  __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 975
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             0)));
#line 975
                  if (__s2_len > 0U) {
#line 975
                    if (__result___22 == 0) {
#line 975
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 1)));
#line 975
                      if (__s2_len > 1U) {
#line 975
                        if (__result___22 == 0) {
#line 975
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  2)));
#line 975
                          if (__s2_len > 2U) {
#line 975
                            if (__result___22 == 0) {
#line 975
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 975
                  tmp___37 = __result___22;
                }
              } else {
#line 975
                tmp___37 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
#line 975
              tmp___37 = __builtin_strcmp(dent->d_name, ".");
            }
          } else {
#line 975
            tmp___37 = __builtin_strcmp(dent->d_name, ".");
          }
        }
      }
#line 975
      if (tmp___37) {
#line 975
        tmp___137 = __builtin_constant_p((int )(dent->d_name));
#line 975
        if (tmp___137) {
#line 975
          tmp___138 = __builtin_constant_p((int )"..");
#line 975
          if (tmp___138) {
#line 975
            __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 975
            __s2_len___0 = strlen("..");
#line 975
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___36;
            } else {
#line 975
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 975
                if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                       1U)) {
#line 975
                  tmp___139 = 1;
                } else {
#line 975
                  if (__s2_len___0 >= 4U) {
#line 975
                    tmp___139 = 1;
                  } else {
#line 975
                    tmp___139 = 0;
                  }
                }
              } else {
#line 975
                tmp___139 = 0;
              }
            }
#line 975
            if (tmp___139) {
#line 975
              tmp___106 = __builtin_strcmp(dent->d_name, "..");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 975
          tmp___136 = __builtin_constant_p((int )(dent->d_name));
#line 975
          if (tmp___136) {
#line 975
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
#line 975
              __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 975
              if (__s1_len___0 < 4U) {
#line 975
                tmp___125 = __builtin_constant_p((int )"..");
#line 975
                if (tmp___125) {
#line 975
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
#line 975
                    tmp___106 = __builtin_strcmp(dent->d_name, "..");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 975
                  __s2___14 = (unsigned char const   *)"..";
#line 975
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 975
                  if (__s1_len___0 > 0U) {
#line 975
                    if (__result___42 == 0) {
#line 975
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 975
                      if (__s1_len___0 > 1U) {
#line 975
                        if (__result___42 == 0) {
#line 975
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 975
                          if (__s1_len___0 > 2U) {
#line 975
                            if (__result___42 == 0) {
#line 975
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 975
                  tmp___106 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 975
            tmp___135 = __builtin_constant_p((int )"..");
#line 975
            if (tmp___135) {
#line 975
              if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                  1U) {
#line 975
                __s2_len___0 = strlen("..");
#line 975
                if (__s2_len___0 < 4U) {
#line 975
                  tmp___134 = __builtin_constant_p((int )(dent->d_name));
#line 975
                  if (tmp___134) {
#line 975
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
#line 975
                      tmp___106 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 975
                    __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 975
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               0)));
#line 975
                    if (__s2_len___0 > 0U) {
#line 975
                      if (__result___46 == 0) {
#line 975
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                1)));
#line 975
                        if (__s2_len___0 > 1U) {
#line 975
                          if (__result___46 == 0) {
#line 975
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    2)));
#line 975
                            if (__s2_len___0 > 2U) {
#line 975
                              if (__result___46 == 0) {
#line 975
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 975
                    tmp___106 = __result___46;
                  }
                } else {
#line 975
                  tmp___106 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
#line 975
                tmp___106 = __builtin_strcmp(dent->d_name, "..");
              }
            } else {
#line 975
              tmp___106 = __builtin_strcmp(dent->d_name, "..");
            }
          }
        }
#line 975
        if (tmp___106) {
#line 975
          tmp___140 = cli_strbcasestr((char const   *)(dent->d_name), ".db");
#line 975
          if (tmp___140) {
            goto _L___39;
          } else {
#line 975
            tmp___141 = cli_strbcasestr((char const   *)(dent->d_name), ".db2");
#line 975
            if (tmp___141) {
              goto _L___39;
            } else {
#line 975
              tmp___142 = cli_strbcasestr((char const   *)(dent->d_name), ".db3");
#line 975
              if (tmp___142) {
                goto _L___39;
              } else {
#line 975
                tmp___143 = cli_strbcasestr((char const   *)(dent->d_name), ".hdb");
#line 975
                if (tmp___143) {
                  goto _L___39;
                } else {
#line 975
                  tmp___144 = cli_strbcasestr((char const   *)(dent->d_name), ".fp");
#line 975
                  if (tmp___144) {
                    goto _L___39;
                  } else {
#line 975
                    tmp___145 = cli_strbcasestr((char const   *)(dent->d_name), ".ndb");
#line 975
                    if (tmp___145) {
                      goto _L___39;
                    } else {
#line 975
                      tmp___146 = cli_strbcasestr((char const   *)(dent->d_name),
                                                  ".zmd");
#line 975
                      if (tmp___146) {
                        goto _L___39;
                      } else {
#line 975
                        tmp___147 = cli_strbcasestr((char const   *)(dent->d_name),
                                                    ".rmd");
#line 975
                        if (tmp___147) {
                          goto _L___39;
                        } else {
#line 975
                          tmp___148 = cli_strbcasestr((char const   *)(dent->d_name),
                                                      ".cvd");
#line 975
                          if (tmp___148) {
                            _L___39: 
#line 986
                            tmp = strlen((char const   *)(dent->d_name));
#line 986
                            tmp___0 = strlen(dirname);
#line 986
                            dbfile = (char *)cli_calloc((tmp + tmp___0) + 2U, sizeof(char ));
#line 988
                            if (! dbfile) {
#line 989
                              cli_dbgmsg("cl_loaddbdir(): dbfile == NULL\n");
#line 990
                              closedir(dd);
#line 991
                              return (-3);
                            }
#line 993
                            sprintf((char * __restrict  )dbfile, (char const   * __restrict  )"%s/%s",
                                    dirname, dent->d_name);
#line 994
                            ret = cl_loaddb((char const   *)dbfile, root, signo);
#line 994
                            if (ret) {
#line 995
                              cli_dbgmsg("cl_loaddbdir(): error loading database %s\n",
                                         dbfile);
#line 996
                              free((void *)dbfile);
#line 997
                              closedir(dd);
#line 998
                              return (ret);
                            }
#line 1000
                            free((void *)dbfile);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1005
  closedir(dd);
#line 1006
  return (0);
}
}
#line 1009 "readdb.c"
char const   *cl_retdbdir(void) 
{ 

  {
#line 1011
  return ("/usr/local/share/clamav");
}
}
#line 1014 "readdb.c"
int cl_statinidir(char const   *dirname , struct cl_stat *dbstat ) 
{ DIR *dd ;
  struct dirent  const  *dent ;
  char *fname ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___57 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___76 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___126 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___145 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;

  {
#line 1027
  if (dbstat) {
#line 1028
    dbstat->no = 0;
#line 1029
    dbstat->stattab = (struct stat *)((void *)0);
#line 1030
    dbstat->statdname = (char **)((void *)0);
#line 1031
    tmp___18 = __builtin_constant_p((int )dirname);
#line 1031
    if (tmp___18) {
#line 1031
      if ((unsigned int )((void const   *)(dirname + 1)) - (unsigned int )((void const   *)dirname) ==
          1U) {
#line 1031
        if ((int const   )(*(dirname + 0)) == 0) {
#line 1031
          dbstat->dir = (char *)calloc(1U, 1U);
        } else {
#line 1031
          tmp___15 = strlen(dirname);
#line 1031
          __len___2 = tmp___15 + 1U;
#line 1031
          tmp___16 = (char *)malloc(__len___2);
#line 1031
          __retval___2 = tmp___16;
#line 1031
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1031
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dirname,
                                          __len___2);
          }
#line 1031
          dbstat->dir = __retval___2;
        }
      } else {
#line 1031
        dbstat->dir = __strdup(dirname);
      }
    } else {
#line 1031
      dbstat->dir = __strdup(dirname);
    }
  } else {
#line 1033
    cli_errmsg("cl_statdbdir(): Null argument passed.\n");
#line 1034
    return (300);
  }
#line 1037
  dd = opendir(dirname);
#line 1037
  if ((unsigned int )dd == (unsigned int )((void *)0)) {
#line 1038
    cli_errmsg("cl_statdbdir(): Can\'t open directory %s\n", dirname);
#line 1039
    return (-4);
  }
#line 1042
  cli_dbgmsg("Stat()ing files in %s\n", dirname);
#line 1049
  while (1) {
#line 1049
    dent = readdir(dd);
#line 1049
    if (! dent) {
#line 1049
      break;
    }
#line 1052
    if (dent->d_ino) {
#line 1055
      tmp___88 = __builtin_constant_p((int )(dent->d_name));
#line 1055
      if (tmp___88) {
#line 1055
        tmp___89 = __builtin_constant_p((int )".");
#line 1055
        if (tmp___89) {
#line 1055
          __s1_len = strlen((char const   *)(dent->d_name));
#line 1055
          __s2_len = strlen(".");
#line 1055
          if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                 1U)) {
            goto _L___16;
          } else {
#line 1055
            if (__s1_len >= 4U) {
              _L___16: 
#line 1055
              if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                     1U)) {
#line 1055
                tmp___90 = 1;
              } else {
#line 1055
                if (__s2_len >= 4U) {
#line 1055
                  tmp___90 = 1;
                } else {
#line 1055
                  tmp___90 = 0;
                }
              }
            } else {
#line 1055
              tmp___90 = 0;
            }
          }
#line 1055
          if (tmp___90) {
#line 1055
            tmp___57 = __builtin_strcmp(dent->d_name, ".");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
#line 1055
        tmp___87 = __builtin_constant_p((int )(dent->d_name));
#line 1055
        if (tmp___87) {
#line 1055
          if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
              1U) {
#line 1055
            __s1_len = strlen((char const   *)(dent->d_name));
#line 1055
            if (__s1_len < 4U) {
#line 1055
              tmp___76 = __builtin_constant_p((int )".");
#line 1055
              if (tmp___76) {
#line 1055
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
#line 1055
                  tmp___57 = __builtin_strcmp(dent->d_name, ".");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
#line 1055
                __s2___6 = (unsigned char const   *)".";
#line 1055
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 1055
                if (__s1_len > 0U) {
#line 1055
                  if (__result___18 == 0) {
#line 1055
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 1055
                    if (__s1_len > 1U) {
#line 1055
                      if (__result___18 == 0) {
#line 1055
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 1055
                        if (__s1_len > 2U) {
#line 1055
                          if (__result___18 == 0) {
#line 1055
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 1055
                tmp___57 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
#line 1055
          tmp___86 = __builtin_constant_p((int )".");
#line 1055
          if (tmp___86) {
#line 1055
            if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                1U) {
#line 1055
              __s2_len = strlen(".");
#line 1055
              if (__s2_len < 4U) {
#line 1055
                tmp___85 = __builtin_constant_p((int )(dent->d_name));
#line 1055
                if (tmp___85) {
#line 1055
                  if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                      1U) {
#line 1055
                    tmp___57 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
#line 1055
                  __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 1055
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             0)));
#line 1055
                  if (__s2_len > 0U) {
#line 1055
                    if (__result___22 == 0) {
#line 1055
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 1)));
#line 1055
                      if (__s2_len > 1U) {
#line 1055
                        if (__result___22 == 0) {
#line 1055
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  2)));
#line 1055
                          if (__s2_len > 2U) {
#line 1055
                            if (__result___22 == 0) {
#line 1055
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 1055
                  tmp___57 = __result___22;
                }
              } else {
#line 1055
                tmp___57 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
#line 1055
              tmp___57 = __builtin_strcmp(dent->d_name, ".");
            }
          } else {
#line 1055
            tmp___57 = __builtin_strcmp(dent->d_name, ".");
          }
        }
      }
#line 1055
      if (tmp___57) {
#line 1055
        tmp___157 = __builtin_constant_p((int )(dent->d_name));
#line 1055
        if (tmp___157) {
#line 1055
          tmp___158 = __builtin_constant_p((int )"..");
#line 1055
          if (tmp___158) {
#line 1055
            __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 1055
            __s2_len___0 = strlen("..");
#line 1055
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___36;
            } else {
#line 1055
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 1055
                if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                       1U)) {
#line 1055
                  tmp___159 = 1;
                } else {
#line 1055
                  if (__s2_len___0 >= 4U) {
#line 1055
                    tmp___159 = 1;
                  } else {
#line 1055
                    tmp___159 = 0;
                  }
                }
              } else {
#line 1055
                tmp___159 = 0;
              }
            }
#line 1055
            if (tmp___159) {
#line 1055
              tmp___126 = __builtin_strcmp(dent->d_name, "..");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 1055
          tmp___156 = __builtin_constant_p((int )(dent->d_name));
#line 1055
          if (tmp___156) {
#line 1055
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
#line 1055
              __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 1055
              if (__s1_len___0 < 4U) {
#line 1055
                tmp___145 = __builtin_constant_p((int )"..");
#line 1055
                if (tmp___145) {
#line 1055
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
#line 1055
                    tmp___126 = __builtin_strcmp(dent->d_name, "..");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 1055
                  __s2___14 = (unsigned char const   *)"..";
#line 1055
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 1055
                  if (__s1_len___0 > 0U) {
#line 1055
                    if (__result___42 == 0) {
#line 1055
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 1055
                      if (__s1_len___0 > 1U) {
#line 1055
                        if (__result___42 == 0) {
#line 1055
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 1055
                          if (__s1_len___0 > 2U) {
#line 1055
                            if (__result___42 == 0) {
#line 1055
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 1055
                  tmp___126 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 1055
            tmp___155 = __builtin_constant_p((int )"..");
#line 1055
            if (tmp___155) {
#line 1055
              if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                  1U) {
#line 1055
                __s2_len___0 = strlen("..");
#line 1055
                if (__s2_len___0 < 4U) {
#line 1055
                  tmp___154 = __builtin_constant_p((int )(dent->d_name));
#line 1055
                  if (tmp___154) {
#line 1055
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
#line 1055
                      tmp___126 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 1055
                    __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 1055
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               0)));
#line 1055
                    if (__s2_len___0 > 0U) {
#line 1055
                      if (__result___46 == 0) {
#line 1055
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                1)));
#line 1055
                        if (__s2_len___0 > 1U) {
#line 1055
                          if (__result___46 == 0) {
#line 1055
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    2)));
#line 1055
                            if (__s2_len___0 > 2U) {
#line 1055
                              if (__result___46 == 0) {
#line 1055
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 1055
                    tmp___126 = __result___46;
                  }
                } else {
#line 1055
                  tmp___126 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
#line 1055
                tmp___126 = __builtin_strcmp(dent->d_name, "..");
              }
            } else {
#line 1055
              tmp___126 = __builtin_strcmp(dent->d_name, "..");
            }
          }
        }
#line 1055
        if (tmp___126) {
#line 1055
          tmp___160 = cli_strbcasestr((char const   *)(dent->d_name), ".db");
#line 1055
          if (tmp___160) {
            goto _L___39;
          } else {
#line 1055
            tmp___161 = cli_strbcasestr((char const   *)(dent->d_name), ".db2");
#line 1055
            if (tmp___161) {
              goto _L___39;
            } else {
#line 1055
              tmp___162 = cli_strbcasestr((char const   *)(dent->d_name), ".db3");
#line 1055
              if (tmp___162) {
                goto _L___39;
              } else {
#line 1055
                tmp___163 = cli_strbcasestr((char const   *)(dent->d_name), ".hdb");
#line 1055
                if (tmp___163) {
                  goto _L___39;
                } else {
#line 1055
                  tmp___164 = cli_strbcasestr((char const   *)(dent->d_name), ".fp");
#line 1055
                  if (tmp___164) {
                    goto _L___39;
                  } else {
#line 1055
                    tmp___165 = cli_strbcasestr((char const   *)(dent->d_name), ".ndb");
#line 1055
                    if (tmp___165) {
                      goto _L___39;
                    } else {
#line 1055
                      tmp___166 = cli_strbcasestr((char const   *)(dent->d_name),
                                                  ".zmd");
#line 1055
                      if (tmp___166) {
                        goto _L___39;
                      } else {
#line 1055
                        tmp___167 = cli_strbcasestr((char const   *)(dent->d_name),
                                                    ".rmd");
#line 1055
                        if (tmp___167) {
                          goto _L___39;
                        } else {
#line 1055
                          tmp___168 = cli_strbcasestr((char const   *)(dent->d_name),
                                                      ".cvd");
#line 1055
                          if (tmp___168) {
                            _L___39: 
#line 1066
                            dbstat->no ++;
#line 1067
                            dbstat->stattab = (struct stat *)realloc((void *)dbstat->stattab,
                                                                     (unsigned int )dbstat->no *
                                                                     sizeof(struct stat ));
#line 1072
                            tmp___20 = strlen(dirname);
#line 1072
                            tmp___21 = strlen((char const   *)(dent->d_name));
#line 1072
                            fname = (char *)cli_calloc((tmp___20 + tmp___21) + 2U,
                                                       sizeof(char ));
#line 1073
                            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                                    dirname, dent->d_name);
#line 1078
                            stat__extinline((char const   *)fname, dbstat->stattab +
                                                                   (dbstat->no - 1));
#line 1079
                            free((void *)fname);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1084
  closedir(dd);
#line 1085
  return (0);
}
}
#line 1088 "readdb.c"
int cl_statchkdir(struct cl_stat  const  *dbstat ) 
{ DIR *dd ;
  struct dirent *dent ;
  struct stat sb ;
  int i ;
  int found ;
  char *fname ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___55 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___105 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___124 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;

  {
#line 1103
  if (! dbstat) {
#line 1104
    cli_errmsg("cl_statdbdir(): Null argument passed.\n");
#line 1105
    return (300);
  } else {
#line 1103
    if (! dbstat->dir) {
#line 1104
      cli_errmsg("cl_statdbdir(): Null argument passed.\n");
#line 1105
      return (300);
    }
  }
#line 1108
  dd = opendir((char const   *)dbstat->dir);
#line 1108
  if ((unsigned int )dd == (unsigned int )((void *)0)) {
#line 1109
    cli_errmsg("cl_statdbdir(): Can\'t open directory %s\n", dbstat->dir);
#line 1110
    return (-4);
  }
#line 1113
  cli_dbgmsg("Stat()ing files in %s\n", dbstat->dir);
#line 1120
  while (1) {
#line 1120
    dent = readdir(dd);
#line 1120
    if (! dent) {
#line 1120
      break;
    }
#line 1123
    if (dent->d_ino) {
#line 1126
      tmp___67 = __builtin_constant_p((int )(dent->d_name));
#line 1126
      if (tmp___67) {
#line 1126
        tmp___68 = __builtin_constant_p((int )".");
#line 1126
        if (tmp___68) {
#line 1126
          __s1_len = strlen((char const   *)(dent->d_name));
#line 1126
          __s2_len = strlen(".");
#line 1126
          if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                 1U)) {
            goto _L___16;
          } else {
#line 1126
            if (__s1_len >= 4U) {
              _L___16: 
#line 1126
              if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                     1U)) {
#line 1126
                tmp___69 = 1;
              } else {
#line 1126
                if (__s2_len >= 4U) {
#line 1126
                  tmp___69 = 1;
                } else {
#line 1126
                  tmp___69 = 0;
                }
              }
            } else {
#line 1126
              tmp___69 = 0;
            }
          }
#line 1126
          if (tmp___69) {
#line 1126
            tmp___36 = __builtin_strcmp(dent->d_name, ".");
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
#line 1126
        tmp___66 = __builtin_constant_p((int )(dent->d_name));
#line 1126
        if (tmp___66) {
#line 1126
          if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
              1U) {
#line 1126
            __s1_len = strlen((char const   *)(dent->d_name));
#line 1126
            if (__s1_len < 4U) {
#line 1126
              tmp___55 = __builtin_constant_p((int )".");
#line 1126
              if (tmp___55) {
#line 1126
                if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                    1U) {
#line 1126
                  tmp___36 = __builtin_strcmp(dent->d_name, ".");
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
#line 1126
                __s2___6 = (unsigned char const   *)".";
#line 1126
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 1126
                if (__s1_len > 0U) {
#line 1126
                  if (__result___18 == 0) {
#line 1126
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 1126
                    if (__s1_len > 1U) {
#line 1126
                      if (__result___18 == 0) {
#line 1126
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 1126
                        if (__s1_len > 2U) {
#line 1126
                          if (__result___18 == 0) {
#line 1126
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 1126
                tmp___36 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
#line 1126
          tmp___65 = __builtin_constant_p((int )".");
#line 1126
          if (tmp___65) {
#line 1126
            if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                1U) {
#line 1126
              __s2_len = strlen(".");
#line 1126
              if (__s2_len < 4U) {
#line 1126
                tmp___64 = __builtin_constant_p((int )(dent->d_name));
#line 1126
                if (tmp___64) {
#line 1126
                  if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                      1U) {
#line 1126
                    tmp___36 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
#line 1126
                  __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 1126
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             0)));
#line 1126
                  if (__s2_len > 0U) {
#line 1126
                    if (__result___22 == 0) {
#line 1126
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"." +
                                                                                                 1)));
#line 1126
                      if (__s2_len > 1U) {
#line 1126
                        if (__result___22 == 0) {
#line 1126
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"." +
                                                                  2)));
#line 1126
                          if (__s2_len > 2U) {
#line 1126
                            if (__result___22 == 0) {
#line 1126
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 1126
                  tmp___36 = __result___22;
                }
              } else {
#line 1126
                tmp___36 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
#line 1126
              tmp___36 = __builtin_strcmp(dent->d_name, ".");
            }
          } else {
#line 1126
            tmp___36 = __builtin_strcmp(dent->d_name, ".");
          }
        }
      }
#line 1126
      if (tmp___36) {
#line 1126
        tmp___136 = __builtin_constant_p((int )(dent->d_name));
#line 1126
        if (tmp___136) {
#line 1126
          tmp___137 = __builtin_constant_p((int )"..");
#line 1126
          if (tmp___137) {
#line 1126
            __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 1126
            __s2_len___0 = strlen("..");
#line 1126
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___36;
            } else {
#line 1126
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 1126
                if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                       1U)) {
#line 1126
                  tmp___138 = 1;
                } else {
#line 1126
                  if (__s2_len___0 >= 4U) {
#line 1126
                    tmp___138 = 1;
                  } else {
#line 1126
                    tmp___138 = 0;
                  }
                }
              } else {
#line 1126
                tmp___138 = 0;
              }
            }
#line 1126
            if (tmp___138) {
#line 1126
              tmp___105 = __builtin_strcmp(dent->d_name, "..");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 1126
          tmp___135 = __builtin_constant_p((int )(dent->d_name));
#line 1126
          if (tmp___135) {
#line 1126
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
#line 1126
              __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 1126
              if (__s1_len___0 < 4U) {
#line 1126
                tmp___124 = __builtin_constant_p((int )"..");
#line 1126
                if (tmp___124) {
#line 1126
                  if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                      1U) {
#line 1126
                    tmp___105 = __builtin_strcmp(dent->d_name, "..");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 1126
                  __s2___14 = (unsigned char const   *)"..";
#line 1126
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 1126
                  if (__s1_len___0 > 0U) {
#line 1126
                    if (__result___42 == 0) {
#line 1126
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 1126
                      if (__s1_len___0 > 1U) {
#line 1126
                        if (__result___42 == 0) {
#line 1126
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 1126
                          if (__s1_len___0 > 2U) {
#line 1126
                            if (__result___42 == 0) {
#line 1126
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 1126
                  tmp___105 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 1126
            tmp___134 = __builtin_constant_p((int )"..");
#line 1126
            if (tmp___134) {
#line 1126
              if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                  1U) {
#line 1126
                __s2_len___0 = strlen("..");
#line 1126
                if (__s2_len___0 < 4U) {
#line 1126
                  tmp___133 = __builtin_constant_p((int )(dent->d_name));
#line 1126
                  if (tmp___133) {
#line 1126
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
#line 1126
                      tmp___105 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 1126
                    __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 1126
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               0)));
#line 1126
                    if (__s2_len___0 > 0U) {
#line 1126
                      if (__result___46 == 0) {
#line 1126
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)".." +
                                                                1)));
#line 1126
                        if (__s2_len___0 > 1U) {
#line 1126
                          if (__result___46 == 0) {
#line 1126
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)".." +
                                                                    2)));
#line 1126
                            if (__s2_len___0 > 2U) {
#line 1126
                              if (__result___46 == 0) {
#line 1126
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 1126
                    tmp___105 = __result___46;
                  }
                } else {
#line 1126
                  tmp___105 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
#line 1126
                tmp___105 = __builtin_strcmp(dent->d_name, "..");
              }
            } else {
#line 1126
              tmp___105 = __builtin_strcmp(dent->d_name, "..");
            }
          }
        }
#line 1126
        if (tmp___105) {
#line 1126
          tmp___139 = cli_strbcasestr((char const   *)(dent->d_name), ".db");
#line 1126
          if (tmp___139) {
            goto _L___39;
          } else {
#line 1126
            tmp___140 = cli_strbcasestr((char const   *)(dent->d_name), ".db2");
#line 1126
            if (tmp___140) {
              goto _L___39;
            } else {
#line 1126
              tmp___141 = cli_strbcasestr((char const   *)(dent->d_name), ".db3");
#line 1126
              if (tmp___141) {
                goto _L___39;
              } else {
#line 1126
                tmp___142 = cli_strbcasestr((char const   *)(dent->d_name), ".hdb");
#line 1126
                if (tmp___142) {
                  goto _L___39;
                } else {
#line 1126
                  tmp___143 = cli_strbcasestr((char const   *)(dent->d_name), ".fp");
#line 1126
                  if (tmp___143) {
                    goto _L___39;
                  } else {
#line 1126
                    tmp___144 = cli_strbcasestr((char const   *)(dent->d_name), ".ndb");
#line 1126
                    if (tmp___144) {
                      goto _L___39;
                    } else {
#line 1126
                      tmp___145 = cli_strbcasestr((char const   *)(dent->d_name),
                                                  ".zmd");
#line 1126
                      if (tmp___145) {
                        goto _L___39;
                      } else {
#line 1126
                        tmp___146 = cli_strbcasestr((char const   *)(dent->d_name),
                                                    ".rmd");
#line 1126
                        if (tmp___146) {
                          goto _L___39;
                        } else {
#line 1126
                          tmp___147 = cli_strbcasestr((char const   *)(dent->d_name),
                                                      ".cvd");
#line 1126
                          if (tmp___147) {
                            _L___39: 
#line 1137
                            tmp = strlen((char const   *)dbstat->dir);
#line 1137
                            tmp___0 = strlen((char const   *)(dent->d_name));
#line 1137
                            fname = (char *)cli_calloc((tmp + tmp___0) + 2U, sizeof(char ));
#line 1138
                            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                                    dbstat->dir, dent->d_name);
#line 1139
                            stat__extinline((char const   *)fname, & sb);
#line 1140
                            free((void *)fname);
#line 1142
                            found = 0;
#line 1143
                            i = 0;
#line 1143
                            while (i < dbstat->no) {
#line 1147
                              if ((dbstat->stattab + i)->st_ino == sb.st_ino) {
#line 1149
                                found = 1;
#line 1150
                                if ((dbstat->stattab + i)->st_mtim.tv_sec != sb.st_mtim.tv_sec) {
#line 1151
                                  closedir(dd);
#line 1152
                                  return (1);
                                }
                              }
#line 1143
                              i ++;
                            }
#line 1156
                            if (! found) {
#line 1157
                              closedir(dd);
#line 1158
                              return (1);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1164
  closedir(dd);
#line 1165
  return (0);
}
}
#line 1168 "readdb.c"
int cl_statfree(struct cl_stat *dbstat ) 
{ 

  {
#line 1171
  if (dbstat) {
#line 1184
    free((void *)dbstat->stattab);
#line 1185
    dbstat->stattab = (struct stat *)((void *)0);
#line 1186
    dbstat->no = 0;
#line 1187
    if (dbstat->dir) {
#line 1188
      free((void *)dbstat->dir);
#line 1189
      dbstat->dir = (char *)((void *)0);
    }
  } else {
#line 1192
    cli_errmsg("cl_statfree(): Null argument passed\n");
#line 1193
    return (300);
  }
#line 1196
  return (0);
}
}
#line 1 "cvd.lo"
#pragma merger(0,"/tmp/cil-qsYy7dyq.i","-g -O2 -fPIC")
#line 611 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 645
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 952 "/usr/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 973
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1090
extern int gzclose(gzFile file ) ;
#line 203 "clamav.h"
struct cl_cvd *cl_cvdparse(char const   *head ) ;
#line 204
int cl_cvdverify(char const   *file ) ;
#line 41 "cvd.c"
int cli_untgz(int fd , char const   *destdir ) 
{ char *fullname ;
  char osize[13] ;
  char name[101] ;
  char type ;
  char block[512] ;
  int nbytes ;
  int nread ;
  int nwritten ;
  int in_block ;
  unsigned int size ;
  FILE *outfile ;
  gzFile *infile ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 45
  in_block = 0;
#line 47
  outfile = (FILE *)((void *)0);
#line 50
  cli_dbgmsg("in cli_untgz()\n");
#line 52
  infile = (gzFile *)gzdopen(fd, "rb");
#line 52
  if ((unsigned int )infile == (unsigned int )((void *)0)) {
#line 53
    cli_errmsg("Can\'t gzdopen() descriptor %d\n", fd);
#line 54
    return (-1);
  }
#line 58
  tmp = strlen(destdir);
#line 58
  fullname = (char *)calloc(sizeof(char ), (tmp + 100U) + 5U);
#line 60
  while (1) {
#line 62
    nread = gzread((void *)infile, (void *)(block), 512U);
#line 64
    if (! in_block) {
#line 64
      if (nread == 0) {
#line 65
        break;
      }
    }
#line 67
    if (nread != 512) {
#line 68
      cli_errmsg("Incomplete block read.\n");
#line 69
      free((void *)fullname);
#line 70
      gzclose((void *)infile);
#line 71
      return (-1);
    }
#line 74
    if (! in_block) {
#line 75
      if ((int )block[0] == 0) {
#line 76
        break;
      }
#line 78
      __builtin_strncpy(name, block, 100);
#line 79
      name[100] = (char )'\000';
#line 80
      strcpy((char * __restrict  )fullname, (char const   * __restrict  )destdir);
#line 81
      strcat((char * __restrict  )fullname, (char const   * __restrict  )"/");
#line 82
      strcat((char * __restrict  )fullname, (char const   * __restrict  )(name));
#line 83
      cli_dbgmsg("Unpacking %s\n", fullname);
#line 84
      type = block[156];
#line 86
      switch ((int )type) {
      case 48: ;
      case 0: ;
#line 89
      break;
      case 53: 
#line 91
      cli_errmsg("Directories in CVD are not supported.\n");
#line 92
      free((void *)fullname);
#line 93
      gzclose((void *)infile);
#line 94
      return (-1);
      default: 
#line 96
      cli_errmsg("Unknown type flag %c.\n", type);
#line 97
      free((void *)fullname);
#line 98
      gzclose((void *)infile);
#line 99
      return (-1);
      }
#line 102
      in_block = 1;
#line 104
      if (outfile) {
#line 105
        tmp___1 = fclose(outfile);
#line 105
        if (tmp___1) {
#line 106
          cli_errmsg("Cannot close file %s.\n", fullname);
#line 107
          free((void *)fullname);
#line 108
          gzclose((void *)infile);
#line 109
          return (-1);
        }
#line 111
        outfile = (FILE *)((void *)0);
      }
#line 114
      outfile = fopen((char const   * __restrict  )fullname, (char const   * __restrict  )"wb");
#line 114
      if (! outfile) {
#line 115
        cli_errmsg("Cannot create file %s.\n", fullname);
#line 116
        free((void *)fullname);
#line 117
        gzclose((void *)infile);
#line 118
        return (-1);
      }
#line 121
      __builtin_strncpy(osize, block + 124, 12);
#line 122
      osize[12] = (char )'\000';
#line 124
      tmp___2 = sscanf((char const   * __restrict  )(osize), (char const   * __restrict  )"%o",
                       & size);
#line 124
      if (tmp___2 == 0) {
#line 125
        cli_errmsg("Invalid size in header.\n");
#line 126
        free((void *)fullname);
#line 127
        gzclose((void *)infile);
#line 128
        fclose(outfile);
#line 129
        return (-1);
      }
    } else {
#line 133
      if (size > 512U) {
#line 133
        nbytes = 512;
      } else {
#line 133
        nbytes = (int )size;
      }
#line 134
      nwritten = (int )fwrite((void const   * __restrict  )(block), 1U, (unsigned int )nbytes,
                              (FILE * __restrict  )outfile);
#line 136
      if (nwritten != nbytes) {
#line 137
        cli_errmsg("Wrote %d instead of %d (%s).\n", nwritten, nbytes, fullname);
#line 138
        free((void *)fullname);
#line 139
        gzclose((void *)infile);
#line 140
        return (-1);
      }
#line 143
      size -= (unsigned int )nbytes;
#line 144
      if (size == 0U) {
#line 145
        in_block = 0;
      }
    }
  }
#line 149
  if (outfile) {
#line 150
    fclose(outfile);
  }
#line 152
  gzclose((void *)infile);
#line 153
  free((void *)fullname);
#line 154
  return (0);
}
}
#line 157 "cvd.c"
struct cl_cvd *cl_cvdparse(char const   *head ) 
{ char *pt ;
  struct cl_cvd *cvd ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___109 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___128 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;

  {
#line 162
  tmp___143 = __builtin_constant_p((int )head);
#line 162
  if (tmp___143) {
#line 162
    tmp___144 = strlen(head);
#line 162
    if (tmp___144 < 11U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
#line 162
    tmp___145 = __builtin_constant_p((int )"ClamAV-VDB:");
#line 162
    if (tmp___145) {
#line 162
      tmp___146 = strlen("ClamAV-VDB:");
#line 162
      if (tmp___146 < 11U) {
        _L___39: 
#line 162
        tmp___140 = __builtin_constant_p((int )head);
#line 162
        if (tmp___140) {
#line 162
          tmp___141 = __builtin_constant_p((int )"ClamAV-VDB:");
#line 162
          if (tmp___141) {
#line 162
            __s1_len___0 = strlen(head);
#line 162
            __s2_len___0 = strlen("ClamAV-VDB:");
#line 162
            if (! ((unsigned int )((void const   *)(head + 1)) - (unsigned int )((void const   *)head) ==
                   1U)) {
              goto _L___36;
            } else {
#line 162
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 162
                if (! ((unsigned int )((void const   *)("ClamAV-VDB:" + 1)) - (unsigned int )((void const   *)"ClamAV-VDB:") ==
                       1U)) {
#line 162
                  tmp___142 = 1;
                } else {
#line 162
                  if (__s2_len___0 >= 4U) {
#line 162
                    tmp___142 = 1;
                  } else {
#line 162
                    tmp___142 = 0;
                  }
                }
              } else {
#line 162
                tmp___142 = 0;
              }
            }
#line 162
            if (tmp___142) {
#line 162
              tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 162
          tmp___139 = __builtin_constant_p((int )head);
#line 162
          if (tmp___139) {
#line 162
            if ((unsigned int )((void const   *)(head + 1)) - (unsigned int )((void const   *)head) ==
                1U) {
#line 162
              __s1_len___0 = strlen(head);
#line 162
              if (__s1_len___0 < 4U) {
#line 162
                tmp___128 = __builtin_constant_p((int )"ClamAV-VDB:");
#line 162
                if (tmp___128) {
#line 162
                  if ((unsigned int )((void const   *)("ClamAV-VDB:" + 1)) - (unsigned int )((void const   *)"ClamAV-VDB:") ==
                      1U) {
#line 162
                    tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 162
                  __s2___14 = (unsigned char const   *)"ClamAV-VDB:";
#line 162
                  __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 162
                  if (__s1_len___0 > 0U) {
#line 162
                    if (__result___42 == 0) {
#line 162
                      __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 162
                      if (__s1_len___0 > 1U) {
#line 162
                        if (__result___42 == 0) {
#line 162
                          __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 162
                          if (__s1_len___0 > 2U) {
#line 162
                            if (__result___42 == 0) {
#line 162
                              __result___42 = (int )((int const   )(*((unsigned char const   *)head +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 162
                  tmp___109 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 162
            tmp___138 = __builtin_constant_p((int )"ClamAV-VDB:");
#line 162
            if (tmp___138) {
#line 162
              if ((unsigned int )((void const   *)("ClamAV-VDB:" + 1)) - (unsigned int )((void const   *)"ClamAV-VDB:") ==
                  1U) {
#line 162
                __s2_len___0 = strlen("ClamAV-VDB:");
#line 162
                if (__s2_len___0 < 4U) {
#line 162
                  tmp___137 = __builtin_constant_p((int )head);
#line 162
                  if (tmp___137) {
#line 162
                    if ((unsigned int )((void const   *)(head + 1)) - (unsigned int )((void const   *)head) ==
                        1U) {
#line 162
                      tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 162
                    __s1___30 = (unsigned char const   *)head;
#line 162
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                                               0)));
#line 162
                    if (__s2_len___0 > 0U) {
#line 162
                      if (__result___46 == 0) {
#line 162
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                1)));
#line 162
                        if (__s2_len___0 > 1U) {
#line 162
                          if (__result___46 == 0) {
#line 162
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                    2)));
#line 162
                            if (__s2_len___0 > 2U) {
#line 162
                              if (__result___46 == 0) {
#line 162
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"ClamAV-VDB:" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 162
                    tmp___109 = __result___46;
                  }
                } else {
#line 162
                  tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
                }
              } else {
#line 162
                tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
              }
            } else {
#line 162
              tmp___109 = __builtin_strcmp(head, "ClamAV-VDB:");
            }
          }
        }
#line 162
        tmp___73 = tmp___109;
      } else {
#line 162
        tmp___73 = strncmp(head, "ClamAV-VDB:", 11U);
      }
    } else {
#line 162
      tmp___73 = strncmp(head, "ClamAV-VDB:", 11U);
    }
  }
#line 162
  if (tmp___73) {
#line 163
    cli_dbgmsg("Not a CVD head.\n");
#line 164
    return ((struct cl_cvd *)((void *)0));
  }
#line 167
  cvd = (struct cl_cvd *)cli_calloc(1U, sizeof(struct cl_cvd ));
#line 169
  cvd->time = cli_strtok(head, 1, ":");
#line 169
  if (! cvd->time) {
#line 170
    cli_errmsg("CVD -> Can\'t extract time from header.\n");
#line 171
    free((void *)cvd);
#line 172
    return ((struct cl_cvd *)((void *)0));
  }
#line 175
  pt = cli_strtok(head, 2, ":");
#line 175
  if (! pt) {
#line 176
    cli_errmsg("CVD -> Can\'t extract version from header.\n");
#line 177
    free((void *)cvd->time);
#line 178
    free((void *)cvd);
#line 179
    return ((struct cl_cvd *)((void *)0));
  }
#line 181
  cvd->version = atoi__extinline((char const   *)pt);
#line 182
  free((void *)pt);
#line 184
  pt = cli_strtok(head, 3, ":");
#line 184
  if (! pt) {
#line 185
    cli_errmsg("CVD -> Can\'t extract signature number from header.\n");
#line 186
    free((void *)cvd->time);
#line 187
    free((void *)cvd);
#line 188
    return ((struct cl_cvd *)((void *)0));
  }
#line 190
  cvd->sigs = atoi__extinline((char const   *)pt);
#line 191
  free((void *)pt);
#line 193
  pt = cli_strtok(head, 4, ":");
#line 193
  if (! pt) {
#line 194
    cli_errmsg("CVD -> Can\'t extract functionality level from header.\n");
#line 195
    free((void *)cvd->time);
#line 196
    free((void *)cvd);
#line 197
    return ((struct cl_cvd *)((void *)0));
  }
#line 199
  cvd->fl = (short )atoi__extinline((char const   *)pt);
#line 200
  free((void *)pt);
#line 202
  cvd->md5 = cli_strtok(head, 5, ":");
#line 202
  if (! cvd->md5) {
#line 203
    cli_errmsg("CVD -> Can\'t extract MD5 checksum from header.\n");
#line 204
    free((void *)cvd->time);
#line 205
    free((void *)cvd);
#line 206
    return ((struct cl_cvd *)((void *)0));
  }
#line 209
  cvd->dsig = cli_strtok(head, 6, ":");
#line 209
  if (! cvd->dsig) {
#line 210
    cli_errmsg("CVD -> Can\'t extract digital signature from header.\n");
#line 211
    free((void *)cvd->time);
#line 212
    free((void *)cvd->md5);
#line 213
    free((void *)cvd);
#line 214
    return ((struct cl_cvd *)((void *)0));
  }
#line 217
  cvd->builder = cli_strtok(head, 7, ":");
#line 217
  if (! cvd->builder) {
#line 218
    cli_errmsg("CVD -> Can\'t extract builder name from header.\n");
#line 219
    free((void *)cvd->time);
#line 220
    free((void *)cvd->md5);
#line 221
    free((void *)cvd->dsig);
#line 222
    free((void *)cvd);
#line 223
    return ((struct cl_cvd *)((void *)0));
  }
#line 226
  pt = cli_strtok(head, 8, ":");
#line 226
  if (pt) {
#line 227
    cvd->stime = atoi__extinline((char const   *)pt);
#line 228
    free((void *)pt);
  } else {
#line 230
    cli_dbgmsg("CVD -> No creation time in seconds (old file format)\n");
  }
#line 233
  return (cvd);
}
}
#line 236 "cvd.c"
struct cl_cvd *cl_cvdhead(char const   *file ) 
{ FILE *fd ;
  char head[513] ;
  int i ;
  struct cl_cvd *tmp ;

  {
#line 242
  fd = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 242
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
#line 243
    cli_dbgmsg("Can\'t open CVD file %s\n", file);
#line 244
    return ((struct cl_cvd *)((void *)0));
  }
#line 247
  i = (int )fread((void * __restrict  )(head), 1U, 512U, (FILE * __restrict  )fd);
#line 247
  if (i != 512) {
#line 248
    cli_dbgmsg("Short read (%d) while reading CVD head from %s\n", i, file);
#line 249
    fclose(fd);
#line 250
    return ((struct cl_cvd *)((void *)0));
  }
#line 253
  fclose(fd);
#line 255
  head[512] = (char)0;
#line 256
  i = 511;
#line 256
  while (1) {
#line 256
    if (i > 0) {
#line 256
      if (! ((int )head[i] == 32)) {
#line 256
        if (! ((int )head[i] == 10)) {
#line 256
          break;
        }
      }
    } else {
#line 256
      break;
    }
#line 256
    head[i] = (char)0;
#line 256
    i --;
  }
#line 258
  tmp = cl_cvdparse((char const   *)(head));
#line 258
  return (tmp);
}
}
#line 261 "cvd.c"
void cl_cvdfree(struct cl_cvd *cvd ) 
{ 

  {
#line 263
  free((void *)cvd->time);
#line 264
  free((void *)cvd->md5);
#line 265
  free((void *)cvd->dsig);
#line 266
  free((void *)cvd->builder);
#line 267
  free((void *)cvd);
#line 268
  return;
}
}
#line 270 "cvd.c"
int cli_cvdverify(FILE *fd , struct cl_cvd *cvdpt ) 
{ struct cl_cvd *cvd ;
  char *md5 ;
  char head[513] ;
  int i ;
  size_t tmp ;
  int tmp___74 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___110 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___129 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;

  {
#line 276
  fseek(fd, 0L, 0);
#line 277
  tmp = fread((void * __restrict  )(head), 1U, 512U, (FILE * __restrict  )fd);
#line 277
  if (tmp != 512U) {
#line 278
    cli_dbgmsg("Can\'t read CVD head from stream\n");
#line 279
    return (-8);
  }
#line 282
  head[512] = (char)0;
#line 283
  i = 511;
#line 283
  while (1) {
#line 283
    if (i > 0) {
#line 283
      if (! ((int )head[i] == 32)) {
#line 283
        if (! ((int )head[i] == 10)) {
#line 283
          break;
        }
      }
    } else {
#line 283
      break;
    }
#line 283
    head[i] = (char)0;
#line 283
    i --;
  }
#line 285
  cvd = cl_cvdparse((char const   *)(head));
#line 285
  if ((unsigned int )cvd == (unsigned int )((void *)0)) {
#line 286
    return (-8);
  }
#line 288
  if (cvdpt) {
#line 289
    memcpy((void * __restrict  )cvdpt, (void const   * __restrict  )cvd, sizeof(struct cl_cvd ));
  }
#line 291
  md5 = cli_md5stream(fd, (unsigned char *)((void *)0));
#line 292
  cli_dbgmsg("MD5(.tar.gz) = %s\n", md5);
#line 294
  tmp___144 = __builtin_constant_p((int )md5);
#line 294
  if (tmp___144) {
#line 294
    tmp___145 = strlen((char const   *)md5);
#line 294
    if (tmp___145 < 32U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
#line 294
    tmp___146 = __builtin_constant_p((int )cvd->md5);
#line 294
    if (tmp___146) {
#line 294
      tmp___147 = strlen((char const   *)cvd->md5);
#line 294
      if (tmp___147 < 32U) {
        _L___39: 
#line 294
        tmp___141 = __builtin_constant_p((int )md5);
#line 294
        if (tmp___141) {
#line 294
          tmp___142 = __builtin_constant_p((int )cvd->md5);
#line 294
          if (tmp___142) {
#line 294
            __s1_len___0 = strlen((char const   *)md5);
#line 294
            __s2_len___0 = strlen((char const   *)cvd->md5);
#line 294
            if (! ((unsigned int )((void const   *)(md5 + 1)) - (unsigned int )((void const   *)md5) ==
                   1U)) {
              goto _L___36;
            } else {
#line 294
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 294
                if (! ((unsigned int )((void const   *)(cvd->md5 + 1)) - (unsigned int )((void const   *)cvd->md5) ==
                       1U)) {
#line 294
                  tmp___143 = 1;
                } else {
#line 294
                  if (__s2_len___0 >= 4U) {
#line 294
                    tmp___143 = 1;
                  } else {
#line 294
                    tmp___143 = 0;
                  }
                }
              } else {
#line 294
                tmp___143 = 0;
              }
            }
#line 294
            if (tmp___143) {
#line 294
              tmp___110 = __builtin_strcmp(md5, cvd->md5);
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 294
          tmp___140 = __builtin_constant_p((int )md5);
#line 294
          if (tmp___140) {
#line 294
            if ((unsigned int )((void const   *)(md5 + 1)) - (unsigned int )((void const   *)md5) ==
                1U) {
#line 294
              __s1_len___0 = strlen((char const   *)md5);
#line 294
              if (__s1_len___0 < 4U) {
#line 294
                tmp___129 = __builtin_constant_p((int )cvd->md5);
#line 294
                if (tmp___129) {
#line 294
                  if ((unsigned int )((void const   *)(cvd->md5 + 1)) - (unsigned int )((void const   *)cvd->md5) ==
                      1U) {
#line 294
                    tmp___110 = __builtin_strcmp(md5, cvd->md5);
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 294
                  __s2___14 = (unsigned char const   *)((char const   *)cvd->md5);
#line 294
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 294
                  if (__s1_len___0 > 0U) {
#line 294
                    if (__result___42 == 0) {
#line 294
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 294
                      if (__s1_len___0 > 1U) {
#line 294
                        if (__result___42 == 0) {
#line 294
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 294
                          if (__s1_len___0 > 2U) {
#line 294
                            if (__result___42 == 0) {
#line 294
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)md5) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 294
                  tmp___110 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 294
            tmp___139 = __builtin_constant_p((int )cvd->md5);
#line 294
            if (tmp___139) {
#line 294
              if ((unsigned int )((void const   *)(cvd->md5 + 1)) - (unsigned int )((void const   *)cvd->md5) ==
                  1U) {
#line 294
                __s2_len___0 = strlen((char const   *)cvd->md5);
#line 294
                if (__s2_len___0 < 4U) {
#line 294
                  tmp___138 = __builtin_constant_p((int )md5);
#line 294
                  if (tmp___138) {
#line 294
                    if ((unsigned int )((void const   *)(md5 + 1)) - (unsigned int )((void const   *)md5) ==
                        1U) {
#line 294
                      tmp___110 = __builtin_strcmp(md5, cvd->md5);
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 294
                    __s1___30 = (unsigned char const   *)((char const   *)md5);
#line 294
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                                               0)));
#line 294
                    if (__s2_len___0 > 0U) {
#line 294
                      if (__result___46 == 0) {
#line 294
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                1)));
#line 294
                        if (__s2_len___0 > 1U) {
#line 294
                          if (__result___46 == 0) {
#line 294
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                    2)));
#line 294
                            if (__s2_len___0 > 2U) {
#line 294
                              if (__result___46 == 0) {
#line 294
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)cvd->md5) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 294
                    tmp___110 = __result___46;
                  }
                } else {
#line 294
                  tmp___110 = __builtin_strcmp(md5, cvd->md5);
                }
              } else {
#line 294
                tmp___110 = __builtin_strcmp(md5, cvd->md5);
              }
            } else {
#line 294
              tmp___110 = __builtin_strcmp(md5, cvd->md5);
            }
          }
        }
#line 294
        tmp___74 = tmp___110;
      } else {
#line 294
        tmp___74 = strncmp((char const   *)md5, (char const   *)cvd->md5, 32U);
      }
    } else {
#line 294
      tmp___74 = strncmp((char const   *)md5, (char const   *)cvd->md5, 32U);
    }
  }
#line 294
  if (tmp___74) {
#line 295
    cli_dbgmsg("MD5 verification error.\n");
#line 296
    free((void *)md5);
#line 297
    cl_cvdfree(cvd);
#line 298
    return (-10);
  }
#line 310
  free((void *)md5);
#line 311
  cl_cvdfree(cvd);
#line 312
  return (0);
}
}
#line 315 "cvd.c"
int cl_cvdverify(char const   *file ) 
{ FILE *fd ;
  int ret ;

  {
#line 320
  fd = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 320
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
#line 321
    cli_errmsg("Can\'t open CVD file %s\n", file);
#line 322
    return (-4);
  }
#line 325
  ret = cli_cvdverify(fd, (struct cl_cvd *)((void *)0));
#line 326
  fclose(fd);
#line 328
  return (ret);
}
}
#line 331 "cvd.c"
int cli_cvdload(FILE *fd , struct cl_node **root , unsigned int *signo , short warn ) 
{ char *dir ;
  char *tmp ;
  char *buffer ;
  struct cl_cvd cvd ;
  int bytes ;
  int ret ;
  FILE *tmpd ;
  time_t stime___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 340
  cli_dbgmsg("in cli_cvdload()\n");
#line 344
  ret = cli_cvdverify(fd, & cvd);
#line 344
  if (ret) {
#line 345
    return (ret);
  }
#line 347
  if (cvd.stime) {
#line 347
    if (warn) {
#line 348
      time(& stime___0);
#line 349
      if ((int )stime___0 - cvd.stime > 604800) {
#line 350
        cli_warnmsg("**************************************************\n");
#line 351
        cli_warnmsg("***  The virus database is older than 7 days.  ***\n");
#line 352
        cli_warnmsg("***        Please update it IMMEDIATELY!       ***\n");
#line 353
        cli_warnmsg("**************************************************\n");
      }
    }
  }
#line 357
  tmp___0 = cl_retflevel();
#line 357
  if ((int )cvd.fl > tmp___0) {
#line 358
    cli_warnmsg("********************************************************\n");
#line 359
    cli_warnmsg("***  This version of the ClamAV engine is outdated.  ***\n");
#line 360
    cli_warnmsg("*** DON\'T PANIC! Read http://www.clamav.net/faq.html ***\n");
#line 361
    cli_warnmsg("********************************************************\n");
  }
#line 364
  fseek(fd, 512L, 0);
#line 366
  dir = cli_gentemp((char const   *)((void *)0));
#line 367
  tmp___1 = mkdir((char const   *)dir, 448U);
#line 367
  if (tmp___1) {
#line 368
    cli_errmsg("cli_cvdload():  Can\'t create temporary directory %s\n", dir);
#line 369
    return (-7);
  }
#line 385
  tmp = cli_gentemp((char const   *)((void *)0));
#line 386
  tmpd = fopen((char const   * __restrict  )tmp, (char const   * __restrict  )"wb+");
#line 386
  if ((unsigned int )tmpd == (unsigned int )((void *)0)) {
#line 387
    cli_errmsg("Can\'t create temporary file %s\n", tmp);
#line 388
    free((void *)dir);
#line 389
    free((void *)tmp);
#line 390
    return (-1);
  }
#line 393
  buffer = (char *)cli_malloc(8192U);
#line 393
  if (! buffer) {
#line 394
    free((void *)dir);
#line 395
    free((void *)tmp);
#line 396
    fclose(tmpd);
#line 397
    return (-3);
  }
#line 400
  while (1) {
#line 400
    bytes = (int )fread((void * __restrict  )buffer, 1U, 8192U, (FILE * __restrict  )fd);
#line 400
    if (! (bytes > 0)) {
#line 400
      break;
    }
#line 401
    fwrite((void const   * __restrict  )buffer, 1U, (unsigned int )bytes, (FILE * __restrict  )tmpd);
  }
#line 403
  free((void *)buffer);
#line 405
  fflush(tmpd);
#line 406
  fseek(tmpd, 0L, 0);
#line 408
  tmp___3 = fileno(tmpd);
#line 408
  tmp___4 = cli_untgz(tmp___3, (char const   *)dir);
#line 408
  if (tmp___4) {
#line 409
    perror("cli_untgz");
#line 410
    cli_errmsg("cli_cvdload(): Can\'t unpack CVD file.\n");
#line 411
    cli_rmdirs((char const   *)dir);
#line 412
    free((void *)dir);
#line 413
    fclose(tmpd);
#line 414
    unlink((char const   *)tmp);
#line 415
    free((void *)tmp);
#line 416
    return (-9);
  }
#line 419
  fclose(tmpd);
#line 420
  unlink((char const   *)tmp);
#line 421
  free((void *)tmp);
#line 426
  cl_loaddbdir((char const   *)dir, root, signo);
#line 428
  cli_rmdirs((char const   *)dir);
#line 429
  free((void *)dir);
#line 431
  return (0);
}
}
#line 1 "dsig.lo"
#pragma merger(0,"/tmp/cil-zn97rWTG.i","-g -O2 -fPIC")
#line 1 "str.lo"
#pragma merger(0,"/tmp/cil-YxYgX37I.i","-g -O2 -fPIC")
#line 28 "str.h"
char *cli_str2hex(char const   *string , unsigned int len ) ;
#line 29
char *cli_strtokbuf(char const   *input , int fieldno , char const   *delim , char *output ) ;
#line 30
char const   *cli_memstr(char const   *haystack , int hs , char const   *needle ,
                         int ns ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 325
 __attribute__((__nothrow__)) int strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 190 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower__extinline(int __c ) ;
#line 34 "str.c"
static int cli_hex2int(int c ) 
{ int l ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 36
  if (sizeof(c) > 1U) {
#line 36
    tmp___1 = __builtin_constant_p(c);
#line 36
    if (tmp___1) {
#line 36
      __c = c;
#line 36
      if (__c < -128) {
#line 36
        __res = __c;
      } else {
#line 36
        if (__c > 255) {
#line 36
          __res = __c;
        } else {
#line 36
          tmp___0 = __ctype_tolower_loc();
#line 36
          __res = (*((*tmp___0) + __c));
        }
      }
    } else {
#line 36
      __res = tolower__extinline(c);
    }
  } else {
#line 36
    tmp___2 = __ctype_tolower_loc();
#line 36
    __res = (*((*tmp___2) + c));
  }
#line 36
  l = __res;
#line 38
  if (! ((l & -128) == 0)) {
#line 39
    return (-1);
  }
#line 40
  tmp___3 = __ctype_b_loc();
#line 40
  if ((int const   )(*((*tmp___3) + l)) & 2048) {
#line 41
    return (l - 48);
  }
#line 42
  if (l >= 97) {
#line 42
    if (l <= 102) {
#line 43
      return ((l + 10) - 97);
    }
  }
#line 45
  cli_errmsg("hex2int() translation problem (%d)\n", l);
#line 46
  return (-1);
}
}
#line 49 "str.c"
short *cli_hex2si(char const   *hex___0 ) 
{ short *str ;
  short *ptr ;
  short val ;
  short c ;
  int i ;
  int len ;
  short *tmp ;

  {
#line 55
  len = (int )strlen(hex___0);
#line 57
  if (len % 2 != 0) {
#line 58
    cli_errmsg("cli_hex2si(): Malformed hexstring: %s (length: %d)\n", hex___0, len);
#line 59
    return ((short *)((void *)0));
  }
#line 62
  str = (short *)cli_calloc((unsigned int )(len / 2 + 1), sizeof(short ));
#line 63
  if (! str) {
#line 64
    return ((short *)((void *)0));
  }
#line 66
  ptr = str;
#line 68
  i = 0;
#line 68
  while (i < len) {
#line 69
    if ((int const   )(*(hex___0 + i)) == 63) {
#line 70
      val = (short)-200;
    } else {
#line 71
      if ((int const   )(*(hex___0 + i)) == 64) {
#line 72
        val = (short)-201;
      } else {
#line 74
        c = (short )cli_hex2int((int )(*(hex___0 + i)));
#line 74
        if ((int )c >= 0) {
#line 75
          val = c;
#line 76
          c = (short )cli_hex2int((int )(*(hex___0 + (i + 1))));
#line 76
          if ((int )c >= 0) {
#line 77
            val = (short )(((int )val << 4) + (int )c);
          } else {
#line 79
            free((void *)str);
#line 80
            return ((short *)((void *)0));
          }
        } else {
#line 83
          free((void *)str);
#line 84
          return ((short *)((void *)0));
        }
      }
    }
#line 87
    tmp = ptr;
#line 87
    ptr ++;
#line 87
    (*tmp) = val;
#line 68
    i += 2;
  }
#line 90
  return (str);
}
}
#line 93 "str.c"
char *cli_hex2str(char const   *hex___0 ) 
{ char *str ;
  char *ptr ;
  char val ;
  char c ;
  int i ;
  int len ;
  char *tmp ;

  {
#line 99
  len = (int )strlen(hex___0);
#line 101
  if (len % 2 != 0) {
#line 102
    cli_errmsg("cli_hex2str(): Malformed hexstring: %s (length: %d)\n", hex___0, len);
#line 103
    return ((char *)((void *)0));
  }
#line 106
  str = (char *)cli_calloc((unsigned int )(len / 2 + 1), sizeof(char ));
#line 107
  if (! str) {
#line 108
    return ((char *)((void *)0));
  }
#line 110
  ptr = str;
#line 112
  i = 0;
#line 112
  while (i < len) {
#line 113
    c = (char )cli_hex2int((int )(*(hex___0 + i)));
#line 113
    if ((int )c >= 0) {
#line 114
      val = c;
#line 115
      c = (char )cli_hex2int((int )(*(hex___0 + (i + 1))));
#line 115
      if ((int )c >= 0) {
#line 116
        val = (char )(((int )val << 4) + (int )c);
      } else {
#line 118
        free((void *)str);
#line 119
        return ((char *)((void *)0));
      }
    } else {
#line 122
      free((void *)str);
#line 123
      return ((char *)((void *)0));
    }
#line 126
    tmp = ptr;
#line 126
    ptr ++;
#line 126
    (*tmp) = val;
#line 112
    i += 2;
  }
#line 129
  return (str);
}
}
#line 132 "str.c"
int cli_hex2num(char const   *hex___0 ) 
{ int hexval ;
  int ret ;
  int len ;
  int i ;

  {
#line 134
  ret = 0;
#line 137
  len = (int )strlen(hex___0);
#line 139
  if (len % 2 != 0) {
#line 140
    cli_errmsg("cli_hex2num(): Malformed hexstring: %s (length: %d)\n", hex___0, len);
#line 141
    return (-1);
  }
#line 144
  i = 0;
#line 144
  while (i < len) {
#line 145
    hexval = cli_hex2int((int )(*(hex___0 + i)));
#line 145
    if (hexval < 0) {
#line 146
      break;
    }
#line 147
    ret = (ret << 4) | hexval;
#line 144
    i ++;
  }
#line 150
  return (ret);
}
}
#line 153 "str.c"
char *cli_str2hex(char const   *string , unsigned int len ) 
{ char *hexstr ;
  char HEX[16] ;
  unsigned int i ;
  unsigned int j ;

  {
#line 156
  HEX[0] = (char )'0';
#line 156
  HEX[1] = (char )'1';
#line 156
  HEX[2] = (char )'2';
#line 156
  HEX[3] = (char )'3';
#line 156
  HEX[4] = (char )'4';
#line 156
  HEX[5] = (char )'5';
#line 156
  HEX[6] = (char )'6';
#line 156
  HEX[7] = (char )'7';
#line 156
  HEX[8] = (char )'8';
#line 156
  HEX[9] = (char )'9';
#line 156
  HEX[10] = (char )'a';
#line 156
  HEX[11] = (char )'b';
#line 156
  HEX[12] = (char )'c';
#line 156
  HEX[13] = (char )'d';
#line 156
  HEX[14] = (char )'e';
#line 156
  HEX[15] = (char )'f';
#line 160
  hexstr = (char *)cli_calloc(2U * len + 1U, sizeof(char ));
#line 160
  if ((unsigned int )hexstr == (unsigned int )((void *)0)) {
#line 161
    return ((char *)((void *)0));
  }
#line 163
  i = 0U;
#line 163
  j = 0U;
#line 163
  while (i < len) {
#line 164
    (*(hexstr + j)) = HEX[((int const   )(*(string + i)) >> 4) & 15];
#line 165
    (*(hexstr + (j + 1U))) = HEX[(int const   )(*(string + i)) & 15];
#line 163
    i ++;
#line 163
    j += 2U;
  }
#line 168
  return (hexstr);
}
}
#line 171 "str.c"
int cli_strbcasestr(char const   *haystack , char const   *needle ) 
{ char *pt ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 173
  pt = (char *)haystack;
#line 176
  i = (int )strlen(haystack);
#line 177
  j = (int )strlen(needle);
#line 179
  if (i < j) {
#line 180
    return (0);
  }
#line 182
  pt += i - j;
#line 184
  tmp = strcasecmp((char const   *)pt, needle);
#line 184
  if (tmp) {
#line 184
    tmp___0 = 0;
  } else {
#line 184
    tmp___0 = 1;
  }
#line 184
  return (tmp___0);
}
}
#line 191 "str.c"
int cli_chomp(char *string ) 
{ int l ;
  int tmp ;

  {
#line 196
  if ((unsigned int )string == (unsigned int )((void *)0)) {
#line 197
    return (-1);
  }
#line 199
  l = (int )strlen((char const   *)string);
#line 201
  if (l == 0) {
#line 202
    return (0);
  }
#line 204
  l --;
#line 206
  while (1) {
#line 206
    if (l >= 0) {
#line 206
      if (! ((int )(*(string + l)) == 10)) {
#line 206
        if (! ((int )(*(string + l)) == 13)) {
#line 206
          break;
        }
      }
    } else {
#line 206
      break;
    }
#line 207
    tmp = l;
#line 207
    l --;
#line 207
    (*(string + tmp)) = (char )'\000';
  }
#line 209
  return (l + 1);
}
}
#line 219 "str.c"
char *cli_strtok(char const   *line , int fieldno , char const   *delim ) 
{ int counter ;
  int i ;
  int j ;
  char *buffer ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 221
  counter = 0;
#line 222
  buffer = (char *)((void *)0);
#line 226
  i = 0;
#line 226
  while (1) {
#line 226
    if ((*(line + i))) {
#line 226
      if (! (counter != fieldno)) {
#line 226
        break;
      }
    } else {
#line 226
      break;
    }
#line 227
    tmp___13 = __builtin_constant_p((int )(*(line + i)));
#line 227
    if (tmp___13) {
#line 227
      tmp___14 = __builtin_constant_p((int )delim);
#line 227
      if (tmp___14) {
#line 227
        tmp___11 = (char *)__builtin_strchr(delim, (*(line + i)));
      } else {
#line 227
        if ((int const   )(*(line + i)) == 0) {
#line 227
          tmp___11 = (char *)__rawmemchr((void const   *)delim, (int )(*(line + i)));
        } else {
#line 227
          tmp___11 = (char *)__builtin_strchr(delim, (*(line + i)));
        }
      }
    } else {
#line 227
      tmp___11 = (char *)__builtin_strchr(delim, (*(line + i)));
    }
#line 227
    if (tmp___11) {
#line 228
      counter ++;
#line 229
      while (1) {
#line 229
        if ((*(line + (i + 1)))) {
#line 229
          tmp___5 = __builtin_constant_p((int )(*(line + (i + 1))));
#line 229
          if (tmp___5) {
#line 229
            tmp___6 = __builtin_constant_p((int )delim);
#line 229
            if (tmp___6) {
#line 229
              tmp___3 = (char *)__builtin_strchr(delim, (*(line + (i + 1))));
            } else {
#line 229
              if ((int const   )(*(line + (i + 1))) == 0) {
#line 229
                tmp___3 = (char *)__rawmemchr((void const   *)delim, (int )(*(line +
                                                                              (i +
                                                                               1))));
              } else {
#line 229
                tmp___3 = (char *)__builtin_strchr(delim, (*(line + (i + 1))));
              }
            }
          } else {
#line 229
            tmp___3 = (char *)__builtin_strchr(delim, (*(line + (i + 1))));
          }
#line 229
          if (! tmp___3) {
#line 229
            break;
          }
        } else {
#line 229
          break;
        }
#line 230
        i ++;
      }
    }
#line 226
    i ++;
  }
#line 234
  if (! (*(line + i))) {
#line 236
    return ((char *)((void *)0));
  }
#line 239
  j = i;
#line 239
  while ((*(line + j))) {
#line 240
    tmp___21 = __builtin_constant_p((int )(*(line + j)));
#line 240
    if (tmp___21) {
#line 240
      tmp___22 = __builtin_constant_p((int )delim);
#line 240
      if (tmp___22) {
#line 240
        tmp___19 = (char *)__builtin_strchr(delim, (*(line + j)));
      } else {
#line 240
        if ((int const   )(*(line + j)) == 0) {
#line 240
          tmp___19 = (char *)__rawmemchr((void const   *)delim, (int )(*(line + j)));
        } else {
#line 240
          tmp___19 = (char *)__builtin_strchr(delim, (*(line + j)));
        }
      }
    } else {
#line 240
      tmp___19 = (char *)__builtin_strchr(delim, (*(line + j)));
    }
#line 240
    if (tmp___19) {
#line 241
      break;
    }
#line 239
    j ++;
  }
#line 244
  if (i == j) {
#line 245
    return ((char *)((void *)0));
  }
#line 247
  buffer = (char *)malloc((unsigned int )((j - i) + 1));
#line 248
  if (! buffer) {
#line 249
    return ((char *)((void *)0));
  }
#line 250
  __builtin_strncpy(buffer, line + i, j - i);
#line 251
  (*(buffer + (j - i))) = (char )'\000';
#line 253
  return (buffer);
}
}
#line 262 "str.c"
char *cli_strtokbuf(char const   *input , int fieldno , char const   *delim , char *output ) 
{ int counter ;
  int i ;
  int j ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 264
  counter = 0;
#line 267
  i = 0;
#line 267
  while (1) {
#line 267
    if ((*(input + i))) {
#line 267
      if (! (counter != fieldno)) {
#line 267
        break;
      }
    } else {
#line 267
      break;
    }
#line 268
    tmp___13 = __builtin_constant_p((int )(*(input + i)));
#line 268
    if (tmp___13) {
#line 268
      tmp___14 = __builtin_constant_p((int )delim);
#line 268
      if (tmp___14) {
#line 268
        tmp___11 = (char *)__builtin_strchr(delim, (*(input + i)));
      } else {
#line 268
        if ((int const   )(*(input + i)) == 0) {
#line 268
          tmp___11 = (char *)__rawmemchr((void const   *)delim, (int )(*(input + i)));
        } else {
#line 268
          tmp___11 = (char *)__builtin_strchr(delim, (*(input + i)));
        }
      }
    } else {
#line 268
      tmp___11 = (char *)__builtin_strchr(delim, (*(input + i)));
    }
#line 268
    if (tmp___11) {
#line 269
      counter ++;
#line 270
      while (1) {
#line 270
        if ((*(input + (i + 1)))) {
#line 270
          tmp___5 = __builtin_constant_p((int )(*(input + (i + 1))));
#line 270
          if (tmp___5) {
#line 270
            tmp___6 = __builtin_constant_p((int )delim);
#line 270
            if (tmp___6) {
#line 270
              tmp___3 = (char *)__builtin_strchr(delim, (*(input + (i + 1))));
            } else {
#line 270
              if ((int const   )(*(input + (i + 1))) == 0) {
#line 270
                tmp___3 = (char *)__rawmemchr((void const   *)delim, (int )(*(input +
                                                                              (i +
                                                                               1))));
              } else {
#line 270
                tmp___3 = (char *)__builtin_strchr(delim, (*(input + (i + 1))));
              }
            }
          } else {
#line 270
            tmp___3 = (char *)__builtin_strchr(delim, (*(input + (i + 1))));
          }
#line 270
          if (! tmp___3) {
#line 270
            break;
          }
        } else {
#line 270
          break;
        }
#line 271
        i ++;
      }
    }
#line 267
    i ++;
  }
#line 275
  if ((int const   )(*(input + i)) == 0) {
#line 277
    return ((char *)((void *)0));
  }
#line 280
  j = i;
#line 280
  while ((*(input + j))) {
#line 281
    tmp___21 = __builtin_constant_p((int )(*(input + j)));
#line 281
    if (tmp___21) {
#line 281
      tmp___22 = __builtin_constant_p((int )delim);
#line 281
      if (tmp___22) {
#line 281
        tmp___19 = (char *)__builtin_strchr(delim, (*(input + j)));
      } else {
#line 281
        if ((int const   )(*(input + j)) == 0) {
#line 281
          tmp___19 = (char *)__rawmemchr((void const   *)delim, (int )(*(input + j)));
        } else {
#line 281
          tmp___19 = (char *)__builtin_strchr(delim, (*(input + j)));
        }
      }
    } else {
#line 281
      tmp___19 = (char *)__builtin_strchr(delim, (*(input + j)));
    }
#line 281
    if (tmp___19) {
#line 282
      break;
    }
#line 280
    j ++;
  }
#line 285
  if (i == j) {
#line 286
    return ((char *)((void *)0));
  }
#line 288
  __builtin_strncpy(output, input + i, j - i);
#line 289
  (*(output + (j - i))) = (char )'\000';
#line 291
  return (output);
}
}
#line 294 "str.c"
char const   *cli_memstr(char const   *haystack , int hs , char const   *needle ,
                         int ns ) 
{ char const   *pt ;
  char const   *hay ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 300
  if (hs < ns) {
#line 301
    return ((char const   *)((void *)0));
  }
#line 303
  if ((unsigned int )haystack == (unsigned int )needle) {
#line 304
    return (haystack);
  }
#line 306
  tmp = memcmp((void const   *)haystack, (void const   *)needle, (unsigned int )ns);
#line 306
  if (! tmp) {
#line 307
    return (haystack);
  }
#line 309
  hay = haystack;
#line 309
  pt = hay;
#line 310
  n = hs;
#line 312
  while (1) {
#line 312
    pt = (char const   *)memchr((void const   *)hay, (int )(*(needle + 0)), (unsigned int )n);
#line 312
    if (! ((unsigned int )pt != (unsigned int )((void *)0))) {
#line 312
      break;
    }
#line 313
    n -= pt - hay;
#line 314
    if (n < ns) {
#line 315
      break;
    }
#line 317
    tmp___0 = memcmp((void const   *)pt, (void const   *)needle, (unsigned int )ns);
#line 317
    if (! tmp___0) {
#line 318
      return (pt);
    }
#line 320
    if ((unsigned int )hay == (unsigned int )pt) {
#line 321
      n --;
#line 322
      hay ++;
    } else {
#line 324
      hay = pt;
    }
  }
#line 328
  return ((char const   *)((void *)0));
}
}
#line 1 "scanners.lo"
#pragma merger(0,"/tmp/cil-e2Oc3xD8.i","-g -O2 -fPIC")
#line 166 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 353
extern  __attribute__((__nothrow__)) int snprintf(char * __restrict  __s , size_t __maxlen ,
                                                  char const   * __restrict  __format 
                                                  , ...) ;
#line 869 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 480 "mspack/mspack.h"
struct mscab_decompressor *mspack_create_cab_decompressor(struct mspack_system *sys ) ;
#line 491
void mspack_destroy_cab_decompressor(struct mscab_decompressor *base ) ;
#line 614 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) void _pthread_cleanup_push(struct _pthread_cleanup_buffer *__buffer ,
                                                                void (*__routine)(void * ) ,
                                                                void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void _pthread_cleanup_pop(struct _pthread_cleanup_buffer *__buffer ,
                                                               int __execute ) ;
#line 47 "scanners.c"
struct __anonstruct_pthread_mutex_t_16 cli_scanrar_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
#line 49 "scanners.c"
int cli_scanrar_inuse  =    0;
#line 53
int cli_mbox(char const   *dir , int desc , unsigned int options ) ;
#line 187 "clamav.h"
int cl_scandesc(int desc , char const   **virname , unsigned long *scanned , struct cl_node  const  *root ,
                struct cl_limits  const  *limits , unsigned int options ) ;
#line 189
int cl_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                struct cl_node  const  *root , struct cl_limits  const  *limits ,
                unsigned int options ) ;
#line 24 "scanners.h"
int cli_magic_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) ;
#line 162 "unrarlib.h"
int urarlib_get(void *output , unsigned long *size , char *filename , int desc , char *libpassword ) ;
#line 182
int urarlib_list(int desc , ArchiveList_struct *list ) ;
#line 194
void urarlib_freelist(ArchiveList_struct *list ) ;
#line 28 "ole2_extract.h"
int cli_ole2_extract(int fd , char const   *dirname , struct cl_limits  const  *limits ) ;
#line 37 "vba_extract.h"
vba_project_t *vba56_dir_read(char const   *dir ) ;
#line 38
unsigned char *vba_decompress(int fd , uint32_t offset , int *size ) ;
#line 40
char *ppt_vba_read(char const   *dir ) ;
#line 42
vba_project_t *wm_dir_read(char const   *dir ) ;
#line 43
unsigned char *wm_decrypt_macro(int fd , uint32_t offset , uint32_t len , unsigned char key ) ;
#line 24 "msexpand.h"
int cli_msexpand(FILE *in , FILE *out ) ;
#line 24 "chmunpack.h"
int chm_unpack(int fd , char const   *dirname ) ;
#line 103 "pe.h"
int cli_scanpe(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
               struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
               unsigned int mrec ) ;
#line 54 "filetypes.h"
cli_file_t cli_filetype2(int desc ) ;
#line 30 "htmlnorm.h"
int html_normalise_fd(int fd , char const   *dirname , tag_arguments_t *hrefs ) ;
#line 32
int html_screnc_decode(int fd , char const   *dirname ) ;
#line 30 "untar.h"
int cli_untar(char const   *dir , int desc , unsigned int posix ) ;
#line 22 "special.h"
int cli_check_mydoom_log(int desc , char const   **virname ) ;
#line 23
int cli_check_jpeg_exploit(int fd ) ;
#line 24
int cli_check_riff_exploit(int fd ) ;
#line 31 "binhex.h"
int cli_binhex(char const   *dir , int desc ) ;
#line 157 "zziplib/zziplib.h"
ZZIP_DIR *zzip_dir_fdopen(int fd , zzip_error_t *errcode_p ) ;
#line 161
int zzip_dir_close(ZZIP_DIR *dir ) ;
#line 163
int zzip_dir_read(ZZIP_DIR *dir , ZZIP_DIRENT *d ) ;
#line 189
ZZIP_FILE *zzip_file_open(ZZIP_DIR *dir , zzip_char_t *name , int o_mode ) ;
#line 191
int zzip_file_close(ZZIP_FILE *fp ) ;
#line 193
zzip_ssize_t zzip_file_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) ;
#line 179 "/usr/include/bzlib.h"
extern BZFILE *BZ2_bzReadOpen(int *bzerror , FILE *f , int verbosity , int small ,
                              void *unused , int nUnused ) ;
#line 188
extern void BZ2_bzReadClose(int *bzerror , BZFILE *b ) ;
#line 200
extern int BZ2_bzRead(int *bzerror , BZFILE *b , void *buf , int len ) ;
#line 111 "scanners.c"
static int cli_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                        struct cl_node  const  *root , struct cl_limits  const  *limits ,
                        unsigned int options , unsigned int arec , unsigned int mrec ) ;
#line 115 "scanners.c"
static void cli_unlock_mutex(void *mtx ) 
{ 

  {
#line 117
  cli_dbgmsg("Pthread cancelled. Unlocking mutex.\n");
#line 118
  pthread_mutex_unlock((pthread_mutex_t *)mtx);
#line 119
  return;
}
}
#line 122 "scanners.c"
static int cli_scanrar(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) 
{ FILE *tmp ;
  int fd ;
  int ret ;
  unsigned int files ;
  unsigned int encrypted ;
  unsigned int afiles ;
  ArchiveList_struct *rarlist ;
  ArchiveList_struct *rarlist_head ;
  char *rar_data_ptr ;
  unsigned long rar_data_size ;
  struct cli_meta_node *mdata ;
  struct _pthread_cleanup_buffer _buffer ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;

  {
#line 124
  tmp = (FILE *)((void *)0);
#line 125
  ret = 0;
#line 126
  files = 0U;
#line 127
  rarlist = (ArchiveList_struct *)((void *)0);
#line 128
  rarlist_head = (ArchiveList_struct *)((void *)0);
#line 134
  cli_dbgmsg("in scanrar()\n");
#line 137
  _pthread_cleanup_push(& _buffer, & cli_unlock_mutex, (void *)(& cli_scanrar_mutex));
#line 138
  pthread_mutex_lock(& cli_scanrar_mutex);
#line 139
  cli_scanrar_inuse = 1;
#line 142
  afiles = (unsigned int )urarlib_list(desc, (ArchiveList_struct *)(& rarlist));
#line 142
  if (! afiles) {
#line 144
    pthread_mutex_unlock(& cli_scanrar_mutex);
#line 145
    cli_scanrar_inuse = 0;
#line 147
    return (100);
  }
#line 150
  cli_dbgmsg("RAR: Number of archived files: %d\n", afiles);
#line 152
  rarlist_head = rarlist;
#line 154
  while (rarlist) {
#line 156
    files ++;
#line 157
    encrypted = (unsigned int )((int )rarlist->item.Flags & 4);
#line 159
    if (limits) {
#line 159
      tmp___0 = limits->maxratio;
    } else {
#line 159
      tmp___0 = 0U;
    }
#line 159
    if (rarlist->item.PackSize) {
#line 159
      tmp___1 = (unsigned int )rarlist->item.UnpSize / (unsigned int )rarlist->item.PackSize;
    } else {
#line 159
      tmp___1 = 0U;
    }
#line 159
    cli_dbgmsg("RAR: %s, crc32: 0x%x, encrypted: %d, compressed: %u, normal: %u, method: %d, ratio: %d (max: %d)\n",
               rarlist->item.Name, rarlist->item.FileCRC, encrypted, rarlist->item.PackSize,
               rarlist->item.UnpSize, rarlist->item.Method, tmp___1, tmp___0);
#line 162
    mdata = root->rar_mlist;
#line 163
    if (mdata) {
#line 163
      while (1) {
#line 164
        if (mdata->encrypted != encrypted) {
          goto __Cont;
        }
#line 167
        if (mdata->crc32) {
#line 167
          if ((unsigned long )mdata->crc32 != rarlist->item.FileCRC) {
            goto __Cont;
          }
        }
#line 170
        if (mdata->csize > 0) {
#line 170
          if ((unsigned long )((unsigned int )mdata->csize) != rarlist->item.PackSize) {
            goto __Cont;
          }
        }
#line 173
        if (mdata->size >= 0) {
#line 173
          if ((unsigned long )((unsigned int )mdata->size) != rarlist->item.UnpSize) {
            goto __Cont;
          }
        }
#line 176
        if (mdata->method >= 0) {
#line 176
          if (mdata->method != (int )rarlist->item.Method) {
            goto __Cont;
          }
        }
#line 179
        if (mdata->fileno) {
#line 179
          if (mdata->fileno != files) {
            goto __Cont;
          }
        }
#line 182
        if (mdata->maxdepth) {
#line 182
          if (arec > mdata->maxdepth) {
            goto __Cont;
          }
        }
#line 187
        if (mdata->filename) {
#line 187
          tmp___68 = __builtin_constant_p((int )rarlist->item.Name);
#line 187
          if (tmp___68) {
#line 187
            tmp___69 = __builtin_constant_p((int )mdata->filename);
#line 187
            if (tmp___69) {
#line 187
              __s1_len = strlen((char const   *)rarlist->item.Name);
#line 187
              __s2_len = strlen((char const   *)mdata->filename);
#line 187
              if (! ((unsigned int )((void const   *)(rarlist->item.Name + 1)) - (unsigned int )((void const   *)rarlist->item.Name) ==
                     1U)) {
                goto _L___16;
              } else {
#line 187
                if (__s1_len >= 4U) {
                  _L___16: 
#line 187
                  if (! ((unsigned int )((void const   *)(mdata->filename + 1)) -
                         (unsigned int )((void const   *)mdata->filename) == 1U)) {
#line 187
                    tmp___70 = 1;
                  } else {
#line 187
                    if (__s2_len >= 4U) {
#line 187
                      tmp___70 = 1;
                    } else {
#line 187
                      tmp___70 = 0;
                    }
                  }
                } else {
#line 187
                  tmp___70 = 0;
                }
              }
#line 187
              if (tmp___70) {
#line 187
                tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
#line 187
            tmp___67 = __builtin_constant_p((int )rarlist->item.Name);
#line 187
            if (tmp___67) {
#line 187
              if ((unsigned int )((void const   *)(rarlist->item.Name + 1)) - (unsigned int )((void const   *)rarlist->item.Name) ==
                  1U) {
#line 187
                __s1_len = strlen((char const   *)rarlist->item.Name);
#line 187
                if (__s1_len < 4U) {
#line 187
                  tmp___56 = __builtin_constant_p((int )mdata->filename);
#line 187
                  if (tmp___56) {
#line 187
                    if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                        1U) {
#line 187
                      tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
#line 187
                    __s2___6 = (unsigned char const   *)((char const   *)mdata->filename);
#line 187
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
#line 187
                    if (__s1_len > 0U) {
#line 187
                      if (__result___18 == 0) {
#line 187
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
#line 187
                        if (__s1_len > 1U) {
#line 187
                          if (__result___18 == 0) {
#line 187
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
#line 187
                            if (__s1_len > 2U) {
#line 187
                              if (__result___18 == 0) {
#line 187
                                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)rarlist->item.Name) +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 187
                    tmp___37 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
#line 187
              tmp___66 = __builtin_constant_p((int )mdata->filename);
#line 187
              if (tmp___66) {
#line 187
                if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                    1U) {
#line 187
                  __s2_len = strlen((char const   *)mdata->filename);
#line 187
                  if (__s2_len < 4U) {
#line 187
                    tmp___65 = __builtin_constant_p((int )rarlist->item.Name);
#line 187
                    if (tmp___65) {
#line 187
                      if ((unsigned int )((void const   *)(rarlist->item.Name + 1)) -
                          (unsigned int )((void const   *)rarlist->item.Name) == 1U) {
#line 187
                        tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
#line 187
                      __s1___14 = (unsigned char const   *)((char const   *)rarlist->item.Name);
#line 187
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 0)));
#line 187
                      if (__s2_len > 0U) {
#line 187
                        if (__result___22 == 0) {
#line 187
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                  1)));
#line 187
                          if (__s2_len > 1U) {
#line 187
                            if (__result___22 == 0) {
#line 187
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                             2)));
#line 187
                              if (__s2_len > 2U) {
#line 187
                                if (__result___22 == 0) {
#line 187
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 187
                      tmp___37 = __result___22;
                    }
                  } else {
#line 187
                    tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                  }
                } else {
#line 187
                  tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
                }
              } else {
#line 187
                tmp___37 = __builtin_strcmp(rarlist->item.Name, mdata->filename);
              }
            }
          }
#line 187
          if (tmp___37) {
            goto __Cont;
          }
        }
#line 190
        break;
        __Cont: 
#line 163
        mdata = mdata->next;
#line 163
        if (! mdata) {
#line 163
          break;
        }
      }
    }
#line 194
    if (mdata) {
#line 195
      (*virname) = (char const   *)mdata->virname;
#line 196
      ret = 1;
#line 197
      break;
    }
#line 200
    if (options & 16U) {
#line 200
      if ((int )rarlist->item.Flags & 4) {
#line 201
        cli_dbgmsg("RAR: Encrypted files found in archive.\n");
#line 202
        lseek(desc, 0L, 0);
#line 203
        ret = cli_scandesc(desc, virname, scanned, root, (short)0, (unsigned short)0);
#line 204
        if (ret < 0) {
#line 205
          break;
        } else {
#line 206
          if (ret != 1) {
#line 207
            (*virname) = "Encrypted.RAR";
#line 208
            ret = 1;
          }
        }
#line 210
        break;
      }
    }
#line 213
    if (((int )rarlist->item.Flags & 3) != 0) {
#line 214
      cli_dbgmsg("RAR: Skipping %s (splitted)\n", rarlist->item.Name);
#line 215
      rarlist = rarlist->next;
#line 216
      continue;
    }
#line 219
    if (limits) {
#line 221
      if (limits->maxratio) {
#line 221
        if (rarlist->item.UnpSize) {
#line 221
          if (rarlist->item.PackSize) {
#line 222
            if ((unsigned int )rarlist->item.UnpSize / (unsigned int )rarlist->item.PackSize >=
                limits->maxratio) {
#line 223
              cli_dbgmsg("RAR: Max ratio reached (normal: %d, compressed: %d, max: %ld)\n",
                         (int )rarlist->item.UnpSize, (int )rarlist->item.PackSize,
                         limits->maxratio);
#line 224
              (*virname) = "Oversized.RAR";
#line 225
              ret = 1;
#line 226
              break;
            }
          }
        }
      }
#line 230
      if (limits->maxfilesize) {
#line 230
        if (rarlist->item.UnpSize > (unsigned long )((unsigned int )limits->maxfilesize)) {
#line 231
          cli_dbgmsg("RAR: %s: Size exceeded (%u, max: %lu)\n", rarlist->item.Name,
                     (unsigned int )rarlist->item.UnpSize, limits->maxfilesize);
#line 232
          rarlist = rarlist->next;
#line 233
          if (options & 512U) {
#line 234
            (*virname) = "RAR.ExceededFileSize";
#line 235
            ret = 1;
#line 236
            break;
          }
#line 238
          continue;
        }
      }
#line 241
      if (limits->maxfiles) {
#line 241
        if (files > limits->maxfiles) {
#line 242
          cli_dbgmsg("RAR: Files limit reached (max: %d)\n", limits->maxfiles);
#line 243
          if (options & 512U) {
#line 244
            (*virname) = "RAR.ExceededFilesLimit";
#line 245
            ret = 1;
#line 246
            break;
          }
#line 248
          break;
        }
      }
    }
#line 252
    if (rarlist->item.FileAttr & 16400UL) {
#line 253
      rarlist = rarlist->next;
#line 254
      continue;
    }
#line 257
    tmp = tmpfile();
#line 257
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 258
      cli_dbgmsg("RAR: Can\'t generate temporary file.\n");
#line 260
      pthread_mutex_unlock(& cli_scanrar_mutex);
#line 261
      cli_scanrar_inuse = 0;
#line 263
      return (-1);
    }
#line 265
    fd = fileno(tmp);
#line 267
    tmp___75 = urarlib_get((void *)(& rar_data_ptr), & rar_data_size, rarlist->item.Name,
                           desc, (char *)"clam");
#line 267
    if (tmp___75) {
#line 268
      cli_dbgmsg("RAR: Extracted: %s, size: %lu\n", rarlist->item.Name, rar_data_size);
#line 269
      tmp___71 = fwrite((void const   * __restrict  )rar_data_ptr, 1U, (unsigned int )rar_data_size,
                        (FILE * __restrict  )tmp);
#line 269
      if ((unsigned long )tmp___71 != rar_data_size) {
#line 270
        cli_dbgmsg("RAR: Can\'t write to file.\n");
#line 271
        fclose(tmp);
#line 272
        tmp = (FILE *)((void *)0);
#line 273
        ret = 100;
#line 274
        if (rar_data_ptr) {
#line 275
          free((void *)rar_data_ptr);
#line 276
          rar_data_ptr = (char *)((void *)0);
        }
#line 278
        break;
      }
#line 281
      if (rar_data_ptr) {
#line 282
        free((void *)rar_data_ptr);
#line 283
        rar_data_ptr = (char *)((void *)0);
      }
#line 285
      tmp___74 = fflush(tmp);
#line 285
      if (tmp___74 != 0) {
#line 286
        tmp___72 = __errno_location();
#line 286
        tmp___73 = strerror((*tmp___72));
#line 286
        cli_dbgmsg("RAR: fflush() failed: %s\n", tmp___73);
#line 287
        fclose(tmp);
#line 288
        urarlib_freelist(rarlist_head);
#line 290
        pthread_mutex_unlock(& cli_scanrar_mutex);
#line 291
        cli_scanrar_inuse = 0;
#line 293
        return (-2);
      }
#line 296
      lseek(fd, 0L, 0);
#line 297
      ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec,
                               mrec);
#line 297
      if (ret == 1) {
#line 298
        cli_dbgmsg("RAR: Infected with %s\n", (*virname));
#line 300
        fclose(tmp);
#line 301
        urarlib_freelist(rarlist);
#line 303
        pthread_mutex_unlock(& cli_scanrar_mutex);
#line 304
        cli_scanrar_inuse = 0;
#line 306
        return (ret);
      }
    } else {
#line 310
      cli_dbgmsg("RAR: Can\'t decompress file %s\n", rarlist->item.Name);
#line 311
      fclose(tmp);
#line 312
      tmp = (FILE *)((void *)0);
#line 313
      ret = 100;
#line 314
      break;
    }
#line 317
    fclose(tmp);
#line 318
    tmp = (FILE *)((void *)0);
#line 319
    rarlist = rarlist->next;
  }
#line 322
  urarlib_freelist(rarlist_head);
#line 324
  pthread_mutex_unlock(& cli_scanrar_mutex);
#line 325
  cli_scanrar_inuse = 0;
#line 326
  _pthread_cleanup_pop(& _buffer, 0);
#line 329
  cli_dbgmsg("RAR: Exit code: %d\n", ret);
#line 331
  return (ret);
}
}
#line 335 "scanners.c"
static int cli_scanzip(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) 
{ ZZIP_DIR *zdir ;
  ZZIP_DIRENT zdirent ;
  ZZIP_FILE *zfp ;
  FILE *tmp ;
  char *buff ;
  int fd ;
  int bytes ;
  int ret ;
  unsigned long size ;
  unsigned int files ;
  unsigned int encrypted ;
  struct stat source ;
  struct cli_meta_node *mdata ;
  zzip_error_t err ;
  int tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___41 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___60 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  size_t tmp___75 ;
  size_t tmp___76 ;
  int *tmp___77 ;
  char *tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;

  {
#line 340
  tmp = (FILE *)((void *)0);
#line 342
  ret = 0;
#line 343
  size = 0UL;
#line 344
  files = 0U;
#line 350
  cli_dbgmsg("in scanzip()\n");
#line 352
  tmp___0 = dup(desc);
#line 352
  zdir = zzip_dir_fdopen(tmp___0, & err);
#line 352
  if ((unsigned int )zdir == (unsigned int )((void *)0)) {
#line 353
    cli_dbgmsg("Zip: Not supported file format ?.\n");
#line 354
    cli_dbgmsg("Zip: zzip_dir_fdopen() return code: %d\n", err);
#line 356
    return (0);
  }
#line 359
  fstat__extinline(desc, & source);
#line 361
  buff = (char *)cli_malloc(8192U);
#line 361
  if (! buff) {
#line 362
    cli_dbgmsg("Zip: unable to malloc(%d)\n", 8192);
#line 363
    zzip_dir_close(zdir);
#line 364
    return (-3);
  }
#line 367
  while (1) {
#line 367
    tmp___80 = zzip_dir_read(zdir, & zdirent);
#line 367
    if (! tmp___80) {
#line 367
      break;
    }
#line 368
    files ++;
#line 370
    if (! zdirent.d_name) {
#line 371
      tmp___2 = strlen((char const   *)zdirent.d_name);
#line 371
      cli_dbgmsg("Zip: strlen(zdirent.d_name) == %d\n", tmp___2);
#line 372
      (*virname) = "Suspect.Zip";
#line 373
      ret = 1;
#line 374
      break;
    } else {
#line 370
      tmp___3 = strlen((char const   *)zdirent.d_name);
#line 370
      if (! tmp___3) {
#line 371
        tmp___2 = strlen((char const   *)zdirent.d_name);
#line 371
        cli_dbgmsg("Zip: strlen(zdirent.d_name) == %d\n", tmp___2);
#line 372
        (*virname) = "Suspect.Zip";
#line 373
        ret = 1;
#line 374
        break;
      }
    }
#line 381
    encrypted = (unsigned int )((int )zdirent.d_flags & 1);
#line 383
    if (limits) {
#line 383
      tmp___4 = limits->maxratio;
    } else {
#line 383
      tmp___4 = 0U;
    }
#line 383
    if (zdirent.d_csize) {
#line 383
      tmp___5 = zdirent.st_size / zdirent.d_csize;
    } else {
#line 383
      tmp___5 = 0;
    }
#line 383
    cli_dbgmsg("Zip: %s, crc32: 0x%x, encrypted: %d, compressed: %u, normal: %u, method: %d, ratio: %d (max: %d)\n",
               zdirent.d_name, zdirent.d_crc32, encrypted, zdirent.d_csize, zdirent.st_size,
               zdirent.d_compr, tmp___5, tmp___4);
#line 385
    if (! zdirent.st_size) {
#line 386
      if (zdirent.d_crc32) {
#line 387
        cli_dbgmsg("Zip: Broken file or modified information in local header part of archive\n");
#line 388
        (*virname) = "Exploit.Zip.ModifiedHeaders";
#line 389
        ret = 1;
#line 390
        break;
      }
#line 392
      continue;
    }
#line 396
    mdata = root->zip_mlist;
#line 397
    if (mdata) {
#line 397
      while (1) {
#line 398
        if (mdata->encrypted != encrypted) {
          goto __Cont;
        }
#line 401
        if (mdata->crc32) {
#line 401
          if (mdata->crc32 != (unsigned int )zdirent.d_crc32) {
            goto __Cont;
          }
        }
#line 404
        if (mdata->csize > 0) {
#line 404
          if (mdata->csize != zdirent.d_csize) {
            goto __Cont;
          }
        }
#line 407
        if (mdata->size >= 0) {
#line 407
          if (mdata->size != zdirent.st_size) {
            goto __Cont;
          }
        }
#line 410
        if (mdata->method >= 0) {
#line 410
          if ((unsigned int )mdata->method != (unsigned int )zdirent.d_compr) {
            goto __Cont;
          }
        }
#line 413
        if (mdata->fileno) {
#line 413
          if (mdata->fileno != files) {
            goto __Cont;
          }
        }
#line 416
        if (mdata->maxdepth) {
#line 416
          if (arec > mdata->maxdepth) {
            goto __Cont;
          }
        }
#line 421
        if (mdata->filename) {
#line 421
          tmp___72 = __builtin_constant_p((int )zdirent.d_name);
#line 421
          if (tmp___72) {
#line 421
            tmp___73 = __builtin_constant_p((int )mdata->filename);
#line 421
            if (tmp___73) {
#line 421
              __s1_len = strlen((char const   *)zdirent.d_name);
#line 421
              __s2_len = strlen((char const   *)mdata->filename);
#line 421
              if (! ((unsigned int )((void const   *)(zdirent.d_name + 1)) - (unsigned int )((void const   *)zdirent.d_name) ==
                     1U)) {
                goto _L___16;
              } else {
#line 421
                if (__s1_len >= 4U) {
                  _L___16: 
#line 421
                  if (! ((unsigned int )((void const   *)(mdata->filename + 1)) -
                         (unsigned int )((void const   *)mdata->filename) == 1U)) {
#line 421
                    tmp___74 = 1;
                  } else {
#line 421
                    if (__s2_len >= 4U) {
#line 421
                      tmp___74 = 1;
                    } else {
#line 421
                      tmp___74 = 0;
                    }
                  }
                } else {
#line 421
                  tmp___74 = 0;
                }
              }
#line 421
              if (tmp___74) {
#line 421
                tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: 
#line 421
            tmp___71 = __builtin_constant_p((int )zdirent.d_name);
#line 421
            if (tmp___71) {
#line 421
              if ((unsigned int )((void const   *)(zdirent.d_name + 1)) - (unsigned int )((void const   *)zdirent.d_name) ==
                  1U) {
#line 421
                __s1_len = strlen((char const   *)zdirent.d_name);
#line 421
                if (__s1_len < 4U) {
#line 421
                  tmp___60 = __builtin_constant_p((int )mdata->filename);
#line 421
                  if (tmp___60) {
#line 421
                    if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                        1U) {
#line 421
                      tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                    } else {
                      goto _L___11;
                    }
                  } else {
                    _L___11: 
#line 421
                    __s2___6 = (unsigned char const   *)((char const   *)mdata->filename);
#line 421
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                            0)) - (int const   )(*(__s2___6 +
                                                                                   0)));
#line 421
                    if (__s1_len > 0U) {
#line 421
                      if (__result___18 == 0) {
#line 421
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                                1)) - (int const   )(*(__s2___6 +
                                                                                       1)));
#line 421
                        if (__s1_len > 1U) {
#line 421
                          if (__result___18 == 0) {
#line 421
                            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                                    2)) - (int const   )(*(__s2___6 +
                                                                                           2)));
#line 421
                            if (__s1_len > 2U) {
#line 421
                              if (__result___18 == 0) {
#line 421
                                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)zdirent.d_name) +
                                                                        3)) - (int const   )(*(__s2___6 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 421
                    tmp___41 = __result___18;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                goto _L___15;
              }
            } else {
              _L___15: 
#line 421
              tmp___70 = __builtin_constant_p((int )mdata->filename);
#line 421
              if (tmp___70) {
#line 421
                if ((unsigned int )((void const   *)(mdata->filename + 1)) - (unsigned int )((void const   *)mdata->filename) ==
                    1U) {
#line 421
                  __s2_len = strlen((char const   *)mdata->filename);
#line 421
                  if (__s2_len < 4U) {
#line 421
                    tmp___69 = __builtin_constant_p((int )zdirent.d_name);
#line 421
                    if (tmp___69) {
#line 421
                      if ((unsigned int )((void const   *)(zdirent.d_name + 1)) -
                          (unsigned int )((void const   *)zdirent.d_name) == 1U) {
#line 421
                        tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                      } else {
                        goto _L___13;
                      }
                    } else {
                      _L___13: 
#line 421
                      __s1___14 = (unsigned char const   *)((char const   *)zdirent.d_name);
#line 421
                      __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 0)));
#line 421
                      if (__s2_len > 0U) {
#line 421
                        if (__result___22 == 0) {
#line 421
                          __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                  1)));
#line 421
                          if (__s2_len > 1U) {
#line 421
                            if (__result___22 == 0) {
#line 421
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      2)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                             2)));
#line 421
                              if (__s2_len > 2U) {
#line 421
                                if (__result___22 == 0) {
#line 421
                                  __result___22 = (int )((int const   )(*(__s1___14 +
                                                                          3)) - (int const   )(*((unsigned char const   *)((char const   *)mdata->filename) +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 421
                      tmp___41 = __result___22;
                    }
                  } else {
#line 421
                    tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                  }
                } else {
#line 421
                  tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
                }
              } else {
#line 421
                tmp___41 = __builtin_strcmp(zdirent.d_name, mdata->filename);
              }
            }
          }
#line 421
          if (tmp___41) {
            goto __Cont;
          }
        }
#line 424
        break;
        __Cont: 
#line 397
        mdata = mdata->next;
#line 397
        if (! mdata) {
#line 397
          break;
        }
      }
    }
#line 428
    if (mdata) {
#line 429
      (*virname) = (char const   *)mdata->virname;
#line 430
      ret = 1;
#line 431
      break;
    }
#line 439
    tmp___75 = strlen((char const   *)zdirent.d_name);
#line 439
    if ((int )(*(zdirent.d_name + (tmp___75 - 1U))) == 47) {
#line 440
      cli_dbgmsg("Zip: Directory entry with st_size != 0\n");
#line 441
      continue;
    }
#line 445
    if (zdirent.d_csize <= 0) {
#line 446
      cli_dbgmsg("Zip: Malformed archive detected.\n");
#line 447
      (*virname) = "Suspect.Zip";
#line 448
      ret = 1;
#line 449
      break;
    } else {
#line 445
      if (zdirent.st_size < 0) {
#line 446
        cli_dbgmsg("Zip: Malformed archive detected.\n");
#line 447
        (*virname) = "Suspect.Zip";
#line 448
        ret = 1;
#line 449
        break;
      }
    }
#line 452
    if (limits) {
#line 452
      if (limits->maxratio > 0U) {
#line 452
        if ((unsigned int )zdirent.st_size / (unsigned int )zdirent.d_csize >= limits->maxratio) {
#line 453
          (*virname) = "Oversized.Zip";
#line 454
          ret = 1;
#line 455
          break;
        }
      }
    }
#line 458
    if (options & 16U) {
#line 458
      if (encrypted) {
#line 459
        cli_dbgmsg("Zip: Encrypted files found in archive.\n");
#line 460
        lseek(desc, 0L, 0);
#line 461
        ret = cli_scandesc(desc, virname, scanned, root, (short)0, (unsigned short)0);
#line 462
        if (ret < 0) {
#line 463
          break;
        } else {
#line 464
          if (ret != 1) {
#line 465
            (*virname) = "Encrypted.Zip";
#line 466
            ret = 1;
          }
        }
#line 468
        break;
      }
    }
#line 471
    if (limits) {
#line 472
      if (limits->maxfilesize) {
#line 472
        if ((unsigned long )((unsigned int )zdirent.st_size) > limits->maxfilesize) {
#line 473
          cli_dbgmsg("Zip: %s: Size exceeded (%d, max: %ld)\n", zdirent.d_name, zdirent.st_size,
                     limits->maxfilesize);
#line 475
          if (options & 512U) {
#line 476
            (*virname) = "Zip.ExceededFileSize";
#line 477
            ret = 1;
#line 478
            break;
          }
#line 480
          continue;
        }
      }
#line 483
      if (limits->maxfiles) {
#line 483
        if (files > limits->maxfiles) {
#line 484
          cli_dbgmsg("Zip: Files limit reached (max: %d)\n", limits->maxfiles);
#line 485
          if (options & 512U) {
#line 486
            (*virname) = "Zip.ExceededFilesLimit";
#line 487
            ret = 1;
#line 488
            break;
          }
#line 490
          break;
        }
      }
    }
#line 494
    zfp = zzip_file_open(zdir, (zzip_char_t *)zdirent.d_name, 0);
#line 494
    if ((unsigned int )zfp == (unsigned int )((void *)0)) {
#line 495
      cli_dbgmsg("Zip: Can\'t open file %s\n", zdirent.d_name);
#line 496
      ret = 101;
#line 497
      break;
    }
#line 501
    tmp = tmpfile();
#line 501
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 502
      cli_dbgmsg("Zip: Can\'t generate tmpfile().\n");
#line 503
      zzip_file_close(zfp);
#line 504
      ret = -1;
#line 505
      break;
    }
#line 508
    size = 0UL;
#line 509
    while (1) {
#line 509
      bytes = zzip_file_read(zfp, buff, 8192U);
#line 509
      if (! (bytes > 0)) {
#line 509
        break;
      }
#line 510
      size += (unsigned long )bytes;
#line 511
      tmp___76 = fwrite((void const   * __restrict  )buff, 1U, (unsigned int )bytes,
                        (FILE * __restrict  )tmp);
#line 511
      if (tmp___76 != (unsigned int )bytes) {
#line 512
        cli_dbgmsg("Zip: Can\'t write to file.\n");
#line 513
        zzip_file_close(zfp);
#line 514
        zzip_dir_close(zdir);
#line 515
        fclose(tmp);
#line 516
        free((void *)buff);
#line 517
        return (-12);
      }
    }
#line 521
    zzip_file_close(zfp);
#line 523
    if (! encrypted) {
#line 523
      if (size != (unsigned long )zdirent.st_size) {
#line 524
        cli_dbgmsg("Zip: Incorrectly decompressed (%d != %d)\n", size, zdirent.st_size);
#line 525
        ret = 101;
#line 526
        break;
      }
    }
#line 529
    tmp___79 = fflush(tmp);
#line 529
    if (tmp___79 != 0) {
#line 530
      tmp___77 = __errno_location();
#line 530
      tmp___78 = strerror((*tmp___77));
#line 530
      cli_dbgmsg("Zip: fflush() failed: %s\n", tmp___78);
#line 531
      ret = -2;
#line 532
      break;
    }
#line 535
    fd = fileno(tmp);
#line 537
    lseek(fd, 0L, 0);
#line 538
    ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
#line 538
    if (ret == 1) {
#line 539
      cli_dbgmsg("Zip: Infected with %s\n", (*virname));
#line 540
      ret = 1;
#line 541
      break;
    } else {
#line 542
      if (ret == 102) {
#line 543
        cli_dbgmsg("Zip: Malformed Zip file, scanning stopped.\n");
#line 544
        (*virname) = "Suspect.Zip";
#line 545
        ret = 1;
#line 546
        break;
      }
    }
#line 549
    if (tmp) {
#line 550
      fclose(tmp);
#line 551
      tmp = (FILE *)((void *)0);
    }
  }
#line 555
  zzip_dir_close(zdir);
#line 556
  if (tmp) {
#line 557
    fclose(tmp);
#line 558
    tmp = (FILE *)((void *)0);
  }
#line 561
  free((void *)buff);
#line 562
  return (ret);
}
}
#line 565 "scanners.c"
static int cli_scangzip(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int bytes ;
  int ret ;
  unsigned long size ;
  char *buff ;
  FILE *tmp ;
  gzFile gd ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 567
  ret = 0;
#line 568
  size = 0UL;
#line 570
  tmp = (FILE *)((void *)0);
#line 574
  cli_dbgmsg("in cli_scangzip()\n");
#line 576
  tmp___0 = dup(desc);
#line 576
  gd = gzdopen(tmp___0, "rb");
#line 576
  if ((unsigned int )gd == (unsigned int )((void *)0)) {
#line 577
    cli_dbgmsg("GZip: Can\'t open descriptor %d\n", desc);
#line 578
    return (103);
  }
#line 581
  tmp = tmpfile();
#line 581
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 582
    cli_dbgmsg("GZip: Can\'t generate temporary file.\n");
#line 583
    gzclose(gd);
#line 584
    return (-1);
  }
#line 586
  fd = fileno(tmp);
#line 588
  buff = (char *)cli_malloc(8192U);
#line 588
  if (! buff) {
#line 589
    cli_dbgmsg("GZip: Unable to malloc %d bytes.\n", 8192);
#line 590
    gzclose(gd);
#line 591
    return (-3);
  }
#line 594
  while (1) {
#line 594
    bytes = gzread(gd, (void *)buff, 8192U);
#line 594
    if (! (bytes > 0)) {
#line 594
      break;
    }
#line 595
    size += (unsigned long )bytes;
#line 597
    if (limits) {
#line 598
      if (limits->maxfilesize) {
#line 598
        if (size + 8192UL > limits->maxfilesize) {
#line 599
          cli_dbgmsg("GZip: Size exceeded (stopped at %ld, max: %ld)\n", size, limits->maxfilesize);
#line 600
          if (options & 512U) {
#line 601
            (*virname) = "GZip.ExceededFileSize";
#line 602
            ret = 1;
          }
#line 604
          break;
        }
      }
    }
#line 607
    tmp___2 = cli_writen(fd, (void *)buff, (unsigned int )bytes);
#line 607
    if (tmp___2 != bytes) {
#line 608
      cli_dbgmsg("GZip: Can\'t write to file.\n");
#line 609
      fclose(tmp);
#line 610
      gzclose(gd);
#line 611
      free((void *)buff);
#line 612
      return (103);
    }
  }
#line 616
  free((void *)buff);
#line 617
  gzclose(gd);
#line 619
  if (ret == 1) {
#line 620
    fclose(tmp);
#line 621
    return (ret);
  }
#line 624
  tmp___3 = fsync(fd);
#line 624
  if (tmp___3 == -1) {
#line 625
    cli_dbgmsg("GZip: Can\'t synchronise descriptor %d\n", fd);
#line 626
    fclose(tmp);
#line 627
    return (-2);
  }
#line 630
  lseek(fd, 0L, 0);
#line 631
  ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
#line 631
  if (ret == 1) {
#line 632
    cli_dbgmsg("GZip: Infected with %s\n", (*virname));
#line 633
    fclose(tmp);
#line 634
    return (1);
  }
#line 636
  fclose(tmp);
#line 638
  return (ret);
}
}
#line 650 "scanners.c"
static int cli_scanbzip(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int bytes ;
  int ret ;
  int bzerror ;
  short memlim ;
  unsigned long size ;
  char *buff ;
  FILE *fs ;
  FILE *tmp ;
  BZFILE *bfd ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 652
  ret = 0;
#line 652
  bzerror = 0;
#line 653
  memlim = (short)0;
#line 654
  size = 0UL;
#line 656
  tmp = (FILE *)((void *)0);
#line 660
  tmp___0 = dup(desc);
#line 660
  fs = fdopen(tmp___0, "rb");
#line 660
  if ((unsigned int )fs == (unsigned int )((void *)0)) {
#line 661
    cli_dbgmsg("Bzip: Can\'t open descriptor %d.\n", desc);
#line 662
    return (104);
  }
#line 665
  if (limits) {
#line 666
    if (limits->archivememlim) {
#line 667
      memlim = (short)1;
    }
  }
#line 669
  bfd = BZ2_bzReadOpen(& bzerror, fs, 0, (int )memlim, (void *)0, 0);
#line 669
  if ((unsigned int )bfd == (unsigned int )((void *)0)) {
#line 670
    cli_dbgmsg("Bzip: Can\'t initialize bzip2 library (descriptor: %d).\n", desc);
#line 671
    fclose(fs);
#line 672
    return (104);
  }
#line 675
  tmp = tmpfile();
#line 675
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 676
    cli_dbgmsg("Bzip: Can\'t generate temporary file.\n");
#line 677
    BZ2_bzReadClose(& bzerror, bfd);
#line 678
    fclose(fs);
#line 679
    return (-1);
  }
#line 681
  fd = fileno(tmp);
#line 683
  buff = (char *)malloc(8192U);
#line 683
  if (! buff) {
#line 684
    cli_dbgmsg("Bzip: Unable to malloc %d bytes.\n", 8192);
#line 685
    fclose(tmp);
#line 686
    fclose(fs);
#line 687
    BZ2_bzReadClose(& bzerror, bfd);
#line 688
    return (-3);
  }
#line 691
  while (1) {
#line 691
    bytes = BZ2_bzRead(& bzerror, bfd, (void *)buff, 8192);
#line 691
    if (! (bytes > 0)) {
#line 691
      break;
    }
#line 692
    size += (unsigned long )bytes;
#line 694
    if (limits) {
#line 695
      if (limits->maxfilesize) {
#line 695
        if (size + 8192UL > limits->maxfilesize) {
#line 696
          cli_dbgmsg("Bzip: Size exceeded (stopped at %ld, max: %ld)\n", size, limits->maxfilesize);
#line 697
          if (options & 512U) {
#line 698
            (*virname) = "BZip.ExceededFileSize";
#line 699
            ret = 1;
          }
#line 701
          break;
        }
      }
    }
#line 704
    tmp___2 = cli_writen(fd, (void *)buff, (unsigned int )bytes);
#line 704
    if (tmp___2 != bytes) {
#line 705
      cli_dbgmsg("Bzip: Can\'t write to file.\n");
#line 706
      BZ2_bzReadClose(& bzerror, bfd);
#line 707
      fclose(tmp);
#line 708
      free((void *)buff);
#line 709
      fclose(fs);
#line 710
      return (103);
    }
  }
#line 714
  free((void *)buff);
#line 715
  BZ2_bzReadClose(& bzerror, bfd);
#line 717
  if (ret == 1) {
#line 718
    fclose(tmp);
#line 719
    fclose(fs);
#line 720
    return (ret);
  }
#line 723
  tmp___3 = fsync(fd);
#line 723
  if (tmp___3 == -1) {
#line 724
    cli_dbgmsg("Bzip: Synchronisation failed for descriptor %d\n", fd);
#line 725
    fclose(tmp);
#line 726
    fclose(fs);
#line 727
    return (-2);
  }
#line 730
  lseek(fd, 0L, 0);
#line 731
  ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
#line 731
  if (ret == 1) {
#line 732
    cli_dbgmsg("Bzip: Infected with %s\n", (*virname));
  }
#line 734
  fclose(tmp);
#line 735
  fclose(fs);
#line 737
  return (ret);
}
}
#line 741 "scanners.c"
static int cli_scanszdd(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int ret ;
  FILE *tmp ;
  FILE *in ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 743
  ret = 0;
#line 744
  tmp = (FILE *)((void *)0);
#line 747
  cli_dbgmsg("in cli_scanmscomp()\n");
#line 749
  tmp___0 = dup(desc);
#line 749
  in = fdopen(tmp___0, "rb");
#line 749
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 750
    cli_dbgmsg("SZDD: Can\'t open descriptor %d\n", desc);
#line 751
    return (106);
  }
#line 754
  tmp = tmpfile();
#line 754
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 755
    cli_dbgmsg("SZDD: Can\'t generate temporary file.\n");
#line 756
    fclose(in);
#line 757
    return (-1);
  }
#line 760
  tmp___1 = cli_msexpand(in, tmp);
#line 760
  if (tmp___1 == -1) {
#line 761
    cli_dbgmsg("SZDD: msexpand failed.\n");
#line 762
    return (106);
  }
#line 765
  fclose(in);
#line 766
  tmp___2 = fflush(tmp);
#line 766
  if (tmp___2) {
#line 767
    cli_dbgmsg("SZDD: fflush() failed.\n");
#line 768
    fclose(tmp);
#line 769
    return (-2);
  }
#line 772
  fd = fileno(tmp);
#line 773
  lseek(fd, 0L, 0);
#line 774
  ret = cli_magic_scandesc(fd, virname, scanned, root, limits, options, arec, mrec);
#line 774
  if (ret == 1) {
#line 775
    cli_dbgmsg("SZDD: Infected with %s\n", (*virname));
#line 776
    fclose(tmp);
#line 777
    return (1);
  }
#line 780
  fclose(tmp);
#line 781
  return (ret);
}
}
#line 784 "scanners.c"
static int cli_scanmscab(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                         struct cl_limits  const  *limits , unsigned int options ,
                         unsigned int arec , unsigned int mrec ) 
{ struct mscab_decompressor *cabd ;
  struct mscabd_cabinet *base ;
  struct mscabd_cabinet *cab ;
  struct mscabd_file *file ;
  char *tempname ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 786
  cabd = (struct mscab_decompressor *)((void *)0);
#line 790
  ret = 0;
#line 793
  cli_dbgmsg("in cli_scanmscab()\n");
#line 795
  cabd = mspack_create_cab_decompressor((struct mspack_system *)((void *)0));
#line 795
  if ((unsigned int )cabd == (unsigned int )((void *)0)) {
#line 796
    cli_dbgmsg("MSCAB: Can\'t create libmspack CAB decompressor\n");
#line 797
    return (107);
  }
#line 800
  tmp = dup(desc);
#line 800
  base = ((*(cabd->dsearch)))(cabd, tmp);
#line 800
  if ((unsigned int )base == (unsigned int )((void *)0)) {
#line 801
    cli_dbgmsg("MSCAB: I/O error or no valid cabinets found\n");
#line 802
    mspack_destroy_cab_decompressor(cabd);
#line 803
    return (107);
  }
#line 806
  cab = base;
#line 806
  while (cab) {
#line 807
    file = cab->files;
#line 807
    while (file) {
#line 809
      if (limits) {
#line 809
        if (limits->maxfilesize) {
#line 809
          if (file->length > (unsigned int )limits->maxfilesize) {
#line 810
            cli_dbgmsg("MSCAB: %s: Size exceeded (%u, max: %lu)\n", file->filename,
                       file->length, limits->maxfilesize);
#line 811
            if (options & 512U) {
#line 812
              (*virname) = "MSCAB.ExceededFileSize";
#line 813
              ((*(cabd->close)))(cabd, base);
#line 814
              mspack_destroy_cab_decompressor(cabd);
#line 815
              return (1);
            }
            goto __Cont;
          }
        }
      }
#line 820
      tempname = cli_gentemp((char const   *)((void *)0));
#line 821
      cli_dbgmsg("MSCAB: Extracting data to %s\n", tempname);
#line 822
      tmp___1 = ((*(cabd->extract)))(cabd, file, tempname);
#line 822
      if (tmp___1) {
#line 823
        tmp___0 = ((*(cabd->last_error)))(cabd);
#line 823
        cli_dbgmsg("MSCAB: libmscab error code: %d\n", tmp___0);
      } else {
#line 825
        ret = cli_scanfile((char const   *)tempname, virname, (unsigned long *)scanned,
                           root, limits, options, arec, mrec);
      }
#line 827
      if (! cli_leavetemps_flag) {
#line 828
        unlink((char const   *)tempname);
      }
#line 829
      free((void *)tempname);
#line 830
      if (ret == 1) {
#line 831
        break;
      }
      __Cont: 
#line 807
      file = file->next;
    }
#line 833
    if (ret == 1) {
#line 834
      break;
    }
#line 806
    cab = cab->next;
  }
#line 837
  ((*(cabd->close)))(cabd, base);
#line 838
  mspack_destroy_cab_decompressor(cabd);
#line 840
  return (ret);
}
}
#line 843 "scanners.c"
static int cli_scandir(char const   *dirname , char const   **virname , long *scanned ,
                       struct cl_node  const  *root , struct cl_limits  const  *limits ,
                       unsigned int options , unsigned int arec , unsigned int mrec ) 
{ DIR *dd ;
  struct dirent *dent ;
  struct stat statbuf ;
  char *fname ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___39 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___58 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___108 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___127 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;

  {
#line 857
  dd = opendir(dirname);
#line 857
  if ((unsigned int )dd != (unsigned int )((void *)0)) {
#line 863
    while (1) {
#line 863
      dent = readdir(dd);
#line 863
      if (! dent) {
#line 863
        break;
      }
#line 866
      if (dent->d_ino) {
#line 869
        tmp___70 = __builtin_constant_p((int )(dent->d_name));
#line 869
        if (tmp___70) {
#line 869
          tmp___71 = __builtin_constant_p((int )".");
#line 869
          if (tmp___71) {
#line 869
            __s1_len = strlen((char const   *)(dent->d_name));
#line 869
            __s2_len = strlen(".");
#line 869
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___17;
            } else {
#line 869
              if (__s1_len >= 4U) {
                _L___17: 
#line 869
                if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                       1U)) {
#line 869
                  tmp___72 = 1;
                } else {
#line 869
                  if (__s2_len >= 4U) {
#line 869
                    tmp___72 = 1;
                  } else {
#line 869
                    tmp___72 = 0;
                  }
                }
              } else {
#line 869
                tmp___72 = 0;
              }
            }
#line 869
            if (tmp___72) {
#line 869
              tmp___39 = __builtin_strcmp(dent->d_name, ".");
            } else {
              goto _L___19;
            }
          } else {
            goto _L___19;
          }
        } else {
          _L___19: 
#line 869
          tmp___69 = __builtin_constant_p((int )(dent->d_name));
#line 869
          if (tmp___69) {
#line 869
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
#line 869
              __s1_len = strlen((char const   *)(dent->d_name));
#line 869
              if (__s1_len < 4U) {
#line 869
                tmp___58 = __builtin_constant_p((int )".");
#line 869
                if (tmp___58) {
#line 869
                  if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                      1U) {
#line 869
                    tmp___39 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___12;
                  }
                } else {
                  _L___12: 
#line 869
                  __s2___6 = (unsigned char const   *)".";
#line 869
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 869
                  if (__s1_len > 0U) {
#line 869
                    if (__result___18 == 0) {
#line 869
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 869
                      if (__s1_len > 1U) {
#line 869
                        if (__result___18 == 0) {
#line 869
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 869
                          if (__s1_len > 2U) {
#line 869
                            if (__result___18 == 0) {
#line 869
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 869
                  tmp___39 = __result___18;
                }
              } else {
                goto _L___16;
              }
            } else {
              goto _L___16;
            }
          } else {
            _L___16: 
#line 869
            tmp___68 = __builtin_constant_p((int )".");
#line 869
            if (tmp___68) {
#line 869
              if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                  1U) {
#line 869
                __s2_len = strlen(".");
#line 869
                if (__s2_len < 4U) {
#line 869
                  tmp___67 = __builtin_constant_p((int )(dent->d_name));
#line 869
                  if (tmp___67) {
#line 869
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
#line 869
                      tmp___39 = __builtin_strcmp(dent->d_name, ".");
                    } else {
                      goto _L___14;
                    }
                  } else {
                    _L___14: 
#line 869
                    __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 869
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               0)));
#line 869
                    if (__s2_len > 0U) {
#line 869
                      if (__result___22 == 0) {
#line 869
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"." +
                                                                1)));
#line 869
                        if (__s2_len > 1U) {
#line 869
                          if (__result___22 == 0) {
#line 869
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"." +
                                                                    2)));
#line 869
                            if (__s2_len > 2U) {
#line 869
                              if (__result___22 == 0) {
#line 869
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 869
                    tmp___39 = __result___22;
                  }
                } else {
#line 869
                  tmp___39 = __builtin_strcmp(dent->d_name, ".");
                }
              } else {
#line 869
                tmp___39 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
#line 869
              tmp___39 = __builtin_strcmp(dent->d_name, ".");
            }
          }
        }
#line 869
        if (tmp___39) {
#line 869
          tmp___139 = __builtin_constant_p((int )(dent->d_name));
#line 869
          if (tmp___139) {
#line 869
            tmp___140 = __builtin_constant_p((int )"..");
#line 869
            if (tmp___140) {
#line 869
              __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 869
              __s2_len___0 = strlen("..");
#line 869
              if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                     1U)) {
                goto _L___37;
              } else {
#line 869
                if (__s1_len___0 >= 4U) {
                  _L___37: 
#line 869
                  if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                         1U)) {
#line 869
                    tmp___141 = 1;
                  } else {
#line 869
                    if (__s2_len___0 >= 4U) {
#line 869
                      tmp___141 = 1;
                    } else {
#line 869
                      tmp___141 = 0;
                    }
                  }
                } else {
#line 869
                  tmp___141 = 0;
                }
              }
#line 869
              if (tmp___141) {
#line 869
                tmp___108 = __builtin_strcmp(dent->d_name, "..");
              } else {
                goto _L___39;
              }
            } else {
              goto _L___39;
            }
          } else {
            _L___39: 
#line 869
            tmp___138 = __builtin_constant_p((int )(dent->d_name));
#line 869
            if (tmp___138) {
#line 869
              if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                  1U) {
#line 869
                __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 869
                if (__s1_len___0 < 4U) {
#line 869
                  tmp___127 = __builtin_constant_p((int )"..");
#line 869
                  if (tmp___127) {
#line 869
                    if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                        1U) {
#line 869
                      tmp___108 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___32;
                    }
                  } else {
                    _L___32: 
#line 869
                    __s2___14 = (unsigned char const   *)"..";
#line 869
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
#line 869
                    if (__s1_len___0 > 0U) {
#line 869
                      if (__result___42 == 0) {
#line 869
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
#line 869
                        if (__s1_len___0 > 1U) {
#line 869
                          if (__result___42 == 0) {
#line 869
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
#line 869
                            if (__s1_len___0 > 2U) {
#line 869
                              if (__result___42 == 0) {
#line 869
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 869
                    tmp___108 = __result___42;
                  }
                } else {
                  goto _L___36;
                }
              } else {
                goto _L___36;
              }
            } else {
              _L___36: 
#line 869
              tmp___137 = __builtin_constant_p((int )"..");
#line 869
              if (tmp___137) {
#line 869
                if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                    1U) {
#line 869
                  __s2_len___0 = strlen("..");
#line 869
                  if (__s2_len___0 < 4U) {
#line 869
                    tmp___136 = __builtin_constant_p((int )(dent->d_name));
#line 869
                    if (tmp___136) {
#line 869
                      if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                          1U) {
#line 869
                        tmp___108 = __builtin_strcmp(dent->d_name, "..");
                      } else {
                        goto _L___34;
                      }
                    } else {
                      _L___34: 
#line 869
                      __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 869
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 0)));
#line 869
                      if (__s2_len___0 > 0U) {
#line 869
                        if (__result___46 == 0) {
#line 869
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)".." +
                                                                  1)));
#line 869
                          if (__s2_len___0 > 1U) {
#line 869
                            if (__result___46 == 0) {
#line 869
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)".." +
                                                                                             2)));
#line 869
                              if (__s2_len___0 > 2U) {
#line 869
                                if (__result___46 == 0) {
#line 869
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 869
                      tmp___108 = __result___46;
                    }
                  } else {
#line 869
                    tmp___108 = __builtin_strcmp(dent->d_name, "..");
                  }
                } else {
#line 869
                  tmp___108 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
#line 869
                tmp___108 = __builtin_strcmp(dent->d_name, "..");
              }
            }
          }
#line 869
          if (tmp___108) {
#line 871
            tmp = strlen(dirname);
#line 871
            tmp___0 = strlen((char const   *)(dent->d_name));
#line 871
            fname = (char *)cli_calloc((tmp + tmp___0) + 2U, sizeof(char ));
#line 872
            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                    dirname, dent->d_name);
#line 875
            tmp___3 = lstat__extinline((char const   *)fname, & statbuf);
#line 875
            if (tmp___3 != -1) {
#line 876
              if ((statbuf.st_mode & 61440U) == 16384U) {
#line 876
                if (! ((statbuf.st_mode & 61440U) == 40960U)) {
#line 877
                  tmp___1 = cli_scandir((char const   *)fname, virname, scanned, root,
                                        limits, options, arec, mrec);
#line 877
                  if (tmp___1 == 1) {
#line 878
                    free((void *)fname);
#line 879
                    closedir(dd);
#line 880
                    return (1);
                  }
                } else {
                  goto _L;
                }
              } else {
                _L: 
#line 883
                if ((statbuf.st_mode & 61440U) == 32768U) {
#line 884
                  tmp___2 = cli_scanfile((char const   *)fname, virname, (unsigned long *)scanned,
                                         root, limits, options, arec, mrec);
#line 884
                  if (tmp___2 == 1) {
#line 885
                    free((void *)fname);
#line 886
                    closedir(dd);
#line 887
                    return (1);
                  }
                }
              }
            }
#line 891
            free((void *)fname);
          }
        }
      }
    }
  } else {
#line 896
    cli_dbgmsg("ScanDir: Can\'t open directory %s.\n", dirname);
#line 897
    return (-4);
  }
#line 900
  closedir(dd);
#line 901
  return (0);
}
}
#line 904 "scanners.c"
static int cli_vba_scandir(char const   *dirname , char const   **virname , long *scanned ,
                           struct cl_node  const  *root , struct cl_limits  const  *limits ,
                           unsigned int options , unsigned int arec , unsigned int mrec ) 
{ int ret ;
  int i ;
  int fd ;
  int data_len ;
  vba_project_t *vba_project ;
  DIR *dd ;
  struct dirent *dent ;
  struct stat statbuf ;
  char *fname ;
  char *fullname ;
  unsigned char *data ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  unsigned char *tmp___8 ;
  int tmp___9 ;
  vba_project_t *tmp___10 ;
  vba_project_t *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___51 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___70 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___120 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___139 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;

  {
#line 906
  ret = 0;
#line 921
  cli_dbgmsg("VBADir: %s\n", dirname);
#line 922
  tmp___11 = vba56_dir_read(dirname);
#line 922
  vba_project = tmp___11;
#line 922
  if (vba_project) {
#line 924
    i = 0;
#line 924
    while (i < vba_project->count) {
#line 925
      tmp = strlen((char const   *)vba_project->dir);
#line 925
      tmp___0 = strlen((char const   *)(*(vba_project->name + i)));
#line 925
      fullname = (char *)cli_malloc((tmp + tmp___0) + 2U);
#line 926
      sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/%s",
              vba_project->dir, (*(vba_project->name + i)));
#line 927
      fd = open((char const   *)fullname, 0);
#line 928
      if (fd == -1) {
#line 929
        cli_dbgmsg("VBADir: Can\'t open file %s\n", fullname);
#line 930
        free((void *)fullname);
#line 931
        ret = -4;
#line 932
        break;
      }
#line 934
      free((void *)fullname);
#line 935
      cli_dbgmsg("VBADir: Decompress VBA project \'%s\'\n", (*(vba_project->name +
                                                               i)));
#line 936
      tmp___2 = vba_decompress(fd, (*(vba_project->offset + i)), & data_len);
#line 936
      data = tmp___2;
#line 937
      close(fd);
#line 939
      if (! data) {
#line 940
        cli_dbgmsg("VBADir: WARNING: VBA project \'%s\' decompressed to NULL\n", (*(vba_project->name +
                                                                                    i)));
      } else {
#line 942
        if (scanned) {
#line 943
          (*scanned) += (long )(data_len / 4096);
        }
#line 945
        tmp___3 = cli_scanbuff((char const   *)data, (unsigned int )data_len, virname,
                               root, (unsigned short)511);
#line 945
        if (tmp___3 == 1) {
#line 946
          free((void *)data);
#line 947
          ret = 1;
#line 948
          break;
        }
#line 951
        free((void *)data);
      }
#line 924
      i ++;
    }
#line 955
    i = 0;
#line 955
    while (i < vba_project->count) {
#line 956
      free((void *)(*(vba_project->name + i)));
#line 955
      i ++;
    }
#line 957
    free((void *)vba_project->name);
#line 958
    free((void *)vba_project->dir);
#line 959
    free((void *)vba_project->offset);
#line 960
    free((void *)vba_project);
  } else {
#line 961
    fullname = ppt_vba_read(dirname);
#line 961
    if (fullname) {
#line 962
      tmp___4 = cli_scandir((char const   *)fullname, virname, scanned, root, limits,
                            options, arec, mrec);
#line 962
      if (tmp___4 == 1) {
#line 963
        ret = 1;
      }
#line 965
      if (! cli_leavetemps_flag) {
#line 966
        cli_rmdirs((char const   *)fullname);
      }
#line 967
      free((void *)fullname);
    } else {
#line 968
      tmp___10 = wm_dir_read(dirname);
#line 968
      vba_project = tmp___10;
#line 968
      if (vba_project) {
#line 969
        i = 0;
#line 969
        while (i < vba_project->count) {
#line 970
          tmp___5 = strlen((char const   *)vba_project->dir);
#line 970
          tmp___6 = strlen((char const   *)(*(vba_project->name + i)));
#line 970
          fullname = (char *)cli_malloc((tmp___5 + tmp___6) + 2U);
#line 971
          sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/%s",
                  vba_project->dir, (*(vba_project->name + i)));
#line 972
          fd = open((char const   *)fullname, 0);
#line 973
          if (fd == -1) {
#line 974
            cli_dbgmsg("VBADir: Can\'t open file %s\n", fullname);
#line 975
            free((void *)fullname);
#line 976
            ret = -4;
#line 977
            break;
          }
#line 979
          free((void *)fullname);
#line 980
          cli_dbgmsg("VBADir: Decompress WM project \'%s\' macro:%d key:%d\n", (*(vba_project->name +
                                                                                  i)),
                     i, (*(vba_project->key + i)));
#line 981
          tmp___8 = wm_decrypt_macro(fd, (*(vba_project->offset + i)), (*(vba_project->length +
                                                                          i)), (*(vba_project->key +
                                                                                  i)));
#line 981
          data = tmp___8;
#line 982
          close(fd);
#line 984
          if (! data) {
#line 985
            cli_dbgmsg("VBADir: WARNING: WM project \'%s\' macro %d decrypted to NULL\n",
                       (*(vba_project->name + i)), i);
          } else {
#line 987
            if (scanned) {
#line 988
              (*scanned) = (long )((unsigned long )(*scanned) + (unsigned long )((*(vba_project->length +
                                                                                    i)) /
                                                                                 4096U));
            }
#line 989
            tmp___9 = cli_scanbuff((char const   *)data, (*(vba_project->length +
                                                            i)), virname, root, (unsigned short)511);
#line 989
            if (tmp___9 == 1) {
#line 990
              free((void *)data);
#line 991
              ret = 1;
#line 992
              break;
            }
#line 994
            free((void *)data);
          }
#line 969
          i ++;
        }
#line 997
        i = 0;
#line 997
        while (i < vba_project->count) {
#line 998
          free((void *)(*(vba_project->name + i)));
#line 997
          i ++;
        }
#line 999
        free((void *)vba_project->key);
#line 1000
        free((void *)vba_project->length);
#line 1001
        free((void *)vba_project->offset);
#line 1002
        free((void *)vba_project->name);
#line 1003
        free((void *)vba_project->dir);
#line 1004
        free((void *)vba_project);
      }
    }
  }
#line 1007
  if (ret != 0) {
#line 1008
    return (ret);
  }
#line 1010
  dd = opendir(dirname);
#line 1010
  if ((unsigned int )dd != (unsigned int )((void *)0)) {
#line 1016
    while (1) {
#line 1016
      dent = readdir(dd);
#line 1016
      if (! dent) {
#line 1016
        break;
      }
#line 1019
      if (dent->d_ino) {
#line 1022
        tmp___82 = __builtin_constant_p((int )(dent->d_name));
#line 1022
        if (tmp___82) {
#line 1022
          tmp___83 = __builtin_constant_p((int )".");
#line 1022
          if (tmp___83) {
#line 1022
            __s1_len = strlen((char const   *)(dent->d_name));
#line 1022
            __s2_len = strlen(".");
#line 1022
            if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                   1U)) {
              goto _L___16;
            } else {
#line 1022
              if (__s1_len >= 4U) {
                _L___16: 
#line 1022
                if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                       1U)) {
#line 1022
                  tmp___84 = 1;
                } else {
#line 1022
                  if (__s2_len >= 4U) {
#line 1022
                    tmp___84 = 1;
                  } else {
#line 1022
                    tmp___84 = 0;
                  }
                }
              } else {
#line 1022
                tmp___84 = 0;
              }
            }
#line 1022
            if (tmp___84) {
#line 1022
              tmp___51 = __builtin_strcmp(dent->d_name, ".");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
#line 1022
          tmp___81 = __builtin_constant_p((int )(dent->d_name));
#line 1022
          if (tmp___81) {
#line 1022
            if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                1U) {
#line 1022
              __s1_len = strlen((char const   *)(dent->d_name));
#line 1022
              if (__s1_len < 4U) {
#line 1022
                tmp___70 = __builtin_constant_p((int )".");
#line 1022
                if (tmp___70) {
#line 1022
                  if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                      1U) {
#line 1022
                    tmp___51 = __builtin_strcmp(dent->d_name, ".");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
#line 1022
                  __s2___6 = (unsigned char const   *)".";
#line 1022
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 1022
                  if (__s1_len > 0U) {
#line 1022
                    if (__result___18 == 0) {
#line 1022
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 1022
                      if (__s1_len > 1U) {
#line 1022
                        if (__result___18 == 0) {
#line 1022
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 1022
                          if (__s1_len > 2U) {
#line 1022
                            if (__result___18 == 0) {
#line 1022
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 1022
                  tmp___51 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
#line 1022
            tmp___80 = __builtin_constant_p((int )".");
#line 1022
            if (tmp___80) {
#line 1022
              if ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") ==
                  1U) {
#line 1022
                __s2_len = strlen(".");
#line 1022
                if (__s2_len < 4U) {
#line 1022
                  tmp___79 = __builtin_constant_p((int )(dent->d_name));
#line 1022
                  if (tmp___79) {
#line 1022
                    if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                        1U) {
#line 1022
                      tmp___51 = __builtin_strcmp(dent->d_name, ".");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
#line 1022
                    __s1___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 1022
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               0)));
#line 1022
                    if (__s2_len > 0U) {
#line 1022
                      if (__result___22 == 0) {
#line 1022
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"." +
                                                                1)));
#line 1022
                        if (__s2_len > 1U) {
#line 1022
                          if (__result___22 == 0) {
#line 1022
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"." +
                                                                    2)));
#line 1022
                            if (__s2_len > 2U) {
#line 1022
                              if (__result___22 == 0) {
#line 1022
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"." +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 1022
                    tmp___51 = __result___22;
                  }
                } else {
#line 1022
                  tmp___51 = __builtin_strcmp(dent->d_name, ".");
                }
              } else {
#line 1022
                tmp___51 = __builtin_strcmp(dent->d_name, ".");
              }
            } else {
#line 1022
              tmp___51 = __builtin_strcmp(dent->d_name, ".");
            }
          }
        }
#line 1022
        if (tmp___51) {
#line 1022
          tmp___151 = __builtin_constant_p((int )(dent->d_name));
#line 1022
          if (tmp___151) {
#line 1022
            tmp___152 = __builtin_constant_p((int )"..");
#line 1022
            if (tmp___152) {
#line 1022
              __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 1022
              __s2_len___0 = strlen("..");
#line 1022
              if (! ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                     1U)) {
                goto _L___36;
              } else {
#line 1022
                if (__s1_len___0 >= 4U) {
                  _L___36: 
#line 1022
                  if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                         1U)) {
#line 1022
                    tmp___153 = 1;
                  } else {
#line 1022
                    if (__s2_len___0 >= 4U) {
#line 1022
                      tmp___153 = 1;
                    } else {
#line 1022
                      tmp___153 = 0;
                    }
                  }
                } else {
#line 1022
                  tmp___153 = 0;
                }
              }
#line 1022
              if (tmp___153) {
#line 1022
                tmp___120 = __builtin_strcmp(dent->d_name, "..");
              } else {
                goto _L___38;
              }
            } else {
              goto _L___38;
            }
          } else {
            _L___38: 
#line 1022
            tmp___150 = __builtin_constant_p((int )(dent->d_name));
#line 1022
            if (tmp___150) {
#line 1022
              if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                  1U) {
#line 1022
                __s1_len___0 = strlen((char const   *)(dent->d_name));
#line 1022
                if (__s1_len___0 < 4U) {
#line 1022
                  tmp___139 = __builtin_constant_p((int )"..");
#line 1022
                  if (tmp___139) {
#line 1022
                    if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                        1U) {
#line 1022
                      tmp___120 = __builtin_strcmp(dent->d_name, "..");
                    } else {
                      goto _L___31;
                    }
                  } else {
                    _L___31: 
#line 1022
                    __s2___14 = (unsigned char const   *)"..";
#line 1022
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                            0)) - (int const   )(*(__s2___14 +
                                                                                   0)));
#line 1022
                    if (__s1_len___0 > 0U) {
#line 1022
                      if (__result___42 == 0) {
#line 1022
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                1)) - (int const   )(*(__s2___14 +
                                                                                       1)));
#line 1022
                        if (__s1_len___0 > 1U) {
#line 1022
                          if (__result___42 == 0) {
#line 1022
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                    2)) - (int const   )(*(__s2___14 +
                                                                                           2)));
#line 1022
                            if (__s1_len___0 > 2U) {
#line 1022
                              if (__result___42 == 0) {
#line 1022
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                        3)) - (int const   )(*(__s2___14 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 1022
                    tmp___120 = __result___42;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                goto _L___35;
              }
            } else {
              _L___35: 
#line 1022
              tmp___149 = __builtin_constant_p((int )"..");
#line 1022
              if (tmp___149) {
#line 1022
                if ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") ==
                    1U) {
#line 1022
                  __s2_len___0 = strlen("..");
#line 1022
                  if (__s2_len___0 < 4U) {
#line 1022
                    tmp___148 = __builtin_constant_p((int )(dent->d_name));
#line 1022
                    if (tmp___148) {
#line 1022
                      if ((unsigned int )((void const   *)(dent->d_name + 1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                          1U) {
#line 1022
                        tmp___120 = __builtin_strcmp(dent->d_name, "..");
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: 
#line 1022
                      __s1___30 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 1022
                      __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 0)));
#line 1022
                      if (__s2_len___0 > 0U) {
#line 1022
                        if (__result___46 == 0) {
#line 1022
                          __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                 (int const   )(*((unsigned char const   *)".." +
                                                                  1)));
#line 1022
                          if (__s2_len___0 > 1U) {
#line 1022
                            if (__result___46 == 0) {
#line 1022
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      2)) - (int const   )(*((unsigned char const   *)".." +
                                                                                             2)));
#line 1022
                              if (__s2_len___0 > 2U) {
#line 1022
                                if (__result___46 == 0) {
#line 1022
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          3)) - (int const   )(*((unsigned char const   *)".." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 1022
                      tmp___120 = __result___46;
                    }
                  } else {
#line 1022
                    tmp___120 = __builtin_strcmp(dent->d_name, "..");
                  }
                } else {
#line 1022
                  tmp___120 = __builtin_strcmp(dent->d_name, "..");
                }
              } else {
#line 1022
                tmp___120 = __builtin_strcmp(dent->d_name, "..");
              }
            }
          }
#line 1022
          if (tmp___120) {
#line 1024
            tmp___12 = strlen(dirname);
#line 1024
            tmp___13 = strlen((char const   *)(dent->d_name));
#line 1024
            fname = (char *)cli_calloc((tmp___12 + tmp___13) + 2U, sizeof(char ));
#line 1025
            sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s",
                    dirname, dent->d_name);
#line 1028
            tmp___15 = lstat__extinline((char const   *)fname, & statbuf);
#line 1028
            if (tmp___15 != -1) {
#line 1029
              if ((statbuf.st_mode & 61440U) == 16384U) {
#line 1029
                if (! ((statbuf.st_mode & 61440U) == 40960U)) {
#line 1030
                  tmp___14 = cli_vba_scandir((char const   *)fname, virname, scanned,
                                             root, limits, options, arec, mrec);
#line 1030
                  if (tmp___14 == 1) {
#line 1031
                    ret = 1;
#line 1032
                    free((void *)fname);
#line 1033
                    break;
                  }
                }
              }
            }
#line 1036
            free((void *)fname);
          }
        }
      }
    }
  } else {
#line 1041
    cli_dbgmsg("VBADir: Can\'t open directory %s.\n", dirname);
#line 1042
    return (-4);
  }
#line 1045
  closedir(dd);
#line 1046
  return (ret);
}
}
#line 1049 "scanners.c"
static int cli_scanhtml(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ char *tempname ;
  char fullname[1024] ;
  int ret ;
  int fd ;
  int tmp ;

  {
#line 1052
  ret = 0;
#line 1055
  cli_dbgmsg("in cli_scanhtml()\n");
#line 1057
  tempname = cli_gentemp((char const   *)((void *)0));
#line 1058
  tmp = mkdir((char const   *)tempname, 448U);
#line 1058
  if (tmp) {
#line 1059
    cli_dbgmsg("ScanHTML -> Can\'t create temporary directory %s\n", tempname);
#line 1060
    free((void *)tempname);
#line 1061
    return (-7);
  }
#line 1064
  html_normalise_fd(desc, (char const   *)tempname, (tag_arguments_t *)((void *)0));
#line 1065
  snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/comment.html",
           tempname);
#line 1066
  fd = open((char const   *)(fullname), 0);
#line 1067
  if (fd >= 0) {
#line 1068
    ret = cli_scandesc(fd, virname, scanned, root, (short)0, (unsigned short)519);
#line 1069
    close(fd);
  }
#line 1072
  if (ret < 0) {
    goto _L;
  } else {
#line 1072
    if (ret == 1) {
      _L: 
#line 1073
      if (! cli_leavetemps_flag) {
#line 1074
        cli_rmdirs((char const   *)tempname);
      }
#line 1075
      free((void *)tempname);
#line 1076
      return (ret);
    }
  }
#line 1079
  if (ret == 0) {
#line 1080
    snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/nocomment.html",
             tempname);
#line 1081
    fd = open((char const   *)(fullname), 0);
#line 1082
    if (fd >= 0) {
#line 1083
      ret = cli_scandesc(fd, virname, scanned, root, (short)0, (unsigned short)519);
#line 1084
      close(fd);
    }
  }
#line 1088
  if (ret < 0) {
    goto _L___0;
  } else {
#line 1088
    if (ret == 1) {
      _L___0: 
#line 1089
      if (! cli_leavetemps_flag) {
#line 1090
        cli_rmdirs((char const   *)tempname);
      }
#line 1091
      free((void *)tempname);
#line 1092
      return (ret);
    }
  }
#line 1095
  if (ret == 0) {
#line 1096
    snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/script.html",
             tempname);
#line 1097
    fd = open((char const   *)(fullname), 0);
#line 1098
    if (fd >= 0) {
#line 1099
      ret = cli_scandesc(fd, virname, scanned, root, (short)0, (unsigned short)519);
#line 1100
      close(fd);
    }
  }
#line 1104
  if (ret < 0) {
    goto _L___1;
  } else {
#line 1104
    if (ret == 1) {
      _L___1: 
#line 1105
      if (! cli_leavetemps_flag) {
#line 1106
        cli_rmdirs((char const   *)tempname);
      }
#line 1107
      free((void *)tempname);
#line 1108
      return (ret);
    }
  }
#line 1111
  if (ret == 0) {
#line 1112
    snprintf((char * __restrict  )(fullname), 1024U, (char const   * __restrict  )"%s/rfc2397",
             tempname);
#line 1113
    ret = cli_scandir((char const   *)(fullname), virname, scanned, root, limits,
                      options, arec, mrec);
  }
#line 1116
  if (! cli_leavetemps_flag) {
#line 1117
    cli_rmdirs((char const   *)tempname);
  }
#line 1119
  free((void *)tempname);
#line 1120
  return (ret);
}
}
#line 1123 "scanners.c"
static int cli_scanole2(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ char *dir ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1126
  ret = 0;
#line 1129
  cli_dbgmsg("in cli_scanole2()\n");
#line 1132
  dir = cli_gentemp((char const   *)((void *)0));
#line 1133
  tmp = mkdir((char const   *)dir, 448U);
#line 1133
  if (tmp) {
#line 1134
    cli_dbgmsg("OLE2: Can\'t create temporary directory %s\n", dir);
#line 1135
    free((void *)dir);
#line 1136
    return (-7);
  }
#line 1139
  ret = cli_ole2_extract(desc, (char const   *)dir, limits);
#line 1139
  if (ret) {
#line 1140
    tmp___0 = cl_strerror(ret);
#line 1140
    cli_dbgmsg("OLE2: %s\n", tmp___0);
#line 1141
    if (! cli_leavetemps_flag) {
#line 1142
      cli_rmdirs((char const   *)dir);
    }
#line 1143
    free((void *)dir);
#line 1144
    return (ret);
  }
#line 1147
  ret = cli_vba_scandir((char const   *)dir, virname, scanned, root, limits, options,
                        arec, mrec);
#line 1147
  if (ret != 1) {
#line 1148
    tmp___1 = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                          arec, mrec);
#line 1148
    if (tmp___1 == 1) {
#line 1149
      ret = 1;
    }
  }
#line 1153
  if (! cli_leavetemps_flag) {
#line 1154
    cli_rmdirs((char const   *)dir);
  }
#line 1155
  free((void *)dir);
#line 1156
  return (ret);
}
}
#line 1159 "scanners.c"
static int cli_scantar(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec , unsigned int posix ) 
{ char *dir ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 1162
  ret = 0;
#line 1165
  cli_dbgmsg("in cli_scantar()\n");
#line 1168
  dir = cli_gentemp((char const   *)((void *)0));
#line 1169
  tmp = mkdir((char const   *)dir, 448U);
#line 1169
  if (tmp) {
#line 1170
    cli_errmsg("Tar: Can\'t create temporary directory %s\n", dir);
#line 1171
    free((void *)dir);
#line 1172
    return (-7);
  }
#line 1175
  ret = cli_untar((char const   *)dir, desc, posix);
#line 1175
  if (ret) {
#line 1176
    tmp___0 = cl_strerror(ret);
#line 1176
    cli_dbgmsg("Tar: %s\n", tmp___0);
  } else {
#line 1178
    ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                      arec, mrec);
  }
#line 1180
  if (! cli_leavetemps_flag) {
#line 1181
    cli_rmdirs((char const   *)dir);
  }
#line 1183
  free((void *)dir);
#line 1184
  return (ret);
}
}
#line 1187 "scanners.c"
static int cli_scanbinhex(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                          struct cl_limits  const  *limits , unsigned int options ,
                          unsigned int arec , unsigned int mrec ) 
{ char *dir ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 1190
  ret = 0;
#line 1193
  cli_dbgmsg("in cli_scanbinhex()\n");
#line 1196
  dir = cli_gentemp((char const   *)((void *)0));
#line 1198
  tmp = mkdir((char const   *)dir, 448U);
#line 1198
  if (tmp) {
#line 1199
    cli_errmsg("Binhex: Can\'t create temporary directory %s\n", dir);
#line 1200
    free((void *)dir);
#line 1201
    return (-7);
  }
#line 1204
  ret = cli_binhex((char const   *)dir, desc);
#line 1204
  if (ret) {
#line 1205
    tmp___0 = cl_strerror(ret);
#line 1205
    cli_dbgmsg("Binhex: %s\n", tmp___0);
  } else {
#line 1207
    ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                      arec, mrec);
  }
#line 1209
  if (! cli_leavetemps_flag) {
#line 1210
    cli_rmdirs((char const   *)dir);
  }
#line 1212
  free((void *)dir);
#line 1213
  return (ret);
}
}
#line 1216 "scanners.c"
static int cli_scanmschm(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                         struct cl_limits  const  *limits , unsigned int options ,
                         unsigned int arec , unsigned int mrec ) 
{ char *tempname ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 1219
  ret = 0;
#line 1222
  cli_dbgmsg("in cli_scanmschm()\n");
#line 1224
  tempname = cli_gentemp((char const   *)((void *)0));
#line 1225
  tmp = mkdir((char const   *)tempname, 448U);
#line 1225
  if (tmp) {
#line 1226
    cli_dbgmsg("CHM: Can\'t create temporary directory %s\n", tempname);
#line 1227
    free((void *)tempname);
#line 1228
    return (-7);
  }
#line 1231
  tmp___0 = chm_unpack(desc, (char const   *)tempname);
#line 1231
  if (tmp___0) {
#line 1232
    ret = cli_scandir((char const   *)tempname, virname, scanned, root, limits, options,
                      arec, mrec);
  }
#line 1234
  if (! cli_leavetemps_flag) {
#line 1235
    cli_rmdirs((char const   *)tempname);
  }
#line 1237
  free((void *)tempname);
#line 1238
  return (ret);
}
}
#line 1241 "scanners.c"
static int cli_scanscrenc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                          struct cl_limits  const  *limits , unsigned int options ,
                          unsigned int arec , unsigned int mrec ) 
{ char *tempname ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 1244
  ret = 0;
#line 1246
  cli_dbgmsg("in cli_scanscrenc()\n");
#line 1248
  tempname = cli_gentemp((char const   *)((void *)0));
#line 1249
  tmp = mkdir((char const   *)tempname, 448U);
#line 1249
  if (tmp) {
#line 1250
    cli_dbgmsg("CHM: Can\'t create temporary directory %s\n", tempname);
#line 1251
    free((void *)tempname);
#line 1252
    return (-7);
  }
#line 1255
  tmp___0 = html_screnc_decode(desc, (char const   *)tempname);
#line 1255
  if (tmp___0) {
#line 1256
    ret = cli_scandir((char const   *)tempname, virname, scanned, root, limits, options,
                      arec, mrec);
  }
#line 1258
  if (! cli_leavetemps_flag) {
#line 1259
    cli_rmdirs((char const   *)tempname);
  }
#line 1261
  free((void *)tempname);
#line 1262
  return (ret);
}
}
#line 1265 "scanners.c"
static int cli_scanriff(int desc , char const   **virname ) 
{ int ret ;
  int tmp ;

  {
#line 1267
  ret = 0;
#line 1269
  tmp = cli_check_riff_exploit(desc);
#line 1269
  if (tmp == 2) {
#line 1270
    ret = 1;
#line 1271
    (*virname) = "Exploit.W32.MS05-002";
  }
#line 1274
  return (ret);
}
}
#line 1277 "scanners.c"
static int cli_scanjpeg(int desc , char const   **virname ) 
{ int ret ;
  int tmp ;

  {
#line 1279
  ret = 0;
#line 1281
  tmp = cli_check_jpeg_exploit(desc);
#line 1281
  if (tmp == 1) {
#line 1282
    ret = 1;
#line 1283
    (*virname) = "Exploit.W32.MS04-028";
  }
#line 1286
  return (ret);
}
}
#line 1301
int cli_tnef(char const   *dir , int desc ) ;
#line 1289 "scanners.c"
static int cli_scantnef(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ int ret ;
  char *dir ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1292
  tmp = cli_gentemp((char const   *)((void *)0));
#line 1292
  dir = tmp;
#line 1295
  tmp___0 = mkdir((char const   *)dir, 448U);
#line 1295
  if (tmp___0) {
#line 1296
    cli_dbgmsg("Can\'t create temporary directory for tnef file %s\n", dir);
#line 1297
    free((void *)dir);
#line 1298
    return (-7);
  }
#line 1301
  ret = cli_tnef((char const   *)dir, desc);
#line 1303
  if (ret == 0) {
#line 1304
    ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                      arec, mrec);
  }
#line 1306
  if (! cli_leavetemps_flag) {
#line 1307
    cli_rmdirs((char const   *)dir);
  }
#line 1309
  free((void *)dir);
#line 1310
  return (ret);
}
}
#line 1313 "scanners.c"
static int cli_scanmail(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                        struct cl_limits  const  *limits , unsigned int options ,
                        unsigned int arec , unsigned int mrec ) 
{ char *dir ;
  int ret ;
  int tmp ;

  {
#line 1319
  cli_dbgmsg("Starting cli_scanmail(), mrec == %d, arec == %d\n", mrec, arec);
#line 1322
  dir = cli_gentemp((char const   *)((void *)0));
#line 1323
  tmp = mkdir((char const   *)dir, 448U);
#line 1323
  if (tmp) {
#line 1324
    cli_dbgmsg("Mail: Can\'t create temporary directory %s\n", dir);
#line 1325
    free((void *)dir);
#line 1326
    return (-7);
  }
#line 1332
  ret = cli_mbox((char const   *)dir, desc, options);
#line 1332
  if (ret) {
#line 1333
    if (! cli_leavetemps_flag) {
#line 1334
      cli_rmdirs((char const   *)dir);
    }
#line 1335
    free((void *)dir);
#line 1336
    return (ret);
  }
#line 1339
  ret = cli_scandir((char const   *)dir, virname, scanned, root, limits, options,
                    arec, mrec);
#line 1341
  if (! cli_leavetemps_flag) {
#line 1342
    cli_rmdirs((char const   *)dir);
  }
#line 1344
  free((void *)dir);
#line 1345
  return (ret);
}
}
#line 1348 "scanners.c"
int cli_magic_scandesc(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
                       struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
                       unsigned int mrec ) 
{ int ret ;
  int nret ;
  int bread ;
  cli_file_t type ;
  struct stat sb ;
  int tmp ;
  int tmp___0 ;
  struct stat s ;
  int tmp___1 ;
  int typerec ;
  __off_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1350
  ret = 0;
#line 1351
  bread = 0;
#line 1356
  tmp = fstat__extinline(desc, & sb);
#line 1356
  if (tmp == -1) {
#line 1357
    cli_errmsg("Can\'s fstat descriptor %d\n", desc);
#line 1358
    return (-12);
  }
#line 1361
  if (sb.st_size <= 5L) {
#line 1362
    cli_dbgmsg("Small data (%d bytes)\n", sb.st_size);
#line 1363
    return (0);
  }
#line 1366
  if (! root) {
#line 1367
    cli_errmsg("CRITICAL: root == NULL\n");
#line 1368
    return (-5);
  }
#line 1371
  if (! options) {
#line 1372
    cli_dbgmsg("Raw mode: No support for special files\n");
#line 1373
    tmp___0 = cli_scandesc(desc, virname, scanned, root, (short)0, (unsigned short)0);
#line 1373
    ret = tmp___0 == 1;
#line 1373
    if (ret) {
#line 1374
      cli_dbgmsg("%s found in descriptor %d\n", (*virname), desc);
    }
#line 1375
    return (ret);
  }
#line 1378
  if (options & 1U) {
#line 1378
    if (limits) {
#line 1378
      if (limits->maxreclevel) {
#line 1379
        if (arec > limits->maxreclevel) {
#line 1380
          cli_dbgmsg("Archive recursion limit exceeded (arec == %d).\n", arec);
#line 1381
          if (options & 512U) {
#line 1382
            (*virname) = "Archive.ExceededRecursionLimit";
#line 1383
            return (1);
          }
#line 1385
          return (0);
        }
      }
    }
  }
#line 1388
  if (options & 2U) {
#line 1389
    if (mrec > 15U) {
#line 1390
      cli_dbgmsg("Mail recursion level exceeded (mrec == %d).\n", mrec);
#line 1392
      return (0);
    }
  }
#line 1395
  lseek(desc, 0L, 0);
#line 1396
  type = cli_filetype2(desc);
#line 1397
  lseek(desc, 0L, 0);
#line 1399
  if ((int )type == 520) {
#line 1399
    mrec ++;
  } else {
#line 1399
    arec ++;
  }
#line 1401
  switch ((int )type) {
  case 509: ;
#line 1403
  if (! (options & 4U)) {
#line 1403
    if (options & 1U) {
#line 1403
      if (! cli_scanrar_inuse) {
#line 1404
        ret = cli_scanrar(desc, virname, scanned, root, limits, options, arec, mrec);
      }
    }
  }
#line 1405
  break;
  case 507: ;
#line 1408
  if (options & 1U) {
#line 1409
    ret = cli_scanzip(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1410
  break;
  case 506: ;
#line 1413
  if (options & 1U) {
#line 1414
    ret = cli_scangzip(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1415
  break;
  case 508: ;
#line 1419
  if (options & 1U) {
#line 1420
    ret = cli_scanbzip(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1422
  break;
  case 510: ;
#line 1425
  if (options & 1U) {
#line 1426
    ret = cli_scanszdd(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1427
  break;
  case 512: ;
#line 1430
  if (options & 1U) {
#line 1431
    ret = cli_scanmscab(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1432
  break;
  case 520: ;
#line 1435
  if (options & 2U) {
#line 1436
    ret = cli_scanmail(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1437
  break;
  case 518: ;
#line 1440
  if (options & 2U) {
#line 1441
    ret = cli_scantnef(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1442
  break;
  case 513: ;
#line 1445
  if (options & 1U) {
#line 1446
    ret = cli_scanmschm(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1447
  break;
  case 511: ;
#line 1450
  if (options & 8U) {
#line 1451
    ret = cli_scanole2(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1452
  break;
  case 504: ;
#line 1455
  if (options & 1U) {
#line 1456
    ret = cli_scantar(desc, virname, scanned, root, limits, options, arec, mrec, 1U);
  }
#line 1457
  break;
  case 505: ;
#line 1460
  if (options & 1U) {
#line 1461
    ret = cli_scantar(desc, virname, scanned, root, limits, options, arec, mrec, 0U);
  }
#line 1462
  break;
  case 517: ;
#line 1465
  if (options & 1U) {
#line 1466
    ret = cli_scanbinhex(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1467
  break;
  case 514: 
#line 1470
  ret = cli_scanscrenc(desc, virname, scanned, root, limits, options, arec, mrec);
#line 1471
  break;
  case 516: 
#line 1474
  ret = cli_scanriff(desc, virname);
#line 1475
  break;
  case 515: 
#line 1478
  ret = cli_scanjpeg(desc, virname);
#line 1479
  break;
  case 503: 
#line 1485
  tmp___1 = fstat__extinline(desc, & s);
#line 1485
  if (tmp___1 == 0) {
#line 1485
    if ((s.st_mode & 61440U) == 32768U) {
#line 1485
      if (s.st_size < 65536L) {
#line 1486
        type = (enum __anonenum_cli_file_t_36 )501;
      }
    }
  }
  case 501: 
#line 1490
  ret = cli_check_mydoom_log(desc, virname);
#line 1491
  break;
  default: ;
#line 1494
  break;
  }
#line 1497
  if ((int )type == 520) {
#line 1497
    mrec --;
  } else {
#line 1497
    arec --;
  }
#line 1499
  if ((int )type != 503) {
#line 1499
    if (ret != 1) {
#line 1502
      if ((int )type == 500) {
#line 1502
        typerec = 1;
      } else {
#line 1502
        typerec = 0;
      }
#line 1503
      tmp___2 = lseek(desc, 0L, 0);
#line 1503
      if (tmp___2 < 0L) {
#line 1504
        cli_errmsg("lseek() failed, trying to continue anyway...\n");
      }
#line 1506
      nret = cli_scandesc(desc, virname, scanned, root, (short )typerec, (unsigned short )type);
#line 1506
      if (nret == 1) {
#line 1507
        cli_dbgmsg("%s found in descriptor %d.\n", (*virname), desc);
#line 1508
        return (1);
      } else {
#line 1510
        if (nret < 0) {
#line 1511
          return (nret);
        } else {
#line 1513
          if (nret >= 500) {
#line 1514
            lseek(desc, 0L, 0);
#line 1516
            if (nret == 520) {
#line 1516
              mrec ++;
            } else {
#line 1516
              arec ++;
            }
#line 1517
            switch (nret) {
            case 519: ;
#line 1519
            if (options & 32U) {
#line 1520
              tmp___3 = cli_scanhtml(desc, virname, scanned, root, limits, options,
                                     arec, mrec);
#line 1520
              if (tmp___3 == 1) {
#line 1521
                return (1);
              }
            }
#line 1522
            break;
            case 520: ;
#line 1525
            if (options & 2U) {
#line 1526
              tmp___4 = cli_scanmail(desc, virname, scanned, root, limits, options,
                                     arec, mrec);
#line 1526
              if (tmp___4 == 1) {
#line 1527
                return (1);
              }
            }
#line 1528
            break;
            }
#line 1530
            if (nret == 520) {
#line 1530
              mrec --;
            } else {
#line 1530
              arec --;
            }
          }
        }
      }
    }
  }
#line 1534
  arec ++;
#line 1535
  lseek(desc, 0L, 0);
#line 1536
  switch ((int )type) {
  case 502: ;
#line 1541
  if (options & 64U) {
#line 1542
    ret = cli_scanpe(desc, virname, scanned, root, limits, options, arec, mrec);
  }
#line 1543
  break;
  default: ;
#line 1546
  break;
  }
#line 1548
  arec --;
#line 1550
  if (ret == -13) {
#line 1551
    tmp___5 = cl_strerror(-13);
#line 1551
    cli_dbgmsg("Descriptor[%d]: %s\n", desc, tmp___5);
#line 1552
    return (0);
  } else {
#line 1554
    return (ret);
  }
}
}
#line 1558 "scanners.c"
int cl_scandesc(int desc , char const   **virname , unsigned long *scanned , struct cl_node  const  *root ,
                struct cl_limits  const  *limits , unsigned int options ) 
{ int tmp ;

  {
#line 1560
  tmp = cli_magic_scandesc(desc, virname, (long *)scanned, root, limits, options,
                           0U, 0U);
#line 1560
  return (tmp);
}
}
#line 1563 "scanners.c"
static int cli_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                        struct cl_node  const  *root , struct cl_limits  const  *limits ,
                        unsigned int options , unsigned int arec , unsigned int mrec ) 
{ int fd ;
  int ret ;

  {
#line 1569
  fd = open(filename, 0);
#line 1569
  if (fd == -1) {
#line 1570
    return (-4);
  }
#line 1572
  ret = cli_magic_scandesc(fd, virname, (long *)scanned, root, limits, options, arec,
                           mrec);
#line 1574
  close(fd);
#line 1575
  return (ret);
}
}
#line 1578 "scanners.c"
int cl_scanfile(char const   *filename , char const   **virname , unsigned long *scanned ,
                struct cl_node  const  *root , struct cl_limits  const  *limits ,
                unsigned int options ) 
{ int fd ;
  int ret ;

  {
#line 1583
  fd = open(filename, 0);
#line 1583
  if (fd == -1) {
#line 1584
    return (-4);
  }
#line 1586
  ret = cl_scandesc(fd, virname, scanned, root, limits, options);
#line 1587
  close(fd);
#line 1589
  return (ret);
}
}
#line 1 "filetypes.lo"
#pragma merger(0,"/tmp/cil-tACYxtrw.i","-g -O2 -fPIC")
#line 53 "filetypes.h"
cli_file_t cli_filetype(char const   *buf , size_t buflen ) ;
#line 48 "filetypes.c"
static struct cli_magic_s  const  cli_magic[57]  = 
#line 48
  {      {0, "MZ", 2U, "DOS/W32 executable/library/driver", (cli_file_t )502}, 
        {0, "Rar!", 4U, "RAR", (cli_file_t )509}, 
        {0, "PK\003\004", 4U, "ZIP", (cli_file_t )507}, 
        {0, "PK00PK\003\004", 8U, "ZIP", (cli_file_t )507}, 
        {0, "\037\213", 2U, "GZip", (cli_file_t )506}, 
        {0, "BZh", 3U, "BZip", (cli_file_t )508}, 
        {0, "SZDD", 4U, "compress.exe\'d", (cli_file_t )510}, 
        {0, "MSCF", 4U, "MS CAB", (cli_file_t )512}, 
        {0, "ITSF", 4U, "MS CHM", (cli_file_t )513}, 
        {0, "#@~^", 4U, "SCRENC", (cli_file_t )514}, 
        {0, "(This file must be converted with BinHex 4.0)", 45U, "BinHex", (cli_file_t )517}, 
        {0,
      "From ", 5U, "MBox", (cli_file_t )520}, 
        {0, "Received: ", 10U, "Raw mail", (cli_file_t )520}, 
        {0, "Return-Path: ", 13U, "Maildir", (cli_file_t )520}, 
        {0, "Return-path: ", 13U, "Maildir", (cli_file_t )520}, 
        {0, "Delivered-To: ", 14U, "Mail", (cli_file_t )520}, 
        {0, "X-UIDL: ", 8U, "Mail", (cli_file_t )520}, 
        {0, "X-Apparently-To: ", 17U, "Mail", (cli_file_t )520}, 
        {0, "X-Envelope-From: ", 17U, "Mail", (cli_file_t )520}, 
        {0, "X-Original-To: ", 15U, "Mail", (cli_file_t )520}, 
        {0, "X-Symantec-", 11U, "Symantec", (cli_file_t )520}, 
        {0, "X-EVS", 5U, "EVS mail", (cli_file_t )520}, 
        {0, "X-Real-To: ", 11U, "Mail", (cli_file_t )520}, 
        {0, "X-Sieve: ", 9U, "Mail", (cli_file_t )520}, 
        {0, ">From ", 6U, "Mail", (cli_file_t )520}, 
        {0, "Date: ", 6U, "Mail", (cli_file_t )520}, 
        {0, "Message-Id: ", 12U, "Mail", (cli_file_t )520}, 
        {0, "Message-ID: ", 12U, "Mail", (cli_file_t )520}, 
        {0, "Envelope-to: ", 13U, "Mail", (cli_file_t )520}, 
        {0, "Delivery-date: ", 15U, "Mail", (cli_file_t )520}, 
        {0, "To: ", 4U, "Mail", (cli_file_t )520}, 
        {0, "Subject: ", 9U, "Mail", (cli_file_t )520}, 
        {0, "For: ", 5U, "Eserv mail", (cli_file_t )520}, 
        {0, "From: ", 6U, "Exim mail", (cli_file_t )520}, 
        {0, "v:\r\nReceived: ", 14U, "VPOP3 Mail (DOS)", (cli_file_t )520}, 
        {0, "v:\nReceived: ", 13U, "VPOP3 Mail (UNIX)", (cli_file_t )520}, 
        {0, "Hi. This is the qmail-send", 26U, "Qmail bounce", (cli_file_t )520}, 
        {0, "x\237>\"", 4U, "TNEF", (cli_file_t )518}, 
        {0, "\320\317\021\340\241\261\032\341", 8U, "OLE2 container", (cli_file_t )511}, 
        {0,
      "GIF", 3U, "GIF", (cli_file_t )515}, 
        {0, "BM", 2U, "BMP", (cli_file_t )515}, 
        {0, "\377\330\377", 3U, "JPEG", (cli_file_t )515}, 
        {6, "JFIF", 4U, "JPEG", (cli_file_t )515}, 
        {6, "Exif", 4U, "JPEG", (cli_file_t )515}, 
        {0, "\211PNG", 4U, "PNG", (cli_file_t )515}, 
        {0, "RIFF", 4U, "RIFF", (cli_file_t )516}, 
        {0, "RIFX", 4U, "RIFX", (cli_file_t )516}, 
        {0, "\000\000\001\263", 4U, "MPEG video stream", (cli_file_t )503}, 
        {0, "\000\000\001\272", 4U, "MPEG sys stream", (cli_file_t )503}, 
        {0, "OggS", 4U, "Ogg Stream", (cli_file_t )503}, 
        {0, "ID3", 3U, "MP3", (cli_file_t )503}, 
        {0, "\377\373\220", 3U, "MP3", (cli_file_t )503}, 
        {0, "%PDF-", 5U, "PDF document", (cli_file_t )503}, 
        {0, "%!PS-Adobe-", 11U, "PostScript", (cli_file_t )503}, 
        {0, "0&\262u\216f\317", 7U, "WMA/WMV/ASF", (cli_file_t )503}, 
        {0, ".RMF", 4U, "Real Media File", (cli_file_t )503}, 
        {-1, (char const   *)((void *)0), 0U, (char const   *)((void *)0), (cli_file_t )501}};
#line 129 "filetypes.c"
static struct cli_smagic_s  const  cli_smagic[33]  = 
#line 129
  {      {"0a46726f6d3a20{-2048}0a436f6e74656e742d547970653a20", "Mail file", (cli_file_t )520}, 
        {"0a52656365697665643a20{-2048}0a436f6e74656e742d547970653a20",
      "Mail file", (cli_file_t )520}, 
        {"0a52656365697665643a20{-2048}0a436f6e74656e742d747970653a20", "Mail file",
      (cli_file_t )520}, 
        {"4d494d452d56657273696f6e3a20{-2048}0a436f6e74656e742d547970653a20", "Mail file",
      (cli_file_t )520}, 
        {"3c62723e", "HTML data", (cli_file_t )519}, 
        {"3c42723e", "HTML data", (cli_file_t )519}, 
        {"3c42523e", "HTML data", (cli_file_t )519}, 
        {"3c703e", "HTML data", (cli_file_t )519}, 
        {"3c503e", "HTML data", (cli_file_t )519}, 
        {"68726566", "HTML data", (cli_file_t )519}, 
        {"48726566", "HTML data", (cli_file_t )519}, 
        {"48524546", "HTML data", (cli_file_t )519}, 
        {"3c68746d6c3e", "HTML data", (cli_file_t )519}, 
        {"3c48544d4c3e", "HTML data", (cli_file_t )519}, 
        {"3c48746d6c3e", "HTML data", (cli_file_t )519}, 
        {"3c686561643e", "HTML data", (cli_file_t )519}, 
        {"3c484541443e", "HTML data", (cli_file_t )519}, 
        {"3c486561643e", "HTML data", (cli_file_t )519}, 
        {"3c666f6e74", "HTML data", (cli_file_t )519}, 
        {"3c466f6e74", "HTML data", (cli_file_t )519}, 
        {"3c464f4e54", "HTML data", (cli_file_t )519}, 
        {"3c696d67", "HTML data", (cli_file_t )519}, 
        {"3c494d47", "HTML data", (cli_file_t )519}, 
        {"3c496d67", "HTML data", (cli_file_t )519}, 
        {"3c736372697074", "HTML data", (cli_file_t )519}, 
        {"3c536372697074", "HTML data", (cli_file_t )519}, 
        {"3c534352495054", "HTML data", (cli_file_t )519}, 
        {"3c6f626a656374", "HTML data", (cli_file_t )519}, 
        {"3c4f626a656374", "HTML data", (cli_file_t )519}, 
        {"3c4f424a454354", "HTML data", (cli_file_t )519}, 
        {"3c696672616d65", "HTML data", (cli_file_t )519}, 
        {"3c494652414d45", "HTML data", (cli_file_t )519}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (cli_file_t )501}};
#line 176 "filetypes.c"
static char internat[256]  = 
#line 176
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)1, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1};
#line 196 "filetypes.c"
cli_file_t cli_filetype(char const   *buf , size_t buflen ) 
{ int i ;
  int ascii ;
  int len ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
#line 198
  ascii = 1;
#line 201
  i = 0;
#line 201
  while (cli_magic[i].magic) {
#line 202
    if (buflen >= (unsigned int )cli_magic[i].offset + cli_magic[i].length) {
#line 203
      tmp = memcmp((void const   *)(buf + cli_magic[i].offset), (void const   *)cli_magic[i].magic,
                   cli_magic[i].length);
#line 203
      if (tmp == 0) {
#line 204
        cli_dbgmsg("Recognized %s file\n", cli_magic[i].descr);
#line 205
        return (cli_magic[i].type);
      }
    }
#line 201
    i ++;
  }
#line 210
  if (buflen < 25U) {
#line 210
    len = (int )buflen;
  } else {
#line 210
    len = 25;
  }
#line 211
  i = 0;
#line 211
  while (i < len) {
#line 212
    tmp___0 = __ctype_b_loc();
#line 212
    if (! ((int const   )(*((*tmp___0) + (int )(*(buf + i)))) & 2)) {
#line 212
      tmp___1 = __ctype_b_loc();
#line 212
      if (! ((int const   )(*((*tmp___1) + (int )(*(buf + i)))) & 16384)) {
#line 212
        if (! internat[(int const   )(*(buf + i)) & 255]) {
#line 213
          ascii = 0;
#line 214
          break;
        }
      }
    }
#line 211
    i ++;
  }
#line 217
  if (ascii) {
#line 217
    tmp___2 = 500;
  } else {
#line 217
    tmp___2 = 501;
  }
#line 217
  return ((enum __anonenum_cli_file_t_36 )tmp___2);
}
}
#line 220
int is_tar(unsigned char *buf , int nbytes ) ;
#line 222 "filetypes.c"
cli_file_t cli_filetype2(int desc ) 
{ char smallbuff[51] ;
  unsigned char *bigbuff ;
  int bread ;
  cli_file_t ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 227
  ret = (enum __anonenum_cli_file_t_36 )501;
#line 230
  memset((void *)(smallbuff), 0, sizeof(smallbuff));
#line 231
  bread = read(desc, (void *)(smallbuff), 50U);
#line 231
  if (bread > 0) {
#line 232
    ret = cli_filetype((char const   *)(smallbuff), (unsigned int )bread);
  }
#line 234
  if ((int )ret == 501) {
    goto _L___0;
  } else {
#line 234
    if ((int )ret == 500) {
      _L___0: 
#line 236
      bigbuff = (unsigned char *)cli_calloc(37639U, sizeof(unsigned char ));
#line 236
      if (! bigbuff) {
#line 237
        return (ret);
      }
#line 239
      lseek(desc, 0L, 0);
#line 240
      bread = read(desc, (void *)bigbuff, 37638U);
#line 240
      if (bread > 0) {
#line 242
        (*(bigbuff + bread)) = (unsigned char)0;
#line 244
        tmp___0 = is_tar(bigbuff, bread);
#line 244
        switch (tmp___0) {
        case 1: 
#line 246
        ret = (enum __anonenum_cli_file_t_36 )505;
#line 247
        cli_dbgmsg("Recognized old fashioned tar file\n");
#line 248
        break;
        case 2: 
#line 250
        ret = (enum __anonenum_cli_file_t_36 )504;
#line 251
        cli_dbgmsg("Recognized POSIX tar file\n");
#line 252
        break;
        }
      }
#line 256
      if ((int )ret == 501) {
        goto _L;
      } else {
#line 256
        if ((int )ret == 500) {
          _L: 
#line 258
          tmp___2 = memcmp((void const   *)(bigbuff + 32769), (void const   *)"CD001",
                           5U);
#line 258
          if (tmp___2) {
#line 258
            tmp___3 = memcmp((void const   *)(bigbuff + 37633), (void const   *)"CD001",
                             5U);
#line 258
            if (tmp___3) {
#line 261
              tmp___1 = memcmp((void const   *)(bigbuff + 32776), (void const   *)"CDROM",
                               5U);
#line 261
              if (! tmp___1) {
#line 262
                cli_dbgmsg("Recognized High Sierra CD-ROM data\n");
#line 263
                ret = (enum __anonenum_cli_file_t_36 )503;
              }
            } else {
#line 259
              cli_dbgmsg("Recognized ISO 9660 CD-ROM data\n");
#line 260
              ret = (enum __anonenum_cli_file_t_36 )503;
            }
          } else {
#line 259
            cli_dbgmsg("Recognized ISO 9660 CD-ROM data\n");
#line 260
            ret = (enum __anonenum_cli_file_t_36 )503;
          }
        }
      }
#line 267
      free((void *)bigbuff);
    }
  }
#line 270
  return (ret);
}
}
#line 273 "filetypes.c"
int cli_addtypesigs(struct cl_node *root ) 
{ int i ;
  int ret ;

  {
#line 277
  i = 0;
#line 277
  while (cli_smagic[i].sig) {
#line 278
    ret = cli_parse_add(root, cli_smagic[i].descr, cli_smagic[i].sig, (unsigned short )cli_smagic[i].type,
                        (char *)((void *)0), (unsigned short)0);
#line 278
    if (ret) {
#line 279
      cli_errmsg("cli_addtypesigs(): Problem adding signature for %s\n", cli_smagic[i].descr);
#line 280
      return (ret);
    }
#line 277
    i ++;
  }
#line 284
  return (0);
}
}
#line 1 "unrarlib.lo"
#pragma merger(0,"/tmp/cil-NiGKGYfs.i","-g -O2 -fPIC")
#line 650 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 778 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 85 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 196
__inline static  __attribute__((__nothrow__)) int toupper__extinline(int __c ) ;
#line 196
__inline static  __attribute__((__nothrow__)) int toupper__extinline(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper__extinline(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = (*((*tmp___1) + __c));
    } else {
#line 199
      tmp___0 = __c;
    }
  } else {
#line 199
    tmp___0 = __c;
  }
#line 199
  return (tmp___0);
}
}
#line 301 "unrarlib.c"
static struct MarkHeader MarkHead  ;
#line 302 "unrarlib.c"
static struct NewMainArchiveHeader NewMhd  ;
#line 303 "unrarlib.c"
static struct NewFileHeader NewLhd  ;
#line 304 "unrarlib.c"
static struct BlockHeader BlockHead  ;
#line 306 "unrarlib.c"
static UBYTE *TempMemory  =    (UBYTE *)((void *)0);
#line 307 "unrarlib.c"
static char *CommMemory  =    (char *)((void *)0);
#line 310 "unrarlib.c"
static UBYTE *UnpMemory  =    (UBYTE *)((void *)0);
#line 311 "unrarlib.c"
static char ArgName[260]  ;
#line 312 "unrarlib.c"
static char ArcFileName[260]  ;
#line 317 "unrarlib.c"
static FILE *ArcPtr  ;
#line 319 "unrarlib.c"
static char Password[255]  ;
#line 321 "unrarlib.c"
static unsigned char *temp_output_buffer  ;
#line 322 "unrarlib.c"
static unsigned long *temp_output_buffer_offset  ;
#line 324 "unrarlib.c"
static int MainHeadSize  ;
#line 326 "unrarlib.c"
static long CurBlockPos  ;
#line 326 "unrarlib.c"
static long NextBlockPos  ;
#line 328 "unrarlib.c"
static unsigned long CurUnpRead  ;
#line 329 "unrarlib.c"
static long UnpPackedSize  ;
#line 330 "unrarlib.c"
static long DestUnpSize  ;
#line 332 "unrarlib.c"
static UDWORD HeaderCRC  ;
#line 333 "unrarlib.c"
static int Encryption  ;
#line 335 "unrarlib.c"
static unsigned int UnpPtr  ;
#line 335 "unrarlib.c"
static unsigned int WrPtr  ;
#line 337 "unrarlib.c"
static unsigned char PN1  ;
#line 337 "unrarlib.c"
static unsigned char PN2  ;
#line 337 "unrarlib.c"
static unsigned char PN3  ;
#line 338 "unrarlib.c"
static unsigned short OldKey[4]  ;
#line 343
static int ReadHeader(int BlockType ) ;
#line 344
static BOOL ExtrFile(int desc ) ;
#line 345
static int tread(void *stream , void *buf , unsigned int len ) ;
#line 346
static int tseek(void *stream , long offset , int fromwhere ) ;
#line 348
static int IsArchive(void) ;
#line 349
static int ReadBlock(int BlockType ) ;
#line 350
static unsigned int UnpRead(unsigned char *Addr , unsigned int Count ) ;
#line 351
static void UnpInitData(void) ;
#line 352
static void Unpack(unsigned char *UnpAddr , BOOL FileFound ) ;
#line 353
static UBYTE DecodeAudio(int Delta ) ;
#line 354
static void DecodeNumber(struct Decode *Deco ) ;
#line 355
static void UpdKeys(UBYTE *Buf ) ;
#line 356
static void SetCryptKeys(char *NewPassword ) ;
#line 357
static void SetOldKeys(char *NewPassword ) ;
#line 358
static void DecryptBlock(unsigned char *Buf ) ;
#line 359
static void InitCRC(void) ;
#line 360
static UDWORD CalcCRC32(UDWORD StartCRC , UBYTE *Addr , UDWORD Size ) ;
#line 361
static void UnpReadBuf(int FirstBuf ) ;
#line 362
static void ReadTables(void) ;
#line 363
static void ReadLastTables(void) ;
#line 364
static void MakeDecodeTables(unsigned char *LenTab , struct Decode *Dec , int Size ) ;
#line 367
static int stricomp(char *Str1 , char *Str2 ) ;
#line 373 "unrarlib.c"
int urarlib_get(void *output , unsigned long *size , char *filename , int desc , char *libpassword ) 
{ BOOL retcode ;

  {
#line 384
  retcode = (short)0;
#line 398
  InitCRC();
#line 400
  strcpy((char * __restrict  )(ArgName), (char const   * __restrict  )filename);
#line 404
  if ((unsigned int )libpassword != (unsigned int )((void *)0)) {
#line 405
    strcpy((char * __restrict  )(Password), (char const   * __restrict  )libpassword);
  }
#line 407
  temp_output_buffer = (unsigned char *)((void *)0);
#line 408
  temp_output_buffer_offset = size;
#line 410
  retcode = ExtrFile(desc);
#line 413
  memset((void *)(Password), 0, sizeof(Password));
#line 416
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 418
    cli_dbgmsg("%s:%d NOT Close ArcPtr from fd %d\n", "unrarlib.c", 418, desc);
  }
#line 427
  if (UnpMemory) {
#line 428
    free((void *)UnpMemory);
  }
#line 430
  if (TempMemory) {
#line 431
    free((void *)TempMemory);
  }
#line 433
  if (CommMemory) {
#line 434
    free((void *)CommMemory);
  }
#line 436
  UnpMemory = (UBYTE *)((void *)0);
#line 437
  TempMemory = (UBYTE *)((void *)0);
#line 438
  CommMemory = (char *)((void *)0);
#line 441
  if ((int )retcode == 0) {
#line 443
    if (temp_output_buffer) {
#line 444
      free((void *)temp_output_buffer);
    }
#line 445
    temp_output_buffer = (unsigned char *)((void *)0);
#line 446
    (*((DWORD *)output)) = 0L;
#line 447
    (*size) = 0UL;
  }
#line 467
  (*((DWORD *)output)) = (long )temp_output_buffer;
#line 470
  return ((int )retcode);
}
}
#line 474 "unrarlib.c"
int urarlib_list(int desc , ArchiveList_struct *list ) 
{ ArchiveList_struct *tmp_List ;
  int NoOfFilesInArchive ;
  int newdesc ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int ReadBlockResult ;

  {
#line 476
  tmp_List = (ArchiveList_struct *)((void *)0);
#line 477
  NoOfFilesInArchive = 0;
#line 488
  InitCRC();
#line 500
  newdesc = dup(desc);
#line 501
  cli_dbgmsg("ExtrFile(): dup(%d) = %d\n", desc, newdesc);
#line 502
  ArcPtr = fdopen(newdesc, "r");
#line 502
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 504
    tmp = IsArchive();
#line 504
    if (! tmp) {
#line 506
      cli_dbgmsg("urarlib_list(): Not a valid archive.");
#line 507
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 507, "Not a RAR file");
#line 508
      fclose(ArcPtr);
#line 509
      lseek(desc, 0L, 0);
#line 510
      ArcPtr = (FILE *)((void *)0);
#line 511
      return (NoOfFilesInArchive);
    }
  } else {
#line 515
    tmp___0 = __errno_location();
#line 515
    tmp___1 = strerror((*tmp___0));
#line 515
    cli_dbgmsg("urarlib_list(): Error opening file: %s", tmp___1);
#line 516
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 516, "Error opening file.");
#line 517
    cli_dbgmsg("%s:%d Close fd %d\n", "unrarlib.c", 517, newdesc);
#line 518
    close(newdesc);
#line 519
    return (NoOfFilesInArchive);
  }
#line 523
  UnpMemory = (UBYTE *)malloc(1048576U);
#line 523
  if ((unsigned int )UnpMemory == (unsigned int )((void *)0)) {
#line 525
    cli_dbgmsg("urarlib_list(): out of memory.");
#line 526
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 526, "Can\'t allocate memory for decompression!");
#line 527
    fclose(ArcPtr);
#line 528
    return (NoOfFilesInArchive);
  }
#line 534
  tseek((void *)ArcPtr, (long )((int )NewMhd.HeadSize - MainHeadSize), 1);
#line 536
  (*((DWORD *)list)) = (long )((void *)0);
#line 538
  while (1) {
#line 541
    ReadBlockResult = ReadBlock(32884);
#line 541
    if (ReadBlockResult <= 0) {
#line 543
      cli_dbgmsg("Couldn\'t read next filename from archive (I/O error): %d\n", ReadBlockResult);
#line 544
      break;
    }
#line 546
    if ((int )BlockHead.HeadType == 119) {
#line 548
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 548, "Sorry, sub-headers not supported.");
#line 549
      NoOfFilesInArchive = 0;
#line 550
      break;
    }
#line 553
    if ((unsigned int )((void *)(*((DWORD *)list))) == (unsigned int )((void *)0)) {
#line 555
      tmp_List = (ArchiveList_struct *)malloc(sizeof(ArchiveList_struct ));
#line 556
      tmp_List->next = (struct archivelist *)((void *)0);
#line 558
      (*((DWORD *)list)) = (long )tmp_List;
    } else {
#line 562
      tmp_List->next = (struct archivelist *)malloc(sizeof(ArchiveList_struct ));
#line 563
      tmp_List = tmp_List->next;
#line 564
      tmp_List->next = (struct archivelist *)((void *)0);
    }
#line 567
    tmp_List->item.Name = (char *)malloc((unsigned int )((int )NewLhd.NameSize + 1));
#line 568
    strcpy((char * __restrict  )tmp_List->item.Name, (char const   * __restrict  )(ArcFileName));
#line 569
    tmp_List->item.NameSize = NewLhd.NameSize;
#line 570
    tmp_List->item.PackSize = NewLhd.PackSize;
#line 571
    tmp_List->item.UnpSize = NewLhd.UnpSize;
#line 572
    tmp_List->item.HostOS = NewLhd.HostOS;
#line 573
    tmp_List->item.FileCRC = NewLhd.FileCRC;
#line 574
    tmp_List->item.FileTime = NewLhd.FileTime;
#line 575
    tmp_List->item.UnpVer = NewLhd.UnpVer;
#line 576
    tmp_List->item.Method = NewLhd.Method;
#line 577
    tmp_List->item.FileAttr = NewLhd.FileAttr;
#line 578
    tmp_List->item.Flags = NewLhd.Flags;
#line 580
    NoOfFilesInArchive ++;
#line 585
    if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 585
      tseek((void *)ArcPtr, NextBlockPos, 0);
    }
  }
#line 591
  memset((void *)(Password), 0, sizeof(Password));
#line 593
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 594
    fclose(ArcPtr);
#line 595
    ArcPtr = (FILE *)((void *)0);
#line 596
    lseek(desc, 0L, 0);
  }
#line 600
  if (UnpMemory) {
#line 601
    free((void *)UnpMemory);
  }
#line 603
  if (TempMemory) {
#line 604
    free((void *)TempMemory);
  }
#line 606
  if (CommMemory) {
#line 607
    free((void *)CommMemory);
  }
#line 609
  UnpMemory = (UBYTE *)((void *)0);
#line 610
  TempMemory = (UBYTE *)((void *)0);
#line 611
  CommMemory = (char *)((void *)0);
#line 613
  return (NoOfFilesInArchive);
}
}
#line 627 "unrarlib.c"
void urarlib_freelist(ArchiveList_struct *list ) 
{ ArchiveList_struct *tmp ;

  {
#line 629
  tmp = list;
#line 631
  while (list) {
#line 632
    tmp = list->next;
#line 633
    free((void *)list->item.Name);
#line 634
    free((void *)list);
#line 635
    list = tmp;
  }
#line 637
  return;
}
}
#line 689 "unrarlib.c"
static int LastBlock  ;
#line 685 "unrarlib.c"
static int ReadBlock(int BlockType ) 
{ struct NewFileHeader SaveFileHead ;
  int Size ;
  int ReadSubBlock ;

  {
#line 688
  Size = 0;
#line 688
  ReadSubBlock = 0;
#line 690
  memcpy((void * __restrict  )(& SaveFileHead), (void const   * __restrict  )(& NewLhd),
         sizeof(SaveFileHead));
#line 691
  if (BlockType & 32768) {
#line 692
    ReadSubBlock = 1;
#line 693
    BlockType &= 255;
  }
#line 696
  while (1) {
#line 701
    CurBlockPos = ftell(ArcPtr);
#line 703
    Size = ReadHeader(116);
#line 704
    if (Size != 0) {
#line 706
      if ((int )NewLhd.HeadSize < 7) {
#line 707
        return (0);
      }
#line 708
      NextBlockPos = CurBlockPos + (long )NewLhd.HeadSize;
#line 709
      if ((int )NewLhd.Flags & 32768) {
#line 710
        NextBlockPos = (long )((unsigned long )NextBlockPos + NewLhd.PackSize);
      }
#line 711
      if (NextBlockPos <= CurBlockPos) {
#line 712
        return (0);
      }
    }
#line 715
    if (Size > 0) {
#line 715
      if (BlockType != 119) {
#line 716
        LastBlock = BlockType;
      }
    }
#line 717
    if (Size == 0) {
#line 719
      break;
    } else {
#line 717
      if (BlockType == 0) {
#line 719
        break;
      } else {
#line 717
        if ((int )NewLhd.HeadType == BlockType) {
#line 719
          break;
        } else {
#line 717
          if ((int )NewLhd.HeadType == 119) {
#line 717
            if (ReadSubBlock) {
#line 717
              if (LastBlock == BlockType) {
#line 719
                break;
              }
            }
          }
        }
      }
    }
#line 723
    tseek((void *)ArcPtr, NextBlockPos, 0);
  }
#line 728
  BlockHead.HeadCRC = NewLhd.HeadCRC;
#line 729
  BlockHead.HeadType = NewLhd.HeadType;
#line 730
  BlockHead.Flags = NewLhd.Flags;
#line 731
  BlockHead.HeadSize = NewLhd.HeadSize;
#line 732
  BlockHead.DataSize = NewLhd.PackSize;
#line 734
  if (BlockType != (int )NewLhd.HeadType) {
#line 734
    BlockType = 0;
  }
#line 736
  if (116 == BlockType) {
#line 736
    if (Size > 0) {
#line 738
      if ((unsigned int )NewLhd.NameSize < sizeof(ArcFileName) - 1U) {
#line 738
        NewLhd.NameSize = NewLhd.NameSize;
      } else {
#line 738
        NewLhd.NameSize = (unsigned short )(sizeof(ArcFileName) - 1U);
      }
#line 742
      tread((void *)ArcPtr, (void *)(ArcFileName), (unsigned int )NewLhd.NameSize);
#line 744
      ArcFileName[NewLhd.NameSize] = (char)0;
#line 752
      Size += (int )NewLhd.NameSize;
    } else {
#line 755
      memcpy((void * __restrict  )(& NewLhd), (void const   * __restrict  )(& SaveFileHead),
             sizeof(NewLhd));
#line 759
      tseek((void *)ArcPtr, CurBlockPos, 0);
    }
  } else {
#line 755
    memcpy((void * __restrict  )(& NewLhd), (void const   * __restrict  )(& SaveFileHead),
           sizeof(NewLhd));
#line 759
    tseek((void *)ArcPtr, CurBlockPos, 0);
  }
#line 764
  return (Size);
}
}
#line 768 "unrarlib.c"
static int ReadHeader(int BlockType ) 
{ int Size ;
  unsigned char Header[64] ;

  {
#line 770
  Size = 0;
#line 772
  memset((void *)(Header), 0, sizeof(Header));
#line 773
  switch (BlockType) {
  case 115: 
#line 779
  Size = tread((void *)ArcPtr, (void *)(Header), 13U);
#line 781
  NewMhd.HeadCRC = (unsigned short )((int )Header[0] + ((int )((unsigned short )Header[1]) <<
                                                        8));
#line 782
  NewMhd.HeadType = Header[2];
#line 783
  NewMhd.Flags = (unsigned short )((int )Header[3] + ((int )((unsigned short )Header[4]) <<
                                                      8));
#line 784
  NewMhd.HeadSize = (unsigned short )((int )Header[5] + ((int )((unsigned short )Header[6]) <<
                                                         8));
#line 785
  NewMhd.Reserved = (unsigned short )((int )Header[7] + ((int )((unsigned short )Header[8]) <<
                                                         8));
#line 786
  NewMhd.Reserved1 = ((unsigned long )((int )Header[9] + ((int )((unsigned short )Header[10]) <<
                                                          8)) + ((unsigned long )Header[11] <<
                                                                 16)) + ((unsigned long )Header[12] <<
                                                                         24);
#line 787
  HeaderCRC = CalcCRC32(4294967295UL, & Header[2], 11UL);
#line 788
  break;
  case 116: 
#line 793
  Size = tread((void *)ArcPtr, (void *)(Header), 32U);
#line 795
  NewLhd.HeadCRC = (unsigned short )((int )Header[0] + ((int )((unsigned short )Header[1]) <<
                                                        8));
#line 796
  NewLhd.HeadType = Header[2];
#line 797
  NewLhd.Flags = (unsigned short )((int )Header[3] + ((int )((unsigned short )Header[4]) <<
                                                      8));
#line 798
  NewLhd.HeadSize = (unsigned short )((int )Header[5] + ((int )((unsigned short )Header[6]) <<
                                                         8));
#line 799
  NewLhd.PackSize = ((unsigned long )((int )Header[7] + ((int )((unsigned short )Header[8]) <<
                                                         8)) + ((unsigned long )Header[9] <<
                                                                16)) + ((unsigned long )Header[10] <<
                                                                        24);
#line 800
  NewLhd.UnpSize = ((unsigned long )((int )Header[11] + ((int )((unsigned short )Header[12]) <<
                                                         8)) + ((unsigned long )Header[13] <<
                                                                16)) + ((unsigned long )Header[14] <<
                                                                        24);
#line 801
  NewLhd.HostOS = Header[15];
#line 802
  NewLhd.FileCRC = ((unsigned long )((int )Header[16] + ((int )((unsigned short )Header[17]) <<
                                                         8)) + ((unsigned long )Header[18] <<
                                                                16)) + ((unsigned long )Header[19] <<
                                                                        24);
#line 803
  NewLhd.FileTime = ((unsigned long )((int )Header[20] + ((int )((unsigned short )Header[21]) <<
                                                          8)) + ((unsigned long )Header[22] <<
                                                                 16)) + ((unsigned long )Header[23] <<
                                                                         24);
#line 804
  NewLhd.UnpVer = Header[24];
#line 805
  NewLhd.Method = Header[25];
#line 806
  NewLhd.NameSize = (unsigned short )((int )Header[26] + ((int )((unsigned short )Header[27]) <<
                                                          8));
#line 807
  NewLhd.FileAttr = ((unsigned long )((int )Header[28] + ((int )((unsigned short )Header[29]) <<
                                                          8)) + ((unsigned long )Header[30] <<
                                                                 16)) + ((unsigned long )Header[31] <<
                                                                         24);
#line 808
  HeaderCRC = CalcCRC32(4294967295UL, Header + 2, 30UL);
#line 809
  break;
  default: ;
#line 826
  break;
  }
#line 829
  return (Size);
}
}
#line 870 "unrarlib.c"
static int IsArchive(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 883
  tmp = tread((void *)ArcPtr, (void *)(MarkHead.Mark), 7U);
#line 883
  if (tmp != 7) {
#line 884
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 884, "IsArchive(): short read: FALSE");
#line 885
    return (0);
  }
#line 889
  if ((int )MarkHead.Mark[0] == 82) {
#line 889
    if ((int )MarkHead.Mark[1] == 69) {
#line 889
      if ((int )MarkHead.Mark[2] == 126) {
#line 889
        if ((int )MarkHead.Mark[3] == 94) {
#line 892
          cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 892, "Attention: format as OLD detected! Can\'t handle archive!");
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: 
#line 896
    if ((int )MarkHead.Mark[0] == 82) {
#line 896
      if ((int )MarkHead.Mark[1] == 97) {
#line 896
        if ((int )MarkHead.Mark[2] == 114) {
#line 896
          if ((int )MarkHead.Mark[3] == 33) {
#line 896
            if ((int )MarkHead.Mark[4] == 26) {
#line 896
              if ((int )MarkHead.Mark[5] == 7) {
#line 896
                if ((int )MarkHead.Mark[6] == 0) {
                  goto _L;
                } else {
                  goto _L___5;
                }
              } else {
                goto _L___5;
              }
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else {
          goto _L___5;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
#line 896
      if ((int )MarkHead.Mark[0] == 85) {
#line 896
        if ((int )MarkHead.Mark[1] == 110) {
#line 896
          if ((int )MarkHead.Mark[2] == 105) {
#line 896
            if ((int )MarkHead.Mark[3] == 113) {
#line 896
              if ((int )MarkHead.Mark[4] == 117) {
#line 896
                if ((int )MarkHead.Mark[5] == 69) {
#line 896
                  if ((int )MarkHead.Mark[6] == 33) {
                    _L: 
#line 907
                    tmp___0 = ReadHeader(115);
#line 907
                    if (tmp___0 != 13) {
#line 908
                      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 908, "IsArchive(): ReadHeader() failed");
#line 909
                      return (0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 928
  MainHeadSize = 13;
#line 930
  return (1);
}
}
#line 934 "unrarlib.c"
static BOOL ExtrFile(int desc ) 
{ BOOL ReturnCode ;
  BOOL FileFound ;
  int newdesc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  UDWORD tmp___2 ;
  int tmp___3 ;

  {
#line 936
  ReturnCode = (short)1;
#line 937
  FileFound = (short)0;
#line 952
  newdesc = dup(desc);
#line 953
  cli_dbgmsg("ExtrFile(): dup(%d) = %d\n", desc, newdesc);
#line 954
  ArcPtr = fdopen(newdesc, "r");
#line 954
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 956
    tmp = IsArchive();
#line 956
    if (! tmp) {
#line 958
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 958, "Not a RAR file");
#line 959
      fclose(ArcPtr);
#line 960
      ArcPtr = (FILE *)((void *)0);
#line 961
      return ((short)0);
    }
  } else {
#line 965
    cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 965, "Error opening file.");
#line 966
    return ((short)0);
  }
#line 971
  UnpMemory = (UBYTE *)malloc(1048576U);
#line 971
  if ((unsigned int )UnpMemory == (unsigned int )((void *)0)) {
#line 973
    cli_dbgmsg("unrarlib: Can\'t allocate memory for decompression!");
#line 974
    return ((short)0);
  } else {
#line 975
    cli_dbgmsg("unrarlib: Allocated %d bytes.\n", 1048576);
  }
#line 980
  tseek((void *)ArcPtr, (long )((int )NewMhd.HeadSize - MainHeadSize), 1);
#line 984
  while (1) {
#line 987
    tmp___0 = ReadBlock(32884);
#line 987
    if (tmp___0 <= 0) {
#line 1000
      ReturnCode = (short)0;
#line 1001
      break;
    }
#line 1003
    if ((int )BlockHead.HeadType == 119) {
#line 1005
      cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1005, "Sorry, sub-headers not supported.");
#line 1006
      ReturnCode = (short)0;
#line 1007
      break;
    }
#line 1011
    tmp___1 = stricomp(ArgName, ArcFileName);
#line 1011
    FileFound = (short )(tmp___1 == 0);
#line 1011
    if (1 == (int )FileFound) {
#line 1015
      cli_dbgmsg("unrarlib: Allocating %d bytes\n", NewLhd.UnpSize);
#line 1016
      temp_output_buffer = (unsigned char *)malloc((unsigned int )NewLhd.UnpSize);
#line 1016
      if ((unsigned int )temp_output_buffer == (unsigned int )((void *)0)) {
#line 1017
        cli_errmsg("unrarlib: Can\'t malloc %d bytes\n", NewLhd.UnpSize);
#line 1018
        ReturnCode = (short)0;
#line 1019
        break;
      }
#line 1022
      (*temp_output_buffer_offset) = 0UL;
    }
#line 1031
    if ((int )NewMhd.Flags & 8) {
      goto _L;
    } else {
#line 1031
      if (FileFound) {
        _L: 
#line 1033
        if ((int )NewLhd.UnpVer < 13) {
#line 1035
          cli_dbgmsg("unknown compression method: %d  (min=13 max=%d)\n", NewLhd.UnpVer,
                     20);
#line 1036
          ReturnCode = (short)0;
#line 1037
          break;
        } else {
#line 1033
          if ((int )NewLhd.UnpVer > 20) {
#line 1035
            cli_dbgmsg("unknown compression method: %d  (min=13 max=%d)\n", NewLhd.UnpVer,
                       20);
#line 1036
            ReturnCode = (short)0;
#line 1037
            break;
          }
        }
#line 1040
        CurUnpRead = 0UL;
#line 1041
        if ((int )Password[0] != 0) {
#line 1041
          if ((int )NewLhd.Flags & 4) {
#line 1042
            Encryption = (int )NewLhd.UnpVer;
          } else {
#line 1044
            Encryption = 0;
          }
        } else {
#line 1044
          Encryption = 0;
        }
#line 1045
        if (Encryption) {
#line 1045
          SetCryptKeys(Password);
        }
#line 1047
        UnpPackedSize = (long )NewLhd.PackSize;
#line 1048
        DestUnpSize = (long )NewLhd.UnpSize;
#line 1050
        if ((int )NewLhd.Method == 48) {
#line 1052
          cli_dbgmsg("unrarlib: Unstore method temporarily not supported\n");
#line 1054
          ReturnCode = (short)0;
#line 1055
          break;
        } else {
#line 1058
          cli_dbgmsg("unrarlib: Unpack()\n");
#line 1059
          Unpack(UnpMemory, FileFound);
        }
#line 1064
        if ((unsigned int )temp_output_buffer != (unsigned int )((void *)0)) {
#line 1066
          tmp___2 = CalcCRC32(4294967295UL, temp_output_buffer, NewLhd.UnpSize);
#line 1066
          if (NewLhd.FileCRC != ~ tmp___2) {
#line 1070
            cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1070, "CRC32 error - file couldn\'t be decompressed correctly!");
#line 1071
            ReturnCode = (short)0;
#line 1072
            break;
          }
        }
      }
    }
#line 1082
    if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 1082
      tseek((void *)ArcPtr, NextBlockPos, 0);
    }
#line 984
    tmp___3 = stricomp(ArgName, ArcFileName);
#line 984
    if (! (tmp___3 != 0)) {
#line 984
      break;
    }
  }
#line 1087
  if (UnpMemory) {
#line 1088
    free((void *)UnpMemory);
  }
#line 1090
  UnpMemory = (UBYTE *)((void *)0);
#line 1092
  if ((unsigned int )ArcPtr != (unsigned int )((void *)0)) {
#line 1093
    fclose(ArcPtr);
#line 1094
    lseek(desc, 0L, 0);
#line 1095
    ArcPtr = (FILE *)((void *)0);
  }
#line 1099
  return (ReturnCode);
}
}
#line 1141 "unrarlib.c"
static int tread(void *stream , void *buf , unsigned int len ) 
{ int tmp ;

  {
#line 1155
  tmp = (int )fread((void * __restrict  )buf, 1U, len, (FILE * __restrict  )((FILE *)stream));
#line 1155
  return (tmp);
}
}
#line 1161 "unrarlib.c"
static int tseek(void *stream , long offset , int fromwhere ) 
{ int tmp ;

  {
#line 1163
  tmp = fseek((FILE *)stream, offset, fromwhere);
#line 1163
  return (tmp);
}
}
#line 1168 "unrarlib.c"
static char *strupper(char *Str ) 
{ char *ChPtr ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  __int32_t const   **tmp___2 ;

  {
#line 1171
  ChPtr = Str;
#line 1171
  while ((*ChPtr)) {
#line 1172
    if (sizeof((*ChPtr)) > 1U) {
#line 1172
      tmp___1 = __builtin_constant_p((int )(*ChPtr));
#line 1172
      if (tmp___1) {
#line 1172
        __c = (int )(*ChPtr);
#line 1172
        if (__c < -128) {
#line 1172
          __res = __c;
        } else {
#line 1172
          if (__c > 255) {
#line 1172
            __res = __c;
          } else {
#line 1172
            tmp___0 = __ctype_toupper_loc();
#line 1172
            __res = (*((*tmp___0) + __c));
          }
        }
      } else {
#line 1172
        __res = toupper__extinline((int )(*ChPtr));
      }
    } else {
#line 1172
      tmp___2 = __ctype_toupper_loc();
#line 1172
      __res = (*((*tmp___2) + (int )(*ChPtr)));
    }
#line 1172
    (*ChPtr) = (char )__res;
#line 1171
    ChPtr ++;
  }
#line 1173
  return (Str);
}
}
#line 1177 "unrarlib.c"
static int stricomp(char *Str1 , char *Str2 ) 
{ char S1[512] ;
  char S2[512] ;
  char *chptr ;
  int tmp___3 ;
  int tmp___8 ;
  int tmp___13 ;
  int tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___216 ;
  char *tmp___217 ;
  char *tmp___218 ;
  char *tmp___323 ;
  char *tmp___324 ;
  unsigned char const   *__s2___6 ;
  char const   *tmp___325 ;
  register int __result___18 ;
  char *tmp___326 ;
  char *tmp___327 ;
  char *tmp___328 ;
  char *tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  char *tmp___332 ;
  char *tmp___333 ;
  char *tmp___378 ;
  char *tmp___379 ;
  unsigned char const   *__s1___14 ;
  char const   *tmp___380 ;
  register int __result___22 ;
  char *tmp___381 ;
  char *tmp___382 ;
  char *tmp___383 ;
  char *tmp___384 ;
  int tmp___385 ;
  int tmp___386 ;
  char *tmp___387 ;
  char *tmp___388 ;
  char *tmp___389 ;
  char *tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  char *tmp___393 ;
  char *tmp___394 ;
  char const   *tmp___395 ;
  int tmp___396 ;
  int tmp___397 ;
  char *tmp___398 ;
  char *tmp___399 ;
  char const   *tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___404 ;
  char const   *tmp___405 ;
  char const   *tmp___406 ;
  char *tmp___407 ;
  char *tmp___408 ;
  char *tmp___409 ;
  char *tmp___410 ;
  int tmp___411 ;

  {
#line 1183
  __builtin_strncpy(S1, Str1, sizeof(S1));
#line 1184
  __builtin_strncpy(S2, Str2, sizeof(S2));
#line 1186
  while (1) {
#line 1186
    tmp___3 = __builtin_constant_p((int )(S1));
#line 1186
    if (tmp___3) {
#line 1186
      chptr = (char *)__builtin_strchr(S1, '\\');
    } else {
#line 1186
      chptr = (char *)__builtin_strchr(S1, '\\');
    }
#line 1186
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
#line 1186
      break;
    }
#line 1188
    (*chptr) = (char )'_';
  }
#line 1191
  while (1) {
#line 1191
    tmp___8 = __builtin_constant_p((int )(S2));
#line 1191
    if (tmp___8) {
#line 1191
      chptr = (char *)__builtin_strchr(S2, '\\');
    } else {
#line 1191
      chptr = (char *)__builtin_strchr(S2, '\\');
    }
#line 1191
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
#line 1191
      break;
    }
#line 1193
    (*chptr) = (char )'_';
  }
#line 1196
  while (1) {
#line 1196
    tmp___13 = __builtin_constant_p((int )(S1));
#line 1196
    if (tmp___13) {
#line 1196
      chptr = (char *)__builtin_strchr(S1, '/');
    } else {
#line 1196
      chptr = (char *)__builtin_strchr(S1, '/');
    }
#line 1196
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
#line 1196
      break;
    }
#line 1198
    (*chptr) = (char )'_';
  }
#line 1201
  while (1) {
#line 1201
    tmp___18 = __builtin_constant_p((int )(S2));
#line 1201
    if (tmp___18) {
#line 1201
      chptr = (char *)__builtin_strchr(S2, '/');
    } else {
#line 1201
      chptr = (char *)__builtin_strchr(S2, '/');
    }
#line 1201
    if (! ((unsigned int )chptr != (unsigned int )((void *)0))) {
#line 1201
      break;
    }
#line 1203
    (*chptr) = (char )'_';
  }
#line 1206
  tmp___401 = (int )strupper(S1);
#line 1206
  tmp___402 = __builtin_constant_p(tmp___401);
#line 1206
  if (tmp___402) {
#line 1206
    tmp___403 = (int )strupper(S2);
#line 1206
    tmp___404 = __builtin_constant_p(tmp___403);
#line 1206
    if (tmp___404) {
#line 1206
      tmp___405 = strupper(S1);
#line 1206
      __s1_len = strlen(tmp___405);
#line 1206
      tmp___406 = strupper(S2);
#line 1206
      __s2_len = strlen(tmp___406);
#line 1206
      tmp___407 = strupper(S1);
#line 1206
      tmp___408 = strupper(S1);
#line 1206
      if ((unsigned int )((void const   *)(tmp___407 + 1)) - (unsigned int )((void const   *)tmp___408) ==
          1U) {
#line 1206
        if (__s1_len >= 4U) {
          _L___16: 
#line 1206
          tmp___409 = strupper(S2);
#line 1206
          tmp___410 = strupper(S2);
#line 1206
          if ((unsigned int )((void const   *)(tmp___409 + 1)) - (unsigned int )((void const   *)tmp___410) ==
              1U) {
#line 1206
            if (__s2_len >= 4U) {
#line 1206
              tmp___411 = 1;
            } else {
#line 1206
              tmp___411 = 0;
            }
          } else {
#line 1206
            tmp___411 = 1;
          }
        } else {
#line 1206
          tmp___411 = 0;
        }
      } else {
        goto _L___16;
      }
#line 1206
      if (tmp___411) {
#line 1206
        tmp___217 = strupper(S2);
#line 1206
        tmp___218 = strupper(S1);
#line 1206
        tmp___216 = __builtin_strcmp(tmp___218, tmp___217);
      } else {
        goto _L___18;
      }
    } else {
      goto _L___18;
    }
  } else {
    _L___18: 
#line 1206
    tmp___396 = (int )strupper(S1);
#line 1206
    tmp___397 = __builtin_constant_p(tmp___396);
#line 1206
    if (tmp___397) {
#line 1206
      tmp___398 = strupper(S1);
#line 1206
      tmp___399 = strupper(S1);
#line 1206
      if ((unsigned int )((void const   *)(tmp___398 + 1)) - (unsigned int )((void const   *)tmp___399) ==
          1U) {
#line 1206
        tmp___400 = strupper(S1);
#line 1206
        __s1_len = strlen(tmp___400);
#line 1206
        if (__s1_len < 4U) {
#line 1206
          tmp___330 = (int )strupper(S2);
#line 1206
          tmp___331 = __builtin_constant_p(tmp___330);
#line 1206
          if (tmp___331) {
#line 1206
            tmp___332 = strupper(S2);
#line 1206
            tmp___333 = strupper(S2);
#line 1206
            if ((unsigned int )((void const   *)(tmp___332 + 1)) - (unsigned int )((void const   *)tmp___333) ==
                1U) {
#line 1206
              tmp___323 = strupper(S2);
#line 1206
              tmp___324 = strupper(S1);
#line 1206
              tmp___216 = __builtin_strcmp(tmp___324, tmp___323);
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
#line 1206
            tmp___325 = strupper(S2);
#line 1206
            __s2___6 = (unsigned char const   *)tmp___325;
#line 1206
            tmp___326 = strupper(S1);
#line 1206
            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___326) +
                                                    0)) - (int const   )(*(__s2___6 +
                                                                           0)));
#line 1206
            if (__s1_len > 0U) {
#line 1206
              if (__result___18 == 0) {
#line 1206
                tmp___327 = strupper(S1);
#line 1206
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___327) +
                                                        1)) - (int const   )(*(__s2___6 +
                                                                               1)));
#line 1206
                if (__s1_len > 1U) {
#line 1206
                  if (__result___18 == 0) {
#line 1206
                    tmp___328 = strupper(S1);
#line 1206
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___328) +
                                                            2)) - (int const   )(*(__s2___6 +
                                                                                   2)));
#line 1206
                    if (__s1_len > 2U) {
#line 1206
                      if (__result___18 == 0) {
#line 1206
                        tmp___329 = strupper(S1);
#line 1206
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)tmp___329) +
                                                                3)) - (int const   )(*(__s2___6 +
                                                                                       3)));
                      }
                    }
                  }
                }
              }
            }
#line 1206
            tmp___216 = __result___18;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: 
#line 1206
      tmp___391 = (int )strupper(S2);
#line 1206
      tmp___392 = __builtin_constant_p(tmp___391);
#line 1206
      if (tmp___392) {
#line 1206
        tmp___393 = strupper(S2);
#line 1206
        tmp___394 = strupper(S2);
#line 1206
        if ((unsigned int )((void const   *)(tmp___393 + 1)) - (unsigned int )((void const   *)tmp___394) ==
            1U) {
#line 1206
          tmp___395 = strupper(S2);
#line 1206
          __s2_len = strlen(tmp___395);
#line 1206
          if (__s2_len < 4U) {
#line 1206
            tmp___385 = (int )strupper(S1);
#line 1206
            tmp___386 = __builtin_constant_p(tmp___385);
#line 1206
            if (tmp___386) {
#line 1206
              tmp___387 = strupper(S1);
#line 1206
              tmp___388 = strupper(S1);
#line 1206
              if ((unsigned int )((void const   *)(tmp___387 + 1)) - (unsigned int )((void const   *)tmp___388) ==
                  1U) {
#line 1206
                tmp___378 = strupper(S2);
#line 1206
                tmp___379 = strupper(S1);
#line 1206
                tmp___216 = __builtin_strcmp(tmp___379, tmp___378);
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
#line 1206
              tmp___380 = strupper(S1);
#line 1206
              __s1___14 = (unsigned char const   *)tmp___380;
#line 1206
              tmp___381 = strupper(S2);
#line 1206
              __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)tmp___381) +
                                                                                         0)));
#line 1206
              if (__s2_len > 0U) {
#line 1206
                if (__result___22 == 0) {
#line 1206
                  tmp___382 = strupper(S2);
#line 1206
                  __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)tmp___382) +
                                                                                             1)));
#line 1206
                  if (__s2_len > 1U) {
#line 1206
                    if (__result___22 == 0) {
#line 1206
                      tmp___383 = strupper(S2);
#line 1206
                      __result___22 = (int )((int const   )(*(__s1___14 + 2)) - (int const   )(*((unsigned char const   *)((char const   *)tmp___383) +
                                                                                                 2)));
#line 1206
                      if (__s2_len > 2U) {
#line 1206
                        if (__result___22 == 0) {
#line 1206
                          tmp___384 = strupper(S2);
#line 1206
                          __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)tmp___384) +
                                                                  3)));
                        }
                      }
                    }
                  }
                }
              }
#line 1206
              tmp___216 = __result___22;
            }
          } else {
#line 1206
            tmp___389 = strupper(S2);
#line 1206
            tmp___390 = strupper(S1);
#line 1206
            tmp___216 = __builtin_strcmp(tmp___390, tmp___389);
          }
        } else {
#line 1206
          tmp___389 = strupper(S2);
#line 1206
          tmp___390 = strupper(S1);
#line 1206
          tmp___216 = __builtin_strcmp(tmp___390, tmp___389);
        }
      } else {
#line 1206
        tmp___389 = strupper(S2);
#line 1206
        tmp___390 = strupper(S1);
#line 1206
        tmp___216 = __builtin_strcmp(tmp___390, tmp___389);
      }
    }
  }
#line 1206
  return (tmp___216);
}
}
#line 1299 "unrarlib.c"
static struct AudioVariables AudV[4]  ;
#line 1312 "unrarlib.c"
static unsigned char *UnpBuf  ;
#line 1313 "unrarlib.c"
static unsigned int BitField  ;
#line 1314 "unrarlib.c"
static unsigned int Number  ;
#line 1316 "unrarlib.c"
static unsigned char InBuf[8192]  ;
#line 1318 "unrarlib.c"
static unsigned char UnpOldTable[1028]  ;
#line 1320 "unrarlib.c"
static unsigned int InAddr  ;
#line 1320 "unrarlib.c"
static unsigned int InBit  ;
#line 1320 "unrarlib.c"
static unsigned int ReadTop  ;
#line 1322 "unrarlib.c"
static unsigned int LastDist  ;
#line 1322 "unrarlib.c"
static unsigned int LastLength  ;
#line 1323 "unrarlib.c"
static unsigned int Length  ;
#line 1323 "unrarlib.c"
static unsigned int Distance  ;
#line 1325 "unrarlib.c"
static unsigned int OldDist[4]  ;
#line 1325 "unrarlib.c"
static unsigned int OldDistPtr  ;
#line 1328 "unrarlib.c"
static struct LitDecode LD  ;
#line 1336 "unrarlib.c"
static struct DistDecode DD  ;
#line 1344 "unrarlib.c"
static struct RepDecode RD  ;
#line 1352 "unrarlib.c"
static struct MultDecode MD[4]  ;
#line 1360 "unrarlib.c"
static struct BitDecode BD  ;
#line 1368 "unrarlib.c"
static struct MultDecode *MDPtr[4]  = {      MD,      & MD[1],      & MD[2],      & MD[3]};
#line 1370 "unrarlib.c"
static int UnpAudioBlock  ;
#line 1370 "unrarlib.c"
static int UnpChannels  ;
#line 1370 "unrarlib.c"
static int CurChannel  ;
#line 1370 "unrarlib.c"
static int ChannelDelta  ;
#line 1376 "unrarlib.c"
static unsigned char LDecode[28]  = 
#line 1376
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)10,      (unsigned char)12,      (unsigned char)14, 
        (unsigned char)16,      (unsigned char)20,      (unsigned char)24,      (unsigned char)28, 
        (unsigned char)32,      (unsigned char)40,      (unsigned char)48,      (unsigned char)56, 
        (unsigned char)64,      (unsigned char)80,      (unsigned char)96,      (unsigned char)112, 
        (unsigned char)128,      (unsigned char)160,      (unsigned char)192,      (unsigned char)224};
#line 1378 "unrarlib.c"
static unsigned char LBits[28]  = 
#line 1378
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)2,      (unsigned char)2,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)5,      (unsigned char)5};
#line 1380 "unrarlib.c"
static int DDecode[48]  = 
#line 1380
  {      0,      1,      2,      3, 
        4,      6,      8,      12, 
        16,      24,      32,      48, 
        64,      96,      128,      192, 
        256,      384,      512,      768, 
        1024,      1536,      2048,      3072, 
        4096,      6144,      8192,      12288, 
        16384,      24576,      32768,      49152, 
        65536,      98304,      131072,      196608, 
        262144,      327680,      393216,      458752, 
        524288,      589824,      655360,      720896, 
        786432,      851968,      917504,      983040};
#line 1385 "unrarlib.c"
static unsigned char DBits[48]  = 
#line 1385
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)6,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)7,      (unsigned char)8,      (unsigned char)8, 
        (unsigned char)9,      (unsigned char)9,      (unsigned char)10,      (unsigned char)10, 
        (unsigned char)11,      (unsigned char)11,      (unsigned char)12,      (unsigned char)12, 
        (unsigned char)13,      (unsigned char)13,      (unsigned char)14,      (unsigned char)14, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)16, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)16};
#line 1388 "unrarlib.c"
static unsigned char SDDecode[8]  = 
#line 1388
  {      (unsigned char)0,      (unsigned char)4,      (unsigned char)8,      (unsigned char)16, 
        (unsigned char)32,      (unsigned char)64,      (unsigned char)128,      (unsigned char)192};
#line 1389 "unrarlib.c"
static unsigned char SDBits[8]  = 
#line 1389
  {      (unsigned char)2,      (unsigned char)2,      (unsigned char)3,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)6,      (unsigned char)6,      (unsigned char)6};
#line 1373 "unrarlib.c"
static void Unpack(unsigned char *UnpAddr , BOOL FileFound ) 
{ unsigned int Bits ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 1393
  UnpBuf = UnpAddr;
#line 1394
  UnpInitData();
#line 1395
  UnpReadBuf(1);
#line 1396
  if (! ((int )NewLhd.Flags & 16)) {
#line 1397
    ReadTables();
  }
#line 1398
  DestUnpSize --;
#line 1400
  while (DestUnpSize >= 0L) {
#line 1402
    UnpPtr &= 1048575U;
#line 1404
    if (InAddr > sizeof(InBuf) - 30U) {
#line 1405
      UnpReadBuf(0);
    }
#line 1406
    if (((WrPtr - UnpPtr) & 1048575U) < 270U) {
#line 1406
      if (WrPtr != UnpPtr) {
#line 1410
        if (FileFound) {
#line 1413
          if (UnpPtr < WrPtr) {
#line 1415
            if (((*temp_output_buffer_offset) + (unsigned long )((0U - WrPtr) & 1048575U)) +
                (unsigned long )UnpPtr > NewLhd.UnpSize) {
#line 1417
              cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1417, "Fatal! Buffer overrun during decompression!");
#line 1418
              DestUnpSize = -1L;
            } else {
#line 1423
              memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
                     (void const   * __restrict  )(UnpBuf + WrPtr), (0U - WrPtr) &
                                                                    1048575U);
#line 1426
              (*temp_output_buffer_offset) += (unsigned long )((0U - WrPtr) & 1048575U);
#line 1428
              memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
                     (void const   * __restrict  )UnpBuf, UnpPtr);
#line 1431
              (*temp_output_buffer_offset) += (unsigned long )UnpPtr;
            }
          } else {
#line 1435
            if ((*temp_output_buffer_offset) + (unsigned long )(UnpPtr - WrPtr) >
                NewLhd.UnpSize) {
#line 1437
              cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1437, "Fatal! Buffer overrun during decompression!");
#line 1438
              DestUnpSize = -1L;
            } else {
#line 1442
              memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
                     (void const   * __restrict  )(UnpBuf + WrPtr), UnpPtr - WrPtr);
#line 1444
              (*temp_output_buffer_offset) += (unsigned long )(UnpPtr - WrPtr);
            }
          }
        }
#line 1450
        WrPtr = UnpPtr;
      }
    }
#line 1453
    if (UnpAudioBlock) {
#line 1455
      DecodeNumber((struct Decode *)MDPtr[CurChannel]);
#line 1456
      if (Number == 256U) {
#line 1458
        ReadTables();
#line 1459
        continue;
      }
#line 1461
      tmp = UnpPtr;
#line 1461
      UnpPtr ++;
#line 1461
      (*(UnpBuf + tmp)) = DecodeAudio((int )Number);
#line 1462
      CurChannel ++;
#line 1462
      if (CurChannel == UnpChannels) {
#line 1463
        CurChannel = 0;
      }
#line 1464
      DestUnpSize --;
#line 1465
      continue;
    }
#line 1468
    DecodeNumber((struct Decode *)(& LD));
#line 1469
    if (Number < 256U) {
#line 1471
      tmp___0 = UnpPtr;
#line 1471
      UnpPtr ++;
#line 1471
      (*(UnpBuf + tmp___0)) = (unsigned char )Number;
#line 1472
      DestUnpSize --;
#line 1473
      continue;
    }
#line 1475
    if (Number > 269U) {
#line 1477
      Number -= 270U;
#line 1477
      Length = (unsigned int )((int )LDecode[Number] + 3);
#line 1478
      Bits = (unsigned int )LBits[Number];
#line 1478
      if (Bits > 0U) {
#line 1480
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
#line 1481
        Length += BitField >> (16U - Bits);
#line 1482
        InAddr += (InBit + Bits) >> 3;
#line 1482
        InBit = (InBit + Bits) & 7U;
      }
#line 1485
      DecodeNumber((struct Decode *)(& DD));
#line 1486
      Distance = (unsigned int )(DDecode[Number] + 1);
#line 1487
      Bits = (unsigned int )DBits[Number];
#line 1487
      if (Bits > 0U) {
#line 1489
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
#line 1490
        Distance += BitField >> (16U - Bits);
#line 1491
        InAddr += (InBit + Bits) >> 3;
#line 1491
        InBit = (InBit + Bits) & 7U;
      }
#line 1494
      if ((unsigned long )Distance >= 262144UL) {
#line 1495
        Length ++;
      }
#line 1497
      if (Distance >= 8192U) {
#line 1498
        Length ++;
      }
#line 1500
      tmp___1 = OldDistPtr;
#line 1500
      OldDistPtr ++;
#line 1500
      OldDist[tmp___1 & 3U] = Distance;
#line 1500
      LastDist = OldDist[tmp___1 & 3U];
#line 1501
      LastLength = Length;
#line 1501
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
#line 1502
      while (1) {
#line 1502
        tmp___2 = Length;
#line 1502
        Length --;
#line 1502
        if (! tmp___2) {
#line 1502
          break;
        }
#line 1504
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
#line 1505
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
#line 1508
      continue;
    }
#line 1510
    if (Number == 269U) {
#line 1512
      ReadTables();
#line 1513
      continue;
    }
#line 1515
    if (Number == 256U) {
#line 1517
      Length = LastLength;
#line 1518
      Distance = LastDist;
#line 1519
      tmp___3 = OldDistPtr;
#line 1519
      OldDistPtr ++;
#line 1519
      OldDist[tmp___3 & 3U] = Distance;
#line 1519
      LastDist = OldDist[tmp___3 & 3U];
#line 1520
      LastLength = Length;
#line 1520
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
#line 1521
      while (1) {
#line 1521
        tmp___4 = Length;
#line 1521
        Length --;
#line 1521
        if (! tmp___4) {
#line 1521
          break;
        }
#line 1523
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
#line 1524
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
#line 1526
      continue;
    }
#line 1528
    if (Number < 261U) {
#line 1530
      Distance = OldDist[(OldDistPtr - (Number - 256U)) & 3U];
#line 1531
      DecodeNumber((struct Decode *)(& RD));
#line 1532
      Length = (unsigned int )((int )LDecode[Number] + 2);
#line 1533
      Bits = (unsigned int )LBits[Number];
#line 1533
      if (Bits > 0U) {
#line 1535
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
#line 1536
        Length += BitField >> (16U - Bits);
#line 1537
        InAddr += (InBit + Bits) >> 3;
#line 1537
        InBit = (InBit + Bits) & 7U;
      }
#line 1539
      if (Distance >= 262144U) {
#line 1540
        Length ++;
      }
#line 1541
      if (Distance >= 8192U) {
#line 1542
        Length ++;
      }
#line 1543
      if (Distance >= 257U) {
#line 1544
        Length ++;
      }
#line 1545
      tmp___5 = OldDistPtr;
#line 1545
      OldDistPtr ++;
#line 1545
      OldDist[tmp___5 & 3U] = Distance;
#line 1545
      LastDist = OldDist[tmp___5 & 3U];
#line 1546
      LastLength = Length;
#line 1546
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
#line 1547
      while (1) {
#line 1547
        tmp___6 = Length;
#line 1547
        Length --;
#line 1547
        if (! tmp___6) {
#line 1547
          break;
        }
#line 1549
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
#line 1550
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
#line 1552
      continue;
    }
#line 1554
    if (Number < 270U) {
#line 1556
      Number -= 261U;
#line 1556
      Distance = (unsigned int )((int )SDDecode[Number] + 1);
#line 1557
      Bits = (unsigned int )SDBits[Number];
#line 1557
      if (Bits > 0U) {
#line 1559
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
#line 1560
        Distance += BitField >> (16U - Bits);
#line 1561
        InAddr += (InBit + Bits) >> 3;
#line 1561
        InBit = (InBit + Bits) & 7U;
      }
#line 1563
      Length = 2U;
#line 1564
      tmp___7 = OldDistPtr;
#line 1564
      OldDistPtr ++;
#line 1564
      OldDist[tmp___7 & 3U] = Distance;
#line 1564
      LastDist = OldDist[tmp___7 & 3U];
#line 1565
      LastLength = Length;
#line 1565
      DestUnpSize = (long )((unsigned long )DestUnpSize - (unsigned long )LastLength);
#line 1566
      while (1) {
#line 1566
        tmp___8 = Length;
#line 1566
        Length --;
#line 1566
        if (! tmp___8) {
#line 1566
          break;
        }
#line 1568
        (*(UnpBuf + UnpPtr)) = (*(UnpBuf + ((UnpPtr - Distance) & 1048575U)));
#line 1569
        UnpPtr = (UnpPtr + 1U) & 1048575U;
      }
#line 1571
      continue;
    }
  }
#line 1574
  ReadLastTables();
#line 1576
  if (FileFound) {
#line 1579
    if (UnpPtr < WrPtr) {
#line 1581
      if (((*temp_output_buffer_offset) + (unsigned long )((0U - WrPtr) & 1048575U)) +
          (unsigned long )UnpPtr > NewLhd.UnpSize) {
#line 1583
        cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1583, "Fatal! Buffer overrun during decompression!");
#line 1584
        DestUnpSize = -1L;
      } else {
#line 1588
        memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
               (void const   * __restrict  )(UnpBuf + WrPtr), (0U - WrPtr) & 1048575U);
#line 1591
        (*temp_output_buffer_offset) += (unsigned long )((0U - WrPtr) & 1048575U);
#line 1593
        memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
               (void const   * __restrict  )UnpBuf, UnpPtr);
#line 1595
        (*temp_output_buffer_offset) += (unsigned long )UnpPtr;
      }
    } else {
#line 1599
      if ((*temp_output_buffer_offset) + (unsigned long )(UnpPtr - WrPtr) > NewLhd.UnpSize) {
#line 1601
        cli_dbgmsg("%s:%d %s\n", "unrarlib.c", 1601, "Fatal! Buffer overrun during decompression!");
#line 1602
        DestUnpSize = -1L;
      } else {
#line 1606
        memcpy((void * __restrict  )(temp_output_buffer + (*temp_output_buffer_offset)),
               (void const   * __restrict  )(UnpBuf + WrPtr), UnpPtr - WrPtr);
#line 1609
        (*temp_output_buffer_offset) += (unsigned long )(UnpPtr - WrPtr);
      }
    }
  }
#line 1614
  WrPtr = UnpPtr;
#line 1615
  return;
}
}
#line 1618 "unrarlib.c"
static unsigned int UnpRead(unsigned char *Addr , unsigned int Count ) 
{ int RetCode ;
  unsigned int I ;
  unsigned int ReadSize ;
  unsigned int TotalRead ;
  unsigned char *ReadAddr ;
  unsigned long tmp ;

  {
#line 1620
  RetCode = 0;
#line 1621
  TotalRead = 0U;
#line 1623
  ReadAddr = Addr;
#line 1624
  while (Count > 0U) {
#line 1626
    if ((unsigned long )Count > (unsigned long )UnpPackedSize) {
#line 1626
      tmp = (unsigned long )UnpPackedSize;
    } else {
#line 1626
      tmp = (unsigned long )Count;
    }
#line 1626
    ReadSize = (unsigned int )tmp;
#line 1634
    if ((unsigned int )ArcPtr == (unsigned int )((void *)0)) {
#line 1635
      return (0U);
    }
#line 1636
    RetCode = tread((void *)ArcPtr, (void *)ReadAddr, ReadSize);
#line 1638
    CurUnpRead += (unsigned long )RetCode;
#line 1639
    ReadAddr += RetCode;
#line 1640
    TotalRead += (unsigned int )RetCode;
#line 1641
    Count -= (unsigned int )RetCode;
#line 1642
    UnpPackedSize -= (long )RetCode;
#line 1643
    break;
  }
#line 1646
  cli_dbgmsg("CurUnpRead == %d, TotalRead == %d, Count == %d, UnpPackedSize == %d\n",
             CurUnpRead, TotalRead, Count, UnpPackedSize);
#line 1648
  if (RetCode != -1) {
#line 1650
    RetCode = (int )TotalRead;
#line 1651
    if (Encryption) {
#line 1653
      if (Encryption < 20) {
#line 1655
        cli_dbgmsg("unrarlib: Old Crypt() not supported!");
      } else {
#line 1659
        I = 0U;
#line 1659
        while (I < (unsigned int )RetCode) {
#line 1660
          DecryptBlock(Addr + I);
#line 1659
          I += 16U;
        }
      }
    }
  }
#line 1664
  return ((unsigned int )RetCode);
}
}
#line 1668 "unrarlib.c"
static void UnpReadBuf(int FirstBuf ) 
{ int RetCode ;

  {
#line 1671
  if (FirstBuf) {
#line 1673
    ReadTop = UnpRead(InBuf, sizeof(InBuf));
#line 1674
    InAddr = 0U;
  } else {
#line 1678
    memcpy((void * __restrict  )(InBuf), (void const   * __restrict  )(& InBuf[sizeof(InBuf) -
                                                                               32U]),
           32U);
#line 1679
    InAddr &= 31U;
#line 1680
    RetCode = (int )UnpRead(& InBuf[32], sizeof(InBuf) - 32U);
#line 1681
    if (RetCode > 0) {
#line 1682
      ReadTop = (unsigned int )(RetCode + 32);
    } else {
#line 1684
      ReadTop = InAddr;
    }
  }
#line 1686
  return;
}
}
#line 1689 "unrarlib.c"
static void ReadTables(void) 
{ UBYTE BitLength[19] ;
  unsigned char Table[1028] ;
  int TableSize ;
  int N ;
  int I ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1694
  if (InAddr > sizeof(InBuf) - 25U) {
#line 1695
    UnpReadBuf(0);
  }
#line 1696
  BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                       1U]) <<
                                                                                         8)) |
                               (unsigned long )InBuf[InAddr + 2U]) >> (8U - InBit)) &
                             65535UL);
#line 1697
  UnpAudioBlock = (int )(BitField & 32768U);
#line 1699
  if (! (BitField & 16384U)) {
#line 1700
    memset((void *)(UnpOldTable), 0, sizeof(UnpOldTable));
  }
#line 1701
  InAddr += (InBit + 2U) >> 3;
#line 1701
  InBit = (InBit + 2U) & 7U;
#line 1704
  if (UnpAudioBlock) {
#line 1706
    UnpChannels = (int )(((BitField >> 12) & 3U) + 1U);
#line 1707
    if (CurChannel >= UnpChannels) {
#line 1708
      CurChannel = 0;
    }
#line 1709
    InAddr += (InBit + 2U) >> 3;
#line 1709
    InBit = (InBit + 2U) & 7U;
#line 1710
    TableSize = 257 * UnpChannels;
  } else {
#line 1713
    TableSize = 374;
  }
#line 1716
  I = 0;
#line 1716
  while (I < 19) {
#line 1718
    BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                         1U]) <<
                                                                                           8)) |
                                 (unsigned long )InBuf[InAddr + 2U]) >> (8U - InBit)) &
                               65535UL);
#line 1719
    BitLength[I] = (unsigned char )(BitField >> 12);
#line 1720
    InAddr += (InBit + 4U) >> 3;
#line 1720
    InBit = (InBit + 4U) & 7U;
#line 1716
    I ++;
  }
#line 1722
  MakeDecodeTables(BitLength, (struct Decode *)(& BD), 19);
#line 1723
  I = 0;
#line 1724
  while (I < TableSize) {
#line 1726
    if (InAddr > sizeof(InBuf) - 5U) {
#line 1727
      UnpReadBuf(0);
    }
#line 1728
    DecodeNumber((struct Decode *)(& BD));
#line 1729
    if (Number < 16U) {
#line 1730
      Table[I] = (unsigned char )((Number + (unsigned int )UnpOldTable[I]) & 15U);
#line 1731
      I ++;
    } else {
#line 1734
      if (Number == 16U) {
#line 1736
        BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                             1U]) <<
                                                                                               8)) |
                                     (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                             InBit)) &
                                   65535UL);
#line 1737
        N = (int )((BitField >> 14) + 3U);
#line 1738
        InAddr += (InBit + 2U) >> 3;
#line 1738
        InBit = (InBit + 2U) & 7U;
#line 1739
        while (1) {
#line 1739
          tmp = N;
#line 1739
          N --;
#line 1739
          if (tmp > 0) {
#line 1739
            if (! (I < TableSize)) {
#line 1739
              break;
            }
          } else {
#line 1739
            break;
          }
#line 1741
          Table[I] = Table[I - 1];
#line 1742
          I ++;
        }
      } else {
#line 1747
        if (Number == 17U) {
#line 1749
          BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                               1U]) <<
                                                                                                 8)) |
                                       (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                               InBit)) &
                                     65535UL);
#line 1750
          N = (int )((BitField >> 13) + 3U);
#line 1751
          InAddr += (InBit + 3U) >> 3;
#line 1751
          InBit = (InBit + 3U) & 7U;
        } else {
#line 1755
          BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                               1U]) <<
                                                                                                 8)) |
                                       (unsigned long )InBuf[InAddr + 2U]) >> (8U -
                                                                               InBit)) &
                                     65535UL);
#line 1756
          N = (int )((BitField >> 9) + 11U);
#line 1757
          InAddr += (InBit + 7U) >> 3;
#line 1757
          InBit = (InBit + 7U) & 7U;
        }
#line 1759
        while (1) {
#line 1759
          tmp___1 = N;
#line 1759
          N --;
#line 1759
          if (tmp___1 > 0) {
#line 1759
            if (! (I < TableSize)) {
#line 1759
              break;
            }
          } else {
#line 1759
            break;
          }
#line 1760
          tmp___0 = I;
#line 1760
          I ++;
#line 1760
          Table[tmp___0] = (unsigned char)0;
        }
      }
    }
  }
#line 1763
  if (UnpAudioBlock) {
#line 1764
    I = 0;
#line 1764
    while (I < UnpChannels) {
#line 1765
      MakeDecodeTables(& Table[I * 257], (struct Decode *)MDPtr[I], 257);
#line 1764
      I ++;
    }
  } else {
#line 1768
    MakeDecodeTables(Table, (struct Decode *)(& LD), 298);
#line 1769
    MakeDecodeTables(& Table[298], (struct Decode *)(& DD), 48);
#line 1770
    MakeDecodeTables(& Table[346], (struct Decode *)(& RD), 28);
  }
#line 1772
  memcpy((void * __restrict  )(UnpOldTable), (void const   * __restrict  )(Table),
         sizeof(UnpOldTable));
#line 1773
  return;
}
}
#line 1776 "unrarlib.c"
static void ReadLastTables(void) 
{ 

  {
#line 1778
  if (ReadTop >= InAddr + 5U) {
#line 1780
    if (UnpAudioBlock) {
#line 1782
      DecodeNumber((struct Decode *)MDPtr[CurChannel]);
#line 1783
      if (Number == 256U) {
#line 1784
        ReadTables();
      }
    } else {
#line 1788
      DecodeNumber((struct Decode *)(& LD));
#line 1789
      if (Number == 269U) {
#line 1790
        ReadTables();
      }
    }
  }
#line 1793
  return;
}
}
#line 1796 "unrarlib.c"
static void MakeDecodeTables(unsigned char *LenTab , struct Decode *Dec , int Size ) 
{ int LenCount[16] ;
  int TmpPos[16] ;
  int I ;
  long M ;
  long N ;
  int tmp ;

  {
#line 1802
  memset((void *)(LenCount), 0, sizeof(LenCount));
#line 1803
  I = 0;
#line 1803
  while (I < Size) {
#line 1804
    LenCount[(int )(*(LenTab + I)) & 15] = LenCount[(int )(*(LenTab + I)) & 15] +
                                           1;
#line 1803
    I ++;
  }
#line 1806
  LenCount[0] = 0;
#line 1807
  Dec->DecodeLen[0] = 0U;
#line 1807
  Dec->DecodePos[0] = Dec->DecodeLen[0];
#line 1807
  TmpPos[0] = (int )Dec->DecodePos[0];
#line 1807
  N = 0L;
#line 1807
  I = 1;
#line 1807
  while (I < 16) {
#line 1809
    N = 2L * (N + (long )LenCount[I]);
#line 1810
    M = N << (15 - I);
#line 1811
    if (M > 65535L) {
#line 1812
      M = 65535L;
    }
#line 1813
    Dec->DecodeLen[I] = (unsigned int )M;
#line 1814
    Dec->DecodePos[I] = Dec->DecodePos[I - 1] + (unsigned int )LenCount[I - 1];
#line 1814
    TmpPos[I] = (int )Dec->DecodePos[I];
#line 1807
    I ++;
  }
#line 1817
  I = 0;
#line 1817
  while (I < Size) {
#line 1818
    if ((int )(*(LenTab + I)) != 0) {
#line 1819
      tmp = TmpPos[(int )(*(LenTab + I)) & 15];
#line 1819
      TmpPos[(int )(*(LenTab + I)) & 15] = TmpPos[(int )(*(LenTab + I)) & 15] + 1;
#line 1819
      Dec->DecodeNum[tmp] = (unsigned int )I;
    }
#line 1817
    I ++;
  }
#line 1820
  Dec->MaxNum = (unsigned int )Size;
#line 1821
  return;
}
}
#line 1824 "unrarlib.c"
static void DecodeNumber(struct Decode *Deco ) 
{ unsigned int I ;
  register unsigned int N ;

  {
#line 1829
  BitField = (unsigned int )((((((unsigned long )InBuf[InAddr] << 16) | (unsigned long )((int )((unsigned short )InBuf[InAddr +
                                                                                                                       1U]) <<
                                                                                         8)) |
                               (unsigned long )InBuf[InAddr + 2U]) >> (8U - InBit)) &
                             65535UL);
#line 2080
  N = BitField & 65534U;
#line 2081
  if (N < Deco->DecodeLen[8]) {
#line 2082
    if (N < Deco->DecodeLen[4]) {
#line 2083
      if (N < Deco->DecodeLen[2]) {
#line 2084
        if (N < Deco->DecodeLen[1]) {
#line 2085
          I = 1U;
        } else {
#line 2087
          I = 2U;
        }
      } else {
#line 2089
        if (N < Deco->DecodeLen[3]) {
#line 2090
          I = 3U;
        } else {
#line 2092
          I = 4U;
        }
      }
    } else {
#line 2095
      if (N < Deco->DecodeLen[6]) {
#line 2096
        if (N < Deco->DecodeLen[5]) {
#line 2097
          I = 5U;
        } else {
#line 2099
          I = 6U;
        }
      } else {
#line 2101
        if (N < Deco->DecodeLen[7]) {
#line 2102
          I = 7U;
        } else {
#line 2104
          I = 8U;
        }
      }
    }
  } else {
#line 2108
    if (N < Deco->DecodeLen[12]) {
#line 2109
      if (N < Deco->DecodeLen[10]) {
#line 2110
        if (N < Deco->DecodeLen[9]) {
#line 2111
          I = 9U;
        } else {
#line 2113
          I = 10U;
        }
      } else {
#line 2115
        if (N < Deco->DecodeLen[11]) {
#line 2116
          I = 11U;
        } else {
#line 2118
          I = 12U;
        }
      }
    } else {
#line 2121
      if (N < Deco->DecodeLen[14]) {
#line 2122
        if (N < Deco->DecodeLen[13]) {
#line 2123
          I = 13U;
        } else {
#line 2125
          I = 14U;
        }
      } else {
#line 2128
        I = 15U;
      }
    }
  }
#line 2135
  InAddr += (InBit + I) >> 3;
#line 2135
  InBit = (InBit + I) & 7U;
#line 2136
  N = Deco->DecodePos[I] + ((N - Deco->DecodeLen[I - 1U]) >> (16U - I));
#line 2136
  if (N >= Deco->MaxNum) {
#line 2137
    N = 0U;
  }
#line 2138
  Number = Deco->DecodeNum[N];
#line 2139
  return;
}
}
#line 2142 "unrarlib.c"
static void UnpInitData(void) 
{ 

  {
#line 2144
  InBit = 0U;
#line 2144
  InAddr = InBit;
#line 2145
  if (! ((int )NewLhd.Flags & 16)) {
#line 2147
    CurChannel = 0;
#line 2147
    ChannelDelta = CurChannel;
#line 2234
    memset((void *)(AudV), 0, sizeof(AudV));
#line 2235
    memset((void *)(OldDist), 0, sizeof(OldDist));
#line 2236
    OldDistPtr = 0U;
#line 2237
    LastLength = 0U;
#line 2237
    LastDist = LastLength;
#line 2238
    memset((void *)UnpBuf, 0, 1048576U);
#line 2239
    memset((void *)(UnpOldTable), 0, sizeof(UnpOldTable));
#line 2240
    WrPtr = 0U;
#line 2240
    UnpPtr = WrPtr;
  }
#line 2244
  return;
}
}
#line 2247 "unrarlib.c"
static UBYTE DecodeAudio(int Delta ) 
{ struct AudioVariables *V ;
  unsigned int Ch ;
  unsigned int NumMinDif ;
  unsigned int MinDif ;
  int PCh ;
  int I ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2254
  V = & AudV[CurChannel];
#line 2255
  V->ByteCount ++;
#line 2256
  V->D4 = V->D3;
#line 2257
  V->D3 = V->D2;
#line 2258
  V->D2 = V->LastDelta - V->D1;
#line 2259
  V->D1 = V->LastDelta;
#line 2260
  PCh = ((((8 * V->LastChar + V->K1 * V->D1) + V->K2 * V->D2) + V->K3 * V->D3) + V->K4 *
                                                                                 V->D4) +
        V->K5 * ChannelDelta;
#line 2262
  PCh = (PCh >> 3) & 255;
#line 2264
  Ch = (unsigned int )(PCh - Delta);
#line 2266
  I = (int )((signed char )Delta) << 3;
#line 2268
  tmp = abs(I);
#line 2268
  V->Dif[0] += (unsigned int )tmp;
#line 2269
  tmp___0 = abs(I - V->D1);
#line 2269
  V->Dif[1] += (unsigned int )tmp___0;
#line 2270
  tmp___1 = abs(I + V->D1);
#line 2270
  V->Dif[2] += (unsigned int )tmp___1;
#line 2271
  tmp___2 = abs(I - V->D2);
#line 2271
  V->Dif[3] += (unsigned int )tmp___2;
#line 2272
  tmp___3 = abs(I + V->D2);
#line 2272
  V->Dif[4] += (unsigned int )tmp___3;
#line 2273
  tmp___4 = abs(I - V->D3);
#line 2273
  V->Dif[5] += (unsigned int )tmp___4;
#line 2274
  tmp___5 = abs(I + V->D3);
#line 2274
  V->Dif[6] += (unsigned int )tmp___5;
#line 2275
  tmp___6 = abs(I - V->D4);
#line 2275
  V->Dif[7] += (unsigned int )tmp___6;
#line 2276
  tmp___7 = abs(I + V->D4);
#line 2276
  V->Dif[8] += (unsigned int )tmp___7;
#line 2277
  tmp___8 = abs(I - ChannelDelta);
#line 2277
  V->Dif[9] += (unsigned int )tmp___8;
#line 2278
  tmp___9 = abs(I + ChannelDelta);
#line 2278
  V->Dif[10] += (unsigned int )tmp___9;
#line 2280
  V->LastDelta = (int )((signed char )(Ch - (unsigned int )V->LastChar));
#line 2280
  ChannelDelta = V->LastDelta;
#line 2281
  V->LastChar = (int )Ch;
#line 2283
  if ((V->ByteCount & 31U) == 0U) {
#line 2285
    MinDif = V->Dif[0];
#line 2286
    NumMinDif = 0U;
#line 2287
    V->Dif[0] = 0U;
#line 2288
    I = 1;
#line 2288
    while ((unsigned int )I < sizeof(V->Dif) / sizeof(V->Dif[0])) {
#line 2290
      if (V->Dif[I] < MinDif) {
#line 2292
        MinDif = V->Dif[I];
#line 2293
        NumMinDif = (unsigned int )I;
      }
#line 2295
      V->Dif[I] = 0U;
#line 2288
      I ++;
    }
#line 2297
    switch ((int )NumMinDif) {
    case 1: ;
#line 2300
    if (V->K1 >= -16) {
#line 2301
      V->K1 --;
    }
#line 2302
    break;
    case 2: ;
#line 2304
    if (V->K1 < 16) {
#line 2305
      V->K1 ++;
    }
#line 2306
    break;
    case 3: ;
#line 2308
    if (V->K2 >= -16) {
#line 2309
      V->K2 --;
    }
#line 2310
    break;
    case 4: ;
#line 2312
    if (V->K2 < 16) {
#line 2313
      V->K2 ++;
    }
#line 2314
    break;
    case 5: ;
#line 2316
    if (V->K3 >= -16) {
#line 2317
      V->K3 --;
    }
#line 2318
    break;
    case 6: ;
#line 2320
    if (V->K3 < 16) {
#line 2321
      V->K3 ++;
    }
#line 2322
    break;
    case 7: ;
#line 2324
    if (V->K4 >= -16) {
#line 2325
      V->K4 --;
    }
#line 2326
    break;
    case 8: ;
#line 2328
    if (V->K4 < 16) {
#line 2329
      V->K4 ++;
    }
#line 2330
    break;
    case 9: ;
#line 2332
    if (V->K5 >= -16) {
#line 2333
      V->K5 --;
    }
#line 2334
    break;
    case 10: ;
#line 2336
    if (V->K5 < 16) {
#line 2337
      V->K5 ++;
    }
#line 2338
    break;
    }
  }
#line 2341
  return ((unsigned char )Ch);
}
}
#line 2366 "unrarlib.c"
static UDWORD CRCTab[256]  ;
#line 2368 "unrarlib.c"
static UBYTE SubstTable[256]  ;
#line 2369 "unrarlib.c"
static UBYTE const   InitSubstTable[256]  = 
#line 2369
  {      (UBYTE const   )(unsigned char)215,      (UBYTE const   )(unsigned char)19,      (UBYTE const   )(unsigned char)149,      (UBYTE const   )(unsigned char)35, 
        (UBYTE const   )(unsigned char)73,      (UBYTE const   )(unsigned char)197,      (UBYTE const   )(unsigned char)192,      (UBYTE const   )(unsigned char)205, 
        (UBYTE const   )(unsigned char)249,      (UBYTE const   )(unsigned char)28,      (UBYTE const   )(unsigned char)16,      (UBYTE const   )(unsigned char)119, 
        (UBYTE const   )(unsigned char)48,      (UBYTE const   )(unsigned char)221,      (UBYTE const   )(unsigned char)2,      (UBYTE const   )(unsigned char)42, 
        (UBYTE const   )(unsigned char)232,      (UBYTE const   )(unsigned char)1,      (UBYTE const   )(unsigned char)177,      (UBYTE const   )(unsigned char)233, 
        (UBYTE const   )(unsigned char)14,      (UBYTE const   )(unsigned char)88,      (UBYTE const   )(unsigned char)219,      (UBYTE const   )(unsigned char)25, 
        (UBYTE const   )(unsigned char)223,      (UBYTE const   )(unsigned char)195,      (UBYTE const   )(unsigned char)244,      (UBYTE const   )(unsigned char)90, 
        (UBYTE const   )(unsigned char)87,      (UBYTE const   )(unsigned char)239,      (UBYTE const   )(unsigned char)153,      (UBYTE const   )(unsigned char)137, 
        (UBYTE const   )(unsigned char)255,      (UBYTE const   )(unsigned char)199,      (UBYTE const   )(unsigned char)147,      (UBYTE const   )(unsigned char)70, 
        (UBYTE const   )(unsigned char)92,      (UBYTE const   )(unsigned char)66,      (UBYTE const   )(unsigned char)246,      (UBYTE const   )(unsigned char)13, 
        (UBYTE const   )(unsigned char)216,      (UBYTE const   )(unsigned char)40,      (UBYTE const   )(unsigned char)62,      (UBYTE const   )(unsigned char)29, 
        (UBYTE const   )(unsigned char)217,      (UBYTE const   )(unsigned char)230,      (UBYTE const   )(unsigned char)86,      (UBYTE const   )(unsigned char)6, 
        (UBYTE const   )(unsigned char)71,      (UBYTE const   )(unsigned char)24,      (UBYTE const   )(unsigned char)171,      (UBYTE const   )(unsigned char)196, 
        (UBYTE const   )(unsigned char)101,      (UBYTE const   )(unsigned char)113,      (UBYTE const   )(unsigned char)218,      (UBYTE const   )(unsigned char)123, 
        (UBYTE const   )(unsigned char)93,      (UBYTE const   )(unsigned char)91,      (UBYTE const   )(unsigned char)163,      (UBYTE const   )(unsigned char)178, 
        (UBYTE const   )(unsigned char)202,      (UBYTE const   )(unsigned char)67,      (UBYTE const   )(unsigned char)44,      (UBYTE const   )(unsigned char)235, 
        (UBYTE const   )(unsigned char)107,      (UBYTE const   )(unsigned char)250,      (UBYTE const   )(unsigned char)75,      (UBYTE const   )(unsigned char)234, 
        (UBYTE const   )(unsigned char)49,      (UBYTE const   )(unsigned char)167,      (UBYTE const   )(unsigned char)125,      (UBYTE const   )(unsigned char)211, 
        (UBYTE const   )(unsigned char)83,      (UBYTE const   )(unsigned char)114,      (UBYTE const   )(unsigned char)157,      (UBYTE const   )(unsigned char)144, 
        (UBYTE const   )(unsigned char)32,      (UBYTE const   )(unsigned char)193,      (UBYTE const   )(unsigned char)143,      (UBYTE const   )(unsigned char)36, 
        (UBYTE const   )(unsigned char)158,      (UBYTE const   )(unsigned char)124,      (UBYTE const   )(unsigned char)247,      (UBYTE const   )(unsigned char)187, 
        (UBYTE const   )(unsigned char)89,      (UBYTE const   )(unsigned char)214,      (UBYTE const   )(unsigned char)141,      (UBYTE const   )(unsigned char)47, 
        (UBYTE const   )(unsigned char)121,      (UBYTE const   )(unsigned char)228,      (UBYTE const   )(unsigned char)61,      (UBYTE const   )(unsigned char)130, 
        (UBYTE const   )(unsigned char)213,      (UBYTE const   )(unsigned char)194,      (UBYTE const   )(unsigned char)174,      (UBYTE const   )(unsigned char)251, 
        (UBYTE const   )(unsigned char)97,      (UBYTE const   )(unsigned char)110,      (UBYTE const   )(unsigned char)54,      (UBYTE const   )(unsigned char)229, 
        (UBYTE const   )(unsigned char)115,      (UBYTE const   )(unsigned char)57,      (UBYTE const   )(unsigned char)152,      (UBYTE const   )(unsigned char)94, 
        (UBYTE const   )(unsigned char)105,      (UBYTE const   )(unsigned char)243,      (UBYTE const   )(unsigned char)212,      (UBYTE const   )(unsigned char)55, 
        (UBYTE const   )(unsigned char)209,      (UBYTE const   )(unsigned char)245,      (UBYTE const   )(unsigned char)63,      (UBYTE const   )(unsigned char)11, 
        (UBYTE const   )(unsigned char)164,      (UBYTE const   )(unsigned char)200,      (UBYTE const   )(unsigned char)31,      (UBYTE const   )(unsigned char)156, 
        (UBYTE const   )(unsigned char)81,      (UBYTE const   )(unsigned char)176,      (UBYTE const   )(unsigned char)227,      (UBYTE const   )(unsigned char)21, 
        (UBYTE const   )(unsigned char)76,      (UBYTE const   )(unsigned char)99,      (UBYTE const   )(unsigned char)139,      (UBYTE const   )(unsigned char)188, 
        (UBYTE const   )(unsigned char)127,      (UBYTE const   )(unsigned char)17,      (UBYTE const   )(unsigned char)248,      (UBYTE const   )(unsigned char)51, 
        (UBYTE const   )(unsigned char)207,      (UBYTE const   )(unsigned char)120,      (UBYTE const   )(unsigned char)189,      (UBYTE const   )(unsigned char)210, 
        (UBYTE const   )(unsigned char)8,      (UBYTE const   )(unsigned char)226,      (UBYTE const   )(unsigned char)41,      (UBYTE const   )(unsigned char)72, 
        (UBYTE const   )(unsigned char)183,      (UBYTE const   )(unsigned char)203,      (UBYTE const   )(unsigned char)135,      (UBYTE const   )(unsigned char)165, 
        (UBYTE const   )(unsigned char)166,      (UBYTE const   )(unsigned char)60,      (UBYTE const   )(unsigned char)98,      (UBYTE const   )(unsigned char)7, 
        (UBYTE const   )(unsigned char)122,      (UBYTE const   )(unsigned char)38,      (UBYTE const   )(unsigned char)155,      (UBYTE const   )(unsigned char)170, 
        (UBYTE const   )(unsigned char)69,      (UBYTE const   )(unsigned char)172,      (UBYTE const   )(unsigned char)252,      (UBYTE const   )(unsigned char)238, 
        (UBYTE const   )(unsigned char)39,      (UBYTE const   )(unsigned char)134,      (UBYTE const   )(unsigned char)59,      (UBYTE const   )(unsigned char)128, 
        (UBYTE const   )(unsigned char)236,      (UBYTE const   )(unsigned char)27,      (UBYTE const   )(unsigned char)240,      (UBYTE const   )(unsigned char)80, 
        (UBYTE const   )(unsigned char)131,      (UBYTE const   )(unsigned char)3,      (UBYTE const   )(unsigned char)85,      (UBYTE const   )(unsigned char)206, 
        (UBYTE const   )(unsigned char)145,      (UBYTE const   )(unsigned char)79,      (UBYTE const   )(unsigned char)154,      (UBYTE const   )(unsigned char)142, 
        (UBYTE const   )(unsigned char)159,      (UBYTE const   )(unsigned char)220,      (UBYTE const   )(unsigned char)201,      (UBYTE const   )(unsigned char)133, 
        (UBYTE const   )(unsigned char)74,      (UBYTE const   )(unsigned char)64,      (UBYTE const   )(unsigned char)20,      (UBYTE const   )(unsigned char)129, 
        (UBYTE const   )(unsigned char)224,      (UBYTE const   )(unsigned char)185,      (UBYTE const   )(unsigned char)138,      (UBYTE const   )(unsigned char)103, 
        (UBYTE const   )(unsigned char)173,      (UBYTE const   )(unsigned char)182,      (UBYTE const   )(unsigned char)43,      (UBYTE const   )(unsigned char)34, 
        (UBYTE const   )(unsigned char)254,      (UBYTE const   )(unsigned char)82,      (UBYTE const   )(unsigned char)198,      (UBYTE const   )(unsigned char)151, 
        (UBYTE const   )(unsigned char)231,      (UBYTE const   )(unsigned char)180,      (UBYTE const   )(unsigned char)58,      (UBYTE const   )(unsigned char)10, 
        (UBYTE const   )(unsigned char)118,      (UBYTE const   )(unsigned char)26,      (UBYTE const   )(unsigned char)102,      (UBYTE const   )(unsigned char)12, 
        (UBYTE const   )(unsigned char)50,      (UBYTE const   )(unsigned char)132,      (UBYTE const   )(unsigned char)22,      (UBYTE const   )(unsigned char)191, 
        (UBYTE const   )(unsigned char)136,      (UBYTE const   )(unsigned char)111,      (UBYTE const   )(unsigned char)162,      (UBYTE const   )(unsigned char)179, 
        (UBYTE const   )(unsigned char)45,      (UBYTE const   )(unsigned char)4,      (UBYTE const   )(unsigned char)148,      (UBYTE const   )(unsigned char)108, 
        (UBYTE const   )(unsigned char)161,      (UBYTE const   )(unsigned char)56,      (UBYTE const   )(unsigned char)78,      (UBYTE const   )(unsigned char)126, 
        (UBYTE const   )(unsigned char)242,      (UBYTE const   )(unsigned char)222,      (UBYTE const   )(unsigned char)15,      (UBYTE const   )(unsigned char)175, 
        (UBYTE const   )(unsigned char)146,      (UBYTE const   )(unsigned char)23,      (UBYTE const   )(unsigned char)33,      (UBYTE const   )(unsigned char)241, 
        (UBYTE const   )(unsigned char)181,      (UBYTE const   )(unsigned char)190,      (UBYTE const   )(unsigned char)77,      (UBYTE const   )(unsigned char)225, 
        (UBYTE const   )(unsigned char)0,      (UBYTE const   )(unsigned char)46,      (UBYTE const   )(unsigned char)169,      (UBYTE const   )(unsigned char)186, 
        (UBYTE const   )(unsigned char)68,      (UBYTE const   )(unsigned char)95,      (UBYTE const   )(unsigned char)237,      (UBYTE const   )(unsigned char)65, 
        (UBYTE const   )(unsigned char)53,      (UBYTE const   )(unsigned char)208,      (UBYTE const   )(unsigned char)253,      (UBYTE const   )(unsigned char)168, 
        (UBYTE const   )(unsigned char)9,      (UBYTE const   )(unsigned char)18,      (UBYTE const   )(unsigned char)100,      (UBYTE const   )(unsigned char)52, 
        (UBYTE const   )(unsigned char)116,      (UBYTE const   )(unsigned char)184,      (UBYTE const   )(unsigned char)160,      (UBYTE const   )(unsigned char)96, 
        (UBYTE const   )(unsigned char)109,      (UBYTE const   )(unsigned char)37,      (UBYTE const   )(unsigned char)30,      (UBYTE const   )(unsigned char)106, 
        (UBYTE const   )(unsigned char)140,      (UBYTE const   )(unsigned char)104,      (UBYTE const   )(unsigned char)150,      (UBYTE const   )(unsigned char)5, 
        (UBYTE const   )(unsigned char)204,      (UBYTE const   )(unsigned char)117,      (UBYTE const   )(unsigned char)112,      (UBYTE const   )(unsigned char)84};
#line 2388 "unrarlib.c"
static UDWORD Key[4]  ;
#line 2391 "unrarlib.c"
static void EncryptBlock(UBYTE *Buf ) 
{ int I ;
  UDWORD A ;
  UDWORD B ;
  UDWORD C ;
  UDWORD D ;
  UDWORD T ;
  UDWORD TA ;
  UDWORD TB ;
  UDWORD *BufPtr ;

  {
#line 2407
  BufPtr = (UDWORD *)Buf;
#line 2408
  A = (*(BufPtr + 0)) ^ Key[0];
#line 2409
  B = (*(BufPtr + 1)) ^ Key[1];
#line 2410
  C = (*(BufPtr + 2)) ^ Key[2];
#line 2411
  D = (*(BufPtr + 3)) ^ Key[3];
#line 2413
  I = 0;
#line 2413
  while (I < 32) {
#line 2415
    T = (C + ((D << 11) | (D >> (8U * sizeof(D) - 11U)))) ^ Key[I & 3];
#line 2416
    TA = A ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
#line 2417
    T = (D ^ ((C << 17) | (C >> (8U * sizeof(C) - 17U)))) + Key[I & 3];
#line 2418
    TB = B ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
#line 2419
    A = C;
#line 2420
    B = D;
#line 2421
    C = TA;
#line 2422
    D = TB;
#line 2413
    I ++;
  }
#line 2446
  (*(BufPtr + 0)) = C ^ Key[0];
#line 2447
  (*(BufPtr + 1)) = D ^ Key[1];
#line 2448
  (*(BufPtr + 2)) = A ^ Key[2];
#line 2449
  (*(BufPtr + 3)) = B ^ Key[3];
#line 2451
  UpdKeys(Buf);
#line 2452
  return;
}
}
#line 2455 "unrarlib.c"
static void DecryptBlock(unsigned char *Buf ) 
{ int I ;
  UBYTE InBuf___0[16] ;
  UDWORD A ;
  UDWORD B ;
  UDWORD C ;
  UDWORD D ;
  UDWORD T ;
  UDWORD TA ;
  UDWORD TB ;
  UDWORD *BufPtr ;

  {
#line 2471
  BufPtr = (UDWORD *)Buf;
#line 2472
  A = (*(BufPtr + 0)) ^ Key[0];
#line 2473
  B = (*(BufPtr + 1)) ^ Key[1];
#line 2474
  C = (*(BufPtr + 2)) ^ Key[2];
#line 2475
  D = (*(BufPtr + 3)) ^ Key[3];
#line 2477
  memcpy((void * __restrict  )(InBuf___0), (void const   * __restrict  )Buf, sizeof(InBuf___0));
#line 2478
  I = 31;
#line 2478
  while (I >= 0) {
#line 2480
    T = (C + ((D << 11) | (D >> (8U * sizeof(D) - 11U)))) ^ Key[I & 3];
#line 2481
    TA = A ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
#line 2482
    T = (D ^ ((C << 17) | (C >> (8U * sizeof(C) - 17U)))) + Key[I & 3];
#line 2483
    TB = B ^ ((((unsigned long )SubstTable[(int )T & 255] | ((unsigned long )SubstTable[(int )(T >>
                                                                                               8) &
                                                                                        255] <<
                                                             8)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                      16) &
                                                                                               255] <<
                                                                    16)) | ((unsigned long )SubstTable[(int )(T >>
                                                                                                              24) &
                                                                                                       255] <<
                                                                            24));
#line 2484
    A = C;
#line 2485
    B = D;
#line 2486
    C = TA;
#line 2487
    D = TB;
#line 2478
    I --;
  }
#line 2511
  (*(BufPtr + 0)) = C ^ Key[0];
#line 2512
  (*(BufPtr + 1)) = D ^ Key[1];
#line 2513
  (*(BufPtr + 2)) = A ^ Key[2];
#line 2514
  (*(BufPtr + 3)) = B ^ Key[3];
#line 2516
  UpdKeys(InBuf___0);
#line 2517
  return;
}
}
#line 2520 "unrarlib.c"
static void UpdKeys(UBYTE *Buf ) 
{ int I ;

  {
#line 2523
  I = 0;
#line 2523
  while (I < 16) {
#line 2525
    Key[0] ^= CRCTab[(*(Buf + I))];
#line 2526
    Key[1] ^= CRCTab[(*(Buf + (I + 1)))];
#line 2527
    Key[2] ^= CRCTab[(*(Buf + (I + 2)))];
#line 2528
    Key[3] ^= CRCTab[(*(Buf + (I + 3)))];
#line 2523
    I += 4;
  }
#line 2530
  return;
}
}
#line 2532 "unrarlib.c"
static void SetCryptKeys(char *NewPassword ) 
{ unsigned int I ;
  unsigned int J ;
  unsigned int K ;
  unsigned int PswLength ;
  unsigned char N1 ;
  unsigned char N2 ;
  unsigned char Psw[256] ;
  UBYTE Ch ;

  {
#line 2542
  SetOldKeys(NewPassword);
#line 2544
  Key[0] = 3550722169UL;
#line 2545
  Key[1] = 1064112887UL;
#line 2546
  Key[2] = 1964352053UL;
#line 2547
  Key[3] = 2766663971UL;
#line 2548
  memset((void *)(Psw), 0, sizeof(Psw));
#line 2549
  strcpy((char * __restrict  )((char *)(Psw)), (char const   * __restrict  )NewPassword);
#line 2550
  PswLength = strlen((char const   *)NewPassword);
#line 2551
  memcpy((void * __restrict  )(SubstTable), (void const   * __restrict  )(InitSubstTable),
         sizeof(SubstTable));
#line 2553
  J = 0U;
#line 2553
  while (J < 256U) {
#line 2554
    I = 0U;
#line 2554
    while (I < PswLength) {
#line 2556
      N2 = (unsigned char )CRCTab[((unsigned int )Psw[I + 1U] + J) & 255U];
#line 2557
      K = 1U;
#line 2557
      N1 = (unsigned char )CRCTab[((unsigned int )Psw[I] - J) & 255U];
#line 2557
      while ((int )N1 != (int )N2) {
#line 2613
        Ch = SubstTable[N1];
#line 2614
        SubstTable[N1] = SubstTable[(((unsigned int )N1 + I) + K) & 255U];
#line 2615
        SubstTable[(((unsigned int )N1 + I) + K) & 255U] = Ch;
#line 2557
        N1 = (unsigned char )((int )N1 + 1);
#line 2557
        K ++;
      }
#line 2554
      I += 2U;
    }
#line 2553
    J ++;
  }
#line 2619
  I = 0U;
#line 2619
  while (I < PswLength) {
#line 2620
    EncryptBlock(& Psw[I]);
#line 2619
    I += 16U;
  }
#line 2621
  return;
}
}
#line 2624 "unrarlib.c"
static void SetOldKeys(char *NewPassword ) 
{ UDWORD PswCRC ;
  UBYTE Ch ;
  UDWORD tmp ;

  {
#line 2628
  tmp = (UDWORD )strlen((char const   *)NewPassword);
#line 2628
  PswCRC = CalcCRC32(4294967295UL, (UBYTE *)NewPassword, tmp);
#line 2629
  OldKey[0] = (unsigned short )PswCRC;
#line 2630
  OldKey[1] = (unsigned short )(PswCRC >> 16);
#line 2631
  OldKey[3] = (unsigned short)0;
#line 2631
  OldKey[2] = OldKey[3];
#line 2632
  PN3 = (unsigned char)0;
#line 2632
  PN2 = PN3;
#line 2632
  PN1 = PN2;
#line 2633
  while (1) {
#line 2633
    Ch = (unsigned char )(*NewPassword);
#line 2633
    if (! ((int )Ch != 0)) {
#line 2633
      break;
    }
#line 2635
    PN1 = (unsigned char )((int )PN1 + (int )Ch);
#line 2636
    PN2 = (unsigned char )((int )PN2 ^ (int )Ch);
#line 2637
    PN3 = (unsigned char )((int )PN3 + (int )Ch);
#line 2638
    PN3 = (unsigned char )(((int )PN3 << 1) | ((int )PN3 >> (8U * sizeof(PN3) - 1U)));
#line 2639
    OldKey[2] = (unsigned short )((int )OldKey[2] ^ (int )((unsigned short )((unsigned long )Ch ^
                                                                             CRCTab[Ch])));
#line 2640
    OldKey[3] = (unsigned short )((int )OldKey[3] + (int )((unsigned short )((unsigned long )Ch +
                                                                             (CRCTab[Ch] >>
                                                                              16))));
#line 2641
    NewPassword ++;
  }
#line 2643
  return;
}
}
#line 2645 "unrarlib.c"
static short crcInitialized  =    (short)0;
#line 2646 "unrarlib.c"
static void InitCRC(void) 
{ int I ;
  int J ;
  UDWORD C ;

  {
#line 2650
  if (crcInitialized) {
#line 2650
    return;
  }
#line 2652
  cli_dbgmsg("%s:%d:%s Initialize CRC table\n", "unrarlib.c", 2652, "InitCRC");
#line 2653
  I = 0;
#line 2653
  while (I < 256) {
#line 2655
    C = (unsigned long )I;
#line 2655
    J = 0;
#line 2655
    while (J < 8) {
#line 2656
      if (C & 1UL) {
#line 2656
        C = (C >> 1) ^ 3988292384UL;
      } else {
#line 2656
        C = C >> 1;
      }
#line 2655
      J ++;
    }
#line 2657
    CRCTab[I] = C;
#line 2653
    I ++;
  }
#line 2659
  crcInitialized = (short)1;
#line 2660
  return;
}
}
#line 2663 "unrarlib.c"
static UDWORD CalcCRC32(UDWORD StartCRC , UBYTE *Addr , UDWORD Size ) 
{ unsigned int I ;

  {
#line 2666
  I = 0U;
#line 2666
  while ((unsigned long )I < Size) {
#line 2667
    StartCRC = CRCTab[(int )((unsigned char )StartCRC) ^ (int )(*(Addr + I))] ^ (StartCRC >>
                                                                                 8);
#line 2666
    I ++;
  }
#line 2668
  return (StartCRC);
}
}
#line 1 "zzip-dir.lo"
#pragma merger(0,"/tmp/cil-9nF29J93.i","-g -O2 -fPIC")
#line 115 "zziplib/zziplib.h"
int zzip_errno(int errcode ) ;
#line 172
ZZIP_DIR *zzip_opendir(zzip_char_t *filename ) ;
#line 174
int zzip_closedir(ZZIP_DIR *dir ) ;
#line 176
ZZIP_DIRENT *zzip_readdir(ZZIP_DIR *dir ) ;
#line 178
void zzip_rewinddir(ZZIP_DIR *dir ) ;
#line 180
zzip_off_t zzip_telldir(ZZIP_DIR *dir ) ;
#line 182
void zzip_seekdir(ZZIP_DIR *dir , zzip_off_t offset ) ;
#line 258
ZZIP_DIR *zzip_opendir_ext_io(zzip_char_t *filename , int o_modes , zzip_strings_t *ext___0 ,
                              zzip_plugin_io_t io ) ;
#line 267
ZZIP_DIR *zzip_dir_open_ext_io(zzip_char_t *filename , zzip_error_t *e , zzip_strings_t *ext___0 ,
                               zzip_plugin_io_t io ) ;
#line 56 "zziplib/zzip-dir.c"
void zzip_rewinddir(ZZIP_DIR *dir ) 
{ 

  {
#line 59
  if (! dir) {
#line 59
    return;
  }
#line 69
  if (dir->hdr0) {
#line 70
    dir->hdr = dir->hdr0;
  } else {
#line 72
    dir->hdr = (struct zzip_dir_hdr *)0;
  }
#line 73
  return;
}
}
#line 127 "zziplib/zzip-dir.c"
ZZIP_DIRENT *zzip_readdir(ZZIP_DIR *dir ) 
{ int *tmp ;

  {
#line 130
  if (! dir) {
#line 130
    tmp = __errno_location();
#line 130
    (*tmp) = 9;
#line 130
    return ((ZZIP_DIRENT *)0);
  }
#line 139
  if (! dir->hdr) {
#line 139
    return ((ZZIP_DIRENT *)0);
  }
#line 141
  dir->dirent.d_name = (dir->hdr)->d_name;
#line 142
  dir->dirent.d_compr = (int )(dir->hdr)->d_compr;
#line 144
  dir->dirent.d_csize = (int )(dir->hdr)->d_csize;
#line 145
  dir->dirent.st_size = (int )(dir->hdr)->d_usize;
#line 147
  dir->dirent.d_flags = (dir->hdr)->d_flags;
#line 149
  dir->dirent.d_crc32 = (int )(dir->hdr)->d_crc32;
#line 151
  if (! (dir->hdr)->d_reclen) {
#line 151
    dir->hdr = (struct zzip_dir_hdr *)0;
  } else {
#line 152
    dir->hdr = (struct zzip_dir_hdr *)((char *)dir->hdr + (int )(dir->hdr)->d_reclen);
  }
#line 155
  return (& dir->dirent);
}
}
#line 161 "zziplib/zzip-dir.c"
zzip_off_t zzip_telldir(ZZIP_DIR *dir ) 
{ int *tmp ;

  {
#line 164
  if (! dir) {
#line 164
    tmp = __errno_location();
#line 164
    (*tmp) = 9;
#line 164
    return (-1L);
  }
#line 171
  return ((long )((char *)dir->hdr - (char *)dir->hdr0));
}
}
#line 178 "zziplib/zzip-dir.c"
void zzip_seekdir(ZZIP_DIR *dir , zzip_off_t offset ) 
{ char *tmp ;

  {
#line 181
  if (! dir) {
#line 181
    return;
  }
#line 188
  if (dir->hdr0) {
#line 188
    tmp = (char *)dir->hdr0 + (unsigned int )offset;
  } else {
#line 188
    tmp = (char *)0;
  }
#line 188
  dir->hdr = (struct zzip_dir_hdr *)tmp;
#line 191
  return;
}
}
#line 221 "zziplib/zzip-dir.c"
ZZIP_DIR *zzip_opendir(zzip_char_t *filename ) 
{ ZZIP_DIR *tmp ;

  {
#line 224
  tmp = zzip_opendir_ext_io(filename, 0, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
#line 224
  return (tmp);
}
}
#line 231 "zziplib/zzip-dir.c"
ZZIP_DIR *zzip_opendir_ext_io(zzip_char_t *filename , int o_modes , zzip_strings_t *ext___0 ,
                              zzip_plugin_io_t io ) 
{ zzip_error_t e ;
  ZZIP_DIR *dir ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;

  {
#line 242
  if (o_modes & 81920) {
    goto try_zzip;
  }
  try_real: 
#line 246
  tmp = stat__extinline(filename, & st);
#line 246
  if (tmp >= 0) {
#line 246
    if ((st.st_mode & 61440U) == 16384U) {
#line 265
      return ((ZZIP_DIR *)0);
    }
  }
  try_zzip: 
#line 270
  dir = zzip_dir_open_ext_io(filename, & e, ext___0, io);
#line 271
  if (! dir) {
#line 271
    if (o_modes & 16384) {
      goto try_real;
    }
  }
#line 272
  if (e) {
#line 272
    tmp___0 = __errno_location();
#line 272
    (*tmp___0) = zzip_errno((int )e);
  }
#line 273
  return (dir);
}
}
#line 284 "zziplib/zzip-dir.c"
int zzip_closedir(ZZIP_DIR *dir ) 
{ int *tmp ;

  {
#line 287
  if (! dir) {
#line 287
    tmp = __errno_location();
#line 287
    (*tmp) = 9;
#line 287
    return (-1);
  }
#line 297
  zzip_dir_close(dir);
#line 298
  return (0);
}
}
#line 1 "zzip-err.lo"
#pragma merger(0,"/tmp/cil-fpr6n4nJ.i","-g -O2 -fPIC")
#line 111 "zziplib/zziplib.h"
zzip_char_t *zzip_strerror(int errcode ) ;
#line 113
zzip_char_t *zzip_strerror_of(ZZIP_DIR *dir ) ;
#line 1192 "/usr/include/zlib.h"
extern char const   *zError(int  ) ;
#line 26 "zziplib/zzip-err.c"
static struct errlistentry errlist[14]  = 
#line 26
  {      {0, "No error"}, 
        {-4116, "could not get temporary memory for internal structures"}, 
        {-4117, "Failed to open zip-file %s"}, 
        {-4118, "Failed to fstat zip-file %s"}, 
        {-4119, "Failed to lseek zip-file %s"}, 
        {-4120, "Failed to read zip-file %s"}, 
        {-4121, "zip-file %s too short"}, 
        {-4122, "zip-file central directory not found"}, 
        {-4123, "Directory size too big..."}, 
        {-4124, "No such file found in zip-file %s"}, 
        {-4125, "Unsupported compression format"}, 
        {-4127, "Zipfile corrupted"}, 
        {-4128, "Some undefined error occurred"}, 
        {0, (char const   *)0}};
#line 55 "zziplib/zzip-err.c"
zzip_char_t *zzip_strerror(int errcode ) 
{ struct errlistentry *err ;
  zzip_char_t *tmp ;
  zzip_char_t *tmp___0 ;
  zzip_char_t *tmp___1 ;

  {
#line 58
  if (errcode < -4096) {
#line 58
    if (errcode > -4128) {
#line 60
      err = errlist;
#line 61
      while (err->mesg) {
#line 63
        if (err->code == errcode) {
#line 64
          return (err->mesg);
        }
#line 61
        err ++;
      }
#line 66
      errcode = 22;
    }
  }
#line 69
  if (errcode < 0) {
#line 71
    if (errcode == -1) {
#line 72
      tmp = strerror(errcode);
#line 72
      return (tmp);
    } else {
#line 74
      tmp___0 = zError(errcode);
#line 74
      return (tmp___0);
    }
  }
#line 77
  tmp___1 = strerror(errcode);
#line 77
  return (tmp___1);
}
}
#line 85 "zziplib/zzip-err.c"
zzip_char_t *zzip_strerror_of(ZZIP_DIR *dir ) 
{ int *tmp ;
  zzip_char_t *tmp___0 ;
  zzip_char_t *tmp___1 ;

  {
#line 88
  if (! dir) {
#line 88
    tmp = __errno_location();
#line 88
    tmp___0 = strerror((*tmp));
#line 88
    return (tmp___0);
  }
#line 89
  tmp___1 = zzip_strerror(dir->errcode);
#line 89
  return (tmp___1);
}
}
#line 92 "zziplib/zzip-err.c"
static struct errnolistentry errnolist[18]  = 
#line 92
  {      {-2, 32}, 
        {-3, 29}, 
        {-4, 12}, 
        {-5, 24}, 
        {-6, 8}, 
        {-4117, 20}, 
        {-4118, 66}, 
        {-4119, 29}, 
        {-4120, 86}, 
        {-4121, 8}, 
        {-4122, 123}, 
        {-4123, 27}, 
        {-4116, 12}, 
        {-4124, 2}, 
        {-4125, 96}, 
        {-4127, 84}, 
        {-4128, 22}, 
        {0, 0}};
#line 139 "zziplib/zzip-err.c"
int zzip_errno(int errcode ) 
{ int *tmp ;
  struct errnolistentry *err ;

  {
#line 142
  if (errcode >= -1) {
#line 142
    tmp = __errno_location();
#line 142
    return ((*tmp));
  }
#line 144
  err = errnolist;
#line 145
  while (err->code) {
#line 147
    if (err->code == errcode) {
#line 148
      return (err->e_no);
    }
#line 145
    err ++;
  }
#line 151
  return (22);
}
}
#line 1 "zzip-file.lo"
#pragma merger(0,"/tmp/cil-M7hGkpNS.i","-g -O2 -fPIC")
#line 196 "zziplib/zziplib.h"
ZZIP_FILE *zzip_open(zzip_char_t *filename , int o_flags ) ;
#line 198
int zzip_close(ZZIP_FILE *fp ) ;
#line 200
zzip_ssize_t zzip_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) ;
#line 207
ZZIP_FILE *zzip_freopen(zzip_char_t *filename , zzip_char_t *mode , ZZIP_FILE *stream ) ;
#line 209
ZZIP_FILE *zzip_fopen(zzip_char_t *filename , zzip_char_t *mode ) ;
#line 211
zzip_size_t zzip_fread(void *ptr , zzip_size_t size , zzip_size_t nmemb , ZZIP_FILE *file ) ;
#line 214
int zzip_fclose(ZZIP_FILE *fp ) ;
#line 220
int zzip_rewind(ZZIP_FILE *fp ) ;
#line 222
zzip_off_t zzip_seek(ZZIP_FILE *fp , zzip_off_t offset , int whence ) ;
#line 224
zzip_off_t zzip_tell(ZZIP_FILE *fp ) ;
#line 249
ZZIP_FILE *zzip_open_shared_io(ZZIP_FILE *stream , zzip_char_t *filename , int o_flags ,
                               int o_modes , zzip_strings_t *ext___0 , zzip_plugin_io_t io ) ;
#line 254
ZZIP_FILE *zzip_open_ext_io(zzip_char_t *filename , int o_flags , int o_modes , zzip_strings_t *ext___0 ,
                            zzip_plugin_io_t io ) ;
#line 56 "zziplib/zzip-io.h"
zzip_plugin_io_t zzip_get_default_io(void) ;
#line 69 "zziplib/zzip.h"
int __zzip_try_open(zzip_char_t *filename , int filemode , zzip_strings_t *ext___0 ,
                    zzip_plugin_io_t io ) ;
#line 75
ZZIP_DIR *zzip_dir_fdopen_ext_io(int fd , zzip_error_t *errcode_p , zzip_strings_t *ext___0 ,
                                 zzip_plugin_io_t io ) ;
#line 334 "/usr/include/zlib.h"
extern int inflate(z_streamp strm , int flush ) ;
#line 433
extern int inflateEnd(z_streamp strm ) ;
#line 1168
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 99 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 57 "zziplib/zzip-file.c"
int zzip_file_close(ZZIP_FILE *fp ) 
{ ZZIP_DIR *dir ;
  int tmp ;

  {
#line 60
  dir = fp->dir;
#line 62
  if (fp->method) {
#line 64
    inflateEnd(& fp->d_stream);
  }
#line 66
  if (fp->buf32k) {
#line 68
    if ((unsigned int )dir->cache.buf32k == (unsigned int )((void *)0)) {
#line 68
      dir->cache.buf32k = fp->buf32k;
    } else {
#line 69
      free((void *)fp->buf32k);
    }
  }
#line 72
  if ((unsigned int )dir->currentfp == (unsigned int )fp) {
#line 73
    dir->currentfp = (struct zzip_file *)((void *)0);
  }
#line 75
  dir->refcount = dir->refcount - 1L;
#line 77
  memset((void *)fp, 0, sizeof((*fp)));
#line 79
  if ((unsigned int )dir->cache.fp == (unsigned int )((void *)0)) {
#line 79
    dir->cache.fp = fp;
  } else {
#line 80
    free((void *)fp);
  }
#line 82
  if (! dir->refcount) {
#line 82
    tmp = zzip_dir_close(dir);
#line 82
    return (tmp);
  } else {
#line 82
    return (0);
  }
}
}
#line 86 "zziplib/zzip-file.c"
static int zzip_file_saveoffset(ZZIP_FILE *fp ) 
{ int fd ;
  zzip_off_t off ;
  zzip_off_t tmp ;

  {
#line 89
  if (fp) {
#line 91
    fd = (fp->dir)->fd;
#line 92
    tmp = ((*((fp->io)->seeks)))(fd, 0L, 1);
#line 92
    off = tmp;
#line 93
    if (off < 0L) {
#line 94
      return (-1);
    }
#line 96
    fp->offset = off;
  }
#line 98
  return (0);
}
}
#line 116 "zziplib/zzip-file.c"
static zzip_char_t *_dirsep_strrchr(zzip_char_t *name ) 
{ char *n ;
  char *tmp ;
  char *m ;
  char *tmp___0 ;

  {
#line 119
  tmp = strrchr(name, '/');
#line 119
  n = tmp;
#line 120
  tmp___0 = strrchr(name, '\\');
#line 120
  m = tmp___0;
#line 121
  if (m) {
#line 121
    if (n) {
#line 121
      if ((unsigned int )m > (unsigned int )n) {
#line 121
        n = m;
      }
    }
  }
#line 122
  return ((zzip_char_t *)n);
}
}
#line 128
static int _dirsep_casecmp(zzip_char_t *s1 , zzip_char_t *s2 ) ;
#line 128 "zziplib/zzip-file.c"
static char const   mapping[33]  = 
#line 128
  {      (char const   )'@',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )'[', 
        (char const   )'/',      (char const   )']',      (char const   )'^',      (char const   )'_', 
        (char const   )'\000'};
#line 124 "zziplib/zzip-file.c"
static int _dirsep_casecmp(zzip_char_t *s1 , zzip_char_t *s2 ) 
{ int c1 ;
  int c2 ;

  {
#line 130
  while (1) {
#line 130
    if ((*s1)) {
#line 130
      if (! (*s2)) {
#line 130
        break;
      }
    } else {
#line 130
      break;
    }
#line 132
    c1 = (int )((unsigned char )(*s1));
#line 133
    c2 = (int )((unsigned char )(*s2));
#line 134
    if ((c1 & 224) == 64) {
#line 134
      c1 = (int )mapping[c1 & 31];
    }
#line 135
    if ((c1 & 224) == 64) {
#line 135
      c2 = (int )mapping[c2 & 31];
    }
#line 136
    if (c1 != c2) {
#line 137
      return (c1 - c2);
    }
#line 138
    s1 ++;
#line 138
    s2 ++;
  }
#line 141
  return ((int )((unsigned char )(*s1)) - (int )((unsigned char )(*s2)));
}
}
#line 145
static int zzip_inflate_init(ZZIP_FILE *fp , struct zzip_dir_hdr *hdr ) ;
#line 155 "zziplib/zzip-file.c"
ZZIP_FILE *zzip_file_open(ZZIP_DIR *dir , zzip_char_t *name , int o_mode ) 
{ zzip_error_t err ;
  struct zzip_file *fp ;
  struct zzip_dir_hdr *hdr ;
  int (*cmp)(zzip_char_t * , zzip_char_t * ) ;
  register zzip_char_t *n ;
  zzip_char_t *tmp ;
  register zzip_char_t *hdr_name ;
  register zzip_char_t *n___0 ;
  zzip_char_t *tmp___0 ;
  int tmp___3 ;
  zzip_off_t tmp___4 ;
  zzip_ssize_t dataoff ;
  struct zzip_file_header *p ;
  zzip_off_t tmp___5 ;
  int tmp___6 ;

  {
#line 158
  err = (enum __anonenum_zzip_error_t_37 )0;
#line 159
  fp = (struct zzip_file *)0;
#line 160
  hdr = dir->hdr0;
#line 163
  if (o_mode & 4096) {
#line 163
    cmp = & _dirsep_casecmp;
  } else {
#line 163
    cmp = & strcmp;
  }
#line 165
  if (! dir) {
#line 165
    return ((ZZIP_FILE *)0);
  } else {
#line 165
    if (! dir->fd) {
#line 165
      return ((ZZIP_FILE *)0);
    } else {
#line 165
      if (dir->fd == -1) {
#line 165
        return ((ZZIP_FILE *)0);
      }
    }
  }
#line 167
  if (o_mode & 8192) {
#line 169
    tmp = _dirsep_strrchr(name);
#line 169
    n = tmp;
#line 170
    if (n) {
#line 170
      name = n + 1;
    }
  }
#line 173
  if (hdr) {
#line 174
    while (1) {
#line 176
      hdr_name = (zzip_char_t *)(hdr->d_name);
#line 177
      if (o_mode & 8192) {
#line 179
        tmp___0 = _dirsep_strrchr(hdr_name);
#line 179
        n___0 = tmp___0;
#line 180
        if (n___0) {
#line 180
          hdr_name = n___0 + 1;
        }
      }
#line 188
      tmp___6 = ((*cmp))(hdr_name, name);
#line 188
      if (tmp___6) {
#line 273
        if ((int )hdr->d_reclen == 0) {
#line 274
          break;
        }
#line 275
        hdr = (struct zzip_dir_hdr *)((char *)hdr + (int )hdr->d_reclen);
      } else {
#line 190
        switch ((int )hdr->d_compr) {
        case 0: ;
        case 1: ;
        case 6: ;
        case 8: ;
        case 9: ;
#line 197
        break;
        default: 
#line 199
        cli_dbgmsg("ZzipLib: Unsupported compression mode (%d)\n", hdr->d_compr);
#line 200
        err = (enum __anonenum_zzip_error_t_37 )-4125;
        goto error;
        }
#line 204
        if (dir->cache.fp) {
#line 206
          fp = dir->cache.fp;
#line 206
          dir->cache.fp = (struct zzip_file *)((void *)0);
        } else {
#line 210
          fp = (struct zzip_file *)calloc(1U, sizeof((*fp)));
#line 210
          if (! fp) {
#line 211
            err = (enum __anonenum_zzip_error_t_37 )-4116;
            goto error;
          }
        }
#line 214
        fp->dir = dir;
#line 215
        fp->io = dir->io;
#line 216
        dir->refcount = dir->refcount + 1L;
#line 218
        if (dir->cache.buf32k) {
#line 219
          fp->buf32k = dir->cache.buf32k;
#line 219
          dir->cache.buf32k = (char *)((void *)0);
        } else {
#line 222
          fp->buf32k = (char *)malloc(32768U);
#line 222
          if (! fp->buf32k) {
#line 223
            err = (enum __anonenum_zzip_error_t_37 )-4116;
            goto error;
          }
        }
#line 232
        tmp___3 = zzip_file_saveoffset(dir->currentfp);
#line 232
        if (tmp___3 < 0) {
#line 233
          err = (enum __anonenum_zzip_error_t_37 )-4119;
          goto error;
        }
#line 235
        fp->offset = (long )hdr->d_off;
#line 236
        dir->currentfp = fp;
#line 238
        tmp___4 = ((*((dir->io)->seeks)))(dir->fd, (long )hdr->d_off, 0);
#line 238
        if (tmp___4 < 0L) {
#line 239
          err = (enum __anonenum_zzip_error_t_37 )-4119;
          goto error;
        }
#line 244
        p = (struct zzip_file_header *)((void *)fp->buf32k);
#line 246
        dataoff = ((*((dir->io)->read)))(dir->fd, (void *)p, sizeof((*p)));
#line 247
        if (dataoff < (int )sizeof((*p))) {
#line 248
          err = (enum __anonenum_zzip_error_t_37 )-4120;
          goto error;
        }
#line 257
        dataoff = (int )(*((uint16_t *)(p->z_namlen))) + (int )(*((uint16_t *)(p->z_extras)));
#line 259
        tmp___5 = ((*((dir->io)->seeks)))(dir->fd, (long )dataoff, 1);
#line 259
        if (tmp___5 < 0L) {
#line 260
          err = (enum __anonenum_zzip_error_t_37 )-4119;
          goto error;
        }
#line 262
        fp->dataoffset = ((*((dir->io)->seeks)))(dir->fd, 0L, 1);
#line 263
        fp->usize = hdr->d_usize;
#line 264
        fp->csize = hdr->d_csize;
#line 267
        err = (zzip_error_t )zzip_inflate_init(fp, hdr);
#line 268
        if (err) {
          goto error;
        }
#line 270
        return (fp);
      }
    }
  }
#line 278
  dir->errcode = -4124;
#line 278
  zzip_errno(-4124);
#line 279
  return ((ZZIP_FILE *)((void *)0));
  error: 
#line 281
  if (fp) {
#line 281
    zzip_file_close(fp);
  }
#line 282
  dir->errcode = (int )err;
#line 282
  zzip_errno((int )err);
#line 283
  return ((ZZIP_FILE *)((void *)0));
}
}
#line 290 "zziplib/zzip-file.c"
static int zzip_inflate_init(ZZIP_FILE *fp , struct zzip_dir_hdr *hdr ) 
{ int err ;

  {
#line 294
  fp->method = (int )hdr->d_compr;
#line 295
  fp->restlen = hdr->d_usize;
#line 297
  if (fp->method) {
#line 299
    memset((void *)(& fp->d_stream), 0, sizeof(fp->d_stream));
#line 301
    err = inflateInit2_(& fp->d_stream, -15, "1.2.2", (int )sizeof(z_stream ));
#line 302
    if (err != 0) {
      goto error;
    }
#line 304
    fp->crestlen = hdr->d_csize;
  }
#line 306
  return (0);
  error: 
#line 308
  if (fp) {
#line 308
    zzip_file_close(fp);
  }
#line 309
  return (err);
}
}
#line 318 "zziplib/zzip-file.c"
int zzip_fclose(ZZIP_FILE *fp ) 
{ int r ;
  int tmp ;
  int tmp___0 ;

  {
#line 321
  if (! fp) {
#line 321
    return (0);
  }
#line 322
  if (! fp->dir) {
#line 323
    tmp = ((*((fp->io)->close)))(fp->fd);
#line 323
    r = tmp;
#line 323
    free((void *)fp);
#line 323
    return (r);
  } else {
#line 324
    tmp___0 = zzip_file_close(fp);
#line 324
    return (tmp___0);
  }
}
}
#line 329 "zziplib/zzip-file.c"
int zzip_close(ZZIP_FILE *fp ) 
{ int tmp ;

  {
#line 332
  tmp = zzip_fclose(fp);
#line 332
  return (tmp);
}
}
#line 349 "zziplib/zzip-file.c"
zzip_ssize_t zzip_file_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) 
{ ZZIP_DIR *dir ;
  zzip_size_t l ;
  zzip_ssize_t rv ;
  int tmp ;
  zzip_off_t tmp___0 ;
  int err ;
  zzip_size_t startlen ;
  zzip_size_t cl ;
  zzip_size_t tmp___1 ;
  zzip_ssize_t i ;
  zzip_ssize_t tmp___2 ;

  {
#line 356
  if (! fp) {
#line 356
    return (0);
  } else {
#line 356
    if (! fp->dir) {
#line 356
      return (0);
    }
  }
#line 358
  dir = fp->dir;
#line 359
  if (fp->restlen > len) {
#line 359
    l = len;
  } else {
#line 359
    l = fp->restlen;
  }
#line 360
  if (fp->restlen == 0U) {
#line 361
    return (0);
  }
#line 367
  if ((unsigned int )dir->currentfp != (unsigned int )fp) {
#line 369
    tmp = zzip_file_saveoffset(dir->currentfp);
#line 369
    if (tmp < 0) {
#line 371
      dir->errcode = -4119;
#line 371
      return (-1);
    } else {
#line 369
      tmp___0 = ((*((fp->io)->seeks)))(dir->fd, fp->offset, 0);
#line 369
      if (tmp___0 < 0L) {
#line 371
        dir->errcode = -4119;
#line 371
        return (-1);
      } else {
#line 373
        dir->currentfp = fp;
      }
    }
  }
#line 377
  if (fp->method) {
#line 379
    fp->d_stream.avail_out = l;
#line 380
    fp->d_stream.next_out = (unsigned char *)buf;
#line 382
    while (1) {
#line 386
      if (fp->crestlen > 0U) {
#line 386
        if (fp->d_stream.avail_in == 0U) {
#line 388
          if (fp->crestlen < 32768U) {
#line 388
            tmp___1 = fp->crestlen;
          } else {
#line 388
            tmp___1 = 32768U;
          }
#line 388
          cl = tmp___1;
#line 392
          tmp___2 = ((*((fp->io)->read)))(dir->fd, (void *)fp->buf32k, cl);
#line 392
          i = tmp___2;
#line 393
          if (i <= 0) {
#line 395
            dir->errcode = -4120;
#line 396
            return (-1);
          }
#line 398
          fp->crestlen = fp->crestlen - (unsigned int )i;
#line 399
          fp->d_stream.avail_in = (unsigned int )i;
#line 400
          fp->d_stream.next_in = (unsigned char *)fp->buf32k;
        }
      }
#line 403
      startlen = (unsigned int )fp->d_stream.total_out;
#line 404
      err = inflate(& fp->d_stream, 0);
#line 406
      if (err == 1) {
#line 407
        fp->restlen = 0U;
      } else {
#line 409
        if (err == 0) {
#line 410
          fp->restlen = (unsigned int )((unsigned long )fp->restlen - (fp->d_stream.total_out -
                                                                       (unsigned long )startlen));
        } else {
#line 412
          dir->errcode = err;
#line 412
          return (-1);
        }
      }
#line 382
      if (fp->restlen) {
#line 382
        if (! fp->d_stream.avail_out) {
#line 382
          break;
        }
      } else {
#line 382
        break;
      }
    }
#line 415
    return ((int )(l - fp->d_stream.avail_out));
  } else {
#line 418
    rv = ((*((fp->io)->read)))(dir->fd, (void *)buf, l);
#line 419
    if (rv > 0) {
#line 420
      fp->restlen = fp->restlen - (unsigned int )rv;
    } else {
#line 422
      if (rv < 0) {
#line 423
        dir->errcode = -4120;
      }
    }
#line 424
    return (rv);
  }
}
}
#line 439 "zziplib/zzip-file.c"
zzip_ssize_t zzip_read(ZZIP_FILE *fp , char *buf , zzip_size_t len ) 
{ zzip_ssize_t tmp ;
  register zzip_ssize_t v ;
  int *tmp___0 ;

  {
#line 442
  if (! fp) {
#line 442
    return (0);
  }
#line 443
  if (! fp->dir) {
#line 444
    tmp = ((*((fp->io)->read)))(fp->fd, (void *)buf, len);
#line 444
    return (tmp);
  } else {
#line 447
    v = zzip_file_read(fp, buf, len);
#line 448
    if (v == -1) {
#line 448
      tmp___0 = __errno_location();
#line 448
      (*tmp___0) = zzip_errno((fp->dir)->errcode);
    }
#line 449
    return (v);
  }
}
}
#line 455 "zziplib/zzip-file.c"
zzip_size_t zzip_fread(void *ptr , zzip_size_t size , zzip_size_t nmemb , ZZIP_FILE *file ) 
{ zzip_ssize_t tmp ;

  {
#line 458
  if (! size) {
#line 458
    size = 1U;
  }
#line 459
  tmp = zzip_read(file, (char *)ptr, size * nmemb);
#line 459
  return ((unsigned int )tmp / size);
}
}
#line 526 "zziplib/zzip-file.c"
ZZIP_FILE *zzip_fopen(zzip_char_t *filename , zzip_char_t *mode ) 
{ ZZIP_FILE *tmp ;

  {
#line 529
  tmp = zzip_freopen(filename, mode, (ZZIP_FILE *)0);
#line 529
  return (tmp);
}
}
#line 551 "zziplib/zzip-file.c"
ZZIP_FILE *zzip_freopen(zzip_char_t *filename , zzip_char_t *mode , ZZIP_FILE *stream ) 
{ int o_flags ;
  int o_modes ;
  int tmp ;
  int tmp___0 ;
  ZZIP_FILE *fp ;
  ZZIP_FILE *tmp___1 ;

  {
#line 554
  o_flags = 0;
#line 555
  o_modes = 436;
#line 556
  if (! mode) {
#line 556
    mode = "rb";
  }
#line 571
  while ((*mode)) {
#line 573
    switch ((int )(*mode)) {
    case 48: ;
    case 49: ;
    case 50: ;
    case 51: ;
    case 52: ;
    case 53: ;
    case 54: ;
    case 55: ;
    case 56: ;
    case 57: ;
    goto __Cont;
    case 114: ;
#line 578
    if ((int const   )(*(mode + 1)) == 43) {
#line 578
      tmp = 2;
    } else {
#line 578
      tmp = 0;
    }
#line 578
    o_flags |= tmp;
#line 578
    break;
    case 119: ;
#line 579
    if ((int const   )(*(mode + 1)) == 43) {
#line 579
      tmp___0 = 2;
    } else {
#line 579
      tmp___0 = 1;
    }
#line 579
    o_flags |= tmp___0;
#line 580
    o_flags |= 512;
#line 580
    break;
    case 98: 
#line 581
    o_flags |= 0;
#line 581
    break;
    case 102: 
#line 582
    o_flags |= 256;
#line 582
    break;
    case 105: 
#line 583
    o_modes |= 4096;
#line 583
    break;
    case 42: 
#line 584
    o_modes |= 8192;
#line 584
    break;
    case 120: 
#line 585
    o_flags |= 128;
#line 585
    break;
    case 115: 
#line 586
    o_flags |= 4096;
#line 586
    break;
    case 110: 
#line 587
    o_flags |= 2048;
#line 587
    break;
    case 111: 
#line 588
    o_modes &= -8;
#line 589
    o_modes |= (int )(((int const   )(*(mode + 1)) - 48) & 7);
    goto __Cont;
    case 103: 
#line 590
    o_modes &= -57;
#line 591
    o_modes |= (int )((((int const   )(*(mode + 1)) - 48) << 3) & 56);
    goto __Cont;
    case 117: 
#line 592
    o_modes &= -449;
#line 593
    o_modes |= (int )((((int const   )(*(mode + 1)) - 48) << 6) & 448);
    goto __Cont;
    case 113: 
#line 594
    o_modes |= 131072;
#line 594
    break;
    case 122: ;
    goto __Cont;
    }
    __Cont: 
#line 571
    mode ++;
  }
#line 601
  tmp___1 = zzip_open_shared_io(stream, filename, o_flags, o_modes, (zzip_strings_t *)0,
                                (struct zzip_plugin_io  const  *)0);
#line 601
  fp = tmp___1;
#line 604
  if (((! o_modes != 0) != 0) & 131072) {
#line 604
    if (stream) {
#line 605
      zzip_file_close(stream);
    }
  }
#line 607
  return (fp);
}
}
#line 638 "zziplib/zzip-file.c"
ZZIP_FILE *zzip_open(zzip_char_t *filename , int o_flags ) 
{ int o_modes ;
  ZZIP_FILE *tmp ;

  {
#line 642
  o_modes = 436;
#line 643
  if (o_flags & 1024) {
#line 644
    o_flags ^= 1024;
#line 644
    o_modes |= 4096;
  }
#line 645
  if (o_flags & 512) {
#line 646
    o_flags ^= 512;
#line 646
    o_modes |= 8192;
  }
#line 647
  tmp = zzip_open_ext_io(filename, o_flags, o_modes, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
#line 647
  return (tmp);
}
}
#line 666 "zziplib/zzip-file.c"
ZZIP_FILE *zzip_open_ext_io(zzip_char_t *filename , int o_flags , int o_modes , zzip_strings_t *ext___0 ,
                            zzip_plugin_io_t io ) 
{ ZZIP_FILE *tmp ;

  {
#line 670
  tmp = zzip_open_shared_io((ZZIP_FILE *)0, filename, o_flags, o_modes, ext___0, io);
#line 670
  return (tmp);
}
}
#line 691 "zziplib/zzip-file.c"
ZZIP_FILE *zzip_open_shared_io(ZZIP_FILE *stream , zzip_char_t *filename , int o_flags ,
                               int o_modes , zzip_strings_t *ext___0 , zzip_plugin_io_t io ) 
{ zzip_plugin_io_t os ;
  zzip_plugin_io_t tmp___0 ;
  int fd ;
  int tmp___1 ;
  ZZIP_FILE *fp ;
  ZZIP_FILE *tmp___2 ;
  int *tmp___3 ;
  char basename[4096] ;
  char *p ;
  zzip_size_t len ;
  zzip_size_t tmp___4 ;
  ZZIP_FILE *fp___0 ;
  ZZIP_FILE *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  zzip_error_t e ;
  ZZIP_DIR *dir ;
  ZZIP_FILE *fp___1 ;
  int fd___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  size_t __len___2 ;
  size_t tmp___26 ;
  char *__retval___2 ;
  char *tmp___27 ;
  int tmp___29 ;
  int *tmp___30 ;

  {
#line 696
  if (stream) {
#line 696
    if (stream->dir) {
#line 698
      if (! ext___0) {
#line 698
        ext___0 = (stream->dir)->fileext;
      }
#line 699
      if (! io) {
#line 699
        io = (stream->dir)->io;
      }
    }
  }
#line 701
  if (! io) {
#line 701
    io = zzip_get_default_io();
  }
#line 703
  if (o_modes & 81920) {
    goto try_zzip;
  }
  try_real: 
#line 707
  if (o_modes & 262144) {
#line 707
    tmp___0 = zzip_get_default_io();
  } else {
#line 707
    tmp___0 = io;
  }
#line 707
  os = tmp___0;
#line 709
  tmp___1 = ((*(os->open)))(filename, o_flags);
#line 709
  fd = tmp___1;
#line 710
  if (fd != -1) {
#line 712
    tmp___2 = (ZZIP_FILE *)calloc(1U, sizeof(ZZIP_FILE ));
#line 712
    fp = tmp___2;
#line 713
    if (! fp) {
#line 713
      ((*(os->close)))(fd);
#line 713
      return ((ZZIP_FILE *)0);
    }
#line 715
    fp->fd = fd;
#line 716
    fp->io = os;
#line 717
    return (fp);
  }
#line 719
  if (o_modes & 16384) {
#line 719
    return ((ZZIP_FILE *)0);
  }
  try_zzip: 
#line 725
  if (o_flags & 65) {
#line 725
    tmp___3 = __errno_location();
#line 725
    (*tmp___3) = 22;
#line 725
    return ((ZZIP_FILE *)0);
  }
#line 726
  if (o_flags & 2) {
#line 726
    o_flags ^= 2;
#line 726
    o_flags |= 0;
  }
#line 736
  strcpy((char * __restrict  )(basename), (char const   * __restrict  )filename);
#line 739
  if (stream) {
#line 739
    if (stream->dir) {
#line 739
      if ((stream->dir)->realname) {
#line 741
        tmp___4 = strlen((char const   *)(stream->dir)->realname);
#line 741
        len = tmp___4;
#line 742
        tmp___7 = memcmp((void const   *)filename, (void const   *)(stream->dir)->realname,
                         len);
#line 742
        if (! tmp___7) {
#line 742
          if ((int const   )(*(filename + len)) == 47) {
#line 742
            if ((*(filename + (len + 1U)))) {
#line 745
              tmp___5 = zzip_file_open(stream->dir, (filename + len) + 1, o_modes);
#line 745
              fp___0 = tmp___5;
#line 747
              if (! fp___0) {
#line 747
                tmp___6 = __errno_location();
#line 747
                (*tmp___6) = zzip_errno((stream->dir)->errcode);
              }
#line 748
              return (fp___0);
            }
          }
        }
      }
    }
  }
#line 753
  while (1) {
#line 753
    p = strrchr((char const   *)(basename), '/');
#line 753
    if (! p) {
#line 753
      break;
    }
#line 755
    e = (enum __anonenum_zzip_error_t_37 )0;
#line 760
    (*p) = (char )'\000';
#line 761
    fd___0 = __zzip_try_open((zzip_char_t *)(basename), (o_flags | 0) | 0, ext___0,
                             io);
#line 762
    if (fd___0 == -1) {
#line 762
      continue;
    }
#line 765
    dir = zzip_dir_fdopen_ext_io(fd___0, & e, ext___0, io);
#line 766
    if (e) {
#line 766
      tmp___8 = __errno_location();
#line 766
      (*tmp___8) = zzip_errno((int )e);
#line 766
      ((*(io->close)))(fd___0);
#line 766
      return ((ZZIP_FILE *)0);
    }
#line 769
    fp___1 = zzip_file_open(dir, (filename + (p - basename)) + 1, o_modes);
#line 770
    if (! fp___1) {
#line 770
      tmp___9 = __errno_location();
#line 770
      (*tmp___9) = zzip_errno(dir->errcode);
    } else {
#line 771
      if (! dir->realname) {
#line 771
        tmp___29 = __builtin_constant_p((int )(basename));
#line 771
        if (tmp___29) {
#line 771
          if ((unsigned int )((void const   *)(basename + 1)) - (unsigned int )((void const   *)(basename)) ==
              1U) {
#line 771
            if ((int const   )(*((char const   *)(basename) + 0)) == 0) {
#line 771
              dir->realname = (char *)calloc(1U, 1U);
            } else {
#line 771
              tmp___26 = strlen((char const   *)(basename));
#line 771
              __len___2 = tmp___26 + 1U;
#line 771
              tmp___27 = (char *)malloc(__len___2);
#line 771
              __retval___2 = tmp___27;
#line 771
              if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 771
                __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )(basename),
                                              __len___2);
              }
#line 771
              dir->realname = __retval___2;
            }
          } else {
#line 771
            dir->realname = __strdup((char const   *)(basename));
          }
        } else {
#line 771
          dir->realname = __strdup((char const   *)(basename));
        }
      }
    }
#line 773
    zzip_dir_close(dir);
#line 777
    return (fp___1);
  }
#line 780
  if (o_modes & 16384) {
    goto try_real;
  }
#line 781
  tmp___30 = __errno_location();
#line 781
  (*tmp___30) = 2;
#line 781
  return ((ZZIP_FILE *)0);
}
}
#line 826 "zziplib/zzip-file.c"
int zzip_rewind(ZZIP_FILE *fp ) 
{ ZZIP_DIR *dir ;
  int err ;
  int tmp ;
  zzip_off_t tmp___0 ;

  {
#line 832
  if (! fp) {
#line 833
    return (-1);
  }
#line 835
  if (! fp->dir) {
#line 837
    ((*((fp->io)->seeks)))(fp->fd, 0L, 0);
#line 838
    return (0);
  }
#line 841
  dir = fp->dir;
#line 845
  if ((unsigned int )dir->currentfp != (unsigned int )fp) {
#line 847
    tmp = zzip_file_saveoffset(dir->currentfp);
#line 847
    if (tmp < 0) {
#line 848
      dir->errcode = -4119;
#line 848
      return (-1);
    } else {
#line 850
      dir->currentfp = fp;
    }
  }
#line 854
  tmp___0 = ((*((fp->io)->seeks)))(dir->fd, fp->dataoffset, 0);
#line 854
  if (tmp___0 < 0L) {
#line 855
    return (-1);
  }
#line 858
  fp->restlen = fp->usize;
#line 859
  fp->offset = fp->dataoffset;
#line 861
  if (fp->method) {
#line 863
    memset((void *)(& fp->d_stream), 0, sizeof(fp->d_stream));
#line 864
    err = inflateInit2_(& fp->d_stream, -15, "1.2.2", (int )sizeof(z_stream ));
#line 865
    if (err != 0) {
      goto error;
    }
#line 867
    fp->crestlen = fp->csize;
  }
#line 870
  return (0);
  error: 
#line 873
  if (fp) {
#line 873
    zzip_file_close(fp);
  }
#line 874
  return (err);
}
}
#line 891 "zziplib/zzip-file.c"
zzip_off_t zzip_seek(ZZIP_FILE *fp , zzip_off_t offset , int whence ) 
{ zzip_off_t cur_pos ;
  zzip_off_t rel_ofs ;
  zzip_off_t read_size ;
  zzip_off_t ofs ;
  ZZIP_DIR *dir ;
  zzip_off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  zzip_off_t tmp___2 ;
  char *buf ;
  zzip_off_t size ;
  zzip_off_t tmp___4 ;

  {
#line 897
  if (! fp) {
#line 898
    return (-1L);
  }
#line 900
  if (! fp->dir) {
#line 902
    tmp = ((*((fp->io)->seeks)))(fp->fd, offset, whence);
#line 902
    return (tmp);
  }
#line 905
  cur_pos = zzip_tell(fp);
#line 908
  switch (whence) {
  case 0: 
#line 911
  rel_ofs = offset - cur_pos;
#line 912
  break;
  case 1: 
#line 914
  rel_ofs = offset;
#line 915
  break;
  case 2: 
#line 917
  rel_ofs = (long )(((unsigned long )fp->usize + (unsigned long )offset) - (unsigned long )cur_pos);
#line 918
  break;
  default: ;
#line 920
  return (-1L);
  }
#line 923
  if (rel_ofs == 0L) {
#line 924
    return (cur_pos);
  }
#line 926
  if (rel_ofs < 0L) {
#line 928
    tmp___0 = zzip_rewind(fp);
#line 928
    if (tmp___0 == -1) {
#line 929
      return (-1L);
    }
#line 931
    read_size = cur_pos + rel_ofs;
#line 932
    cur_pos = 0L;
  } else {
#line 935
    read_size = rel_ofs;
  }
#line 938
  if (read_size < 0L) {
#line 939
    return (-1L);
  }
#line 941
  if (read_size + cur_pos > (long )fp->usize) {
#line 942
    return (-1L);
  }
#line 944
  if (read_size == 0L) {
#line 945
    return (cur_pos);
  }
#line 947
  dir = fp->dir;
#line 952
  if ((unsigned int )dir->currentfp != (unsigned int )fp) {
#line 954
    tmp___1 = zzip_file_saveoffset(dir->currentfp);
#line 954
    if (tmp___1 < 0) {
#line 956
      dir->errcode = -4119;
#line 956
      return (-1L);
    } else {
#line 954
      tmp___2 = ((*(((dir->currentfp)->io)->seeks)))(dir->fd, fp->offset, 0);
#line 954
      if (tmp___2 < 0L) {
#line 956
        dir->errcode = -4119;
#line 956
        return (-1L);
      } else {
#line 958
        dir->currentfp = fp;
      }
    }
  }
#line 961
  if (fp->method == 0) {
#line 963
    ofs = ((*((fp->io)->seeks)))(dir->fd, 0L, 1);
#line 964
    ofs = ((*((fp->io)->seeks)))(dir->fd, read_size, 1);
#line 965
    if (ofs > 0L) {
#line 967
      ofs -= fp->dataoffset;
#line 968
      fp->restlen = (unsigned int )((unsigned long )fp->usize - (unsigned long )ofs);
    }
#line 970
    return (ofs);
  } else {
#line 975
    buf = (char *)malloc(32768U);
#line 976
    if (! buf) {
#line 976
      return (-1L);
    }
#line 978
    while (read_size > 0L) {
#line 980
      size = 32768L;
#line 981
      if (read_size < size) {
#line 981
        size = read_size;
      }
#line 983
      size = (zzip_off_t )zzip_file_read(fp, buf, (unsigned int )size);
#line 984
      if (size <= 0L) {
#line 984
        free((void *)buf);
#line 984
        return (-1L);
      }
#line 986
      read_size -= size;
    }
#line 989
    free((void *)buf);
  }
#line 992
  tmp___4 = zzip_tell(fp);
#line 992
  return (tmp___4);
}
}
#line 1006 "zziplib/zzip-file.c"
zzip_off_t zzip_tell(ZZIP_FILE *fp ) 
{ zzip_off_t tmp ;

  {
#line 1009
  if (! fp) {
#line 1010
    return (-1L);
  }
#line 1012
  if (! fp->dir) {
#line 1013
    tmp = ((*((fp->io)->seeks)))(fp->fd, 0L, 1);
#line 1013
    return (tmp);
  }
#line 1016
  return ((long )(fp->usize - fp->restlen));
}
}
#line 1 "zzip-info.lo"
#pragma merger(0,"/tmp/cil-7Hdk7Rii.i","-g -O2 -fPIC")
#line 124 "zziplib/zziplib.h"
int zzip_error(ZZIP_DIR *dir ) ;
#line 126
void zzip_seterror(ZZIP_DIR *dir , int errcode ) ;
#line 128
zzip_char_t *zzip_compr_str(int compr ) ;
#line 131
ZZIP_DIR *zzip_dirhandle(ZZIP_FILE *fp ) ;
#line 133
int zzip_dirfd(ZZIP_DIR *dir ) ;
#line 135
int zzip_dir_real(ZZIP_DIR *dir ) ;
#line 137
int zzip_file_real(ZZIP_FILE *fp ) ;
#line 139
void *zzip_realdir(ZZIP_DIR *dir ) ;
#line 141
int zzip_realfd(ZZIP_FILE *fp ) ;
#line 32 "zziplib/zzip-info.c"
int zzip_error(ZZIP_DIR *dir ) 
{ 

  {
#line 35
  return (dir->errcode);
}
}
#line 41 "zziplib/zzip-info.c"
void zzip_seterror(ZZIP_DIR *dir , int errcode ) 
{ 

  {
#line 43
  dir->errcode = errcode;
#line 43
  return;
}
}
#line 51 "zziplib/zzip-info.c"
ZZIP_DIR *zzip_dirhandle(ZZIP_FILE *fp ) 
{ 

  {
#line 54
  return (fp->dir);
}
}
#line 64 "zziplib/zzip-info.c"
int zzip_dirfd(ZZIP_DIR *dir ) 
{ 

  {
#line 67
  return (dir->fd);
}
}
#line 74 "zziplib/zzip-info.c"
zzip_char_t *zzip_compr_str(int compr ) 
{ 

  {
#line 77
  switch (compr) {
  case 0: ;
#line 79
  return ("stored");
  case 1: ;
#line 80
  return ("shrunk");
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
#line 84
  return ("reduced");
  case 6: ;
#line 85
  return ("imploded");
  case 7: ;
#line 86
  return ("tokenized");
  case 8: ;
#line 87
  return ("deflated");
  case 9: ;
#line 88
  return ("deflatedX");
  case 10: ;
#line 89
  return ("implodedX");
  default: ;
#line 91
  if (0 < compr) {
#line 91
    if (compr < 256) {
#line 91
      return ("zipped");
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 95
    if ((compr & 61440) == 16384) {
#line 95
      return ("directory");
    }
#line 98
    if ((compr & 61440) == 8192) {
#line 98
      return ("is/chr");
    }
#line 101
    if ((compr & 61440) == 24576) {
#line 101
      return ("is/blk");
    }
#line 104
    if ((compr & 61440) == 4096) {
#line 104
      return ("is/fifo");
    }
#line 107
    if ((compr & 61440) == 49152) {
#line 107
      return ("is/sock");
    }
#line 110
    if ((compr & 61440) == 40960) {
#line 110
      return ("is/lnk");
    }
#line 112
    return ("special");
  }
  }
}
}
#line 122 "zziplib/zzip-info.c"
int zzip_dir_real(ZZIP_DIR *dir ) 
{ 

  {
#line 125
  return ((unsigned int )dir->realdir != (unsigned int )((void *)0));
}
}
#line 133 "zziplib/zzip-info.c"
int zzip_file_real(ZZIP_FILE *fp ) 
{ 

  {
#line 136
  return ((unsigned int )fp->dir == (unsigned int )((struct zzip_dir *)0));
}
}
#line 144 "zziplib/zzip-info.c"
void *zzip_realdir(ZZIP_DIR *dir ) 
{ 

  {
#line 147
  return (dir->realdir);
}
}
#line 155 "zziplib/zzip-info.c"
int zzip_realfd(ZZIP_FILE *fp ) 
{ 

  {
#line 158
  return (fp->fd);
}
}
#line 1 "zzip-io.lo"
#pragma merger(0,"/tmp/cil-tbTgAsit.i","-g -O2 -fPIC")
#line 52 "zziplib/zzip-io.h"
zzip_off_t zzip_filesize(int fd ) ;
#line 64
int zzip_init_io(struct zzip_plugin_io *io , int flags ) ;
#line 33 "zziplib/zzip-io.c"
zzip_off_t zzip_filesize(int fd ) 
{ struct stat st ;
  int tmp ;

  {
#line 38
  tmp = fstat__extinline(fd, & st);
#line 38
  if (tmp < 0) {
#line 39
    return (-1L);
  }
#line 47
  return (st.st_size);
}
}
#line 60 "zziplib/zzip-io.c"
static struct zzip_plugin_io  const  default_io  =    {& open, & close, & read, & lseek, & zzip_filesize, 1L};
#line 76 "zziplib/zzip-io.c"
zzip_plugin_io_t zzip_get_default_io(void) 
{ 

  {
#line 79
  return (& default_io);
}
}
#line 86 "zziplib/zzip-io.c"
int zzip_init_io(struct zzip_plugin_io *io , int flags ) 
{ 

  {
#line 88
  if (! io) {
#line 89
    return (-4096);
  }
#line 91
  memcpy((void * __restrict  )io, (void const   * __restrict  )(& default_io), sizeof(default_io));
#line 92
  io->use_mmap = (long )flags;
#line 93
  return (0);
}
}
#line 1 "zzip-stat.lo"
#pragma merger(0,"/tmp/cil-dVpMgZRl.i","-g -O2 -fPIC")
#line 231 "zziplib/zziplib.h"
int zzip_dir_stat(ZZIP_DIR *dir , zzip_char_t *name , ZZIP_STAT *zs , int flags ) ;
#line 34 "zziplib/zzip-stat.c"
int zzip_dir_stat(ZZIP_DIR *dir , zzip_char_t *name , ZZIP_STAT *zs , int flags ) 
{ struct zzip_dir_hdr *hdr ;
  int (*cmp)(zzip_char_t * , zzip_char_t * ) ;
  char *n ;
  char *tmp ;
  register char *hdr_name ;
  register char *n___0 ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 37
  hdr = dir->hdr0;
#line 40
  if (flags & 1024) {
#line 40
    cmp = & strcasecmp;
  } else {
#line 40
    cmp = & strcmp;
  }
#line 42
  if (flags & 512) {
#line 44
    tmp = strrchr(name, '/');
#line 44
    n = tmp;
#line 45
    if (n) {
#line 45
      name = (zzip_char_t *)(n + 1);
    }
  }
#line 48
  if (hdr) {
#line 49
    while (1) {
#line 51
      hdr_name = hdr->d_name;
#line 52
      if (flags & 512) {
#line 54
        tmp___0 = strrchr((char const   *)hdr_name, '/');
#line 54
        n___0 = tmp___0;
#line 55
        if (n___0) {
#line 55
          hdr_name = n___0 + 1;
        }
      }
#line 58
      tmp___1 = ((*cmp))((zzip_char_t *)hdr_name, name);
#line 58
      if (! tmp___1) {
#line 59
        break;
      }
#line 61
      if (! hdr->d_reclen) {
#line 63
        dir->errcode = -4124;
#line 64
        return (-1);
      }
#line 67
      hdr = (struct zzip_dir_hdr *)((char *)hdr + (int )hdr->d_reclen);
    }
  }
#line 70
  zs->d_compr = (int )hdr->d_compr;
#line 71
  zs->d_csize = (int )hdr->d_csize;
#line 72
  zs->st_size = (int )hdr->d_usize;
#line 73
  zs->d_name = hdr->d_name;
#line 75
  return (0);
}
}
#line 1 "zzip-zip.lo"
#pragma merger(0,"/tmp/cil-NE2JyWtX.i","-g -O2 -fPIC")
#line 148 "zziplib/zziplib.h"
ZZIP_DIR *zzip_dir_alloc(zzip_strings_t *fileext ) ;
#line 150
int zzip_dir_free(ZZIP_DIR *dir ) ;
#line 159
ZZIP_DIR *zzip_dir_open(zzip_char_t *filename , zzip_error_t *e ) ;
#line 79 "zziplib/zzip.h"
ZZIP_DIR *zzip_dir_alloc_ext_io(zzip_strings_t *ext___0 , zzip_plugin_io_t io ) ;
#line 83
uint32_t __zzip_get32(unsigned char *s ) ;
#line 84
uint16_t __zzip_get16(unsigned char *s ) ;
#line 47 "zziplib/zzip-zip.c"
uint32_t __zzip_get32(unsigned char *s ) 
{ 

  {
#line 49
  return (((((unsigned int )(*(s + 3)) << 24) | ((unsigned int )(*(s + 2)) << 16)) |
           ((unsigned int )(*(s + 1)) << 8)) | (unsigned int )(*(s + 0)));
}
}
#line 56 "zziplib/zzip-zip.c"
uint16_t __zzip_get16(unsigned char *s ) 
{ 

  {
#line 58
  return ((unsigned short )(((int )((unsigned short )(*(s + 1))) << 8) | (int )((unsigned short )(*(s +
                                                                                                    0)))));
}
}
#line 67
int __zzip_find_disk_trailer(int fd , zzip_off_t filesize , struct zzip_disk_trailer *trailer ,
                             zzip_plugin_io_t io ) ;
#line 70
int __zzip_parse_root_directory(int fd , struct zzip_disk_trailer *trailer , struct zzip_dir_hdr **hdr_return ,
                                zzip_plugin_io_t io ) ;
#line 75
__inline char *__zzip_aligned4(char *p ) ;
#line 166 "zziplib/zzip-zip.c"
int __zzip_find_disk_trailer(int fd , zzip_off_t filesize , struct zzip_disk_trailer *trailer ,
                             zzip_plugin_io_t io ) 
{ register int e ;
  char buffer[1024] ;
  char *buf ;
  zzip_off_t offset ;
  zzip_off_t maplen ;
  char *fd_map ;
  register unsigned char *mapped ;
  zzip_off_t pagesize___0 ;
  zzip_off_t tmp ;
  int tmp___0 ;
  register unsigned char *end ;
  register unsigned char *tail ;

  {
#line 184
  buf = buffer;
#line 188
  offset = 0L;
#line 189
  maplen = 0L;
#line 190
  fd_map = (char *)0;
#line 192
  if (! trailer) {
#line 193
    e = 22;
    goto cleanup;
  }
#line 195
  if (filesize < (long )((int )sizeof(struct zzip_disk_trailer ))) {
#line 196
    e = -4121;
    goto cleanup;
  }
#line 198
  if (! buf) {
#line 199
    e = -4116;
    goto cleanup;
  }
#line 201
  offset = filesize;
#line 202
  while (1) {
#line 206
    if (offset <= 0L) {
#line 206
      e = -4122;
      goto cleanup;
    }
#line 209
    if (filesize - offset > 65536L) {
#line 210
      e = -4122;
      goto cleanup;
    }
#line 240
    fd_map = (char *)0;
#line 242
    pagesize___0 = 512L;
#line 243
    if (offset == filesize) {
#line 243
      if (filesize > pagesize___0) {
#line 244
        offset -= pagesize___0;
      }
    }
#line 245
    if (offset < pagesize___0) {
#line 246
      maplen = offset + pagesize___0;
#line 246
      offset = 0L;
    } else {
#line 248
      offset -= pagesize___0;
#line 248
      maplen = 2L * pagesize___0;
#line 249
      if (offset & (pagesize___0 - 1L)) {
#line 250
        pagesize___0 -= offset & (pagesize___0 - 1L);
#line 251
        offset += pagesize___0;
#line 252
        maplen -= pagesize___0;
      }
    }
#line 255
    if (offset + maplen > filesize) {
#line 255
      maplen = filesize - offset;
    }
#line 258
    tmp = ((*(io->seeks)))(fd, offset, 0);
#line 258
    if (tmp < 0L) {
#line 259
      e = -4119;
      goto cleanup;
    }
#line 260
    tmp___0 = ((*(io->read)))(fd, (void *)buf, (unsigned int )maplen);
#line 260
    if (tmp___0 < (int )maplen) {
#line 261
      e = -4120;
      goto cleanup;
    }
#line 262
    mapped = (unsigned char *)buf;
#line 270
    end = mapped + maplen;
#line 272
    tail = end - 1;
#line 272
    while ((unsigned int )tail >= (unsigned int )mapped) {
#line 274
      if ((int )(*tail) == 80) {
#line 274
        if (end - tail >= (int )sizeof((*trailer)) - 2) {
#line 274
          if ((int )(*((char *)tail + 0)) == 80) {
#line 274
            if ((int )(*((char *)tail + 1)) == 75) {
#line 274
              if ((int )(*((char *)tail + 2)) == 5) {
#line 274
                if ((int )(*((char *)tail + 3)) == 6) {
#line 280
                  if (end - tail >= (int )sizeof((*trailer))) {
#line 282
                    memcpy((void * __restrict  )trailer, (void const   * __restrict  )tail,
                           sizeof((*trailer)));
                  } else {
#line 284
                    memcpy((void * __restrict  )trailer, (void const   * __restrict  )tail,
                           sizeof((*trailer)) - 2U);
#line 285
                    trailer->z_comment[0] = (char)0;
#line 286
                    trailer->z_comment[1] = (char)0;
                  }
#line 289
                  (*((zzip_off_t *)trailer)) = (long )((tail + offset) - mapped);
#line 290
                  e = 0;
                  goto cleanup;
                }
              }
            }
          }
        }
      }
#line 272
      tail --;
    }
  }
  cleanup: 
#line 312
  return (e);
}
}
#line 322 "zziplib/zzip-zip.c"
__inline char *__zzip_aligned4(char *p ) 
{ 

  {
#line 325
  p += (long )p & 1L;
#line 326
  p += (long )p & 2L;
#line 327
  return (p);
}
}
#line 336 "zziplib/zzip-zip.c"
int __zzip_parse_root_directory(int fd , struct zzip_disk_trailer *trailer , struct zzip_dir_hdr **hdr_return ,
                                zzip_plugin_io_t io ) 
{ struct zzip_root_dirent dirent ;
  struct zzip_dir_hdr *hdr ;
  struct zzip_dir_hdr *hdr0 ;
  uint16_t *p_reclen ;
  short entries ;
  long offset ;
  char *fd_map ;
  int32_t fd_gap ;
  uint16_t u_entries ;
  uint32_t u_rootsize ;
  uint32_t u_rootseek ;
  register struct zzip_root_dirent *d ;
  uint16_t u_extras ;
  uint16_t u_comment ;
  uint16_t u_namlen ;
  uint16_t u_flags ;
  zzip_off_t tmp___0 ;
  int tmp___1 ;
  register char *p ;
  register char *q ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 345
  p_reclen = (uint16_t *)0;
#line 348
  fd_map = (char *)0;
#line 349
  fd_gap = 0;
#line 350
  u_entries = (*((uint16_t *)(trailer->z_entries)));
#line 351
  u_rootsize = (*((uint32_t *)(trailer->z_rootsize)));
#line 352
  u_rootseek = (*((uint32_t *)(trailer->z_rootseek)));
#line 353
  if ((unsigned long )u_rootseek > (unsigned long )(*((zzip_off_t *)trailer)) - (unsigned long )u_rootsize) {
#line 353
    u_rootseek = (unsigned int )((unsigned long )(*((zzip_off_t *)trailer)) - (unsigned long )u_rootsize);
  }
#line 355
  hdr0 = (struct zzip_dir_hdr *)malloc(u_rootsize);
#line 356
  if (! hdr0) {
#line 357
    return (-4123);
  }
#line 358
  hdr = hdr0;
#line 375
  entries = (short )u_entries;
#line 375
  offset = 0L;
#line 375
  while ((int )entries > 0) {
#line 381
    if (fd_map) {
#line 382
      d = (struct zzip_root_dirent *)((void *)((fd_map + fd_gap) + offset));
    } else {
#line 385
      tmp___0 = ((*(io->seeks)))(fd, (long )((unsigned long )u_rootseek + (unsigned long )offset),
                                 0);
#line 385
      if (tmp___0 < 0L) {
#line 386
        free((void *)hdr0);
#line 387
        return (-4119);
      }
#line 389
      tmp___1 = ((*(io->read)))(fd, (void *)(& dirent), sizeof(dirent));
#line 389
      if (tmp___1 < (int )sizeof(dirent)) {
#line 390
        free((void *)hdr0);
#line 391
        return (-4120);
      }
#line 393
      d = & dirent;
    }
#line 396
    if ((unsigned long )offset + (unsigned long )sizeof((*d)) > (unsigned long )u_rootsize) {
#line 397
      break;
    }
#line 403
    u_extras = (*((uint16_t *)(d->z_extras)));
#line 404
    u_comment = (*((uint16_t *)(d->z_comment)));
#line 405
    u_namlen = (*((uint16_t *)(d->z_namlen)));
#line 406
    u_flags = (*((uint16_t *)(d->z_flags)));
#line 417
    hdr->d_crc32 = (*((uint32_t *)(d->z_crc32)));
#line 418
    hdr->d_csize = (*((uint32_t *)(d->z_csize)));
#line 419
    hdr->d_usize = (*((uint32_t *)(d->z_usize)));
#line 420
    hdr->d_off = (*((uint32_t *)(d->z_off)));
#line 421
    hdr->d_compr = (unsigned char )(*((uint16_t *)(d->z_compr)));
#line 422
    hdr->d_flags = u_flags;
#line 427
    if (((unsigned long )offset + (unsigned long )sizeof((*d))) + (unsigned long )u_namlen >
        (unsigned long )u_rootsize) {
#line 428
      break;
    }
#line 430
    if (fd_map) {
#line 431
      memcpy((void * __restrict  )(hdr->d_name), (void const   * __restrict  )(((fd_map +
                                                                                 fd_gap) +
                                                                                offset) +
                                                                               sizeof((*d))),
             (unsigned int )u_namlen);
    } else {
#line 432
      ((*(io->read)))(fd, (void *)(hdr->d_name), (unsigned int )u_namlen);
    }
#line 433
    hdr->d_name[u_namlen] = (char )'\000';
#line 434
    hdr->d_namlen = u_namlen;
#line 437
    offset = (long )((unsigned long )offset + (unsigned long )(((sizeof((*d)) + (unsigned int )u_namlen) +
                                                                (unsigned int )u_extras) +
                                                               (unsigned int )u_comment));
#line 439
    if (offset > (long )u_rootsize) {
#line 440
      entries = (short )((int )entries - 1);
#line 440
      break;
    }
#line 451
    p_reclen = & hdr->d_reclen;
#line 453
    p = (char *)hdr;
#line 454
    tmp___2 = __zzip_aligned4(((p + sizeof((*hdr))) + (int )u_namlen) + 1);
#line 454
    q = tmp___2;
#line 455
    (*p_reclen) = (unsigned short )(q - p);
#line 456
    hdr = (struct zzip_dir_hdr *)q;
#line 375
    entries = (short )((int )entries - 1);
  }
#line 466
  if (p_reclen) {
#line 468
    (*p_reclen) = (unsigned short)0;
#line 470
    if (hdr_return) {
#line 471
      (*hdr_return) = hdr0;
    }
  } else {
#line 472
    free((void *)hdr0);
  }
#line 474
  if (entries) {
#line 474
    tmp___3 = -4127;
  } else {
#line 474
    tmp___3 = 0;
  }
#line 474
  return (tmp___3);
}
}
#line 485
static zzip_strings_t *zzip_get_default_ext(void) ;
#line 485 "zziplib/zzip-zip.c"
static zzip_strings_t ext[3]  = {      (char const   * const  )".zip",      (char const   * const  )".ZIP",      (char const   * const  )0};
#line 483 "zziplib/zzip-zip.c"
static zzip_strings_t *zzip_get_default_ext(void) 
{ 

  {
#line 495
  return (ext);
}
}
#line 506 "zziplib/zzip-zip.c"
ZZIP_DIR *zzip_dir_alloc_ext_io(zzip_strings_t *ext___0 , zzip_plugin_io_t io ) 
{ ZZIP_DIR *dir ;

  {
#line 510
  dir = (ZZIP_DIR *)calloc(1U, sizeof((*dir)));
#line 510
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 511
    return ((ZZIP_DIR *)0);
  }
#line 514
  if (ext___0) {
#line 514
    dir->fileext = ext___0;
  } else {
#line 514
    dir->fileext = zzip_get_default_ext();
  }
#line 515
  if (io) {
#line 515
    dir->io = io;
  } else {
#line 515
    dir->io = zzip_get_default_io();
  }
#line 516
  return (dir);
}
}
#line 525 "zziplib/zzip-zip.c"
ZZIP_DIR *zzip_dir_alloc(zzip_strings_t *fileext ) 
{ ZZIP_DIR *tmp ;

  {
#line 528
  tmp = zzip_dir_alloc_ext_io(fileext, (struct zzip_plugin_io  const  *)0);
#line 528
  return (tmp);
}
}
#line 541 "zziplib/zzip-zip.c"
int zzip_dir_free(ZZIP_DIR *dir ) 
{ 

  {
#line 544
  if (dir->refcount) {
#line 545
    return ((int )dir->refcount);
  }
#line 547
  if (dir->fd >= 0) {
#line 547
    ((*((dir->io)->close)))(dir->fd);
  }
#line 548
  if (dir->hdr0) {
#line 548
    free((void *)dir->hdr0);
  }
#line 549
  if (dir->cache.fp) {
#line 549
    free((void *)dir->cache.fp);
  }
#line 550
  if (dir->cache.buf32k) {
#line 550
    free((void *)dir->cache.buf32k);
  }
#line 551
  if (dir->realname) {
#line 551
    free((void *)dir->realname);
  }
#line 552
  free((void *)dir);
#line 553
  return (0);
}
}
#line 561 "zziplib/zzip-zip.c"
int zzip_dir_close(ZZIP_DIR *dir ) 
{ int tmp ;

  {
#line 564
  dir->refcount = dir->refcount & -268435457L;
#line 565
  tmp = zzip_dir_free(dir);
#line 565
  return (tmp);
}
}
#line 577 "zziplib/zzip-zip.c"
ZZIP_DIR *zzip_dir_fdopen(int fd , zzip_error_t *errcode_p ) 
{ ZZIP_DIR *tmp ;

  {
#line 580
  tmp = zzip_dir_fdopen_ext_io(fd, errcode_p, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
#line 580
  return (tmp);
}
}
#line 583
static zzip_error_t __zzip_dir_parse(ZZIP_DIR *dir ) ;
#line 589 "zziplib/zzip-zip.c"
ZZIP_DIR *zzip_dir_fdopen_ext_io(int fd , zzip_error_t *errcode_p , zzip_strings_t *ext___0 ,
                                 zzip_plugin_io_t io ) 
{ zzip_error_t rv ;
  ZZIP_DIR *dir ;

  {
#line 596
  dir = zzip_dir_alloc_ext_io(ext___0, io);
#line 596
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 597
    rv = (enum __anonenum_zzip_error_t_37 )-4116;
    goto error;
  }
#line 599
  dir->fd = fd;
#line 600
  rv = __zzip_dir_parse(dir);
#line 600
  if (rv) {
    goto error;
  }
#line 603
  dir->hdr = dir->hdr0;
#line 604
  dir->refcount = dir->refcount | 268435456L;
#line 606
  if (errcode_p) {
#line 606
    (*errcode_p) = rv;
  }
#line 607
  return (dir);
  error: 
#line 609
  if (dir) {
#line 609
    zzip_dir_free(dir);
  }
#line 610
  if (errcode_p) {
#line 610
    (*errcode_p) = rv;
  }
#line 611
  return ((ZZIP_DIR *)((void *)0));
}
}
#line 614 "zziplib/zzip-zip.c"
static zzip_error_t __zzip_dir_parse(ZZIP_DIR *dir ) 
{ zzip_error_t rv ;
  zzip_off_t filesize ;
  struct zzip_disk_trailer trailer ;

  {
#line 627
  filesize = ((*((dir->io)->filesize)))(dir->fd);
#line 627
  if (filesize < 0L) {
#line 628
    rv = (enum __anonenum_zzip_error_t_37 )-4118;
    goto error;
  }
#line 633
  rv = (zzip_error_t )__zzip_find_disk_trailer(dir->fd, filesize, & trailer, dir->io);
#line 633
  if ((int )rv != 0) {
    goto error;
  }
#line 643
  rv = (zzip_error_t )__zzip_parse_root_directory(dir->fd, & trailer, & dir->hdr0,
                                                  dir->io);
#line 643
  if ((int )rv != 0) {
    goto error;
  }
  error: 
#line 647
  return (rv);
}
}
#line 655 "zziplib/zzip-zip.c"
int __zzip_try_open(zzip_char_t *filename , int filemode , zzip_strings_t *ext___0 ,
                    zzip_plugin_io_t io ) 
{ char file[4096] ;
  int fd ;
  zzip_size_t len ;
  zzip_size_t tmp ;

  {
#line 661
  tmp = strlen(filename);
#line 661
  len = tmp;
#line 663
  if (len + 4U >= 4096U) {
#line 663
    return (-1);
  }
#line 664
  memcpy((void * __restrict  )(file), (void const   * __restrict  )filename, len +
                                                                             1U);
#line 666
  if (! io) {
#line 666
    io = zzip_get_default_io();
  }
#line 667
  if (! ext___0) {
#line 667
    ext___0 = zzip_get_default_ext();
  }
#line 669
  while ((*ext___0)) {
#line 671
    strcpy((char * __restrict  )(file + len), (char const   * __restrict  )(*ext___0));
#line 672
    fd = ((*(io->open)))((zzip_char_t *)(file), filemode);
#line 673
    if (fd != -1) {
#line 673
      return (fd);
    }
#line 669
    ext___0 ++;
  }
#line 675
  return (-1);
}
}
#line 683 "zziplib/zzip-zip.c"
ZZIP_DIR *zzip_dir_open(zzip_char_t *filename , zzip_error_t *e ) 
{ ZZIP_DIR *tmp ;

  {
#line 686
  tmp = zzip_dir_open_ext_io(filename, e, (zzip_strings_t *)0, (struct zzip_plugin_io  const  *)0);
#line 686
  return (tmp);
}
}
#line 693 "zziplib/zzip-zip.c"
ZZIP_DIR *zzip_dir_open_ext_io(zzip_char_t *filename , zzip_error_t *e , zzip_strings_t *ext___0 ,
                               zzip_plugin_io_t io ) 
{ int fd ;
  ZZIP_DIR *tmp ;
  ZZIP_DIR *tmp___0 ;

  {
#line 699
  if (! io) {
#line 699
    io = zzip_get_default_io();
  }
#line 700
  if (! ext___0) {
#line 700
    ext___0 = zzip_get_default_ext();
  }
#line 702
  fd = ((*(io->open)))(filename, 0);
#line 703
  if (fd != -1) {
#line 704
    tmp = zzip_dir_fdopen_ext_io(fd, e, ext___0, io);
#line 704
    return (tmp);
  } else {
#line 707
    fd = __zzip_try_open(filename, 0, ext___0, io);
#line 708
    if (fd != -1) {
#line 709
      tmp___0 = zzip_dir_fdopen_ext_io(fd, e, ext___0, io);
#line 709
      return (tmp___0);
    } else {
#line 712
      if (e) {
#line 712
        (*e) = (enum __anonenum_zzip_error_t_37 )-4117;
      }
#line 713
      return ((ZZIP_DIR *)0);
    }
  }
}
}
#line 724 "zziplib/zzip-zip.c"
int zzip_dir_read(ZZIP_DIR *dir , ZZIP_DIRENT *d ) 
{ 

  {
#line 727
  if (! dir) {
#line 727
    return (0);
  } else {
#line 727
    if (! dir->hdr) {
#line 727
      return (0);
    } else {
#line 727
      if (! d) {
#line 727
        return (0);
      }
    }
  }
#line 729
  d->d_compr = (int )(dir->hdr)->d_compr;
#line 730
  d->d_csize = (int )(dir->hdr)->d_csize;
#line 731
  d->st_size = (int )(dir->hdr)->d_usize;
#line 732
  d->d_name = (dir->hdr)->d_name;
#line 733
  d->d_flags = (dir->hdr)->d_flags;
#line 734
  d->d_crc32 = (int )(dir->hdr)->d_crc32;
#line 736
  if (! (dir->hdr)->d_reclen) {
#line 737
    dir->hdr = (struct zzip_dir_hdr *)0;
  } else {
#line 739
    dir->hdr = (struct zzip_dir_hdr *)((char *)dir->hdr + (int )(dir->hdr)->d_reclen);
  }
#line 741
  return (1);
}
}
#line 1 "strc.lo"
#pragma merger(0,"/tmp/cil-mcMPgSWP.i","-g -O2 -fPIC")
#line 33 "zziplib/strc.c"
 __attribute__((__nothrow__)) int strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 33 "zziplib/strc.c"
int strcasecmp(char const   *s1 , char const   *s2 ) 
{ unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __res ;
  int __c ;
  unsigned char const   *tmp ;
  __int32_t const   **tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  __int32_t const   **tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  int __res___0 ;
  int __c___0 ;
  unsigned char const   *tmp___8 ;
  __int32_t const   **tmp___10 ;
  unsigned char const   *tmp___11 ;
  unsigned char const   *tmp___12 ;
  int tmp___13 ;
  __int32_t const   **tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char const   *tmp___16 ;

  {
#line 37
  p1 = (unsigned char const   *)s1;
#line 38
  p2 = (unsigned char const   *)s2;
#line 41
  if ((unsigned int )p1 == (unsigned int )p2) {
#line 42
    return (0);
  }
#line 44
  while (1) {
#line 46
    if (sizeof((*tmp___7)) > 1U) {
#line 46
      tmp___3 = p1;
#line 46
      p1 ++;
#line 46
      tmp___4 = __builtin_constant_p((int )(*tmp___3));
#line 46
      if (tmp___4) {
#line 46
        tmp = p1;
#line 46
        p1 ++;
#line 46
        __c = (int )(*tmp);
#line 46
        if (__c < -128) {
#line 46
          __res = __c;
        } else {
#line 46
          if (__c > 255) {
#line 46
            __res = __c;
          } else {
#line 46
            tmp___1 = __ctype_tolower_loc();
#line 46
            __res = (*((*tmp___1) + __c));
          }
        }
      } else {
#line 46
        tmp___2 = p1;
#line 46
        p1 ++;
#line 46
        __res = tolower__extinline((int )(*tmp___2));
      }
    } else {
#line 46
      tmp___5 = __ctype_tolower_loc();
#line 46
      tmp___6 = p1;
#line 46
      p1 ++;
#line 46
      __res = (*((*tmp___5) + (int )(*tmp___6)));
    }
#line 46
    c1 = (unsigned char )__res;
#line 47
    if (sizeof((*tmp___16)) > 1U) {
#line 47
      tmp___12 = p2;
#line 47
      p2 ++;
#line 47
      tmp___13 = __builtin_constant_p((int )(*tmp___12));
#line 47
      if (tmp___13) {
#line 47
        tmp___8 = p2;
#line 47
        p2 ++;
#line 47
        __c___0 = (int )(*tmp___8);
#line 47
        if (__c___0 < -128) {
#line 47
          __res___0 = __c___0;
        } else {
#line 47
          if (__c___0 > 255) {
#line 47
            __res___0 = __c___0;
          } else {
#line 47
            tmp___10 = __ctype_tolower_loc();
#line 47
            __res___0 = (*((*tmp___10) + __c___0));
          }
        }
      } else {
#line 47
        tmp___11 = p2;
#line 47
        p2 ++;
#line 47
        __res___0 = tolower__extinline((int )(*tmp___11));
      }
    } else {
#line 47
      tmp___14 = __ctype_tolower_loc();
#line 47
      tmp___15 = p2;
#line 47
      p2 ++;
#line 47
      __res___0 = (*((*tmp___14) + (int )(*tmp___15)));
    }
#line 47
    c2 = (unsigned char )__res___0;
#line 48
    if ((int )c1 == 0) {
#line 49
      break;
    }
#line 44
    if (! ((int )c1 == (int )c2)) {
#line 44
      break;
    }
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 1 "blob.lo"
#pragma merger(0,"/tmp/cil-JQz19YYI.i","-g -O2 -fPIC")
#line 702 "/usr/include/stdlib.h"
extern int mkstemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 884 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
#line 38 "blob.h"
blob *blobCreate(void) ;
#line 39
void blobDestroy(blob *b ) ;
#line 40
void blobArrayDestroy(blob **blobList , int n ) ;
#line 41
void blobSetFilename(blob *b , char const   *dir , char const   *filename ) ;
#line 42
char const   *blobGetFilename(blob const   *b ) ;
#line 43
int blobAddData(blob *b , unsigned char const   *data , size_t len ) ;
#line 44
unsigned char *blobGetData(blob const   *b ) ;
#line 45
unsigned long blobGetDataSize(blob const   *b ) ;
#line 46
void blobClose(blob *b ) ;
#line 47
int blobcmp(blob const   *b1 , blob const   *b2 ) ;
#line 48
void blobGrow(blob *b , size_t len ) ;
#line 59
fileblob *fileblobCreate(void) ;
#line 60
void fileblobDestroy(fileblob *fb ) ;
#line 61
void fileblobSetFilename(fileblob *fb , char const   *dir , char const   *filename ) ;
#line 62
char const   *fileblobGetFilename(fileblob const   *fb ) ;
#line 63
int fileblobAddData(fileblob *fb , unsigned char const   *data , size_t len ) ;
#line 64
void sanitiseName(char *name ) ;
#line 54 "blob.c"
blob *blobCreate(void) 
{ blob *tmp ;

  {
#line 64
  tmp = (blob *)cli_calloc(1U, sizeof(blob ));
#line 64
  return (tmp);
}
}
#line 68 "blob.c"
void blobDestroy(blob *b ) 
{ 

  {
#line 74
  cli_dbgmsg("blobDestroy\n");
#line 80
  if (b->name) {
#line 81
    free((void *)b->name);
  }
#line 82
  if (b->data) {
#line 83
    free((void *)b->data);
  }
#line 87
  free((void *)b);
#line 88
  return;
}
}
#line 90 "blob.c"
void blobArrayDestroy(blob **blobList , int n ) 
{ 

  {
#line 95
  while (1) {
#line 95
    n --;
#line 95
    if (! (n >= 0)) {
#line 95
      break;
    }
#line 96
    cli_dbgmsg("blobArrayDestroy: %d\n", n);
#line 97
    if ((*(blobList + n))) {
#line 98
      blobDestroy((*(blobList + n)));
#line 99
      (*(blobList + n)) = (blob *)((void *)0);
    }
  }
#line 102
  return;
}
}
#line 105 "blob.c"
void blobSetFilename(blob *b , char const   *dir , char const   *filename ) 
{ size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;

  {
#line 112
  cli_dbgmsg("blobSetFilename: %s\n", filename);
#line 114
  if (b->name) {
#line 115
    free((void *)b->name);
  }
#line 117
  tmp___18 = __builtin_constant_p((int )filename);
#line 117
  if (tmp___18) {
#line 117
    if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)filename) ==
        1U) {
#line 117
      if ((int const   )(*(filename + 0)) == 0) {
#line 117
        b->name = (char *)calloc(1U, 1U);
      } else {
#line 117
        tmp___15 = strlen(filename);
#line 117
        __len___2 = tmp___15 + 1U;
#line 117
        tmp___16 = (char *)malloc(__len___2);
#line 117
        __retval___2 = tmp___16;
#line 117
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 117
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )filename,
                                        __len___2);
        }
#line 117
        b->name = __retval___2;
      }
    } else {
#line 117
      b->name = __strdup(filename);
    }
  } else {
#line 117
    b->name = __strdup(filename);
  }
#line 119
  if (b->name) {
#line 120
    sanitiseName(b->name);
  }
#line 121
  return;
}
}
#line 123 "blob.c"
char const   *blobGetFilename(blob const   *b ) 
{ 

  {
#line 129
  return ((char const   *)b->name);
}
}
#line 136 "blob.c"
static int pagesize  ;
#line 132 "blob.c"
int blobAddData(blob *b , unsigned char const   *data , size_t len ) 
{ int growth ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 144
  if (len == 0U) {
#line 145
    return (0);
  }
#line 147
  if (b->isClosed) {
#line 152
    cli_warnmsg("Reopening closed blob\n");
#line 153
    b->isClosed = 0;
  }
#line 165
  if (pagesize == 0) {
#line 166
    pagesize = getpagesize();
#line 167
    if (pagesize == 0) {
#line 168
      pagesize = 4096;
    }
  }
#line 170
  growth = pagesize;
#line 171
  if (len >= (unsigned int )pagesize) {
#line 172
    growth = (int )((len / (unsigned int )pagesize + 1U) * (unsigned int )pagesize);
  }
#line 176
  if ((unsigned int )b->data == (unsigned int )((void *)0)) {
#line 180
    b->size = (unsigned long )growth;
#line 181
    b->data = (unsigned char *)cli_malloc((unsigned int )growth);
  } else {
#line 182
    if (b->size < b->len + (unsigned long )len) {
#line 183
      tmp = (unsigned char *)cli_realloc((void *)b->data, (unsigned int )(b->size +
                                                                          (unsigned long )growth));
#line 183
      p = tmp;
#line 185
      if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 186
        return (-1);
      }
#line 188
      b->size += (unsigned long )growth;
#line 189
      b->data = p;
    }
  }
#line 209
  if (b->data) {
#line 210
    memcpy((void * __restrict  )(b->data + b->len), (void const   * __restrict  )data,
           len);
#line 211
    b->len += (unsigned long )len;
  }
#line 213
  return (0);
}
}
#line 216 "blob.c"
unsigned char *blobGetData(blob const   *b ) 
{ 

  {
#line 222
  if (b->len == 0UL) {
#line 223
    return ((unsigned char *)((void *)0));
  }
#line 224
  return (b->data);
}
}
#line 227 "blob.c"
unsigned long blobGetDataSize(blob const   *b ) 
{ 

  {
#line 233
  return (b->len);
}
}
#line 236 "blob.c"
void blobClose(blob *b ) 
{ unsigned char *ptr ;
  unsigned char *tmp ;

  {
#line 242
  if (b->isClosed) {
#line 243
    cli_dbgmsg("Attempt to close a previously closed blob\n");
#line 244
    return;
  }
#line 251
  if (b->size - b->len >= 64UL) {
#line 252
    if (b->len == 0UL) {
#line 253
      free((void *)b->data);
#line 254
      b->data = (unsigned char *)((void *)0);
#line 255
      cli_dbgmsg("blobClose: recovered all %u bytes\n", b->size);
#line 257
      b->size = 0UL;
    } else {
#line 259
      tmp = (unsigned char *)cli_realloc((void *)b->data, (unsigned int )b->len);
#line 259
      ptr = tmp;
#line 261
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 262
        return;
      }
#line 264
      cli_dbgmsg("blobClose: recovered %u bytes from %u\n", b->size - b->len, b->size);
#line 266
      b->size = b->len;
#line 267
      b->data = ptr;
    }
  }
#line 270
  b->isClosed = 1;
#line 271
  return;
}
}
#line 276 "blob.c"
int blobcmp(blob const   *b1 , blob const   *b2 ) 
{ unsigned long s1 ;
  unsigned long s2 ;
  void const   *tmp ;
  void const   *tmp___0 ;
  int tmp___1 ;

  {
#line 284
  if ((unsigned int )b1 == (unsigned int )b2) {
#line 285
    return (0);
  }
#line 287
  s1 = blobGetDataSize(b1);
#line 288
  s2 = blobGetDataSize(b2);
#line 290
  if (s1 != s2) {
#line 291
    return (1);
  }
#line 293
  if (s1 == 0UL) {
#line 293
    if (s2 == 0UL) {
#line 294
      return (0);
    }
  }
#line 296
  tmp = (void const   *)blobGetData(b2);
#line 296
  tmp___0 = (void const   *)blobGetData(b1);
#line 296
  tmp___1 = memcmp(tmp___0, tmp, (unsigned int )s1);
#line 296
  return (tmp___1);
}
}
#line 299 "blob.c"
void blobGrow(blob *b , size_t len ) 
{ unsigned char *ptr ;
  unsigned char *tmp ;

  {
#line 305
  if (len == 0U) {
#line 306
    return;
  }
#line 308
  if (b->isClosed) {
#line 313
    cli_warnmsg("Growing closed blob\n");
#line 314
    b->isClosed = 0;
  }
#line 316
  if ((unsigned int )b->data == (unsigned int )((void *)0)) {
#line 320
    b->data = (unsigned char *)cli_malloc(len);
#line 321
    if (b->data) {
#line 322
      b->size = (unsigned long )len;
    }
  } else {
#line 324
    tmp = (unsigned char *)cli_realloc((void *)b->data, (unsigned int )(b->size +
                                                                        (unsigned long )len));
#line 324
    ptr = tmp;
#line 326
    if (ptr) {
#line 327
      b->size += (unsigned long )len;
#line 328
      b->data = ptr;
    }
  }
#line 331
  return;
}
}
#line 333 "blob.c"
fileblob *fileblobCreate(void) 
{ fileblob *tmp ;

  {
#line 343
  tmp = (fileblob *)cli_calloc(1U, sizeof(fileblob ));
#line 343
  return (tmp);
}
}
#line 347 "blob.c"
void fileblobDestroy(fileblob *fb ) 
{ 

  {
#line 353
  if (fb->b.name) {
#line 353
    if (fb->fp) {
#line 354
      fclose(fb->fp);
#line 355
      cli_dbgmsg("fileblobDestroy: %s\n", fb->b.name);
#line 356
      if (! fb->isNotEmpty) {
#line 357
        cli_dbgmsg("fileblobDestroy: not saving empty file\n");
#line 358
        unlink((char const   *)fb->b.name);
      }
#line 360
      free((void *)fb->b.name);
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 363
    if (fb->b.data) {
#line 364
      cli_errmsg("fileblobDestroy: file not saved: report to bugs@clamav.net\n");
#line 365
      free((void *)fb->b.data);
#line 366
      if (fb->b.name) {
#line 367
        free((void *)fb->b.name);
      }
    }
  }
#line 372
  free((void *)fb);
#line 373
  return;
}
}
#line 375 "blob.c"
void fileblobSetFilename(fileblob *fb , char const   *dir , char const   *filename ) 
{ int fd ;
  char fullname[256] ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;

  {
#line 381
  if (fb->b.name) {
#line 382
    return;
  }
#line 387
  blobSetFilename(& fb->b, dir, filename);
#line 393
  filename = blobGetFilename((blob const   *)(& fb->b));
#line 404
  tmp = strlen(dir);
#line 404
  snprintf((char * __restrict  )(fullname), sizeof(fullname) - 1U, (char const   * __restrict  )"%s/%.*sXXXXXX",
           dir, (int )((sizeof(fullname) - 9U) - tmp), filename);
#line 409
  cli_dbgmsg("fileblobSetFilename: mkstemp(%s)\n", fullname);
#line 410
  fd = mkstemp(fullname);
#line 417
  if (fd < 0) {
#line 418
    tmp___0 = __errno_location();
#line 418
    tmp___1 = strerror((*tmp___0));
#line 418
    cli_errmsg("Can\'t create temporary file %s: %s\n", fullname, tmp___1);
#line 419
    tmp___2 = strlen((char const   *)(fullname));
#line 419
    cli_dbgmsg("%d %d\n", sizeof(fullname), tmp___2);
#line 420
    return;
  }
#line 423
  cli_dbgmsg("Saving attachment as %s\n", fullname);
#line 425
  fb->fp = fdopen(fd, "wb");
#line 427
  if ((unsigned int )fb->fp == (unsigned int )((void *)0)) {
#line 428
    tmp___3 = __errno_location();
#line 428
    tmp___4 = strerror((*tmp___3));
#line 428
    cli_errmsg("Can\'t create file %s: %s\n", fullname, tmp___4);
#line 429
    tmp___5 = strlen((char const   *)(fullname));
#line 429
    cli_dbgmsg("%d %d\n", sizeof(fullname), tmp___5);
#line 430
    close(fd);
#line 432
    return;
  }
#line 434
  if (fb->b.data) {
#line 435
    tmp___8 = fwrite((void const   * __restrict  )fb->b.data, (unsigned int )fb->b.len,
                     1U, (FILE * __restrict  )fb->fp);
#line 435
    if (tmp___8 != 1U) {
#line 436
      tmp___6 = __errno_location();
#line 436
      tmp___7 = strerror((*tmp___6));
#line 436
      cli_errmsg("fileblobSetFilename: Can\'t write to temporary file %s: %s\n", fullname,
                 tmp___7);
    } else {
#line 438
      fb->isNotEmpty = 1;
    }
#line 439
    free((void *)fb->b.data);
#line 440
    fb->b.data = (unsigned char *)((void *)0);
#line 441
    fb->b.size = 0UL;
#line 441
    fb->b.len = fb->b.size;
  }
#line 443
  return;
}
}
#line 445 "blob.c"
int fileblobAddData(fileblob *fb , unsigned char const   *data , size_t len ) 
{ int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 448
  if (len == 0U) {
#line 449
    return (0);
  }
#line 453
  if (fb->fp) {
#line 454
    tmp___1 = fwrite((void const   * __restrict  )data, len, 1U, (FILE * __restrict  )fb->fp);
#line 454
    if (tmp___1 != 1U) {
#line 455
      tmp = __errno_location();
#line 455
      tmp___0 = strerror((*tmp));
#line 455
      cli_errmsg("fileblobAddData: Can\'t write %u bytes to temporary file %s: %s\n",
                 len, fb->b.name, tmp___0);
#line 456
      return (-1);
    }
#line 458
    fb->isNotEmpty = 1;
#line 459
    return (0);
  }
#line 461
  tmp___2 = blobAddData(& fb->b, data, len);
#line 461
  return (tmp___2);
}
}
#line 464 "blob.c"
char const   *fileblobGetFilename(fileblob const   *fb ) 
{ char const   *tmp ;

  {
#line 467
  tmp = blobGetFilename((blob const   *)(& fb->b));
#line 467
  return (tmp);
}
}
#line 475 "blob.c"
void sanitiseName(char *name ) 
{ 

  {
#line 478
  while ((*name)) {
#line 486
    if ((int )(*name) == 47) {
#line 488
      (*name) = (char )'_';
    }
#line 489
    name ++;
  }
#line 491
  return;
}
}
#line 1 "mbox.lo"
#pragma merger(0,"/tmp/cil-Gu7RlaTG.i","-g -O2 -fPIC")
#line 444 "/usr/include/libio.h"
extern  __attribute__((__nothrow__)) int _IO_getc(_IO_FILE *__fp ) ;
#line 445
extern  __attribute__((__nothrow__)) int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 585 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 598
extern int ungetc(int __c , FILE *__stream ) ;
#line 724
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 726
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 205 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *__strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                                                      char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
#line 329
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1174 "/usr/include/bits/string2.h"
__inline static char *__strtok_r_1c__extinline(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1178
  if ((unsigned int )__s == (unsigned int )((void *)0)) {
#line 1179
    __s = (*__nextp);
  }
#line 1180
  while ((int )(*__s) == (int )__sep) {
#line 1181
    __s ++;
  }
#line 1182
  __result = (char *)((void *)0);
#line 1183
  if ((int )(*__s) != 0) {
#line 1185
    tmp = __s;
#line 1185
    __s ++;
#line 1185
    __result = tmp;
#line 1186
    while ((int )(*__s) != 0) {
#line 1187
      tmp___0 = __s;
#line 1187
      __s ++;
#line 1187
      if ((int )(*tmp___0) == (int )__sep) {
#line 1189
        (*(__s + -1)) = (char )'\000';
#line 1190
        break;
      }
    }
#line 1192
    (*__nextp) = __s;
  }
#line 1194
  return (__result);
}
}
#line 163 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __threadp ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg ) ;
#line 180
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 33 "table.h"
struct table *tableCreate(void) ;
#line 34
void tableDestroy(table_t *table ) ;
#line 35
int tableInsert(table_t *table , char const   *key , int value ) ;
#line 36
int tableFind(table_t const   *table , char const   *key ) ;
#line 40 "mbox.h"
size_t strstrip(char *s ) ;
#line 50 "line.h"
char const   *lineGetData(line_t const   *line ) ;
#line 46 "message.h"
message *messageCreate(void) ;
#line 47
void messageDestroy(message *m ) ;
#line 48
void messageReset(message *m ) ;
#line 49
int messageSetMimeType(message *mess , char const   *type ) ;
#line 50
mime_type messageGetMimeType(message const   *m ) ;
#line 51
void messageSetMimeSubtype(message *m , char const   *subtype___0 ) ;
#line 52
char const   *messageGetMimeSubtype(message const   *m ) ;
#line 53
void messageSetDispositionType(message *m , char const   *disptype ) ;
#line 54
char const   *messageGetDispositionType(message const   *m ) ;
#line 55
void messageAddArgument(message *m , char const   *arg ) ;
#line 56
void messageAddArguments(message *m , char const   *s ) ;
#line 57
char const   *messageFindArgument(message const   *m , char const   *variable ) ;
#line 58
void messageSetEncoding(message *m , char const   *enctype ) ;
#line 59
encoding_type messageGetEncoding(message const   *m ) ;
#line 60
int messageAddLine(message *m , line_t *line ) ;
#line 61
int messageAddStr(message *m , char const   *data ) ;
#line 63
text const   *messageGetBody(message const   *m ) ;
#line 64
void messageClean(message *m ) ;
#line 65
fileblob *messageToFileblob(message *m , char const   *dir ) ;
#line 66
blob *messageToBlob(message *m ) ;
#line 68
text const   *binhexBegin(message const   *m ) ;
#line 69
text const   *uuencodeBegin(message const   *m ) ;
#line 71
text const   *bounceBegin(message const   *m ) ;
#line 72
text const   *encodingLine(message const   *m ) ;
#line 74
unsigned char *decodeLine(message *m , encoding_type et , char const   *line , unsigned char *buf ,
                          size_t buflen ) ;
#line 75
int isuuencodebegin(char const   *line ) ;
#line 43 "text.h"
void textDestroy(text *t_head ) ;
#line 45
text *textAdd(text *t_head , text const   *t ) ;
#line 46
text *textAddMessage(text *aText , message *aMessage ) ;
#line 48
fileblob *textToFileblob(text const   *t , fileblob *fb ) ;
#line 29 "htmlnorm.h"
int html_normalise_mem(unsigned char *in_buff , off_t in_size , char const   *dirname ,
                       tag_arguments_t *hrefs ) ;
#line 31
void html_tag_arg_free(tag_arguments_t *tags ) ;
#line 1141 "/usr/include/curl/curl.h"
extern CURLcode curl_global_init(long flags ) ;
#line 1187
extern struct curl_slist *curl_slist_append(struct curl_slist * , char const   * ) ;
#line 1197
extern void curl_slist_free_all(struct curl_slist * ) ;
#line 29 "/usr/include/curl/easy.h"
extern CURL *curl_easy_init(void) ;
#line 30
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
#line 31
extern CURLcode curl_easy_perform(CURL *curl ) ;
#line 32
extern void curl_easy_cleanup(CURL *curl ) ;
#line 171 "mbox.c"
static int cli_parse_mbox(char const   *dir , int desc , unsigned int options ) ;
#line 172
static message *parseEmailFile(FILE *fin , table_t const   *rfc821___0 , char const   *firstLine ,
                               char const   *dir ) ;
#line 173
static message *parseEmailHeaders(message const   *m , table_t const   *rfc821___0 ) ;
#line 174
static int parseEmailHeader(message *m , char const   *line , table_t const   *rfc821___0 ) ;
#line 175
static int parseEmailBody(message *messageIn , text *textIn , char const   *dir ,
                          table_t const   *rfc821Table , table_t const   *subtypeTable ,
                          unsigned int options ) ;
#line 176
static int boundaryStart(char const   *line , char const   *boundary ) ;
#line 177
static int endOfMessage(char const   *line , char const   *boundary ) ;
#line 178
static int initialiseTables(table_t **rfc821Table , table_t **subtypeTable ) ;
#line 179
static int getTextPart(message * const  *messages , size_t size ) ;
#line 180
static size_t strip(char *buf , int len ) ;
#line 181
static bool continuationMarker(char const   *line ) ;
#line 182
static int parseMimeHeader(message *m , char const   *cmd , table_t const   *rfc821Table ,
                           char const   *arg ) ;
#line 183
static void saveTextPart(message *m , char const   *dir ) ;
#line 184
static char *rfc2047(char const   *in ) ;
#line 185
static char *rfc822comments(char const   *in , char *out ) ;
#line 187
static int rfc1341(message *m , char const   *dir ) ;
#line 189
static bool usefulHeader(int commandNumber , char const   *cmd ) ;
#line 190
static void uufasttrack(message *m , char const   *firstline , char const   *dir ,
                        FILE *fin ) ;
#line 191
static char *getline(char *buffer , size_t len , FILE *fin ) ;
#line 196
static void checkURLs(message *m , char const   *dir ) ;
#line 204
static void *getURL(void *a ) ;
#line 258 "mbox.c"
static struct tableinit  const  rfc821headers[4]  = {      {"Content-Type", 1}, 
        {"Content-Transfer-Encoding", 2}, 
        {"Content-Disposition", 3}, 
        {(char const   *)((void *)0), 0}};
#line 258 "mbox.c"
static struct tableinit  const  mimeSubtypes[20]  = 
#line 258
  {      {"plain", 1}, 
        {"enriched", 2}, 
        {"html", 3}, 
        {"richtext", 4}, 
        {"mixed", 5}, 
        {"alternative", 6}, 
        {"digest", 7}, 
        {"signed", 8}, 
        {"parallel", 9}, 
        {"related", 10}, 
        {"report", 11}, 
        {"appledouble", 12}, 
        {"fax-message", 5}, 
        {"encrypted", 13}, 
        {"x-bfile", 10}, 
        {"knowbot", 14}, 
        {"knowbot-metadata", 14}, 
        {"knowbot-code", 14}, 
        {"knowbot-state", 14}, 
        {(char const   *)((void *)0), 0}};
#line 293 "mbox.c"
static struct __anonstruct_pthread_mutex_t_16 tables_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
#line 690 "mbox.c"
int cli_mbox(char const   *dir , int desc , unsigned int options ) 
{ int tmp ;

  {
#line 693
  if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 694
    cli_warnmsg("cli_mbox called with NULL dir\n");
#line 695
    return (300);
  }
#line 697
  tmp = cli_parse_mbox(dir, desc, options);
#line 697
  return (tmp);
}
}
#line 725 "mbox.c"
static table_t *rfc821  ;
#line 725 "mbox.c"
static table_t *subtype  ;
#line 715 "mbox.c"
static int cli_parse_mbox(char const   *dir , int desc , unsigned int options ) 
{ int retcode ;
  int i ;
  message *body___0 ;
  FILE *fd ;
  char buffer[1001] ;
  char *tmp ;
  int tmp___0 ;
  bool lastLineWasEmpty ;
  int messagenumber ;
  message *m ;
  message *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  text const   *tmp___4 ;
  int tmp___79 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___115 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___134 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  size_t tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  char *tmp___161 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___239 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___275 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___294 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___303 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  size_t tmp___310 ;
  int tmp___311 ;
  size_t tmp___312 ;
  char *tmp___317 ;
  int tmp___319 ;
  int tmp___320 ;
  char *tmp___321 ;
  int tmp___396 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___432 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___451 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___460 ;
  int tmp___461 ;
  int tmp___462 ;
  int tmp___463 ;
  int tmp___464 ;
  int tmp___465 ;
  int tmp___466 ;
  size_t tmp___467 ;
  int tmp___468 ;
  size_t tmp___469 ;
  int tmp___470 ;
  text const   *tmp___471 ;

  {
#line 731
  cli_dbgmsg("in mbox()\n");
#line 733
  i = dup(desc);
#line 734
  fd = fdopen(i, "rb");
#line 734
  if ((unsigned int )fd == (unsigned int )((void *)0)) {
#line 735
    cli_errmsg("Can\'t open descriptor %d\n", desc);
#line 736
    close(i);
#line 737
    return (-4);
  }
#line 764
  tmp = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U), (FILE * __restrict  )fd);
#line 764
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 766
    fclose(fd);
#line 770
    return (0);
  }
#line 773
  pthread_mutex_lock(& tables_mutex);
#line 775
  if ((unsigned int )rfc821 == (unsigned int )((void *)0)) {
#line 778
    tmp___0 = initialiseTables(& rfc821, & subtype);
#line 778
    if (tmp___0 < 0) {
#line 779
      rfc821 = (table_t *)((void *)0);
#line 780
      subtype = (table_t *)((void *)0);
#line 782
      pthread_mutex_unlock(& tables_mutex);
#line 784
      fclose(fd);
#line 788
      return (-3);
    }
  }
#line 792
  pthread_mutex_unlock(& tables_mutex);
#line 809
  tmp___466 = __builtin_constant_p((int )(buffer));
#line 809
  if (tmp___466) {
#line 809
    tmp___467 = strlen((char const   *)(buffer));
#line 809
    if (tmp___467 < 5U) {
      goto _L___123;
    } else {
      goto _L___124;
    }
  } else {
    _L___124: 
#line 809
    tmp___468 = __builtin_constant_p((int )"From ");
#line 809
    if (tmp___468) {
#line 809
      tmp___469 = strlen("From ");
#line 809
      if (tmp___469 < 5U) {
        _L___123: 
#line 809
        tmp___463 = __builtin_constant_p((int )(buffer));
#line 809
        if (tmp___463) {
#line 809
          tmp___464 = __builtin_constant_p((int )"From ");
#line 809
          if (tmp___464) {
#line 809
            __s1_len___4 = strlen((char const   *)(buffer));
#line 809
            __s2_len___4 = strlen("From ");
#line 809
            if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                   1U)) {
              goto _L___120;
            } else {
#line 809
              if (__s1_len___4 >= 4U) {
                _L___120: 
#line 809
                if (! ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                       1U)) {
#line 809
                  tmp___465 = 1;
                } else {
#line 809
                  if (__s2_len___4 >= 4U) {
#line 809
                    tmp___465 = 1;
                  } else {
#line 809
                    tmp___465 = 0;
                  }
                }
              } else {
#line 809
                tmp___465 = 0;
              }
            }
#line 809
            if (tmp___465) {
#line 809
              tmp___432 = __builtin_strcmp(buffer, "From ");
            } else {
              goto _L___122;
            }
          } else {
            goto _L___122;
          }
        } else {
          _L___122: 
#line 809
          tmp___462 = __builtin_constant_p((int )(buffer));
#line 809
          if (tmp___462) {
#line 809
            if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                1U) {
#line 809
              __s1_len___4 = strlen((char const   *)(buffer));
#line 809
              if (__s1_len___4 < 4U) {
#line 809
                tmp___451 = __builtin_constant_p((int )"From ");
#line 809
                if (tmp___451) {
#line 809
                  if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                      1U) {
#line 809
                    tmp___432 = __builtin_strcmp(buffer, "From ");
                  } else {
                    goto _L___115;
                  }
                } else {
                  _L___115: 
#line 809
                  __s2___46 = (unsigned char const   *)"From ";
#line 809
                  __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                           0)) - (int const   )(*(__s2___46 +
                                                                                  0)));
#line 809
                  if (__s1_len___4 > 0U) {
#line 809
                    if (__result___138 == 0) {
#line 809
                      __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                               1)) - (int const   )(*(__s2___46 +
                                                                                      1)));
#line 809
                      if (__s1_len___4 > 1U) {
#line 809
                        if (__result___138 == 0) {
#line 809
                          __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                   2)) - (int const   )(*(__s2___46 +
                                                                                          2)));
#line 809
                          if (__s1_len___4 > 2U) {
#line 809
                            if (__result___138 == 0) {
#line 809
                              __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                       3)) - (int const   )(*(__s2___46 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 809
                  tmp___432 = __result___138;
                }
              } else {
                goto _L___119;
              }
            } else {
              goto _L___119;
            }
          } else {
            _L___119: 
#line 809
            tmp___461 = __builtin_constant_p((int )"From ");
#line 809
            if (tmp___461) {
#line 809
              if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                  1U) {
#line 809
                __s2_len___4 = strlen("From ");
#line 809
                if (__s2_len___4 < 4U) {
#line 809
                  tmp___460 = __builtin_constant_p((int )(buffer));
#line 809
                  if (tmp___460) {
#line 809
                    if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                        1U) {
#line 809
                      tmp___432 = __builtin_strcmp(buffer, "From ");
                    } else {
                      goto _L___117;
                    }
                  } else {
                    _L___117: 
#line 809
                    __s1___94 = (unsigned char const   *)((char const   *)(buffer));
#line 809
                    __result___142 = (int )((int const   )(*(__s1___94 + 0)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                                0)));
#line 809
                    if (__s2_len___4 > 0U) {
#line 809
                      if (__result___142 == 0) {
#line 809
                        __result___142 = (int )((int const   )(*(__s1___94 + 1)) -
                                                (int const   )(*((unsigned char const   *)"From " +
                                                                 1)));
#line 809
                        if (__s2_len___4 > 1U) {
#line 809
                          if (__result___142 == 0) {
#line 809
                            __result___142 = (int )((int const   )(*(__s1___94 + 2)) -
                                                    (int const   )(*((unsigned char const   *)"From " +
                                                                     2)));
#line 809
                            if (__s2_len___4 > 2U) {
#line 809
                              if (__result___142 == 0) {
#line 809
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 809
                    tmp___432 = __result___142;
                  }
                } else {
#line 809
                  tmp___432 = __builtin_strcmp(buffer, "From ");
                }
              } else {
#line 809
                tmp___432 = __builtin_strcmp(buffer, "From ");
              }
            } else {
#line 809
              tmp___432 = __builtin_strcmp(buffer, "From ");
            }
          }
        }
#line 809
        tmp___396 = tmp___432;
      } else {
#line 809
        tmp___396 = strncmp((char const   *)(buffer), "From ", 5U);
      }
    } else {
#line 809
      tmp___396 = strncmp((char const   *)(buffer), "From ", 5U);
    }
  }
#line 809
  if (tmp___396 == 0) {
#line 830
    tmp___1 = messageCreate();
#line 830
    m = tmp___1;
#line 832
    if ((unsigned int )m == (unsigned int )((void *)0)) {
#line 833
      fclose(fd);
#line 840
      return (-3);
    }
#line 843
    lastLineWasEmpty = (enum __anonenum_bool_35 )0;
#line 844
    messagenumber = 1;
#line 846
    while (1) {
#line 847
      cli_chomp(buffer);
#line 848
      if (lastLineWasEmpty) {
#line 848
        tmp___149 = __builtin_constant_p((int )(buffer));
#line 848
        if (tmp___149) {
#line 848
          tmp___150 = strlen((char const   *)(buffer));
#line 848
          if (tmp___150 < 5U) {
            goto _L___39;
          } else {
            goto _L___40;
          }
        } else {
          _L___40: 
#line 848
          tmp___151 = __builtin_constant_p((int )"From ");
#line 848
          if (tmp___151) {
#line 848
            tmp___152 = strlen("From ");
#line 848
            if (tmp___152 < 5U) {
              _L___39: 
#line 848
              tmp___146 = __builtin_constant_p((int )(buffer));
#line 848
              if (tmp___146) {
#line 848
                tmp___147 = __builtin_constant_p((int )"From ");
#line 848
                if (tmp___147) {
#line 848
                  __s1_len___0 = strlen((char const   *)(buffer));
#line 848
                  __s2_len___0 = strlen("From ");
#line 848
                  if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                         1U)) {
                    goto _L___36;
                  } else {
#line 848
                    if (__s1_len___0 >= 4U) {
                      _L___36: 
#line 848
                      if (! ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                             1U)) {
#line 848
                        tmp___148 = 1;
                      } else {
#line 848
                        if (__s2_len___0 >= 4U) {
#line 848
                          tmp___148 = 1;
                        } else {
#line 848
                          tmp___148 = 0;
                        }
                      }
                    } else {
#line 848
                      tmp___148 = 0;
                    }
                  }
#line 848
                  if (tmp___148) {
#line 848
                    tmp___115 = __builtin_strcmp(buffer, "From ");
                  } else {
                    goto _L___38;
                  }
                } else {
                  goto _L___38;
                }
              } else {
                _L___38: 
#line 848
                tmp___145 = __builtin_constant_p((int )(buffer));
#line 848
                if (tmp___145) {
#line 848
                  if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                      1U) {
#line 848
                    __s1_len___0 = strlen((char const   *)(buffer));
#line 848
                    if (__s1_len___0 < 4U) {
#line 848
                      tmp___134 = __builtin_constant_p((int )"From ");
#line 848
                      if (tmp___134) {
#line 848
                        if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                            1U) {
#line 848
                          tmp___115 = __builtin_strcmp(buffer, "From ");
                        } else {
                          goto _L___31;
                        }
                      } else {
                        _L___31: 
#line 848
                        __s2___14 = (unsigned char const   *)"From ";
#line 848
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                0)) - (int const   )(*(__s2___14 +
                                                                                       0)));
#line 848
                        if (__s1_len___0 > 0U) {
#line 848
                          if (__result___42 == 0) {
#line 848
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                    1)) - (int const   )(*(__s2___14 +
                                                                                           1)));
#line 848
                            if (__s1_len___0 > 1U) {
#line 848
                              if (__result___42 == 0) {
#line 848
                                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                        2)) - (int const   )(*(__s2___14 +
                                                                                               2)));
#line 848
                                if (__s1_len___0 > 2U) {
#line 848
                                  if (__result___42 == 0) {
#line 848
                                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                            3)) -
                                                           (int const   )(*(__s2___14 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 848
                        tmp___115 = __result___42;
                      }
                    } else {
                      goto _L___35;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  _L___35: 
#line 848
                  tmp___144 = __builtin_constant_p((int )"From ");
#line 848
                  if (tmp___144) {
#line 848
                    if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                        1U) {
#line 848
                      __s2_len___0 = strlen("From ");
#line 848
                      if (__s2_len___0 < 4U) {
#line 848
                        tmp___143 = __builtin_constant_p((int )(buffer));
#line 848
                        if (tmp___143) {
#line 848
                          if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                              1U) {
#line 848
                            tmp___115 = __builtin_strcmp(buffer, "From ");
                          } else {
                            goto _L___33;
                          }
                        } else {
                          _L___33: 
#line 848
                          __s1___30 = (unsigned char const   *)((char const   *)(buffer));
#line 848
                          __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                                 (int const   )(*((unsigned char const   *)"From " +
                                                                  0)));
#line 848
                          if (__s2_len___0 > 0U) {
#line 848
                            if (__result___46 == 0) {
#line 848
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      1)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                             1)));
#line 848
                              if (__s2_len___0 > 1U) {
#line 848
                                if (__result___46 == 0) {
#line 848
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          2)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                                 2)));
#line 848
                                  if (__s2_len___0 > 2U) {
#line 848
                                    if (__result___46 == 0) {
#line 848
                                      __result___46 = (int )((int const   )(*(__s1___30 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)"From " +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 848
                          tmp___115 = __result___46;
                        }
                      } else {
#line 848
                        tmp___115 = __builtin_strcmp(buffer, "From ");
                      }
                    } else {
#line 848
                      tmp___115 = __builtin_strcmp(buffer, "From ");
                    }
                  } else {
#line 848
                    tmp___115 = __builtin_strcmp(buffer, "From ");
                  }
                }
              }
#line 848
              tmp___79 = tmp___115;
            } else {
#line 848
              tmp___79 = strncmp((char const   *)(buffer), "From ", 5U);
            }
          } else {
#line 848
            tmp___79 = strncmp((char const   *)(buffer), "From ", 5U);
          }
        }
#line 848
        if (tmp___79 == 0) {
#line 849
          tmp___2 = messagenumber;
#line 849
          messagenumber ++;
#line 849
          cli_dbgmsg("Deal with email number %d\n", tmp___2);
#line 853
          body___0 = parseEmailHeaders((message const   *)m, (table_t const   *)rfc821);
#line 854
          if ((unsigned int )body___0 == (unsigned int )((void *)0)) {
#line 855
            messageReset(m);
            goto __Cont;
          }
#line 858
          messageDestroy(m);
#line 859
          tmp___4 = messageGetBody((message const   *)body___0);
#line 859
          if (tmp___4) {
#line 860
            tmp___3 = parseEmailBody(body___0, (text *)((void *)0), dir, (table_t const   *)rfc821,
                                     (table_t const   *)subtype, options);
#line 860
            if (! tmp___3) {
#line 861
              messageReset(body___0);
#line 862
              m = body___0;
              goto __Cont;
            }
          }
#line 873
          m = body___0;
#line 874
          messageReset(body___0);
#line 876
          cli_dbgmsg("Finished processing message\n");
        } else {
#line 878
          lastLineWasEmpty = (enum __anonenum_bool_35 )((int )buffer[0] == 0);
        }
      } else {
#line 878
        lastLineWasEmpty = (enum __anonenum_bool_35 )((int )buffer[0] == 0);
      }
#line 880
      tmp___154 = isuuencodebegin((char const   *)(buffer));
#line 880
      if (tmp___154) {
#line 885
        uufasttrack(m, (char const   *)(buffer), dir, fd);
      } else {
#line 887
        tmp___153 = messageAddStr(m, (char const   *)(buffer));
#line 887
        if (tmp___153 < 0) {
#line 888
          break;
        }
      }
      __Cont: 
#line 846
      tmp___155 = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U),
                        (FILE * __restrict  )fd);
#line 846
      if (! ((unsigned int )tmp___155 != (unsigned int )((void *)0))) {
#line 846
        break;
      }
    }
#line 891
    fclose(fd);
#line 893
    cli_dbgmsg("Extract attachments from email %d\n", messagenumber);
#line 894
    body___0 = parseEmailHeaders((message const   *)m, (table_t const   *)rfc821);
#line 895
    messageDestroy(m);
  } else {
#line 900
    tmp___309 = __builtin_constant_p((int )(buffer));
#line 900
    if (tmp___309) {
#line 900
      tmp___310 = strlen((char const   *)(buffer));
#line 900
      if (tmp___310 < 4U) {
        goto _L___81;
      } else {
        goto _L___82;
      }
    } else {
      _L___82: 
#line 900
      tmp___311 = __builtin_constant_p((int )"P I ");
#line 900
      if (tmp___311) {
#line 900
        tmp___312 = strlen("P I ");
#line 900
        if (tmp___312 < 4U) {
          _L___81: 
#line 900
          tmp___306 = __builtin_constant_p((int )(buffer));
#line 900
          if (tmp___306) {
#line 900
            tmp___307 = __builtin_constant_p((int )"P I ");
#line 900
            if (tmp___307) {
#line 900
              __s1_len___2 = strlen((char const   *)(buffer));
#line 900
              __s2_len___2 = strlen("P I ");
#line 900
              if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                     1U)) {
                goto _L___78;
              } else {
#line 900
                if (__s1_len___2 >= 4U) {
                  _L___78: 
#line 900
                  if (! ((unsigned int )((void const   *)("P I " + 1)) - (unsigned int )((void const   *)"P I ") ==
                         1U)) {
#line 900
                    tmp___308 = 1;
                  } else {
#line 900
                    if (__s2_len___2 >= 4U) {
#line 900
                      tmp___308 = 1;
                    } else {
#line 900
                      tmp___308 = 0;
                    }
                  }
                } else {
#line 900
                  tmp___308 = 0;
                }
              }
#line 900
              if (tmp___308) {
#line 900
                tmp___275 = __builtin_strcmp(buffer, "P I ");
              } else {
                goto _L___80;
              }
            } else {
              goto _L___80;
            }
          } else {
            _L___80: 
#line 900
            tmp___305 = __builtin_constant_p((int )(buffer));
#line 900
            if (tmp___305) {
#line 900
              if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                  1U) {
#line 900
                __s1_len___2 = strlen((char const   *)(buffer));
#line 900
                if (__s1_len___2 < 4U) {
#line 900
                  tmp___294 = __builtin_constant_p((int )"P I ");
#line 900
                  if (tmp___294) {
#line 900
                    if ((unsigned int )((void const   *)("P I " + 1)) - (unsigned int )((void const   *)"P I ") ==
                        1U) {
#line 900
                      tmp___275 = __builtin_strcmp(buffer, "P I ");
                    } else {
                      goto _L___73;
                    }
                  } else {
                    _L___73: 
#line 900
                    __s2___30 = (unsigned char const   *)"P I ";
#line 900
                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                            0)) - (int const   )(*(__s2___30 +
                                                                                   0)));
#line 900
                    if (__s1_len___2 > 0U) {
#line 900
                      if (__result___90 == 0) {
#line 900
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                1)) - (int const   )(*(__s2___30 +
                                                                                       1)));
#line 900
                        if (__s1_len___2 > 1U) {
#line 900
                          if (__result___90 == 0) {
#line 900
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                    2)) - (int const   )(*(__s2___30 +
                                                                                           2)));
#line 900
                            if (__s1_len___2 > 2U) {
#line 900
                              if (__result___90 == 0) {
#line 900
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(buffer)) +
                                                                        3)) - (int const   )(*(__s2___30 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 900
                    tmp___275 = __result___90;
                  }
                } else {
                  goto _L___77;
                }
              } else {
                goto _L___77;
              }
            } else {
              _L___77: 
#line 900
              tmp___304 = __builtin_constant_p((int )"P I ");
#line 900
              if (tmp___304) {
#line 900
                if ((unsigned int )((void const   *)("P I " + 1)) - (unsigned int )((void const   *)"P I ") ==
                    1U) {
#line 900
                  __s2_len___2 = strlen("P I ");
#line 900
                  if (__s2_len___2 < 4U) {
#line 900
                    tmp___303 = __builtin_constant_p((int )(buffer));
#line 900
                    if (tmp___303) {
#line 900
                      if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)(buffer)) ==
                          1U) {
#line 900
                        tmp___275 = __builtin_strcmp(buffer, "P I ");
                      } else {
                        goto _L___75;
                      }
                    } else {
                      _L___75: 
#line 900
                      __s1___62 = (unsigned char const   *)((char const   *)(buffer));
#line 900
                      __result___94 = (int )((int const   )(*(__s1___62 + 0)) - (int const   )(*((unsigned char const   *)"P I " +
                                                                                                 0)));
#line 900
                      if (__s2_len___2 > 0U) {
#line 900
                        if (__result___94 == 0) {
#line 900
                          __result___94 = (int )((int const   )(*(__s1___62 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"P I " +
                                                                  1)));
#line 900
                          if (__s2_len___2 > 1U) {
#line 900
                            if (__result___94 == 0) {
#line 900
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"P I " +
                                                                                             2)));
#line 900
                              if (__s2_len___2 > 2U) {
#line 900
                                if (__result___94 == 0) {
#line 900
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"P I " +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 900
                      tmp___275 = __result___94;
                    }
                  } else {
#line 900
                    tmp___275 = __builtin_strcmp(buffer, "P I ");
                  }
                } else {
#line 900
                  tmp___275 = __builtin_strcmp(buffer, "P I ");
                }
              } else {
#line 900
                tmp___275 = __builtin_strcmp(buffer, "P I ");
              }
            }
          }
#line 900
          tmp___239 = tmp___275;
        } else {
#line 900
          tmp___239 = strncmp((char const   *)(buffer), "P I ", 4U);
        }
      } else {
#line 900
        tmp___239 = strncmp((char const   *)(buffer), "P I ", 4U);
      }
    }
#line 900
    if (tmp___239 == 0) {
#line 905
      while (1) {
#line 905
        tmp___156 = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U),
                          (FILE * __restrict  )fd);
#line 905
        if ((unsigned int )tmp___156 != (unsigned int )((void *)0)) {
#line 905
          tmp___163 = __builtin_constant_p((int )buffer[0]);
#line 905
          if (tmp___163) {
#line 905
            tmp___164 = __builtin_constant_p((int )"\r\n");
#line 905
            if (tmp___164) {
#line 905
              tmp___161 = (char *)__builtin_strchr("\r\n", buffer[0]);
            } else {
#line 905
              if ((int )buffer[0] == 0) {
#line 905
                tmp___161 = (char *)__rawmemchr((void const   *)"\r\n", (int )buffer[0]);
              } else {
#line 905
                tmp___161 = (char *)__builtin_strchr("\r\n", buffer[0]);
              }
            }
          } else {
#line 905
            tmp___161 = (char *)__builtin_strchr("\r\n", buffer[0]);
          }
#line 905
          if (! ((unsigned int )tmp___161 == (unsigned int )((void *)0))) {
#line 905
            break;
          }
        } else {
#line 905
          break;
        }
      }
    }
#line 911
    while (1) {
#line 911
      tmp___319 = __builtin_constant_p((int )buffer[0]);
#line 911
      if (tmp___319) {
#line 911
        tmp___320 = __builtin_constant_p((int )"\r\n");
#line 911
        if (tmp___320) {
#line 911
          tmp___317 = (char *)__builtin_strchr("\r\n", buffer[0]);
        } else {
#line 911
          if ((int )buffer[0] == 0) {
#line 911
            tmp___317 = (char *)__rawmemchr((void const   *)"\r\n", (int )buffer[0]);
          } else {
#line 911
            tmp___317 = (char *)__builtin_strchr("\r\n", buffer[0]);
          }
        }
      } else {
#line 911
        tmp___317 = (char *)__builtin_strchr("\r\n", buffer[0]);
      }
#line 911
      if (tmp___317) {
#line 911
        tmp___321 = getline(buffer, sizeof(buffer) - 1U, fd);
#line 911
        if (! ((unsigned int )tmp___321 != (unsigned int )((void *)0))) {
#line 911
          break;
        }
      } else {
#line 911
        break;
      }
    }
#line 915
    buffer[sizeof(buffer) - 1U] = (char )'\000';
#line 917
    body___0 = parseEmailFile(fd, (table_t const   *)rfc821, (char const   *)(buffer),
                              dir);
#line 918
    fclose(fd);
  }
#line 926
  retcode = 0;
#line 928
  if (body___0) {
#line 932
    tmp___471 = messageGetBody((message const   *)body___0);
#line 932
    if (tmp___471) {
#line 933
      tmp___470 = parseEmailBody(body___0, (text *)((void *)0), dir, (table_t const   *)rfc821,
                                 (table_t const   *)subtype, options);
#line 933
      if (! tmp___470) {
#line 934
        retcode = -13;
      }
    }
#line 939
    messageDestroy(body___0);
  }
#line 942
  cli_dbgmsg("cli_mbox returning %d\n", retcode);
#line 951
  return (retcode);
}
}
#line 960 "mbox.c"
static message *parseEmailFile(FILE *fin , table_t const   *rfc821___0 , char const   *firstLine ,
                               char const   *dir ) 
{ bool inHeader ;
  bool contMarker ;
  bool lastWasBlank ;
  message *ret ;
  bool anyHeadersFound ;
  int commandNumber ;
  char *fullline ;
  char *boundary ;
  size_t fulllinelength ;
  char buffer[1001] ;
  char *line ;
  int tmp ;
  char const   *tmp___0 ;
  char copy[(int )sizeof(buffer)] ;
  int tmp___1 ;
  unsigned short const   **tmp___3 ;
  char *ptr ;
  char const   *qptr ;
  int lookahead ;
  char cmd[1001] ;
  char out[1001] ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___114 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___133 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  char *tmp___155 ;
  int tmp___157 ;
  char *tmp___158 ;
  char *tmp___159 ;
  size_t __len___2 ;
  size_t tmp___176 ;
  char *__retval___2 ;
  char *tmp___177 ;
  int tmp___179 ;
  size_t tmp___180 ;
  size_t tmp___181 ;
  int quotes ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  char *tmp___185 ;

  {
#line 963
  inHeader = (enum __anonenum_bool_35 )1;
#line 964
  contMarker = (enum __anonenum_bool_35 )0;
#line 965
  lastWasBlank = (enum __anonenum_bool_35 )0;
#line 967
  anyHeadersFound = (enum __anonenum_bool_35 )0;
#line 968
  commandNumber = -1;
#line 969
  fullline = (char *)((void *)0);
#line 969
  boundary = (char *)((void *)0);
#line 970
  fulllinelength = 0U;
#line 973
  cli_dbgmsg("parseEmailFile\n");
#line 975
  ret = messageCreate();
#line 976
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 977
    return ((message *)((void *)0));
  }
#line 979
  strcpy((char * __restrict  )(buffer), (char const   * __restrict  )firstLine);
#line 980
  while (1) {
#line 983
    cli_chomp(buffer);
#line 985
    line = buffer;
#line 987
    if ((int )(*(line + 0)) == 0) {
#line 988
      line = (char *)((void *)0);
    }
#line 994
    if (lastWasBlank) {
#line 995
      lastWasBlank = (enum __anonenum_bool_35 )0;
#line 996
      tmp = boundaryStart((char const   *)(buffer), (char const   *)boundary);
#line 996
      if (tmp) {
#line 997
        cli_dbgmsg("Found a header line with space that should be blank\n");
#line 998
        inHeader = (enum __anonenum_bool_35 )0;
      }
    }
#line 1001
    if (boundary) {
#line 1002
      free((void *)boundary);
#line 1003
      boundary = (char *)((void *)0);
    }
#line 1005
    if (inHeader) {
#line 1006
      if (buffer) {
#line 1006
        tmp___0 = (char const   *)(buffer);
      } else {
#line 1006
        tmp___0 = "";
      }
#line 1006
      cli_dbgmsg("parseEmailFile: check \'%s\' contMarker %d fullline 0x%p\n", tmp___0,
                 (int )contMarker, fullline);
#line 1008
      if (line) {
#line 1008
        tmp___3 = __ctype_b_loc();
#line 1008
        if ((int const   )(*((*tmp___3) + (int )(*(line + 0)))) & 8192) {
#line 1011
          strcpy((char * __restrict  )(copy), (char const   * __restrict  )(buffer));
#line 1012
          strstrip(copy);
#line 1013
          if ((int )copy[0] == 0) {
#line 1027
            if (fullline) {
#line 1028
              tmp___1 = parseEmailHeader(ret, (char const   *)fullline, rfc821___0);
#line 1028
              if (tmp___1 < 0) {
                goto __Cont;
              }
#line 1031
              free((void *)fullline);
#line 1032
              fullline = (char *)((void *)0);
            }
#line 1034
            boundary = messageFindArgument((message const   *)ret, "boundary");
#line 1034
            if ((unsigned int )boundary != (unsigned int )((void *)0)) {
#line 1035
              lastWasBlank = (enum __anonenum_bool_35 )1;
              goto __Cont;
            }
          }
        }
      }
#line 1040
      lastWasBlank = (enum __anonenum_bool_35 )0;
#line 1041
      if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1041
        if ((unsigned int )fullline == (unsigned int )((void *)0)) {
#line 1042
          if (! contMarker) {
#line 1047
            if (! anyHeadersFound) {
              goto __Cont;
            }
#line 1051
            cli_dbgmsg("End of header information\n");
#line 1052
            inHeader = (enum __anonenum_bool_35 )0;
          } else {
#line 1054
            contMarker = (enum __anonenum_bool_35 )0;
          }
        } else {
          goto _L___42;
        }
      } else {
        _L___42: 
#line 1060
        if ((unsigned int )fullline == (unsigned int )((void *)0)) {
#line 1066
          if ((int )(*(line + 0)) == 9) {
#line 1067
            contMarker = continuationMarker((char const   *)line);
            goto __Cont;
          } else {
#line 1066
            if ((int )(*(line + 0)) == 32) {
#line 1067
              contMarker = continuationMarker((char const   *)line);
              goto __Cont;
            } else {
#line 1066
              if (contMarker) {
#line 1067
                contMarker = continuationMarker((char const   *)line);
                goto __Cont;
              }
            }
          }
#line 1074
          tmp___157 = __builtin_constant_p((int )line);
#line 1074
          if (tmp___157) {
#line 1074
            tmp___155 = (char *)__builtin_strchr(line, ':');
          } else {
#line 1074
            tmp___155 = (char *)__builtin_strchr(line, ':');
          }
#line 1074
          if ((unsigned int )tmp___155 == (unsigned int )((void *)0)) {
            goto _L___41;
          } else {
#line 1074
            tmp___158 = cli_strtokbuf((char const   *)line, 0, ":", cmd);
#line 1074
            if ((unsigned int )tmp___158 == (unsigned int )((void *)0)) {
              _L___41: 
#line 1076
              tmp___148 = __builtin_constant_p((int )line);
#line 1076
              if (tmp___148) {
#line 1076
                tmp___149 = strlen((char const   *)line);
#line 1076
                if (tmp___149 < 5U) {
                  goto _L___39;
                } else {
                  goto _L___40;
                }
              } else {
                _L___40: 
#line 1076
                tmp___150 = __builtin_constant_p((int )"From ");
#line 1076
                if (tmp___150) {
#line 1076
                  tmp___151 = strlen("From ");
#line 1076
                  if (tmp___151 < 5U) {
                    _L___39: 
#line 1076
                    tmp___145 = __builtin_constant_p((int )line);
#line 1076
                    if (tmp___145) {
#line 1076
                      tmp___146 = __builtin_constant_p((int )"From ");
#line 1076
                      if (tmp___146) {
#line 1076
                        __s1_len___0 = strlen((char const   *)line);
#line 1076
                        __s2_len___0 = strlen("From ");
#line 1076
                        if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                               1U)) {
                          goto _L___36;
                        } else {
#line 1076
                          if (__s1_len___0 >= 4U) {
                            _L___36: 
#line 1076
                            if (! ((unsigned int )((void const   *)("From " + 1)) -
                                   (unsigned int )((void const   *)"From ") == 1U)) {
#line 1076
                              tmp___147 = 1;
                            } else {
#line 1076
                              if (__s2_len___0 >= 4U) {
#line 1076
                                tmp___147 = 1;
                              } else {
#line 1076
                                tmp___147 = 0;
                              }
                            }
                          } else {
#line 1076
                            tmp___147 = 0;
                          }
                        }
#line 1076
                        if (tmp___147) {
#line 1076
                          tmp___114 = __builtin_strcmp(line, "From ");
                        } else {
                          goto _L___38;
                        }
                      } else {
                        goto _L___38;
                      }
                    } else {
                      _L___38: 
#line 1076
                      tmp___144 = __builtin_constant_p((int )line);
#line 1076
                      if (tmp___144) {
#line 1076
                        if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                            1U) {
#line 1076
                          __s1_len___0 = strlen((char const   *)line);
#line 1076
                          if (__s1_len___0 < 4U) {
#line 1076
                            tmp___133 = __builtin_constant_p((int )"From ");
#line 1076
                            if (tmp___133) {
#line 1076
                              if ((unsigned int )((void const   *)("From " + 1)) -
                                  (unsigned int )((void const   *)"From ") == 1U) {
#line 1076
                                tmp___114 = __builtin_strcmp(line, "From ");
                              } else {
                                goto _L___31;
                              }
                            } else {
                              _L___31: 
#line 1076
                              __s2___14 = (unsigned char const   *)"From ";
#line 1076
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
#line 1076
                              if (__s1_len___0 > 0U) {
#line 1076
                                if (__result___42 == 0) {
#line 1076
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
#line 1076
                                  if (__s1_len___0 > 1U) {
#line 1076
                                    if (__result___42 == 0) {
#line 1076
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
#line 1076
                                      if (__s1_len___0 > 2U) {
#line 1076
                                        if (__result___42 == 0) {
#line 1076
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)line) +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
#line 1076
                              tmp___114 = __result___42;
                            }
                          } else {
                            goto _L___35;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
#line 1076
                        tmp___143 = __builtin_constant_p((int )"From ");
#line 1076
                        if (tmp___143) {
#line 1076
                          if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                              1U) {
#line 1076
                            __s2_len___0 = strlen("From ");
#line 1076
                            if (__s2_len___0 < 4U) {
#line 1076
                              tmp___142 = __builtin_constant_p((int )line);
#line 1076
                              if (tmp___142) {
#line 1076
                                if ((unsigned int )((void const   *)(line + 1)) -
                                    (unsigned int )((void const   *)line) == 1U) {
#line 1076
                                  tmp___114 = __builtin_strcmp(line, "From ");
                                } else {
                                  goto _L___33;
                                }
                              } else {
                                _L___33: 
#line 1076
                                __s1___30 = (unsigned char const   *)((char const   *)line);
#line 1076
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                               0)));
#line 1076
                                if (__s2_len___0 > 0U) {
#line 1076
                                  if (__result___46 == 0) {
#line 1076
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)"From " +
                                                                            1)));
#line 1076
                                    if (__s2_len___0 > 1U) {
#line 1076
                                      if (__result___46 == 0) {
#line 1076
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)"From " +
                                                                                2)));
#line 1076
                                        if (__s2_len___0 > 2U) {
#line 1076
                                          if (__result___46 == 0) {
#line 1076
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)"From " +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
#line 1076
                                tmp___114 = __result___46;
                              }
                            } else {
#line 1076
                              tmp___114 = __builtin_strcmp(line, "From ");
                            }
                          } else {
#line 1076
                            tmp___114 = __builtin_strcmp(line, "From ");
                          }
                        } else {
#line 1076
                          tmp___114 = __builtin_strcmp(line, "From ");
                        }
                      }
                    }
#line 1076
                    tmp___78 = tmp___114;
                  } else {
#line 1076
                    tmp___78 = strncmp((char const   *)line, "From ", 5U);
                  }
                } else {
#line 1076
                  tmp___78 = strncmp((char const   *)line, "From ", 5U);
                }
              }
#line 1076
              if (tmp___78 == 0) {
#line 1077
                anyHeadersFound = (enum __anonenum_bool_35 )1;
              }
              goto __Cont;
            }
          }
#line 1081
          ptr = rfc822comments((char const   *)(cmd), out);
#line 1082
          if (ptr) {
#line 1082
            tmp___159 = ptr;
          } else {
#line 1082
            tmp___159 = cmd;
          }
#line 1082
          commandNumber = tableFind(rfc821___0, (char const   *)tmp___159);
#line 1084
          switch (commandNumber) {
          case 2: ;
          case 3: ;
          case 1: 
#line 1088
          anyHeadersFound = (enum __anonenum_bool_35 )1;
#line 1089
          break;
          default: ;
#line 1091
          if (! anyHeadersFound) {
#line 1092
            anyHeadersFound = usefulHeader(commandNumber, (char const   *)(cmd));
          }
          goto __Cont;
          }
#line 1095
          tmp___179 = __builtin_constant_p((int )line);
#line 1095
          if (tmp___179) {
#line 1095
            if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                1U) {
#line 1095
              if ((int const   )(*((char const   *)line + 0)) == 0) {
#line 1095
                fullline = (char *)calloc(1U, 1U);
              } else {
#line 1095
                tmp___176 = strlen((char const   *)line);
#line 1095
                __len___2 = tmp___176 + 1U;
#line 1095
                tmp___177 = (char *)malloc(__len___2);
#line 1095
                __retval___2 = tmp___177;
#line 1095
                if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1095
                  __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                (void const   * __restrict  )line,
                                                __len___2);
                }
#line 1095
                fullline = __retval___2;
              }
            } else {
#line 1095
              fullline = __strdup((char const   *)line);
            }
          } else {
#line 1095
            fullline = __strdup((char const   *)line);
          }
#line 1096
          tmp___180 = strlen((char const   *)line);
#line 1096
          fulllinelength = tmp___180 + 1U;
        } else {
#line 1097
          if ((unsigned int )line != (unsigned int )((void *)0)) {
#line 1098
            tmp___181 = strlen((char const   *)line);
#line 1098
            fulllinelength += tmp___181;
#line 1099
            fullline = (char *)cli_realloc((void *)fullline, fulllinelength);
#line 1100
            strcat((char * __restrict  )fullline, (char const   * __restrict  )line);
          }
        }
#line 1103
        if (line) {
#line 1104
          contMarker = continuationMarker((char const   *)line);
#line 1106
          if (contMarker) {
            goto __Cont;
          }
        } else {
#line 1109
          contMarker = (enum __anonenum_bool_35 )0;
        }
#line 1113
        lookahead = _IO_getc(fin);
#line 1114
        if (lookahead != -1) {
#line 1115
          ungetc(lookahead, fin);
#line 1124
          if (lookahead == 9) {
            goto __Cont;
          } else {
#line 1124
            if (lookahead == 32) {
              goto __Cont;
            }
          }
        }
#line 1128
        if (line) {
#line 1129
          quotes = 0;
#line 1130
          qptr = (char const   *)fullline;
#line 1130
          while ((*qptr)) {
#line 1131
            if ((int const   )(*qptr) == 34) {
#line 1132
              quotes ++;
            }
#line 1130
            qptr ++;
          }
#line 1134
          if (quotes & 1) {
            goto __Cont;
          }
        }
#line 1138
        ptr = rfc822comments((char const   *)fullline, (char *)((void *)0));
#line 1139
        if (ptr) {
#line 1140
          free((void *)fullline);
#line 1141
          fullline = ptr;
        }
#line 1144
        tmp___182 = parseEmailHeader(ret, (char const   *)fullline, rfc821___0);
#line 1144
        if (tmp___182 < 0) {
          goto __Cont;
        }
#line 1147
        free((void *)fullline);
#line 1148
        fullline = (char *)((void *)0);
      }
    } else {
#line 1150
      if (line) {
#line 1150
        tmp___184 = isuuencodebegin((char const   *)line);
#line 1150
        if (tmp___184) {
#line 1155
          uufasttrack(ret, (char const   *)line, dir, fin);
        } else {
          goto _L___43;
        }
      } else {
        _L___43: 
#line 1157
        tmp___183 = messageAddStr(ret, (char const   *)line);
#line 1157
        if (tmp___183 < 0) {
#line 1158
          break;
        }
      }
    }
    __Cont: 
#line 980
    tmp___185 = getline(buffer, sizeof(buffer) - 1U, fin);
#line 980
    if (! ((unsigned int )tmp___185 != (unsigned int )((void *)0))) {
#line 980
      break;
    }
  }
#line 1161
  if (fullline) {
#line 1162
    if ((*fullline)) {
#line 1162
      switch (commandNumber) {
      case 2: ;
      case 3: ;
      case 1: 
#line 1166
      cli_dbgmsg("parseEmailHeaders: Fullline unparsed \'%s\'\n", fullline);
      }
    }
#line 1168
    free((void *)fullline);
  }
#line 1171
  if (! anyHeadersFound) {
#line 1175
    messageDestroy(ret);
#line 1176
    cli_dbgmsg("parseEmailFile: no headers found, assuming it isn\'t an email\n");
#line 1177
    return ((message *)((void *)0));
  }
#line 1180
  messageClean(ret);
#line 1182
  cli_dbgmsg("parseEmailFile: return\n");
#line 1184
  return (ret);
}
}
#line 1199 "mbox.c"
static message *parseEmailHeaders(message const   *m , table_t const   *rfc821___0 ) 
{ bool inHeader ;
  text const   *t ;
  message *ret ;
  bool anyHeadersFound ;
  int commandNumber ;
  char *fullline ;
  size_t fulllinelength ;
  char const   *buffer ;
  char const   *tmp ;
  char *ptr ;
  char const   *qptr ;
  int quotes ;
  char cmd[1001] ;
  int tmp___74 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___110 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___129 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  char *tmp___151 ;
  int tmp___153 ;
  char *tmp___154 ;
  char *tmp___155 ;
  size_t __len___2 ;
  size_t tmp___172 ;
  char *__retval___2 ;
  char *tmp___173 ;
  int tmp___175 ;
  size_t tmp___176 ;
  size_t tmp___177 ;
  char const   *tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;

  {
#line 1202
  inHeader = (enum __anonenum_bool_35 )1;
#line 1205
  anyHeadersFound = (enum __anonenum_bool_35 )0;
#line 1206
  commandNumber = -1;
#line 1207
  fullline = (char *)((void *)0);
#line 1208
  fulllinelength = 0U;
#line 1210
  cli_dbgmsg("parseEmailHeaders\n");
#line 1212
  if ((unsigned int )m == (unsigned int )((void *)0)) {
#line 1213
    return ((message *)((void *)0));
  }
#line 1215
  ret = messageCreate();
#line 1217
  t = messageGetBody(m);
#line 1217
  while (t) {
#line 1220
    if (t->t_line) {
#line 1221
      buffer = lineGetData((line_t const   *)t->t_line);
    } else {
#line 1223
      buffer = (char const   *)((void *)0);
    }
#line 1225
    if (inHeader) {
#line 1226
      if (buffer) {
#line 1226
        tmp = buffer;
      } else {
#line 1226
        tmp = "";
      }
#line 1226
      cli_dbgmsg("parseEmailHeaders: check \'%s\'\n", tmp);
#line 1228
      if ((unsigned int )buffer == (unsigned int )((void *)0)) {
#line 1233
        cli_dbgmsg("End of header information\n");
#line 1234
        inHeader = (enum __anonenum_bool_35 )0;
#line 1235
        if (! anyHeadersFound) {
#line 1236
          cli_dbgmsg("Nothing interesting in the header\n");
#line 1237
          break;
        }
      } else {
#line 1244
        if ((unsigned int )fullline == (unsigned int )((void *)0)) {
#line 1250
          if ((int const   )(*(buffer + 0)) == 9) {
            goto __Cont;
          } else {
#line 1250
            if ((int const   )(*(buffer + 0)) == 32) {
              goto __Cont;
            }
          }
#line 1256
          tmp___153 = __builtin_constant_p((int )buffer);
#line 1256
          if (tmp___153) {
#line 1256
            tmp___151 = (char *)__builtin_strchr(buffer, ':');
          } else {
#line 1256
            tmp___151 = (char *)__builtin_strchr(buffer, ':');
          }
#line 1256
          if ((unsigned int )tmp___151 == (unsigned int )((void *)0)) {
            goto _L___41;
          } else {
#line 1256
            tmp___154 = cli_strtokbuf(buffer, 0, ":", cmd);
#line 1256
            if ((unsigned int )tmp___154 == (unsigned int )((void *)0)) {
              _L___41: 
#line 1258
              tmp___144 = __builtin_constant_p((int )buffer);
#line 1258
              if (tmp___144) {
#line 1258
                tmp___145 = strlen(buffer);
#line 1258
                if (tmp___145 < 5U) {
                  goto _L___39;
                } else {
                  goto _L___40;
                }
              } else {
                _L___40: 
#line 1258
                tmp___146 = __builtin_constant_p((int )"From ");
#line 1258
                if (tmp___146) {
#line 1258
                  tmp___147 = strlen("From ");
#line 1258
                  if (tmp___147 < 5U) {
                    _L___39: 
#line 1258
                    tmp___141 = __builtin_constant_p((int )buffer);
#line 1258
                    if (tmp___141) {
#line 1258
                      tmp___142 = __builtin_constant_p((int )"From ");
#line 1258
                      if (tmp___142) {
#line 1258
                        __s1_len___0 = strlen(buffer);
#line 1258
                        __s2_len___0 = strlen("From ");
#line 1258
                        if (! ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)buffer) ==
                               1U)) {
                          goto _L___36;
                        } else {
#line 1258
                          if (__s1_len___0 >= 4U) {
                            _L___36: 
#line 1258
                            if (! ((unsigned int )((void const   *)("From " + 1)) -
                                   (unsigned int )((void const   *)"From ") == 1U)) {
#line 1258
                              tmp___143 = 1;
                            } else {
#line 1258
                              if (__s2_len___0 >= 4U) {
#line 1258
                                tmp___143 = 1;
                              } else {
#line 1258
                                tmp___143 = 0;
                              }
                            }
                          } else {
#line 1258
                            tmp___143 = 0;
                          }
                        }
#line 1258
                        if (tmp___143) {
#line 1258
                          tmp___110 = __builtin_strcmp(buffer, "From ");
                        } else {
                          goto _L___38;
                        }
                      } else {
                        goto _L___38;
                      }
                    } else {
                      _L___38: 
#line 1258
                      tmp___140 = __builtin_constant_p((int )buffer);
#line 1258
                      if (tmp___140) {
#line 1258
                        if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)buffer) ==
                            1U) {
#line 1258
                          __s1_len___0 = strlen(buffer);
#line 1258
                          if (__s1_len___0 < 4U) {
#line 1258
                            tmp___129 = __builtin_constant_p((int )"From ");
#line 1258
                            if (tmp___129) {
#line 1258
                              if ((unsigned int )((void const   *)("From " + 1)) -
                                  (unsigned int )((void const   *)"From ") == 1U) {
#line 1258
                                tmp___110 = __builtin_strcmp(buffer, "From ");
                              } else {
                                goto _L___31;
                              }
                            } else {
                              _L___31: 
#line 1258
                              __s2___14 = (unsigned char const   *)"From ";
#line 1258
                              __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
#line 1258
                              if (__s1_len___0 > 0U) {
#line 1258
                                if (__result___42 == 0) {
#line 1258
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
#line 1258
                                  if (__s1_len___0 > 1U) {
#line 1258
                                    if (__result___42 == 0) {
#line 1258
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
#line 1258
                                      if (__s1_len___0 > 2U) {
#line 1258
                                        if (__result___42 == 0) {
#line 1258
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)buffer +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
#line 1258
                              tmp___110 = __result___42;
                            }
                          } else {
                            goto _L___35;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
#line 1258
                        tmp___139 = __builtin_constant_p((int )"From ");
#line 1258
                        if (tmp___139) {
#line 1258
                          if ((unsigned int )((void const   *)("From " + 1)) - (unsigned int )((void const   *)"From ") ==
                              1U) {
#line 1258
                            __s2_len___0 = strlen("From ");
#line 1258
                            if (__s2_len___0 < 4U) {
#line 1258
                              tmp___138 = __builtin_constant_p((int )buffer);
#line 1258
                              if (tmp___138) {
#line 1258
                                if ((unsigned int )((void const   *)(buffer + 1)) -
                                    (unsigned int )((void const   *)buffer) == 1U) {
#line 1258
                                  tmp___110 = __builtin_strcmp(buffer, "From ");
                                } else {
                                  goto _L___33;
                                }
                              } else {
                                _L___33: 
#line 1258
                                __s1___30 = (unsigned char const   *)buffer;
#line 1258
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)"From " +
                                                                                               0)));
#line 1258
                                if (__s2_len___0 > 0U) {
#line 1258
                                  if (__result___46 == 0) {
#line 1258
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)"From " +
                                                                            1)));
#line 1258
                                    if (__s2_len___0 > 1U) {
#line 1258
                                      if (__result___46 == 0) {
#line 1258
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)"From " +
                                                                                2)));
#line 1258
                                        if (__s2_len___0 > 2U) {
#line 1258
                                          if (__result___46 == 0) {
#line 1258
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)"From " +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
#line 1258
                                tmp___110 = __result___46;
                              }
                            } else {
#line 1258
                              tmp___110 = __builtin_strcmp(buffer, "From ");
                            }
                          } else {
#line 1258
                            tmp___110 = __builtin_strcmp(buffer, "From ");
                          }
                        } else {
#line 1258
                          tmp___110 = __builtin_strcmp(buffer, "From ");
                        }
                      }
                    }
#line 1258
                    tmp___74 = tmp___110;
                  } else {
#line 1258
                    tmp___74 = strncmp(buffer, "From ", 5U);
                  }
                } else {
#line 1258
                  tmp___74 = strncmp(buffer, "From ", 5U);
                }
              }
#line 1258
              if (tmp___74 == 0) {
#line 1259
                anyHeadersFound = (enum __anonenum_bool_35 )1;
              }
              goto __Cont;
            }
          }
#line 1263
          ptr = rfc822comments((char const   *)(cmd), (char *)((void *)0));
#line 1264
          if (ptr) {
#line 1264
            tmp___155 = ptr;
          } else {
#line 1264
            tmp___155 = cmd;
          }
#line 1264
          commandNumber = tableFind(rfc821___0, (char const   *)tmp___155);
#line 1265
          if (ptr) {
#line 1266
            free((void *)ptr);
          }
#line 1268
          switch (commandNumber) {
          case 2: ;
          case 3: ;
          case 1: 
#line 1272
          anyHeadersFound = (enum __anonenum_bool_35 )1;
#line 1273
          break;
          default: ;
#line 1275
          if (! anyHeadersFound) {
#line 1276
            anyHeadersFound = usefulHeader(commandNumber, (char const   *)(cmd));
          }
          goto __Cont;
          }
#line 1279
          tmp___175 = __builtin_constant_p((int )buffer);
#line 1279
          if (tmp___175) {
#line 1279
            if ((unsigned int )((void const   *)(buffer + 1)) - (unsigned int )((void const   *)buffer) ==
                1U) {
#line 1279
              if ((int const   )(*(buffer + 0)) == 0) {
#line 1279
                fullline = (char *)calloc(1U, 1U);
              } else {
#line 1279
                tmp___172 = strlen(buffer);
#line 1279
                __len___2 = tmp___172 + 1U;
#line 1279
                tmp___173 = (char *)malloc(__len___2);
#line 1279
                __retval___2 = tmp___173;
#line 1279
                if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1279
                  __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                (void const   * __restrict  )buffer,
                                                __len___2);
                }
#line 1279
                fullline = __retval___2;
              }
            } else {
#line 1279
              fullline = __strdup(buffer);
            }
          } else {
#line 1279
            fullline = __strdup(buffer);
          }
#line 1280
          tmp___176 = strlen(buffer);
#line 1280
          fulllinelength = tmp___176 + 1U;
        } else {
#line 1281
          if (buffer) {
#line 1282
            tmp___177 = strlen(buffer);
#line 1282
            fulllinelength += tmp___177;
#line 1283
            fullline = (char *)cli_realloc((void *)fullline, fulllinelength);
#line 1284
            strcat((char * __restrict  )fullline, (char const   * __restrict  )buffer);
          }
        }
#line 1289
        if (t->t_next) {
#line 1289
          if ((unsigned int )(t->t_next)->t_line != (unsigned int )((void *)0)) {
#line 1297
            tmp___178 = lineGetData((line_t const   *)(t->t_next)->t_line);
#line 1297
            switch ((int )(*(tmp___178 + 0))) {
            case 32: ;
            case 9: ;
            goto __Cont;
            }
          }
        }
#line 1303
        quotes = 0;
#line 1304
        qptr = (char const   *)fullline;
#line 1304
        while ((*qptr)) {
#line 1305
          if ((int const   )(*qptr) == 34) {
#line 1306
            quotes ++;
          }
#line 1304
          qptr ++;
        }
#line 1308
        if (quotes & 1) {
          goto __Cont;
        }
#line 1311
        ptr = rfc822comments((char const   *)fullline, (char *)((void *)0));
#line 1312
        if (ptr) {
#line 1313
          free((void *)fullline);
#line 1314
          fullline = ptr;
        }
#line 1317
        tmp___179 = parseEmailHeader(ret, (char const   *)fullline, rfc821___0);
#line 1317
        if (tmp___179 < 0) {
          goto __Cont;
        }
#line 1320
        free((void *)fullline);
#line 1321
        fullline = (char *)((void *)0);
      }
    } else {
#line 1325
      tmp___180 = messageAddLine(ret, t->t_line);
#line 1325
      if (tmp___180 < 0) {
#line 1326
        break;
      }
    }
    __Cont: 
#line 1217
    t = (text const   *)t->t_next;
  }
#line 1329
  if (fullline) {
#line 1330
    if ((*fullline)) {
#line 1330
      switch (commandNumber) {
      case 2: ;
      case 3: ;
      case 1: 
#line 1334
      cli_dbgmsg("parseEmailHeaders: Fullline unparsed \'%s\'\n", fullline);
      }
    }
#line 1336
    free((void *)fullline);
  }
#line 1339
  if (! anyHeadersFound) {
#line 1343
    messageDestroy(ret);
#line 1344
    cli_dbgmsg("parseEmailHeaders: no headers found, assuming it isn\'t an email\n");
#line 1345
    return ((message *)((void *)0));
  }
#line 1348
  messageClean(ret);
#line 1350
  cli_dbgmsg("parseEmailHeaders: return\n");
#line 1352
  return (ret);
}
}
#line 1358 "mbox.c"
static int parseEmailHeader(message *m , char const   *line , table_t const   *rfc821___0 ) 
{ char *cmd ;
  int ret ;
  char *strptr ;
  char const   *separater ;
  char *copy ;
  char tokenseparater[2] ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __len___2 ;
  size_t tmp___23 ;
  char *__retval___2 ;
  char *tmp___24 ;
  int tmp___26 ;
  int tmp___34 ;
  char *arg ;
  char *tmp___40 ;
  int tmp___43 ;
  size_t tmp___44 ;

  {
#line 1362
  ret = -1;
#line 1369
  cli_dbgmsg("parseEmailHeader \'%s\'\n", line);
#line 1377
  separater = ":= ";
#line 1377
  while ((*separater)) {
#line 1378
    tmp___5 = __builtin_constant_p((int )(*separater));
#line 1378
    if (tmp___5) {
#line 1378
      tmp___6 = __builtin_constant_p((int )line);
#line 1378
      if (tmp___6) {
#line 1378
        tmp___3 = (char *)__builtin_strchr(line, (*separater));
      } else {
#line 1378
        if ((int const   )(*separater) == 0) {
#line 1378
          tmp___3 = (char *)__rawmemchr((void const   *)line, (int )(*separater));
        } else {
#line 1378
          tmp___3 = (char *)__builtin_strchr(line, (*separater));
        }
      }
    } else {
#line 1378
      tmp___3 = (char *)__builtin_strchr(line, (*separater));
    }
#line 1378
    if ((unsigned int )tmp___3 != (unsigned int )((void *)0)) {
#line 1379
      break;
    }
#line 1377
    separater ++;
  }
#line 1381
  if ((int const   )(*separater) == 0) {
#line 1382
    return (-1);
  }
#line 1384
  copy = rfc2047(line);
#line 1385
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 1387
    tmp___26 = __builtin_constant_p((int )line);
#line 1387
    if (tmp___26) {
#line 1387
      if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
          1U) {
#line 1387
        if ((int const   )(*(line + 0)) == 0) {
#line 1387
          copy = (char *)calloc(1U, 1U);
        } else {
#line 1387
          tmp___23 = strlen(line);
#line 1387
          __len___2 = tmp___23 + 1U;
#line 1387
          tmp___24 = (char *)malloc(__len___2);
#line 1387
          __retval___2 = tmp___24;
#line 1387
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1387
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )line,
                                          __len___2);
          }
#line 1387
          copy = __retval___2;
        }
      } else {
#line 1387
        copy = __strdup(line);
      }
    } else {
#line 1387
      copy = __strdup(line);
    }
  }
#line 1389
  tokenseparater[0] = (char )(*separater);
#line 1390
  tokenseparater[1] = (char )'\000';
#line 1393
  tmp___34 = __builtin_constant_p((int )(tokenseparater));
#line 1393
  if (tmp___34) {
#line 1393
    if ((unsigned int )((void const   *)(tokenseparater + 1)) - (unsigned int )((void const   *)(tokenseparater)) ==
        1U) {
#line 1393
      if ((int const   )(*((char const   *)(tokenseparater) + 0)) != 0) {
#line 1393
        if ((int const   )(*((char const   *)(tokenseparater) + 1)) == 0) {
#line 1393
          cmd = __strtok_r_1c__extinline(copy, (char )(*((char const   *)(tokenseparater) +
                                                         0)), & strptr);
        } else {
#line 1393
          cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                           (char ** __restrict  )(& strptr));
        }
      } else {
#line 1393
        cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                         (char ** __restrict  )(& strptr));
      }
    } else {
#line 1393
      cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                       (char ** __restrict  )(& strptr));
    }
  } else {
#line 1393
    cmd = __strtok_r((char * __restrict  )copy, (char const   * __restrict  )(tokenseparater),
                     (char ** __restrict  )(& strptr));
  }
#line 1398
  if (cmd) {
#line 1398
    tmp___44 = strstrip(cmd);
#line 1398
    if (tmp___44 > 0U) {
#line 1400
      tmp___43 = __builtin_constant_p((int )"");
#line 1400
      if (tmp___43) {
#line 1400
        if ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
            1U) {
#line 1400
          if ((int const   )(*("" + 0)) != 0) {
#line 1400
            if ((int const   )(*("" + 1)) == 0) {
#line 1400
              tmp___40 = __strtok_r_1c__extinline((char *)((void *)0), (char )(*("" +
                                                                                 0)),
                                                  & strptr);
            } else {
#line 1400
              tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                                    (char ** __restrict  )(& strptr));
            }
          } else {
#line 1400
            tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                                  (char ** __restrict  )(& strptr));
          }
        } else {
#line 1400
          tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                                (char ** __restrict  )(& strptr));
        }
      } else {
#line 1400
        tmp___40 = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )"",
                              (char ** __restrict  )(& strptr));
      }
#line 1400
      arg = tmp___40;
#line 1405
      if (arg) {
#line 1413
        ret = parseMimeHeader(m, (char const   *)cmd, rfc821___0, (char const   *)arg);
      }
    }
  }
#line 1415
  free((void *)copy);
#line 1416
  return (ret);
}
}
#line 1435 "mbox.c"
static int parseEmailBody(message *messageIn , text *textIn , char const   *dir ,
                          table_t const   *rfc821Table , table_t const   *subtypeTable ,
                          unsigned int options ) 
{ message **messages ;
  int inMimeHead ;
  int i ;
  int rc ;
  int htmltextPart ;
  int multiparts ;
  text *aText ;
  char const   *cptr ;
  message *mainMessage ;
  fileblob *fb ;
  mime_type mimeType ;
  int subtype___0 ;
  int inhead ;
  char const   *mimeSubtype ;
  char const   *boundary ;
  char *protocol ;
  text const   *t_line ;
  message *aMessage ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  encoding_type tmp___2 ;
  encoding_type tmp___3 ;
  encoding_type tmp___4 ;
  text const   *tmp___5 ;
  text const   *tmp___6 ;
  text const   *tmp___7 ;
  int lines ;
  message **m ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  text const   *tmp___10 ;
  char const   *line ;
  char const   *tmp___11 ;
  unsigned short const   **tmp___12 ;
  int quotes ;
  char *fullline ;
  char *ptr ;
  char const   *qptr ;
  text const   *next ;
  char const   *data ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  encoding_type tmp___15 ;
  mime_type tmp___16 ;
  int tmp___91 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___127 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___146 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  size_t tmp___162 ;
  int tmp___163 ;
  size_t tmp___164 ;
  int tmp___239 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___275 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___294 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___303 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  size_t tmp___310 ;
  int tmp___311 ;
  size_t tmp___312 ;
  mime_type tmp___313 ;
  unsigned short const   **tmp___314 ;
  size_t __len___2 ;
  size_t tmp___331 ;
  char *__retval___2 ;
  char *tmp___332 ;
  int tmp___334 ;
  char const   *data___0 ;
  char const   *tmp___335 ;
  unsigned short const   **tmp___336 ;
  size_t tmp___337 ;
  size_t tmp___338 ;
  int tmp___339 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  mime_type tmp___344 ;
  bool addToText ;
  char const   *dtype ;
  mime_type tmp___345 ;
  int tmp___346 ;
  text const   *tmp___347 ;
  text const   *tmp___348 ;
  text const   *tmp___349 ;
  text const   *tmp___350 ;
  int tmp___351 ;
  char *filename ;
  int tmp___354 ;
  int tmp___355 ;
  encoding_type tmp___356 ;
  text const   *tmp___357 ;
  int tmp___358 ;
  encoding_type tmp___359 ;
  int tmp___360 ;
  text const   *tmp___361 ;
  mime_type tmp___362 ;
  text const   *tmp___363 ;
  int tmp___365 ;
  int tmp___366 ;
  message *m___0 ;
  message *tmp___367 ;
  text const   *tmp___368 ;
  int tmp___369 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  text const   *tmp___375 ;
  text const   *t ;
  line_t const   *l ;
  text const   *lookahead ;
  text const   *topofbounce ;
  char const   *s ;
  bool inheader ;
  size_t tmp___376 ;
  cli_file_t tmp___377 ;
  char *tmp___378 ;
  int tmp___379 ;
  int tmp___380 ;
  char *tmp___381 ;
  char *tmp___382 ;
  char *tmp___383 ;
  size_t tmp___384 ;
  size_t tmp___385 ;
  cli_file_t tmp___386 ;
  text const   *t_line___0 ;
  text const   *t___0 ;
  text const   *start ;
  char cmd[1001] ;
  char const   *txt ;
  char const   *tmp___387 ;
  char *tmp___388 ;
  int tmp___389 ;
  char *tmp___390 ;
  char *tmp___391 ;
  char *tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  fileblob *tmp___395 ;
  bool saveIt ;
  text const   *tmp___396 ;
  char const   *tmp___397 ;
  mime_type tmp___398 ;
  text const   *tmp___399 ;

  {
#line 1439
  rc = 1;
#line 1439
  multiparts = 0;
#line 1445
  cli_dbgmsg("in parseEmailBody\n");
#line 1447
  aText = textIn;
#line 1448
  messages = (message **)((void *)0);
#line 1449
  mainMessage = messageIn;
#line 1452
  if (mainMessage) {
#line 1452
    tmp___375 = messageGetBody((message const   *)mainMessage);
#line 1452
    if ((unsigned int )tmp___375 != (unsigned int )((void *)0)) {
#line 1461
      cli_dbgmsg("Parsing mail file\n");
#line 1463
      mimeType = messageGetMimeType((message const   *)mainMessage);
#line 1464
      mimeSubtype = messageGetMimeSubtype((message const   *)mainMessage);
#line 1467
      subtype___0 = tableFind(subtypeTable, mimeSubtype);
#line 1468
      if ((int )mimeType == 6) {
#line 1468
        if (subtype___0 == 1) {
#line 1473
          cli_dbgmsg("assume no encoding\n");
#line 1474
          mimeType = (enum __anonenum_mime_type_31 )0;
#line 1475
          messageSetMimeSubtype(mainMessage, "");
        } else {
          goto _L;
        }
      } else {
        _L: 
#line 1476
        if ((int )mimeType == 4) {
#line 1476
          tmp = strcasecmp(mimeSubtype, "rfc822-headers");
#line 1476
          if (tmp == 0) {
#line 1484
            cli_dbgmsg("Changing message/rfc822-headers to text/rfc822-headers\n");
#line 1485
            mimeType = (enum __anonenum_mime_type_31 )0;
#line 1486
            messageSetMimeSubtype(mainMessage, "");
          }
        }
      }
#line 1489
      cli_dbgmsg("mimeType = %d\n", mimeType);
#line 1491
      switch ((int )mimeType) {
      case 0: 
#line 1493
      cli_dbgmsg("Not a mime encoded message\n");
#line 1494
      aText = textAddMessage(aText, mainMessage);
#line 1495
      break;
      case 6: ;
#line 1498
      if (options & 256U) {
#line 1498
        if (subtype___0 == 3) {
#line 1499
          checkURLs(mainMessage, dir);
        }
      }
#line 1500
      break;
      case 5: 
#line 1502
      cli_dbgmsg("Content-type \'multipart\' handler\n");
#line 1503
      boundary = messageFindArgument((message const   *)mainMessage, "boundary");
#line 1505
      if ((unsigned int )boundary == (unsigned int )((void *)0)) {
#line 1506
        cli_warnmsg("Multipart MIME message contains no boundaries\n");
#line 1508
        mimeType = (enum __anonenum_mime_type_31 )0;
#line 1513
        break;
      }
#line 1517
      if ((int const   )(*(mimeSubtype + 0)) == 0) {
#line 1518
        cli_warnmsg("Multipart has no subtype assuming alternative\n");
#line 1519
        mimeSubtype = "alternative";
#line 1520
        messageSetMimeSubtype(mainMessage, "alternative");
      }
#line 1526
      t_line = messageGetBody((message const   *)mainMessage);
#line 1528
      if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1529
        cli_warnmsg("Multipart MIME message has no body\n");
#line 1530
        free((void *)((char *)boundary));
#line 1531
        mimeType = (enum __anonenum_mime_type_31 )0;
#line 1532
        break;
      }
#line 1535
      while (1) {
#line 1536
        if (t_line->t_line) {
#line 1537
          tmp___0 = lineGetData((line_t const   *)t_line->t_line);
#line 1537
          tmp___1 = boundaryStart(tmp___0, boundary);
#line 1537
          if (tmp___1) {
#line 1538
            break;
          }
#line 1544
          tmp___7 = uuencodeBegin((message const   *)mainMessage);
#line 1544
          if ((unsigned int )tmp___7 == (unsigned int )t_line) {
#line 1545
            tmp___2 = messageGetEncoding((message const   *)mainMessage);
#line 1545
            if ((int )tmp___2 == 0) {
#line 1546
              messageSetEncoding(mainMessage, "x-uuencode");
#line 1547
              fb = messageToFileblob(mainMessage, dir);
#line 1549
              if (fb) {
#line 1550
                fileblobDestroy(fb);
              }
            }
          } else {
#line 1552
            tmp___6 = binhexBegin((message const   *)mainMessage);
#line 1552
            if ((unsigned int )tmp___6 == (unsigned int )t_line) {
#line 1553
              tmp___3 = messageGetEncoding((message const   *)mainMessage);
#line 1553
              if ((int )tmp___3 == 0) {
#line 1554
                messageSetEncoding(mainMessage, "x-binhex");
#line 1555
                fb = messageToFileblob(mainMessage, dir);
#line 1557
                if (fb) {
#line 1558
                  fileblobDestroy(fb);
                }
              }
            } else {
#line 1560
              tmp___5 = encodingLine((message const   *)mainMessage);
#line 1560
              if ((unsigned int )tmp___5 == (unsigned int )t_line->t_next) {
#line 1570
                cli_dbgmsg("Found MIME attachment before the first MIME section\n");
#line 1571
                tmp___4 = messageGetEncoding((message const   *)mainMessage);
#line 1571
                if ((int )tmp___4 == 0) {
#line 1572
                  break;
                }
              }
            }
          }
        }
#line 1535
        t_line = (text const   *)t_line->t_next;
#line 1535
        if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
#line 1535
          break;
        }
      }
#line 1577
      if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1578
        cli_dbgmsg("Multipart MIME message contains no boundary lines\n");
#line 1583
        free((void *)((char *)boundary));
#line 1584
        mimeType = (enum __anonenum_mime_type_31 )0;
#line 1589
        break;
      }
#line 1596
      inhead = 1;
#line 1597
      inMimeHead = 0;
#line 1607
      multiparts = 0;
#line 1607
      while (t_line) {
#line 1608
        lines = 0;
#line 1611
        m = (message **)cli_realloc((void *)messages, (unsigned int )(multiparts +
                                                                      1) * sizeof(message *));
#line 1612
        if ((unsigned int )m == (unsigned int )((void *)0)) {
#line 1613
          break;
        }
#line 1614
        messages = m;
#line 1616
        (*(messages + multiparts)) = messageCreate();
#line 1616
        aMessage = (*(messages + multiparts));
#line 1617
        if ((unsigned int )aMessage == (unsigned int )((void *)0)) {
#line 1618
          multiparts --;
          goto __Cont;
        }
#line 1622
        cli_dbgmsg("Now read in part %d\n", multiparts);
#line 1628
        while (1) {
#line 1628
          t_line = (text const   *)t_line->t_next;
#line 1628
          if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
#line 1628
            break;
          }
#line 1629
          if (t_line->t_line) {
#line 1629
            tmp___8 = lineGetData((line_t const   *)t_line->t_line);
#line 1629
            tmp___9 = strlen(tmp___8);
#line 1629
            if (tmp___9 > 0U) {
#line 1632
              break;
            }
          }
        }
#line 1634
        if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1635
          cli_dbgmsg("Empty part\n");
#line 1643
          tmp___10 = uuencodeBegin((message const   *)mainMessage);
#line 1643
          if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
#line 1644
            messageDestroy(aMessage);
#line 1645
            multiparts --;
          }
          goto __Cont;
        }
#line 1650
        while (1) {
#line 1651
          tmp___11 = lineGetData((line_t const   *)t_line->t_line);
#line 1651
          line = tmp___11;
#line 1657
          if (inMimeHead) {
#line 1658
            if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1659
              inMimeHead = 0;
              goto __Cont___0;
            }
#line 1668
            cli_dbgmsg("Multipart %d: About to add mime Argument \'%s\'\n", multiparts,
                       line);
#line 1677
            parseEmailHeader(aMessage, line, rfc821Table);
#line 1679
            while (1) {
#line 1679
              tmp___12 = __ctype_b_loc();
#line 1679
              if (! ((int const   )(*((*tmp___12) + (int )(*line))) & 8192)) {
#line 1679
                break;
              }
#line 1680
              line ++;
            }
#line 1682
            if ((int const   )(*line) == 0) {
#line 1683
              inMimeHead = 0;
#line 1683
              inhead = inMimeHead;
              goto __Cont___0;
            }
#line 1691
            inMimeHead = (int )continuationMarker(line);
#line 1692
            messageAddArgument(aMessage, line);
          } else {
#line 1693
            if (inhead) {
#line 1699
              if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1717
                next = (text const   *)t_line->t_next;
#line 1718
                if (next) {
#line 1718
                  if (next->t_line) {
#line 1719
                    tmp___13 = lineGetData((line_t const   *)next->t_line);
#line 1719
                    data = tmp___13;
#line 1721
                    tmp___15 = messageGetEncoding((message const   *)aMessage);
#line 1721
                    if ((int )tmp___15 == 0) {
#line 1721
                      tmp___16 = messageGetMimeType((message const   *)aMessage);
#line 1721
                      if ((int )tmp___16 == 1) {
#line 1733
                        tmp___14 = strstr(data, "base64");
#line 1733
                        if (tmp___14) {
#line 1734
                          messageSetEncoding(aMessage, "base64");
#line 1735
                          cli_dbgmsg("Ignoring fake end of headers\n");
                          goto __Cont___0;
                        }
                      }
                    }
#line 1738
                    tmp___161 = __builtin_constant_p((int )data);
#line 1738
                    if (tmp___161) {
#line 1738
                      tmp___162 = strlen(data);
#line 1738
                      if (tmp___162 < 7U) {
                        goto _L___40;
                      } else {
                        goto _L___41;
                      }
                    } else {
                      _L___41: 
#line 1738
                      tmp___163 = __builtin_constant_p((int )"Content");
#line 1738
                      if (tmp___163) {
#line 1738
                        tmp___164 = strlen("Content");
#line 1738
                        if (tmp___164 < 7U) {
                          _L___40: 
#line 1738
                          tmp___158 = __builtin_constant_p((int )data);
#line 1738
                          if (tmp___158) {
#line 1738
                            tmp___159 = __builtin_constant_p((int )"Content");
#line 1738
                            if (tmp___159) {
#line 1738
                              __s1_len___0 = strlen(data);
#line 1738
                              __s2_len___0 = strlen("Content");
#line 1738
                              if (! ((unsigned int )((void const   *)(data + 1)) -
                                     (unsigned int )((void const   *)data) == 1U)) {
                                goto _L___37;
                              } else {
#line 1738
                                if (__s1_len___0 >= 4U) {
                                  _L___37: 
#line 1738
                                  if (! ((unsigned int )((void const   *)("Content" +
                                                                          1)) - (unsigned int )((void const   *)"Content") ==
                                         1U)) {
#line 1738
                                    tmp___160 = 1;
                                  } else {
#line 1738
                                    if (__s2_len___0 >= 4U) {
#line 1738
                                      tmp___160 = 1;
                                    } else {
#line 1738
                                      tmp___160 = 0;
                                    }
                                  }
                                } else {
#line 1738
                                  tmp___160 = 0;
                                }
                              }
#line 1738
                              if (tmp___160) {
#line 1738
                                tmp___127 = __builtin_strcmp(data, "Content");
                              } else {
                                goto _L___39;
                              }
                            } else {
                              goto _L___39;
                            }
                          } else {
                            _L___39: 
#line 1738
                            tmp___157 = __builtin_constant_p((int )data);
#line 1738
                            if (tmp___157) {
#line 1738
                              if ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                                  1U) {
#line 1738
                                __s1_len___0 = strlen(data);
#line 1738
                                if (__s1_len___0 < 4U) {
#line 1738
                                  tmp___146 = __builtin_constant_p((int )"Content");
#line 1738
                                  if (tmp___146) {
#line 1738
                                    if ((unsigned int )((void const   *)("Content" +
                                                                         1)) - (unsigned int )((void const   *)"Content") ==
                                        1U) {
#line 1738
                                      tmp___127 = __builtin_strcmp(data, "Content");
                                    } else {
                                      goto _L___32;
                                    }
                                  } else {
                                    _L___32: 
#line 1738
                                    __s2___14 = (unsigned char const   *)"Content";
#line 1738
                                    __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                            0)) -
                                                           (int const   )(*(__s2___14 +
                                                                            0)));
#line 1738
                                    if (__s1_len___0 > 0U) {
#line 1738
                                      if (__result___42 == 0) {
#line 1738
                                        __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                1)) -
                                                               (int const   )(*(__s2___14 +
                                                                                1)));
#line 1738
                                        if (__s1_len___0 > 1U) {
#line 1738
                                          if (__result___42 == 0) {
#line 1738
                                            __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                    2)) -
                                                                   (int const   )(*(__s2___14 +
                                                                                    2)));
#line 1738
                                            if (__s1_len___0 > 2U) {
#line 1738
                                              if (__result___42 == 0) {
#line 1738
                                                __result___42 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                        3)) -
                                                                       (int const   )(*(__s2___14 +
                                                                                        3)));
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
#line 1738
                                    tmp___127 = __result___42;
                                  }
                                } else {
                                  goto _L___36;
                                }
                              } else {
                                goto _L___36;
                              }
                            } else {
                              _L___36: 
#line 1738
                              tmp___156 = __builtin_constant_p((int )"Content");
#line 1738
                              if (tmp___156) {
#line 1738
                                if ((unsigned int )((void const   *)("Content" + 1)) -
                                    (unsigned int )((void const   *)"Content") ==
                                    1U) {
#line 1738
                                  __s2_len___0 = strlen("Content");
#line 1738
                                  if (__s2_len___0 < 4U) {
#line 1738
                                    tmp___155 = __builtin_constant_p((int )data);
#line 1738
                                    if (tmp___155) {
#line 1738
                                      if ((unsigned int )((void const   *)(data +
                                                                           1)) - (unsigned int )((void const   *)data) ==
                                          1U) {
#line 1738
                                        tmp___127 = __builtin_strcmp(data, "Content");
                                      } else {
                                        goto _L___34;
                                      }
                                    } else {
                                      _L___34: 
#line 1738
                                      __s1___30 = (unsigned char const   *)data;
#line 1738
                                      __result___46 = (int )((int const   )(*(__s1___30 +
                                                                              0)) -
                                                             (int const   )(*((unsigned char const   *)"Content" +
                                                                              0)));
#line 1738
                                      if (__s2_len___0 > 0U) {
#line 1738
                                        if (__result___46 == 0) {
#line 1738
                                          __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                  1)) -
                                                                 (int const   )(*((unsigned char const   *)"Content" +
                                                                                  1)));
#line 1738
                                          if (__s2_len___0 > 1U) {
#line 1738
                                            if (__result___46 == 0) {
#line 1738
                                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                      2)) -
                                                                     (int const   )(*((unsigned char const   *)"Content" +
                                                                                      2)));
#line 1738
                                              if (__s2_len___0 > 2U) {
#line 1738
                                                if (__result___46 == 0) {
#line 1738
                                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                          3)) -
                                                                         (int const   )(*((unsigned char const   *)"Content" +
                                                                                          3)));
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
#line 1738
                                      tmp___127 = __result___46;
                                    }
                                  } else {
#line 1738
                                    tmp___127 = __builtin_strcmp(data, "Content");
                                  }
                                } else {
#line 1738
                                  tmp___127 = __builtin_strcmp(data, "Content");
                                }
                              } else {
#line 1738
                                tmp___127 = __builtin_strcmp(data, "Content");
                              }
                            }
                          }
#line 1738
                          tmp___91 = tmp___127;
                        } else {
#line 1738
                          tmp___91 = strncmp(data, "Content", 7U);
                        }
                      } else {
#line 1738
                        tmp___91 = strncmp(data, "Content", 7U);
                      }
                    }
#line 1739
                    if (tmp___91 == 0) {
#line 1740
                      cli_dbgmsg("Ignoring fake end of headers\n");
                      goto __Cont___0;
                    } else {
#line 1739
                      tmp___309 = __builtin_constant_p((int )data);
#line 1739
                      if (tmp___309) {
#line 1739
                        tmp___310 = strlen(data);
#line 1739
                        if (tmp___310 < 9U) {
                          goto _L___82;
                        } else {
                          goto _L___83;
                        }
                      } else {
                        _L___83: 
#line 1739
                        tmp___311 = __builtin_constant_p((int )"filename=");
#line 1739
                        if (tmp___311) {
#line 1739
                          tmp___312 = strlen("filename=");
#line 1739
                          if (tmp___312 < 9U) {
                            _L___82: 
#line 1739
                            tmp___306 = __builtin_constant_p((int )data);
#line 1739
                            if (tmp___306) {
#line 1739
                              tmp___307 = __builtin_constant_p((int )"filename=");
#line 1739
                              if (tmp___307) {
#line 1739
                                __s1_len___2 = strlen(data);
#line 1739
                                __s2_len___2 = strlen("filename=");
#line 1739
                                if (! ((unsigned int )((void const   *)(data + 1)) -
                                       (unsigned int )((void const   *)data) == 1U)) {
                                  goto _L___79;
                                } else {
#line 1739
                                  if (__s1_len___2 >= 4U) {
                                    _L___79: 
#line 1739
                                    if (! ((unsigned int )((void const   *)("filename=" +
                                                                            1)) -
                                           (unsigned int )((void const   *)"filename=") ==
                                           1U)) {
#line 1739
                                      tmp___308 = 1;
                                    } else {
#line 1739
                                      if (__s2_len___2 >= 4U) {
#line 1739
                                        tmp___308 = 1;
                                      } else {
#line 1739
                                        tmp___308 = 0;
                                      }
                                    }
                                  } else {
#line 1739
                                    tmp___308 = 0;
                                  }
                                }
#line 1739
                                if (tmp___308) {
#line 1739
                                  tmp___275 = __builtin_strcmp(data, "filename=");
                                } else {
                                  goto _L___81;
                                }
                              } else {
                                goto _L___81;
                              }
                            } else {
                              _L___81: 
#line 1739
                              tmp___305 = __builtin_constant_p((int )data);
#line 1739
                              if (tmp___305) {
#line 1739
                                if ((unsigned int )((void const   *)(data + 1)) -
                                    (unsigned int )((void const   *)data) == 1U) {
#line 1739
                                  __s1_len___2 = strlen(data);
#line 1739
                                  if (__s1_len___2 < 4U) {
#line 1739
                                    tmp___294 = __builtin_constant_p((int )"filename=");
#line 1739
                                    if (tmp___294) {
#line 1739
                                      if ((unsigned int )((void const   *)("filename=" +
                                                                           1)) - (unsigned int )((void const   *)"filename=") ==
                                          1U) {
#line 1739
                                        tmp___275 = __builtin_strcmp(data, "filename=");
                                      } else {
                                        goto _L___74;
                                      }
                                    } else {
                                      _L___74: 
#line 1739
                                      __s2___30 = (unsigned char const   *)"filename=";
#line 1739
                                      __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                              0)) -
                                                             (int const   )(*(__s2___30 +
                                                                              0)));
#line 1739
                                      if (__s1_len___2 > 0U) {
#line 1739
                                        if (__result___90 == 0) {
#line 1739
                                          __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                  1)) -
                                                                 (int const   )(*(__s2___30 +
                                                                                  1)));
#line 1739
                                          if (__s1_len___2 > 1U) {
#line 1739
                                            if (__result___90 == 0) {
#line 1739
                                              __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                      2)) -
                                                                     (int const   )(*(__s2___30 +
                                                                                      2)));
#line 1739
                                              if (__s1_len___2 > 2U) {
#line 1739
                                                if (__result___90 == 0) {
#line 1739
                                                  __result___90 = (int )((int const   )(*((unsigned char const   *)data +
                                                                                          3)) -
                                                                         (int const   )(*(__s2___30 +
                                                                                          3)));
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
#line 1739
                                      tmp___275 = __result___90;
                                    }
                                  } else {
                                    goto _L___78;
                                  }
                                } else {
                                  goto _L___78;
                                }
                              } else {
                                _L___78: 
#line 1739
                                tmp___304 = __builtin_constant_p((int )"filename=");
#line 1739
                                if (tmp___304) {
#line 1739
                                  if ((unsigned int )((void const   *)("filename=" +
                                                                       1)) - (unsigned int )((void const   *)"filename=") ==
                                      1U) {
#line 1739
                                    __s2_len___2 = strlen("filename=");
#line 1739
                                    if (__s2_len___2 < 4U) {
#line 1739
                                      tmp___303 = __builtin_constant_p((int )data);
#line 1739
                                      if (tmp___303) {
#line 1739
                                        if ((unsigned int )((void const   *)(data +
                                                                             1)) -
                                            (unsigned int )((void const   *)data) ==
                                            1U) {
#line 1739
                                          tmp___275 = __builtin_strcmp(data, "filename=");
                                        } else {
                                          goto _L___76;
                                        }
                                      } else {
                                        _L___76: 
#line 1739
                                        __s1___62 = (unsigned char const   *)data;
#line 1739
                                        __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                0)) -
                                                               (int const   )(*((unsigned char const   *)"filename=" +
                                                                                0)));
#line 1739
                                        if (__s2_len___2 > 0U) {
#line 1739
                                          if (__result___94 == 0) {
#line 1739
                                            __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                    1)) -
                                                                   (int const   )(*((unsigned char const   *)"filename=" +
                                                                                    1)));
#line 1739
                                            if (__s2_len___2 > 1U) {
#line 1739
                                              if (__result___94 == 0) {
#line 1739
                                                __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                        2)) -
                                                                       (int const   )(*((unsigned char const   *)"filename=" +
                                                                                        2)));
#line 1739
                                                if (__s2_len___2 > 2U) {
#line 1739
                                                  if (__result___94 == 0) {
#line 1739
                                                    __result___94 = (int )((int const   )(*(__s1___62 +
                                                                                            3)) -
                                                                           (int const   )(*((unsigned char const   *)"filename=" +
                                                                                            3)));
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
#line 1739
                                        tmp___275 = __result___94;
                                      }
                                    } else {
#line 1739
                                      tmp___275 = __builtin_strcmp(data, "filename=");
                                    }
                                  } else {
#line 1739
                                    tmp___275 = __builtin_strcmp(data, "filename=");
                                  }
                                } else {
#line 1739
                                  tmp___275 = __builtin_strcmp(data, "filename=");
                                }
                              }
                            }
#line 1739
                            tmp___239 = tmp___275;
                          } else {
#line 1739
                            tmp___239 = strncmp(data, "filename=", 9U);
                          }
                        } else {
#line 1739
                          tmp___239 = strncmp(data, "filename=", 9U);
                        }
                      }
#line 1739
                      if (tmp___239 == 0) {
#line 1740
                        cli_dbgmsg("Ignoring fake end of headers\n");
                        goto __Cont___0;
                      }
                    }
                  }
                }
#line 1744
                cli_dbgmsg("Multipart %d: End of header information\n", multiparts);
#line 1746
                inhead = 0;
                goto __Cont___0;
              }
#line 1749
              tmp___314 = __ctype_b_loc();
#line 1749
              if ((int const   )(*((*tmp___314) + (int )(*line))) & 8192) {
#line 1758
                cli_dbgmsg("Part %d starts with a continuation line\n", multiparts);
#line 1760
                messageAddArgument(aMessage, line);
#line 1770
                tmp___313 = messageGetMimeType((message const   *)aMessage);
#line 1770
                if ((int )tmp___313 == 0) {
#line 1771
                  messageSetMimeType(aMessage, "application");
                }
                goto __Cont___0;
              }
#line 1775
              inMimeHead = 0;
#line 1779
              fullline = rfc822comments(line, (char *)((void *)0));
#line 1780
              if ((unsigned int )fullline == (unsigned int )((void *)0)) {
#line 1781
                tmp___334 = __builtin_constant_p((int )line);
#line 1781
                if (tmp___334) {
#line 1781
                  if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                      1U) {
#line 1781
                    if ((int const   )(*(line + 0)) == 0) {
#line 1781
                      fullline = (char *)calloc(1U, 1U);
                    } else {
#line 1781
                      tmp___331 = strlen(line);
#line 1781
                      __len___2 = tmp___331 + 1U;
#line 1781
                      tmp___332 = (char *)malloc(__len___2);
#line 1781
                      __retval___2 = tmp___332;
#line 1781
                      if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1781
                        __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                      (void const   * __restrict  )line,
                                                      __len___2);
                      }
#line 1781
                      fullline = __retval___2;
                    }
                  } else {
#line 1781
                    fullline = __strdup(line);
                  }
                } else {
#line 1781
                  fullline = __strdup(line);
                }
              }
#line 1783
              quotes = 0;
#line 1784
              qptr = (char const   *)fullline;
#line 1784
              while ((*qptr)) {
#line 1785
                if ((int const   )(*qptr) == 34) {
#line 1786
                  quotes ++;
                }
#line 1784
                qptr ++;
              }
#line 1795
              next = (text const   *)t_line->t_next;
#line 1796
              while (1) {
#line 1796
                if (next) {
#line 1796
                  if (! next->t_line) {
#line 1796
                    break;
                  }
                } else {
#line 1796
                  break;
                }
#line 1797
                tmp___335 = lineGetData((line_t const   *)next->t_line);
#line 1797
                data___0 = tmp___335;
#line 1802
                tmp___336 = __ctype_b_loc();
#line 1802
                if (! ((int const   )(*((*tmp___336) + (int )(*(data___0 + 0)))) &
                       8192)) {
#line 1803
                  break;
                }
#line 1805
                tmp___337 = strlen((char const   *)fullline);
#line 1805
                tmp___338 = strlen(data___0);
#line 1805
                ptr = (char *)cli_realloc((void *)fullline, (tmp___337 + tmp___338) +
                                                            1U);
#line 1808
                if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 1809
                  break;
                }
#line 1811
                fullline = ptr;
#line 1812
                strcat((char * __restrict  )fullline, (char const   * __restrict  )data___0);
#line 1818
                t_line = next;
#line 1819
                next = (text const   *)next->t_next;
              }
#line 1821
              cli_dbgmsg("Multipart %d: About to parse folded header \'%s\'\n", multiparts,
                         fullline);
#line 1824
              parseEmailHeader(aMessage, (char const   *)fullline, rfc821Table);
#line 1825
              free((void *)fullline);
            } else {
#line 1826
              tmp___341 = endOfMessage(line, boundary);
#line 1826
              if (tmp___341) {
#line 1836
                break;
              } else {
#line 1837
                tmp___340 = boundaryStart(line, boundary);
#line 1837
                if (tmp___340) {
#line 1838
                  inhead = 1;
#line 1839
                  break;
                } else {
#line 1841
                  tmp___339 = messageAddLine(aMessage, t_line->t_line);
#line 1841
                  if (tmp___339 < 0) {
#line 1842
                    break;
                  }
#line 1843
                  lines ++;
                }
              }
            }
          }
          __Cont___0: 
#line 1650
          t_line = (text const   *)t_line->t_next;
#line 1650
          if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
#line 1650
            break;
          }
        }
#line 1847
        messageClean(aMessage);
#line 1849
        cli_dbgmsg("Part %d has %d lines\n", multiparts, lines);
        __Cont: 
#line 1607
        multiparts ++;
      }
#line 1853
      free((void *)((char *)boundary));
#line 1859
      tmp___342 = tableFind(subtypeTable, mimeSubtype);
#line 1859
      switch (tmp___342) {
      case 14: 
#line 1862
      cli_dbgmsg("multipart/knowbot parsed as multipart/mixed for now\n");
#line 1863
      mimeSubtype = "mixed";
#line 1864
      break;
      case -1: 
#line 1871
      cli_dbgmsg("Unsupported multipart format `%s\', parsed as mixed\n", mimeSubtype);
#line 1872
      mimeSubtype = "mixed";
#line 1873
      break;
      }
#line 1879
      if (mainMessage) {
#line 1879
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 1880
          messageDestroy(mainMessage);
#line 1881
          mainMessage = (message *)((void *)0);
        }
      }
#line 1884
      if (multiparts == 0) {
#line 1885
        if (messages) {
#line 1886
          free((void *)messages);
        }
#line 1887
        return (2);
      }
#line 1890
      cli_dbgmsg("The message has %d parts\n", multiparts);
#line 1891
      cli_dbgmsg("Find out the multipart type (%s)\n", mimeSubtype);
#line 1899
      tmp___343 = tableFind(subtypeTable, mimeSubtype);
#line 1899
      switch (tmp___343) {
      case 10: 
#line 1901
      cli_dbgmsg("Multipart related handler\n");
#line 1906
      aMessage = (message *)((void *)0);
#line 1909
      htmltextPart = getTextPart((message * const  *)messages, (unsigned int )multiparts);
#line 1911
      if (htmltextPart >= 0) {
#line 1912
        aText = textAddMessage(aText, (*(messages + htmltextPart)));
      } else {
#line 1919
        i = 0;
#line 1919
        while (i < multiparts) {
#line 1920
          tmp___344 = messageGetMimeType((message const   *)(*(messages + i)));
#line 1920
          if ((int )tmp___344 == 5) {
#line 1921
            aMessage = (*(messages + i));
#line 1922
            htmltextPart = i;
#line 1923
            break;
          }
#line 1919
          i ++;
        }
      }
#line 1926
      if (htmltextPart == -1) {
#line 1927
        cli_dbgmsg("No HTML code found to be scanned");
      } else {
#line 1929
        rc = parseEmailBody(aMessage, aText, dir, rfc821Table, subtypeTable, options);
#line 1930
        if (rc == 1) {
#line 1932
          messageDestroy(aMessage);
#line 1933
          (*(messages + htmltextPart)) = (message *)((void *)0);
        }
      }
      case 7: ;
      case 6: 
#line 1974
      cli_dbgmsg("Multipart alternative handler\n");
      case 11: ;
      case 5: ;
      case 12: ;
#line 2000
      if (aText) {
#line 2001
        if (mainMessage) {
#line 2001
          if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2002
            messageDestroy(mainMessage);
          }
        }
#line 2003
        mainMessage = (message *)((void *)0);
      }
#line 2006
      cli_dbgmsg("Mixed message with %d parts\n", multiparts);
#line 2007
      i = 0;
#line 2007
      while (i < multiparts) {
#line 2008
        addToText = (enum __anonenum_bool_35 )0;
#line 2014
        aMessage = (*(messages + i));
#line 2016
        if ((unsigned int )aMessage == (unsigned int )((void *)0)) {
          goto __Cont___1;
        }
#line 2019
        tmp___345 = messageGetMimeType((message const   *)aMessage);
#line 2019
        cli_dbgmsg("Mixed message part %d is of type %d\n", i, tmp___345);
#line 2022
        tmp___346 = (int )messageGetMimeType((message const   *)aMessage);
#line 2022
        switch (tmp___346) {
        case 1: ;
        case 2: ;
        case 3: ;
        case 7: ;
#line 2027
        break;
        case 0: 
#line 2029
        cli_dbgmsg("No mime headers found in multipart part %d\n", i);
#line 2030
        if (mainMessage) {
#line 2031
          tmp___347 = uuencodeBegin((message const   *)aMessage);
#line 2031
          if (tmp___347) {
#line 2032
            cli_dbgmsg("Found uuencoded message in multipart/mixed mainMessage\n");
#line 2033
            messageSetEncoding(mainMessage, "x-uuencode");
#line 2034
            fb = messageToFileblob(mainMessage, dir);
#line 2036
            if (fb) {
#line 2037
              fileblobDestroy(fb);
            }
          }
#line 2039
          if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2040
            messageDestroy(mainMessage);
          }
#line 2041
          mainMessage = (message *)((void *)0);
        } else {
#line 2042
          if (aMessage) {
#line 2043
            tmp___349 = uuencodeBegin((message const   *)aMessage);
#line 2043
            if (tmp___349) {
#line 2044
              cli_dbgmsg("Found uuencoded message in multipart/mixed non mime part\n");
#line 2045
              messageSetEncoding(aMessage, "x-uuencode");
#line 2046
              fb = messageToFileblob(aMessage, dir);
#line 2048
              if (fb) {
#line 2049
                fileblobDestroy(fb);
              }
#line 2051
              messageReset((*(messages + i)));
            } else {
#line 2052
              tmp___348 = binhexBegin((message const   *)aMessage);
#line 2052
              if (tmp___348) {
#line 2053
                cli_dbgmsg("Found binhex message in multipart/mixed non mime part\n");
#line 2054
                messageSetEncoding(aMessage, "x-binhex");
#line 2055
                fb = messageToFileblob(aMessage, dir);
#line 2057
                if (fb) {
#line 2058
                  fileblobDestroy(fb);
                }
#line 2060
                messageReset((*(messages + i)));
              }
            }
          }
        }
#line 2063
        addToText = (enum __anonenum_bool_35 )1;
#line 2064
        tmp___350 = messageGetBody((message const   *)aMessage);
#line 2064
        if ((unsigned int )tmp___350 == (unsigned int )((void *)0)) {
#line 2068
          messageAddStr(aMessage, "No plain text alternative");
        }
#line 2070
        break;
        case 6: 
#line 2072
        dtype = messageGetDispositionType((message const   *)aMessage);
#line 2073
        cli_dbgmsg("Mixed message text part disposition \"%s\"\n", dtype);
#line 2075
        tmp___351 = strcasecmp(dtype, "attachment");
#line 2075
        if (tmp___351 == 0) {
#line 2076
          break;
        }
#line 2077
        if ((int const   )(*dtype) == 0) {
          goto _L___85;
        } else {
#line 2077
          tmp___358 = strcasecmp(dtype, "inline");
#line 2077
          if (tmp___358 == 0) {
            _L___85: 
#line 2078
            if (mainMessage) {
#line 2078
              if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2079
                messageDestroy(mainMessage);
              }
            }
#line 2080
            mainMessage = (message *)((void *)0);
#line 2081
            cptr = messageGetMimeSubtype((message const   *)aMessage);
#line 2082
            cli_dbgmsg("Mime subtype \"%s\"\n", cptr);
#line 2083
            tmp___357 = uuencodeBegin((message const   *)aMessage);
#line 2083
            if (tmp___357) {
#line 2084
              cli_dbgmsg("Found uuencoded message in multipart/mixed text portion\n");
#line 2085
              messageSetEncoding(aMessage, "x-uuencode");
            } else {
#line 2086
              tmp___355 = tableFind(subtypeTable, cptr);
#line 2086
              if (tmp___355 == 1) {
#line 2086
                tmp___356 = messageGetEncoding((message const   *)aMessage);
#line 2086
                if ((int )tmp___356 == 0) {
#line 2097
                  filename = messageFindArgument((message const   *)aMessage, "filename");
#line 2098
                  if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 2099
                    filename = messageFindArgument((message const   *)aMessage, "name");
                  }
#line 2101
                  if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 2102
                    cli_dbgmsg("Adding part to main message\n");
#line 2103
                    addToText = (enum __anonenum_bool_35 )1;
                  } else {
#line 2105
                    cli_dbgmsg("Treating %s as attachment\n", filename);
#line 2107
                    free((void *)filename);
                  }
                } else {
                  goto _L___84;
                }
              } else {
                _L___84: 
#line 2110
                if (options & 256U) {
#line 2111
                  tmp___354 = tableFind(subtypeTable, cptr);
#line 2111
                  if (tmp___354 == 3) {
#line 2112
                    checkURLs(aMessage, dir);
                  }
                }
#line 2113
                messageAddArgument(aMessage, "filename=mixedtextportion");
              }
            }
          } else {
#line 2116
            cli_dbgmsg("Text type %s is not supported\n", dtype);
            goto __Cont___1;
          }
        }
#line 2119
        break;
        case 4: 
#line 2122
        tmp___359 = messageGetEncoding((message const   *)aMessage);
#line 2122
        cli_dbgmsg("Found message inside multipart (encoding type %d)\n", tmp___359);
#line 2124
        tmp___360 = (int )messageGetEncoding((message const   *)aMessage);
#line 2124
        switch (tmp___360) {
        case 0: ;
        case 3: ;
        case 4: 
#line 2128
        tmp___361 = encodingLine((message const   *)aMessage);
#line 2128
        if ((unsigned int )tmp___361 == (unsigned int )((void *)0)) {
#line 2135
          cli_dbgmsg("No encoding line found in the multipart/message\n");
#line 2137
          messageDestroy((*(messages + i)));
#line 2138
          (*(messages + i)) = (message *)((void *)0);
          goto __Cont___1;
        }
        }
#line 2151
        saveTextPart(aMessage, dir);
#line 2153
        messageDestroy((*(messages + i)));
#line 2154
        (*(messages + i)) = (message *)((void *)0);
        goto __Cont___1;
        case 5: 
#line 2186
        cli_dbgmsg("Found multipart inside multipart\n");
#line 2187
        if (aMessage) {
#line 2192
          rc = parseEmailBody(aMessage, aText, dir, rfc821Table, subtypeTable, options);
#line 2193
          cli_dbgmsg("Finished recursion\n");
#line 2195
          messageDestroy((*(messages + i)));
#line 2196
          (*(messages + i)) = (message *)((void *)0);
        } else {
#line 2198
          rc = parseEmailBody((message *)((void *)0), (text *)((void *)0), dir, rfc821Table,
                              subtypeTable, options);
#line 2199
          if (mainMessage) {
#line 2199
            if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2200
              messageDestroy(mainMessage);
            }
          }
#line 2201
          mainMessage = (message *)((void *)0);
        }
        goto __Cont___1;
        default: 
#line 2205
        tmp___362 = messageGetMimeType((message const   *)aMessage);
#line 2205
        cli_warnmsg("Only text and application attachments are supported, type = %d\n",
                    tmp___362);
        goto __Cont___1;
        }
#line 2210
        if (addToText) {
#line 2211
          cli_dbgmsg("Adding to non mime-part\n");
#line 2212
          tmp___363 = messageGetBody((message const   *)aMessage);
#line 2212
          aText = textAdd(aText, tmp___363);
        } else {
#line 2214
          fb = messageToFileblob(aMessage, dir);
#line 2216
          if (fb) {
#line 2217
            fileblobDestroy(fb);
          }
        }
#line 2220
        messageDestroy((*(messages + i)));
#line 2221
        (*(messages + i)) = (message *)((void *)0);
        __Cont___1: 
#line 2007
        i ++;
      }
#line 2225
      break;
      case 8: ;
      case 9: 
#line 2236
      htmltextPart = getTextPart((message * const  *)messages, (unsigned int )multiparts);
#line 2237
      if (htmltextPart == -1) {
#line 2238
        htmltextPart = 0;
      }
#line 2240
      rc = parseEmailBody((*(messages + htmltextPart)), aText, dir, rfc821Table, subtypeTable,
                          options);
#line 2241
      break;
      case 13: 
#line 2243
      rc = 0;
#line 2244
      protocol = messageFindArgument((message const   *)mainMessage, "protocol");
#line 2245
      if (protocol) {
#line 2246
        tmp___365 = strcasecmp((char const   *)protocol, "application/pgp-encrypted");
#line 2246
        if (tmp___365 == 0) {
#line 2248
          cli_warnmsg("PGP encoded attachment not scanned\n");
#line 2249
          rc = 2;
        } else {
#line 2251
          cli_warnmsg("Unknown encryption protocol \'%s\' - if you believe this file contains a virus, report it to bugs@clamav.net\n");
        }
#line 2252
        free((void *)protocol);
      } else {
#line 2254
        cli_dbgmsg("Encryption method missing protocol name\n");
      }
#line 2256
      break;
      default: ;
      }
#line 2261
      if (mainMessage) {
#line 2261
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2262
          messageDestroy(mainMessage);
        }
      }
#line 2264
      if (aText) {
#line 2264
        if ((unsigned int )textIn == (unsigned int )((void *)0)) {
#line 2265
          fb = fileblobCreate();
#line 2265
          if ((unsigned int )fb != (unsigned int )((void *)0)) {
#line 2266
            cli_dbgmsg("Save non mime and/or text/plain part\n");
#line 2267
            fileblobSetFilename(fb, dir, "textpart");
#line 2269
            textToFileblob((text const   *)aText, fb);
#line 2271
            fileblobDestroy(fb);
          }
#line 2273
          textDestroy(aText);
        }
      }
#line 2276
      i = 0;
#line 2276
      while (i < multiparts) {
#line 2277
        if ((*(messages + i))) {
#line 2278
          messageDestroy((*(messages + i)));
        }
#line 2276
        i ++;
      }
#line 2280
      if (messages) {
#line 2281
        free((void *)messages);
      }
#line 2283
      return (rc);
      case 4: 
#line 2289
      tmp___366 = (int )messageGetEncoding((message const   *)mainMessage);
#line 2289
      switch (tmp___366) {
      case 0: ;
      case 3: ;
      case 4: ;
#line 2293
      break;
      default: 
#line 2295
      cli_warnmsg("MIME type \'message\' cannot be decoded\n");
#line 2296
      break;
      }
#line 2298
      rc = 0;
#line 2299
      tmp___373 = strcasecmp(mimeSubtype, "rfc822");
#line 2299
      if (tmp___373 == 0) {
        goto _L___86;
      } else {
#line 2299
        tmp___374 = strcasecmp(mimeSubtype, "delivery-status");
#line 2299
        if (tmp___374 == 0) {
          _L___86: 
#line 2301
          tmp___367 = parseEmailHeaders((message const   *)mainMessage, rfc821Table);
#line 2301
          m___0 = tmp___367;
#line 2302
          if (m___0) {
#line 2303
            cli_dbgmsg("Decode rfc822");
#line 2305
            if (mainMessage) {
#line 2305
              if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2306
                messageDestroy(mainMessage);
#line 2307
                mainMessage = (message *)((void *)0);
              } else {
#line 2309
                messageReset(mainMessage);
              }
            } else {
#line 2309
              messageReset(mainMessage);
            }
#line 2310
            tmp___368 = messageGetBody((message const   *)m___0);
#line 2310
            if (tmp___368) {
#line 2311
              rc = parseEmailBody(m___0, (text *)((void *)0), dir, rfc821Table, subtypeTable,
                                  options);
            }
#line 2313
            messageDestroy(m___0);
          }
#line 2315
          break;
        } else {
#line 2316
          tmp___372 = strcasecmp(mimeSubtype, "disposition-notification");
#line 2316
          if (tmp___372 == 0) {
#line 2318
            rc = 1;
#line 2319
            break;
          } else {
#line 2320
            tmp___371 = strcasecmp(mimeSubtype, "partial");
#line 2320
            if (tmp___371 == 0) {
#line 2323
              tmp___369 = rfc1341(mainMessage, dir);
#line 2323
              if (tmp___369 >= 0) {
#line 2324
                rc = 1;
              }
            } else {
#line 2329
              tmp___370 = strcasecmp(mimeSubtype, "external-body");
#line 2329
              if (tmp___370 == 0) {
#line 2331
                cli_warnmsg("Attempt to send Content-type message/external-body trapped");
              } else {
#line 2333
                cli_warnmsg("Unsupported message format `%s\' - if you believe this file contains a virus, report it to bugs@clamav.net\n",
                            mimeSubtype);
              }
            }
          }
        }
      }
#line 2336
      if (mainMessage) {
#line 2336
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2337
          messageDestroy(mainMessage);
        }
      }
#line 2338
      if (messages) {
#line 2339
        free((void *)messages);
      }
#line 2340
      return (rc);
      case 1: 
#line 2348
      fb = messageToFileblob(mainMessage, dir);
#line 2350
      if (fb) {
#line 2351
        cli_dbgmsg("Saving main message as attachment\n");
#line 2352
        fileblobDestroy(fb);
#line 2353
        if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2354
          messageDestroy(mainMessage);
#line 2355
          mainMessage = (message *)((void *)0);
        } else {
#line 2357
          messageReset(mainMessage);
        }
      }
#line 2361
      break;
      case 2: ;
      case 7: ;
      case 3: ;
#line 2366
      break;
      default: 
#line 2369
      cli_warnmsg("Message received with unknown mime encoding");
#line 2370
      break;
      }
    }
  }
#line 2374
  if (aText) {
#line 2374
    if ((unsigned int )textIn == (unsigned int )((void *)0)) {
#line 2378
      t = (text const   *)aText;
#line 2378
      while (t) {
#line 2379
        l = (line_t const   *)t->t_line;
#line 2384
        if ((unsigned int )l == (unsigned int )((void *)0)) {
          goto __Cont___2;
        }
#line 2387
        s = lineGetData(l);
#line 2389
        tmp___376 = strlen(s);
#line 2389
        tmp___377 = cli_filetype(s, tmp___376);
#line 2389
        if ((int )tmp___377 != 520) {
          goto __Cont___2;
        }
#line 2399
        lookahead = (text const   *)t->t_next;
#line 2399
        while (lookahead) {
#line 2400
          l = (line_t const   *)lookahead->t_line;
#line 2402
          if ((unsigned int )l == (unsigned int )((void *)0)) {
#line 2403
            break;
          }
#line 2404
          s = lineGetData(l);
#line 2405
          tmp___379 = strncasecmp(s, "Content-Type:", 13U);
#line 2405
          if (tmp___379 == 0) {
#line 2410
            tmp___378 = strstr(s, "text/");
#line 2410
            if ((unsigned int )tmp___378 == (unsigned int )((void *)0)) {
#line 2415
              break;
            }
          }
#line 2399
          lookahead = (text const   *)lookahead->t_next;
        }
#line 2418
        if (lookahead) {
#line 2418
          if ((unsigned int )lookahead->t_line == (unsigned int )((void *)0)) {
#line 2419
            cli_dbgmsg("Non mime part bounce message is not mime encoded, so it will not be scanned\n");
#line 2420
            t = lookahead;
            goto __Cont___2;
          }
        }
#line 2434
        while (lookahead) {
#line 2435
          l = (line_t const   *)lookahead->t_line;
#line 2437
          if (l) {
#line 2438
            s = lineGetData(l);
#line 2439
            tmp___380 = strncasecmp(s, "Content-Type:", 13U);
#line 2439
            if (tmp___380 == 0) {
#line 2439
              tmp___381 = strstr(s, "multipart/");
#line 2439
              if ((unsigned int )tmp___381 == (unsigned int )((void *)0)) {
#line 2439
                tmp___382 = strstr(s, "message/rfc822");
#line 2439
                if ((unsigned int )tmp___382 == (unsigned int )((void *)0)) {
#line 2439
                  tmp___383 = strstr(s, "text/plain");
#line 2439
                  if ((unsigned int )tmp___383 == (unsigned int )((void *)0)) {
#line 2443
                    break;
                  }
                }
              }
            }
          }
#line 2434
          lookahead = (text const   *)lookahead->t_next;
        }
#line 2446
        if ((unsigned int )lookahead == (unsigned int )((void *)0)) {
#line 2447
          cli_dbgmsg("cli_mbox: I believe it\'s plain text which must be clean\n");
#line 2449
          break;
        }
#line 2451
        fb = fileblobCreate();
#line 2451
        if ((unsigned int )fb == (unsigned int )((void *)0)) {
#line 2452
          break;
        }
#line 2453
        cli_dbgmsg("Save non mime part bounce message\n");
#line 2454
        fileblobSetFilename(fb, dir, "bounce");
#line 2455
        fileblobAddData(fb, (unsigned char const   *)((unsigned char *)"Received: by clamd (bounce)\n"),
                        28U);
#line 2457
        inheader = (enum __anonenum_bool_35 )1;
#line 2458
        topofbounce = (text const   *)((void *)0);
#line 2459
        while (1) {
#line 2460
          l = (line_t const   *)t->t_line;
#line 2462
          if ((unsigned int )l == (unsigned int )((void *)0)) {
#line 2463
            if (inheader) {
#line 2464
              inheader = (enum __anonenum_bool_35 )0;
#line 2465
              topofbounce = t;
            }
          } else {
#line 2468
            s = lineGetData(l);
#line 2469
            tmp___384 = strlen(s);
#line 2469
            fileblobAddData(fb, (unsigned char const   *)((unsigned char *)s), tmp___384);
          }
#line 2471
          fileblobAddData(fb, (unsigned char const   *)((unsigned char *)"\n"), 1U);
#line 2472
          lookahead = (text const   *)t->t_next;
#line 2473
          if ((unsigned int )lookahead == (unsigned int )((void *)0)) {
#line 2474
            break;
          }
#line 2475
          t = lookahead;
#line 2476
          l = (line_t const   *)t->t_line;
#line 2477
          if (! inheader) {
#line 2477
            if (l) {
#line 2478
              s = lineGetData(l);
#line 2479
              tmp___385 = strlen(s);
#line 2479
              tmp___386 = cli_filetype(s, tmp___385);
#line 2479
              if ((int )tmp___386 == 520) {
#line 2480
                cli_dbgmsg("Found the start of another bounce candidate\n");
#line 2481
                break;
              }
            }
          }
        }
#line 2486
        fileblobDestroy(fb);
#line 2487
        if (topofbounce) {
#line 2488
          t = topofbounce;
        }
        __Cont___2: 
#line 2378
        t = (text const   *)t->t_next;
      }
#line 2495
      textDestroy(aText);
#line 2496
      aText = (text *)((void *)0);
    }
  }
#line 2503
  cli_dbgmsg("%d multiparts found\n", multiparts);
#line 2504
  i = 0;
#line 2504
  while (i < multiparts) {
#line 2505
    fb = messageToFileblob((*(messages + i)), dir);
#line 2507
    if (fb) {
#line 2508
      cli_dbgmsg("Saving multipart %d\n", i);
#line 2510
      fileblobDestroy(fb);
    }
#line 2504
    i ++;
  }
#line 2514
  if (mainMessage) {
#line 2520
    t_line___0 = uuencodeBegin((message const   *)mainMessage);
#line 2520
    if ((unsigned int )t_line___0 != (unsigned int )((void *)0)) {
#line 2521
      cli_dbgmsg("Found uuencoded file\n");
#line 2526
      messageSetEncoding(mainMessage, "x-uuencode");
#line 2528
      fb = messageToFileblob(mainMessage, dir);
#line 2528
      if ((unsigned int )fb != (unsigned int )((void *)0)) {
#line 2529
        cptr = fileblobGetFilename((fileblob const   *)fb);
#line 2529
        if ((unsigned int )cptr != (unsigned int )((void *)0)) {
#line 2530
          cli_dbgmsg("Saving uuencoded message %s\n", cptr);
        }
#line 2531
        fileblobDestroy(fb);
      }
#line 2533
      rc = 1;
    } else {
#line 2534
      tmp___399 = encodingLine((message const   *)mainMessage);
#line 2534
      if ((unsigned int )tmp___399 != (unsigned int )((void *)0)) {
#line 2534
        t_line___0 = bounceBegin((message const   *)mainMessage);
#line 2534
        if ((unsigned int )t_line___0 != (unsigned int )((void *)0)) {
#line 2556
          start = t_line___0;
#line 2556
          t___0 = start;
#line 2556
          while (t___0) {
#line 2558
            tmp___387 = lineGetData((line_t const   *)t___0->t_line);
#line 2558
            txt = tmp___387;
#line 2560
            if ((unsigned int )txt == (unsigned int )((void *)0)) {
              goto __Cont___3;
            }
#line 2562
            tmp___388 = cli_strtokbuf(txt, 0, ":", cmd);
#line 2562
            if ((unsigned int )tmp___388 == (unsigned int )((void *)0)) {
              goto __Cont___3;
            }
#line 2565
            tmp___389 = tableFind(rfc821Table, (char const   *)(cmd));
#line 2565
            switch (tmp___389) {
            case 2: 
#line 2567
            tmp___390 = strstr(txt, "7bit");
#line 2567
            if ((unsigned int )tmp___390 == (unsigned int )((void *)0)) {
#line 2567
              tmp___391 = strstr(txt, "8bit");
#line 2567
              if ((unsigned int )tmp___391 == (unsigned int )((void *)0)) {
#line 2569
                break;
              }
            }
            goto __Cont___3;
            case 3: ;
#line 2572
            break;
            case 1: 
#line 2574
            tmp___392 = strstr(txt, "text/plain");
#line 2574
            if ((unsigned int )tmp___392 != (unsigned int )((void *)0)) {
#line 2575
              t___0 = (text const   *)((void *)0);
            }
#line 2576
            break;
            default: 
#line 2578
            tmp___394 = strcasecmp((char const   *)(cmd), "From");
#line 2578
            if (tmp___394 == 0) {
#line 2579
              start = t_line___0;
            } else {
#line 2580
              tmp___393 = strcasecmp((char const   *)(cmd), "Received");
#line 2580
              if (tmp___393 == 0) {
#line 2581
                start = t_line___0;
              }
            }
            goto __Cont___3;
            }
#line 2584
            break;
            __Cont___3: 
#line 2556
            t___0 = (text const   *)t___0->t_next;
          }
#line 2586
          if (t___0) {
#line 2586
            fb = fileblobCreate();
#line 2586
            if ((unsigned int )fb != (unsigned int )((void *)0)) {
#line 2587
              cli_dbgmsg("Found a bounce message\n");
#line 2588
              fileblobSetFilename(fb, dir, "bounce");
#line 2589
              tmp___395 = textToFileblob(start, fb);
#line 2589
              if ((unsigned int )tmp___395 == (unsigned int )((void *)0)) {
#line 2590
                cli_dbgmsg("Nothing new to save in the bounce message");
              } else {
#line 2592
                rc = 1;
              }
#line 2593
              fileblobDestroy(fb);
            } else {
#line 2595
              cli_dbgmsg("Not found a bounce message\n");
            }
          } else {
#line 2595
            cli_dbgmsg("Not found a bounce message\n");
          }
        } else {
          goto _L___87;
        }
      } else {
        _L___87: 
#line 2599
        cli_dbgmsg("Not found uuencoded file\n");
#line 2601
        tmp___398 = messageGetMimeType((message const   *)mainMessage);
#line 2601
        if ((int )tmp___398 == 4) {
#line 2608
          tmp___396 = encodingLine((message const   *)mainMessage);
#line 2608
          saveIt = (enum __anonenum_bool_35 )((unsigned int )tmp___396 != (unsigned int )((void *)0));
        } else {
#line 2609
          t_line___0 = encodingLine((message const   *)mainMessage);
#line 2609
          if ((unsigned int )t_line___0 != (unsigned int )((void *)0)) {
#line 2617
            fb = fileblobCreate();
#line 2617
            if ((unsigned int )fb != (unsigned int )((void *)0)) {
#line 2618
              tmp___397 = lineGetData((line_t const   *)t_line___0->t_line);
#line 2618
              cli_dbgmsg("Found a bounce message with no header at \'%s\'\n", tmp___397);
#line 2620
              fileblobSetFilename(fb, dir, "bounce");
#line 2621
              fileblobAddData(fb, (unsigned char const   *)"Received: by clamd (bounce)\n",
                              28U);
#line 2625
              fb = textToFileblob(t_line___0, fb);
#line 2627
              fileblobDestroy(fb);
            }
#line 2629
            saveIt = (enum __anonenum_bool_35 )0;
          } else {
#line 2630
            if (multiparts == 0) {
#line 2636
              saveIt = (enum __anonenum_bool_35 )1;
            } else {
#line 2638
              saveIt = (enum __anonenum_bool_35 )0;
            }
          }
        }
#line 2640
        if (saveIt) {
#line 2641
          cli_dbgmsg("Saving text part to scan\n");
#line 2645
          saveTextPart(mainMessage, dir);
#line 2646
          if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2647
            messageDestroy(mainMessage);
#line 2648
            mainMessage = (message *)((void *)0);
          } else {
#line 2650
            messageReset(mainMessage);
          }
#line 2651
          rc = 1;
        }
      }
    }
  } else {
#line 2655
    if (multiparts) {
#line 2655
      rc = 1;
    } else {
#line 2655
      rc = 2;
    }
  }
#line 2657
  if (mainMessage) {
#line 2657
    if ((unsigned int )mainMessage != (unsigned int )messageIn) {
#line 2658
      messageDestroy(mainMessage);
    }
  }
#line 2660
  if (messages) {
#line 2661
    free((void *)messages);
  }
#line 2663
  cli_dbgmsg("parseEmailBody() returning %d\n", rc);
#line 2665
  return (rc);
}
}
#line 2673 "mbox.c"
static int boundaryStart(char const   *line , char const   *boundary ) 
{ char *ptr ;
  char *out ;
  int rc ;
  char buf[1001] ;
  char *tmp___2 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 2680
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 2681
    return (0);
  }
#line 2685
  if ((int const   )(*line) != 45) {
#line 2685
    if ((int const   )(*line) != 40) {
#line 2686
      return (0);
    }
  }
#line 2688
  tmp___4 = __builtin_constant_p((int )line);
#line 2688
  if (tmp___4) {
#line 2688
    tmp___2 = (char *)__builtin_strchr(line, '-');
  } else {
#line 2688
    tmp___2 = (char *)__builtin_strchr(line, '-');
  }
#line 2688
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 2689
    return (0);
  }
#line 2691
  tmp___5 = strlen(line);
#line 2691
  if (tmp___5 <= sizeof(buf)) {
#line 2692
    out = (char *)((void *)0);
#line 2693
    ptr = rfc822comments(line, buf);
  } else {
#line 2695
    ptr = rfc822comments(line, (char *)((void *)0));
#line 2695
    out = ptr;
  }
#line 2697
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 2698
    ptr = (char *)line;
  }
#line 2700
  tmp___6 = ptr;
#line 2700
  ptr ++;
#line 2700
  if ((int )(*tmp___6) != 45) {
#line 2701
    if (out) {
#line 2702
      free((void *)out);
    }
#line 2703
    return (0);
  }
#line 2726
  tmp___9 = strstr((char const   *)ptr, boundary);
#line 2726
  if ((unsigned int )tmp___9 != (unsigned int )((void *)0)) {
#line 2727
    rc = 1;
  } else {
#line 2726
    tmp___10 = strstr(line, boundary);
#line 2726
    if ((unsigned int )tmp___10 != (unsigned int )((void *)0)) {
#line 2727
      rc = 1;
    } else {
#line 2728
      tmp___8 = ptr;
#line 2728
      ptr ++;
#line 2728
      if ((int )(*tmp___8) != 45) {
#line 2729
        rc = 0;
      } else {
#line 2731
        tmp___7 = strcasecmp((char const   *)ptr, boundary);
#line 2731
        rc = tmp___7 == 0;
      }
    }
  }
#line 2733
  if (out) {
#line 2734
    free((void *)out);
  }
#line 2736
  if (rc == 1) {
#line 2737
    cli_dbgmsg("boundaryStart: found %s in %s\n", boundary, line);
  }
#line 2739
  return (rc);
}
}
#line 2747 "mbox.c"
static int endOfMessage(char const   *line , char const   *boundary ) 
{ size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;

  {
#line 2752
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 2753
    return (0);
  }
#line 2755
  tmp = line;
#line 2755
  line ++;
#line 2755
  if ((int const   )(*tmp) != 45) {
#line 2756
    return (0);
  }
#line 2757
  tmp___0 = line;
#line 2757
  line ++;
#line 2757
  if ((int const   )(*tmp___0) != 45) {
#line 2758
    return (0);
  }
#line 2759
  len = strlen(boundary);
#line 2760
  tmp___1 = strncasecmp(line, boundary, len);
#line 2760
  if (tmp___1 != 0) {
#line 2761
    return (0);
  }
#line 2766
  tmp___2 = strlen(line);
#line 2766
  if (tmp___2 < len + 2U) {
#line 2767
    return (0);
  }
#line 2768
  line = line + len;
#line 2769
  tmp___3 = line;
#line 2769
  line ++;
#line 2769
  if ((int const   )(*tmp___3) != 45) {
#line 2770
    return (0);
  }
#line 2771
  return ((int const   )(*line) == 45);
}
}
#line 2777 "mbox.c"
static int initialiseTables(table_t **rfc821Table , table_t **subtypeTable ) 
{ struct tableinit  const  *tableinit ;
  int tmp ;
  int tmp___0 ;

  {
#line 2785
  (*rfc821Table) = tableCreate();
#line 2788
  tableinit = rfc821headers;
#line 2788
  while (tableinit->key) {
#line 2789
    tmp = tableInsert((*rfc821Table), tableinit->key, tableinit->value);
#line 2789
    if (tmp < 0) {
#line 2790
      tableDestroy((*rfc821Table));
#line 2791
      (*rfc821Table) = (table_t *)((void *)0);
#line 2792
      return (-1);
    }
#line 2788
    tableinit ++;
  }
#line 2795
  (*subtypeTable) = tableCreate();
#line 2798
  tableinit = mimeSubtypes;
#line 2798
  while (tableinit->key) {
#line 2799
    tmp___0 = tableInsert((*subtypeTable), tableinit->key, tableinit->value);
#line 2799
    if (tmp___0 < 0) {
#line 2800
      tableDestroy((*rfc821Table));
#line 2801
      tableDestroy((*subtypeTable));
#line 2802
      (*rfc821Table) = (table_t *)((void *)0);
#line 2803
      (*subtypeTable) = (table_t *)((void *)0);
#line 2804
      return (-1);
    }
#line 2798
    tableinit ++;
  }
#line 2807
  return (0);
}
}
#line 2818 "mbox.c"
static int getTextPart(message * const  *messages , size_t size ) 
{ size_t i ;
  int textpart ;
  char const   *tmp ;
  int tmp___0 ;
  mime_type tmp___1 ;

  {
#line 2822
  textpart = -1;
#line 2824
  i = 0U;
#line 2824
  while (i < size) {
#line 2826
    tmp___1 = messageGetMimeType((message const   *)(*(messages + i)));
#line 2826
    if ((int )tmp___1 == 6) {
#line 2827
      tmp = messageGetMimeSubtype((message const   *)(*(messages + i)));
#line 2827
      tmp___0 = strcasecmp(tmp, "html");
#line 2827
      if (tmp___0 == 0) {
#line 2828
        return ((int )i);
      }
#line 2829
      textpart = (int )i;
    }
#line 2824
    i ++;
  }
#line 2832
  return (textpart);
}
}
#line 2849 "mbox.c"
static size_t strip(char *buf , int len ) 
{ register char *ptr ;
  register size_t i ;
  unsigned short const   **tmp ;

  {
#line 2855
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 2856
    return (0U);
  } else {
#line 2855
    if (len <= 0) {
#line 2856
      return (0U);
    }
  }
#line 2858
  i = strlen((char const   *)buf);
#line 2859
  if (len > (int )(i + 1U)) {
#line 2860
    return (i);
  }
#line 2861
  len --;
#line 2861
  ptr = buf + len;
#line 2864
  while (1) {
#line 2865
    if ((*ptr)) {
#line 2866
      (*ptr) = (char )'\000';
    }
#line 2864
    len --;
#line 2864
    if (len >= 0) {
#line 2864
      tmp = __ctype_b_loc();
#line 2864
      ptr --;
#line 2864
      if ((int const   )(*((*tmp) + (int )(*ptr))) & 32768) {
#line 2864
        break;
      } else {
#line 2864
        if ((int )(*ptr) != 10) {
#line 2864
          if (! ((int )(*ptr) != 13)) {
#line 2864
            break;
          }
        } else {
#line 2864
          break;
        }
      }
    } else {
#line 2864
      break;
    }
  }
#line 2876
  return ((unsigned int )(len + 1));
}
}
#line 2883 "mbox.c"
size_t strstrip(char *s ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 2886
  if ((unsigned int )s == (unsigned int )((char *)((void *)0))) {
#line 2887
    return (0U);
  }
#line 2889
  tmp = strlen((char const   *)s);
#line 2889
  tmp___0 = strip(s, (int )(tmp + 1U));
#line 2889
  return (tmp___0);
}
}
#line 2896 "mbox.c"
static bool continuationMarker(char const   *line ) 
{ char const   *ptr ;
  size_t tmp ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 2901
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 2902
    return ((enum __anonenum_bool_35 )0);
  }
#line 2908
  tmp = strlen(line);
#line 2908
  if (tmp == 0U) {
#line 2909
    return ((enum __anonenum_bool_35 )0);
  }
#line 2911
  tmp___4 = __builtin_constant_p((int )line);
#line 2911
  if (tmp___4) {
#line 2911
    ptr = (char const   *)__builtin_strchr(line, '\000');
  } else {
#line 2911
    tmp___3 = __rawmemchr((void const   *)line, '\000');
#line 2911
    ptr = (char const   *)((char *)tmp___3);
  }
#line 2915
  while ((unsigned int )ptr > (unsigned int )line) {
#line 2916
    ptr --;
#line 2916
    switch ((int )(*ptr)) {
    case 10: ;
    case 13: ;
    case 32: ;
    case 9: ;
#line 2921
    continue;
    case 59: ;
#line 2923
    return ((enum __anonenum_bool_35 )1);
    default: ;
#line 2925
    return ((enum __anonenum_bool_35 )0);
    }
  }
#line 2928
  return ((enum __anonenum_bool_35 )0);
}
}
#line 2931 "mbox.c"
static int parseMimeHeader(message *m , char const   *cmd , table_t const   *rfc821Table ,
                           char const   *arg ) 
{ char *copy ;
  char *p ;
  char const   *ptr ;
  int commandNumber ;
  int i ;
  char *mimeArgs ;
  unsigned short const   **tmp ;
  char *s ;
  char *mimeType ;
  char *strptr ;
  int set ;
  char *tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___17 ;
  size_t len ;
  size_t tmp___18 ;
  char *t ;
  char *tmp___19 ;
  char *tmp___23 ;
  int tmp___25 ;
  unsigned short const   **tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___32 ;
  int tmp___34 ;

  {
#line 2938
  cli_dbgmsg("parseMimeHeader: cmd=\'%s\', arg=\'%s\'\n", cmd, arg);
#line 2940
  copy = rfc822comments(cmd, (char *)((void *)0));
#line 2941
  if (copy) {
#line 2942
    commandNumber = tableFind(rfc821Table, (char const   *)copy);
#line 2943
    free((void *)copy);
  } else {
#line 2945
    commandNumber = tableFind(rfc821Table, cmd);
  }
#line 2947
  copy = rfc822comments(arg, (char *)((void *)0));
#line 2949
  if (copy) {
#line 2950
    ptr = (char const   *)copy;
  } else {
#line 2952
    ptr = arg;
  }
#line 2954
  switch (commandNumber) {
  case 1: ;
#line 2962
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 2972
    cli_warnmsg("Empty content-type received, no subtype specified, assuming text/plain; charset=us-ascii\n");
  } else {
#line 2973
    tmp___34 = __builtin_constant_p((int )ptr);
#line 2973
    if (tmp___34) {
#line 2973
      tmp___32 = (char *)__builtin_strchr(ptr, '/');
    } else {
#line 2973
      tmp___32 = (char *)__builtin_strchr(ptr, '/');
    }
#line 2973
    if ((unsigned int )tmp___32 == (unsigned int )((void *)0)) {
#line 2980
      cli_dbgmsg("Invalid content-type \'%s\' received, no subtype specified, assuming text/plain; charset=us-ascii\n",
                 ptr);
    } else {
#line 2989
      if ((int const   )(*arg) == 47) {
#line 2990
        cli_warnmsg("Content-type \'/\' received, assuming application/octet-stream\n");
#line 2991
        messageSetMimeType(m, "application");
#line 2992
        messageSetMimeSubtype(m, "octet-stream");
      } else {
#line 3001
        while (1) {
#line 3001
          tmp = __ctype_b_loc();
#line 3001
          if (! ((int const   )(*((*tmp) + (int )(*ptr))) & 8192)) {
#line 3001
            break;
          }
#line 3002
          ptr ++;
        }
#line 3003
        if ((int const   )(*(ptr + 0)) == 34) {
#line 3004
          ptr ++;
        }
#line 3006
        if ((int const   )(*(ptr + 0)) != 47) {
#line 3013
          mimeType = cli_strtok(ptr, 0, ";");
#line 3013
          s = mimeType;
#line 3020
          if (s) {
#line 3020
            if ((*s)) {
#line 3020
              while (1) {
#line 3022
                tmp___8 = __builtin_constant_p((int )"/");
#line 3022
                if (tmp___8) {
#line 3022
                  if ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") ==
                      1U) {
#line 3022
                    if ((int const   )(*("/" + 0)) != 0) {
#line 3022
                      if ((int const   )(*("/" + 1)) == 0) {
#line 3022
                        tmp___5 = __strtok_r_1c__extinline(s, (char )(*("/" + 0)),
                                                           & strptr);
                      } else {
#line 3022
                        tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                             (char ** __restrict  )(& strptr));
                      }
                    } else {
#line 3022
                      tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                           (char ** __restrict  )(& strptr));
                    }
                  } else {
#line 3022
                    tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                         (char ** __restrict  )(& strptr));
                  }
                } else {
#line 3022
                  tmp___5 = __strtok_r((char * __restrict  )s, (char const   * __restrict  )"/",
                                       (char ** __restrict  )(& strptr));
                }
#line 3022
                tmp___9 = messageSetMimeType(m, (char const   *)tmp___5);
#line 3022
                set = tmp___9;
#line 3034
                tmp___17 = __builtin_constant_p((int )";");
#line 3034
                if (tmp___17) {
#line 3034
                  if ((unsigned int )((void const   *)(";" + 1)) - (unsigned int )((void const   *)";") ==
                      1U) {
#line 3034
                    if ((int const   )(*(";" + 0)) != 0) {
#line 3034
                      if ((int const   )(*(";" + 1)) == 0) {
#line 3034
                        s = __strtok_r_1c__extinline((char *)((void *)0), (char )(*(";" +
                                                                                    0)),
                                                     & strptr);
                      } else {
#line 3034
                        s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                       (char ** __restrict  )(& strptr));
                      }
                    } else {
#line 3034
                      s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                     (char ** __restrict  )(& strptr));
                    }
                  } else {
#line 3034
                    s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                   (char ** __restrict  )(& strptr));
                  }
                } else {
#line 3034
                  s = __strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )";",
                                 (char ** __restrict  )(& strptr));
                }
#line 3038
                if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 3039
                  break;
                }
#line 3040
                if (set) {
#line 3041
                  tmp___18 = strstrip(s);
#line 3041
                  len = tmp___18 - 1U;
#line 3042
                  if ((int )(*(s + len)) == 34) {
#line 3043
                    (*(s + len)) = (char )'\000';
#line 3044
                    len = strstrip(s);
                  }
#line 3046
                  if (len) {
#line 3047
                    tmp___25 = __builtin_constant_p((int )s);
#line 3047
                    if (tmp___25) {
#line 3047
                      tmp___23 = (char *)__builtin_strchr(s, ' ');
                    } else {
#line 3047
                      tmp___23 = (char *)__builtin_strchr(s, ' ');
                    }
#line 3047
                    if (tmp___23) {
#line 3048
                      tmp___19 = cli_strtok((char const   *)s, 0, " ");
#line 3048
                      t = tmp___19;
#line 3050
                      messageSetMimeSubtype(m, (char const   *)t);
#line 3051
                      free((void *)t);
                    } else {
#line 3053
                      messageSetMimeSubtype(m, (char const   *)s);
                    }
                  }
                }
#line 3057
                while (1) {
#line 3057
                  if ((*s)) {
#line 3057
                    tmp___26 = __ctype_b_loc();
#line 3057
                    if ((int const   )(*((*tmp___26) + (int )(*s))) & 8192) {
#line 3057
                      break;
                    }
                  } else {
#line 3057
                    break;
                  }
#line 3058
                  s ++;
                }
#line 3059
                tmp___27 = s;
#line 3059
                s ++;
#line 3059
                if ((int )(*tmp___27) == 0) {
#line 3060
                  break;
                }
#line 3061
                if ((int )(*s) == 0) {
#line 3062
                  break;
                }
              }
            }
          }
#line 3064
          if (mimeType) {
#line 3065
            free((void *)mimeType);
          }
        }
      }
#line 3075
      i = 1;
#line 3076
      while (1) {
#line 3076
        tmp___28 = i;
#line 3076
        i ++;
#line 3076
        mimeArgs = cli_strtok(ptr, tmp___28, ";");
#line 3076
        if (! ((unsigned int )mimeArgs != (unsigned int )((void *)0))) {
#line 3076
          break;
        }
#line 3077
        cli_dbgmsg("mimeArgs = \'%s\'\n", mimeArgs);
#line 3079
        messageAddArguments(m, (char const   *)mimeArgs);
#line 3080
        free((void *)mimeArgs);
      }
    }
  }
#line 3083
  break;
  case 2: 
#line 3085
  messageSetEncoding(m, ptr);
#line 3086
  break;
  case 3: 
#line 3088
  p = cli_strtok(ptr, 0, ";");
#line 3089
  if (p) {
#line 3090
    if ((*p)) {
#line 3091
      messageSetDispositionType(m, (char const   *)p);
#line 3092
      free((void *)p);
#line 3093
      p = cli_strtok(ptr, 1, ";");
#line 3094
      messageAddArgument(m, (char const   *)p);
    }
#line 3096
    free((void *)p);
  }
  }
#line 3099
  if (copy) {
#line 3100
    free((void *)copy);
  }
#line 3102
  return (0);
}
}
#line 3108 "mbox.c"
static void saveTextPart(message *m , char const   *dir ) 
{ fileblob *fb ;

  {
#line 3113
  messageAddArgument(m, "filename=textportion");
#line 3114
  fb = messageToFileblob(m, dir);
#line 3114
  if ((unsigned int )fb != (unsigned int )((void *)0)) {
#line 3118
    cli_dbgmsg("Saving main message\n");
#line 3120
    fileblobDestroy(fb);
  }
#line 3122
  return;
}
}
#line 3132 "mbox.c"
static char *rfc822comments(char const   *in , char *out ) 
{ char const   *iptr ;
  char *optr ;
  int backslash ;
  int inquote ;
  int commentlevel ;
  char *tmp___2 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 3139
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 3140
    return ((char *)((void *)0));
  }
#line 3142
  tmp___4 = __builtin_constant_p((int )in);
#line 3142
  if (tmp___4) {
#line 3142
    tmp___2 = (char *)__builtin_strchr(in, '(');
  } else {
#line 3142
    tmp___2 = (char *)__builtin_strchr(in, '(');
  }
#line 3142
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 3143
    return ((char *)((void *)0));
  }
#line 3147
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 3148
    tmp___5 = strlen(in);
#line 3148
    out = (char *)cli_malloc(tmp___5 + 1U);
#line 3149
    if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 3150
      return ((char *)((void *)0));
    }
  }
#line 3153
  inquote = 0;
#line 3153
  commentlevel = inquote;
#line 3153
  backslash = commentlevel;
#line 3154
  optr = out;
#line 3156
  cli_dbgmsg("rfc822comments: contains a comment\n");
#line 3158
  iptr = in;
#line 3158
  while ((*iptr)) {
#line 3159
    if (backslash) {
#line 3160
      if (commentlevel == 0) {
#line 3161
        tmp___6 = optr;
#line 3161
        optr ++;
#line 3161
        (*tmp___6) = (char )(*iptr);
      }
#line 3162
      backslash = 0;
    } else {
#line 3163
      switch ((int )(*iptr)) {
      case 92: 
#line 3165
      backslash = 1;
#line 3166
      break;
      case 34: 
#line 3168
      tmp___7 = optr;
#line 3168
      optr ++;
#line 3168
      (*tmp___7) = (char )'\"';
#line 3169
      inquote = (! inquote != 0) != 0;
#line 3170
      break;
      case 40: ;
#line 3172
      if (inquote) {
#line 3173
        tmp___8 = optr;
#line 3173
        optr ++;
#line 3173
        (*tmp___8) = (char )'(';
      } else {
#line 3175
        commentlevel ++;
      }
#line 3176
      break;
      case 41: ;
#line 3178
      if (inquote) {
#line 3179
        tmp___9 = optr;
#line 3179
        optr ++;
#line 3179
        (*tmp___9) = (char )')';
      } else {
#line 3180
        if (commentlevel > 0) {
#line 3181
          commentlevel --;
        }
      }
#line 3182
      break;
      default: ;
#line 3184
      if (commentlevel == 0) {
#line 3185
        tmp___10 = optr;
#line 3185
        optr ++;
#line 3185
        (*tmp___10) = (char )(*iptr);
      }
      }
    }
#line 3158
    iptr ++;
  }
#line 3188
  if (backslash) {
#line 3189
    tmp___11 = optr;
#line 3189
    optr ++;
#line 3189
    (*tmp___11) = (char )'\\';
  }
#line 3190
  (*optr) = (char )'\000';
#line 3194
  cli_dbgmsg("rfc822comments \'%s\'=>\'%s\'\n", in, out);
#line 3196
  return (out);
}
}
#line 3203 "mbox.c"
static char *rfc2047(char const   *in ) 
{ char *out ;
  char *pout ;
  size_t len ;
  char *tmp___10 ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char encoding___0 ;
  char *ptr ;
  char *enctext ;
  message *m ;
  blob *b ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___26 ;
  int tmp___27 ;
  __int32_t const   **tmp___28 ;
  size_t __len___6 ;
  size_t tmp___45 ;
  char *__retval___6 ;
  char *tmp___46 ;
  int tmp___48 ;
  unsigned char *tmp___49 ;
  void const   * __restrict  tmp___50 ;

  {
#line 3209
  tmp___20 = strstr(in, "=?");
#line 3209
  if ((unsigned int )tmp___20 == (unsigned int )((void *)0)) {
    goto _L;
  } else {
#line 3209
    tmp___21 = strstr(in, "?=");
#line 3209
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
      _L: 
#line 3210
      tmp___19 = __builtin_constant_p((int )in);
#line 3210
      if (tmp___19) {
#line 3210
        if ((unsigned int )((void const   *)(in + 1)) - (unsigned int )((void const   *)in) ==
            1U) {
#line 3210
          if ((int const   )(*(in + 0)) == 0) {
#line 3210
            tmp___10 = (char *)calloc(1U, 1U);
          } else {
#line 3210
            tmp___16 = strlen(in);
#line 3210
            __len___2 = tmp___16 + 1U;
#line 3210
            tmp___17 = (char *)malloc(__len___2);
#line 3210
            __retval___2 = tmp___17;
#line 3210
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 3210
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )in,
                                            __len___2);
            }
#line 3210
            tmp___10 = __retval___2;
          }
        } else {
#line 3210
          tmp___10 = __strdup(in);
        }
      } else {
#line 3210
        tmp___10 = __strdup(in);
      }
#line 3210
      return (tmp___10);
    }
  }
#line 3212
  cli_dbgmsg("rfc2047 \'%s\'\n", in);
#line 3213
  tmp___22 = strlen(in);
#line 3213
  out = (char *)cli_malloc(tmp___22 + 1U);
#line 3215
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 3216
    return ((char *)((void *)0));
  }
#line 3218
  pout = out;
#line 3221
  while ((*in)) {
#line 3227
    while ((*in)) {
#line 3228
      if ((int const   )(*in) == 61) {
#line 3228
        if ((int const   )(*(in + 1)) == 63) {
#line 3229
          in += 2;
#line 3230
          break;
        }
      }
#line 3232
      tmp___23 = pout;
#line 3232
      pout ++;
#line 3232
      tmp___24 = in;
#line 3232
      in ++;
#line 3232
      (*tmp___23) = (char )(*tmp___24);
    }
#line 3235
    while (1) {
#line 3235
      if ((int const   )(*in) != 63) {
#line 3235
        if (! (*in)) {
#line 3235
          break;
        }
      } else {
#line 3235
        break;
      }
#line 3236
      in ++;
    }
#line 3237
    if ((int const   )(*in) == 0) {
#line 3238
      break;
    }
#line 3239
    in ++;
#line 3239
    encoding___0 = (char )(*in);
#line 3240
    if (sizeof(encoding___0) > 1U) {
#line 3240
      tmp___27 = __builtin_constant_p((int )encoding___0);
#line 3240
      if (tmp___27) {
#line 3240
        __c = (int )encoding___0;
#line 3240
        if (__c < -128) {
#line 3240
          __res = __c;
        } else {
#line 3240
          if (__c > 255) {
#line 3240
            __res = __c;
          } else {
#line 3240
            tmp___26 = __ctype_tolower_loc();
#line 3240
            __res = (*((*tmp___26) + __c));
          }
        }
      } else {
#line 3240
        __res = tolower__extinline((int )encoding___0);
      }
    } else {
#line 3240
      tmp___28 = __ctype_tolower_loc();
#line 3240
      __res = (*((*tmp___28) + (int )encoding___0));
    }
#line 3240
    encoding___0 = (char )__res;
#line 3242
    if ((int )encoding___0 != 113) {
#line 3242
      if ((int )encoding___0 != 98) {
#line 3243
        cli_warnmsg("Unsupported RFC2047 encoding type \'%c\' - if you believe this file contains a virus that was missed, report it to bugs@clamav.net\n",
                    encoding___0);
#line 3244
        free((void *)out);
#line 3245
        out = (char *)((void *)0);
#line 3246
        break;
      }
    }
#line 3249
    in ++;
#line 3249
    if ((int const   )(*in) != 63) {
#line 3250
      break;
    }
#line 3251
    in ++;
#line 3251
    if ((int const   )(*in) == 0) {
#line 3252
      break;
    }
#line 3254
    tmp___48 = __builtin_constant_p((int )in);
#line 3254
    if (tmp___48) {
#line 3254
      if ((unsigned int )((void const   *)(in + 1)) - (unsigned int )((void const   *)in) ==
          1U) {
#line 3254
        if ((int const   )(*(in + 0)) == 0) {
#line 3254
          enctext = (char *)calloc(1U, 1U);
        } else {
#line 3254
          tmp___45 = strlen(in);
#line 3254
          __len___6 = tmp___45 + 1U;
#line 3254
          tmp___46 = (char *)malloc(__len___6);
#line 3254
          __retval___6 = tmp___46;
#line 3254
          if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 3254
            __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )in,
                                          __len___6);
          }
#line 3254
          enctext = __retval___6;
        }
      } else {
#line 3254
        enctext = __strdup(in);
      }
    } else {
#line 3254
      enctext = __strdup(in);
    }
#line 3255
    if ((unsigned int )enctext == (unsigned int )((void *)0)) {
#line 3256
      free((void *)out);
#line 3257
      out = (char *)((void *)0);
#line 3258
      break;
    }
#line 3260
    in = strstr(in, "?=");
#line 3261
    if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 3262
      free((void *)enctext);
#line 3263
      break;
    }
#line 3265
    in += 2;
#line 3266
    ptr = strstr((char const   *)enctext, "?=");
#line 3268
    (*ptr) = (char )'\000';
#line 3271
    m = messageCreate();
#line 3272
    if ((unsigned int )m == (unsigned int )((void *)0)) {
#line 3273
      break;
    }
#line 3274
    messageAddStr(m, (char const   *)enctext);
#line 3275
    free((void *)enctext);
#line 3276
    switch ((int )encoding___0) {
    case 113: 
#line 3278
    messageSetEncoding(m, "quoted-printable");
#line 3279
    break;
    case 98: 
#line 3281
    messageSetEncoding(m, "base64");
#line 3282
    break;
    }
#line 3284
    b = messageToBlob(m);
#line 3285
    len = (size_t )blobGetDataSize((blob const   *)b);
#line 3286
    tmp___49 = blobGetData((blob const   *)b);
#line 3286
    cli_dbgmsg("Decoded as \'%*.*s\'\n", len, len, tmp___49);
#line 3287
    tmp___50 = (void const   * __restrict  )blobGetData((blob const   *)b);
#line 3287
    memcpy((void * __restrict  )pout, tmp___50, len);
#line 3288
    blobDestroy(b);
#line 3289
    messageDestroy(m);
#line 3290
    if ((int )(*(pout + (len - 1U))) == 10) {
#line 3291
      pout += len - 1U;
    } else {
#line 3293
      pout += len;
    }
  }
#line 3296
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 3297
    return ((char *)((void *)0));
  }
#line 3299
  (*pout) = (char )'\000';
#line 3301
  cli_dbgmsg("rfc2047 returns \'%s\'\n", out);
#line 3302
  return (out);
}
}
#line 3309 "mbox.c"
static int rfc1341(message *m , char const   *dir ) 
{ fileblob *fb ;
  char *arg ;
  char *id ;
  char *number ;
  char *total ;
  char *oldfilename ;
  char const   *tmpdir ;
  char pdir[256] ;
  struct stat statb ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___9 ;
  int n ;
  int tmp___10 ;
  int t ;
  int tmp___11 ;
  DIR *dd ;
  FILE *fout ;
  char outname[256] ;
  char filename[256] ;
  struct dirent  const  *dent ;
  FILE *fin ;
  char buffer[8192] ;
  int nblanks ;
  int tmp___91 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___127 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___146 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  size_t tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  size_t tmp___165 ;
  size_t tmp___166 ;
  int tmp___167 ;
  size_t tmp___168 ;
  size_t tmp___169 ;
  char *tmp___170 ;

  {
#line 3317
  id = messageFindArgument((message const   *)m, "id");
#line 3318
  if ((unsigned int )id == (unsigned int )((void *)0)) {
#line 3319
    return (-1);
  }
#line 3327
  tmpdir = getenv("TMPDIR");
#line 3327
  if ((unsigned int )tmpdir == (unsigned int )((char *)((void *)0))) {
#line 3328
    tmpdir = getenv("TMP");
#line 3328
    if ((unsigned int )tmpdir == (unsigned int )((char *)((void *)0))) {
#line 3329
      tmpdir = getenv("TEMP");
#line 3329
      if ((unsigned int )tmpdir == (unsigned int )((char *)((void *)0))) {
#line 3331
        tmpdir = "/tmp";
      }
    }
  }
#line 3337
  snprintf((char * __restrict  )(pdir), sizeof(pdir) - 1U, (char const   * __restrict  )"%s/clamav-partial",
           tmpdir);
#line 3339
  tmp___1 = mkdir((char const   *)(pdir), 448U);
#line 3339
  if (tmp___1 < 0) {
#line 3339
    tmp___2 = __errno_location();
#line 3339
    if ((*tmp___2) != 17) {
#line 3340
      cli_errmsg("Can\'t create the directory \'%s\'\n", pdir);
#line 3341
      return (-1);
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 3345
    tmp___0 = stat__extinline((char const   *)(pdir), & statb);
#line 3345
    if (tmp___0 < 0) {
#line 3346
      cli_errmsg("Can\'t stat the directory \'%s\'\n", pdir);
#line 3347
      return (-1);
    }
#line 3349
    if (statb.st_mode & 63U) {
#line 3350
      cli_warnmsg("Insecure partial directory %s (mode 0%o)\n", pdir, statb.st_mode &
                                                                      511U);
    }
  }
#line 3354
  number = messageFindArgument((message const   *)m, "number");
#line 3355
  if ((unsigned int )number == (unsigned int )((void *)0)) {
#line 3356
    free((void *)id);
#line 3357
    return (-1);
  }
#line 3360
  oldfilename = messageFindArgument((message const   *)m, "filename");
#line 3361
  if ((unsigned int )oldfilename == (unsigned int )((void *)0)) {
#line 3362
    oldfilename = messageFindArgument((message const   *)m, "name");
  }
#line 3364
  tmp___6 = strlen((char const   *)id);
#line 3364
  tmp___7 = strlen((char const   *)number);
#line 3364
  arg = (char *)cli_malloc((10U + tmp___6) + tmp___7);
#line 3365
  sprintf((char * __restrict  )arg, (char const   * __restrict  )"filename=%s%s",
          id, number);
#line 3366
  messageAddArgument(m, (char const   *)arg);
#line 3367
  free((void *)arg);
#line 3369
  if (oldfilename) {
#line 3370
    cli_warnmsg("Must reset to %s\n", oldfilename);
#line 3371
    free((void *)oldfilename);
  }
#line 3374
  fb = messageToFileblob(m, (char const   *)(pdir));
#line 3374
  if ((unsigned int )fb == (unsigned int )((void *)0)) {
#line 3375
    free((void *)id);
#line 3376
    free((void *)number);
#line 3377
    return (-1);
  }
#line 3380
  fileblobDestroy(fb);
#line 3382
  total = messageFindArgument((message const   *)m, "total");
#line 3383
  if (total) {
#line 3383
    tmp___9 = (char const   *)total;
  } else {
#line 3383
    tmp___9 = "?";
  }
#line 3383
  cli_dbgmsg("rfc1341: %s, %s of %s\n", id, number, tmp___9);
#line 3384
  if (total) {
#line 3385
    tmp___10 = atoi__extinline((char const   *)number);
#line 3385
    n = tmp___10;
#line 3386
    tmp___11 = atoi__extinline((char const   *)total);
#line 3386
    t = tmp___11;
#line 3387
    dd = (DIR *)((void *)0);
#line 3389
    free((void *)total);
#line 3394
    if (n == t) {
#line 3394
      dd = opendir((char const   *)(pdir));
#line 3394
      if ((unsigned int )dd != (unsigned int )((void *)0)) {
#line 3398
        snprintf((char * __restrict  )(outname), sizeof(outname) - 1U, (char const   * __restrict  )"%s/%s",
                 dir, id);
#line 3400
        cli_dbgmsg("outname: %s\n", outname);
#line 3402
        fout = fopen((char const   * __restrict  )(outname), (char const   * __restrict  )"wb");
#line 3403
        if ((unsigned int )fout == (unsigned int )((void *)0)) {
#line 3404
          cli_errmsg("Can\'t open \'%s\' for writing", outname);
#line 3405
          free((void *)id);
#line 3406
          free((void *)number);
#line 3407
          closedir(dd);
#line 3408
          return (-1);
        }
#line 3411
        n = 1;
#line 3411
        while (n <= t) {
#line 3421
          snprintf((char * __restrict  )(filename), sizeof(filename), (char const   * __restrict  )"%s%d",
                   id, n);
#line 3428
          while (1) {
#line 3428
            dent = readdir(dd);
#line 3428
            if (! dent) {
#line 3428
              break;
            }
#line 3435
            if (dent->d_ino == 0UL) {
#line 3436
              continue;
            }
#line 3438
            tmp___162 = (int )strlen((char const   *)(filename));
#line 3438
            tmp___163 = __builtin_constant_p(tmp___162);
#line 3438
            if (tmp___163) {
#line 3438
              tmp___164 = __builtin_constant_p((int )(filename));
#line 3438
              if (tmp___164) {
#line 3438
                tmp___165 = strlen((char const   *)(filename));
#line 3438
                tmp___166 = strlen((char const   *)(filename));
#line 3438
                if (tmp___165 < tmp___166) {
                  goto _L___40;
                } else {
                  goto _L___41;
                }
              } else {
                _L___41: 
#line 3438
                tmp___167 = __builtin_constant_p((int )(dent->d_name));
#line 3438
                if (tmp___167) {
#line 3438
                  tmp___168 = strlen((char const   *)(dent->d_name));
#line 3438
                  tmp___169 = strlen((char const   *)(filename));
#line 3438
                  if (tmp___168 < tmp___169) {
                    _L___40: 
#line 3438
                    tmp___158 = __builtin_constant_p((int )(filename));
#line 3438
                    if (tmp___158) {
#line 3438
                      tmp___159 = __builtin_constant_p((int )(dent->d_name));
#line 3438
                      if (tmp___159) {
#line 3438
                        __s1_len___0 = strlen((char const   *)(filename));
#line 3438
                        __s2_len___0 = strlen((char const   *)(dent->d_name));
#line 3438
                        if (! ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)(filename)) ==
                               1U)) {
                          goto _L___37;
                        } else {
#line 3438
                          if (__s1_len___0 >= 4U) {
                            _L___37: 
#line 3438
                            if (! ((unsigned int )((void const   *)(dent->d_name +
                                                                    1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                                   1U)) {
#line 3438
                              tmp___160 = 1;
                            } else {
#line 3438
                              if (__s2_len___0 >= 4U) {
#line 3438
                                tmp___160 = 1;
                              } else {
#line 3438
                                tmp___160 = 0;
                              }
                            }
                          } else {
#line 3438
                            tmp___160 = 0;
                          }
                        }
#line 3438
                        if (tmp___160) {
#line 3438
                          tmp___127 = __builtin_strcmp(filename, dent->d_name);
                        } else {
                          goto _L___39;
                        }
                      } else {
                        goto _L___39;
                      }
                    } else {
                      _L___39: 
#line 3438
                      tmp___157 = __builtin_constant_p((int )(filename));
#line 3438
                      if (tmp___157) {
#line 3438
                        if ((unsigned int )((void const   *)(filename + 1)) - (unsigned int )((void const   *)(filename)) ==
                            1U) {
#line 3438
                          __s1_len___0 = strlen((char const   *)(filename));
#line 3438
                          if (__s1_len___0 < 4U) {
#line 3438
                            tmp___146 = __builtin_constant_p((int )(dent->d_name));
#line 3438
                            if (tmp___146) {
#line 3438
                              if ((unsigned int )((void const   *)(dent->d_name +
                                                                   1)) - (unsigned int )((void const   *)(dent->d_name)) ==
                                  1U) {
#line 3438
                                tmp___127 = __builtin_strcmp(filename, dent->d_name);
                              } else {
                                goto _L___32;
                              }
                            } else {
                              _L___32: 
#line 3438
                              __s2___14 = (unsigned char const   *)((char const   *)(dent->d_name));
#line 3438
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
#line 3438
                              if (__s1_len___0 > 0U) {
#line 3438
                                if (__result___42 == 0) {
#line 3438
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
#line 3438
                                  if (__s1_len___0 > 1U) {
#line 3438
                                    if (__result___42 == 0) {
#line 3438
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
#line 3438
                                      if (__s1_len___0 > 2U) {
#line 3438
                                        if (__result___42 == 0) {
#line 3438
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(filename)) +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
#line 3438
                              tmp___127 = __result___42;
                            }
                          } else {
                            goto _L___36;
                          }
                        } else {
                          goto _L___36;
                        }
                      } else {
                        _L___36: 
#line 3438
                        tmp___156 = __builtin_constant_p((int )(dent->d_name));
#line 3438
                        if (tmp___156) {
#line 3438
                          if ((unsigned int )((void const   *)(dent->d_name + 1)) -
                              (unsigned int )((void const   *)(dent->d_name)) == 1U) {
#line 3438
                            __s2_len___0 = strlen((char const   *)(dent->d_name));
#line 3438
                            if (__s2_len___0 < 4U) {
#line 3438
                              tmp___155 = __builtin_constant_p((int )(filename));
#line 3438
                              if (tmp___155) {
#line 3438
                                if ((unsigned int )((void const   *)(filename + 1)) -
                                    (unsigned int )((void const   *)(filename)) ==
                                    1U) {
#line 3438
                                  tmp___127 = __builtin_strcmp(filename, dent->d_name);
                                } else {
                                  goto _L___34;
                                }
                              } else {
                                _L___34: 
#line 3438
                                __s1___30 = (unsigned char const   *)((char const   *)(filename));
#line 3438
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                                               0)));
#line 3438
                                if (__s2_len___0 > 0U) {
#line 3438
                                  if (__result___46 == 0) {
#line 3438
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                            1)));
#line 3438
                                    if (__s2_len___0 > 1U) {
#line 3438
                                      if (__result___46 == 0) {
#line 3438
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                                2)));
#line 3438
                                        if (__s2_len___0 > 2U) {
#line 3438
                                          if (__result___46 == 0) {
#line 3438
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)((char const   *)(dent->d_name)) +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
#line 3438
                                tmp___127 = __result___46;
                              }
                            } else {
#line 3438
                              tmp___127 = __builtin_strcmp(filename, dent->d_name);
                            }
                          } else {
#line 3438
                            tmp___127 = __builtin_strcmp(filename, dent->d_name);
                          }
                        } else {
#line 3438
                          tmp___127 = __builtin_strcmp(filename, dent->d_name);
                        }
                      }
                    }
#line 3438
                    tmp___91 = tmp___127;
                  } else {
#line 3438
                    tmp___161 = strlen((char const   *)(filename));
#line 3438
                    tmp___91 = strncmp((char const   *)(filename), (char const   *)(dent->d_name),
                                       tmp___161);
                  }
                } else {
#line 3438
                  tmp___161 = strlen((char const   *)(filename));
#line 3438
                  tmp___91 = strncmp((char const   *)(filename), (char const   *)(dent->d_name),
                                     tmp___161);
                }
              }
            } else {
#line 3438
              tmp___161 = strlen((char const   *)(filename));
#line 3438
              tmp___91 = strncmp((char const   *)(filename), (char const   *)(dent->d_name),
                                 tmp___161);
            }
#line 3438
            if (tmp___91 != 0) {
#line 3439
              continue;
            }
#line 3441
            sprintf((char * __restrict  )(filename), (char const   * __restrict  )"%s/%s",
                    pdir, dent->d_name);
#line 3442
            fin = fopen((char const   * __restrict  )(filename), (char const   * __restrict  )"rb");
#line 3443
            if ((unsigned int )fin == (unsigned int )((void *)0)) {
#line 3444
              cli_errmsg("Can\'t open \'%s\' for reading", filename);
#line 3445
              fclose(fout);
#line 3446
              unlink((char const   *)(outname));
#line 3447
              free((void *)id);
#line 3448
              free((void *)number);
#line 3449
              closedir(dd);
#line 3450
              return (-1);
            }
#line 3452
            nblanks = 0;
#line 3453
            while (1) {
#line 3453
              tmp___170 = fgets((char * __restrict  )(buffer), (int )sizeof(buffer),
                                (FILE * __restrict  )fin);
#line 3453
              if (! ((unsigned int )tmp___170 != (unsigned int )((void *)0))) {
#line 3453
                break;
              }
#line 3458
              if ((int )buffer[0] == 10) {
#line 3459
                nblanks ++;
              } else {
#line 3461
                if (nblanks) {
#line 3462
                  while (1) {
#line 3463
                    _IO_putc('\n', fout);
#line 3462
                    nblanks --;
#line 3462
                    if (! (nblanks > 0)) {
#line 3462
                      break;
                    }
                  }
                }
#line 3465
                fputs((char const   * __restrict  )(buffer), (FILE * __restrict  )fout);
              }
            }
#line 3467
            fclose(fin);
#line 3470
            if (! cli_leavetemps_flag) {
#line 3471
              unlink((char const   *)(filename));
            }
#line 3472
            break;
          }
#line 3474
          rewinddir(dd);
#line 3411
          n ++;
        }
#line 3476
        closedir(dd);
#line 3477
        fclose(fout);
      }
    }
  }
#line 3480
  free((void *)number);
#line 3481
  free((void *)id);
#line 3483
  return (0);
}
}
#line 3488 "mbox.c"
static void checkURLs(message *m , char const   *dir ) 
{ blob *b ;
  blob *tmp ;
  size_t len ;
  table_t *t ;
  int i ;
  int n ;
  pthread_t tid[5] ;
  struct arg args[5] ;
  tag_arguments_t hrefs ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  char const   *url ;
  char *ptr ;
  char name[256] ;
  int tmp___2 ;
  size_t __len___2 ;
  size_t tmp___19 ;
  char *__retval___2 ;
  char *tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 3491
  tmp = messageToBlob(m);
#line 3491
  b = tmp;
#line 3501
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 3502
    return;
  }
#line 3504
  len = (size_t )blobGetDataSize((blob const   *)b);
#line 3506
  if (len == 0U) {
#line 3507
    blobDestroy(b);
#line 3508
    return;
  }
#line 3512
  if (len > 102400U) {
#line 3513
    cli_warnmsg("Viruses pointed to by URL not scanned in large message\n");
#line 3514
    blobDestroy(b);
#line 3515
    return;
  }
#line 3518
  blobClose(b);
#line 3519
  t = tableCreate();
#line 3520
  if ((unsigned int )t == (unsigned int )((void *)0)) {
#line 3521
    blobDestroy(b);
#line 3522
    return;
  }
#line 3525
  hrefs.count = 0;
#line 3526
  hrefs.value = (unsigned char **)((void *)0);
#line 3526
  hrefs.tag = hrefs.value;
#line 3528
  cli_dbgmsg("checkURLs: calling html_normalise_mem\n");
#line 3529
  tmp___0 = blobGetData((blob const   *)b);
#line 3529
  tmp___1 = html_normalise_mem(tmp___0, (long )len, (char const   *)((void *)0), & hrefs);
#line 3529
  if (! tmp___1) {
#line 3530
    blobDestroy(b);
#line 3531
    tableDestroy(t);
#line 3532
    return;
  }
#line 3534
  cli_dbgmsg("checkURLs: html_normalise_mem returned\n");
#line 3538
  n = 0;
#line 3540
  i = 0;
#line 3540
  while (i < hrefs.count) {
#line 3541
    url = (char const   *)(*(hrefs.value + i));
#line 3543
    tmp___23 = strncasecmp("http://", url, 7U);
#line 3543
    if (tmp___23 == 0) {
#line 3559
      tmp___2 = tableFind((table_t const   *)t, url);
#line 3559
      if (tmp___2 == 1) {
#line 3560
        cli_dbgmsg("URL %s already downloaded\n", url);
        goto __Cont;
      }
#line 3563
      if (n == 5) {
#line 3564
        cli_warnmsg("Not all URLs will be scanned\n");
#line 3565
        break;
      }
#line 3567
      tableInsert(t, url, 1);
#line 3568
      cli_dbgmsg("Downloading URL %s to be scanned\n", url);
#line 3569
      __builtin_strncpy(name, url, sizeof(name) - 1U);
#line 3570
      name[sizeof(name) - 1U] = (char )'\000';
#line 3571
      ptr = name;
#line 3571
      while ((*ptr)) {
#line 3572
        if ((int )(*ptr) == 47) {
#line 3573
          (*ptr) = (char )'_';
        }
#line 3571
        ptr ++;
      }
#line 3577
      args[n].dir = dir;
#line 3578
      args[n].url = url;
#line 3579
      tmp___22 = __builtin_constant_p((int )(name));
#line 3579
      if (tmp___22) {
#line 3579
        if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)(name)) ==
            1U) {
#line 3579
          if ((int const   )(*((char const   *)(name) + 0)) == 0) {
#line 3579
            args[n].filename = (char *)calloc(1U, 1U);
          } else {
#line 3579
            tmp___19 = strlen((char const   *)(name));
#line 3579
            __len___2 = tmp___19 + 1U;
#line 3579
            tmp___20 = (char *)malloc(__len___2);
#line 3579
            __retval___2 = tmp___20;
#line 3579
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 3579
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )(name),
                                            __len___2);
            }
#line 3579
            args[n].filename = __retval___2;
          }
        } else {
#line 3579
          args[n].filename = __strdup((char const   *)(name));
        }
      } else {
#line 3579
        args[n].filename = __strdup((char const   *)(name));
      }
#line 3580
      pthread_create((pthread_t * __restrict  )(& tid[n]), (pthread_attr_t const   * __restrict  )((void *)0),
                     & getURL, (void * __restrict  )(& args[n]));
#line 3624
      n ++;
    }
    __Cont: 
#line 3540
    i ++;
  }
#line 3627
  blobDestroy(b);
#line 3628
  tableDestroy(t);
#line 3632
  cli_dbgmsg("checkURLs: waiting for %d thread(s) to finish\n", n);
#line 3633
  while (1) {
#line 3633
    n --;
#line 3633
    if (! (n >= 0)) {
#line 3633
      break;
    }
#line 3634
    pthread_join(tid[n], (void **)((void *)0));
#line 3635
    free((void *)args[n].filename);
  }
#line 3638
  html_tag_arg_free(& hrefs);
#line 3639
  return;
}
}
#line 3652 "mbox.c"
static int initialised  =    0;
#line 3654 "mbox.c"
static struct __anonstruct_pthread_mutex_t_16 init_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
#line 3642 "mbox.c"
static void *getURL(void *a ) 
{ CURL *curl ;
  FILE *fp ;
  struct curl_slist *headers ;
  struct arg *arg ;
  char const   *url ;
  char const   *dir ;
  char const   *filename ;
  char fout[256] ;
  CURLcode tmp ;
  CURLcode tmp___0 ;
  CURLcode tmp___1 ;
  CURLcode tmp___2 ;

  {
#line 3655
  arg = (struct arg *)a;
#line 3657
  url = arg->url;
#line 3658
  dir = arg->dir;
#line 3659
  filename = (char const   *)arg->filename;
#line 3666
  pthread_mutex_lock(& init_mutex);
#line 3668
  if (! initialised) {
#line 3669
    tmp = curl_global_init(0L);
#line 3669
    if ((int )tmp != 0) {
#line 3671
      pthread_mutex_unlock(& init_mutex);
#line 3673
      return ((void *)0);
    }
#line 3675
    initialised = 1;
  }
#line 3678
  pthread_mutex_unlock(& init_mutex);
#line 3682
  curl = curl_easy_init();
#line 3683
  if ((unsigned int )curl == (unsigned int )((void *)0)) {
#line 3684
    return ((void *)0);
  }
#line 3686
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10018, "www.clamav.net");
#line 3688
  tmp___0 = curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10002, url);
#line 3688
  if ((int )tmp___0 != 0) {
#line 3689
    return ((void *)0);
  }
#line 3691
  snprintf((char * __restrict  )(fout), 255U, (char const   * __restrict  )"%s/%s",
           dir, filename);
#line 3693
  fp = fopen((char const   * __restrict  )(fout), (char const   * __restrict  )"w");
#line 3695
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 3696
    cli_errmsg("Can\'t open \'%s\' for writing", fout);
#line 3697
    curl_easy_cleanup(curl);
#line 3698
    return ((void *)0);
  }
#line 3701
  tmp___1 = curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10001, fp);
#line 3701
  if ((int )tmp___1 != 0) {
#line 3702
    fclose(fp);
#line 3703
    curl_easy_cleanup(curl);
#line 3704
    return ((void *)0);
  }
#line 3718
  headers = curl_slist_append((struct curl_slist *)((void *)0), "Pragma:");
#line 3719
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10023, headers);
#line 3722
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )13, 30);
#line 3723
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )78, 10);
#line 3738
  curl_easy_setopt(curl, (enum __anonenum_CURLoption_43 )10005, "username:password");
#line 3759
  tmp___2 = curl_easy_perform(curl);
#line 3759
  if ((int )tmp___2 != 0) {
#line 3763
    cli_warnmsg("URL %s failed to download\n", url);
  }
#line 3767
  fclose(fp);
#line 3768
  curl_slist_free_all(headers);
#line 3769
  curl_easy_cleanup(curl);
#line 3771
  return ((void *)0);
}
}
#line 3820 "mbox.c"
static bool usefulHeader(int commandNumber , char const   *cmd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3823
  switch (commandNumber) {
  case 2: ;
  case 3: ;
  case 1: ;
#line 3827
  return ((enum __anonenum_bool_35 )1);
  default: 
#line 3829
  tmp___1 = strcasecmp(cmd, "From");
#line 3829
  if (tmp___1 == 0) {
#line 3830
    return ((enum __anonenum_bool_35 )1);
  } else {
#line 3831
    tmp___0 = strcasecmp(cmd, "Received");
#line 3831
    if (tmp___0 == 0) {
#line 3832
      return ((enum __anonenum_bool_35 )1);
    } else {
#line 3833
      tmp = strcasecmp(cmd, "De");
#line 3833
      if (tmp == 0) {
#line 3834
        return ((enum __anonenum_bool_35 )1);
      }
    }
  }
  }
#line 3837
  return ((enum __anonenum_bool_35 )0);
}
}
#line 3844 "mbox.c"
static void uufasttrack(message *m , char const   *firstline , char const   *dir ,
                        FILE *fin ) 
{ fileblob *fb ;
  fileblob *tmp ;
  char buffer[1001] ;
  char *filename ;
  char *tmp___0 ;
  unsigned char data[1024] ;
  unsigned char const   *uptr ;
  size_t len ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 3847
  tmp = fileblobCreate();
#line 3847
  fb = tmp;
#line 3849
  tmp___0 = cli_strtok(firstline, 2, " ");
#line 3849
  filename = tmp___0;
#line 3851
  fileblobSetFilename(fb, dir, (char const   *)filename);
#line 3852
  cli_dbgmsg("Fast track uudecode %s\n", filename);
#line 3853
  free((void *)filename);
#line 3855
  while (1) {
#line 3855
    tmp___3 = fgets((char * __restrict  )(buffer), (int )(sizeof(buffer) - 1U), (FILE * __restrict  )fin);
#line 3855
    if (! ((unsigned int )tmp___3 != (unsigned int )((void *)0))) {
#line 3855
      break;
    }
#line 3860
    cli_chomp(buffer);
#line 3861
    tmp___1 = strcasecmp((char const   *)(buffer), "end");
#line 3861
    if (tmp___1 == 0) {
#line 3862
      break;
    }
#line 3863
    if ((int )buffer[0] == 0) {
#line 3864
      break;
    }
#line 3866
    uptr = decodeLine(m, (enum __anonenum_encoding_type_32 )5, (char const   *)(buffer),
                      data, sizeof(data));
#line 3867
    if ((unsigned int )uptr == (unsigned int )((void *)0)) {
#line 3868
      break;
    }
#line 3870
    len = (unsigned int )(uptr - (unsigned char const   *)(data));
#line 3871
    if (len > 62U) {
#line 3872
      break;
    } else {
#line 3871
      if (len == 0U) {
#line 3872
        break;
      }
    }
#line 3874
    tmp___2 = fileblobAddData(fb, (unsigned char const   *)(data), len);
#line 3874
    if (tmp___2 < 0) {
#line 3875
      break;
    }
  }
#line 3878
  fileblobDestroy(fb);
#line 3879
  return;
}
}
#line 3884 "mbox.c"
static char *getline(char *buffer , size_t len , FILE *fin ) 
{ char *ret ;
  int tmp ;
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 3889
  tmp = feof(fin);
#line 3889
  if (tmp) {
#line 3890
    return ((char *)((void *)0));
  }
#line 3892
  if (len == 0U) {
#line 3893
    cli_errmsg("Invalid call to getline(). Report to bugs@clamav.net\n");
#line 3894
    return ((char *)((void *)0));
  } else {
#line 3892
    if ((unsigned int )buffer == (unsigned int )((void *)0)) {
#line 3893
      cli_errmsg("Invalid call to getline(). Report to bugs@clamav.net\n");
#line 3894
      return ((char *)((void *)0));
    }
  }
#line 3897
  ret = buffer;
#line 3899
  while (1) {
#line 3900
    tmp___0 = _IO_getc(fin);
#line 3900
    c = tmp___0;
#line 3902
    tmp___1 = ferror(fin);
#line 3902
    if (tmp___1) {
#line 3903
      return ((char *)((void *)0));
    }
#line 3905
    switch (c) {
    case 10: 
#line 3907
    tmp___2 = buffer;
#line 3907
    buffer ++;
#line 3907
    (*tmp___2) = (char )'\n';
#line 3908
    c = _IO_getc(fin);
#line 3909
    if (c != 13) {
#line 3909
      tmp___3 = feof(fin);
#line 3909
      if (! tmp___3) {
#line 3910
        ungetc(c, fin);
      }
    }
#line 3911
    break;
    default: 
#line 3913
    tmp___4 = buffer;
#line 3913
    buffer ++;
#line 3913
    (*tmp___4) = (char )c;
    goto __Cont;
    case -1: ;
#line 3916
    break;
    case 13: 
#line 3918
    tmp___5 = buffer;
#line 3918
    buffer ++;
#line 3918
    (*tmp___5) = (char )'\n';
#line 3919
    c = _IO_getc(fin);
#line 3920
    if (c != 10) {
#line 3920
      tmp___6 = feof(fin);
#line 3920
      if (! tmp___6) {
#line 3921
        ungetc(c, fin);
      }
    }
#line 3922
    break;
    }
#line 3924
    break;
    __Cont: 
#line 3899
    len --;
#line 3899
    if (! (len > 0U)) {
#line 3899
      break;
    }
  }
#line 3927
  if (len == 0U) {
#line 3929
    cli_dbgmsg("getline: buffer overflow stopped\n");
#line 3930
    return ((char *)((void *)0));
  }
#line 3932
  (*buffer) = (char )'\000';
#line 3934
  return (ret);
}
}
#line 1 "message.lo"
#pragma merger(0,"/tmp/cil-0fW8qcUt.i","-g -O2 -fPIC")
#line 47 "line.h"
line_t *lineCreate(char const   *data ) ;
#line 48
line_t *lineLink(line_t *line ) ;
#line 49
line_t *lineUnlink(line_t *line ) ;
#line 51
unsigned char lineGetRefCount(line_t const   *line ) ;
#line 62 "message.h"
int messageAddStrAtTop(message *m , char const   *data ) ;
#line 67
text *messageToText(message *m ) ;
#line 70
text const   *yEncBegin(message const   *m ) ;
#line 73
void messageClearMarkers(message *m ) ;
#line 44 "text.h"
text *textClean(text *t_head ) ;
#line 47
blob *textToBlob(text const   *t , blob *b ) ;
#line 70 "message.c"
static void messageIsEncoding(message *m ) ;
#line 71
static unsigned char *decode(message *m , char const   *in , unsigned char *out ,
                             unsigned char (*decoder)(char  ) , bool isFast ) ;
#line 72
static void sanitiseBase64(char *s ) ;
#line 73
static unsigned char hex(char c ) ;
#line 74
static unsigned char base64(char c ) ;
#line 75
static unsigned char uudecode(char c ) ;
#line 76
static char const   *messageGetArgument(message const   *m , int arg ) ;
#line 77
static void *messageExport(message *m , char const   *dir , void *(*create)(void) ,
                           void (*destroy)(void * ) , void (*setFilename)(void * ,
                                                                          char const   * ,
                                                                          char const   * ) ,
                           void (*addData)(void * , unsigned char const   * , size_t  ) ,
                           void *(*exportText)(text const   * , void * ) ) ;
#line 78
static int usefulArg(char const   *arg ) ;
#line 79
static void messageDedup(message *m ) ;
#line 80
static char *rfc2231(char const   *in ) ;
#line 81
static int simil(char const   *str1 , char const   *str2 ) ;
#line 87 "message.c"
static struct encoding_map  const  encoding_map[13]  = 
#line 87
  {      {"7bit", (encoding_type )0}, 
        {"text/plain", (encoding_type )0}, 
        {"quoted-printable", (encoding_type )1}, 
        {"base64", (encoding_type )2}, 
        {"8bit", (encoding_type )3}, 
        {"binary", (encoding_type )4}, 
        {"x-uuencode", (encoding_type )5}, 
        {"x-yencode", (encoding_type )6}, 
        {"x-binhex", (encoding_type )8}, 
        {"us-ascii", (encoding_type )0}, 
        {"x-uue", (encoding_type )5}, 
        {"uuencode", (encoding_type )5}, 
        {(char const   *)((void *)0), (encoding_type )0}};
#line 106 "message.c"
static struct mime_map mime_map[8]  = 
#line 106
  {      {"text", (mime_type )6}, 
        {"multipart", (mime_type )5}, 
        {"application", (mime_type )1}, 
        {"audio", (mime_type )2}, 
        {"image", (mime_type )3}, 
        {"message", (mime_type )4}, 
        {"video", (mime_type )7}, 
        {(char const   *)((void *)0), (mime_type )6}};
#line 126 "message.c"
static unsigned char const   base64Table[256]  = 
#line 126
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )62, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22, 
        (unsigned char const   )23,      (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255};
#line 146 "message.c"
message *messageCreate(void) 
{ message *m ;
  message *tmp ;

  {
#line 149
  tmp = (message *)cli_calloc(1U, sizeof(message ));
#line 149
  m = tmp;
#line 151
  if (m) {
#line 152
    m->mimeType = (enum __anonenum_mime_type_31 )0;
  }
#line 154
  return (m);
}
}
#line 157 "message.c"
void messageDestroy(message *m ) 
{ 

  {
#line 162
  messageReset(m);
#line 164
  free((void *)m);
#line 165
  return;
}
}
#line 167 "message.c"
void messageReset(message *m ) 
{ int i ;

  {
#line 174
  if (m->mimeSubtype) {
#line 175
    free((void *)m->mimeSubtype);
  }
#line 177
  if (m->mimeDispositionType) {
#line 178
    free((void *)m->mimeDispositionType);
  }
#line 180
  if (m->mimeArguments) {
#line 181
    i = 0;
#line 181
    while (i < m->numberOfArguments) {
#line 182
      free((void *)(*(m->mimeArguments + i)));
#line 181
      i ++;
    }
#line 183
    free((void *)m->mimeArguments);
  }
#line 186
  if (m->body_first) {
#line 187
    textDestroy(m->body_first);
  }
#line 191
  if (m->encodingTypes) {
#line 193
    free((void *)m->encodingTypes);
  }
#line 196
  memset((void *)m, '\000', sizeof(message ));
#line 197
  m->mimeType = (enum __anonenum_mime_type_31 )0;
#line 198
  return;
}
}
#line 210 "message.c"
static struct __anonstruct_pthread_mutex_t_16 mime_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
#line 214 "message.c"
static table_t *mime_table  ;
#line 206 "message.c"
int messageSetMimeType(message *mess , char const   *type ) 
{ struct mime_map  const  *m ;
  int typeval ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int highestSimil ;
  int t ;
  char const   *closest ;
  int s ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 217
  if ((unsigned int )type == (unsigned int )((void *)0)) {
#line 218
    cli_warnmsg("Empty content-type field\n");
#line 219
    return (0);
  }
#line 222
  cli_dbgmsg("messageSetMimeType: \'%s\'\n", type);
#line 225
  while (1) {
#line 225
    tmp___0 = __ctype_b_loc();
#line 225
    if ((int const   )(*((*tmp___0) + (int )(*type))) & 1024) {
#line 225
      break;
    }
#line 226
    tmp = type;
#line 226
    type ++;
#line 226
    if ((int const   )(*tmp) == 0) {
#line 227
      return (0);
    }
  }
#line 230
  pthread_mutex_lock(& mime_mutex);
#line 232
  if ((unsigned int )mime_table == (unsigned int )((void *)0)) {
#line 233
    mime_table = tableCreate();
#line 234
    if ((unsigned int )mime_table == (unsigned int )((void *)0)) {
#line 236
      pthread_mutex_unlock(& mime_mutex);
#line 238
      return (0);
    }
#line 241
    m = (struct mime_map  const  *)(mime_map);
#line 241
    while (m->string) {
#line 242
      tmp___1 = tableInsert(mime_table, m->string, (int )m->type);
#line 242
      if (! tmp___1) {
#line 243
        tableDestroy(mime_table);
#line 244
        mime_table = (table_t *)((void *)0);
#line 246
        pthread_mutex_unlock(& mime_mutex);
#line 248
        return (0);
      }
#line 241
      m ++;
    }
  }
#line 252
  pthread_mutex_unlock(& mime_mutex);
#line 255
  typeval = tableFind((table_t const   *)mime_table, type);
#line 257
  if (typeval != -1) {
#line 258
    mess->mimeType = (enum __anonenum_mime_type_31 )typeval;
#line 259
    return (1);
  }
#line 261
  if ((int )mess->mimeType == 0) {
#line 262
    tmp___4 = strncasecmp(type, "x-", 2U);
#line 262
    if (tmp___4 == 0) {
#line 263
      mess->mimeType = (enum __anonenum_mime_type_31 )8;
    } else {
#line 270
      tmp___3 = strcasecmp(type, "plain");
#line 270
      if (tmp___3 == 0) {
#line 271
        cli_dbgmsg("Incorrect MIME type: `plain\', set to Text\n", type);
#line 272
        mess->mimeType = (enum __anonenum_mime_type_31 )6;
      } else {
#line 281
        highestSimil = 0;
#line 281
        t = -1;
#line 282
        closest = (char const   *)((void *)0);
#line 284
        m = (struct mime_map  const  *)(mime_map);
#line 284
        while (m->string) {
#line 285
          tmp___2 = simil(m->string, type);
#line 285
          s = tmp___2;
#line 287
          if (s > highestSimil) {
#line 288
            highestSimil = s;
#line 289
            closest = m->string;
#line 290
            t = (int )m->type;
          }
#line 284
          m ++;
        }
#line 293
        if (highestSimil >= 50) {
#line 294
          cli_dbgmsg("Unknown MIME type \"%s\" - guessing as %s (%u%% certainty)\n",
                     type, closest, highestSimil);
#line 296
          mess->mimeType = (enum __anonenum_mime_type_31 )t;
        } else {
#line 298
          cli_dbgmsg("Unknown MIME type: `%s\', set to Application - if you believe this file contains a missed virus, report it to bugs@clamav.net\n",
                     type);
#line 299
          mess->mimeType = (enum __anonenum_mime_type_31 )1;
        }
      }
    }
#line 303
    return (1);
  }
#line 305
  return (0);
}
}
#line 308 "message.c"
mime_type messageGetMimeType(message const   *m ) 
{ 

  {
#line 313
  return (m->mimeType);
}
}
#line 316 "message.c"
void messageSetMimeSubtype(message *m , char const   *subtype___0 ) 
{ size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;

  {
#line 321
  if ((unsigned int )subtype___0 == (unsigned int )((void *)0)) {
#line 326
    cli_dbgmsg("Empty content subtype\n");
#line 327
    subtype___0 = "";
  }
#line 330
  if (m->mimeSubtype) {
#line 331
    free((void *)m->mimeSubtype);
  }
#line 333
  tmp___18 = __builtin_constant_p((int )subtype___0);
#line 333
  if (tmp___18) {
#line 333
    if ((unsigned int )((void const   *)(subtype___0 + 1)) - (unsigned int )((void const   *)subtype___0) ==
        1U) {
#line 333
      if ((int const   )(*(subtype___0 + 0)) == 0) {
#line 333
        m->mimeSubtype = (char *)calloc(1U, 1U);
      } else {
#line 333
        tmp___15 = strlen(subtype___0);
#line 333
        __len___2 = tmp___15 + 1U;
#line 333
        tmp___16 = (char *)malloc(__len___2);
#line 333
        __retval___2 = tmp___16;
#line 333
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 333
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )subtype___0,
                                        __len___2);
        }
#line 333
        m->mimeSubtype = __retval___2;
      }
    } else {
#line 333
      m->mimeSubtype = __strdup(subtype___0);
    }
  } else {
#line 333
    m->mimeSubtype = __strdup(subtype___0);
  }
#line 334
  return;
}
}
#line 336 "message.c"
char const   *messageGetMimeSubtype(message const   *m ) 
{ char const   *tmp ;

  {
#line 339
  if (m->mimeSubtype) {
#line 339
    tmp = (char const   *)m->mimeSubtype;
  } else {
#line 339
    tmp = "";
  }
#line 339
  return (tmp);
}
}
#line 342 "message.c"
void messageSetDispositionType(message *m , char const   *disptype ) 
{ unsigned short const   **tmp ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;

  {
#line 347
  if (m->mimeDispositionType) {
#line 348
    free((void *)m->mimeDispositionType);
  }
#line 349
  if ((unsigned int )disptype == (unsigned int )((void *)0)) {
#line 350
    m->mimeDispositionType = (char *)((void *)0);
#line 351
    return;
  }
#line 360
  while (1) {
#line 360
    if ((*disptype)) {
#line 360
      tmp = __ctype_b_loc();
#line 360
      if (! ((int const   )(*((*tmp) + (int )(*disptype))) & 8192)) {
#line 360
        break;
      }
    } else {
#line 360
      break;
    }
#line 361
    disptype ++;
  }
#line 363
  if ((*disptype)) {
#line 364
    tmp___19 = __builtin_constant_p((int )disptype);
#line 364
    if (tmp___19) {
#line 364
      if ((unsigned int )((void const   *)(disptype + 1)) - (unsigned int )((void const   *)disptype) ==
          1U) {
#line 364
        if ((int const   )(*(disptype + 0)) == 0) {
#line 364
          m->mimeDispositionType = (char *)calloc(1U, 1U);
        } else {
#line 364
          tmp___16 = strlen(disptype);
#line 364
          __len___2 = tmp___16 + 1U;
#line 364
          tmp___17 = (char *)malloc(__len___2);
#line 364
          __retval___2 = tmp___17;
#line 364
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 364
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )disptype,
                                          __len___2);
          }
#line 364
          m->mimeDispositionType = __retval___2;
        }
      } else {
#line 364
        m->mimeDispositionType = __strdup(disptype);
      }
    } else {
#line 364
      m->mimeDispositionType = __strdup(disptype);
    }
#line 365
    if (m->mimeDispositionType) {
#line 366
      strstrip(m->mimeDispositionType);
    }
  } else {
#line 368
    m->mimeDispositionType = (char *)((void *)0);
  }
#line 369
  return;
}
}
#line 371 "message.c"
char const   *messageGetDispositionType(message const   *m ) 
{ char const   *tmp ;

  {
#line 374
  if (m->mimeDispositionType) {
#line 374
    tmp = (char const   *)m->mimeDispositionType;
  } else {
#line 374
    tmp = "";
  }
#line 374
  return (tmp);
}
}
#line 384 "message.c"
void messageAddArgument(message *m , char const   *arg ) 
{ int offset ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char **ptr ;
  mime_type tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 391
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 392
    return;
  }
#line 394
  while (1) {
#line 394
    tmp = __ctype_b_loc();
#line 394
    if (! ((int const   )(*((*tmp) + (int )(*arg))) & 8192)) {
#line 394
      break;
    }
#line 395
    arg ++;
  }
#line 397
  if ((int const   )(*arg) == 0) {
#line 399
    return;
  }
#line 401
  tmp___0 = usefulArg(arg);
#line 401
  if (! tmp___0) {
#line 402
    return;
  }
#line 404
  offset = 0;
#line 404
  while (offset < m->numberOfArguments) {
#line 405
    if ((unsigned int )(*(m->mimeArguments + offset)) == (unsigned int )((void *)0)) {
#line 406
      break;
    } else {
#line 407
      tmp___1 = strcasecmp(arg, (char const   *)(*(m->mimeArguments + offset)));
#line 407
      if (tmp___1 == 0) {
#line 408
        return;
      }
    }
#line 404
    offset ++;
  }
#line 410
  if (offset == m->numberOfArguments) {
#line 413
    m->numberOfArguments = m->numberOfArguments + 1;
#line 414
    ptr = (char **)cli_realloc((void *)m->mimeArguments, (unsigned int )m->numberOfArguments *
                                                         sizeof(char *));
#line 415
    if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 416
      m->numberOfArguments = m->numberOfArguments - 1;
#line 417
      return;
    }
#line 419
    m->mimeArguments = ptr;
  }
#line 422
  (*(m->mimeArguments + offset)) = rfc2231(arg);
#line 422
  arg = (char const   *)(*(m->mimeArguments + offset));
#line 430
  tmp___4 = strncasecmp(arg, "filename=", 9U);
#line 430
  if (tmp___4 == 0) {
    goto _L;
  } else {
#line 430
    tmp___5 = strncasecmp(arg, "name=", 5U);
#line 430
    if (tmp___5 == 0) {
      _L: 
#line 431
      tmp___3 = messageGetMimeType((message const   *)m);
#line 431
      if ((int )tmp___3 == 0) {
#line 432
        cli_dbgmsg("Force mime encoding to application\n");
#line 433
        messageSetMimeType(m, "application");
      }
    }
  }
#line 435
  return;
}
}
#line 443 "message.c"
void messageAddArguments(message *m , char const   *s ) 
{ char const   *string ;
  char const   *key ;
  char const   *cptr ;
  char *data ;
  char *field ;
  unsigned short const   **tmp ;
  int tmp___4 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char *ptr ;
  void *tmp___28 ;
  size_t __len___2 ;
  size_t tmp___29 ;
  char *__retval___2 ;
  char *tmp___30 ;
  int tmp___32 ;
  int tmp___37 ;
  int tmp___42 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __len___6 ;
  size_t tmp___65 ;
  char *__retval___6 ;
  char *tmp___66 ;
  int tmp___68 ;
  int tmp___79 ;
  size_t tmp___80 ;
  size_t tmp___81 ;
  size_t len ;
  unsigned short const   **tmp___82 ;

  {
#line 446
  string = s;
#line 448
  cli_dbgmsg("Add arguments \'%s\'\n", string);
#line 452
  while ((*string)) {
#line 456
    tmp = __ctype_b_loc();
#line 456
    if ((int const   )(*((*tmp) + (int )(*string))) & 8192) {
#line 457
      string ++;
#line 458
      continue;
    } else {
#line 456
      if ((int const   )(*string) == 59) {
#line 457
        string ++;
#line 458
        continue;
      }
    }
#line 461
    key = string;
#line 463
    tmp___4 = __builtin_constant_p((int )string);
#line 463
    if (tmp___4) {
#line 463
      data = (char *)__builtin_strchr(string, '=');
    } else {
#line 463
      data = (char *)__builtin_strchr(string, '=');
    }
#line 476
    if ((unsigned int )data == (unsigned int )((void *)0)) {
#line 477
      tmp___9 = __builtin_constant_p((int )string);
#line 477
      if (tmp___9) {
#line 477
        data = (char *)__builtin_strchr(string, ':');
      } else {
#line 477
        data = (char *)__builtin_strchr(string, ':');
      }
    }
#line 479
    if ((unsigned int )data == (unsigned int )((void *)0)) {
#line 483
      cli_dbgmsg("Can\'t parse header \"%s\"\n", s);
#line 484
      return;
    }
#line 487
    string = (char const   *)(data + 1);
#line 498
    while (1) {
#line 498
      tmp___10 = __ctype_b_loc();
#line 498
      if ((int const   )(*((*tmp___10) + (int )(*string))) & 8192) {
#line 498
        if (! ((int const   )(*string) != 0)) {
#line 498
          break;
        }
      } else {
#line 498
        break;
      }
#line 499
      string ++;
    }
#line 501
    tmp___11 = string;
#line 501
    string ++;
#line 501
    cptr = tmp___11;
#line 503
    tmp___12 = strlen(key);
#line 503
    if (tmp___12 == 0U) {
#line 504
      continue;
    }
#line 506
    if ((int const   )(*cptr) == 34) {
#line 513
      tmp___32 = __builtin_constant_p((int )key);
#line 513
      if (tmp___32) {
#line 513
        if ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) ==
            1U) {
#line 513
          if ((int const   )(*(key + 0)) == 0) {
#line 513
            tmp___28 = calloc(1U, 1U);
#line 513
            key = (char const   *)((char *)tmp___28);
          } else {
#line 513
            tmp___29 = strlen(key);
#line 513
            __len___2 = tmp___29 + 1U;
#line 513
            tmp___30 = (char *)malloc(__len___2);
#line 513
            __retval___2 = tmp___30;
#line 513
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 513
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )key,
                                            __len___2);
            }
#line 513
            key = (char const   *)__retval___2;
          }
        } else {
#line 513
          key = __strdup(key);
        }
      } else {
#line 513
        key = __strdup(key);
      }
#line 515
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 516
        return;
      }
#line 518
      tmp___37 = __builtin_constant_p((int )key);
#line 518
      if (tmp___37) {
#line 518
        ptr = (char *)__builtin_strchr(key, '=');
      } else {
#line 518
        ptr = (char *)__builtin_strchr(key, '=');
      }
#line 519
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 520
        tmp___42 = __builtin_constant_p((int )key);
#line 520
        if (tmp___42) {
#line 520
          ptr = (char *)__builtin_strchr(key, ':');
        } else {
#line 520
          ptr = (char *)__builtin_strchr(key, ':');
        }
      }
#line 521
      (*ptr) = (char )'\000';
#line 523
      cptr ++;
#line 523
      tmp___47 = __builtin_constant_p((int )cptr);
#line 523
      if (tmp___47) {
#line 523
        cptr ++;
#line 523
        string = (char const   *)__builtin_strchr(cptr, '\"');
      } else {
#line 523
        cptr ++;
#line 523
        string = (char const   *)__builtin_strchr(cptr, '\"');
      }
#line 525
      if ((unsigned int )string == (unsigned int )((void *)0)) {
#line 526
        cli_dbgmsg("Unbalanced quote character in \"%s\"\n", s);
#line 527
        string = "";
      } else {
#line 529
        string ++;
      }
#line 531
      tmp___48 = usefulArg(key);
#line 531
      if (! tmp___48) {
#line 532
        free((void *)((char *)key));
#line 533
        continue;
      }
#line 536
      tmp___68 = __builtin_constant_p((int )cptr);
#line 536
      if (tmp___68) {
#line 536
        if ((unsigned int )((void const   *)(cptr + 1)) - (unsigned int )((void const   *)cptr) ==
            1U) {
#line 536
          if ((int const   )(*(cptr + 0)) == 0) {
#line 536
            data = (char *)calloc(1U, 1U);
          } else {
#line 536
            tmp___65 = strlen(cptr);
#line 536
            __len___6 = tmp___65 + 1U;
#line 536
            tmp___66 = (char *)malloc(__len___6);
#line 536
            __retval___6 = tmp___66;
#line 536
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 536
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )cptr,
                                            __len___6);
            }
#line 536
            data = __retval___6;
          }
        } else {
#line 536
          data = __strdup(cptr);
        }
      } else {
#line 536
        data = __strdup(cptr);
      }
#line 538
      if (data) {
#line 538
        tmp___79 = __builtin_constant_p((int )data);
#line 538
        if (tmp___79) {
#line 538
          ptr = (char *)__builtin_strchr(data, '\"');
        } else {
#line 538
          ptr = (char *)__builtin_strchr(data, '\"');
        }
      } else {
#line 538
        ptr = (char *)((void *)0);
      }
#line 539
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 551
        cli_dbgmsg("Can\'t parse header \"%s\" - if you believe this file contains a missed virus, report it to bugs@clamav.net\n",
                   s);
#line 552
        if (data) {
#line 553
          free((void *)data);
        }
#line 554
        free((void *)((char *)key));
#line 555
        return;
      }
#line 558
      (*ptr) = (char )'\000';
#line 560
      tmp___80 = strlen(key);
#line 560
      tmp___81 = strlen((char const   *)data);
#line 560
      field = (char *)cli_realloc((void *)((char *)key), (tmp___80 + tmp___81) + 2U);
#line 561
      if (field) {
#line 562
        strcat((char * __restrict  )field, (char const   * __restrict  )"=");
#line 563
        strcat((char * __restrict  )field, (char const   * __restrict  )data);
      } else {
#line 565
        free((void *)((char *)key));
      }
#line 566
      free((void *)data);
    } else {
#line 570
      if ((int const   )(*cptr) == 0) {
#line 571
        cli_warnmsg("Ignoring empty field in \"%s\"\n", s);
#line 572
        return;
      }
#line 579
      while (1) {
#line 579
        if ((int const   )(*string) != 0) {
#line 579
          tmp___82 = __ctype_b_loc();
#line 579
          if ((int const   )(*((*tmp___82) + (int )(*string))) & 8192) {
#line 579
            break;
          }
        } else {
#line 579
          break;
        }
#line 580
        string ++;
      }
#line 582
      len = ((unsigned int )string - (unsigned int )key) + 1U;
#line 583
      field = (char *)cli_malloc(len);
#line 585
      if (field) {
#line 586
        memcpy((void * __restrict  )field, (void const   * __restrict  )key, len -
                                                                             1U);
#line 587
        (*(field + (len - 1U))) = (char )'\000';
      }
    }
#line 590
    if (field) {
#line 591
      messageAddArgument(m, (char const   *)field);
#line 592
      free((void *)field);
    }
  }
#line 595
  return;
}
}
#line 597 "message.c"
static char const   *messageGetArgument(message const   *m , int arg ) 
{ char const   *tmp ;

  {
#line 604
  if ((*(m->mimeArguments + arg))) {
#line 604
    tmp = (char const   *)(*(m->mimeArguments + arg));
  } else {
#line 604
    tmp = "";
  }
#line 604
  return (tmp);
}
}
#line 611 "message.c"
char const   *messageFindArgument(message const   *m , char const   *variable ) 
{ int i ;
  size_t len ;
  char const   *ptr ;
  unsigned short const   **tmp ;
  char *ret ;
  char *tmp___11 ;
  size_t __len___2 ;
  size_t tmp___17 ;
  char *__retval___2 ;
  char *tmp___18 ;
  int tmp___20 ;
  char *p ;
  size_t tmp___21 ;
  int tmp___26 ;
  char *tmp___30 ;
  int tmp___32 ;
  char *tmp___44 ;
  size_t __len___6 ;
  size_t tmp___50 ;
  char *__retval___6 ;
  char *tmp___51 ;
  int tmp___53 ;
  int tmp___54 ;

  {
#line 620
  len = strlen(variable);
#line 622
  i = 0;
#line 622
  while (i < m->numberOfArguments) {
#line 625
    ptr = messageGetArgument(m, i);
#line 626
    if ((unsigned int )ptr == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 626
      if ((int const   )(*ptr) == 0) {
        goto __Cont;
      }
    }
#line 632
    tmp___54 = strncasecmp(ptr, variable, len);
#line 632
    if (tmp___54 == 0) {
#line 633
      ptr = ptr + len;
#line 634
      while (1) {
#line 634
        tmp = __ctype_b_loc();
#line 634
        if (! ((int const   )(*((*tmp) + (int )(*ptr))) & 8192)) {
#line 634
          break;
        }
#line 635
        ptr ++;
      }
#line 636
      if ((int const   )(*ptr) != 61) {
#line 637
        cli_warnmsg("messageFindArgument: no \'=\' sign found in MIME header\n");
#line 638
        return ((char const   *)((void *)0));
      }
#line 640
      ptr ++;
#line 640
      if ((int const   )(*ptr) == 34) {
#line 640
        tmp___32 = __builtin_constant_p((int )(ptr + 1));
#line 640
        if (tmp___32) {
#line 640
          tmp___30 = (char *)__builtin_strchr(ptr + 1, '\"');
        } else {
#line 640
          tmp___30 = (char *)__builtin_strchr(ptr + 1, '\"');
        }
#line 640
        if ((unsigned int )tmp___30 != (unsigned int )((void *)0)) {
#line 642
          ptr ++;
#line 642
          tmp___20 = __builtin_constant_p((int )ptr);
#line 642
          if (tmp___20) {
#line 642
            ptr ++;
#line 642
            ptr ++;
#line 642
            if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                1U) {
#line 642
              ptr ++;
#line 642
              if ((int const   )(*(ptr + 0)) == 0) {
#line 642
                tmp___11 = (char *)calloc(1U, 1U);
              } else {
#line 642
                ptr ++;
#line 642
                tmp___17 = strlen(ptr);
#line 642
                __len___2 = tmp___17 + 1U;
#line 642
                tmp___18 = (char *)malloc(__len___2);
#line 642
                __retval___2 = tmp___18;
#line 642
                if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 642
                  ptr ++;
#line 642
                  __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                (void const   * __restrict  )ptr,
                                                __len___2);
                }
#line 642
                tmp___11 = __retval___2;
              }
            } else {
#line 642
              ptr ++;
#line 642
              tmp___11 = __strdup(ptr);
            }
          } else {
#line 642
            ptr ++;
#line 642
            tmp___11 = __strdup(ptr);
          }
#line 642
          ret = tmp___11;
#line 645
          if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 646
            return ((char const   *)((void *)0));
          }
#line 658
          tmp___26 = __builtin_constant_p((int )ret);
#line 658
          if (tmp___26) {
#line 658
            p = (char *)__builtin_strchr(ret, '\"');
          } else {
#line 658
            p = (char *)__builtin_strchr(ret, '\"');
          }
#line 658
          if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 659
            tmp___21 = strlen((char const   *)ret);
#line 659
            (*(ret + (tmp___21 - 1U))) = (char )'\000';
#line 660
            (*p) = (char )'\000';
          }
#line 662
          return ((char const   *)ret);
        }
      }
#line 664
      tmp___53 = __builtin_constant_p((int )ptr);
#line 664
      if (tmp___53) {
#line 664
        if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
            1U) {
#line 664
          if ((int const   )(*(ptr + 0)) == 0) {
#line 664
            tmp___44 = (char *)calloc(1U, 1U);
          } else {
#line 664
            tmp___50 = strlen(ptr);
#line 664
            __len___6 = tmp___50 + 1U;
#line 664
            tmp___51 = (char *)malloc(__len___6);
#line 664
            __retval___6 = tmp___51;
#line 664
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 664
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )ptr,
                                            __len___6);
            }
#line 664
            tmp___44 = __retval___6;
          }
        } else {
#line 664
          tmp___44 = __strdup(ptr);
        }
      } else {
#line 664
        tmp___44 = __strdup(ptr);
      }
#line 664
      return ((char const   *)tmp___44);
    }
    __Cont: 
#line 622
    i ++;
  }
#line 667
  return ((char const   *)((void *)0));
}
}
#line 670 "message.c"
void messageSetEncoding(message *m , char const   *enctype ) 
{ struct encoding_map  const  *e ;
  int i ;
  char *type ;
  int tmp ;
  int highestSimil ;
  char const   *closest ;
  int sim ;
  char lowertype ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___1 ;
  int tmp___2 ;
  __int32_t const   **tmp___3 ;
  int __res___0 ;
  int __c___0 ;
  __int32_t const   **tmp___5 ;
  int tmp___6 ;
  __int32_t const   **tmp___7 ;
  int j ;
  encoding_type *et ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 674
  i = 0;
#line 681
  while (1) {
#line 681
    if (! ((int const   )(*enctype) == 9)) {
#line 681
      if (! ((int const   )(*enctype) == 32)) {
#line 681
        break;
      }
    }
#line 682
    enctype ++;
  }
#line 684
  cli_dbgmsg("messageSetEncoding: \'%s\'\n", enctype);
#line 686
  tmp = strcasecmp(enctype, "8 bit");
#line 686
  if (tmp == 0) {
#line 687
    cli_dbgmsg("Broken content-transfer-encoding: \'8 bit\' changed to \'8bit\'\n");
#line 688
    enctype = "8bit";
  }
#line 696
  i = 0;
#line 697
  while (1) {
#line 697
    tmp___10 = i;
#line 697
    i ++;
#line 697
    type = cli_strtok(enctype, tmp___10, " \t");
#line 697
    if (! ((unsigned int )type != (unsigned int )((void *)0))) {
#line 697
      break;
    }
#line 698
    highestSimil = 0;
#line 699
    closest = (char const   *)((void *)0);
#line 701
    e = encoding_map;
#line 701
    while (e->string) {
#line 703
      if (sizeof((*(type + 0))) > 1U) {
#line 703
        tmp___2 = __builtin_constant_p((int )(*(type + 0)));
#line 703
        if (tmp___2) {
#line 703
          __c = (int )(*(type + 0));
#line 703
          if (__c < -128) {
#line 703
            __res = __c;
          } else {
#line 703
            if (__c > 255) {
#line 703
              __res = __c;
            } else {
#line 703
              tmp___1 = __ctype_tolower_loc();
#line 703
              __res = (*((*tmp___1) + __c));
            }
          }
        } else {
#line 703
          __res = tolower__extinline((int )(*(type + 0)));
        }
      } else {
#line 703
        tmp___3 = __ctype_tolower_loc();
#line 703
        __res = (*((*tmp___3) + (int )(*(type + 0))));
      }
#line 703
      lowertype = (char )__res;
#line 705
      if (sizeof((*(e->string + 0))) > 1U) {
#line 705
        tmp___6 = __builtin_constant_p((int )(*(e->string + 0)));
#line 705
        if (tmp___6) {
#line 705
          __c___0 = (int )(*(e->string + 0));
#line 705
          if (__c___0 < -128) {
#line 705
            __res___0 = __c___0;
          } else {
#line 705
            if (__c___0 > 255) {
#line 705
              __res___0 = __c___0;
            } else {
#line 705
              tmp___5 = __ctype_tolower_loc();
#line 705
              __res___0 = (*((*tmp___5) + __c___0));
            }
          }
        } else {
#line 705
          __res___0 = tolower__extinline((int )(*(e->string + 0)));
        }
      } else {
#line 705
        tmp___7 = __ctype_tolower_loc();
#line 705
        __res___0 = (*((*tmp___7) + (int )(*(e->string + 0))));
      }
#line 705
      if ((int )lowertype != __res___0) {
#line 705
        if ((int )lowertype != 120) {
          goto __Cont;
        }
      }
#line 717
      sim = simil((char const   *)type, e->string);
#line 719
      if (sim == 100) {
#line 723
        j = 0;
#line 723
        while (j < m->numberOfEncTypes) {
#line 724
          if ((int )(*(m->encodingTypes + j)) == (int )e->type) {
#line 725
            break;
          }
#line 723
          j ++;
        }
#line 727
        if (j < m->numberOfEncTypes) {
#line 728
          cli_dbgmsg("Ignoring duplicate encoding mechanism \'%s\'\n", type);
#line 730
          break;
        }
#line 733
        et = (encoding_type *)cli_realloc((void *)m->encodingTypes, (unsigned int )(m->numberOfEncTypes +
                                                                                    1) *
                                                                    sizeof(encoding_type ));
#line 734
        if ((unsigned int )et == (unsigned int )((void *)0)) {
#line 735
          break;
        }
#line 737
        m->encodingTypes = et;
#line 738
        tmp___9 = m->numberOfEncTypes;
#line 738
        m->numberOfEncTypes = m->numberOfEncTypes + 1;
#line 738
        (*(m->encodingTypes + tmp___9)) = e->type;
#line 740
        cli_dbgmsg("Encoding type %d is \"%s\"\n", m->numberOfEncTypes, type);
#line 741
        break;
      } else {
#line 742
        if (sim > highestSimil) {
#line 743
          closest = e->string;
#line 744
          highestSimil = sim;
        }
      }
      __Cont: 
#line 701
      e ++;
    }
#line 748
    if ((unsigned int )e->string == (unsigned int )((void *)0)) {
#line 756
      if (highestSimil >= 50) {
#line 757
        cli_dbgmsg("Unknown encoding type \"%s\" - guessing as %s (%u%% certainty)\n",
                   type, closest, highestSimil);
#line 759
        messageSetEncoding(m, closest);
      } else {
#line 761
        cli_dbgmsg("Unknown encoding type \"%s\" - if you believe this file contains a virus, report it to bugs@clamav.net\n",
                   type);
#line 766
        messageSetEncoding(m, "base64");
#line 767
        messageSetEncoding(m, "quoted-printable");
      }
    }
#line 771
    free((void *)type);
  }
#line 773
  return;
}
}
#line 775 "message.c"
encoding_type messageGetEncoding(message const   *m ) 
{ 

  {
#line 780
  if (m->numberOfEncTypes == 0) {
#line 781
    return ((enum __anonenum_encoding_type_32 )0);
  }
#line 782
  return ((*(m->encodingTypes + 0)));
}
}
#line 785 "message.c"
int messageAddLine(message *m , line_t *line ) 
{ char const   *tmp___1 ;

  {
#line 790
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
#line 791
    m->body_first = (text *)cli_malloc(sizeof(text ));
#line 791
    m->body_last = m->body_first;
  } else {
#line 793
    (m->body_last)->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 794
    m->body_last = (m->body_last)->t_next;
  }
#line 797
  if ((unsigned int )m->body_last == (unsigned int )((void *)0)) {
#line 798
    return (-1);
  }
#line 800
  (m->body_last)->t_next = (struct text *)((void *)0);
#line 802
  if (line) {
#line 802
    tmp___1 = lineGetData((line_t const   *)line);
#line 802
    if (tmp___1) {
#line 803
      (m->body_last)->t_line = lineLink(line);
#line 805
      messageIsEncoding(m);
    } else {
#line 807
      (m->body_last)->t_line = (line_t *)((void *)0);
    }
  } else {
#line 807
    (m->body_last)->t_line = (line_t *)((void *)0);
  }
#line 809
  return (1);
}
}
#line 817 "message.c"
int messageAddStr(message *m , char const   *data ) 
{ line_t *repeat ;
  int iswhite ;
  char const   *p ;
  unsigned short const   **tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___123 ;
  char const   *tmp___124 ;
  char const   *tmp___188 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___190 ;
  int tmp___191 ;
  char const   *tmp___192 ;
  char const   *tmp___193 ;
  char const   *tmp___222 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  char const   *tmp___223 ;
  char const   *tmp___224 ;
  char const   *tmp___225 ;
  char const   *tmp___226 ;
  int tmp___227 ;
  char const   *tmp___228 ;
  int tmp___229 ;
  int tmp___230 ;
  char const   *tmp___231 ;
  char const   *tmp___232 ;
  char const   *tmp___233 ;
  int tmp___234 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  char const   *tmp___238 ;
  char const   *tmp___239 ;
  char const   *tmp___240 ;
  int tmp___241 ;

  {
#line 820
  repeat = (line_t *)((void *)0);
#line 824
  if (data) {
#line 825
    if ((int const   )(*data) == 0) {
#line 826
      data = (char const   *)((void *)0);
    } else {
#line 833
      iswhite = 1;
#line 836
      p = data;
#line 836
      while ((*p)) {
#line 837
        tmp = __ctype_b_loc();
#line 837
        if (! ((int const   )(*((*tmp) + (int )(*p))) & 8192)) {
#line 838
          iswhite = 0;
#line 839
          break;
        }
#line 836
        p ++;
      }
#line 841
      if (iswhite) {
#line 843
        data = " ";
      }
    }
  }
#line 848
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
#line 849
    m->body_first = (text *)cli_malloc(sizeof(text ));
#line 849
    m->body_last = m->body_first;
  } else {
#line 852
    if ((unsigned int )data == (unsigned int )((void *)0)) {
#line 852
      if ((unsigned int )(m->body_last)->t_line == (unsigned int )((void *)0)) {
#line 854
        return (1);
      }
    }
#line 856
    (m->body_last)->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 857
    if ((unsigned int )(m->body_last)->t_next == (unsigned int )((void *)0)) {
#line 858
      messageDedup(m);
#line 859
      (m->body_last)->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 860
      if ((unsigned int )(m->body_last)->t_next == (unsigned int )((void *)0)) {
#line 861
        cli_errmsg("messageAddStr: out of memory\n");
#line 862
        return (-1);
      }
    }
#line 866
    if (data) {
#line 866
      if ((m->body_last)->t_line) {
#line 866
        tmp___235 = __builtin_constant_p((int )data);
#line 866
        if (tmp___235) {
#line 866
          tmp___236 = (int )lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
          tmp___237 = __builtin_constant_p(tmp___236);
#line 866
          if (tmp___237) {
#line 866
            __s1_len = strlen(data);
#line 866
            tmp___238 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
            __s2_len = strlen(tmp___238);
#line 866
            if (! ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                   1U)) {
              goto _L___16;
            } else {
#line 866
              if (__s1_len >= 4U) {
                _L___16: 
#line 866
                tmp___239 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                tmp___240 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                if ((unsigned int )((void const   *)(tmp___239 + 1)) - (unsigned int )((void const   *)tmp___240) ==
                    1U) {
#line 866
                  if (__s2_len >= 4U) {
#line 866
                    tmp___241 = 1;
                  } else {
#line 866
                    tmp___241 = 0;
                  }
                } else {
#line 866
                  tmp___241 = 1;
                }
              } else {
#line 866
                tmp___241 = 0;
              }
            }
#line 866
            if (tmp___241) {
#line 866
              tmp___124 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
              tmp___123 = __builtin_strcmp(data, tmp___124);
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
#line 866
          tmp___234 = __builtin_constant_p((int )data);
#line 866
          if (tmp___234) {
#line 866
            if ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                1U) {
#line 866
              __s1_len = strlen(data);
#line 866
              if (__s1_len < 4U) {
#line 866
                tmp___190 = (int )lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                tmp___191 = __builtin_constant_p(tmp___190);
#line 866
                if (tmp___191) {
#line 866
                  tmp___192 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                  tmp___193 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                  if ((unsigned int )((void const   *)(tmp___192 + 1)) - (unsigned int )((void const   *)tmp___193) ==
                      1U) {
#line 866
                    tmp___188 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                    tmp___123 = __builtin_strcmp(data, tmp___188);
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
#line 866
                  __s2___6 = (unsigned char const   *)lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                  __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 866
                  if (__s1_len > 0U) {
#line 866
                    if (__result___18 == 0) {
#line 866
                      __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 866
                      if (__s1_len > 1U) {
#line 866
                        if (__result___18 == 0) {
#line 866
                          __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 866
                          if (__s1_len > 2U) {
#line 866
                            if (__result___18 == 0) {
#line 866
                              __result___18 = (int )((int const   )(*((unsigned char const   *)data +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 866
                  tmp___123 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
#line 866
            tmp___229 = (int )lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
            tmp___230 = __builtin_constant_p(tmp___229);
#line 866
            if (tmp___230) {
#line 866
              tmp___231 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
              tmp___232 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
              if ((unsigned int )((void const   *)(tmp___231 + 1)) - (unsigned int )((void const   *)tmp___232) ==
                  1U) {
#line 866
                tmp___233 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                __s2_len = strlen(tmp___233);
#line 866
                if (__s2_len < 4U) {
#line 866
                  tmp___227 = __builtin_constant_p((int )data);
#line 866
                  if (tmp___227) {
#line 866
                    if ((unsigned int )((void const   *)(data + 1)) - (unsigned int )((void const   *)data) ==
                        1U) {
#line 866
                      tmp___222 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                      tmp___123 = __builtin_strcmp(data, tmp___222);
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
#line 866
                    __s1___14 = (unsigned char const   *)data;
#line 866
                    tmp___223 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)tmp___223 +
                                                                                               0)));
#line 866
                    if (__s2_len > 0U) {
#line 866
                      if (__result___22 == 0) {
#line 866
                        tmp___224 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)tmp___224 +
                                                                1)));
#line 866
                        if (__s2_len > 1U) {
#line 866
                          if (__result___22 == 0) {
#line 866
                            tmp___225 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)tmp___225 +
                                                                    2)));
#line 866
                            if (__s2_len > 2U) {
#line 866
                              if (__result___22 == 0) {
#line 866
                                tmp___226 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)tmp___226 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 866
                    tmp___123 = __result___22;
                  }
                } else {
#line 866
                  tmp___228 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                  tmp___123 = __builtin_strcmp(data, tmp___228);
                }
              } else {
#line 866
                tmp___228 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
                tmp___123 = __builtin_strcmp(data, tmp___228);
              }
            } else {
#line 866
              tmp___228 = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 866
              tmp___123 = __builtin_strcmp(data, tmp___228);
            }
          }
        }
#line 866
        if (tmp___123 == 0) {
#line 867
          repeat = (m->body_last)->t_line;
        }
      }
    }
#line 868
    m->body_last = (m->body_last)->t_next;
  }
#line 871
  if ((unsigned int )m->body_last == (unsigned int )((void *)0)) {
#line 872
    cli_errmsg("messageAddStr: out of memory\n");
#line 873
    return (-1);
  }
#line 876
  (m->body_last)->t_next = (struct text *)((void *)0);
#line 878
  if (data) {
#line 878
    if ((*data)) {
#line 879
      if (repeat) {
#line 880
        (m->body_last)->t_line = lineLink(repeat);
      } else {
#line 882
        (m->body_last)->t_line = lineCreate(data);
      }
#line 884
      if ((unsigned int )(m->body_last)->t_line == (unsigned int )((void *)0)) {
#line 884
        if ((unsigned int )repeat == (unsigned int )((void *)0)) {
#line 885
          messageDedup(m);
#line 886
          (m->body_last)->t_line = lineCreate(data);
#line 888
          if ((unsigned int )(m->body_last)->t_line == (unsigned int )((void *)0)) {
#line 889
            cli_errmsg("messageAddStr: out of memory\n");
#line 890
            return (-1);
          }
        }
      }
#line 895
      if ((unsigned int )repeat == (unsigned int )((void *)0)) {
#line 896
        messageIsEncoding(m);
      }
    } else {
#line 898
      (m->body_last)->t_line = (line_t *)((void *)0);
    }
  } else {
#line 898
    (m->body_last)->t_line = (line_t *)((void *)0);
  }
#line 900
  return (1);
}
}
#line 908 "message.c"
int messageAddStrAtTop(message *m , char const   *data ) 
{ text *oldfirst ;
  line_t *tmp ;
  int tmp___0 ;
  char const   *tmp___2 ;

  {
#line 915
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
#line 916
    tmp = lineCreate(data);
#line 916
    tmp___0 = messageAddLine(m, tmp);
#line 916
    return (tmp___0);
  }
#line 918
  oldfirst = m->body_first;
#line 919
  m->body_first = (text *)cli_malloc(sizeof(text ));
#line 920
  if ((unsigned int )m->body_first == (unsigned int )((void *)0)) {
#line 921
    m->body_first = oldfirst;
#line 922
    return (-1);
  }
#line 925
  (m->body_first)->t_next = oldfirst;
#line 926
  if (data) {
#line 926
    tmp___2 = data;
  } else {
#line 926
    tmp___2 = "";
  }
#line 926
  (m->body_first)->t_line = lineCreate(tmp___2);
#line 928
  if ((unsigned int )(m->body_first)->t_line == (unsigned int )((void *)0)) {
#line 929
    cli_errmsg("messageAddStrAtTop: out of memory\n");
#line 930
    return (-1);
  }
#line 932
  return (1);
}
}
#line 942 "message.c"
static char const   encoding[26]  = 
#line 942
  {      (char const   )'C',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'-', 
        (char const   )'T',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'s',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'-',      (char const   )'E',      (char const   )'n',      (char const   )'c', 
        (char const   )'o',      (char const   )'d',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'\000'};
#line 943 "message.c"
static char const   binhex[46]  = 
#line 943
  {      (char const   )'(',      (char const   )'T',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'u',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'B',      (char const   )'i', 
        (char const   )'n',      (char const   )'H',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'4',      (char const   )'.',      (char const   )'0', 
        (char const   )')',      (char const   )'\000'};
#line 939 "message.c"
static void messageIsEncoding(message *m ) 
{ char const   *line ;
  char const   *tmp ;
  int tmp___74 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___110 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___129 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  char *tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  cli_file_t tmp___153 ;
  int tmp___154 ;
  char *tmp___155 ;

  {
#line 944
  tmp = lineGetData((line_t const   *)(m->body_last)->t_line);
#line 944
  line = tmp;
#line 946
  if ((unsigned int )m->encoding == (unsigned int )((void *)0)) {
#line 946
    tmp___154 = strncasecmp(line, encoding, sizeof(encoding) - 1U);
#line 946
    if (tmp___154 == 0) {
#line 946
      tmp___155 = strstr(line, "7bit");
#line 946
      if ((unsigned int )tmp___155 == (unsigned int )((void *)0)) {
#line 949
        m->encoding = (text const   *)m->body_last;
      } else {
        goto _L___47;
      }
    } else {
      goto _L___47;
    }
  } else {
    _L___47: 
#line 950
    if ((unsigned int )m->bounce == (unsigned int )((void *)0)) {
#line 950
      tmp___151 = strncasecmp(line, "Received: ", 10U);
#line 950
      if (tmp___151 == 0) {
#line 950
        tmp___152 = strlen(line);
#line 950
        tmp___153 = cli_filetype(line, tmp___152);
#line 950
        if ((int )tmp___153 == 520) {
#line 953
          m->bounce = (text const   *)m->body_last;
        } else {
          goto _L___45;
        }
      } else {
        goto _L___45;
      }
    } else {
      _L___45: 
#line 954
      if ((unsigned int )m->uuencode == (unsigned int )((void *)0)) {
#line 954
        tmp___150 = isuuencodebegin(line);
#line 954
        if (tmp___150) {
#line 955
          m->uuencode = (text const   *)m->body_last;
        } else {
          goto _L___43;
        }
      } else {
        _L___43: 
#line 956
        if ((unsigned int )m->binhex == (unsigned int )((void *)0)) {
#line 956
          tmp___148 = strstr(line, "BinHex");
#line 956
          if (tmp___148) {
#line 956
            tmp___149 = simil(line, binhex);
#line 956
            if (tmp___149 > 90) {
#line 964
              m->binhex = (text const   *)m->body_last;
            } else {
              goto _L___42;
            }
          } else {
            goto _L___42;
          }
        } else {
          _L___42: 
#line 965
          if ((unsigned int )m->yenc == (unsigned int )((void *)0)) {
#line 965
            tmp___144 = __builtin_constant_p((int )line);
#line 965
            if (tmp___144) {
#line 965
              tmp___145 = strlen(line);
#line 965
              if (tmp___145 < 13U) {
                goto _L___39;
              } else {
                goto _L___40;
              }
            } else {
              _L___40: 
#line 965
              tmp___146 = __builtin_constant_p((int )"=ybegin line=");
#line 965
              if (tmp___146) {
#line 965
                tmp___147 = strlen("=ybegin line=");
#line 965
                if (tmp___147 < 13U) {
                  _L___39: 
#line 965
                  tmp___141 = __builtin_constant_p((int )line);
#line 965
                  if (tmp___141) {
#line 965
                    tmp___142 = __builtin_constant_p((int )"=ybegin line=");
#line 965
                    if (tmp___142) {
#line 965
                      __s1_len___0 = strlen(line);
#line 965
                      __s2_len___0 = strlen("=ybegin line=");
#line 965
                      if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                             1U)) {
                        goto _L___36;
                      } else {
#line 965
                        if (__s1_len___0 >= 4U) {
                          _L___36: 
#line 965
                          if (! ((unsigned int )((void const   *)("=ybegin line=" +
                                                                  1)) - (unsigned int )((void const   *)"=ybegin line=") ==
                                 1U)) {
#line 965
                            tmp___143 = 1;
                          } else {
#line 965
                            if (__s2_len___0 >= 4U) {
#line 965
                              tmp___143 = 1;
                            } else {
#line 965
                              tmp___143 = 0;
                            }
                          }
                        } else {
#line 965
                          tmp___143 = 0;
                        }
                      }
#line 965
                      if (tmp___143) {
#line 965
                        tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                      } else {
                        goto _L___38;
                      }
                    } else {
                      goto _L___38;
                    }
                  } else {
                    _L___38: 
#line 965
                    tmp___140 = __builtin_constant_p((int )line);
#line 965
                    if (tmp___140) {
#line 965
                      if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                          1U) {
#line 965
                        __s1_len___0 = strlen(line);
#line 965
                        if (__s1_len___0 < 4U) {
#line 965
                          tmp___129 = __builtin_constant_p((int )"=ybegin line=");
#line 965
                          if (tmp___129) {
#line 965
                            if ((unsigned int )((void const   *)("=ybegin line=" +
                                                                 1)) - (unsigned int )((void const   *)"=ybegin line=") ==
                                1U) {
#line 965
                              tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                            } else {
                              goto _L___31;
                            }
                          } else {
                            _L___31: 
#line 965
                            __s2___14 = (unsigned char const   *)"=ybegin line=";
#line 965
                            __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                    0)) - (int const   )(*(__s2___14 +
                                                                                           0)));
#line 965
                            if (__s1_len___0 > 0U) {
#line 965
                              if (__result___42 == 0) {
#line 965
                                __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                        1)) - (int const   )(*(__s2___14 +
                                                                                               1)));
#line 965
                                if (__s1_len___0 > 1U) {
#line 965
                                  if (__result___42 == 0) {
#line 965
                                    __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                            2)) -
                                                           (int const   )(*(__s2___14 +
                                                                            2)));
#line 965
                                    if (__s1_len___0 > 2U) {
#line 965
                                      if (__result___42 == 0) {
#line 965
                                        __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                                3)) -
                                                               (int const   )(*(__s2___14 +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
#line 965
                            tmp___110 = __result___42;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        goto _L___35;
                      }
                    } else {
                      _L___35: 
#line 965
                      tmp___139 = __builtin_constant_p((int )"=ybegin line=");
#line 965
                      if (tmp___139) {
#line 965
                        if ((unsigned int )((void const   *)("=ybegin line=" + 1)) -
                            (unsigned int )((void const   *)"=ybegin line=") == 1U) {
#line 965
                          __s2_len___0 = strlen("=ybegin line=");
#line 965
                          if (__s2_len___0 < 4U) {
#line 965
                            tmp___138 = __builtin_constant_p((int )line);
#line 965
                            if (tmp___138) {
#line 965
                              if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                  1U) {
#line 965
                                tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                              } else {
                                goto _L___33;
                              }
                            } else {
                              _L___33: 
#line 965
                              __s1___30 = (unsigned char const   *)line;
#line 965
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      0)) - (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                                             0)));
#line 965
                              if (__s2_len___0 > 0U) {
#line 965
                                if (__result___46 == 0) {
#line 965
                                  __result___46 = (int )((int const   )(*(__s1___30 +
                                                                          1)) - (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                                                 1)));
#line 965
                                  if (__s2_len___0 > 1U) {
#line 965
                                    if (__result___46 == 0) {
#line 965
                                      __result___46 = (int )((int const   )(*(__s1___30 +
                                                                              2)) -
                                                             (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                              2)));
#line 965
                                      if (__s2_len___0 > 2U) {
#line 965
                                        if (__result___46 == 0) {
#line 965
                                          __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                  3)) -
                                                                 (int const   )(*((unsigned char const   *)"=ybegin line=" +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
#line 965
                              tmp___110 = __result___46;
                            }
                          } else {
#line 965
                            tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                          }
                        } else {
#line 965
                          tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                        }
                      } else {
#line 965
                        tmp___110 = __builtin_strcmp(line, "=ybegin line=");
                      }
                    }
                  }
#line 965
                  tmp___74 = tmp___110;
                } else {
#line 965
                  tmp___74 = strncmp(line, "=ybegin line=", 13U);
                }
              } else {
#line 965
                tmp___74 = strncmp(line, "=ybegin line=", 13U);
              }
            }
#line 965
            if (tmp___74 == 0) {
#line 966
              m->yenc = (text const   *)m->body_last;
            }
          }
        }
      }
    }
  }
#line 967
  return;
}
}
#line 973 "message.c"
text const   *messageGetBody(message const   *m ) 
{ 

  {
#line 977
  return ((text const   *)m->body_first);
}
}
#line 983 "message.c"
void messageClean(message *m ) 
{ text *newEnd ;
  text *tmp ;

  {
#line 986
  tmp = textClean(m->body_first);
#line 986
  newEnd = tmp;
#line 988
  if (newEnd) {
#line 989
    m->body_last = newEnd;
  }
#line 990
  return;
}
}
#line 999 "message.c"
static void *messageExport(message *m , char const   *dir , void *(*create)(void) ,
                           void (*destroy)(void * ) , void (*setFilename)(void * ,
                                                                          char const   * ,
                                                                          char const   * ) ,
                           void (*addData)(void * , unsigned char const   * , size_t  ) ,
                           void *(*exportText)(text const   * , void * ) ) 
{ void *ret ;
  text const   *t_line ;
  char *filename ;
  int i ;
  text const   *tmp ;
  unsigned char byte ;
  unsigned long newlen ;
  unsigned long len ;
  unsigned long l ;
  unsigned char *data ;
  char *ptr ;
  int bytenumber ;
  blob *tmp___0 ;
  unsigned char hqxtbl[128] ;
  unsigned char *uptr ;
  unsigned char c ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  blob *u ;
  blob *tmp___4 ;
  unsigned char c___0 ;
  int count ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  char const   *tmp___9 ;
  text const   *tmp___10 ;
  void *tmp___11 ;
  text const   *tmp___12 ;
  encoding_type enctype ;
  size_t size ;
  void *newret ;
  char const   *tmp___13 ;
  size_t __len___2 ;
  size_t tmp___31 ;
  char *__retval___2 ;
  char *tmp___32 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___38 ;
  text const   *tmp___39 ;
  text const   *tmp___40 ;
  text const   *tmp___41 ;
  unsigned char smallbuf[1024] ;
  unsigned char *uptr___0 ;
  unsigned char *data___0 ;
  char const   *line ;
  char const   *tmp___42 ;
  unsigned char *bigbuf ;
  size_t datasize ;
  int tmp___43 ;
  int tmp___118 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___154 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___173 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  size_t tmp___189 ;
  int tmp___190 ;
  size_t tmp___191 ;
  size_t tmp___193 ;
  unsigned char data___1[4] ;
  unsigned char *ptr___0 ;

  {
#line 1009
  tmp = messageGetBody((message const   *)m);
#line 1009
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 1010
    return ((void *)0);
  }
#line 1012
  ret = ((*create))();
#line 1014
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 1015
    return ((void *)0);
  }
#line 1017
  cli_dbgmsg("messageExport: numberOfEncTypes == %d\n", m->numberOfEncTypes);
#line 1019
  t_line = binhexBegin((message const   *)m);
#line 1019
  if ((unsigned int )t_line != (unsigned int )((void *)0)) {
#line 1021
    newlen = 0UL;
#line 1031
    hqxtbl[0] = (unsigned char)255;
#line 1031
    hqxtbl[1] = (unsigned char)255;
#line 1031
    hqxtbl[2] = (unsigned char)255;
#line 1031
    hqxtbl[3] = (unsigned char)255;
#line 1031
    hqxtbl[4] = (unsigned char)255;
#line 1031
    hqxtbl[5] = (unsigned char)255;
#line 1031
    hqxtbl[6] = (unsigned char)255;
#line 1031
    hqxtbl[7] = (unsigned char)255;
#line 1031
    hqxtbl[8] = (unsigned char)255;
#line 1031
    hqxtbl[9] = (unsigned char)255;
#line 1031
    hqxtbl[10] = (unsigned char)255;
#line 1031
    hqxtbl[11] = (unsigned char)255;
#line 1031
    hqxtbl[12] = (unsigned char)255;
#line 1031
    hqxtbl[13] = (unsigned char)255;
#line 1031
    hqxtbl[14] = (unsigned char)255;
#line 1031
    hqxtbl[15] = (unsigned char)255;
#line 1031
    hqxtbl[16] = (unsigned char)255;
#line 1031
    hqxtbl[17] = (unsigned char)255;
#line 1031
    hqxtbl[18] = (unsigned char)255;
#line 1031
    hqxtbl[19] = (unsigned char)255;
#line 1031
    hqxtbl[20] = (unsigned char)255;
#line 1031
    hqxtbl[21] = (unsigned char)255;
#line 1031
    hqxtbl[22] = (unsigned char)255;
#line 1031
    hqxtbl[23] = (unsigned char)255;
#line 1031
    hqxtbl[24] = (unsigned char)255;
#line 1031
    hqxtbl[25] = (unsigned char)255;
#line 1031
    hqxtbl[26] = (unsigned char)255;
#line 1031
    hqxtbl[27] = (unsigned char)255;
#line 1031
    hqxtbl[28] = (unsigned char)255;
#line 1031
    hqxtbl[29] = (unsigned char)255;
#line 1031
    hqxtbl[30] = (unsigned char)255;
#line 1031
    hqxtbl[31] = (unsigned char)255;
#line 1031
    hqxtbl[32] = (unsigned char)255;
#line 1031
    hqxtbl[33] = (unsigned char)0;
#line 1031
    hqxtbl[34] = (unsigned char)1;
#line 1031
    hqxtbl[35] = (unsigned char)2;
#line 1031
    hqxtbl[36] = (unsigned char)3;
#line 1031
    hqxtbl[37] = (unsigned char)4;
#line 1031
    hqxtbl[38] = (unsigned char)5;
#line 1031
    hqxtbl[39] = (unsigned char)6;
#line 1031
    hqxtbl[40] = (unsigned char)7;
#line 1031
    hqxtbl[41] = (unsigned char)8;
#line 1031
    hqxtbl[42] = (unsigned char)9;
#line 1031
    hqxtbl[43] = (unsigned char)10;
#line 1031
    hqxtbl[44] = (unsigned char)11;
#line 1031
    hqxtbl[45] = (unsigned char)12;
#line 1031
    hqxtbl[46] = (unsigned char)255;
#line 1031
    hqxtbl[47] = (unsigned char)255;
#line 1031
    hqxtbl[48] = (unsigned char)13;
#line 1031
    hqxtbl[49] = (unsigned char)14;
#line 1031
    hqxtbl[50] = (unsigned char)15;
#line 1031
    hqxtbl[51] = (unsigned char)16;
#line 1031
    hqxtbl[52] = (unsigned char)17;
#line 1031
    hqxtbl[53] = (unsigned char)18;
#line 1031
    hqxtbl[54] = (unsigned char)19;
#line 1031
    hqxtbl[55] = (unsigned char)255;
#line 1031
    hqxtbl[56] = (unsigned char)20;
#line 1031
    hqxtbl[57] = (unsigned char)21;
#line 1031
    hqxtbl[58] = (unsigned char)255;
#line 1031
    hqxtbl[59] = (unsigned char)255;
#line 1031
    hqxtbl[60] = (unsigned char)255;
#line 1031
    hqxtbl[61] = (unsigned char)255;
#line 1031
    hqxtbl[62] = (unsigned char)255;
#line 1031
    hqxtbl[63] = (unsigned char)255;
#line 1031
    hqxtbl[64] = (unsigned char)22;
#line 1031
    hqxtbl[65] = (unsigned char)23;
#line 1031
    hqxtbl[66] = (unsigned char)24;
#line 1031
    hqxtbl[67] = (unsigned char)25;
#line 1031
    hqxtbl[68] = (unsigned char)26;
#line 1031
    hqxtbl[69] = (unsigned char)27;
#line 1031
    hqxtbl[70] = (unsigned char)28;
#line 1031
    hqxtbl[71] = (unsigned char)29;
#line 1031
    hqxtbl[72] = (unsigned char)30;
#line 1031
    hqxtbl[73] = (unsigned char)31;
#line 1031
    hqxtbl[74] = (unsigned char)32;
#line 1031
    hqxtbl[75] = (unsigned char)33;
#line 1031
    hqxtbl[76] = (unsigned char)34;
#line 1031
    hqxtbl[77] = (unsigned char)35;
#line 1031
    hqxtbl[78] = (unsigned char)36;
#line 1031
    hqxtbl[79] = (unsigned char)255;
#line 1031
    hqxtbl[80] = (unsigned char)37;
#line 1031
    hqxtbl[81] = (unsigned char)38;
#line 1031
    hqxtbl[82] = (unsigned char)39;
#line 1031
    hqxtbl[83] = (unsigned char)40;
#line 1031
    hqxtbl[84] = (unsigned char)41;
#line 1031
    hqxtbl[85] = (unsigned char)42;
#line 1031
    hqxtbl[86] = (unsigned char)43;
#line 1031
    hqxtbl[87] = (unsigned char)255;
#line 1031
    hqxtbl[88] = (unsigned char)44;
#line 1031
    hqxtbl[89] = (unsigned char)45;
#line 1031
    hqxtbl[90] = (unsigned char)46;
#line 1031
    hqxtbl[91] = (unsigned char)47;
#line 1031
    hqxtbl[92] = (unsigned char)255;
#line 1031
    hqxtbl[93] = (unsigned char)255;
#line 1031
    hqxtbl[94] = (unsigned char)255;
#line 1031
    hqxtbl[95] = (unsigned char)255;
#line 1031
    hqxtbl[96] = (unsigned char)48;
#line 1031
    hqxtbl[97] = (unsigned char)49;
#line 1031
    hqxtbl[98] = (unsigned char)50;
#line 1031
    hqxtbl[99] = (unsigned char)51;
#line 1031
    hqxtbl[100] = (unsigned char)52;
#line 1031
    hqxtbl[101] = (unsigned char)53;
#line 1031
    hqxtbl[102] = (unsigned char)54;
#line 1031
    hqxtbl[103] = (unsigned char)255;
#line 1031
    hqxtbl[104] = (unsigned char)55;
#line 1031
    hqxtbl[105] = (unsigned char)56;
#line 1031
    hqxtbl[106] = (unsigned char)57;
#line 1031
    hqxtbl[107] = (unsigned char)58;
#line 1031
    hqxtbl[108] = (unsigned char)59;
#line 1031
    hqxtbl[109] = (unsigned char)60;
#line 1031
    hqxtbl[110] = (unsigned char)255;
#line 1031
    hqxtbl[111] = (unsigned char)255;
#line 1031
    hqxtbl[112] = (unsigned char)61;
#line 1031
    hqxtbl[113] = (unsigned char)62;
#line 1031
    hqxtbl[114] = (unsigned char)63;
#line 1031
    hqxtbl[115] = (unsigned char)255;
#line 1031
    hqxtbl[116] = (unsigned char)255;
#line 1031
    hqxtbl[117] = (unsigned char)255;
#line 1031
    hqxtbl[118] = (unsigned char)255;
#line 1031
    hqxtbl[119] = (unsigned char)255;
#line 1031
    hqxtbl[120] = (unsigned char)255;
#line 1031
    hqxtbl[121] = (unsigned char)255;
#line 1031
    hqxtbl[122] = (unsigned char)255;
#line 1031
    hqxtbl[123] = (unsigned char)255;
#line 1031
    hqxtbl[124] = (unsigned char)255;
#line 1031
    hqxtbl[125] = (unsigned char)255;
#line 1031
    hqxtbl[126] = (unsigned char)255;
#line 1031
    hqxtbl[127] = (unsigned char)255;
#line 1050
    while (1) {
#line 1050
      t_line = (text const   *)t_line->t_next;
#line 1050
      if ((unsigned int )t_line != (unsigned int )((void *)0)) {
#line 1050
        if (! ((unsigned int )t_line->t_line == (unsigned int )((void *)0))) {
#line 1050
          break;
        }
      } else {
#line 1050
        break;
      }
    }
#line 1054
    tmp___0 = textToBlob(t_line, (blob *)((void *)0));
#line 1055
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 1056
      ((*destroy))(ret);
#line 1057
      return ((void *)0);
    }
#line 1060
    data = blobGetData((blob const   *)tmp___0);
#line 1062
    if ((unsigned int )data == (unsigned int )((void *)0)) {
#line 1063
      cli_warnmsg("Couldn\'t locate the binhex message that was claimed to be there\n");
#line 1064
      blobDestroy(tmp___0);
#line 1065
      ((*destroy))(ret);
#line 1066
      return ((void *)0);
    }
#line 1068
    len = blobGetDataSize((blob const   *)tmp___0);
#line 1070
    if ((int )(*(data + 0)) == 58) {
#line 1081
      cli_dbgmsg("decode HQX7 message (%lu bytes)\n", len);
#line 1083
      uptr = (unsigned char *)cli_malloc((unsigned int )len);
#line 1084
      if ((unsigned int )uptr == (unsigned int )((void *)0)) {
#line 1085
        blobDestroy(tmp___0);
#line 1086
        ((*destroy))(ret);
#line 1087
        return ((void *)0);
      }
#line 1089
      memcpy((void * __restrict  )uptr, (void const   * __restrict  )data, (unsigned int )len);
#line 1090
      bytenumber = 0;
#line 1096
      l = 1UL;
#line 1096
      while (l < len) {
#line 1097
        c = (*(uptr + l));
#line 1099
        if ((int )c == 58) {
#line 1100
          break;
        }
#line 1102
        if ((int )c == 10) {
          goto __Cont;
        } else {
#line 1102
          if ((int )c == 13) {
            goto __Cont;
          }
        }
#line 1105
        if ((int )c < 32) {
#line 1106
          cli_warnmsg("Invalid HQX7 character \'%c\' (0x%02x)\n", c, c);
#line 1107
          break;
        } else {
#line 1105
          if ((int )c > 127) {
#line 1106
            cli_warnmsg("Invalid HQX7 character \'%c\' (0x%02x)\n", c, c);
#line 1107
            break;
          } else {
#line 1105
            if ((int )hqxtbl[c] == 255) {
#line 1106
              cli_warnmsg("Invalid HQX7 character \'%c\' (0x%02x)\n", c, c);
#line 1107
              break;
            }
          }
        }
#line 1109
        c = hqxtbl[c];
#line 1116
        switch (bytenumber) {
        case 0: 
#line 1118
        (*(data + newlen)) = (unsigned char )(((int )c << 2) & 252);
#line 1119
        bytenumber = 1;
#line 1120
        break;
        case 1: 
#line 1122
        tmp___1 = newlen;
#line 1122
        newlen ++;
#line 1122
        (*(data + tmp___1)) = (unsigned char )((int )(*(data + tmp___1)) | (((int )c >>
                                                                             4) &
                                                                            3));
#line 1123
        (*(data + newlen)) = (unsigned char )(((int )c << 4) & 240);
#line 1124
        bytenumber = 2;
#line 1125
        break;
        case 2: 
#line 1127
        tmp___2 = newlen;
#line 1127
        newlen ++;
#line 1127
        (*(data + tmp___2)) = (unsigned char )((int )(*(data + tmp___2)) | (((int )c >>
                                                                             2) &
                                                                            15));
#line 1128
        (*(data + newlen)) = (unsigned char )(((int )c << 6) & 192);
#line 1129
        bytenumber = 3;
#line 1130
        break;
        case 3: 
#line 1132
        tmp___3 = newlen;
#line 1132
        newlen ++;
#line 1132
        (*(data + tmp___3)) = (unsigned char )((int )(*(data + tmp___3)) | ((int )c &
                                                                            63));
#line 1133
        bytenumber = 0;
#line 1134
        break;
        }
        __Cont: 
#line 1096
        l ++;
      }
#line 1138
      cli_dbgmsg("decoded HQX7 message (now %lu bytes)\n", newlen);
#line 1146
      free((void *)uptr);
    } else {
#line 1148
      cli_warnmsg("HQX8 messages not yet supported - if you believe this file contains a virus, report it to bugs@clamav.net\n",
                  len);
#line 1149
      newlen = len;
    }
#line 1155
    tmp___5 = memchr((void const   *)data, 144, (unsigned int )newlen);
#line 1155
    if (tmp___5) {
#line 1156
      tmp___4 = blobCreate();
#line 1156
      u = tmp___4;
#line 1158
      if ((unsigned int )u == (unsigned int )((void *)0)) {
#line 1159
        ((*destroy))(ret);
#line 1160
        blobDestroy(tmp___0);
#line 1161
        return ((void *)0);
      }
#line 1166
      l = 0UL;
#line 1166
      while (l < newlen) {
#line 1167
        c___0 = (*(data + l));
#line 1173
        blobAddData(u, (unsigned char const   *)(& c___0), 1U);
#line 1175
        if (l < newlen - 1UL) {
#line 1175
          if ((int )(*(data + (l + 1UL))) == 144) {
#line 1178
            l += 2UL;
#line 1179
            count = (int )(*(data + l));
#line 1181
            if (count == 0) {
#line 1182
              c___0 = (unsigned char)144;
#line 1183
              blobAddData(u, (unsigned char const   *)(& c___0), 1U);
            } else {
#line 1188
              blobGrow(u, (unsigned int )count);
#line 1189
              while (1) {
#line 1189
                count --;
#line 1189
                if (! (count > 0)) {
#line 1189
                  break;
                }
#line 1190
                blobAddData(u, (unsigned char const   *)(& c___0), 1U);
              }
            }
          }
        }
#line 1166
        l ++;
      }
#line 1194
      blobDestroy(tmp___0);
#line 1195
      tmp___0 = u;
#line 1196
      data = blobGetData((blob const   *)tmp___0);
#line 1197
      len = blobGetDataSize((blob const   *)tmp___0);
#line 1198
      cli_dbgmsg("Uncompressed %lu bytes to %lu\n", newlen, len);
    } else {
#line 1200
      len = newlen;
#line 1201
      cli_dbgmsg("HQX7 message (%lu bytes) is not compressed\n", len);
    }
#line 1204
    if (len == 0UL) {
#line 1205
      cli_warnmsg("Discarding empty binHex attachment\n");
#line 1206
      ((*destroy))(ret);
#line 1207
      blobDestroy(tmp___0);
#line 1208
      return ((void *)0);
    }
#line 1221
    byte = (*(data + 0));
#line 1222
    if ((unsigned long )byte >= len) {
#line 1223
      ((*destroy))(ret);
#line 1224
      blobDestroy(tmp___0);
#line 1225
      return ((void *)0);
    }
#line 1227
    filename = (char *)cli_malloc((unsigned int )((int )byte + 1));
#line 1228
    if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 1229
      ((*destroy))(ret);
#line 1230
      blobDestroy(tmp___0);
#line 1231
      return ((void *)0);
    }
#line 1233
    memcpy((void * __restrict  )filename, (void const   * __restrict  )(data + 1),
           (unsigned int )byte);
#line 1234
    (*(filename + (int )byte)) = (char )'\000';
#line 1235
    ((*setFilename))(ret, dir, (char const   *)filename);
#line 1237
    ptr = (char *)cli_malloc((unsigned int )((int )byte + 6));
#line 1238
    if (ptr) {
#line 1239
      sprintf((char * __restrict  )ptr, (char const   * __restrict  )"name=%s", filename);
#line 1240
      messageAddArgument(m, (char const   *)ptr);
#line 1241
      free((void *)ptr);
    }
#line 1247
    byte = (unsigned char )(((((1 + (int )byte) + 1) + 4) + 4) + 2);
#line 1252
    len = (unsigned long )(((((unsigned int )((int )(*(data + (int )byte)) << 24) &
                              4278190080U) | (unsigned int )(((int )(*(data + ((int )byte +
                                                                               1))) <<
                                                              16) & 16711680)) | (unsigned int )(((int )(*(data +
                                                                                                           ((int )byte +
                                                                                                            2))) <<
                                                                                                  8) &
                                                                                                 65280)) |
                           (unsigned int )((int )(*(data + ((int )byte + 3))) & 255));
#line 1257
    cli_dbgmsg("Filename = \'%s\', data fork length = %lu bytes\n", filename, len);
#line 1260
    free((void *)filename);
#line 1265
    byte = (unsigned char )((int )byte + 10);
#line 1267
    tmp___6 = blobGetDataSize((blob const   *)tmp___0);
#line 1267
    l = tmp___6 - (unsigned long )byte;
#line 1269
    if (l < len) {
#line 1270
      cli_warnmsg("Corrupt BinHex file, claims it is %lu bytes long in a message of %lu bytes\n",
                  len, l);
#line 1272
      len = l;
    }
#line 1274
    ((*addData))(ret, (unsigned char const   *)(data + (int )byte), (unsigned int )len);
#line 1276
    blobDestroy(tmp___0);
#line 1278
    m->binhex = (text const   *)((void *)0);
#line 1280
    if (m->numberOfEncTypes == 1) {
#line 1280
      if ((int )(*(m->encodingTypes + 0)) == 8) {
#line 1281
        cli_dbgmsg("Finished exporting binhex file\n");
#line 1282
        return (ret);
      }
    }
  }
#line 1286
  if (m->numberOfEncTypes == 0) {
#line 1290
    filename = messageFindArgument((message const   *)m, "filename");
#line 1291
    if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 1292
      filename = messageFindArgument((message const   *)m, "name");
#line 1294
      if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 1295
        cli_dbgmsg("Unencoded attachment sent with no filename\n");
#line 1296
        messageAddArgument(m, "name=attachment");
      } else {
#line 1302
        messageSetEncoding(m, "base64");
      }
    }
#line 1305
    if (filename) {
#line 1305
      if ((*filename)) {
#line 1305
        tmp___9 = (char const   *)filename;
      } else {
#line 1305
        tmp___9 = "attachment";
      }
    } else {
#line 1305
      tmp___9 = "attachment";
    }
#line 1305
    ((*setFilename))(ret, dir, tmp___9);
#line 1307
    if (filename) {
#line 1308
      free((void *)filename);
    }
#line 1310
    if (m->numberOfEncTypes == 0) {
#line 1311
      tmp___12 = uuencodeBegin((message const   *)m);
#line 1311
      if (tmp___12) {
#line 1312
        messageSetEncoding(m, "x-uuencode");
      } else {
#line 1314
        tmp___10 = messageGetBody((message const   *)m);
#line 1314
        tmp___11 = ((*exportText))(tmp___10, ret);
#line 1314
        return (tmp___11);
      }
    }
  }
#line 1318
  i = 0;
#line 1318
  while (i < m->numberOfEncTypes) {
#line 1319
    enctype = (*(m->encodingTypes + i));
#line 1322
    if (i > 0) {
#line 1325
      newret = ((*create))();
#line 1326
      if ((unsigned int )newret == (unsigned int )((void *)0)) {
#line 1327
        cli_errmsg("Not all decoding algorithms were run\n");
#line 1328
        return (ret);
      }
#line 1330
      ((*destroy))(ret);
#line 1331
      ret = newret;
    }
#line 1333
    cli_dbgmsg("messageExport: enctype %d is %d\n", i, enctype);
#line 1337
    if ((int )enctype == 5) {
      goto _L___2;
    } else {
#line 1337
      tmp___41 = uuencodeBegin((message const   *)m);
#line 1337
      if (tmp___41) {
        _L___2: 
#line 1338
        t_line = uuencodeBegin((message const   *)m);
#line 1340
        if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1342
          m->uuencode = (text const   *)((void *)0);
#line 1343
          m->base64chars = 0;
#line 1344
          if (i == m->numberOfEncTypes - 1) {
#line 1345
            ((*destroy))(ret);
#line 1346
            return ((void *)0);
          }
          goto __Cont___0;
        }
#line 1351
        tmp___13 = lineGetData((line_t const   *)t_line->t_line);
#line 1351
        filename = cli_strtok(tmp___13, 2, " ");
#line 1353
        if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 1354
          cli_dbgmsg("UUencoded attachment sent with no filename\n");
#line 1355
          ((*destroy))(ret);
#line 1356
          return ((void *)0);
        }
#line 1358
        cli_chomp(filename);
#line 1360
        cli_dbgmsg("Set uuencode filename to \"%s\"\n", filename);
#line 1362
        ((*setFilename))(ret, dir, (char const   *)filename);
#line 1363
        t_line = (text const   *)t_line->t_next;
#line 1364
        enctype = (enum __anonenum_encoding_type_32 )5;
#line 1365
        m->uuencode = (text const   *)((void *)0);
      } else {
#line 1366
        if ((int )enctype == 6) {
#line 1366
          tmp___39 = yEncBegin((message const   *)m);
#line 1366
          if (tmp___39) {
            goto _L;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
#line 1366
          if (i == 0) {
#line 1366
            tmp___40 = yEncBegin((message const   *)m);
#line 1366
            if (tmp___40) {
              _L: 
#line 1370
              t_line = yEncBegin((message const   *)m);
#line 1371
              filename = lineGetData((line_t const   *)t_line->t_line);
#line 1373
              filename = strstr((char const   *)filename, " name=");
#line 1373
              if ((unsigned int )filename != (unsigned int )((void *)0)) {
#line 1374
                tmp___34 = __builtin_constant_p((int )(filename + 6));
#line 1374
                if (tmp___34) {
#line 1374
                  if ((unsigned int )((void const   *)((filename + 6) + 1)) - (unsigned int )((void const   *)(filename +
                                                                                                               6)) ==
                      1U) {
#line 1374
                    if ((int const   )(*((char const   *)(filename + 6) + 0)) == 0) {
#line 1374
                      filename = (char *)calloc(1U, 1U);
                    } else {
#line 1374
                      tmp___31 = strlen((char const   *)(filename + 6));
#line 1374
                      __len___2 = tmp___31 + 1U;
#line 1374
                      tmp___32 = (char *)malloc(__len___2);
#line 1374
                      __retval___2 = tmp___32;
#line 1374
                      if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1374
                        __retval___2 = (char *)memcpy((void * __restrict  )__retval___2,
                                                      (void const   * __restrict  )(filename +
                                                                                    6),
                                                      __len___2);
                      }
#line 1374
                      filename = __retval___2;
                    }
                  } else {
#line 1374
                    filename = __strdup((char const   *)(filename + 6));
                  }
                } else {
#line 1374
                  filename = __strdup((char const   *)(filename + 6));
                }
#line 1375
                if (filename) {
#line 1376
                  cli_chomp(filename);
#line 1377
                  strstrip(filename);
#line 1378
                  cli_dbgmsg("Set yEnc filename to \"%s\"\n", filename);
                }
              }
#line 1382
              if (filename) {
#line 1382
                if ((*filename)) {
#line 1382
                  tmp___35 = (char const   *)filename;
                } else {
#line 1382
                  tmp___35 = "attachment";
                }
              } else {
#line 1382
                tmp___35 = "attachment";
              }
#line 1382
              ((*setFilename))(ret, dir, tmp___35);
#line 1383
              if (filename) {
#line 1384
                free((void *)filename);
#line 1385
                filename = (char *)((void *)0);
              }
#line 1387
              t_line = (text const   *)t_line->t_next;
#line 1388
              enctype = (enum __anonenum_encoding_type_32 )6;
#line 1389
              m->yenc = (text const   *)((void *)0);
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
#line 1391
            filename = messageFindArgument((message const   *)m, "filename");
#line 1392
            if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 1393
              filename = messageFindArgument((message const   *)m, "name");
#line 1395
              if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 1396
                cli_dbgmsg("Attachment sent with no filename\n");
#line 1397
                messageAddArgument(m, "name=attachment");
              } else {
#line 1398
                if ((int )enctype == 0) {
#line 1403
                  messageSetEncoding(m, "base64");
                }
              }
            }
#line 1406
            if (filename) {
#line 1406
              if ((*filename)) {
#line 1406
                tmp___38 = (char const   *)filename;
              } else {
#line 1406
                tmp___38 = "attachment";
              }
            } else {
#line 1406
              tmp___38 = "attachment";
            }
#line 1406
            ((*setFilename))(ret, dir, tmp___38);
#line 1408
            t_line = messageGetBody((message const   *)m);
          }
        }
      }
    }
#line 1411
    if (filename) {
#line 1412
      free((void *)filename);
    }
#line 1418
    if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1419
      cli_warnmsg("Empty attachment not saved\n");
#line 1420
      ((*destroy))(ret);
#line 1421
      return ((void *)0);
    }
#line 1424
    if ((int )enctype == 0) {
#line 1428
      ((*exportText))(t_line, ret);
      goto __Cont___0;
    }
#line 1432
    size = 0U;
#line 1433
    while (1) {
#line 1436
      tmp___42 = lineGetData((line_t const   *)t_line->t_line);
#line 1436
      line = tmp___42;
#line 1440
      if ((int )enctype == 5) {
#line 1445
        if ((unsigned int )line == (unsigned int )((void *)0)) {
          goto __Cont___1;
        }
#line 1447
        tmp___43 = strcasecmp(line, "end");
#line 1447
        if (tmp___43 == 0) {
#line 1448
          break;
        }
      } else {
#line 1449
        if ((int )enctype == 6) {
#line 1450
          if ((unsigned int )line == (unsigned int )((void *)0)) {
            goto __Cont___1;
          }
#line 1452
          tmp___188 = __builtin_constant_p((int )line);
#line 1452
          if (tmp___188) {
#line 1452
            tmp___189 = strlen(line);
#line 1452
            if (tmp___189 < 6U) {
              goto _L___43;
            } else {
              goto _L___44;
            }
          } else {
            _L___44: 
#line 1452
            tmp___190 = __builtin_constant_p((int )"=yend ");
#line 1452
            if (tmp___190) {
#line 1452
              tmp___191 = strlen("=yend ");
#line 1452
              if (tmp___191 < 6U) {
                _L___43: 
#line 1452
                tmp___185 = __builtin_constant_p((int )line);
#line 1452
                if (tmp___185) {
#line 1452
                  tmp___186 = __builtin_constant_p((int )"=yend ");
#line 1452
                  if (tmp___186) {
#line 1452
                    __s1_len___0 = strlen(line);
#line 1452
                    __s2_len___0 = strlen("=yend ");
#line 1452
                    if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                           1U)) {
                      goto _L___40;
                    } else {
#line 1452
                      if (__s1_len___0 >= 4U) {
                        _L___40: 
#line 1452
                        if (! ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                               1U)) {
#line 1452
                          tmp___187 = 1;
                        } else {
#line 1452
                          if (__s2_len___0 >= 4U) {
#line 1452
                            tmp___187 = 1;
                          } else {
#line 1452
                            tmp___187 = 0;
                          }
                        }
                      } else {
#line 1452
                        tmp___187 = 0;
                      }
                    }
#line 1452
                    if (tmp___187) {
#line 1452
                      tmp___154 = __builtin_strcmp(line, "=yend ");
                    } else {
                      goto _L___42;
                    }
                  } else {
                    goto _L___42;
                  }
                } else {
                  _L___42: 
#line 1452
                  tmp___184 = __builtin_constant_p((int )line);
#line 1452
                  if (tmp___184) {
#line 1452
                    if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                        1U) {
#line 1452
                      __s1_len___0 = strlen(line);
#line 1452
                      if (__s1_len___0 < 4U) {
#line 1452
                        tmp___173 = __builtin_constant_p((int )"=yend ");
#line 1452
                        if (tmp___173) {
#line 1452
                          if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                              1U) {
#line 1452
                            tmp___154 = __builtin_strcmp(line, "=yend ");
                          } else {
                            goto _L___35;
                          }
                        } else {
                          _L___35: 
#line 1452
                          __s2___14 = (unsigned char const   *)"=yend ";
#line 1452
                          __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                  0)) - (int const   )(*(__s2___14 +
                                                                                         0)));
#line 1452
                          if (__s1_len___0 > 0U) {
#line 1452
                            if (__result___42 == 0) {
#line 1452
                              __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                      1)) - (int const   )(*(__s2___14 +
                                                                                             1)));
#line 1452
                              if (__s1_len___0 > 1U) {
#line 1452
                                if (__result___42 == 0) {
#line 1452
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                          2)) - (int const   )(*(__s2___14 +
                                                                                                 2)));
#line 1452
                                  if (__s1_len___0 > 2U) {
#line 1452
                                    if (__result___42 == 0) {
#line 1452
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                              3)) -
                                                             (int const   )(*(__s2___14 +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 1452
                          tmp___154 = __result___42;
                        }
                      } else {
                        goto _L___39;
                      }
                    } else {
                      goto _L___39;
                    }
                  } else {
                    _L___39: 
#line 1452
                    tmp___183 = __builtin_constant_p((int )"=yend ");
#line 1452
                    if (tmp___183) {
#line 1452
                      if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                          1U) {
#line 1452
                        __s2_len___0 = strlen("=yend ");
#line 1452
                        if (__s2_len___0 < 4U) {
#line 1452
                          tmp___182 = __builtin_constant_p((int )line);
#line 1452
                          if (tmp___182) {
#line 1452
                            if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                1U) {
#line 1452
                              tmp___154 = __builtin_strcmp(line, "=yend ");
                            } else {
                              goto _L___37;
                            }
                          } else {
                            _L___37: 
#line 1452
                            __s1___30 = (unsigned char const   *)line;
#line 1452
                            __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                                   (int const   )(*((unsigned char const   *)"=yend " +
                                                                    0)));
#line 1452
                            if (__s2_len___0 > 0U) {
#line 1452
                              if (__result___46 == 0) {
#line 1452
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        1)) - (int const   )(*((unsigned char const   *)"=yend " +
                                                                                               1)));
#line 1452
                                if (__s2_len___0 > 1U) {
#line 1452
                                  if (__result___46 == 0) {
#line 1452
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            2)) -
                                                           (int const   )(*((unsigned char const   *)"=yend " +
                                                                            2)));
#line 1452
                                    if (__s2_len___0 > 2U) {
#line 1452
                                      if (__result___46 == 0) {
#line 1452
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                3)) -
                                                               (int const   )(*((unsigned char const   *)"=yend " +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
#line 1452
                            tmp___154 = __result___46;
                          }
                        } else {
#line 1452
                          tmp___154 = __builtin_strcmp(line, "=yend ");
                        }
                      } else {
#line 1452
                        tmp___154 = __builtin_strcmp(line, "=yend ");
                      }
                    } else {
#line 1452
                      tmp___154 = __builtin_strcmp(line, "=yend ");
                    }
                  }
                }
#line 1452
                tmp___118 = tmp___154;
              } else {
#line 1452
                tmp___118 = strncmp(line, "=yend ", 6U);
              }
            } else {
#line 1452
              tmp___118 = strncmp(line, "=yend ", 6U);
            }
          }
#line 1452
          if (tmp___118 == 0) {
#line 1453
            break;
          }
        }
      }
#line 1459
      if (line) {
#line 1459
        tmp___193 = strlen(line);
#line 1459
        datasize = tmp___193 + 2U;
      } else {
#line 1459
        datasize = 0U;
      }
#line 1461
      if (datasize >= sizeof(smallbuf)) {
#line 1462
        bigbuf = (unsigned char *)cli_malloc(datasize);
#line 1462
        data___0 = bigbuf;
      } else {
#line 1464
        bigbuf = (unsigned char *)((void *)0);
#line 1465
        data___0 = smallbuf;
#line 1466
        datasize = sizeof(smallbuf);
      }
#line 1469
      uptr___0 = decodeLine(m, enctype, line, data___0, datasize);
#line 1470
      if ((unsigned int )uptr___0 == (unsigned int )((void *)0)) {
#line 1471
        if ((unsigned int )data___0 == (unsigned int )bigbuf) {
#line 1472
          free((void *)data___0);
        }
#line 1473
        break;
      }
#line 1476
      if ((unsigned int )uptr___0 != (unsigned int )data___0) {
#line 1478
        ((*addData))(ret, (unsigned char const   *)data___0, (unsigned int )(uptr___0 -
                                                                             data___0));
#line 1479
        size += (unsigned int )(uptr___0 - data___0);
      }
#line 1482
      if ((unsigned int )data___0 == (unsigned int )bigbuf) {
#line 1483
        free((void *)data___0);
      }
      __Cont___1: 
#line 1433
      t_line = (text const   *)t_line->t_next;
#line 1433
      if (! ((unsigned int )t_line != (unsigned int )((void *)0))) {
#line 1433
        break;
      }
    }
#line 1498
    cli_dbgmsg("Exported %u bytes using enctype %d\n", size, enctype);
#line 1501
    if (m->base64chars) {
#line 1505
      cli_dbgmsg("%u trailing bytes to export\n", m->base64chars);
#line 1507
      ptr___0 = decode(m, (char const   *)((void *)0), data___1, & base64, (enum __anonenum_bool_35 )0);
#line 1508
      if (ptr___0) {
#line 1509
        ((*addData))(ret, (unsigned char const   *)(data___1), (unsigned int )(ptr___0 -
                                                                               data___1));
      }
#line 1510
      m->base64chars = 0;
    }
    __Cont___0: 
#line 1318
    i ++;
  }
#line 1514
  return (ret);
}
}
#line 1521 "message.c"
fileblob *messageToFileblob(message *m , char const   *dir ) 
{ fileblob *tmp ;

  {
#line 1524
  cli_dbgmsg("messageToFileblob\n");
#line 1525
  tmp = (fileblob *)messageExport(m, dir, (void *(*)(void))((void *)(& fileblobCreate)),
                                  (void (*)(void * ))((void *)(& fileblobDestroy)),
                                  (void (*)(void * , char const   * , char const   * ))((void *)(& fileblobSetFilename)),
                                  (void (*)(void * , unsigned char const   * , size_t  ))((void *)(& fileblobAddData)),
                                  (void *(*)(text const   * , void * ))((void *)(& textToFileblob)));
#line 1525
  return (tmp);
}
}
#line 1532 "message.c"
blob *messageToBlob(message *m ) 
{ blob *tmp ;

  {
#line 1535
  tmp = (blob *)messageExport(m, (char const   *)((void *)0), (void *(*)(void))((void *)(& blobCreate)),
                              (void (*)(void * ))((void *)(& blobDestroy)), (void (*)(void * ,
                                                                                      char const   * ,
                                                                                      char const   * ))((void *)(& blobSetFilename)),
                              (void (*)(void * , unsigned char const   * , size_t  ))((void *)(& blobAddData)),
                              (void *(*)(text const   * , void * ))((void *)(& textToBlob)));
#line 1535
  return (tmp);
}
}
#line 1542 "message.c"
text *messageToText(message *m ) 
{ int i ;
  text *first ;
  text *last ;
  text const   *t_line ;
  encoding_type enctype ;
  text const   *tmp ;
  unsigned char data[1024] ;
  unsigned char *uptr ;
  char const   *line ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___81 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___117 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___136 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  size_t tmp___155 ;
  size_t tmp___156 ;
  int tmp___157 ;
  size_t tmp___158 ;
  size_t tmp___159 ;
  char *tmp___163 ;
  int tmp___165 ;
  unsigned char data___0[4] ;
  unsigned char *tmp___166 ;

  {
#line 1546
  first = (text *)((void *)0);
#line 1546
  last = (text *)((void *)0);
#line 1551
  if (m->numberOfEncTypes == 0) {
#line 1555
    t_line = messageGetBody((message const   *)m);
#line 1555
    while (t_line) {
#line 1556
      if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 1557
        last = (text *)cli_malloc(sizeof(text ));
#line 1557
        first = last;
      } else {
#line 1559
        last->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 1560
        last = last->t_next;
      }
#line 1563
      if ((unsigned int )last == (unsigned int )((void *)0)) {
#line 1564
        if (first) {
#line 1565
          textDestroy(first);
        }
#line 1566
        return ((text *)((void *)0));
      }
#line 1568
      if (t_line->t_line) {
#line 1569
        last->t_line = lineLink(t_line->t_line);
      } else {
#line 1571
        last->t_line = (line_t *)((void *)0);
      }
#line 1555
      t_line = (text const   *)t_line->t_next;
    }
#line 1573
    if (last) {
#line 1574
      last->t_next = (struct text *)((void *)0);
    }
#line 1576
    return (first);
  }
#line 1582
  i = 0;
#line 1582
  while (i < m->numberOfEncTypes) {
#line 1583
    enctype = (*(m->encodingTypes + i));
#line 1585
    cli_dbgmsg("messageToText: export transfer method %d = %d\n", i, enctype);
#line 1588
    switch ((int )enctype) {
    case 0: ;
    case 4: ;
    case 3: 
#line 1595
    t_line = messageGetBody((message const   *)m);
#line 1595
    while (t_line) {
#line 1596
      if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 1597
        last = (text *)cli_malloc(sizeof(text ));
#line 1597
        first = last;
      } else {
#line 1599
        last->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 1600
        last = last->t_next;
      }
#line 1603
      if ((unsigned int )last == (unsigned int )((void *)0)) {
#line 1604
        if (first) {
#line 1605
          last->t_next = (struct text *)((void *)0);
#line 1606
          textDestroy(first);
        }
#line 1608
        return ((text *)((void *)0));
      }
#line 1610
      if (t_line->t_line) {
#line 1611
        last->t_line = lineLink(t_line->t_line);
      } else {
#line 1613
        last->t_line = (line_t *)((void *)0);
      }
#line 1595
      t_line = (text const   *)t_line->t_next;
    }
    goto __Cont;
    case 5: 
#line 1617
    t_line = uuencodeBegin((message const   *)m);
#line 1619
    if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1621
      if (first) {
#line 1622
        last->t_next = (struct text *)((void *)0);
#line 1623
        textDestroy(first);
      }
#line 1625
      return ((text *)((void *)0));
    }
#line 1627
    t_line = (text const   *)t_line->t_next;
#line 1628
    m->uuencode = (text const   *)((void *)0);
#line 1629
    break;
    case 6: 
#line 1631
    t_line = yEncBegin((message const   *)m);
#line 1633
    if ((unsigned int )t_line == (unsigned int )((void *)0)) {
#line 1635
      if (first) {
#line 1636
        last->t_next = (struct text *)((void *)0);
#line 1637
        textDestroy(first);
      }
#line 1639
      return ((text *)((void *)0));
    }
#line 1641
    t_line = (text const   *)t_line->t_next;
    default: ;
#line 1643
    if (i == 0) {
#line 1643
      tmp = binhexBegin((message const   *)m);
#line 1643
      if (tmp) {
#line 1644
        cli_warnmsg("Binhex messages not supported yet.\n");
      }
    }
#line 1645
    t_line = messageGetBody((message const   *)m);
    }
#line 1648
    while (t_line) {
#line 1651
      tmp___0 = lineGetData((line_t const   *)t_line->t_line);
#line 1651
      line = tmp___0;
#line 1653
      if ((int )enctype == 2) {
#line 1658
        if ((unsigned int )line == (unsigned int )((void *)0)) {
          goto __Cont___0;
        }
      } else {
#line 1660
        if ((int )enctype == 5) {
#line 1661
          tmp___1 = strcasecmp(line, "end");
#line 1661
          if (tmp___1 == 0) {
#line 1662
            break;
          }
        }
      }
#line 1666
      uptr = decodeLine(m, enctype, line, data, sizeof(data));
#line 1668
      if ((unsigned int )uptr == (unsigned int )((void *)0)) {
#line 1669
        break;
      }
#line 1673
      if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 1674
        last = (text *)cli_malloc(sizeof(text ));
#line 1674
        first = last;
      } else {
#line 1676
        last->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 1677
        last = last->t_next;
      }
#line 1680
      if ((unsigned int )last == (unsigned int )((void *)0)) {
#line 1681
        break;
      }
#line 1692
      if ((int )data[0] == 10) {
#line 1693
        last->t_line = (line_t *)((void *)0);
      } else {
#line 1692
        if ((int )data[0] == 0) {
#line 1693
          last->t_line = (line_t *)((void *)0);
        } else {
#line 1694
          if (line) {
#line 1694
            tmp___152 = (int )strlen(line);
#line 1694
            tmp___153 = __builtin_constant_p(tmp___152);
#line 1694
            if (tmp___153) {
#line 1694
              tmp___154 = __builtin_constant_p((int )((char const   *)(data)));
#line 1694
              if (tmp___154) {
#line 1694
                tmp___155 = strlen((char const   *)(data));
#line 1694
                tmp___156 = strlen(line);
#line 1694
                if (tmp___155 < tmp___156) {
                  goto _L___39;
                } else {
                  goto _L___40;
                }
              } else {
                _L___40: 
#line 1694
                tmp___157 = __builtin_constant_p((int )line);
#line 1694
                if (tmp___157) {
#line 1694
                  tmp___158 = strlen(line);
#line 1694
                  tmp___159 = strlen(line);
#line 1694
                  if (tmp___158 < tmp___159) {
                    _L___39: 
#line 1694
                    tmp___148 = __builtin_constant_p((int )((char const   *)(data)));
#line 1694
                    if (tmp___148) {
#line 1694
                      tmp___149 = __builtin_constant_p((int )line);
#line 1694
                      if (tmp___149) {
#line 1694
                        __s1_len___0 = strlen((char const   *)(data));
#line 1694
                        __s2_len___0 = strlen(line);
#line 1694
                        if (! ((unsigned int )((void const   *)((char const   *)(data) +
                                                                1)) - (unsigned int )((void const   *)((char const   *)(data))) ==
                               1U)) {
                          goto _L___36;
                        } else {
#line 1694
                          if (__s1_len___0 >= 4U) {
                            _L___36: 
#line 1694
                            if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                   1U)) {
#line 1694
                              tmp___150 = 1;
                            } else {
#line 1694
                              if (__s2_len___0 >= 4U) {
#line 1694
                                tmp___150 = 1;
                              } else {
#line 1694
                                tmp___150 = 0;
                              }
                            }
                          } else {
#line 1694
                            tmp___150 = 0;
                          }
                        }
#line 1694
                        if (tmp___150) {
#line 1694
                          tmp___117 = __builtin_strcmp((char const   *)(data), line);
                        } else {
                          goto _L___38;
                        }
                      } else {
                        goto _L___38;
                      }
                    } else {
                      _L___38: 
#line 1694
                      tmp___147 = __builtin_constant_p((int )((char const   *)(data)));
#line 1694
                      if (tmp___147) {
#line 1694
                        if ((unsigned int )((void const   *)((char const   *)(data) +
                                                             1)) - (unsigned int )((void const   *)((char const   *)(data))) ==
                            1U) {
#line 1694
                          __s1_len___0 = strlen((char const   *)(data));
#line 1694
                          if (__s1_len___0 < 4U) {
#line 1694
                            tmp___136 = __builtin_constant_p((int )line);
#line 1694
                            if (tmp___136) {
#line 1694
                              if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                                  1U) {
#line 1694
                                tmp___117 = __builtin_strcmp((char const   *)(data),
                                                             line);
                              } else {
                                goto _L___31;
                              }
                            } else {
                              _L___31: 
#line 1694
                              __s2___14 = (unsigned char const   *)line;
#line 1694
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                      0)) - (int const   )(*(__s2___14 +
                                                                                             0)));
#line 1694
                              if (__s1_len___0 > 0U) {
#line 1694
                                if (__result___42 == 0) {
#line 1694
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                          1)) - (int const   )(*(__s2___14 +
                                                                                                 1)));
#line 1694
                                  if (__s1_len___0 > 1U) {
#line 1694
                                    if (__result___42 == 0) {
#line 1694
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                              2)) -
                                                             (int const   )(*(__s2___14 +
                                                                              2)));
#line 1694
                                      if (__s1_len___0 > 2U) {
#line 1694
                                        if (__result___42 == 0) {
#line 1694
                                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(data)) +
                                                                                  3)) -
                                                                 (int const   )(*(__s2___14 +
                                                                                  3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
#line 1694
                              tmp___117 = __result___42;
                            }
                          } else {
                            goto _L___35;
                          }
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
#line 1694
                        tmp___146 = __builtin_constant_p((int )line);
#line 1694
                        if (tmp___146) {
#line 1694
                          if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                              1U) {
#line 1694
                            __s2_len___0 = strlen(line);
#line 1694
                            if (__s2_len___0 < 4U) {
#line 1694
                              tmp___145 = __builtin_constant_p((int )((char const   *)(data)));
#line 1694
                              if (tmp___145) {
#line 1694
                                if ((unsigned int )((void const   *)((char const   *)(data) +
                                                                     1)) - (unsigned int )((void const   *)((char const   *)(data))) ==
                                    1U) {
#line 1694
                                  tmp___117 = __builtin_strcmp((char const   *)(data),
                                                               line);
                                } else {
                                  goto _L___33;
                                }
                              } else {
                                _L___33: 
#line 1694
                                __s1___30 = (unsigned char const   *)((char const   *)(data));
#line 1694
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        0)) - (int const   )(*((unsigned char const   *)line +
                                                                                               0)));
#line 1694
                                if (__s2_len___0 > 0U) {
#line 1694
                                  if (__result___46 == 0) {
#line 1694
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            1)) -
                                                           (int const   )(*((unsigned char const   *)line +
                                                                            1)));
#line 1694
                                    if (__s2_len___0 > 1U) {
#line 1694
                                      if (__result___46 == 0) {
#line 1694
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                2)) -
                                                               (int const   )(*((unsigned char const   *)line +
                                                                                2)));
#line 1694
                                        if (__s2_len___0 > 2U) {
#line 1694
                                          if (__result___46 == 0) {
#line 1694
                                            __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                    3)) -
                                                                   (int const   )(*((unsigned char const   *)line +
                                                                                    3)));
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
#line 1694
                                tmp___117 = __result___46;
                              }
                            } else {
#line 1694
                              tmp___117 = __builtin_strcmp((char const   *)(data),
                                                           line);
                            }
                          } else {
#line 1694
                            tmp___117 = __builtin_strcmp((char const   *)(data), line);
                          }
                        } else {
#line 1694
                          tmp___117 = __builtin_strcmp((char const   *)(data), line);
                        }
                      }
                    }
#line 1694
                    tmp___81 = tmp___117;
                  } else {
#line 1694
                    tmp___151 = strlen(line);
#line 1694
                    tmp___81 = strncmp((char const   *)(data), line, tmp___151);
                  }
                } else {
#line 1694
                  tmp___151 = strlen(line);
#line 1694
                  tmp___81 = strncmp((char const   *)(data), line, tmp___151);
                }
              }
            } else {
#line 1694
              tmp___151 = strlen(line);
#line 1694
              tmp___81 = strncmp((char const   *)(data), line, tmp___151);
            }
#line 1694
            if (tmp___81 == 0) {
#line 1698
              last->t_line = lineLink(t_line->t_line);
            } else {
#line 1700
              last->t_line = lineCreate((char const   *)((char *)(data)));
            }
          } else {
#line 1700
            last->t_line = lineCreate((char const   *)((char *)(data)));
          }
        }
      }
#line 1702
      if (line) {
#line 1702
        if ((int )enctype == 2) {
#line 1703
          tmp___165 = __builtin_constant_p((int )line);
#line 1703
          if (tmp___165) {
#line 1703
            tmp___163 = (char *)__builtin_strchr(line, '=');
          } else {
#line 1703
            tmp___163 = (char *)__builtin_strchr(line, '=');
          }
#line 1703
          if (tmp___163) {
#line 1704
            break;
          }
        }
      }
      __Cont___0: 
#line 1648
      t_line = (text const   *)t_line->t_next;
    }
#line 1706
    if (m->base64chars) {
#line 1709
      memset((void *)(data___0), '\000', sizeof(data___0));
#line 1710
      tmp___166 = decode(m, (char const   *)((void *)0), data___0, & base64, (enum __anonenum_bool_35 )0);
#line 1710
      if (tmp___166) {
#line 1710
        if (data___0[0]) {
#line 1711
          if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 1712
            last = (text *)cli_malloc(sizeof(text ));
#line 1712
            first = last;
          } else {
#line 1714
            last->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 1715
            last = last->t_next;
          }
#line 1718
          if ((unsigned int )last != (unsigned int )((void *)0)) {
#line 1719
            last->t_line = lineCreate((char const   *)((char *)(data___0)));
          }
        }
      }
#line 1721
      m->base64chars = 0;
    }
    __Cont: 
#line 1582
    i ++;
  }
#line 1725
  if (last) {
#line 1726
    last->t_next = (struct text *)((void *)0);
  }
#line 1728
  return (first);
}
}
#line 1752 "message.c"
text const   *uuencodeBegin(message const   *m ) 
{ 

  {
#line 1755
  return (m->uuencode);
}
}
#line 1759 "message.c"
text const   *yEncBegin(message const   *m ) 
{ 

  {
#line 1762
  return (m->yenc);
}
}
#line 1781 "message.c"
text const   *binhexBegin(message const   *m ) 
{ 

  {
#line 1784
  return (m->binhex);
}
}
#line 1805 "message.c"
text const   *bounceBegin(message const   *m ) 
{ 

  {
#line 1808
  return (m->bounce);
}
}
#line 1837 "message.c"
text const   *encodingLine(message const   *m ) 
{ 

  {
#line 1840
  return (m->encoding);
}
}
#line 1844 "message.c"
void messageClearMarkers(message *m ) 
{ 

  {
#line 1847
  m->binhex = (text const   *)((void *)0);
#line 1847
  m->uuencode = m->binhex;
#line 1847
  m->bounce = m->uuencode;
#line 1847
  m->encoding = m->bounce;
#line 1848
  return;
}
}
#line 1856 "message.c"
unsigned char *decodeLine(message *m , encoding_type et , char const   *line , unsigned char *buf ,
                          size_t buflen ) 
{ size_t len ;
  size_t reallen ;
  bool softbreak ;
  char *p2 ;
  char *copy ;
  char base64buf[77] ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char byte ;
  unsigned char *tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  size_t __len___2 ;
  size_t tmp___23 ;
  char *__retval___2 ;
  char *tmp___24 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char const   *tmp___37 ;
  int tmp___113 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___149 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___168 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  size_t tmp___184 ;
  int tmp___185 ;
  size_t tmp___186 ;
  unsigned char *tmp___187 ;
  char const   *tmp___188 ;
  unsigned char *tmp___189 ;
  char const   *tmp___190 ;

  {
#line 1869
  switch ((int )et) {
  case 4: ;
  case 0: ;
  case 3: ;
  default: ;
#line 1878
  if (line) {
#line 1879
    buf = (unsigned char *)strrcpy((char *)buf, line);
  }
#line 1881
  tmp___0 = (unsigned char *)strrcpy((char *)buf, "\n");
#line 1881
  return (tmp___0);
  case 1: ;
#line 1884
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1885
    tmp___1 = buf;
#line 1885
    buf ++;
#line 1885
    (*tmp___1) = (unsigned char )'\n';
#line 1886
    break;
  }
#line 1889
  softbreak = (enum __anonenum_bool_35 )0;
#line 1890
  while (1) {
#line 1890
    if (buflen) {
#line 1890
      if (! (*line)) {
#line 1890
        break;
      }
    } else {
#line 1890
      break;
    }
#line 1891
    if ((int const   )(*line) == 61) {
#line 1894
      line ++;
#line 1894
      if ((int const   )(*line) == 0) {
#line 1895
        softbreak = (enum __anonenum_bool_35 )1;
#line 1897
        break;
      } else {
#line 1894
        if ((int const   )(*line) == 10) {
#line 1895
          softbreak = (enum __anonenum_bool_35 )1;
#line 1897
          break;
        }
      }
#line 1900
      byte = hex((char )(*line));
#line 1902
      line ++;
#line 1902
      if ((int const   )(*line) == 0) {
#line 1907
        tmp___2 = buf;
#line 1907
        buf ++;
#line 1907
        (*tmp___2) = byte;
#line 1908
        break;
      } else {
#line 1902
        if ((int const   )(*line) == 10) {
#line 1907
          tmp___2 = buf;
#line 1907
          buf ++;
#line 1907
          (*tmp___2) = byte;
#line 1908
          break;
        }
      }
#line 1911
      byte = (unsigned char )((int )byte << 4);
#line 1912
      tmp___3 = hex((char )(*line));
#line 1912
      byte = (unsigned char )((int )byte + (int )tmp___3);
#line 1913
      tmp___4 = buf;
#line 1913
      buf ++;
#line 1913
      (*tmp___4) = byte;
    } else {
#line 1915
      tmp___5 = buf;
#line 1915
      buf ++;
#line 1915
      (*tmp___5) = (unsigned char )(*line);
    }
#line 1916
    line ++;
#line 1917
    buflen --;
  }
#line 1919
  if (! softbreak) {
#line 1921
    tmp___6 = buf;
#line 1921
    buf ++;
#line 1921
    (*tmp___6) = (unsigned char )'\n';
  }
#line 1922
  break;
  case 2: ;
#line 1925
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1926
    break;
  }
#line 1931
  tmp___27 = strlen(line);
#line 1931
  if (tmp___27 < sizeof(base64buf)) {
#line 1932
    strcpy((char * __restrict  )(base64buf), (char const   * __restrict  )line);
#line 1933
    copy = base64buf;
  } else {
#line 1935
    tmp___26 = __builtin_constant_p((int )line);
#line 1935
    if (tmp___26) {
#line 1935
      if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
          1U) {
#line 1935
        if ((int const   )(*(line + 0)) == 0) {
#line 1935
          copy = (char *)calloc(1U, 1U);
        } else {
#line 1935
          tmp___23 = strlen(line);
#line 1935
          __len___2 = tmp___23 + 1U;
#line 1935
          tmp___24 = (char *)malloc(__len___2);
#line 1935
          __retval___2 = tmp___24;
#line 1935
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1935
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )line,
                                          __len___2);
          }
#line 1935
          copy = __retval___2;
        }
      } else {
#line 1935
        copy = __strdup(line);
      }
    } else {
#line 1935
      copy = __strdup(line);
    }
#line 1936
    if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 1937
      break;
    }
  }
#line 1940
  tmp___32 = __builtin_constant_p((int )copy);
#line 1940
  if (tmp___32) {
#line 1940
    p2 = (char *)__builtin_strchr(copy, '=');
  } else {
#line 1940
    p2 = (char *)__builtin_strchr(copy, '=');
  }
#line 1941
  if (p2) {
#line 1942
    (*p2) = (char )'\000';
  }
#line 1944
  sanitiseBase64(copy);
#line 1949
  if ((unsigned int )p2 == (unsigned int )((void *)0)) {
#line 1949
    tmp___33 = strlen((char const   *)copy);
#line 1949
    if ((tmp___33 & 3U) == 0U) {
#line 1949
      tmp___34 = 1;
    } else {
#line 1949
      tmp___34 = 0;
    }
  } else {
#line 1949
    tmp___34 = 0;
  }
#line 1949
  buf = decode(m, (char const   *)copy, buf, & base64, (enum __anonenum_bool_35 )tmp___34);
#line 1951
  if ((unsigned int )copy != (unsigned int )(base64buf)) {
#line 1952
    free((void *)copy);
  }
#line 1953
  break;
  case 5: ;
#line 1958
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1959
    break;
  } else {
#line 1958
    if ((int const   )(*line) == 0) {
#line 1959
      break;
    }
  }
#line 1960
  tmp___35 = strcasecmp(line, "end");
#line 1960
  if (tmp___35 == 0) {
#line 1961
    break;
  }
#line 1962
  tmp___36 = isuuencodebegin(line);
#line 1962
  if (tmp___36) {
#line 1963
    break;
  }
#line 1965
  if (((int const   )(*(line + 0)) & 63) == 32) {
#line 1966
    break;
  }
#line 1972
  tmp___37 = line;
#line 1972
  line ++;
#line 1972
  reallen = (size_t )uudecode((char )(*tmp___37));
#line 1973
  if (reallen <= 0U) {
#line 1974
    break;
  }
#line 1975
  if (reallen > 62U) {
#line 1976
    break;
  }
#line 1977
  len = strlen(line);
#line 1979
  if (len > buflen) {
#line 1985
    cli_warnmsg("uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\n");
  } else {
#line 1979
    if (reallen > len) {
#line 1985
      cli_warnmsg("uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\n");
    } else {
#line 1987
      decode(m, line, buf, & uudecode, (enum __anonenum_bool_35 )((len & 3U) == 0U));
#line 1988
      buf = buf + reallen;
    }
  }
#line 1990
  m->base64chars = 0;
#line 1991
  break;
  case 6: ;
#line 1993
  if ((unsigned int )line == (unsigned int )((void *)0)) {
#line 1994
    break;
  } else {
#line 1993
    if ((int const   )(*line) == 0) {
#line 1994
      break;
    }
  }
#line 1995
  tmp___183 = __builtin_constant_p((int )line);
#line 1995
  if (tmp___183) {
#line 1995
    tmp___184 = strlen(line);
#line 1995
    if (tmp___184 < 6U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
#line 1995
    tmp___185 = __builtin_constant_p((int )"=yend ");
#line 1995
    if (tmp___185) {
#line 1995
      tmp___186 = strlen("=yend ");
#line 1995
      if (tmp___186 < 6U) {
        _L___39: 
#line 1995
        tmp___180 = __builtin_constant_p((int )line);
#line 1995
        if (tmp___180) {
#line 1995
          tmp___181 = __builtin_constant_p((int )"=yend ");
#line 1995
          if (tmp___181) {
#line 1995
            __s1_len___0 = strlen(line);
#line 1995
            __s2_len___0 = strlen("=yend ");
#line 1995
            if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                   1U)) {
              goto _L___36;
            } else {
#line 1995
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 1995
                if (! ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                       1U)) {
#line 1995
                  tmp___182 = 1;
                } else {
#line 1995
                  if (__s2_len___0 >= 4U) {
#line 1995
                    tmp___182 = 1;
                  } else {
#line 1995
                    tmp___182 = 0;
                  }
                }
              } else {
#line 1995
                tmp___182 = 0;
              }
            }
#line 1995
            if (tmp___182) {
#line 1995
              tmp___149 = __builtin_strcmp(line, "=yend ");
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 1995
          tmp___179 = __builtin_constant_p((int )line);
#line 1995
          if (tmp___179) {
#line 1995
            if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                1U) {
#line 1995
              __s1_len___0 = strlen(line);
#line 1995
              if (__s1_len___0 < 4U) {
#line 1995
                tmp___168 = __builtin_constant_p((int )"=yend ");
#line 1995
                if (tmp___168) {
#line 1995
                  if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                      1U) {
#line 1995
                    tmp___149 = __builtin_strcmp(line, "=yend ");
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 1995
                  __s2___14 = (unsigned char const   *)"=yend ";
#line 1995
                  __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 1995
                  if (__s1_len___0 > 0U) {
#line 1995
                    if (__result___42 == 0) {
#line 1995
                      __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 1995
                      if (__s1_len___0 > 1U) {
#line 1995
                        if (__result___42 == 0) {
#line 1995
                          __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 1995
                          if (__s1_len___0 > 2U) {
#line 1995
                            if (__result___42 == 0) {
#line 1995
                              __result___42 = (int )((int const   )(*((unsigned char const   *)line +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 1995
                  tmp___149 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 1995
            tmp___178 = __builtin_constant_p((int )"=yend ");
#line 1995
            if (tmp___178) {
#line 1995
              if ((unsigned int )((void const   *)("=yend " + 1)) - (unsigned int )((void const   *)"=yend ") ==
                  1U) {
#line 1995
                __s2_len___0 = strlen("=yend ");
#line 1995
                if (__s2_len___0 < 4U) {
#line 1995
                  tmp___177 = __builtin_constant_p((int )line);
#line 1995
                  if (tmp___177) {
#line 1995
                    if ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)line) ==
                        1U) {
#line 1995
                      tmp___149 = __builtin_strcmp(line, "=yend ");
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 1995
                    __s1___30 = (unsigned char const   *)line;
#line 1995
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"=yend " +
                                                                                               0)));
#line 1995
                    if (__s2_len___0 > 0U) {
#line 1995
                      if (__result___46 == 0) {
#line 1995
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)"=yend " +
                                                                1)));
#line 1995
                        if (__s2_len___0 > 1U) {
#line 1995
                          if (__result___46 == 0) {
#line 1995
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"=yend " +
                                                                    2)));
#line 1995
                            if (__s2_len___0 > 2U) {
#line 1995
                              if (__result___46 == 0) {
#line 1995
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"=yend " +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 1995
                    tmp___149 = __result___46;
                  }
                } else {
#line 1995
                  tmp___149 = __builtin_strcmp(line, "=yend ");
                }
              } else {
#line 1995
                tmp___149 = __builtin_strcmp(line, "=yend ");
              }
            } else {
#line 1995
              tmp___149 = __builtin_strcmp(line, "=yend ");
            }
          }
        }
#line 1995
        tmp___113 = tmp___149;
      } else {
#line 1995
        tmp___113 = strncmp(line, "=yend ", 6U);
      }
    } else {
#line 1995
      tmp___113 = strncmp(line, "=yend ", 6U);
    }
  }
#line 1995
  if (tmp___113 == 0) {
#line 1996
    break;
  }
#line 1998
  while ((*line)) {
#line 1999
    if ((int const   )(*line) == 61) {
#line 2000
      line ++;
#line 2000
      if ((int const   )(*line) == 0) {
#line 2001
        break;
      }
#line 2002
      tmp___187 = buf;
#line 2002
      buf ++;
#line 2002
      tmp___188 = line;
#line 2002
      line ++;
#line 2002
      (*tmp___187) = (unsigned char )(((int const   )(*tmp___188) - 64) & 255);
    } else {
#line 2004
      tmp___189 = buf;
#line 2004
      buf ++;
#line 2004
      tmp___190 = line;
#line 2004
      line ++;
#line 2004
      (*tmp___189) = (unsigned char )(((int const   )(*tmp___190) - 42) & 255);
    }
  }
#line 2005
  break;
  }
#line 2008
  (*buf) = (unsigned char )'\000';
#line 2009
  return (buf);
}
}
#line 2018 "message.c"
static void sanitiseBase64(char *s ) 
{ char *p1 ;

  {
#line 2023
  while ((*s)) {
#line 2024
    if ((int const   )base64Table[(unsigned int )((int )(*s) & 255)] == 255) {
#line 2027
      p1 = s;
#line 2027
      while ((int )(*(p1 + 0)) != 0) {
#line 2028
        (*(p1 + 0)) = (*(p1 + 1));
#line 2027
        p1 ++;
      }
    }
#line 2023
    s ++;
  }
#line 2050
  return;
}
}
#line 2059 "message.c"
static unsigned char *decode(message *m , char const   *in , unsigned char *out ,
                             unsigned char (*decoder)(char  ) , bool isFast ) 
{ unsigned char b1 ;
  unsigned char b2 ;
  unsigned char b3 ;
  unsigned char b4 ;
  unsigned char cb1 ;
  unsigned char cb2 ;
  unsigned char cb3 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  int nbytes ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int nbytes___0 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;

  {
#line 2069
  cb3 = (unsigned char )'\000';
#line 2069
  cb2 = cb3;
#line 2069
  cb1 = cb2;
#line 2071
  switch (m->base64chars) {
  case 3: 
#line 2073
  cb3 = (unsigned char )m->base64_3;
  case 2: 
#line 2076
  cb2 = (unsigned char )m->base64_2;
  case 1: 
#line 2079
  cb1 = (unsigned char )m->base64_1;
#line 2080
  isFast = (enum __anonenum_bool_35 )0;
#line 2081
  break;
  default: ;
  }
#line 2086
  if (isFast) {
#line 2088
    while ((*in)) {
#line 2089
      tmp = in;
#line 2089
      in ++;
#line 2089
      b1 = ((*decoder))((char )(*tmp));
#line 2090
      tmp___0 = in;
#line 2090
      in ++;
#line 2090
      b2 = ((*decoder))((char )(*tmp___0));
#line 2091
      tmp___1 = in;
#line 2091
      in ++;
#line 2091
      b3 = ((*decoder))((char )(*tmp___1));
#line 2100
      tmp___2 = out;
#line 2100
      out ++;
#line 2100
      (*tmp___2) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
#line 2101
      tmp___3 = in;
#line 2101
      in ++;
#line 2101
      b4 = ((*decoder))((char )(*tmp___3));
#line 2102
      tmp___4 = out;
#line 2102
      out ++;
#line 2102
      (*tmp___4) = (unsigned char )(((int )b2 << 4) | (((int )b3 >> 2) & 15));
#line 2103
      tmp___5 = out;
#line 2103
      out ++;
#line 2103
      (*tmp___5) = (unsigned char )(((int )b3 << 6) | ((int )b4 & 63));
    }
  } else {
#line 2105
    if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 2108
      if (m->base64chars == 0) {
#line 2109
        return (out);
      }
#line 2111
      if (cb3) {
#line 2111
        tmp___6 = (int )cb3;
      } else {
#line 2111
        tmp___6 = '@';
      }
#line 2111
      if (cb2) {
#line 2111
        tmp___7 = (int )cb2;
      } else {
#line 2111
        tmp___7 = '@';
      }
#line 2111
      if (cb1) {
#line 2111
        tmp___8 = (int )cb1;
      } else {
#line 2111
        tmp___8 = '@';
      }
#line 2111
      cli_dbgmsg("base64chars = %d (%c %c %c)\n", m->base64chars, tmp___8, tmp___7,
                 tmp___6);
#line 2116
      m->base64chars = m->base64chars - 1;
#line 2117
      b1 = cb1;
#line 2118
      nbytes = 1;
#line 2120
      if (m->base64chars) {
#line 2121
        m->base64chars = m->base64chars - 1;
#line 2122
        b2 = cb2;
#line 2124
        if (m->base64chars) {
#line 2125
          nbytes = 2;
#line 2126
          m->base64chars = m->base64chars - 1;
#line 2127
          b3 = cb3;
#line 2128
          nbytes = 3;
        } else {
#line 2129
          if (b2) {
#line 2130
            nbytes = 2;
          }
        }
      }
#line 2133
      switch (nbytes) {
      case 3: 
#line 2135
      b4 = (unsigned char )'\000';
      case 4: 
#line 2138
      tmp___9 = out;
#line 2138
      out ++;
#line 2138
      (*tmp___9) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
#line 2139
      tmp___10 = out;
#line 2139
      out ++;
#line 2139
      (*tmp___10) = (unsigned char )(((int )b2 << 4) | (((int )b3 >> 2) & 15));
#line 2140
      tmp___11 = out;
#line 2140
      out ++;
#line 2140
      (*tmp___11) = (unsigned char )(((int )b3 << 6) | ((int )b4 & 63));
#line 2141
      break;
      case 2: 
#line 2143
      tmp___12 = out;
#line 2143
      out ++;
#line 2143
      (*tmp___12) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
#line 2144
      if (((int )b2 << 4) & 255) {
#line 2145
        tmp___13 = out;
#line 2145
        out ++;
#line 2145
        (*tmp___13) = (unsigned char )((int )b2 << 4);
      }
#line 2146
      break;
      case 1: 
#line 2148
      tmp___14 = out;
#line 2148
      out ++;
#line 2148
      (*tmp___14) = (unsigned char )((int )b1 << 2);
#line 2149
      break;
      default: ;
      }
    } else {
#line 2153
      while ((*in)) {
#line 2156
        if (m->base64chars) {
#line 2157
          m->base64chars = m->base64chars - 1;
#line 2158
          b1 = cb1;
        } else {
#line 2160
          tmp___15 = in;
#line 2160
          in ++;
#line 2160
          b1 = ((*decoder))((char )(*tmp___15));
        }
#line 2162
        if ((int const   )(*in) == 0) {
#line 2163
          b2 = (unsigned char )'\000';
#line 2164
          nbytes___0 = 1;
        } else {
#line 2166
          if (m->base64chars) {
#line 2167
            m->base64chars = m->base64chars - 1;
#line 2168
            b2 = cb2;
          } else {
#line 2170
            tmp___16 = in;
#line 2170
            in ++;
#line 2170
            b2 = ((*decoder))((char )(*tmp___16));
          }
#line 2172
          if ((int const   )(*in) == 0) {
#line 2173
            b3 = (unsigned char )'\000';
#line 2174
            nbytes___0 = 2;
          } else {
#line 2176
            if (m->base64chars) {
#line 2177
              m->base64chars = m->base64chars - 1;
#line 2178
              b3 = cb3;
            } else {
#line 2180
              tmp___17 = in;
#line 2180
              in ++;
#line 2180
              b3 = ((*decoder))((char )(*tmp___17));
            }
#line 2182
            if ((int const   )(*in) == 0) {
#line 2183
              b4 = (unsigned char )'\000';
#line 2184
              nbytes___0 = 3;
            } else {
#line 2186
              tmp___18 = in;
#line 2186
              in ++;
#line 2186
              b4 = ((*decoder))((char )(*tmp___18));
#line 2187
              nbytes___0 = 4;
            }
          }
        }
#line 2192
        switch (nbytes___0) {
        case 3: 
#line 2194
        m->base64_3 = (char )b3;
        case 2: 
#line 2196
        m->base64_2 = (char )b2;
        case 1: 
#line 2198
        m->base64_1 = (char )b1;
#line 2199
        break;
        case 4: 
#line 2201
        tmp___19 = out;
#line 2201
        out ++;
#line 2201
        (*tmp___19) = (unsigned char )(((int )b1 << 2) | (((int )b2 >> 4) & 3));
#line 2202
        tmp___20 = out;
#line 2202
        out ++;
#line 2202
        (*tmp___20) = (unsigned char )(((int )b2 << 4) | (((int )b3 >> 2) & 15));
#line 2203
        tmp___21 = out;
#line 2203
        out ++;
#line 2203
        (*tmp___21) = (unsigned char )(((int )b3 << 6) | ((int )b4 & 63));
#line 2204
        break;
        default: ;
        }
#line 2208
        if (nbytes___0 != 4) {
#line 2209
          m->base64chars = nbytes___0;
#line 2210
          break;
        }
      }
    }
  }
#line 2213
  return (out);
}
}
#line 2216 "message.c"
static unsigned char hex(char c ) 
{ unsigned short const   **tmp ;

  {
#line 2219
  tmp = __ctype_b_loc();
#line 2219
  if ((int const   )(*((*tmp) + (int )c)) & 2048) {
#line 2220
    return ((unsigned char )((int )c - 48));
  }
#line 2221
  if ((int )c >= 65) {
#line 2221
    if ((int )c <= 70) {
#line 2222
      return ((unsigned char )(((int )c - 65) + 10));
    }
  }
#line 2223
  if ((int )c >= 97) {
#line 2223
    if ((int )c <= 102) {
#line 2224
      return ((unsigned char )(((int )c - 97) + 10));
    }
  }
#line 2225
  cli_dbgmsg("Illegal hex character \'%c\'\n", c);
#line 2231
  return ((unsigned char )'=');
}
}
#line 2235 "message.c"
static unsigned char base64(char c ) 
{ unsigned char ret ;

  {
#line 2238
  ret = (unsigned char )base64Table[(unsigned int )((int )c & 255)];
#line 2240
  if ((int )ret == 255) {
#line 2242
    return ((unsigned char)63);
  }
#line 2244
  return (ret);
}
}
#line 2266 "message.c"
static unsigned char uudecode(char c ) 
{ 

  {
#line 2269
  return ((unsigned char )((int )c - 32));
}
}
#line 2279 "message.c"
static int usefulArg(char const   *arg ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2282
  tmp = strncasecmp(arg, "name", 4U);
#line 2282
  if (tmp != 0) {
#line 2282
    tmp___0 = strncasecmp(arg, "filename", 8U);
#line 2282
    if (tmp___0 != 0) {
#line 2282
      tmp___1 = strncasecmp(arg, "boundary", 8U);
#line 2282
      if (tmp___1 != 0) {
#line 2282
        tmp___2 = strncasecmp(arg, "protocol", 8U);
#line 2282
        if (tmp___2 != 0) {
#line 2282
          tmp___3 = strncasecmp(arg, "id", 2U);
#line 2282
          if (tmp___3 != 0) {
#line 2282
            tmp___4 = strncasecmp(arg, "number", 6U);
#line 2282
            if (tmp___4 != 0) {
#line 2282
              tmp___5 = strncasecmp(arg, "total", 5U);
#line 2282
              if (tmp___5 != 0) {
#line 2282
                tmp___6 = strncasecmp(arg, "type", 4U);
#line 2282
                if (tmp___6 != 0) {
#line 2290
                  cli_dbgmsg("Discarding unwanted argument \'%s\'\n", arg);
#line 2291
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 2293
  return (1);
}
}
#line 2300 "message.c"
static void messageDedup(message *m ) 
{ text const   *t1 ;
  size_t saved ;
  char const   *d1 ;
  text *t2 ;
  line_t *l1 ;
  unsigned int r1 ;
  size_t tmp ;
  char const   *d2 ;
  line_t *l2 ;
  size_t tmp___1 ;
  line_t *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___38 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___57 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;

  {
#line 2304
  saved = 0U;
#line 2306
  cli_dbgmsg("messageDedup\n");
#line 2308
  if (m->dedupedThisFar) {
#line 2308
    t1 = m->dedupedThisFar;
  } else {
#line 2308
    t1 = (text const   *)m->body_first;
  }
#line 2310
  t1 = (text const   *)m->body_first;
#line 2310
  while (t1) {
#line 2316
    if (saved >= 100000U) {
#line 2317
      break;
    }
#line 2318
    l1 = t1->t_line;
#line 2319
    if ((unsigned int )l1 == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 2321
    d1 = lineGetData((line_t const   *)l1);
#line 2322
    tmp = strlen(d1);
#line 2322
    if (tmp < 8U) {
      goto __Cont;
    }
#line 2325
    r1 = (unsigned int )lineGetRefCount((line_t const   *)l1);
#line 2326
    if (r1 == 255U) {
      goto __Cont;
    }
#line 2331
    if ((unsigned int )t1 == (unsigned int )m->encoding) {
      goto __Cont;
    }
#line 2333
    if ((unsigned int )t1 == (unsigned int )m->bounce) {
      goto __Cont;
    }
#line 2335
    if ((unsigned int )t1 == (unsigned int )m->uuencode) {
      goto __Cont;
    }
#line 2337
    if ((unsigned int )t1 == (unsigned int )m->binhex) {
      goto __Cont;
    }
#line 2339
    if ((unsigned int )t1 == (unsigned int )m->yenc) {
      goto __Cont;
    }
#line 2342
    t2 = t1->t_next;
#line 2342
    while (t2) {
#line 2344
      l2 = t2->t_line;
#line 2346
      if ((unsigned int )l2 == (unsigned int )((void *)0)) {
        goto __Cont___0;
      }
#line 2348
      d2 = lineGetData((line_t const   *)l2);
#line 2349
      if ((unsigned int )d1 == (unsigned int )d2) {
        goto __Cont___0;
      }
#line 2352
      tmp___69 = __builtin_constant_p((int )d1);
#line 2352
      if (tmp___69) {
#line 2352
        tmp___70 = __builtin_constant_p((int )d2);
#line 2352
        if (tmp___70) {
#line 2352
          __s1_len = strlen(d1);
#line 2352
          __s2_len = strlen(d2);
#line 2352
          if (! ((unsigned int )((void const   *)(d1 + 1)) - (unsigned int )((void const   *)d1) ==
                 1U)) {
            goto _L___16;
          } else {
#line 2352
            if (__s1_len >= 4U) {
              _L___16: 
#line 2352
              if (! ((unsigned int )((void const   *)(d2 + 1)) - (unsigned int )((void const   *)d2) ==
                     1U)) {
#line 2352
                tmp___71 = 1;
              } else {
#line 2352
                if (__s2_len >= 4U) {
#line 2352
                  tmp___71 = 1;
                } else {
#line 2352
                  tmp___71 = 0;
                }
              }
            } else {
#line 2352
              tmp___71 = 0;
            }
          }
#line 2352
          if (tmp___71) {
#line 2352
            tmp___38 = __builtin_strcmp(d1, d2);
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
#line 2352
        tmp___68 = __builtin_constant_p((int )d1);
#line 2352
        if (tmp___68) {
#line 2352
          if ((unsigned int )((void const   *)(d1 + 1)) - (unsigned int )((void const   *)d1) ==
              1U) {
#line 2352
            __s1_len = strlen(d1);
#line 2352
            if (__s1_len < 4U) {
#line 2352
              tmp___57 = __builtin_constant_p((int )d2);
#line 2352
              if (tmp___57) {
#line 2352
                if ((unsigned int )((void const   *)(d2 + 1)) - (unsigned int )((void const   *)d2) ==
                    1U) {
#line 2352
                  tmp___38 = __builtin_strcmp(d1, d2);
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
#line 2352
                __s2___6 = (unsigned char const   *)d2;
#line 2352
                __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
#line 2352
                if (__s1_len > 0U) {
#line 2352
                  if (__result___18 == 0) {
#line 2352
                    __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
#line 2352
                    if (__s1_len > 1U) {
#line 2352
                      if (__result___18 == 0) {
#line 2352
                        __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
#line 2352
                        if (__s1_len > 2U) {
#line 2352
                          if (__result___18 == 0) {
#line 2352
                            __result___18 = (int )((int const   )(*((unsigned char const   *)d1 +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 2352
                tmp___38 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
#line 2352
          tmp___67 = __builtin_constant_p((int )d2);
#line 2352
          if (tmp___67) {
#line 2352
            if ((unsigned int )((void const   *)(d2 + 1)) - (unsigned int )((void const   *)d2) ==
                1U) {
#line 2352
              __s2_len = strlen(d2);
#line 2352
              if (__s2_len < 4U) {
#line 2352
                tmp___66 = __builtin_constant_p((int )d1);
#line 2352
                if (tmp___66) {
#line 2352
                  if ((unsigned int )((void const   *)(d1 + 1)) - (unsigned int )((void const   *)d1) ==
                      1U) {
#line 2352
                    tmp___38 = __builtin_strcmp(d1, d2);
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
#line 2352
                  __s1___14 = (unsigned char const   *)d1;
#line 2352
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)d2 +
                                                                                             0)));
#line 2352
                  if (__s2_len > 0U) {
#line 2352
                    if (__result___22 == 0) {
#line 2352
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)d2 +
                                                                                                 1)));
#line 2352
                      if (__s2_len > 1U) {
#line 2352
                        if (__result___22 == 0) {
#line 2352
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)d2 +
                                                                  2)));
#line 2352
                          if (__s2_len > 2U) {
#line 2352
                            if (__result___22 == 0) {
#line 2352
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)d2 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 2352
                  tmp___38 = __result___22;
                }
              } else {
#line 2352
                tmp___38 = __builtin_strcmp(d1, d2);
              }
            } else {
#line 2352
              tmp___38 = __builtin_strcmp(d1, d2);
            }
          } else {
#line 2352
            tmp___38 = __builtin_strcmp(d1, d2);
          }
        }
      }
#line 2352
      if (tmp___38 == 0) {
#line 2353
        tmp___2 = lineUnlink(l2);
#line 2353
        if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 2354
          tmp___1 = strlen(d1);
#line 2354
          saved += tmp___1 + 1U;
        }
#line 2355
        t2->t_line = lineLink(l1);
#line 2356
        if ((unsigned int )t2->t_line == (unsigned int )((void *)0)) {
#line 2357
          cli_errmsg("messageDedup: out of memory\n");
#line 2358
          return;
        }
#line 2360
        r1 ++;
#line 2360
        if (r1 == 255U) {
#line 2361
          break;
        }
      }
      __Cont___0: 
#line 2342
      t2 = t2->t_next;
    }
    __Cont: 
#line 2310
    t1 = (text const   *)t1->t_next;
  }
#line 2366
  cli_dbgmsg("messageDedup reclaimed %u bytes\n", saved);
#line 2367
  m->dedupedThisFar = t1;
#line 2368
  return;
}
}
#line 2377 "message.c"
static char *rfc2231(char const   *in ) 
{ char const   *ptr ;
  char *ret ;
  char *out ;
  enum __anonenum_field_35 field ;
  char *tmp___10 ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  unsigned char byte ;
  char *tmp___23 ;
  unsigned char tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___39 ;
  size_t __len___6 ;
  size_t tmp___45 ;
  char *__retval___6 ;
  char *tmp___46 ;
  int tmp___48 ;

  {
#line 2382
  field = (enum __anonenum_field_35 )0;
#line 2384
  ptr = strstr(in, "*=");
#line 2386
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 2387
    tmp___19 = __builtin_constant_p((int )in);
#line 2387
    if (tmp___19) {
#line 2387
      if ((unsigned int )((void const   *)(in + 1)) - (unsigned int )((void const   *)in) ==
          1U) {
#line 2387
        if ((int const   )(*(in + 0)) == 0) {
#line 2387
          tmp___10 = (char *)calloc(1U, 1U);
        } else {
#line 2387
          tmp___16 = strlen(in);
#line 2387
          __len___2 = tmp___16 + 1U;
#line 2387
          tmp___17 = (char *)malloc(__len___2);
#line 2387
          __retval___2 = tmp___17;
#line 2387
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 2387
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )in,
                                          __len___2);
          }
#line 2387
          tmp___10 = __retval___2;
        }
      } else {
#line 2387
        tmp___10 = __strdup(in);
      }
    } else {
#line 2387
      tmp___10 = __strdup(in);
    }
#line 2387
    return (tmp___10);
  }
#line 2389
  cli_dbgmsg("rfc2231 \'%s\'\n", in);
#line 2391
  tmp___20 = strlen(in);
#line 2391
  ret = (char *)cli_malloc(tmp___20 + 1U);
#line 2393
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 2394
    return ((char *)((void *)0));
  }
#line 2396
  out = ret;
#line 2396
  while ((unsigned int )in != (unsigned int )ptr) {
#line 2397
    tmp___21 = out;
#line 2397
    out ++;
#line 2397
    (*tmp___21) = (char )(*in);
#line 2396
    in ++;
  }
#line 2399
  tmp___22 = out;
#line 2399
  out ++;
#line 2399
  (*tmp___22) = (char )'=';
#line 2405
  while ((*in)) {
#line 2406
    switch ((int )field) {
    case 0: ;
#line 2408
    if ((int const   )(*in) == 39) {
#line 2409
      field = (enum __anonenum_field_35 )1;
    }
#line 2410
    break;
    case 1: ;
#line 2412
    if ((int const   )(*in) == 39) {
#line 2413
      field = (enum __anonenum_field_35 )2;
    }
#line 2414
    break;
    case 2: ;
#line 2416
    if ((int const   )(*in) == 37) {
#line 2419
      in ++;
#line 2419
      if ((int const   )(*in) == 0) {
#line 2420
        break;
      } else {
#line 2419
        if ((int const   )(*in) == 10) {
#line 2420
          break;
        }
      }
#line 2422
      byte = hex((char )(*in));
#line 2424
      in ++;
#line 2424
      if ((int const   )(*in) == 0) {
#line 2425
        tmp___23 = out;
#line 2425
        out ++;
#line 2425
        (*tmp___23) = (char )byte;
#line 2426
        break;
      } else {
#line 2424
        if ((int const   )(*in) == 10) {
#line 2425
          tmp___23 = out;
#line 2425
          out ++;
#line 2425
          (*tmp___23) = (char )byte;
#line 2426
          break;
        }
      }
#line 2429
      byte = (unsigned char )((int )byte << 4);
#line 2430
      tmp___24 = hex((char )(*in));
#line 2430
      byte = (unsigned char )((int )byte + (int )tmp___24);
#line 2431
      tmp___25 = out;
#line 2431
      out ++;
#line 2431
      (*tmp___25) = (char )byte;
    } else {
#line 2433
      tmp___26 = out;
#line 2433
      out ++;
#line 2433
      (*tmp___26) = (char )(*in);
    }
    }
#line 2435
    tmp___27 = in;
#line 2435
    in ++;
#line 2435
    if ((int const   )(*tmp___27) == 0) {
#line 2442
      break;
    }
  }
#line 2445
  if ((int )field != 2) {
#line 2446
    free((void *)ret);
#line 2447
    cli_warnmsg("Invalid RFC2231 header: \'%s\'\n", in);
#line 2448
    tmp___48 = __builtin_constant_p((int )"");
#line 2448
    if (tmp___48) {
#line 2448
      if ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") ==
          1U) {
#line 2448
        if ((int const   )(*("" + 0)) == 0) {
#line 2448
          tmp___39 = (char *)calloc(1U, 1U);
        } else {
#line 2448
          tmp___45 = strlen("");
#line 2448
          __len___6 = tmp___45 + 1U;
#line 2448
          tmp___46 = (char *)malloc(__len___6);
#line 2448
          __retval___6 = tmp___46;
#line 2448
          if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 2448
            __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"",
                                          __len___6);
          }
#line 2448
          tmp___39 = __retval___6;
        }
      } else {
#line 2448
        tmp___39 = __strdup("");
      }
    } else {
#line 2448
      tmp___39 = __strdup("");
    }
#line 2448
    return (tmp___39);
  }
#line 2451
  (*out) = (char )'\000';
#line 2453
  cli_dbgmsg("rfc2231 returns \'%s\'\n", ret);
#line 2455
  return (ret);
}
}
#line 2476
static int push(LINK1 *top , char const   *string ) ;
#line 2477
static int pop(LINK1 *top , char *buffer ) ;
#line 2478
static unsigned int compare(char *ls1 , char **rs1 , char *ls2 , char **rs2 ) ;
#line 2482 "message.c"
static int simil(char const   *str1 , char const   *str2 ) 
{ LINK1 top ;
  unsigned int score ;
  unsigned int common ;
  unsigned int total ;
  unsigned int len1 ;
  unsigned int len2 ;
  char ls1[50] ;
  char ls2[50] ;
  char *rs1 ;
  char *rs2 ;
  char *s1 ;
  char *s2 ;
  int tmp ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;
  size_t __len___6 ;
  size_t tmp___36 ;
  char *__retval___6 ;
  char *tmp___37 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  unsigned int tmp___47 ;

  {
#line 2485
  top = (ELEMENT1 *)((void *)0);
#line 2486
  score = 0U;
#line 2490
  rs1 = (char *)((void *)0);
#line 2490
  rs2 = (char *)((void *)0);
#line 2493
  tmp = strcasecmp(str1, str2);
#line 2493
  if (tmp == 0) {
#line 2494
    return (100);
  }
#line 2496
  tmp___19 = __builtin_constant_p((int )str1);
#line 2496
  if (tmp___19) {
#line 2496
    if ((unsigned int )((void const   *)(str1 + 1)) - (unsigned int )((void const   *)str1) ==
        1U) {
#line 2496
      if ((int const   )(*(str1 + 0)) == 0) {
#line 2496
        s1 = (char *)calloc(1U, 1U);
      } else {
#line 2496
        tmp___16 = strlen(str1);
#line 2496
        __len___2 = tmp___16 + 1U;
#line 2496
        tmp___17 = (char *)malloc(__len___2);
#line 2496
        __retval___2 = tmp___17;
#line 2496
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 2496
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )str1,
                                        __len___2);
        }
#line 2496
        s1 = __retval___2;
      }
    } else {
#line 2496
      s1 = __strdup(str1);
    }
  } else {
#line 2496
    s1 = __strdup(str1);
  }
#line 2496
  if ((unsigned int )s1 == (unsigned int )((void *)0)) {
#line 2497
    return (-2);
  }
#line 2498
  tmp___39 = __builtin_constant_p((int )str2);
#line 2498
  if (tmp___39) {
#line 2498
    if ((unsigned int )((void const   *)(str2 + 1)) - (unsigned int )((void const   *)str2) ==
        1U) {
#line 2498
      if ((int const   )(*(str2 + 0)) == 0) {
#line 2498
        s2 = (char *)calloc(1U, 1U);
      } else {
#line 2498
        tmp___36 = strlen(str2);
#line 2498
        __len___6 = tmp___36 + 1U;
#line 2498
        tmp___37 = (char *)malloc(__len___6);
#line 2498
        __retval___6 = tmp___37;
#line 2498
        if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 2498
          __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )str2,
                                        __len___6);
        }
#line 2498
        s2 = __retval___6;
      }
    } else {
#line 2498
      s2 = __strdup(str2);
    }
  } else {
#line 2498
    s2 = __strdup(str2);
  }
#line 2498
  if ((unsigned int )s2 == (unsigned int )((void *)0)) {
#line 2499
    free((void *)s1);
#line 2500
    return (-2);
  }
#line 2503
  total = strstrip(s1);
#line 2503
  if (total > 49U) {
#line 2504
    free((void *)s1);
#line 2505
    free((void *)s2);
#line 2506
    return (-5);
  } else {
#line 2503
    len2 = strstrip(s2);
#line 2503
    if (len2 > 49U) {
#line 2504
      free((void *)s1);
#line 2505
      free((void *)s2);
#line 2506
      return (-5);
    }
  }
#line 2509
  total += len2;
#line 2511
  tmp___40 = push(& top, (char const   *)s1);
#line 2511
  if (tmp___40 == -2) {
#line 2513
    free((void *)s1);
#line 2514
    free((void *)s2);
#line 2515
    return (-2);
  } else {
#line 2511
    tmp___41 = push(& top, (char const   *)s2);
#line 2511
    if (tmp___41 == -2) {
#line 2513
      free((void *)s1);
#line 2514
      free((void *)s2);
#line 2515
      return (-2);
    }
  }
#line 2518
  while (1) {
#line 2518
    tmp___46 = pop(& top, ls2);
#line 2518
    if (! (tmp___46 == -4)) {
#line 2518
      break;
    }
#line 2519
    pop(& top, ls1);
#line 2520
    common = compare(ls1, & rs1, ls2, & rs2);
#line 2521
    if (common > 0U) {
#line 2522
      score += common;
#line 2523
      len1 = strlen((char const   *)(ls1));
#line 2524
      len2 = strlen((char const   *)(ls2));
#line 2526
      if (len1 > 1U) {
#line 2526
        if (len2 >= 1U) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
#line 2526
        if (len2 > 1U) {
#line 2526
          if (len1 >= 1U) {
            _L: 
#line 2527
            tmp___42 = push(& top, (char const   *)(ls1));
#line 2527
            if (tmp___42 == -2) {
#line 2528
              free((void *)s1);
#line 2529
              free((void *)s2);
#line 2530
              return (-2);
            } else {
#line 2527
              tmp___43 = push(& top, (char const   *)(ls2));
#line 2527
              if (tmp___43 == -2) {
#line 2528
                free((void *)s1);
#line 2529
                free((void *)s2);
#line 2530
                return (-2);
              }
            }
          }
        }
      }
#line 2532
      len1 = strlen((char const   *)rs1);
#line 2533
      len2 = strlen((char const   *)rs2);
#line 2535
      if (len1 > 1U) {
#line 2535
        if (len2 >= 1U) {
          goto _L___1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
#line 2535
        if (len2 > 1U) {
#line 2535
          if (len1 >= 1U) {
            _L___1: 
#line 2536
            tmp___44 = push(& top, (char const   *)rs1);
#line 2536
            if (tmp___44 == -2) {
#line 2537
              free((void *)s1);
#line 2538
              free((void *)s2);
#line 2539
              return (-2);
            } else {
#line 2536
              tmp___45 = push(& top, (char const   *)rs2);
#line 2536
              if (tmp___45 == -2) {
#line 2537
                free((void *)s1);
#line 2538
                free((void *)s2);
#line 2539
                return (-2);
              }
            }
          }
        }
      }
    }
  }
#line 2543
  free((void *)s1);
#line 2544
  free((void *)s2);
#line 2545
  if (total > 0U) {
#line 2545
    tmp___47 = (score * 200U) / total;
  } else {
#line 2545
    tmp___47 = 0U;
  }
#line 2545
  return ((int )tmp___47);
}
}
#line 2548 "message.c"
static unsigned int compare(char *ls1 , char **rs1 , char *ls2 , char **rs2 ) 
{ unsigned int common ;
  unsigned int diff ;
  unsigned int maxchars ;
  bool some_similarity ;
  char *s1 ;
  char *s2 ;
  char *maxs1 ;
  char *maxs2 ;
  char *maxe1 ;
  char *maxe2 ;
  char *cs1 ;
  char *cs2 ;
  char *start1 ;
  char *end1 ;
  char *end2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___2 ;
  int tmp___3 ;
  __int32_t const   **tmp___4 ;
  int __res___0 ;
  int __c___0 ;
  __int32_t const   **tmp___6 ;
  int tmp___7 ;
  __int32_t const   **tmp___8 ;
  int __res___1 ;
  int __c___1 ;
  __int32_t const   **tmp___10 ;
  int tmp___11 ;
  __int32_t const   **tmp___12 ;
  int __res___2 ;
  int __c___2 ;
  __int32_t const   **tmp___14 ;
  int tmp___15 ;
  __int32_t const   **tmp___16 ;

  {
#line 2551
  maxchars = 0U;
#line 2552
  some_similarity = (enum __anonenum_bool_35 )0;
#line 2554
  maxs1 = (char *)((void *)0);
#line 2554
  maxs2 = (char *)((void *)0);
#line 2554
  maxe1 = (char *)((void *)0);
#line 2554
  maxe2 = (char *)((void *)0);
#line 2557
  tmp = strlen((char const   *)ls1);
#line 2557
  end1 = ls1 + tmp;
#line 2558
  tmp___0 = strlen((char const   *)ls2);
#line 2558
  end2 = ls2 + tmp___0;
#line 2559
  start1 = ls1;
#line 2561
  while (1) {
#line 2562
    s1 = start1;
#line 2563
    s2 = ls2;
#line 2565
    if ((unsigned int )s1 < (unsigned int )end1) {
#line 2566
      while (1) {
#line 2566
        if ((unsigned int )s1 < (unsigned int )end1) {
#line 2566
          if (! ((unsigned int )s2 < (unsigned int )end2)) {
#line 2566
            break;
          }
        } else {
#line 2566
          break;
        }
#line 2567
        if (sizeof((*s1)) > 1U) {
#line 2567
          tmp___11 = __builtin_constant_p((int )(*s1));
#line 2567
          if (tmp___11) {
#line 2567
            __c___1 = (int )(*s1);
#line 2567
            if (__c___1 < -128) {
#line 2567
              __res___1 = __c___1;
            } else {
#line 2567
              if (__c___1 > 255) {
#line 2567
                __res___1 = __c___1;
              } else {
#line 2567
                tmp___10 = __ctype_tolower_loc();
#line 2567
                __res___1 = (*((*tmp___10) + __c___1));
              }
            }
          } else {
#line 2567
            __res___1 = tolower__extinline((int )(*s1));
          }
        } else {
#line 2567
          tmp___12 = __ctype_tolower_loc();
#line 2567
          __res___1 = (*((*tmp___12) + (int )(*s1)));
        }
#line 2567
        if (sizeof((*s2)) > 1U) {
#line 2567
          tmp___15 = __builtin_constant_p((int )(*s2));
#line 2567
          if (tmp___15) {
#line 2567
            __c___2 = (int )(*s2);
#line 2567
            if (__c___2 < -128) {
#line 2567
              __res___2 = __c___2;
            } else {
#line 2567
              if (__c___2 > 255) {
#line 2567
                __res___2 = __c___2;
              } else {
#line 2567
                tmp___14 = __ctype_tolower_loc();
#line 2567
                __res___2 = (*((*tmp___14) + __c___2));
              }
            }
          } else {
#line 2567
            __res___2 = tolower__extinline((int )(*s2));
          }
        } else {
#line 2567
          tmp___16 = __ctype_tolower_loc();
#line 2567
          __res___2 = (*((*tmp___16) + (int )(*s2)));
        }
#line 2567
        if (__res___1 == __res___2) {
#line 2568
          some_similarity = (enum __anonenum_bool_35 )1;
#line 2569
          cs1 = s1;
#line 2570
          cs2 = s2;
#line 2571
          common = 0U;
#line 2580
          while (1) {
#line 2573
            if ((unsigned int )s1 == (unsigned int )end1) {
#line 2574
              break;
            } else {
#line 2573
              if ((unsigned int )s2 == (unsigned int )end2) {
#line 2574
                break;
              } else {
#line 2576
                s1 ++;
#line 2577
                s2 ++;
#line 2578
                common ++;
              }
            }
#line 2580
            if (sizeof((*s1)) > 1U) {
#line 2580
              tmp___3 = __builtin_constant_p((int )(*s1));
#line 2580
              if (tmp___3) {
#line 2580
                __c = (int )(*s1);
#line 2580
                if (__c < -128) {
#line 2580
                  __res = __c;
                } else {
#line 2580
                  if (__c > 255) {
#line 2580
                    __res = __c;
                  } else {
#line 2580
                    tmp___2 = __ctype_tolower_loc();
#line 2580
                    __res = (*((*tmp___2) + __c));
                  }
                }
              } else {
#line 2580
                __res = tolower__extinline((int )(*s1));
              }
            } else {
#line 2580
              tmp___4 = __ctype_tolower_loc();
#line 2580
              __res = (*((*tmp___4) + (int )(*s1)));
            }
#line 2580
            if (sizeof((*s2)) > 1U) {
#line 2580
              tmp___7 = __builtin_constant_p((int )(*s2));
#line 2580
              if (tmp___7) {
#line 2580
                __c___0 = (int )(*s2);
#line 2580
                if (__c___0 < -128) {
#line 2580
                  __res___0 = __c___0;
                } else {
#line 2580
                  if (__c___0 > 255) {
#line 2580
                    __res___0 = __c___0;
                  } else {
#line 2580
                    tmp___6 = __ctype_tolower_loc();
#line 2580
                    __res___0 = (*((*tmp___6) + __c___0));
                  }
                }
              } else {
#line 2580
                __res___0 = tolower__extinline((int )(*s2));
              }
            } else {
#line 2580
              tmp___8 = __ctype_tolower_loc();
#line 2580
              __res___0 = (*((*tmp___8) + (int )(*s2)));
            }
#line 2580
            if (! (__res == __res___0)) {
#line 2572
              break;
            }
          }
#line 2582
          if (common > maxchars) {
#line 2583
            diff = common - maxchars;
#line 2584
            maxchars = common;
#line 2585
            maxs1 = cs1;
#line 2586
            maxs2 = cs2;
#line 2587
            maxe1 = s1;
#line 2588
            maxe2 = s2;
#line 2589
            end1 -= diff;
#line 2590
            end2 -= diff;
          } else {
#line 2592
            s1 -= common;
          }
        } else {
#line 2594
          s2 ++;
        }
      }
#line 2596
      start1 ++;
    } else {
#line 2598
      break;
    }
  }
#line 2600
  if (some_similarity) {
#line 2601
    (*maxs1) = (char )'\000';
#line 2602
    (*maxs2) = (char )'\000';
#line 2603
    (*rs1) = maxe1;
#line 2604
    (*rs2) = maxe2;
  }
#line 2606
  return (maxchars);
}
}
#line 2609 "message.c"
static int push(LINK1 *top , char const   *string ) 
{ LINK1 element ;
  size_t __len___2 ;
  size_t tmp___16 ;
  char *__retval___2 ;
  char *tmp___17 ;
  int tmp___19 ;

  {
#line 2614
  element = (LINK1 )cli_malloc(sizeof(ELEMENT1 ));
#line 2614
  if ((unsigned int )element == (unsigned int )((void *)0)) {
#line 2615
    return (-2);
  }
#line 2616
  tmp___19 = __builtin_constant_p((int )string);
#line 2616
  if (tmp___19) {
#line 2616
    if ((unsigned int )((void const   *)(string + 1)) - (unsigned int )((void const   *)string) ==
        1U) {
#line 2616
      if ((int const   )(*(string + 0)) == 0) {
#line 2616
        element->d1 = (char *)calloc(1U, 1U);
      } else {
#line 2616
        tmp___16 = strlen(string);
#line 2616
        __len___2 = tmp___16 + 1U;
#line 2616
        tmp___17 = (char *)malloc(__len___2);
#line 2616
        __retval___2 = tmp___17;
#line 2616
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 2616
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )string,
                                        __len___2);
        }
#line 2616
        element->d1 = __retval___2;
      }
    } else {
#line 2616
      element->d1 = __strdup(string);
    }
  } else {
#line 2616
    element->d1 = __strdup(string);
  }
#line 2616
  if ((unsigned int )element->d1 == (unsigned int )((void *)0)) {
#line 2617
    return (-2);
  }
#line 2618
  element->next = (*top);
#line 2619
  (*top) = element;
#line 2621
  return (-4);
}
}
#line 2624 "message.c"
static int pop(LINK1 *top , char *buffer ) 
{ LINK1 t1 ;

  {
#line 2629
  t1 = (*top);
#line 2629
  if ((unsigned int )t1 != (unsigned int )((void *)0)) {
#line 2630
    strcpy((char * __restrict  )buffer, (char const   * __restrict  )t1->d1);
#line 2631
    (*top) = t1->next;
#line 2632
    free((void *)t1->d1);
#line 2633
    free((void *)((char *)t1));
#line 2634
    return (-4);
  }
#line 2636
  return (-3);
}
}
#line 2642 "message.c"
int isuuencodebegin(char const   *line ) 
{ size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
#line 2645
  tmp = strlen(line);
#line 2645
  if (tmp < 10U) {
#line 2646
    return (0);
  }
#line 2648
  tmp___0 = strncasecmp(line, "begin ", 6U);
#line 2648
  if (tmp___0 == 0) {
#line 2648
    tmp___1 = __ctype_b_loc();
#line 2648
    if ((int const   )(*((*tmp___1) + (int )(*(line + 6)))) & 2048) {
#line 2648
      tmp___2 = __ctype_b_loc();
#line 2648
      if ((int const   )(*((*tmp___2) + (int )(*(line + 7)))) & 2048) {
#line 2648
        tmp___3 = __ctype_b_loc();
#line 2648
        if ((int const   )(*((*tmp___3) + (int )(*(line + 8)))) & 2048) {
#line 2648
          if ((int const   )(*(line + 9)) == 32) {
#line 2648
            tmp___4 = 1;
          } else {
#line 2648
            tmp___4 = 0;
          }
        } else {
#line 2648
          tmp___4 = 0;
        }
      } else {
#line 2648
        tmp___4 = 0;
      }
    } else {
#line 2648
      tmp___4 = 0;
    }
  } else {
#line 2648
    tmp___4 = 0;
  }
#line 2648
  return (tmp___4);
}
}
#line 1 "snprintf.lo"
#pragma merger(0,"/tmp/cil-3A0NzwFK.i","-g -O2 -fPIC")
#line 1 "strrcpy.lo"
#pragma merger(0,"/tmp/cil-t2DS1Ab2.i","-g -O2 -fPIC")
#line 37 "strrcpy.c"
char *strrcpy(char *dest , char const   *source ) 
{ char *tmp ;
  char const   *tmp___0 ;

  {
#line 46
  while (1) {
#line 46
    tmp = dest;
#line 46
    dest ++;
#line 46
    tmp___0 = source;
#line 46
    source ++;
#line 46
    (*tmp) = (char )(*tmp___0);
#line 46
    if (! (*tmp)) {
#line 46
      break;
    }
  }
#line 48
  dest --;
#line 48
  return (dest);
}
}
#line 1 "table.lo"
#pragma merger(0,"/tmp/cil-SAOcHnzS.i","-g -O2 -fPIC")
#line 35 "table.c"
struct table *tableCreate(void) 
{ struct table *tmp ;

  {
#line 38
  tmp = (struct table *)cli_calloc(1U, sizeof(struct table ));
#line 38
  return (tmp);
}
}
#line 41 "table.c"
void tableDestroy(table_t *table ) 
{ tableEntry *tableItem ;
  tableEntry *tableNext ;

  {
#line 48
  tableItem = table->tableHead;
#line 50
  while (tableItem) {
#line 51
    tableNext = tableItem->next;
#line 55
    free((void *)tableItem->key);
#line 56
    free((void *)tableItem);
#line 58
    tableItem = tableNext;
  }
#line 61
  free((void *)table);
#line 62
  return;
}
}
#line 67 "table.c"
int tableInsert(table_t *table , char const   *key , int value ) 
{ int v ;
  int tmp ;
  int tmp___0 ;
  size_t __len___2 ;
  size_t tmp___19 ;
  char *__retval___2 ;
  char *tmp___20 ;
  int tmp___22 ;

  {
#line 70
  tmp = tableFind((table_t const   *)table, key);
#line 70
  v = tmp;
#line 72
  if (v > 0) {
#line 73
    if (v == value) {
#line 73
      tmp___0 = value;
    } else {
#line 73
      tmp___0 = -1;
    }
#line 73
    return (tmp___0);
  }
#line 77
  if ((unsigned int )table->tableHead == (unsigned int )((void *)0)) {
#line 78
    table->tableHead = (tableEntry *)cli_malloc(sizeof(tableEntry ));
#line 78
    table->tableLast = table->tableHead;
  } else {
#line 80
    (table->tableLast)->next = (struct tableEntry *)cli_malloc(sizeof(tableEntry ));
#line 80
    table->tableLast = (table->tableLast)->next;
  }
#line 83
  if ((unsigned int )table->tableLast == (unsigned int )((void *)0)) {
#line 84
    return (-1);
  }
#line 86
  (table->tableLast)->next = (struct tableEntry *)((void *)0);
#line 87
  tmp___22 = __builtin_constant_p((int )key);
#line 87
  if (tmp___22) {
#line 87
    if ((unsigned int )((void const   *)(key + 1)) - (unsigned int )((void const   *)key) ==
        1U) {
#line 87
      if ((int const   )(*(key + 0)) == 0) {
#line 87
        (table->tableLast)->key = (char *)calloc(1U, 1U);
      } else {
#line 87
        tmp___19 = strlen(key);
#line 87
        __len___2 = tmp___19 + 1U;
#line 87
        tmp___20 = (char *)malloc(__len___2);
#line 87
        __retval___2 = tmp___20;
#line 87
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 87
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )key,
                                        __len___2);
        }
#line 87
        (table->tableLast)->key = __retval___2;
      }
    } else {
#line 87
      (table->tableLast)->key = __strdup(key);
    }
  } else {
#line 87
    (table->tableLast)->key = __strdup(key);
  }
#line 88
  (table->tableLast)->value = value;
#line 90
  return (value);
}
}
#line 96 "table.c"
int tableFind(table_t const   *table , char const   *key ) 
{ tableEntry const   *tableItem ;
  int tmp ;

  {
#line 106
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 107
    return (-1);
  }
#line 109
  if ((unsigned int )table->tableHead == (unsigned int )((void *)0)) {
#line 110
    return (-1);
  }
#line 116
  tableItem = (tableEntry const   *)table->tableHead;
#line 116
  while (tableItem) {
#line 120
    tmp = strcasecmp((char const   *)tableItem->key, key);
#line 120
    if (tmp == 0) {
#line 124
      return (tableItem->value);
    }
#line 116
    tableItem = (tableEntry const   *)tableItem->next;
  }
#line 128
  return (-1);
}
}
#line 1 "text.lo"
#pragma merger(0,"/tmp/cil-GtvuSWqF.i","-g -O2 -fPIC")
#line 89 "text.c"
static text *textCopy(text const   *t_head ) ;
#line 90
static void addToFileblob(line_t const   *line , void *arg ) ;
#line 91
static void getLength(line_t const   *line , void *arg ) ;
#line 92
static void addToBlob(line_t const   *line , void *arg ) ;
#line 93
static void *textIterate(text const   *t_text , void (*cb)(line_t const   *item ,
                                                           void *arg ) , void *arg ) ;
#line 95 "text.c"
void textDestroy(text *t_head ) 
{ text *t_next ;

  {
#line 98
  while (t_head) {
#line 99
    t_next = t_head->t_next;
#line 100
    if (t_head->t_line) {
#line 101
      lineUnlink(t_head->t_line);
    }
#line 102
    free((void *)t_head);
#line 103
    t_head = t_next;
  }
#line 105
  return;
}
}
#line 113 "text.c"
text *textClean(text *t_head ) 
{ 

  {
#line 116
  return (t_head);
}
}
#line 120 "text.c"
static text *textCopy(text const   *t_head ) 
{ text *first ;
  text *last ;

  {
#line 123
  first = (text *)((void *)0);
#line 123
  last = (text *)((void *)0);
#line 125
  while (t_head) {
#line 126
    if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 127
      first = (text *)cli_malloc(sizeof(text ));
#line 127
      last = first;
    } else {
#line 129
      last->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 130
      last = last->t_next;
    }
#line 133
    if ((unsigned int )last == (unsigned int )((void *)0)) {
#line 134
      if (first) {
#line 135
        textDestroy(first);
      }
#line 136
      return ((text *)((void *)0));
    }
#line 139
    if (t_head->t_line) {
#line 140
      last->t_line = lineLink(t_head->t_line);
    } else {
#line 142
      last->t_line = (line_t *)((void *)0);
    }
#line 144
    t_head = (text const   *)t_head->t_next;
  }
#line 147
  if (first) {
#line 148
    last->t_next = (struct text *)((void *)0);
  }
#line 150
  return (first);
}
}
#line 154 "text.c"
text *textAdd(text *t_head , text const   *t ) 
{ text *ret ;
  int count ;
  text *tmp ;

  {
#line 160
  if ((unsigned int )t_head == (unsigned int )((void *)0)) {
#line 161
    tmp = textCopy(t);
#line 161
    return (tmp);
  }
#line 163
  if ((unsigned int )t == (unsigned int )((void *)0)) {
#line 164
    return (t_head);
  }
#line 166
  ret = t_head;
#line 168
  count = 0;
#line 169
  while (t_head->t_next) {
#line 170
    count ++;
#line 171
    t_head = t_head->t_next;
  }
#line 174
  cli_dbgmsg("textAdd: count = %d\n", count);
#line 176
  while (t) {
#line 177
    t_head->t_next = (struct text *)cli_malloc(sizeof(text ));
#line 178
    t_head = t_head->t_next;
#line 182
    if (t->t_line) {
#line 183
      t_head->t_line = lineLink(t->t_line);
    } else {
#line 185
      t_head->t_line = (line_t *)((void *)0);
    }
#line 187
    t = (text const   *)t->t_next;
  }
#line 190
  t_head->t_next = (struct text *)((void *)0);
#line 192
  return (ret);
}
}
#line 198 "text.c"
text *textAddMessage(text *aText , message *aMessage ) 
{ text const   *tmp ;
  text *tmp___0 ;
  text *anotherText ;
  text *tmp___1 ;
  encoding_type tmp___2 ;

  {
#line 203
  tmp___2 = messageGetEncoding((message const   *)aMessage);
#line 203
  if ((int )tmp___2 == 0) {
#line 204
    tmp = messageGetBody((message const   *)aMessage);
#line 204
    tmp___0 = textAdd(aText, tmp);
#line 204
    return (tmp___0);
  } else {
#line 206
    tmp___1 = messageToText(aMessage);
#line 206
    anotherText = tmp___1;
#line 208
    if (aText) {
#line 209
      aText = textAdd(aText, (text const   *)anotherText);
#line 210
      textDestroy(anotherText);
#line 211
      return (aText);
    }
#line 213
    return (anotherText);
  }
}
}
#line 221 "text.c"
blob *textToBlob(text const   *t , blob *b ) 
{ size_t s ;

  {
#line 226
  if ((unsigned int )t == (unsigned int )((void *)0)) {
#line 227
    return ((blob *)((void *)0));
  }
#line 229
  s = 0U;
#line 231
  textIterate(t, & getLength, (void *)(& s));
#line 233
  if (s == 0U) {
#line 234
    return (b);
  }
#line 236
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 237
    b = blobCreate();
#line 239
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 240
      return ((blob *)((void *)0));
    }
  }
#line 243
  blobGrow(b, s);
#line 245
  textIterate(t, & addToBlob, (void *)b);
#line 247
  blobClose(b);
#line 249
  return (b);
}
}
#line 252 "text.c"
fileblob *textToFileblob(text const   *t , fileblob *fb ) 
{ fileblob *tmp ;

  {
#line 258
  if ((unsigned int )fb == (unsigned int )((void *)0)) {
#line 259
    fb = fileblobCreate();
#line 261
    if ((unsigned int )fb == (unsigned int )((void *)0)) {
#line 262
      return ((fileblob *)((void *)0));
    }
  }
#line 265
  tmp = (fileblob *)textIterate(t, & addToFileblob, (void *)fb);
#line 265
  return (tmp);
}
}
#line 268 "text.c"
static void getLength(line_t const   *line , void *arg ) 
{ size_t *length ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
#line 271
  length = (size_t *)arg;
#line 273
  if (line) {
#line 274
    tmp = lineGetData(line);
#line 274
    tmp___0 = strlen(tmp);
#line 274
    (*length) += tmp___0 + 1U;
  } else {
#line 276
    (*length) ++;
  }
#line 277
  return;
}
}
#line 279 "text.c"
static void addToBlob(line_t const   *line , void *arg ) 
{ blob *b ;
  char const   *l ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
#line 282
  b = (blob *)arg;
#line 284
  if (line) {
#line 285
    tmp = lineGetData(line);
#line 285
    l = tmp;
#line 287
    tmp___0 = strlen(l);
#line 287
    blobAddData(b, (unsigned char const   *)((unsigned char *)l), tmp___0);
  }
#line 289
  blobAddData(b, (unsigned char const   *)((unsigned char *)"\n"), 1U);
#line 290
  return;
}
}
#line 292 "text.c"
static void addToFileblob(line_t const   *line , void *arg ) 
{ fileblob *fb ;
  char const   *l ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
#line 295
  fb = (fileblob *)arg;
#line 297
  if (line) {
#line 298
    tmp = lineGetData(line);
#line 298
    l = tmp;
#line 300
    tmp___0 = strlen(l);
#line 300
    fileblobAddData(fb, (unsigned char const   *)((unsigned char *)l), tmp___0);
  }
#line 302
  fileblobAddData(fb, (unsigned char const   *)((unsigned char *)"\n"), 1U);
#line 303
  return;
}
}
#line 305 "text.c"
static void *textIterate(text const   *t_text , void (*cb)(line_t const   *item ,
                                                           void *arg ) , void *arg ) 
{ 

  {
#line 308
  while (t_text) {
#line 309
    ((*cb))((line_t const   *)t_text->t_line, arg);
#line 310
    t_text = (text const   *)t_text->t_next;
  }
#line 312
  return (arg);
}
}
#line 1 "ole2_extract.lo"
#pragma merger(0,"/tmp/cil-YmWUK6xn.i","-g -O2 -fPIC")
#line 58 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 60 "ole2_extract.c"
static uint16_t ole2_endian_convert_16(uint16_t v ) 
{ 

  {
#line 62
  return ((unsigned short )(((int )v >> 8) + ((int )v << 8)));
}
}
#line 69 "ole2_extract.c"
static uint32_t ole2_endian_convert_32(uint32_t v ) 
{ 

  {
#line 71
  return ((((v >> 24) | ((v & 16711680U) >> 8)) | ((v & 65280U) << 8)) | (v << 24));
}
}
#line 142 "ole2_extract.c"
unsigned char magic_id[8]  = 
#line 142
  {      (unsigned char)208,      (unsigned char)207,      (unsigned char)17,      (unsigned char)224, 
        (unsigned char)161,      (unsigned char)177,      (unsigned char)26,      (unsigned char)225};
#line 144 "ole2_extract.c"
static char *get_property_name(char *name , int size ) 
{ int i ;
  int j ;
  char *newname ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;

  {
#line 149
  if ((int )(*name) == 0) {
#line 150
    return ((char *)((void *)0));
  } else {
#line 149
    if (size <= 0) {
#line 150
      return ((char *)((void *)0));
    } else {
#line 149
      if (size > 64) {
#line 150
        return ((char *)((void *)0));
      }
    }
  }
#line 153
  newname = (char *)cli_malloc((unsigned int )(size * 2));
#line 154
  if (! newname) {
#line 155
    return ((char *)((void *)0));
  }
#line 157
  j = 0;
#line 159
  i = 0;
#line 159
  while (i < size - 2) {
#line 160
    tmp___4 = __ctype_b_loc();
#line 160
    if ((int const   )(*((*tmp___4) + (int )(*(name + i)))) & 16384) {
#line 161
      tmp___0 = j;
#line 161
      j ++;
#line 161
      (*(newname + tmp___0)) = (*(name + i));
    } else {
#line 163
      if ((int )(*(name + i)) < 10) {
#line 163
        if ((int )(*(name + i)) >= 0) {
#line 164
          tmp___1 = j;
#line 164
          j ++;
#line 164
          (*(newname + tmp___1)) = (char )'_';
#line 165
          tmp___2 = j;
#line 165
          j ++;
#line 165
          (*(newname + tmp___2)) = (char )((int )(*(name + i)) + 48);
        }
      }
#line 167
      tmp___3 = j;
#line 167
      j ++;
#line 167
      (*(newname + tmp___3)) = (char )'_';
    }
#line 159
    i += 2;
  }
#line 170
  (*(newname + j)) = (char )'\000';
#line 171
  tmp___5 = strlen((char const   *)newname);
#line 171
  if (tmp___5 == 0U) {
#line 172
    free((void *)newname);
#line 173
    return ((char *)((void *)0));
  }
#line 175
  return (newname);
}
}
#line 178 "ole2_extract.c"
static void print_property_name(char *pname , int size ) 
{ char *name ;

  {
#line 182
  name = get_property_name(pname, size);
#line 183
  if (! name) {
#line 184
    return;
  }
#line 186
  cli_dbgmsg("%34s ", name);
#line 187
  free((void *)name);
#line 188
  return;
}
}
#line 191 "ole2_extract.c"
static void print_ole2_property(property_t *property ) 
{ 

  {
#line 193
  if ((int )property->name_size > 64) {
#line 194
    cli_dbgmsg("[err name len: %d]\n", property->name_size);
#line 195
    return;
  }
#line 197
  print_property_name((char *)(property->name), (int )property->name_size);
#line 198
  switch ((int )property->type) {
  case 2: 
#line 200
  cli_dbgmsg(" [file] ");
#line 201
  break;
  case 1: 
#line 203
  cli_dbgmsg(" [dir ] ");
#line 204
  break;
  case 5: 
#line 206
  cli_dbgmsg(" [root] ");
#line 207
  break;
  default: 
#line 209
  cli_dbgmsg(" [%d]", property->type);
  }
#line 211
  switch ((int )property->color) {
  case 0: 
#line 213
  cli_dbgmsg(" r ");
#line 214
  break;
  case 1: 
#line 216
  cli_dbgmsg(" b ");
#line 217
  break;
  default: 
#line 219
  cli_dbgmsg(" u ");
  }
#line 221
  cli_dbgmsg(" %d %x\n", property->size, property->user_flags);
#line 222
  return;
}
}
#line 224 "ole2_extract.c"
static void print_ole2_header(ole2_header_t *hdr ) 
{ int i ;

  {
#line 228
  if (! hdr) {
#line 229
    return;
  }
#line 232
  cli_dbgmsg("\nMagic:\t\t\t0x");
#line 233
  i = 0;
#line 233
  while (i < 8) {
#line 234
    cli_dbgmsg("%x", hdr->magic[i]);
#line 233
    i ++;
  }
#line 236
  cli_dbgmsg("\n");
#line 238
  cli_dbgmsg("CLSID:\t\t\t{");
#line 239
  i = 0;
#line 239
  while (i < 16) {
#line 240
    cli_dbgmsg("%x ", hdr->clsid[i]);
#line 239
    i ++;
  }
#line 242
  cli_dbgmsg("}\n");
#line 244
  cli_dbgmsg("Minor version:\t\t0x%x\n", hdr->minor_version);
#line 245
  cli_dbgmsg("DLL version:\t\t0x%x\n", hdr->dll_version);
#line 246
  cli_dbgmsg("Byte Order:\t\t%d\n", hdr->byte_order);
#line 247
  cli_dbgmsg("Big Block Size:\t\t%i\n", hdr->log2_big_block_size);
#line 248
  cli_dbgmsg("Small Block Size:\t%i\n", hdr->log2_small_block_size);
#line 249
  cli_dbgmsg("BAT count:\t\t%d\n", hdr->bat_count);
#line 250
  cli_dbgmsg("Prop start:\t\t%d\n", hdr->prop_start);
#line 251
  cli_dbgmsg("SBAT cutoff:\t\t%d\n", hdr->sbat_cutoff);
#line 252
  cli_dbgmsg("SBat start:\t\t%d\n", hdr->sbat_start);
#line 253
  cli_dbgmsg("SBat block count:\t%d\n", hdr->sbat_block_count);
#line 254
  cli_dbgmsg("XBat start:\t\t%d\n", hdr->xbat_start);
#line 255
  cli_dbgmsg("XBat block count:\t%d\n\n", hdr->xbat_count);
#line 256
  return;
}
}
#line 259 "ole2_extract.c"
static int ole2_read_block(int fd , ole2_header_t *hdr , void *buff , int32_t blockno ) 
{ off_t offset ;
  off_t offend ;
  __off_t tmp ;
  int tmp___0 ;

  {
#line 263
  if (blockno < 0) {
#line 264
    return (0);
  }
#line 268
  offset = (long )((blockno << (int )hdr->log2_big_block_size) + 512);
#line 270
  if ((unsigned int )hdr->m_area == (unsigned int )((void *)0)) {
#line 271
    tmp = lseek(fd, offset, 0);
#line 271
    if (tmp != offset) {
#line 272
      return (0);
    }
#line 274
    tmp___0 = cli_readn(fd, buff, (unsigned int )(1 << (int )hdr->log2_big_block_size));
#line 274
    if (tmp___0 != 1 << (int )hdr->log2_big_block_size) {
#line 275
      return (0);
    }
  } else {
#line 278
    offend = offset + (long )(1 << (int )hdr->log2_big_block_size);
#line 279
    if (offend <= 0L) {
#line 280
      return (0);
    } else {
#line 279
      if (offend > hdr->m_length) {
#line 280
        return (0);
      }
    }
#line 282
    memcpy((void * __restrict  )buff, (void const   * __restrict  )(hdr->m_area +
                                                                    offset), (unsigned int )(1 <<
                                                                                             (int )hdr->log2_big_block_size));
  }
#line 284
  return (1);
}
}
#line 287 "ole2_extract.c"
static int32_t ole2_get_next_bat_block(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t bat_array_index ;
  uint32_t bat[128] ;
  int32_t tmp ;
  int tmp___0 ;
  int32_t tmp___1 ;

  {
#line 292
  if (current_block < 0) {
#line 293
    return (-1);
  }
#line 296
  bat_array_index = current_block / 128;
#line 297
  if (bat_array_index > hdr->bat_count) {
#line 298
    cli_dbgmsg("bat_array index error\n");
#line 299
    return (-10);
  }
#line 301
  tmp = (int32_t )ole2_endian_convert_32((unsigned int )hdr->bat_array[bat_array_index]);
#line 301
  tmp___0 = ole2_read_block(fd, hdr, (void *)(& bat), tmp);
#line 301
  if (! tmp___0) {
#line 303
    return (-1);
  }
#line 305
  tmp___1 = (int32_t )ole2_endian_convert_32(bat[current_block - bat_array_index *
                                                                 128]);
#line 305
  return (tmp___1);
}
}
#line 308 "ole2_extract.c"
static int32_t ole2_get_next_xbat_block(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t xbat_index ;
  int32_t xbat_block_index ;
  int32_t bat_index ;
  int32_t bat_blockno ;
  uint32_t xbat[128] ;
  uint32_t bat[128] ;
  int tmp ;
  int32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int32_t tmp___3 ;

  {
#line 313
  if (current_block < 0) {
#line 314
    return (-1);
  }
#line 317
  xbat_index = current_block / 128;
#line 322
  xbat_block_index = (xbat_index - 109) / 127;
#line 323
  bat_blockno = (xbat_index - 109) % 127;
#line 325
  bat_index = current_block % 128;
#line 327
  tmp = ole2_read_block(fd, hdr, (void *)(& xbat), hdr->xbat_start);
#line 327
  if (! tmp) {
#line 328
    return (-1);
  }
#line 332
  while (xbat_block_index > 0) {
#line 333
    tmp___0 = (int32_t )ole2_endian_convert_32(xbat[127]);
#line 333
    tmp___1 = ole2_read_block(fd, hdr, (void *)(& xbat), tmp___0);
#line 333
    if (! tmp___1) {
#line 335
      return (-1);
    }
#line 337
    xbat_block_index --;
  }
#line 340
  tmp___2 = ole2_read_block(fd, hdr, (void *)(& bat), (int )xbat[bat_blockno]);
#line 340
  if (! tmp___2) {
#line 341
    return (-1);
  }
#line 344
  tmp___3 = (int32_t )ole2_endian_convert_32(bat[bat_index]);
#line 344
  return (tmp___3);
}
}
#line 347 "ole2_extract.c"
static int32_t ole2_get_next_block_number(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t tmp ;
  int32_t tmp___0 ;

  {
#line 349
  if (current_block < 0) {
#line 350
    return (-1);
  }
#line 353
  if (current_block / 128 > 108) {
#line 354
    tmp = ole2_get_next_xbat_block(fd, hdr, current_block);
#line 354
    return (tmp);
  } else {
#line 356
    tmp___0 = ole2_get_next_bat_block(fd, hdr, current_block);
#line 356
    return (tmp___0);
  }
}
}
#line 360 "ole2_extract.c"
static int32_t ole2_get_next_sbat_block(int fd , ole2_header_t *hdr , int32_t current_block ) 
{ int32_t iter ;
  int32_t current_bat_block ;
  uint32_t sbat[128] ;
  int tmp ;
  int32_t tmp___0 ;

  {
#line 365
  if (current_block < 0) {
#line 366
    return (-1);
  }
#line 369
  current_bat_block = hdr->sbat_start;
#line 370
  iter = current_block / 128;
#line 371
  while (iter > 0) {
#line 372
    current_bat_block = ole2_get_next_block_number(fd, hdr, current_bat_block);
#line 373
    iter --;
  }
#line 375
  tmp = ole2_read_block(fd, hdr, (void *)(& sbat), current_bat_block);
#line 375
  if (! tmp) {
#line 376
    return (-1);
  }
#line 378
  tmp___0 = (int32_t )ole2_endian_convert_32(sbat[current_block % 128]);
#line 378
  return (tmp___0);
}
}
#line 382 "ole2_extract.c"
static int32_t ole2_get_sbat_data_block(int fd , ole2_header_t *hdr , void *buff ,
                                        int32_t sbat_index ) 
{ int32_t block_count ;
  int32_t current_block ;
  int32_t tmp ;

  {
#line 386
  if (sbat_index < 0) {
#line 387
    return (0);
  }
#line 390
  if (hdr->sbat_root_start < 0) {
#line 391
    cli_errmsg("No root start block\n");
#line 392
    return (0);
  }
#line 395
  block_count = sbat_index / 8;
#line 396
  current_block = hdr->sbat_root_start;
#line 397
  while (block_count > 0) {
#line 398
    current_block = ole2_get_next_block_number(fd, hdr, current_block);
#line 399
    block_count --;
  }
#line 404
  tmp = ole2_read_block(fd, hdr, buff, current_block);
#line 404
  return (tmp);
}
}
#line 459 "ole2_extract.c"
static void ole2_walk_property_tree(int fd , ole2_header_t *hdr , char const   *dir ,
                                    int32_t prop_index , int (*handler)(int fd , ole2_header_t *hdr ,
                                                                        property_t *prop ,
                                                                        char const   *dir ) ,
                                    int rec_level , int *file_count , struct cl_limits  const  *limits ) 
{ property_t prop_block[4] ;
  int32_t index___0 ;
  int32_t current_block ;
  int32_t i ;
  unsigned char *dirname ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 466
  current_block = hdr->prop_start;
#line 468
  if (prop_index < 0) {
#line 469
    return;
  } else {
#line 468
    if (rec_level > 100) {
#line 469
      return;
    } else {
#line 468
      if ((*file_count) > 100000) {
#line 469
        return;
      }
    }
  }
#line 472
  if (limits) {
#line 472
    if (limits->maxfiles) {
#line 472
      if ((unsigned int )(*file_count) > limits->maxfiles) {
#line 473
        cli_dbgmsg("OLE2: File limit reached (max: %d)\n", limits->maxfiles);
#line 474
        return;
      }
    }
  }
#line 477
  if (limits) {
#line 477
    if (limits->maxreclevel) {
#line 477
      if ((unsigned int )rec_level > limits->maxreclevel) {
#line 478
        cli_dbgmsg("OLE2: Recursion limit reached (max: %d)\n", limits->maxreclevel);
#line 479
        return;
      }
    }
  }
#line 482
  index___0 = prop_index / 4;
#line 483
  i = 0;
#line 483
  while (i < index___0) {
#line 484
    current_block = ole2_get_next_block_number(fd, hdr, current_block);
#line 485
    if (current_block < 0) {
#line 486
      return;
    }
#line 483
    i ++;
  }
#line 489
  index___0 = prop_index % 4;
#line 490
  tmp = ole2_read_block(fd, hdr, (void *)(prop_block), current_block);
#line 490
  if (! tmp) {
#line 492
    return;
  }
#line 494
  if ((int )prop_block[index___0].type <= 0) {
#line 495
    return;
  }
#line 497
  prop_block[index___0].name_size = (int16_t )ole2_endian_convert_16((unsigned short )prop_block[index___0].name_size);
#line 498
  prop_block[index___0].prev = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].prev);
#line 499
  prop_block[index___0].next = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].next);
#line 500
  prop_block[index___0].child = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].child);
#line 501
  prop_block[index___0].user_flags = ole2_endian_convert_32(prop_block[index___0].user_flags);
#line 502
  prop_block[index___0].create_lowdate = ole2_endian_convert_32(prop_block[index___0].create_lowdate);
#line 503
  prop_block[index___0].create_highdate = ole2_endian_convert_32(prop_block[index___0].create_highdate);
#line 504
  prop_block[index___0].mod_lowdate = ole2_endian_convert_32(prop_block[index___0].mod_lowdate);
#line 505
  prop_block[index___0].mod_highdate = ole2_endian_convert_32(prop_block[index___0].mod_highdate);
#line 506
  prop_block[index___0].start_block = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].start_block);
#line 507
  prop_block[index___0].size = (int32_t )ole2_endian_convert_32((unsigned int )prop_block[index___0].size);
#line 509
  print_ole2_property(& prop_block[index___0]);
#line 510
  switch ((int )prop_block[index___0].type) {
  case 5: ;
#line 512
  if (prop_index != 0) {
#line 515
    cli_dbgmsg("ERROR: illegal Root Entry\n");
#line 516
    return;
  } else {
#line 512
    if (rec_level != 0) {
#line 515
      cli_dbgmsg("ERROR: illegal Root Entry\n");
#line 516
      return;
    } else {
#line 512
      if ((*file_count) != 0) {
#line 515
        cli_dbgmsg("ERROR: illegal Root Entry\n");
#line 516
        return;
      }
    }
  }
#line 518
  hdr->sbat_root_start = prop_block[index___0].start_block;
#line 519
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].prev, handler, rec_level +
                                                                             1, file_count,
                          limits);
#line 521
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].next, handler, rec_level +
                                                                             1, file_count,
                          limits);
#line 523
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].child, handler, rec_level +
                                                                              1, file_count,
                          limits);
#line 525
  break;
  case 2: 
#line 527
  (*file_count) ++;
#line 528
  tmp___0 = ((*handler))(fd, hdr, & prop_block[index___0], dir);
#line 528
  if (! tmp___0) {
#line 529
    cli_dbgmsg("ERROR: handler failed\n");
  }
#line 536
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].prev, handler, rec_level,
                          file_count, limits);
#line 538
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].next, handler, rec_level,
                          file_count, limits);
#line 540
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].child, handler, rec_level,
                          file_count, limits);
#line 542
  break;
  case 1: 
#line 544
  tmp___1 = strlen(dir);
#line 544
  tmp___2 = cli_malloc(tmp___1 + 8U);
#line 544
  dirname = (unsigned char *)((char *)tmp___2);
#line 545
  if (! dirname) {
#line 546
    return;
  }
#line 548
  tmp___3 = strlen(dir);
#line 548
  snprintf((char * __restrict  )dirname, tmp___3 + 8U, (char const   * __restrict  )"%s/%.6d",
           dir, prop_index);
#line 549
  tmp___4 = mkdir((char const   *)dirname, 448U);
#line 549
  if (tmp___4 != 0) {
#line 550
    free((void *)dirname);
#line 551
    return;
  }
#line 553
  cli_dbgmsg("OLE2 dir entry: %s\n", dirname);
#line 554
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].prev, handler, rec_level +
                                                                             1, file_count,
                          limits);
#line 556
  ole2_walk_property_tree(fd, hdr, dir, prop_block[index___0].next, handler, rec_level +
                                                                             1, file_count,
                          limits);
#line 558
  ole2_walk_property_tree(fd, hdr, (char const   *)dirname, prop_block[index___0].child,
                          handler, rec_level + 1, file_count, limits);
#line 560
  free((void *)dirname);
#line 561
  break;
  default: 
#line 563
  cli_dbgmsg("ERROR: unknown OLE2 entry type: %d\n", prop_block[index___0].type);
#line 564
  break;
  }
#line 566
  return;
}
}
#line 569 "ole2_extract.c"
static int handler_writefile(int fd , ole2_header_t *hdr , property_t *prop , char const   *dir ) 
{ unsigned char *buff ;
  int32_t current_block ;
  int32_t ofd ;
  int32_t len ;
  int32_t offset ;
  char *name ;
  char *newname ;
  off_t i ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int tmp___6 ;
  int32_t tmp___7 ;
  int32_t tmp___8 ;
  int tmp___9 ;
  int32_t tmp___10 ;
  int tmp___11 ;
  int32_t tmp___12 ;
  int32_t tmp___13 ;

  {
#line 575
  if ((int )prop->type != 2) {
#line 577
    return (1);
  }
#line 580
  if ((int )prop->name_size > 64) {
#line 581
    cli_dbgmsg("\nERROR: property name too long: %d\n", prop->name_size);
#line 582
    return (0);
  }
#line 585
  name = get_property_name((char *)(prop->name), (int )prop->name_size);
#line 585
  if (name) {
#line 597
    newname = name;
#line 597
    while ((*newname)) {
#line 604
      if ((int )(*newname) == 47) {
#line 606
        (*newname) = (char )'_';
      }
#line 597
      newname ++;
    }
  } else {
#line 589
    i = lseek(fd, 0L, 1);
#line 590
    name = (char *)cli_malloc(11U);
#line 591
    if (! name) {
#line 592
      return (0);
    }
#line 594
    snprintf((char * __restrict  )name, 11U, (char const   * __restrict  )"%.10ld",
             i + (long )prop);
  }
#line 611
  tmp___0 = strlen((char const   *)name);
#line 611
  tmp___1 = strlen(dir);
#line 611
  newname = (char *)cli_malloc((tmp___0 + tmp___1) + 2U);
#line 612
  if (! newname) {
#line 613
    free((void *)name);
#line 614
    return (0);
  }
#line 616
  sprintf((char * __restrict  )newname, (char const   * __restrict  )"%s/%s", dir,
          name);
#line 617
  free((void *)name);
#line 619
  ofd = open((char const   *)newname, 577, 448);
#line 620
  if (ofd < 0) {
#line 621
    cli_errmsg("ERROR: failed to create file: %s\n", newname);
#line 622
    free((void *)newname);
#line 623
    return (0);
  }
#line 625
  free((void *)newname);
#line 626
  current_block = prop->start_block;
#line 627
  len = prop->size;
#line 629
  buff = (unsigned char *)cli_malloc((unsigned int )(1 << (int )hdr->log2_big_block_size));
#line 630
  if (! buff) {
#line 631
    close(ofd);
#line 632
    return (0);
  }
#line 635
  while (1) {
#line 635
    if (current_block >= 0) {
#line 635
      if (! (len > 0)) {
#line 635
        break;
      }
    } else {
#line 635
      break;
    }
#line 636
    if ((long long )prop->size < (long long )hdr->sbat_cutoff) {
#line 638
      tmp___4 = ole2_get_sbat_data_block(fd, hdr, (void *)buff, current_block);
#line 638
      if (! tmp___4) {
#line 639
        cli_dbgmsg("ole2_get_sbat_data_block failed\n");
#line 640
        close(ofd);
#line 641
        free((void *)buff);
#line 642
        return (0);
      }
#line 645
      offset = 64 * (current_block % 8);
#line 646
      if (len < 64) {
#line 646
        tmp___5 = len;
      } else {
#line 646
        tmp___5 = 64;
      }
#line 646
      tmp___6 = cli_writen(ofd, (void *)(buff + offset), (unsigned int )tmp___5);
#line 646
      if (len < 64) {
#line 646
        tmp___7 = len;
      } else {
#line 646
        tmp___7 = 64;
      }
#line 646
      if (tmp___6 != tmp___7) {
#line 647
        close(ofd);
#line 648
        free((void *)buff);
#line 649
        return (0);
      }
#line 652
      if (len < 64) {
#line 652
        tmp___8 = len;
      } else {
#line 652
        tmp___8 = 64;
      }
#line 652
      len -= tmp___8;
#line 653
      current_block = ole2_get_next_sbat_block(fd, hdr, current_block);
    } else {
#line 656
      tmp___9 = ole2_read_block(fd, hdr, (void *)buff, current_block);
#line 656
      if (! tmp___9) {
#line 657
        close(ofd);
#line 658
        free((void *)buff);
#line 659
        return (0);
      }
#line 661
      if (len < 1 << (int )hdr->log2_big_block_size) {
#line 661
        tmp___10 = len;
      } else {
#line 661
        tmp___10 = 1 << (int )hdr->log2_big_block_size;
      }
#line 661
      tmp___11 = cli_writen(ofd, (void *)buff, (unsigned int )tmp___10);
#line 661
      if (len < 1 << (int )hdr->log2_big_block_size) {
#line 661
        tmp___12 = len;
      } else {
#line 661
        tmp___12 = 1 << (int )hdr->log2_big_block_size;
      }
#line 661
      if (tmp___11 != tmp___12) {
#line 663
        close(ofd);
#line 664
        free((void *)buff);
#line 665
        return (0);
      }
#line 668
      current_block = ole2_get_next_block_number(fd, hdr, current_block);
#line 669
      if (len < 1 << (int )hdr->log2_big_block_size) {
#line 669
        tmp___13 = len;
      } else {
#line 669
        tmp___13 = 1 << (int )hdr->log2_big_block_size;
      }
#line 669
      len -= tmp___13;
    }
  }
#line 672
  close(ofd);
#line 673
  free((void *)buff);
#line 674
  return (1);
}
}
#line 737 "ole2_extract.c"
int cli_ole2_extract(int fd , char const   *dirname , struct cl_limits  const  *limits ) 
{ ole2_header_t hdr ;
  int hdr_size ;
  struct stat statbuf ;
  int file_count ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___76 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___112 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___131 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;

  {
#line 742
  file_count = 0;
#line 744
  cli_dbgmsg("in cli_ole2_extract()\n");
#line 747
  hdr_size = (int )(((sizeof(struct ole2_header_tag ) - sizeof(int32_t )) - sizeof(unsigned char *)) -
                    sizeof(off_t ));
#line 750
  hdr.m_area = (unsigned char *)((void *)0);
#line 753
  tmp___0 = fstat__extinline(fd, & statbuf);
#line 753
  if (tmp___0 == 0) {
#line 754
    if (statbuf.st_size < (long )hdr_size) {
#line 755
      return (0);
    }
#line 757
    hdr.m_length = statbuf.st_size;
#line 758
    hdr.m_area = (unsigned char *)mmap((void *)0, (unsigned int )hdr.m_length, 1,
                                       2, fd, 0L);
#line 759
    if ((unsigned int )hdr.m_area == (unsigned int )((void *)-1)) {
#line 760
      hdr.m_area = (unsigned char *)((void *)0);
    } else {
#line 762
      cli_dbgmsg("mmap\'ed file\n");
#line 763
      memcpy((void * __restrict  )(& hdr), (void const   * __restrict  )hdr.m_area,
             (unsigned int )hdr_size);
    }
  }
#line 768
  if ((unsigned int )hdr.m_area == (unsigned int )((void *)0)) {
#line 770
    tmp___1 = cli_readn(fd, (void *)(& hdr), (unsigned int )hdr_size);
#line 770
    if (tmp___1 != hdr_size) {
#line 771
      return (0);
    }
  }
#line 780
  hdr.minor_version = ole2_endian_convert_16(hdr.minor_version);
#line 781
  hdr.dll_version = ole2_endian_convert_16(hdr.dll_version);
#line 782
  hdr.byte_order = (int16_t )ole2_endian_convert_16((unsigned short )hdr.byte_order);
#line 783
  hdr.log2_big_block_size = ole2_endian_convert_16(hdr.log2_big_block_size);
#line 784
  hdr.log2_small_block_size = ole2_endian_convert_32(hdr.log2_small_block_size);
#line 785
  hdr.bat_count = (int32_t )ole2_endian_convert_32((unsigned int )hdr.bat_count);
#line 786
  hdr.prop_start = (int32_t )ole2_endian_convert_32((unsigned int )hdr.prop_start);
#line 787
  hdr.sbat_cutoff = ole2_endian_convert_32(hdr.sbat_cutoff);
#line 788
  hdr.sbat_start = (int32_t )ole2_endian_convert_32((unsigned int )hdr.sbat_start);
#line 789
  hdr.sbat_block_count = (int32_t )ole2_endian_convert_32((unsigned int )hdr.sbat_block_count);
#line 790
  hdr.xbat_start = (int32_t )ole2_endian_convert_32((unsigned int )hdr.xbat_start);
#line 791
  hdr.xbat_count = (int32_t )ole2_endian_convert_32((unsigned int )hdr.xbat_count);
#line 793
  hdr.sbat_root_start = -1;
#line 795
  tmp___146 = __builtin_constant_p((int )(hdr.magic));
#line 795
  if (tmp___146) {
#line 795
    tmp___147 = strlen((char const   *)(hdr.magic));
#line 795
    if (tmp___147 < 8U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
#line 795
    tmp___148 = __builtin_constant_p((int )(magic_id));
#line 795
    if (tmp___148) {
#line 795
      tmp___149 = strlen((char const   *)(magic_id));
#line 795
      if (tmp___149 < 8U) {
        _L___39: 
#line 795
        tmp___143 = __builtin_constant_p((int )(hdr.magic));
#line 795
        if (tmp___143) {
#line 795
          tmp___144 = __builtin_constant_p((int )(magic_id));
#line 795
          if (tmp___144) {
#line 795
            __s1_len___0 = strlen((char const   *)(hdr.magic));
#line 795
            __s2_len___0 = strlen((char const   *)(magic_id));
#line 795
            if (! ((unsigned int )((void const   *)(hdr.magic + 1)) - (unsigned int )((void const   *)(hdr.magic)) ==
                   1U)) {
              goto _L___36;
            } else {
#line 795
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 795
                if (! ((unsigned int )((void const   *)(magic_id + 1)) - (unsigned int )((void const   *)(magic_id)) ==
                       1U)) {
#line 795
                  tmp___145 = 1;
                } else {
#line 795
                  if (__s2_len___0 >= 4U) {
#line 795
                    tmp___145 = 1;
                  } else {
#line 795
                    tmp___145 = 0;
                  }
                }
              } else {
#line 795
                tmp___145 = 0;
              }
            }
#line 795
            if (tmp___145) {
#line 795
              tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 795
          tmp___142 = __builtin_constant_p((int )(hdr.magic));
#line 795
          if (tmp___142) {
#line 795
            if ((unsigned int )((void const   *)(hdr.magic + 1)) - (unsigned int )((void const   *)(hdr.magic)) ==
                1U) {
#line 795
              __s1_len___0 = strlen((char const   *)(hdr.magic));
#line 795
              if (__s1_len___0 < 4U) {
#line 795
                tmp___131 = __builtin_constant_p((int )(magic_id));
#line 795
                if (tmp___131) {
#line 795
                  if ((unsigned int )((void const   *)(magic_id + 1)) - (unsigned int )((void const   *)(magic_id)) ==
                      1U) {
#line 795
                    tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 795
                  __s2___14 = (unsigned char const   *)((char const   *)(magic_id));
#line 795
                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 795
                  if (__s1_len___0 > 0U) {
#line 795
                    if (__result___42 == 0) {
#line 795
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 795
                      if (__s1_len___0 > 1U) {
#line 795
                        if (__result___42 == 0) {
#line 795
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 795
                          if (__s1_len___0 > 2U) {
#line 795
                            if (__result___42 == 0) {
#line 795
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(hdr.magic)) +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 795
                  tmp___112 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 795
            tmp___141 = __builtin_constant_p((int )(magic_id));
#line 795
            if (tmp___141) {
#line 795
              if ((unsigned int )((void const   *)(magic_id + 1)) - (unsigned int )((void const   *)(magic_id)) ==
                  1U) {
#line 795
                __s2_len___0 = strlen((char const   *)(magic_id));
#line 795
                if (__s2_len___0 < 4U) {
#line 795
                  tmp___140 = __builtin_constant_p((int )(hdr.magic));
#line 795
                  if (tmp___140) {
#line 795
                    if ((unsigned int )((void const   *)(hdr.magic + 1)) - (unsigned int )((void const   *)(hdr.magic)) ==
                        1U) {
#line 795
                      tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 795
                    __s1___30 = (unsigned char const   *)((char const   *)(hdr.magic));
#line 795
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                                               0)));
#line 795
                    if (__s2_len___0 > 0U) {
#line 795
                      if (__result___46 == 0) {
#line 795
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                1)));
#line 795
                        if (__s2_len___0 > 1U) {
#line 795
                          if (__result___46 == 0) {
#line 795
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                    2)));
#line 795
                            if (__s2_len___0 > 2U) {
#line 795
                              if (__result___46 == 0) {
#line 795
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)(magic_id)) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 795
                    tmp___112 = __result___46;
                  }
                } else {
#line 795
                  tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
                }
              } else {
#line 795
                tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
              }
            } else {
#line 795
              tmp___112 = __builtin_strcmp(hdr.magic, magic_id);
            }
          }
        }
#line 795
        tmp___76 = tmp___112;
      } else {
#line 795
        tmp___76 = strncmp((char const   *)(hdr.magic), (char const   *)(magic_id),
                           8U);
      }
    } else {
#line 795
      tmp___76 = strncmp((char const   *)(hdr.magic), (char const   *)(magic_id),
                         8U);
    }
  }
#line 795
  if (tmp___76 != 0) {
#line 796
    cli_dbgmsg("OLE2 magic failed!\n");
#line 798
    if ((unsigned int )hdr.m_area != (unsigned int )((void *)0)) {
#line 799
      munmap((void *)hdr.m_area, (unsigned int )hdr.m_length);
    }
#line 802
    return (105);
  }
#line 805
  if ((int )hdr.log2_big_block_size != 9) {
#line 806
    cli_errmsg("WARNING: not scanned; untested big block size - please report\n");
    goto abort;
  }
#line 809
  if (hdr.log2_small_block_size != 6U) {
#line 810
    cli_errmsg("WARNING: not scanned; untested small block size - please report\n");
    goto abort;
  }
#line 813
  if (hdr.sbat_cutoff != 4096U) {
#line 814
    cli_errmsg("WARNING: not scanned; untested sbat cutoff - please report\n");
    goto abort;
  }
#line 818
  print_ole2_header(& hdr);
#line 826
  ole2_walk_property_tree(fd, & hdr, dirname, 0, & handler_writefile, 0, & file_count,
                          limits);
  abort: 
#line 830
  if ((unsigned int )hdr.m_area != (unsigned int )((void *)0)) {
#line 831
    munmap((void *)hdr.m_area, (unsigned int )hdr.m_length);
  }
#line 834
  return (0);
}
}
#line 1 "vba_extract.lo"
#pragma merger(0,"/tmp/cil-FGkU5eG9.i","-g -O2 -fPIC")
#line 1162 "/usr/include/zlib.h"
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 53 "vba_extract.c"
static uint16_t vba_endian_convert_16(uint16_t value , int is_mac ) 
{ 

  {
#line 55
  if (is_mac) {
#line 59
    return (value);
  } else {
#line 65
    return ((unsigned short )(((int )value >> 8) + ((int )value << 8)));
  }
}
}
#line 70 "vba_extract.c"
static uint32_t vba_endian_convert_32(uint32_t value , int is_mac ) 
{ 

  {
#line 72
  if (is_mac) {
#line 77
    return (value);
  } else {
#line 83
    return ((((value >> 24) | ((value & 16711680U) >> 8)) | ((value & 65280U) << 8)) |
            (value << 24));
  }
}
}
#line 95 "vba_extract.c"
vba_version_t vba_version[14]  = 
#line 95
  {      {{(unsigned char)94, (unsigned char)0, (unsigned char)0, (unsigned char)1}, "Office 97",
      5, 0}, 
        {{(unsigned char)95, (unsigned char)0, (unsigned char)0, (unsigned char)1}, "Office 97 SR1",
      5, 0}, 
        {{(unsigned char)101, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000 alpha?", 6, 0}, 
        {{(unsigned char)107, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000 beta?", 6, 0}, 
        {{(unsigned char)109, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000", 6, 0}, 
        {{(unsigned char)111, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2000", 6, 0}, 
        {{(unsigned char)112, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office XP beta 1/2", 6, 0}, 
        {{(unsigned char)115, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office XP", 6, 0}, 
        {{(unsigned char)118, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2003", 6, 0}, 
        {{(unsigned char)121, (unsigned char)0, (unsigned char)0, (unsigned char)1},
      "Office 2003", 6, 0}, 
        {{(unsigned char)96, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice 98", 5, 1}, 
        {{(unsigned char)98, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice 2001", 5, 1}, 
        {{(unsigned char)99, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice X", 6, 1}, 
        {{(unsigned char)100, (unsigned char)0, (unsigned char)0, (unsigned char)14},
      "MacOffice 2004", 6, 1}};
#line 120 "vba_extract.c"
static char *get_unicode_name(char *name , int size , int is_mac ) 
{ int i ;
  int j ;
  char *newname ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 125
  if (! name) {
#line 126
    return ((char *)((void *)0));
  } else {
#line 125
    if ((int )(*name) == 0) {
#line 126
      return ((char *)((void *)0));
    } else {
#line 125
      if (size <= 0) {
#line 126
        return ((char *)((void *)0));
      }
    }
  }
#line 129
  newname = (char *)cli_malloc((unsigned int )(size * 4));
#line 130
  if (! newname) {
#line 131
    return ((char *)((void *)0));
  }
#line 133
  j = 0;
#line 134
  i = 0;
#line 134
  while (i < size) {
#line 135
    tmp___5 = __ctype_b_loc();
#line 135
    if ((int const   )(*((*tmp___5) + (int )(*(name + i)))) & 16384) {
#line 136
      tmp___1 = j;
#line 136
      j ++;
#line 136
      (*(newname + tmp___1)) = (*(name + i));
    } else {
#line 138
      if ((int )(*(name + i)) < 10) {
#line 138
        if ((int )(*(name + i)) >= 0) {
#line 139
          tmp___2 = j;
#line 139
          j ++;
#line 139
          (*(newname + tmp___2)) = (char )'_';
#line 140
          tmp___3 = j;
#line 140
          j ++;
#line 140
          (*(newname + tmp___3)) = (char )((int )(*(name + i)) + 48);
        }
      }
#line 142
      tmp___4 = j;
#line 142
      j ++;
#line 142
      (*(newname + tmp___4)) = (char )'_';
    }
#line 134
    if (is_mac) {
#line 134
      tmp___0 = 1;
    } else {
#line 134
      tmp___0 = 2;
    }
#line 134
    i += tmp___0;
  }
#line 145
  (*(newname + j)) = (char )'\000';
#line 146
  return (newname);
}
}
#line 154
static void vba56_test_middle(int fd ) ;
#line 154 "vba_extract.c"
static uint8_t const   middle1_str[20]  = 
#line 154
  {      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)1,      (uint8_t const   )(unsigned char)13,      (uint8_t const   )(unsigned char)69, 
        (uint8_t const   )(unsigned char)46,      (uint8_t const   )(unsigned char)225,      (uint8_t const   )(unsigned char)224,      (uint8_t const   )(unsigned char)143, 
        (uint8_t const   )(unsigned char)16,      (uint8_t const   )(unsigned char)26,      (uint8_t const   )(unsigned char)133,      (uint8_t const   )(unsigned char)46, 
        (uint8_t const   )(unsigned char)2,      (uint8_t const   )(unsigned char)96,      (uint8_t const   )(unsigned char)140,      (uint8_t const   )(unsigned char)77, 
        (uint8_t const   )(unsigned char)11,      (uint8_t const   )(unsigned char)180,      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)0};
#line 159 "vba_extract.c"
static uint8_t const   middle2_str[20]  = 
#line 159
  {      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)225,      (uint8_t const   )(unsigned char)46, 
        (uint8_t const   )(unsigned char)69,      (uint8_t const   )(unsigned char)13,      (uint8_t const   )(unsigned char)143,      (uint8_t const   )(unsigned char)224, 
        (uint8_t const   )(unsigned char)26,      (uint8_t const   )(unsigned char)16,      (uint8_t const   )(unsigned char)133,      (uint8_t const   )(unsigned char)46, 
        (uint8_t const   )(unsigned char)2,      (uint8_t const   )(unsigned char)96,      (uint8_t const   )(unsigned char)140,      (uint8_t const   )(unsigned char)77, 
        (uint8_t const   )(unsigned char)11,      (uint8_t const   )(unsigned char)180,      (uint8_t const   )(unsigned char)0,      (uint8_t const   )(unsigned char)0};
#line 149 "vba_extract.c"
static void vba56_test_middle(int fd ) 
{ char test_middle[20] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 164
  tmp = cli_readn(fd, (void *)(& test_middle), 20U);
#line 164
  if (tmp != 20) {
#line 165
    return;
  }
#line 168
  tmp___0 = memcmp((void const   *)(test_middle), (void const   *)(middle1_str), 20U);
#line 168
  if (tmp___0 != 0) {
#line 168
    tmp___1 = memcmp((void const   *)(test_middle), (void const   *)(middle2_str),
                     20U);
#line 168
    if (tmp___1 != 0) {
#line 170
      cli_dbgmsg("middle not found\n");
#line 171
      lseek(fd, -20L, 1);
    } else {
#line 173
      cli_dbgmsg("middle found\n");
    }
  } else {
#line 173
    cli_dbgmsg("middle found\n");
  }
#line 175
  return;
}
}
#line 178 "vba_extract.c"
static int vba_read_project_strings(int fd , int is_mac ) 
{ uint16_t length ;
  unsigned char *buff ;
  unsigned char *name ;
  uint32_t offset ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___79 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___115 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___134 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  size_t tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  int tmp___227 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___263 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___282 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___291 ;
  int tmp___292 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  size_t tmp___298 ;
  int tmp___299 ;
  size_t tmp___300 ;
  int tmp___375 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___411 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___430 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___439 ;
  int tmp___440 ;
  int tmp___441 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  size_t tmp___446 ;
  int tmp___447 ;
  size_t tmp___448 ;
  int tmp___523 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___559 ;
  unsigned char const   *__s2___62 ;
  register int __result___186 ;
  int tmp___578 ;
  unsigned char const   *__s1___126 ;
  register int __result___190 ;
  int tmp___587 ;
  int tmp___588 ;
  int tmp___589 ;
  int tmp___590 ;
  int tmp___591 ;
  int tmp___592 ;
  int tmp___593 ;
  size_t tmp___594 ;
  int tmp___595 ;
  size_t tmp___596 ;

  {
#line 184
  while (1) {
#line 185
    tmp = cli_readn(fd, (void *)(& length), 2U);
#line 185
    if (tmp != 2) {
#line 186
      return (0);
    }
#line 188
    length = vba_endian_convert_16(length, is_mac);
#line 189
    if ((int )length < 6) {
#line 190
      lseek(fd, -2L, 1);
#line 191
      break;
    }
#line 193
    cli_dbgmsg("length: %d, ", length);
#line 194
    buff = (unsigned char *)cli_malloc((unsigned int )length);
#line 195
    if (! buff) {
#line 196
      cli_errmsg("cli_malloc failed\n");
#line 197
      return (0);
    }
#line 199
    offset = (uint32_t )lseek(fd, 0L, 1);
#line 200
    tmp___1 = cli_readn(fd, (void *)buff, (unsigned int )length);
#line 200
    if (tmp___1 != (int )length) {
#line 201
      cli_dbgmsg("read name failed - rewinding\n");
#line 202
      lseek(fd, (long )offset, 0);
#line 203
      free((void *)buff);
#line 204
      break;
    }
#line 206
    name = (unsigned char *)get_unicode_name((char *)buff, (int )length, is_mac);
#line 207
    if (name) {
#line 208
      cli_dbgmsg("name: %s\n", name);
    } else {
#line 210
      cli_dbgmsg("name: [null]\n");
    }
#line 212
    free((void *)buff);
#line 219
    if (name) {
#line 218
      tmp___149 = __builtin_constant_p((int )"*\\G");
#line 218
      if (tmp___149) {
#line 218
        tmp___150 = strlen("*\\G");
#line 218
        if (tmp___150 < 3U) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
#line 218
        tmp___151 = __builtin_constant_p((int )name);
#line 218
        if (tmp___151) {
#line 218
          tmp___152 = strlen((char const   *)name);
#line 218
          if (tmp___152 < 3U) {
            _L___39: 
#line 218
            tmp___146 = __builtin_constant_p((int )"*\\G");
#line 218
            if (tmp___146) {
#line 218
              tmp___147 = __builtin_constant_p((int )name);
#line 218
              if (tmp___147) {
#line 218
                __s1_len___0 = strlen("*\\G");
#line 218
                __s2_len___0 = strlen((char const   *)name);
#line 218
                if (! ((unsigned int )((void const   *)("*\\G" + 1)) - (unsigned int )((void const   *)"*\\G") ==
                       1U)) {
                  goto _L___36;
                } else {
#line 218
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
#line 218
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                           1U)) {
#line 218
                      tmp___148 = 1;
                    } else {
#line 218
                      if (__s2_len___0 >= 4U) {
#line 218
                        tmp___148 = 1;
                      } else {
#line 218
                        tmp___148 = 0;
                      }
                    }
                  } else {
#line 218
                    tmp___148 = 0;
                  }
                }
#line 218
                if (tmp___148) {
#line 218
                  tmp___115 = __builtin_strcmp("*\\G", name);
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
#line 218
              tmp___145 = __builtin_constant_p((int )"*\\G");
#line 218
              if (tmp___145) {
#line 218
                if ((unsigned int )((void const   *)("*\\G" + 1)) - (unsigned int )((void const   *)"*\\G") ==
                    1U) {
#line 218
                  __s1_len___0 = strlen("*\\G");
#line 218
                  if (__s1_len___0 < 4U) {
#line 218
                    tmp___134 = __builtin_constant_p((int )name);
#line 218
                    if (tmp___134) {
#line 218
                      if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                          1U) {
#line 218
                        tmp___115 = __builtin_strcmp("*\\G", name);
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
#line 218
                      __s2___14 = (unsigned char const   *)((char const   *)name);
#line 218
                      __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
#line 218
                      if (__s1_len___0 > 0U) {
#line 218
                        if (__result___42 == 0) {
#line 218
                          __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
#line 218
                          if (__s1_len___0 > 1U) {
#line 218
                            if (__result___42 == 0) {
#line 218
                              __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
#line 218
                              if (__s1_len___0 > 2U) {
#line 218
                                if (__result___42 == 0) {
#line 218
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)"*\\G" +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 218
                      tmp___115 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
#line 218
                tmp___144 = __builtin_constant_p((int )name);
#line 218
                if (tmp___144) {
#line 218
                  if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                      1U) {
#line 218
                    __s2_len___0 = strlen((char const   *)name);
#line 218
                    if (__s2_len___0 < 4U) {
#line 218
                      tmp___143 = __builtin_constant_p((int )"*\\G");
#line 218
                      if (tmp___143) {
#line 218
                        if ((unsigned int )((void const   *)("*\\G" + 1)) - (unsigned int )((void const   *)"*\\G") ==
                            1U) {
#line 218
                          tmp___115 = __builtin_strcmp("*\\G", name);
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
#line 218
                        __s1___30 = (unsigned char const   *)"*\\G";
#line 218
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                0)));
#line 218
                        if (__s2_len___0 > 0U) {
#line 218
                          if (__result___46 == 0) {
#line 218
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                    1)));
#line 218
                            if (__s2_len___0 > 1U) {
#line 218
                              if (__result___46 == 0) {
#line 218
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                               2)));
#line 218
                                if (__s2_len___0 > 2U) {
#line 218
                                  if (__result___46 == 0) {
#line 218
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 218
                        tmp___115 = __result___46;
                      }
                    } else {
#line 218
                      tmp___115 = __builtin_strcmp("*\\G", name);
                    }
                  } else {
#line 218
                    tmp___115 = __builtin_strcmp("*\\G", name);
                  }
                } else {
#line 218
                  tmp___115 = __builtin_strcmp("*\\G", name);
                }
              }
            }
#line 218
            tmp___79 = tmp___115;
          } else {
#line 218
            tmp___79 = strncmp("*\\G", (char const   *)name, 3U);
          }
        } else {
#line 218
          tmp___79 = strncmp("*\\G", (char const   *)name, 3U);
        }
      }
#line 219
      if (tmp___79) {
#line 218
        tmp___297 = __builtin_constant_p((int )"*\\H");
#line 218
        if (tmp___297) {
#line 218
          tmp___298 = strlen("*\\H");
#line 218
          if (tmp___298 < 3U) {
            goto _L___81;
          } else {
            goto _L___82;
          }
        } else {
          _L___82: 
#line 218
          tmp___299 = __builtin_constant_p((int )name);
#line 218
          if (tmp___299) {
#line 218
            tmp___300 = strlen((char const   *)name);
#line 218
            if (tmp___300 < 3U) {
              _L___81: 
#line 218
              tmp___294 = __builtin_constant_p((int )"*\\H");
#line 218
              if (tmp___294) {
#line 218
                tmp___295 = __builtin_constant_p((int )name);
#line 218
                if (tmp___295) {
#line 218
                  __s1_len___2 = strlen("*\\H");
#line 218
                  __s2_len___2 = strlen((char const   *)name);
#line 218
                  if (! ((unsigned int )((void const   *)("*\\H" + 1)) - (unsigned int )((void const   *)"*\\H") ==
                         1U)) {
                    goto _L___78;
                  } else {
#line 218
                    if (__s1_len___2 >= 4U) {
                      _L___78: 
#line 218
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                             1U)) {
#line 218
                        tmp___296 = 1;
                      } else {
#line 218
                        if (__s2_len___2 >= 4U) {
#line 218
                          tmp___296 = 1;
                        } else {
#line 218
                          tmp___296 = 0;
                        }
                      }
                    } else {
#line 218
                      tmp___296 = 0;
                    }
                  }
#line 218
                  if (tmp___296) {
#line 218
                    tmp___263 = __builtin_strcmp("*\\H", name);
                  } else {
                    goto _L___80;
                  }
                } else {
                  goto _L___80;
                }
              } else {
                _L___80: 
#line 218
                tmp___293 = __builtin_constant_p((int )"*\\H");
#line 218
                if (tmp___293) {
#line 218
                  if ((unsigned int )((void const   *)("*\\H" + 1)) - (unsigned int )((void const   *)"*\\H") ==
                      1U) {
#line 218
                    __s1_len___2 = strlen("*\\H");
#line 218
                    if (__s1_len___2 < 4U) {
#line 218
                      tmp___282 = __builtin_constant_p((int )name);
#line 218
                      if (tmp___282) {
#line 218
                        if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                            1U) {
#line 218
                          tmp___263 = __builtin_strcmp("*\\H", name);
                        } else {
                          goto _L___73;
                        }
                      } else {
                        _L___73: 
#line 218
                        __s2___30 = (unsigned char const   *)((char const   *)name);
#line 218
                        __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                0)) - (int const   )(*(__s2___30 +
                                                                                       0)));
#line 218
                        if (__s1_len___2 > 0U) {
#line 218
                          if (__result___90 == 0) {
#line 218
                            __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                    1)) - (int const   )(*(__s2___30 +
                                                                                           1)));
#line 218
                            if (__s1_len___2 > 1U) {
#line 218
                              if (__result___90 == 0) {
#line 218
                                __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                        2)) - (int const   )(*(__s2___30 +
                                                                                               2)));
#line 218
                                if (__s1_len___2 > 2U) {
#line 218
                                  if (__result___90 == 0) {
#line 218
                                    __result___90 = (int )((int const   )(*((unsigned char const   *)"*\\H" +
                                                                            3)) -
                                                           (int const   )(*(__s2___30 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 218
                        tmp___263 = __result___90;
                      }
                    } else {
                      goto _L___77;
                    }
                  } else {
                    goto _L___77;
                  }
                } else {
                  _L___77: 
#line 218
                  tmp___292 = __builtin_constant_p((int )name);
#line 218
                  if (tmp___292) {
#line 218
                    if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                        1U) {
#line 218
                      __s2_len___2 = strlen((char const   *)name);
#line 218
                      if (__s2_len___2 < 4U) {
#line 218
                        tmp___291 = __builtin_constant_p((int )"*\\H");
#line 218
                        if (tmp___291) {
#line 218
                          if ((unsigned int )((void const   *)("*\\H" + 1)) - (unsigned int )((void const   *)"*\\H") ==
                              1U) {
#line 218
                            tmp___263 = __builtin_strcmp("*\\H", name);
                          } else {
                            goto _L___75;
                          }
                        } else {
                          _L___75: 
#line 218
                          __s1___62 = (unsigned char const   *)"*\\H";
#line 218
                          __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                  0)));
#line 218
                          if (__s2_len___2 > 0U) {
#line 218
                            if (__result___94 == 0) {
#line 218
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      1)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                             1)));
#line 218
                              if (__s2_len___2 > 1U) {
#line 218
                                if (__result___94 == 0) {
#line 218
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          2)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                                 2)));
#line 218
                                  if (__s2_len___2 > 2U) {
#line 218
                                    if (__result___94 == 0) {
#line 218
                                      __result___94 = (int )((int const   )(*(__s1___62 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 218
                          tmp___263 = __result___94;
                        }
                      } else {
#line 218
                        tmp___263 = __builtin_strcmp("*\\H", name);
                      }
                    } else {
#line 218
                      tmp___263 = __builtin_strcmp("*\\H", name);
                    }
                  } else {
#line 218
                    tmp___263 = __builtin_strcmp("*\\H", name);
                  }
                }
              }
#line 218
              tmp___227 = tmp___263;
            } else {
#line 218
              tmp___227 = strncmp("*\\H", (char const   *)name, 3U);
            }
          } else {
#line 218
            tmp___227 = strncmp("*\\H", (char const   *)name, 3U);
          }
        }
#line 219
        if (tmp___227) {
#line 219
          tmp___445 = __builtin_constant_p((int )"*\\C");
#line 219
          if (tmp___445) {
#line 219
            tmp___446 = strlen("*\\C");
#line 219
            if (tmp___446 < 3U) {
              goto _L___123;
            } else {
              goto _L___124;
            }
          } else {
            _L___124: 
#line 219
            tmp___447 = __builtin_constant_p((int )name);
#line 219
            if (tmp___447) {
#line 219
              tmp___448 = strlen((char const   *)name);
#line 219
              if (tmp___448 < 3U) {
                _L___123: 
#line 219
                tmp___442 = __builtin_constant_p((int )"*\\C");
#line 219
                if (tmp___442) {
#line 219
                  tmp___443 = __builtin_constant_p((int )name);
#line 219
                  if (tmp___443) {
#line 219
                    __s1_len___4 = strlen("*\\C");
#line 219
                    __s2_len___4 = strlen((char const   *)name);
#line 219
                    if (! ((unsigned int )((void const   *)("*\\C" + 1)) - (unsigned int )((void const   *)"*\\C") ==
                           1U)) {
                      goto _L___120;
                    } else {
#line 219
                      if (__s1_len___4 >= 4U) {
                        _L___120: 
#line 219
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                               1U)) {
#line 219
                          tmp___444 = 1;
                        } else {
#line 219
                          if (__s2_len___4 >= 4U) {
#line 219
                            tmp___444 = 1;
                          } else {
#line 219
                            tmp___444 = 0;
                          }
                        }
                      } else {
#line 219
                        tmp___444 = 0;
                      }
                    }
#line 219
                    if (tmp___444) {
#line 219
                      tmp___411 = __builtin_strcmp("*\\C", name);
                    } else {
                      goto _L___122;
                    }
                  } else {
                    goto _L___122;
                  }
                } else {
                  _L___122: 
#line 219
                  tmp___441 = __builtin_constant_p((int )"*\\C");
#line 219
                  if (tmp___441) {
#line 219
                    if ((unsigned int )((void const   *)("*\\C" + 1)) - (unsigned int )((void const   *)"*\\C") ==
                        1U) {
#line 219
                      __s1_len___4 = strlen("*\\C");
#line 219
                      if (__s1_len___4 < 4U) {
#line 219
                        tmp___430 = __builtin_constant_p((int )name);
#line 219
                        if (tmp___430) {
#line 219
                          if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                              1U) {
#line 219
                            tmp___411 = __builtin_strcmp("*\\C", name);
                          } else {
                            goto _L___115;
                          }
                        } else {
                          _L___115: 
#line 219
                          __s2___46 = (unsigned char const   *)((char const   *)name);
#line 219
                          __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                   0)) - (int const   )(*(__s2___46 +
                                                                                          0)));
#line 219
                          if (__s1_len___4 > 0U) {
#line 219
                            if (__result___138 == 0) {
#line 219
                              __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                       1)) - (int const   )(*(__s2___46 +
                                                                                              1)));
#line 219
                              if (__s1_len___4 > 1U) {
#line 219
                                if (__result___138 == 0) {
#line 219
                                  __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                           2)) - (int const   )(*(__s2___46 +
                                                                                                  2)));
#line 219
                                  if (__s1_len___4 > 2U) {
#line 219
                                    if (__result___138 == 0) {
#line 219
                                      __result___138 = (int )((int const   )(*((unsigned char const   *)"*\\C" +
                                                                               3)) -
                                                              (int const   )(*(__s2___46 +
                                                                               3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 219
                          tmp___411 = __result___138;
                        }
                      } else {
                        goto _L___119;
                      }
                    } else {
                      goto _L___119;
                    }
                  } else {
                    _L___119: 
#line 219
                    tmp___440 = __builtin_constant_p((int )name);
#line 219
                    if (tmp___440) {
#line 219
                      if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                          1U) {
#line 219
                        __s2_len___4 = strlen((char const   *)name);
#line 219
                        if (__s2_len___4 < 4U) {
#line 219
                          tmp___439 = __builtin_constant_p((int )"*\\C");
#line 219
                          if (tmp___439) {
#line 219
                            if ((unsigned int )((void const   *)("*\\C" + 1)) - (unsigned int )((void const   *)"*\\C") ==
                                1U) {
#line 219
                              tmp___411 = __builtin_strcmp("*\\C", name);
                            } else {
                              goto _L___117;
                            }
                          } else {
                            _L___117: 
#line 219
                            __s1___94 = (unsigned char const   *)"*\\C";
#line 219
                            __result___142 = (int )((int const   )(*(__s1___94 + 0)) -
                                                    (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                     0)));
#line 219
                            if (__s2_len___4 > 0U) {
#line 219
                              if (__result___142 == 0) {
#line 219
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         1)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                                1)));
#line 219
                                if (__s2_len___4 > 1U) {
#line 219
                                  if (__result___142 == 0) {
#line 219
                                    __result___142 = (int )((int const   )(*(__s1___94 +
                                                                             2)) -
                                                            (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                             2)));
#line 219
                                    if (__s2_len___4 > 2U) {
#line 219
                                      if (__result___142 == 0) {
#line 219
                                        __result___142 = (int )((int const   )(*(__s1___94 +
                                                                                 3)) -
                                                                (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                 3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
#line 219
                            tmp___411 = __result___142;
                          }
                        } else {
#line 219
                          tmp___411 = __builtin_strcmp("*\\C", name);
                        }
                      } else {
#line 219
                        tmp___411 = __builtin_strcmp("*\\C", name);
                      }
                    } else {
#line 219
                      tmp___411 = __builtin_strcmp("*\\C", name);
                    }
                  }
                }
#line 219
                tmp___375 = tmp___411;
              } else {
#line 219
                tmp___375 = strncmp("*\\C", (char const   *)name, 3U);
              }
            } else {
#line 219
              tmp___375 = strncmp("*\\C", (char const   *)name, 3U);
            }
          }
#line 219
          if (tmp___375) {
#line 219
            tmp___593 = __builtin_constant_p((int )"*\\D");
#line 219
            if (tmp___593) {
#line 219
              tmp___594 = strlen("*\\D");
#line 219
              if (tmp___594 < 3U) {
                goto _L___165;
              } else {
                goto _L___166;
              }
            } else {
              _L___166: 
#line 219
              tmp___595 = __builtin_constant_p((int )name);
#line 219
              if (tmp___595) {
#line 219
                tmp___596 = strlen((char const   *)name);
#line 219
                if (tmp___596 < 3U) {
                  _L___165: 
#line 219
                  tmp___590 = __builtin_constant_p((int )"*\\D");
#line 219
                  if (tmp___590) {
#line 219
                    tmp___591 = __builtin_constant_p((int )name);
#line 219
                    if (tmp___591) {
#line 219
                      __s1_len___6 = strlen("*\\D");
#line 219
                      __s2_len___6 = strlen((char const   *)name);
#line 219
                      if (! ((unsigned int )((void const   *)("*\\D" + 1)) - (unsigned int )((void const   *)"*\\D") ==
                             1U)) {
                        goto _L___162;
                      } else {
#line 219
                        if (__s1_len___6 >= 4U) {
                          _L___162: 
#line 219
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                                 1U)) {
#line 219
                            tmp___592 = 1;
                          } else {
#line 219
                            if (__s2_len___6 >= 4U) {
#line 219
                              tmp___592 = 1;
                            } else {
#line 219
                              tmp___592 = 0;
                            }
                          }
                        } else {
#line 219
                          tmp___592 = 0;
                        }
                      }
#line 219
                      if (tmp___592) {
#line 219
                        tmp___559 = __builtin_strcmp("*\\D", name);
                      } else {
                        goto _L___164;
                      }
                    } else {
                      goto _L___164;
                    }
                  } else {
                    _L___164: 
#line 219
                    tmp___589 = __builtin_constant_p((int )"*\\D");
#line 219
                    if (tmp___589) {
#line 219
                      if ((unsigned int )((void const   *)("*\\D" + 1)) - (unsigned int )((void const   *)"*\\D") ==
                          1U) {
#line 219
                        __s1_len___6 = strlen("*\\D");
#line 219
                        if (__s1_len___6 < 4U) {
#line 219
                          tmp___578 = __builtin_constant_p((int )name);
#line 219
                          if (tmp___578) {
#line 219
                            if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                                1U) {
#line 219
                              tmp___559 = __builtin_strcmp("*\\D", name);
                            } else {
                              goto _L___157;
                            }
                          } else {
                            _L___157: 
#line 219
                            __s2___62 = (unsigned char const   *)((char const   *)name);
#line 219
                            __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                     0)) - (int const   )(*(__s2___62 +
                                                                                            0)));
#line 219
                            if (__s1_len___6 > 0U) {
#line 219
                              if (__result___186 == 0) {
#line 219
                                __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                         1)) - (int const   )(*(__s2___62 +
                                                                                                1)));
#line 219
                                if (__s1_len___6 > 1U) {
#line 219
                                  if (__result___186 == 0) {
#line 219
                                    __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                             2)) -
                                                            (int const   )(*(__s2___62 +
                                                                             2)));
#line 219
                                    if (__s1_len___6 > 2U) {
#line 219
                                      if (__result___186 == 0) {
#line 219
                                        __result___186 = (int )((int const   )(*((unsigned char const   *)"*\\D" +
                                                                                 3)) -
                                                                (int const   )(*(__s2___62 +
                                                                                 3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
#line 219
                            tmp___559 = __result___186;
                          }
                        } else {
                          goto _L___161;
                        }
                      } else {
                        goto _L___161;
                      }
                    } else {
                      _L___161: 
#line 219
                      tmp___588 = __builtin_constant_p((int )name);
#line 219
                      if (tmp___588) {
#line 219
                        if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                            1U) {
#line 219
                          __s2_len___6 = strlen((char const   *)name);
#line 219
                          if (__s2_len___6 < 4U) {
#line 219
                            tmp___587 = __builtin_constant_p((int )"*\\D");
#line 219
                            if (tmp___587) {
#line 219
                              if ((unsigned int )((void const   *)("*\\D" + 1)) -
                                  (unsigned int )((void const   *)"*\\D") == 1U) {
#line 219
                                tmp___559 = __builtin_strcmp("*\\D", name);
                              } else {
                                goto _L___159;
                              }
                            } else {
                              _L___159: 
#line 219
                              __s1___126 = (unsigned char const   *)"*\\D";
#line 219
                              __result___190 = (int )((int const   )(*(__s1___126 +
                                                                       0)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                              0)));
#line 219
                              if (__s2_len___6 > 0U) {
#line 219
                                if (__result___190 == 0) {
#line 219
                                  __result___190 = (int )((int const   )(*(__s1___126 +
                                                                           1)) - (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                                  1)));
#line 219
                                  if (__s2_len___6 > 1U) {
#line 219
                                    if (__result___190 == 0) {
#line 219
                                      __result___190 = (int )((int const   )(*(__s1___126 +
                                                                               2)) -
                                                              (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                               2)));
#line 219
                                      if (__s2_len___6 > 2U) {
#line 219
                                        if (__result___190 == 0) {
#line 219
                                          __result___190 = (int )((int const   )(*(__s1___126 +
                                                                                   3)) -
                                                                  (int const   )(*((unsigned char const   *)((char const   *)name) +
                                                                                   3)));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
#line 219
                              tmp___559 = __result___190;
                            }
                          } else {
#line 219
                            tmp___559 = __builtin_strcmp("*\\D", name);
                          }
                        } else {
#line 219
                          tmp___559 = __builtin_strcmp("*\\D", name);
                        }
                      } else {
#line 219
                        tmp___559 = __builtin_strcmp("*\\D", name);
                      }
                    }
                  }
#line 219
                  tmp___523 = tmp___559;
                } else {
#line 219
                  tmp___523 = strncmp("*\\D", (char const   *)name, 3U);
                }
              } else {
#line 219
                tmp___523 = strncmp("*\\D", (char const   *)name, 3U);
              }
            }
#line 219
            if (tmp___523) {
              goto _L___167;
            } else {
              _L___168: 
#line 220
              tmp___2 = cli_readn(fd, (void *)(& length), 2U);
#line 220
              if (tmp___2 != 2) {
#line 221
                return (0);
              }
#line 223
              length = vba_endian_convert_16(length, is_mac);
#line 224
              if ((int )length != 0) {
#line 224
                if ((int )length != 65535) {
#line 225
                  lseek(fd, -2L, 1);
#line 226
                  free((void *)name);
                  goto __Cont;
                }
              }
#line 229
              buff = (unsigned char *)cli_malloc(10U);
#line 230
              if (! buff) {
#line 231
                free((void *)name);
#line 232
                close(fd);
#line 233
                return (0);
              }
#line 235
              tmp___4 = cli_readn(fd, (void *)buff, 10U);
#line 235
              if (tmp___4 != 10) {
#line 236
                cli_errmsg("failed to read blob\n");
#line 237
                free((void *)buff);
#line 238
                free((void *)name);
#line 239
                close(fd);
#line 240
                return (0);
              }
#line 242
              free((void *)buff);
            }
          } else {
            goto _L___168;
          }
        } else {
          goto _L___168;
        }
      } else {
        goto _L___168;
      }
    } else {
      _L___167: 
#line 245
      lseek(fd, (long )(- ((int )length + 2)), 1);
#line 246
      if (name) {
#line 247
        free((void *)name);
      }
#line 249
      break;
    }
#line 251
    free((void *)name);
#line 252
    offset = (uint32_t )lseek(fd, 0L, 1);
#line 253
    cli_dbgmsg("offset: %u\n", offset);
#line 254
    vba56_test_middle(fd);
    __Cont: ;
  }
#line 256
  return (1);
}
}
#line 259 "vba_extract.c"
vba_project_t *vba56_dir_read(char const   *dir ) 
{ unsigned char magic[2] ;
  unsigned char version[4] ;
  unsigned char *buff ;
  unsigned char vba56_signature[2] ;
  uint16_t record_count ;
  uint16_t length ;
  uint16_t ooff ;
  uint16_t byte_count ;
  uint32_t offset ;
  uint32_t LidA ;
  uint32_t LidB ;
  uint16_t CharSet ;
  uint16_t LenA ;
  uint32_t UnknownB ;
  uint32_t UnknownC ;
  uint16_t LenB ;
  uint16_t LenC ;
  uint16_t LenD ;
  int i ;
  int j ;
  int fd ;
  int is_mac ;
  vba_project_t *vba_project ;
  char *fullname ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __len___2 ;
  size_t tmp___39 ;
  char *__retval___2 ;
  char *tmp___40 ;
  int tmp___42 ;
  int tmp___44 ;
  int tmp___46 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  off_t foffset ;

  {
#line 264
  vba56_signature[0] = (unsigned char)204;
#line 264
  vba56_signature[1] = (unsigned char)97;
#line 282
  cli_dbgmsg("in vba56_dir_read()\n");
#line 284
  tmp = strlen(dir);
#line 284
  fullname = (char *)cli_malloc(tmp + 14U);
#line 285
  if (! fullname) {
#line 286
    return ((vba_project_t *)((void *)0));
  }
#line 288
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/_VBA_PROJECT",
          dir);
#line 289
  fd = open((char const   *)fullname, 0);
#line 291
  if (fd == -1) {
#line 292
    cli_dbgmsg("Can\'t open %s\n", fullname);
#line 293
    free((void *)fullname);
#line 295
    return ((vba_project_t *)((void *)0));
  }
#line 297
  free((void *)fullname);
#line 299
  tmp___1 = cli_readn(fd, (void *)(& magic), 2U);
#line 299
  if (tmp___1 != 2) {
#line 300
    close(fd);
#line 301
    return ((vba_project_t *)((void *)0));
  }
#line 303
  tmp___2 = memcmp((void const   *)(magic), (void const   *)(vba56_signature), 2U);
#line 303
  if (tmp___2 != 0) {
#line 304
    close(fd);
#line 305
    return ((vba_project_t *)((void *)0));
  }
#line 308
  tmp___3 = cli_readn(fd, (void *)(& version), 4U);
#line 308
  if (tmp___3 != 4) {
#line 309
    close(fd);
#line 310
    return ((vba_project_t *)((void *)0));
  }
#line 312
  i = 0;
#line 312
  while (i < 14) {
#line 313
    tmp___4 = memcmp((void const   *)(version), (void const   *)(vba_version[i].signature),
                     4U);
#line 313
    if (tmp___4 == 0) {
#line 314
      break;
    }
#line 312
    i ++;
  }
#line 318
  if (i == 14) {
#line 319
    cli_warnmsg("Unknown VBA version signature %x %x %x %x\n", version[0], version[1],
                version[2], version[3]);
#line 321
    if ((int )version[3] == 1) {
#line 322
      cli_warnmsg("Guessing little-endian\n");
#line 323
      is_mac = 0;
    } else {
#line 324
      if ((int )version[3] == 14) {
#line 325
        cli_warnmsg("Guessing big-endian\n");
#line 326
        is_mac = 1;
      } else {
#line 328
        cli_warnmsg("Unable to guess VBA type\n");
#line 329
        close(fd);
#line 330
        return ((vba_project_t *)((void *)0));
      }
    }
  } else {
#line 333
    cli_dbgmsg("VBA Project: %s, VBA Version=%d\n", vba_version[i].name, vba_version[i].vba_version);
#line 335
    is_mac = vba_version[i].is_mac;
  }
#line 341
  tmp___5 = cli_readn(fd, (void *)(& ooff), 2U);
#line 341
  if (tmp___5 != 2) {
#line 342
    close(fd);
#line 343
    return ((vba_project_t *)((void *)0));
  }
#line 346
  tmp___6 = cli_readn(fd, (void *)(& LidA), 4U);
#line 346
  if (tmp___6 != 4) {
#line 347
    close(fd);
#line 348
    return ((vba_project_t *)((void *)0));
  }
#line 351
  tmp___7 = cli_readn(fd, (void *)(& LidB), 4U);
#line 351
  if (tmp___7 != 4) {
#line 352
    close(fd);
#line 353
    return ((vba_project_t *)((void *)0));
  }
#line 356
  tmp___8 = cli_readn(fd, (void *)(& CharSet), 2U);
#line 356
  if (tmp___8 != 2) {
#line 357
    close(fd);
#line 358
    return ((vba_project_t *)((void *)0));
  }
#line 360
  tmp___9 = cli_readn(fd, (void *)(& LenA), 2U);
#line 360
  if (tmp___9 != 2) {
#line 361
    close(fd);
#line 362
    return ((vba_project_t *)((void *)0));
  }
#line 365
  tmp___10 = cli_readn(fd, (void *)(& UnknownB), 4U);
#line 365
  if (tmp___10 != 4) {
#line 366
    close(fd);
#line 367
    return ((vba_project_t *)((void *)0));
  }
#line 369
  tmp___11 = cli_readn(fd, (void *)(& UnknownC), 4U);
#line 369
  if (tmp___11 != 4) {
#line 370
    close(fd);
#line 371
    return ((vba_project_t *)((void *)0));
  }
#line 374
  tmp___12 = cli_readn(fd, (void *)(& LenB), 2U);
#line 374
  if (tmp___12 != 2) {
#line 375
    close(fd);
#line 376
    return ((vba_project_t *)((void *)0));
  }
#line 378
  tmp___13 = cli_readn(fd, (void *)(& LenC), 2U);
#line 378
  if (tmp___13 != 2) {
#line 379
    close(fd);
#line 380
    return ((vba_project_t *)((void *)0));
  }
#line 382
  tmp___14 = cli_readn(fd, (void *)(& LenD), 2U);
#line 382
  if (tmp___14 != 2) {
#line 383
    close(fd);
#line 384
    return ((vba_project_t *)((void *)0));
  }
#line 387
  LidA = vba_endian_convert_32(LidA, is_mac);
#line 388
  LidB = vba_endian_convert_32(LidB, is_mac);
#line 389
  CharSet = vba_endian_convert_16(CharSet, is_mac);
#line 390
  LenA = vba_endian_convert_16(LenA, is_mac);
#line 391
  LenB = vba_endian_convert_16(LenB, is_mac);
#line 392
  LenC = vba_endian_convert_16(LenC, is_mac);
#line 393
  LenD = vba_endian_convert_16(LenD, is_mac);
#line 395
  cli_dbgmsg(" LidA: %d\n LidB: %d\n CharSet: %d\n", LidA, LidB, CharSet);
#line 396
  cli_dbgmsg(" LenA: %d\n UnknownB: %d\n UnknownC: %d\n", LenA, UnknownB, UnknownC);
#line 397
  cli_dbgmsg(" LenB: %d\n LenC: %d\n LenD: %d\n", LenB, LenC, LenD);
#line 399
  record_count = LenC;
#line 401
  tmp___15 = vba_read_project_strings(fd, is_mac);
#line 401
  if (! tmp___15) {
#line 402
    close(fd);
#line 403
    return ((vba_project_t *)((void *)0));
  }
#line 407
  while (1) {
#line 408
    tmp___16 = cli_readn(fd, (void *)(& ooff), 2U);
#line 408
    if (tmp___16 != 2) {
#line 409
      close(fd);
#line 410
      return ((vba_project_t *)((void *)0));
    }
#line 407
    if (! ((int )ooff != 65535)) {
#line 407
      break;
    }
  }
#line 415
  lseek(fd, -3L, 1);
#line 416
  tmp___17 = cli_readn(fd, (void *)(& ooff), 2U);
#line 416
  if (tmp___17 != 2) {
#line 417
    close(fd);
#line 418
    return ((vba_project_t *)((void *)0));
  }
#line 420
  if ((int )ooff != 65535) {
#line 421
    lseek(fd, 1L, 1);
  }
#line 424
  tmp___18 = cli_readn(fd, (void *)(& ooff), 2U);
#line 424
  if (tmp___18 != 2) {
#line 425
    close(fd);
#line 426
    return ((vba_project_t *)((void *)0));
  }
#line 430
  if ((int )ooff != 65535) {
#line 431
    ooff = vba_endian_convert_16(ooff, is_mac);
#line 432
    lseek(fd, (long )ooff, 1);
  }
#line 434
  tmp___19 = cli_readn(fd, (void *)(& ooff), 2U);
#line 434
  if (tmp___19 != 2) {
#line 435
    close(fd);
#line 436
    return ((vba_project_t *)((void *)0));
  }
#line 438
  if ((int )ooff != 65535) {
#line 439
    ooff = vba_endian_convert_16(ooff, is_mac);
#line 440
    lseek(fd, (long )ooff, 1);
  }
#line 442
  lseek(fd, 100L, 1);
#line 444
  tmp___20 = cli_readn(fd, (void *)(& record_count), 2U);
#line 444
  if (tmp___20 != 2) {
#line 445
    close(fd);
#line 446
    return ((vba_project_t *)((void *)0));
  }
#line 448
  record_count = vba_endian_convert_16(record_count, is_mac);
#line 449
  cli_dbgmsg("\nVBA Record count: %d\n", record_count);
#line 450
  if ((int )record_count > 1000) {
#line 452
    cli_dbgmsg("\nVBA Record count too big");
#line 453
    close(fd);
#line 454
    return ((vba_project_t *)((void *)0));
  }
#line 457
  vba_project = (vba_project_t *)cli_malloc(sizeof(struct vba_project_tag ));
#line 458
  if (! vba_project) {
#line 459
    close(fd);
#line 460
    return ((vba_project_t *)((void *)0));
  }
#line 462
  vba_project->name = (char **)cli_malloc(sizeof(char *) * (unsigned int )record_count);
#line 463
  if (! vba_project->name) {
#line 464
    free((void *)vba_project);
#line 465
    close(fd);
#line 466
    return ((vba_project_t *)((void *)0));
  }
#line 468
  tmp___42 = __builtin_constant_p((int )dir);
#line 468
  if (tmp___42) {
#line 468
    if ((unsigned int )((void const   *)(dir + 1)) - (unsigned int )((void const   *)dir) ==
        1U) {
#line 468
      if ((int const   )(*(dir + 0)) == 0) {
#line 468
        vba_project->dir = (char *)calloc(1U, 1U);
      } else {
#line 468
        tmp___39 = strlen(dir);
#line 468
        __len___2 = tmp___39 + 1U;
#line 468
        tmp___40 = (char *)malloc(__len___2);
#line 468
        __retval___2 = tmp___40;
#line 468
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 468
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dir,
                                        __len___2);
        }
#line 468
        vba_project->dir = __retval___2;
      }
    } else {
#line 468
      vba_project->dir = __strdup(dir);
    }
  } else {
#line 468
    vba_project->dir = __strdup(dir);
  }
#line 469
  vba_project->offset = (uint32_t *)cli_malloc(sizeof(uint32_t ) * (unsigned int )record_count);
#line 471
  if (! vba_project->offset) {
#line 472
    free((void *)vba_project->dir);
#line 473
    free((void *)vba_project->name);
#line 474
    free((void *)vba_project);
#line 475
    close(fd);
#line 476
    return ((vba_project_t *)((void *)0));
  }
#line 478
  vba_project->count = (int )record_count;
#line 479
  i = 0;
#line 479
  while (i < (int )record_count) {
#line 480
    tmp___44 = cli_readn(fd, (void *)(& length), 2U);
#line 480
    if (tmp___44 != 2) {
      goto out_error;
    }
#line 483
    length = vba_endian_convert_16(length, is_mac);
#line 484
    if ((int )length == 0) {
#line 485
      cli_dbgmsg("zero name length\n");
      goto out_error;
    }
#line 488
    buff = (unsigned char *)cli_malloc((unsigned int )length);
#line 489
    if (! buff) {
#line 490
      cli_dbgmsg("cli_malloc failed\n");
      goto out_error;
    }
#line 493
    tmp___46 = cli_readn(fd, (void *)buff, (unsigned int )length);
#line 493
    if (tmp___46 != (int )length) {
#line 494
      cli_dbgmsg("read name failed\n");
#line 495
      free((void *)buff);
      goto out_error;
    }
#line 498
    (*(vba_project->name + i)) = get_unicode_name((char *)buff, (int )length, is_mac);
#line 499
    if (! (*(vba_project->name + i))) {
#line 500
      offset = (uint32_t )lseek(fd, 0L, 1);
#line 501
      (*(vba_project->name + i)) = (char *)cli_malloc(18U);
#line 502
      snprintf((char * __restrict  )(*(vba_project->name + i)), 18U, (char const   * __restrict  )"clamav-%.10d",
               offset);
    }
#line 504
    cli_dbgmsg("project name: %s, ", (*(vba_project->name + i)));
#line 505
    free((void *)buff);
#line 508
    tmp___48 = cli_readn(fd, (void *)(& length), 2U);
#line 508
    if (tmp___48 != 2) {
#line 509
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
#line 512
    length = vba_endian_convert_16(length, is_mac);
#line 513
    lseek(fd, (long )length, 1);
#line 516
    tmp___49 = cli_readn(fd, (void *)(& ooff), 2U);
#line 516
    if (tmp___49 != 2) {
#line 517
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
#line 520
    ooff = vba_endian_convert_16(ooff, is_mac);
#line 521
    if ((int )ooff == 65535) {
#line 522
      lseek(fd, 2L, 1);
#line 523
      tmp___50 = cli_readn(fd, (void *)(& ooff), 2U);
#line 523
      if (tmp___50 != 2) {
#line 524
        free((void *)(*(vba_project->name + i)));
        goto out_error;
      }
#line 527
      ooff = vba_endian_convert_16(ooff, is_mac);
#line 528
      lseek(fd, (long )ooff, 1);
    } else {
#line 530
      lseek(fd, (long )(2 + (int )ooff), 1);
    }
#line 533
    lseek(fd, 8L, 1);
#line 534
    tmp___51 = cli_readn(fd, (void *)(& byte_count), 2U);
#line 534
    if (tmp___51 != 2) {
#line 535
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
#line 538
    byte_count = vba_endian_convert_16(byte_count, is_mac);
#line 539
    j = 0;
#line 539
    while (j < (int )byte_count) {
#line 540
      lseek(fd, 8L, 1);
#line 539
      j ++;
    }
#line 542
    lseek(fd, 5L, 1);
#line 543
    tmp___52 = cli_readn(fd, (void *)(& offset), 4U);
#line 543
    if (tmp___52 != 4) {
#line 544
      free((void *)(*(vba_project->name + i)));
      goto out_error;
    }
#line 547
    offset = vba_endian_convert_32(offset, is_mac);
#line 548
    (*(vba_project->offset + i)) = offset;
#line 549
    cli_dbgmsg("offset:%u\n", offset);
#line 550
    lseek(fd, 2L, 1);
#line 479
    i ++;
  }
#line 558
  foffset = lseek(fd, 0L, 1);
#line 559
  cli_dbgmsg("\nOffset: 0x%x\n", (unsigned int )foffset);
#line 561
  close(fd);
#line 562
  return (vba_project);
  out_error: 
#line 567
  j = 0;
#line 567
  while (j < i) {
#line 568
    free((void *)(*(vba_project->name + j)));
#line 567
    j ++;
  }
#line 570
  free((void *)vba_project->name);
#line 571
  free((void *)vba_project->dir);
#line 572
  free((void *)vba_project->offset);
#line 573
  free((void *)vba_project);
#line 574
  close(fd);
#line 575
  return ((vba_project_t *)((void *)0));
}
}
#line 580 "vba_extract.c"
static void byte_array_append(byte_array_t *array , unsigned char *src , unsigned int len ) 
{ 

  {
#line 582
  if (array->length == 0U) {
#line 583
    array->data = (unsigned char *)cli_malloc(len);
#line 584
    if (! array->data) {
#line 585
      return;
    }
#line 587
    array->length = len;
#line 588
    memcpy((void * __restrict  )array->data, (void const   * __restrict  )src, len);
  } else {
#line 590
    array->data = (unsigned char *)realloc((void *)array->data, array->length + len);
#line 591
    if (! array->data) {
#line 592
      return;
    }
#line 594
    memcpy((void * __restrict  )(array->data + array->length), (void const   * __restrict  )src,
           len);
#line 595
    array->length += len;
  }
#line 597
  return;
}
}
#line 599 "vba_extract.c"
unsigned char *vba_decompress(int fd , uint32_t offset , int *size ) 
{ unsigned int i ;
  unsigned int pos ;
  unsigned int shift ;
  unsigned int win_pos ;
  unsigned int clean ;
  unsigned int mask ;
  unsigned int distance ;
  uint8_t flag ;
  uint16_t token ;
  uint16_t len ;
  unsigned char buffer[4096] ;
  byte_array_t result ;
  int tmp ;
  unsigned int srcpos ;
  unsigned char c ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 601
  pos = 0U;
#line 601
  clean = 1U;
#line 607
  result.length = 0U;
#line 608
  result.data = (unsigned char *)((void *)0);
#line 610
  lseek(fd, (long )(offset + 3U), 0);
#line 612
  while (1) {
#line 612
    tmp___3 = cli_readn(fd, (void *)(& flag), 1U);
#line 612
    if (! (tmp___3 == 1)) {
#line 612
      break;
    }
#line 613
    mask = 1U;
#line 613
    while (mask < 256U) {
#line 614
      if ((unsigned int )flag & mask) {
#line 615
        tmp = cli_readn(fd, (void *)(& token), 2U);
#line 615
        if (tmp != 2) {
#line 616
          if (result.data) {
#line 617
            free((void *)result.data);
          }
#line 619
          if (size) {
#line 620
            (*size) = 0;
          }
#line 622
          return ((unsigned char *)((void *)0));
        }
#line 624
        token = vba_endian_convert_16(token, 0);
#line 625
        win_pos = pos % 4096U;
#line 626
        if (win_pos <= 128U) {
#line 627
          if (win_pos <= 32U) {
#line 628
            if (win_pos <= 16U) {
#line 628
              shift = 12U;
            } else {
#line 628
              shift = 11U;
            }
          } else {
#line 630
            if (win_pos <= 64U) {
#line 630
              shift = 10U;
            } else {
#line 630
              shift = 9U;
            }
          }
        } else {
#line 633
          if (win_pos <= 512U) {
#line 634
            if (win_pos <= 256U) {
#line 634
              shift = 8U;
            } else {
#line 634
              shift = 7U;
            }
          } else {
#line 635
            if (win_pos <= 2048U) {
#line 636
              if (win_pos <= 1024U) {
#line 636
                shift = 6U;
              } else {
#line 636
                shift = 5U;
              }
            } else {
#line 638
              shift = 4U;
            }
          }
        }
#line 641
        len = (unsigned short )(((int )token & ((1 << shift) - 1)) + 3);
#line 642
        distance = (unsigned int )((int )token >> shift);
#line 643
        clean = 1U;
#line 645
        i = 0U;
#line 645
        while (i < (unsigned int )len) {
#line 649
          srcpos = ((pos - distance) - 1U) % 4096U;
#line 650
          c = buffer[srcpos];
#line 651
          tmp___0 = pos;
#line 651
          pos ++;
#line 651
          buffer[tmp___0 % 4096U] = c;
#line 645
          i ++;
        }
      } else {
#line 654
        if (pos != 0U) {
#line 654
          if (pos % 4096U == 0U) {
#line 654
            if (clean) {
#line 657
              tmp___1 = cli_readn(fd, (void *)(& token), 2U);
#line 657
              if (tmp___1 != 2) {
#line 658
                if (result.data) {
#line 659
                  free((void *)result.data);
                }
#line 661
                if (size) {
#line 662
                  (*size) = 0;
                }
#line 664
                return ((unsigned char *)((void *)0));
              }
#line 666
              clean = 0U;
#line 667
              byte_array_append(& result, buffer, 4096U);
#line 668
              break;
            }
          }
        }
#line 670
        tmp___2 = cli_readn(fd, (void *)(buffer + pos % 4096U), 1U);
#line 670
        if (tmp___2 == 1) {
#line 671
          pos ++;
        }
#line 673
        clean = 1U;
      }
#line 613
      mask <<= 1;
    }
  }
#line 678
  if (pos % 4096U) {
#line 679
    byte_array_append(& result, buffer, pos % 4096U);
  }
#line 681
  if (size) {
#line 682
    (*size) = (int )result.length;
  }
#line 684
  return (result.data);
}
}
#line 703 "vba_extract.c"
static int ppt_read_atom_header(int fd , atom_header_t *atom_header ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 705
  atom_header->foffset = lseek(fd, 0L, 1);
#line 706
  tmp = cli_readn(fd, (void *)(& atom_header->ver_inst), 2U);
#line 706
  if (tmp != 2) {
#line 707
    cli_dbgmsg("read ppt_current_user failed\n");
#line 708
    return (0);
  }
#line 710
  atom_header->ver_inst = vba_endian_convert_16(atom_header->ver_inst, 0);
#line 711
  atom_header->version = (unsigned char )((int )atom_header->ver_inst & 15);
#line 712
  atom_header->instance = (unsigned short )((int )atom_header->ver_inst >> 4);
#line 713
  tmp___0 = cli_readn(fd, (void *)(& atom_header->type), 2U);
#line 713
  if (tmp___0 != 2) {
#line 714
    cli_dbgmsg("read ppt_current_user failed\n");
#line 715
    return (0);
  }
#line 717
  tmp___1 = cli_readn(fd, (void *)(& atom_header->length), 4U);
#line 717
  if (tmp___1 != 4) {
#line 718
    cli_dbgmsg("read ppt_current_user failed\n");
#line 719
    return (0);
  }
#line 721
  atom_header->type = vba_endian_convert_16(atom_header->type, 0);
#line 722
  atom_header->length = vba_endian_convert_32(atom_header->length, 0);
#line 723
  return (1);
}
}
#line 726 "vba_extract.c"
static void ppt_print_atom_header(atom_header_t *atom_header ) 
{ 

  {
#line 728
  cli_dbgmsg("Atom Hdr:\n");
#line 729
  cli_dbgmsg("  Version: 0x%.2x\n", atom_header->version);
#line 730
  cli_dbgmsg("  Instance: 0x%.4x\n", atom_header->instance);
#line 731
  cli_dbgmsg("  Type: 0x%.4x\n", atom_header->type);
#line 732
  cli_dbgmsg("  Length: 0x%.8x\n", atom_header->length);
#line 733
  return;
}
}
#line 736 "vba_extract.c"
static int ppt_unlzw(char const   *dir , int fd , uint32_t length ) 
{ int ofd ;
  int retval ;
  unsigned char inbuff[8192] ;
  unsigned char outbuff[8192] ;
  char *fullname ;
  uint32_t bufflen ;
  z_stream stream ;
  size_t tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 744
  tmp = strlen(dir);
#line 744
  fullname = (char *)cli_malloc(tmp + 17U);
#line 745
  if (! fullname) {
#line 746
    return (0);
  }
#line 748
  tmp___0 = lseek(fd, 0L, 1);
#line 748
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/ppt%.8lx.doc",
          dir, tmp___0);
#line 750
  ofd = open((char const   *)fullname, 577, 384);
#line 751
  free((void *)fullname);
#line 752
  if (ofd == -1) {
#line 753
    cli_dbgmsg("ppt_unlzw Open outfile failed\n");
#line 754
    return (0);
  }
#line 757
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 758
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 759
  stream.opaque = (void *)0;
#line 761
  stream.next_in = inbuff;
#line 762
  if (length < 8192U) {
#line 762
    stream.avail_in = length;
  } else {
#line 762
    stream.avail_in = 8192U;
  }
#line 762
  bufflen = stream.avail_in;
#line 764
  tmp___1 = cli_readn(fd, (void *)(inbuff), stream.avail_in);
#line 764
  if ((long long )tmp___1 != (long long )stream.avail_in) {
#line 765
    close(ofd);
#line 766
    return (0);
  }
#line 768
  length -= stream.avail_in;
#line 770
  retval = inflateInit_(& stream, "1.2.2", (int )sizeof(z_stream ));
#line 771
  if (retval != 0) {
#line 772
    cli_dbgmsg(" ppt_unlzw !Z_OK: %d\n", retval);
  }
#line 775
  stream.next_out = outbuff;
#line 776
  stream.avail_out = 8192U;
#line 778
  while (1) {
#line 779
    if (stream.avail_out == 0U) {
#line 780
      tmp___2 = cli_writen(ofd, (void *)(outbuff), 8192U);
#line 780
      if (tmp___2 != 8192) {
#line 782
        close(ofd);
#line 783
        inflateEnd(& stream);
#line 784
        return (0);
      }
#line 786
      stream.next_out = outbuff;
#line 787
      stream.avail_out = 8192U;
    }
#line 789
    if (stream.avail_in == 0U) {
#line 790
      stream.next_in = inbuff;
#line 791
      if (length < 8192U) {
#line 791
        stream.avail_in = length;
      } else {
#line 791
        stream.avail_in = 8192U;
      }
#line 791
      bufflen = stream.avail_in;
#line 792
      tmp___3 = cli_readn(fd, (void *)(inbuff), stream.avail_in);
#line 792
      if ((long long )tmp___3 != (long long )stream.avail_in) {
#line 793
        close(ofd);
#line 794
        inflateEnd(& stream);
#line 795
        return (0);
      }
#line 797
      length -= stream.avail_in;
    }
#line 799
    retval = inflate(& stream, 0);
#line 778
    if (! (retval == 0)) {
#line 778
      break;
    }
  }
#line 802
  tmp___4 = cli_writen(ofd, (void *)(outbuff), bufflen);
#line 802
  if ((long long )tmp___4 != (long long )bufflen) {
#line 803
    close(ofd);
#line 804
    inflateEnd(& stream);
#line 805
    return (0);
  }
#line 807
  inflateEnd(& stream);
#line 808
  close(ofd);
#line 809
  return (1);
}
}
#line 812 "vba_extract.c"
static char *ppt_stream_iter(int fd ) 
{ atom_header_t atom_header ;
  uint32_t ole_id ;
  char *out_dir ;
  off_t offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;

  {
#line 820
  out_dir = cli_gentemp((char const   *)((void *)0));
#line 821
  tmp = mkdir((char const   *)out_dir, 448U);
#line 821
  if (tmp) {
#line 822
    printf((char const   * __restrict  )"ScanOLE2 -> Can\'t create temporary directory %s\n",
           out_dir);
#line 823
    free((void *)out_dir);
#line 824
    close(fd);
#line 825
    return ((char *)((void *)0));
  }
#line 828
  while (1) {
#line 829
    tmp___0 = ppt_read_atom_header(fd, & atom_header);
#line 829
    if (! tmp___0) {
#line 830
      break;
    }
#line 832
    ppt_print_atom_header(& atom_header);
#line 834
    if (atom_header.length == 0U) {
#line 835
      cli_rmdirs((char const   *)out_dir);
#line 836
      free((void *)out_dir);
#line 837
      return ((char *)((void *)0));
    }
#line 840
    if ((int )atom_header.type == 4113) {
#line 841
      tmp___1 = cli_readn(fd, (void *)(& ole_id), 4U);
#line 841
      if (tmp___1 != 4) {
#line 842
        cli_dbgmsg("read ole_id failed\n");
#line 843
        cli_rmdirs((char const   *)out_dir);
#line 844
        free((void *)out_dir);
#line 845
        return ((char *)((void *)0));
      }
#line 847
      ole_id = vba_endian_convert_32(ole_id, 0);
#line 848
      cli_dbgmsg("OleID: %d, length: %d\n", ole_id, atom_header.length - 4U);
#line 850
      tmp___2 = ppt_unlzw((char const   *)out_dir, fd, atom_header.length - 4U);
#line 850
      if (! tmp___2) {
#line 851
        cli_dbgmsg("ppt_unlzw failed\n");
#line 852
        cli_rmdirs((char const   *)out_dir);
#line 853
        free((void *)out_dir);
#line 854
        return ((char *)((void *)0));
      }
    } else {
#line 858
      offset = lseek(fd, 0L, 1);
#line 860
      if (offset + (long )atom_header.length < offset) {
#line 861
        break;
      }
#line 863
      offset = (long )((unsigned long )offset + (unsigned long )atom_header.length);
#line 864
      tmp___3 = lseek(fd, offset, 0);
#line 864
      if (tmp___3 != offset) {
#line 865
        break;
      }
    }
  }
#line 869
  return (out_dir);
}
}
#line 872 "vba_extract.c"
char *ppt_vba_read(char const   *dir ) 
{ char *fullname ;
  char *out_dir ;
  int fd ;
  size_t tmp ;

  {
#line 877
  tmp = strlen(dir);
#line 877
  fullname = (char *)cli_malloc(tmp + 21U);
#line 878
  if (! fullname) {
#line 879
    return ((char *)((void *)0));
  }
#line 881
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/PowerPoint Document",
          dir);
#line 882
  fd = open((char const   *)fullname, 0);
#line 883
  free((void *)fullname);
#line 884
  if (fd == -1) {
#line 885
    cli_dbgmsg("Open  PowerPoint Document failed\n");
#line 886
    return ((char *)((void *)0));
  }
#line 889
  out_dir = ppt_stream_iter(fd);
#line 890
  close(fd);
#line 891
  return (out_dir);
}
}
#line 975 "vba_extract.c"
static void wm_print_fib(mso_fib_t *fib ) 
{ 

  {
#line 977
  cli_dbgmsg("magic: 0x%.4x\n", fib->magic);
#line 978
  cli_dbgmsg("version: 0x%.4x\n", fib->version);
#line 979
  cli_dbgmsg("product: 0x%.4x\n", fib->product);
#line 980
  cli_dbgmsg("lid: 0x%.4x\n", fib->lid);
#line 981
  cli_dbgmsg("macro offset: 0x%.4x\n", fib->macro_offset);
#line 982
  cli_dbgmsg("macro len: 0x%.4x\n\n", fib->macro_len);
#line 983
  return;
}
}
#line 985 "vba_extract.c"
static int wm_read_fib(int fd , mso_fib_t *fib ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 987
  tmp = cli_readn(fd, (void *)(& fib->magic), 2U);
#line 987
  if (tmp != 2) {
#line 988
    cli_dbgmsg("read wm_fib failed\n");
#line 989
    return (0);
  }
#line 991
  tmp___0 = cli_readn(fd, (void *)(& fib->version), 2U);
#line 991
  if (tmp___0 != 2) {
#line 992
    cli_dbgmsg("read wm_fib failed\n");
#line 993
    return (0);
  }
#line 995
  tmp___1 = cli_readn(fd, (void *)(& fib->product), 2U);
#line 995
  if (tmp___1 != 2) {
#line 996
    cli_dbgmsg("read wm_fib failed\n");
#line 997
    return (0);
  }
#line 999
  tmp___2 = cli_readn(fd, (void *)(& fib->lid), 2U);
#line 999
  if (tmp___2 != 2) {
#line 1000
    cli_dbgmsg("read wm_fib failed\n");
#line 1001
    return (0);
  }
#line 1003
  tmp___3 = cli_readn(fd, (void *)(& fib->next), 2U);
#line 1003
  if (tmp___3 != 2) {
#line 1004
    cli_dbgmsg("read wm_fib failed\n");
#line 1005
    return (0);
  }
#line 1007
  tmp___4 = cli_readn(fd, (void *)(& fib->status), 2U);
#line 1007
  if (tmp___4 != 2) {
#line 1008
    cli_dbgmsg("read wm_fib failed\n");
#line 1009
    return (0);
  }
#line 1013
  tmp___5 = lseek(fd, 280L, 0);
#line 1013
  if (tmp___5 != 280L) {
#line 1014
    cli_dbgmsg("lseek wm_fib failed\n");
#line 1015
    return (0);
  }
#line 1018
  tmp___6 = cli_readn(fd, (void *)(& fib->macro_offset), 4U);
#line 1018
  if (tmp___6 != 4) {
#line 1019
    cli_dbgmsg("read wm_fib failed\n");
#line 1020
    return (0);
  }
#line 1022
  tmp___7 = cli_readn(fd, (void *)(& fib->macro_len), 4U);
#line 1022
  if (tmp___7 != 4) {
#line 1023
    cli_dbgmsg("read wm_fib failed\n");
#line 1024
    return (0);
  }
#line 1026
  fib->magic = vba_endian_convert_16(fib->magic, 0);
#line 1027
  fib->version = vba_endian_convert_16(fib->version, 0);
#line 1028
  fib->product = vba_endian_convert_16(fib->product, 0);
#line 1029
  fib->lid = vba_endian_convert_16(fib->lid, 0);
#line 1030
  fib->next = vba_endian_convert_16(fib->next, 0);
#line 1031
  fib->status = vba_endian_convert_16(fib->status, 0);
#line 1032
  fib->macro_offset = vba_endian_convert_32(fib->macro_offset, 0);
#line 1033
  fib->macro_len = vba_endian_convert_32(fib->macro_len, 0);
#line 1035
  return (1);
}
}
#line 1038 "vba_extract.c"
static int wm_read_macro_entry(int fd , macro_entry_t *macro_entry ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1040
  tmp = cli_readn(fd, (void *)(& macro_entry->version), 1U);
#line 1040
  if (tmp != 1) {
#line 1041
    cli_dbgmsg("read macro_entry failed\n");
#line 1042
    return (0);
  }
#line 1044
  tmp___0 = cli_readn(fd, (void *)(& macro_entry->key), 1U);
#line 1044
  if (tmp___0 != 1) {
#line 1045
    cli_dbgmsg("read macro_entry failed\n");
#line 1046
    return (0);
  }
#line 1048
  tmp___1 = cli_readn(fd, (void *)(& macro_entry->intname_i), 2U);
#line 1048
  if (tmp___1 != 2) {
#line 1049
    cli_dbgmsg("read macro_entry failed\n");
#line 1050
    return (0);
  }
#line 1052
  tmp___2 = cli_readn(fd, (void *)(& macro_entry->extname_i), 2U);
#line 1052
  if (tmp___2 != 2) {
#line 1053
    cli_dbgmsg("read macro_entry failed\n");
#line 1054
    return (0);
  }
#line 1056
  tmp___3 = cli_readn(fd, (void *)(& macro_entry->xname_i), 2U);
#line 1056
  if (tmp___3 != 2) {
#line 1057
    cli_dbgmsg("read macro_entry failed\n");
#line 1058
    return (0);
  }
#line 1060
  tmp___4 = cli_readn(fd, (void *)(& macro_entry->unknown), 4U);
#line 1060
  if (tmp___4 != 4) {
#line 1061
    cli_dbgmsg("read macro_entry failed\n");
#line 1062
    return (0);
  }
#line 1064
  tmp___5 = cli_readn(fd, (void *)(& macro_entry->len), 4U);
#line 1064
  if (tmp___5 != 4) {
#line 1065
    cli_dbgmsg("read macro_entry failed\n");
#line 1066
    return (0);
  }
#line 1068
  tmp___6 = cli_readn(fd, (void *)(& macro_entry->state), 4U);
#line 1068
  if (tmp___6 != 4) {
#line 1069
    cli_dbgmsg("read macro_entry failed\n");
#line 1070
    return (0);
  }
#line 1072
  tmp___7 = cli_readn(fd, (void *)(& macro_entry->offset), 4U);
#line 1072
  if (tmp___7 != 4) {
#line 1073
    cli_dbgmsg("read macro_entry failed\n");
#line 1074
    return (0);
  }
#line 1077
  macro_entry->intname_i = vba_endian_convert_16(macro_entry->intname_i, 0);
#line 1078
  macro_entry->extname_i = vba_endian_convert_16(macro_entry->extname_i, 0);
#line 1079
  macro_entry->xname_i = vba_endian_convert_16(macro_entry->xname_i, 0);
#line 1080
  macro_entry->len = vba_endian_convert_32(macro_entry->len, 0);
#line 1081
  macro_entry->state = vba_endian_convert_32(macro_entry->state, 0);
#line 1082
  macro_entry->offset = vba_endian_convert_32(macro_entry->offset, 0);
#line 1083
  return (1);
}
}
#line 1086 "vba_extract.c"
static macro_info_t *wm_read_macro_info(int fd ) 
{ int i ;
  macro_info_t *macro_info ;
  int tmp___0 ;
  int tmp___2 ;

  {
#line 1091
  macro_info = (macro_info_t *)cli_malloc(sizeof(macro_info_t ));
#line 1092
  if (! macro_info) {
#line 1093
    return ((macro_info_t *)((void *)0));
  }
#line 1095
  tmp___0 = cli_readn(fd, (void *)(& macro_info->count), 2U);
#line 1095
  if (tmp___0 != 2) {
#line 1096
    cli_dbgmsg("read macro_info failed\n");
#line 1097
    return ((macro_info_t *)((void *)0));
  }
#line 1099
  macro_info->count = vba_endian_convert_16(macro_info->count, 0);
#line 1100
  cli_dbgmsg("macro count: %d\n", macro_info->count);
#line 1101
  macro_info->macro_entry = (struct macro_entry_tag *)cli_malloc(sizeof(macro_entry_t ) *
                                                                 (unsigned int )macro_info->count);
#line 1103
  if (! macro_info->macro_entry) {
#line 1104
    free((void *)macro_info);
#line 1105
    return ((macro_info_t *)((void *)0));
  }
#line 1107
  i = 0;
#line 1107
  while (i < (int )macro_info->count) {
#line 1108
    tmp___2 = wm_read_macro_entry(fd, macro_info->macro_entry + i);
#line 1108
    if (! tmp___2) {
#line 1110
      free((void *)macro_info->macro_entry);
#line 1111
      free((void *)macro_info);
#line 1112
      return ((macro_info_t *)((void *)0));
    }
#line 1107
    i ++;
  }
#line 1115
  return (macro_info);
}
}
#line 1118 "vba_extract.c"
static void wm_free_macro_info(macro_info_t *macro_info ) 
{ 

  {
#line 1120
  if (macro_info) {
#line 1121
    free((void *)macro_info->macro_entry);
#line 1122
    free((void *)macro_info);
  }
#line 1124
  return;
}
}
#line 1127 "vba_extract.c"
static int wm_read_oxo3(int fd ) 
{ uint8_t count ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __off_t tmp___4 ;

  {
#line 1131
  tmp = cli_readn(fd, (void *)(& count), 1U);
#line 1131
  if (tmp != 1) {
#line 1132
    cli_dbgmsg("read oxo3 record1 failed\n");
#line 1133
    return (0);
  }
#line 1135
  tmp___0 = lseek(fd, (long )((int )count * 14), 1);
#line 1135
  if (tmp___0 == -1L) {
#line 1136
    cli_dbgmsg("lseek oxo3 record1 failed\n");
#line 1137
    return (0);
  }
#line 1139
  cli_dbgmsg("oxo3 records1: %d\n", count);
#line 1141
  tmp___1 = cli_readn(fd, (void *)(& count), 1U);
#line 1141
  if (tmp___1 != 1) {
#line 1142
    cli_dbgmsg("read oxo3 record2 failed\n");
#line 1143
    return (0);
  }
#line 1145
  if ((int )count == 0) {
#line 1146
    tmp___2 = cli_readn(fd, (void *)(& count), 1U);
#line 1146
    if (tmp___2 != 1) {
#line 1147
      cli_dbgmsg("read oxo3 failed\n");
#line 1148
      return (0);
    }
#line 1150
    if ((int )count != 2) {
#line 1151
      lseek(fd, -1L, 1);
#line 1152
      return (1);
    }
#line 1154
    tmp___3 = cli_readn(fd, (void *)(& count), 1U);
#line 1154
    if (tmp___3 != 1) {
#line 1155
      cli_dbgmsg("read oxo3 failed\n");
#line 1156
      return (0);
    }
  }
#line 1159
  if ((int )count > 0) {
#line 1160
    tmp___4 = lseek(fd, (long )((int )count * 4 + 1), 1);
#line 1160
    if (tmp___4 == -1L) {
#line 1161
      cli_dbgmsg("lseek oxo3 failed\n");
#line 1162
      return (0);
    }
  }
#line 1165
  cli_dbgmsg("oxo3 records2: %d\n", count);
#line 1166
  return (1);
}
}
#line 1169 "vba_extract.c"
static menu_info_t *wm_read_menu_info(int fd ) 
{ int i ;
  menu_info_t *menu_info ;
  menu_entry_t *menu_entry ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1175
  menu_info = (menu_info_t *)cli_malloc(sizeof(menu_info_t ));
#line 1176
  if (! menu_info) {
#line 1177
    return ((menu_info_t *)((void *)0));
  }
#line 1180
  tmp___0 = cli_readn(fd, (void *)(& menu_info->count), 2U);
#line 1180
  if (tmp___0 != 2) {
#line 1181
    cli_dbgmsg("read menu_info failed\n");
#line 1182
    free((void *)menu_info);
#line 1183
    return ((menu_info_t *)((void *)0));
  }
#line 1185
  menu_info->count = vba_endian_convert_16(menu_info->count, 0);
#line 1186
  cli_dbgmsg("menu_info count: %d\n", menu_info->count);
#line 1188
  menu_info->menu_entry = (struct menu_entry_tag *)cli_malloc(sizeof(menu_entry_t ) *
                                                              (unsigned int )menu_info->count);
#line 1190
  if (! menu_info->menu_entry) {
#line 1191
    free((void *)menu_info);
#line 1192
    return ((menu_info_t *)((void *)0));
  }
#line 1195
  i = 0;
#line 1195
  while (i < (int )menu_info->count) {
#line 1196
    menu_entry = menu_info->menu_entry + i;
#line 1197
    tmp___2 = cli_readn(fd, (void *)(& menu_entry->context), 2U);
#line 1197
    if (tmp___2 != 2) {
      goto abort;
    }
#line 1200
    tmp___3 = cli_readn(fd, (void *)(& menu_entry->menu), 2U);
#line 1200
    if (tmp___3 != 2) {
      goto abort;
    }
#line 1203
    tmp___4 = cli_readn(fd, (void *)(& menu_entry->extname_i), 2U);
#line 1203
    if (tmp___4 != 2) {
      goto abort;
    }
#line 1206
    tmp___5 = cli_readn(fd, (void *)(& menu_entry->unknown), 2U);
#line 1206
    if (tmp___5 != 2) {
      goto abort;
    }
#line 1209
    tmp___6 = cli_readn(fd, (void *)(& menu_entry->intname_i), 2U);
#line 1209
    if (tmp___6 != 2) {
      goto abort;
    }
#line 1212
    tmp___7 = cli_readn(fd, (void *)(& menu_entry->pos), 2U);
#line 1212
    if (tmp___7 != 2) {
      goto abort;
    }
#line 1215
    menu_entry->context = vba_endian_convert_16(menu_entry->context, 0);
#line 1216
    menu_entry->menu = vba_endian_convert_16(menu_entry->menu, 0);
#line 1217
    menu_entry->extname_i = vba_endian_convert_16(menu_entry->extname_i, 0);
#line 1218
    menu_entry->intname_i = vba_endian_convert_16(menu_entry->intname_i, 0);
#line 1219
    menu_entry->pos = vba_endian_convert_16(menu_entry->pos, 0);
#line 1220
    cli_dbgmsg("menu entry: %d.%d\n", menu_entry->menu, menu_entry->pos);
#line 1195
    i ++;
  }
#line 1222
  return (menu_info);
  abort: 
#line 1225
  cli_dbgmsg("read menu_entry failed\n");
#line 1226
  free((void *)menu_info->menu_entry);
#line 1227
  free((void *)menu_info);
#line 1228
  return ((menu_info_t *)((void *)0));
}
}
#line 1231 "vba_extract.c"
static void wm_free_menu_info(menu_info_t *menu_info ) 
{ 

  {
#line 1233
  if (menu_info) {
#line 1234
    free((void *)menu_info->menu_entry);
#line 1235
    free((void *)menu_info);
  }
#line 1237
  return;
}
}
#line 1240 "vba_extract.c"
static macro_extnames_t *wm_read_macro_extnames(int fd ) 
{ int i ;
  int is_unicode ;
  int16_t size ;
  off_t offset_end ;
  macro_extnames_t *macro_extnames ;
  macro_extname_t *macro_extname ;
  unsigned char *name_tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___21 ;
  size_t __len___2 ;
  size_t tmp___22 ;
  char *__retval___2 ;
  char *tmp___23 ;
  int tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  void *tmp___44 ;
  size_t __len___6 ;
  size_t tmp___45 ;
  char *__retval___6 ;
  char *tmp___46 ;
  int tmp___48 ;
  int tmp___49 ;
  __off_t tmp___50 ;

  {
#line 1242
  is_unicode = 0;
#line 1249
  macro_extnames = (macro_extnames_t *)cli_malloc(sizeof(macro_extnames_t ));
#line 1250
  if (! macro_extnames) {
#line 1251
    return ((macro_extnames_t *)((void *)0));
  }
#line 1253
  macro_extnames->count = (unsigned short)0;
#line 1254
  macro_extnames->macro_extname = (struct macro_extname_tag *)((void *)0);
#line 1256
  offset_end = lseek(fd, 0L, 1);
#line 1257
  tmp___0 = cli_readn(fd, (void *)(& size), 2U);
#line 1257
  if (tmp___0 != 2) {
#line 1258
    cli_dbgmsg("read macro_extnames failed\n");
#line 1259
    free((void *)macro_extnames);
#line 1260
    return ((macro_extnames_t *)((void *)0));
  }
#line 1262
  size = (int16_t )vba_endian_convert_16((unsigned short )size, 0);
#line 1263
  if ((int )size == -1) {
#line 1264
    is_unicode = 1;
#line 1265
    tmp___1 = cli_readn(fd, (void *)(& size), 2U);
#line 1265
    if (tmp___1 != 2) {
#line 1266
      cli_dbgmsg("read macro_extnames failed\n");
#line 1267
      free((void *)macro_extnames);
#line 1268
      return ((macro_extnames_t *)((void *)0));
    }
#line 1270
    size = (int16_t )vba_endian_convert_16((unsigned short )size, 0);
  }
#line 1272
  cli_dbgmsg("ext names size: 0x%x\n", size);
#line 1274
  offset_end += (long )size;
#line 1275
  while (1) {
#line 1275
    tmp___50 = lseek(fd, 0L, 1);
#line 1275
    if (! (tmp___50 < offset_end)) {
#line 1275
      break;
    }
#line 1276
    macro_extnames->count = (unsigned short )((int )macro_extnames->count + 1);
#line 1277
    macro_extnames->macro_extname = (struct macro_extname_tag *)cli_realloc((void *)macro_extnames->macro_extname,
                                                                            sizeof(macro_extname_t ) *
                                                                            (unsigned int )macro_extnames->count);
#line 1280
    if ((unsigned int )macro_extnames->macro_extname == (unsigned int )((void *)0)) {
#line 1281
      cli_dbgmsg("read macro_extnames failed\n");
      goto abort;
    }
#line 1285
    macro_extname = macro_extnames->macro_extname + ((int )macro_extnames->count -
                                                     1);
#line 1286
    if (is_unicode) {
#line 1287
      tmp___3 = cli_readn(fd, (void *)(& macro_extname->length), 1U);
#line 1287
      if (tmp___3 != 1) {
#line 1288
        cli_dbgmsg("read macro_extnames failed\n");
        goto abort;
      }
#line 1291
      lseek(fd, 1L, 1);
#line 1292
      if ((int )macro_extname->length > 0) {
#line 1293
        tmp___4 = cli_malloc((unsigned int )((int )macro_extname->length * 2));
#line 1293
        name_tmp = (unsigned char *)((char *)tmp___4);
#line 1294
        if ((unsigned int )name_tmp == (unsigned int )((void *)0)) {
          goto abort;
        }
#line 1297
        tmp___5 = cli_readn(fd, (void *)name_tmp, (unsigned int )((int )macro_extname->length *
                                                                  2));
#line 1297
        if (tmp___5 != (int )macro_extname->length * 2) {
#line 1299
          cli_dbgmsg("read macro_extnames failed\n");
#line 1300
          free((void *)name_tmp);
          goto abort;
        }
#line 1303
        macro_extname->extname = (unsigned char *)get_unicode_name((char *)name_tmp,
                                                                   (int )macro_extname->length *
                                                                   2, 0);
#line 1305
        free((void *)name_tmp);
      } else {
#line 1307
        tmp___25 = __builtin_constant_p((int )"[no name]");
#line 1307
        if (tmp___25) {
#line 1307
          if ((unsigned int )((void const   *)("[no name]" + 1)) - (unsigned int )((void const   *)"[no name]") ==
              1U) {
#line 1307
            if ((int const   )(*("[no name]" + 0)) == 0) {
#line 1307
              tmp___21 = calloc(1U, 1U);
#line 1307
              macro_extname->extname = (unsigned char *)((char *)tmp___21);
            } else {
#line 1307
              tmp___22 = strlen("[no name]");
#line 1307
              __len___2 = tmp___22 + 1U;
#line 1307
              tmp___23 = (char *)malloc(__len___2);
#line 1307
              __retval___2 = tmp___23;
#line 1307
              if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1307
                __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )"[no name]",
                                              __len___2);
              }
#line 1307
              macro_extname->extname = (unsigned char *)__retval___2;
            }
          } else {
#line 1307
            macro_extname->extname = (unsigned char *)__strdup("[no name]");
          }
        } else {
#line 1307
          macro_extname->extname = (unsigned char *)__strdup("[no name]");
        }
#line 1308
        macro_extname->length = (unsigned char)10;
      }
    } else {
#line 1311
      tmp___26 = cli_readn(fd, (void *)(& macro_extname->length), 1U);
#line 1311
      if (tmp___26 != 1) {
#line 1312
        cli_dbgmsg("read macro_extnames failed\n");
        goto abort;
      }
#line 1315
      if ((int )macro_extname->length > 0) {
#line 1316
        tmp___27 = cli_malloc((unsigned int )((int )macro_extname->length + 1));
#line 1316
        macro_extname->extname = (unsigned char *)((char *)tmp___27);
#line 1317
        if (! macro_extname->extname) {
          goto abort;
        }
#line 1320
        tmp___28 = cli_readn(fd, (void *)macro_extname->extname, (unsigned int )macro_extname->length);
#line 1320
        if (tmp___28 != (int )macro_extname->length) {
#line 1322
          cli_dbgmsg("read macro_extnames failed\n");
#line 1323
          free((void *)macro_extname->extname);
          goto abort;
        }
#line 1326
        (*(macro_extname->extname + (int )macro_extname->length)) = (unsigned char )'\000';
      } else {
#line 1328
        tmp___48 = __builtin_constant_p((int )"[no name]");
#line 1328
        if (tmp___48) {
#line 1328
          if ((unsigned int )((void const   *)("[no name]" + 1)) - (unsigned int )((void const   *)"[no name]") ==
              1U) {
#line 1328
            if ((int const   )(*("[no name]" + 0)) == 0) {
#line 1328
              tmp___44 = calloc(1U, 1U);
#line 1328
              macro_extname->extname = (unsigned char *)((char *)tmp___44);
            } else {
#line 1328
              tmp___45 = strlen("[no name]");
#line 1328
              __len___6 = tmp___45 + 1U;
#line 1328
              tmp___46 = (char *)malloc(__len___6);
#line 1328
              __retval___6 = tmp___46;
#line 1328
              if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 1328
                __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"[no name]",
                                              __len___6);
              }
#line 1328
              macro_extname->extname = (unsigned char *)__retval___6;
            }
          } else {
#line 1328
            macro_extname->extname = (unsigned char *)__strdup("[no name]");
          }
        } else {
#line 1328
          macro_extname->extname = (unsigned char *)__strdup("[no name]");
        }
#line 1329
        macro_extname->length = (unsigned char)10;
      }
    }
#line 1332
    tmp___49 = cli_readn(fd, (void *)(& macro_extname->numref), 2U);
#line 1332
    if (tmp___49 != 2) {
#line 1333
      cli_dbgmsg("read macro_extnames failed\n");
#line 1334
      return ((macro_extnames_t *)((void *)0));
    }
#line 1336
    macro_extname->numref = vba_endian_convert_16(macro_extname->numref, 0);
#line 1337
    cli_dbgmsg("ext name: %s\n", macro_extname->extname);
  }
#line 1339
  return (macro_extnames);
  abort: 
#line 1342
  if ((unsigned int )macro_extnames->macro_extname != (unsigned int )((void *)0)) {
#line 1343
    i = 0;
#line 1343
    while (i < (int )macro_extnames->count - 1) {
#line 1344
      free((void *)(macro_extnames->macro_extname + i)->extname);
#line 1343
      i ++;
    }
#line 1346
    free((void *)macro_extnames->macro_extname);
  }
#line 1348
  free((void *)macro_extnames);
#line 1349
  return ((macro_extnames_t *)((void *)0));
}
}
#line 1352 "vba_extract.c"
static void wm_free_extnames(macro_extnames_t *macro_extnames ) 
{ int i ;

  {
#line 1356
  if (macro_extnames) {
#line 1357
    i = 0;
#line 1357
    while (i < (int )macro_extnames->count) {
#line 1358
      free((void *)(macro_extnames->macro_extname + i)->extname);
#line 1357
      i ++;
    }
#line 1360
    free((void *)macro_extnames->macro_extname);
#line 1361
    free((void *)macro_extnames);
  }
#line 1363
  return;
}
}
#line 1366 "vba_extract.c"
static macro_intnames_t *wm_read_macro_intnames(int fd ) 
{ int i ;
  macro_intnames_t *macro_intnames ;
  macro_intname_t *macro_intname ;
  uint16_t junk ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1373
  macro_intnames = (macro_intnames_t *)cli_malloc(sizeof(macro_intnames_t ));
#line 1374
  if (! macro_intnames) {
#line 1375
    return ((macro_intnames_t *)((void *)0));
  }
#line 1378
  tmp___0 = cli_readn(fd, (void *)(& macro_intnames->count), 2U);
#line 1378
  if (tmp___0 != 2) {
#line 1379
    cli_dbgmsg("read macro_intnames failed\n");
#line 1380
    return ((macro_intnames_t *)((void *)0));
  }
#line 1382
  macro_intnames->count = vba_endian_convert_16(macro_intnames->count, 0);
#line 1383
  cli_dbgmsg("int names count: %d\n", macro_intnames->count);
#line 1385
  macro_intnames->macro_intname = (struct macro_intname_tag *)cli_malloc(sizeof(macro_intname_t ) *
                                                                         (unsigned int )macro_intnames->count);
#line 1387
  if (! macro_intnames->macro_intname) {
#line 1388
    free((void *)macro_intnames);
#line 1389
    return ((macro_intnames_t *)((void *)0));
  }
#line 1391
  i = 0;
#line 1391
  while (i < (int )macro_intnames->count) {
#line 1392
    macro_intname = macro_intnames->macro_intname + i;
#line 1393
    tmp___2 = cli_readn(fd, (void *)(& macro_intname->id), 2U);
#line 1393
    if (tmp___2 != 2) {
#line 1394
      cli_dbgmsg("read macro_intnames failed\n");
#line 1395
      macro_intnames->count = (unsigned short )i;
      goto abort;
    }
#line 1398
    macro_intname->id = vba_endian_convert_16(macro_intname->id, 0);
#line 1399
    tmp___3 = cli_readn(fd, (void *)(& macro_intname->length), 1U);
#line 1399
    if (tmp___3 != 1) {
#line 1400
      cli_dbgmsg("read macro_intnames failed\n");
#line 1401
      macro_intnames->count = (unsigned short )i;
      goto abort;
    }
#line 1404
    tmp___4 = cli_malloc((unsigned int )((int )macro_intname->length + 1));
#line 1404
    macro_intname->intname = (unsigned char *)((char *)tmp___4);
#line 1405
    if (! macro_intname->intname) {
#line 1406
      macro_intnames->count = (unsigned short )i;
      goto abort;
    }
#line 1409
    tmp___5 = cli_readn(fd, (void *)macro_intname->intname, (unsigned int )macro_intname->length);
#line 1409
    if (tmp___5 != (int )macro_intname->length) {
#line 1410
      cli_dbgmsg("read macro_intnames failed\n");
#line 1411
      macro_intnames->count = (unsigned short )(i + 1);
      goto abort;
    }
#line 1414
    (*(macro_intname->intname + (int )macro_intname->length)) = (unsigned char )'\000';
#line 1415
    tmp___6 = cli_readn(fd, (void *)(& junk), 1U);
#line 1415
    if (tmp___6 != 1) {
#line 1416
      cli_dbgmsg("read macro_intnames failed\n");
#line 1417
      macro_intnames->count = (unsigned short )(i + 1);
      goto abort;
    }
#line 1420
    cli_dbgmsg("int name: %s\n", macro_intname->intname);
#line 1391
    i ++;
  }
#line 1422
  return (macro_intnames);
  abort: 
#line 1424
  i = 0;
#line 1424
  while (i < (int )macro_intnames->count) {
#line 1425
    free((void *)(macro_intnames->macro_intname + i)->intname);
#line 1424
    i ++;
  }
#line 1427
  free((void *)macro_intnames->macro_intname);
#line 1428
  free((void *)macro_intnames);
#line 1429
  return ((macro_intnames_t *)((void *)0));
}
}
#line 1432 "vba_extract.c"
static void wm_free_intnames(macro_intnames_t *macro_intnames ) 
{ int i ;

  {
#line 1436
  if (macro_intnames) {
#line 1437
    i = 0;
#line 1437
    while (i < (int )macro_intnames->count) {
#line 1438
      free((void *)(macro_intnames->macro_intname + i)->intname);
#line 1437
      i ++;
    }
#line 1440
    free((void *)macro_intnames->macro_intname);
#line 1441
    free((void *)macro_intnames);
  }
#line 1443
  return;
}
}
#line 1446 "vba_extract.c"
vba_project_t *wm_dir_read(char const   *dir ) 
{ int fd ;
  int done ;
  int i ;
  mso_fib_t fib ;
  off_t end_offset ;
  unsigned char start_id ;
  unsigned char info_id ;
  macro_info_t *macro_info ;
  menu_info_t *menu_info ;
  macro_extnames_t *macro_extnames ;
  macro_intnames_t *macro_intnames ;
  vba_project_t *vba_project ;
  char *fullname ;
  size_t tmp ;
  int tmp___1 ;
  __off_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  size_t __len___2 ;
  size_t tmp___25 ;
  char *__retval___2 ;
  char *tmp___26 ;
  int tmp___28 ;
  size_t __len___6 ;
  size_t tmp___48 ;
  char *__retval___6 ;
  char *tmp___49 ;
  int tmp___51 ;

  {
#line 1448
  done = 0;
#line 1452
  macro_info = (macro_info_t *)((void *)0);
#line 1453
  menu_info = (menu_info_t *)((void *)0);
#line 1454
  macro_extnames = (macro_extnames_t *)((void *)0);
#line 1455
  macro_intnames = (macro_intnames_t *)((void *)0);
#line 1456
  vba_project = (vba_project_t *)((void *)0);
#line 1459
  tmp = strlen(dir);
#line 1459
  fullname = (char *)cli_malloc(tmp + 14U);
#line 1460
  if (! fullname) {
#line 1461
    return ((vba_project_t *)((void *)0));
  }
#line 1463
  sprintf((char * __restrict  )fullname, (char const   * __restrict  )"%s/WordDocument",
          dir);
#line 1464
  fd = open((char const   *)fullname, 0);
#line 1465
  free((void *)fullname);
#line 1466
  if (fd == -1) {
#line 1467
    cli_dbgmsg("Open WordDocument failed\n");
#line 1468
    return ((vba_project_t *)((void *)0));
  }
#line 1471
  tmp___1 = wm_read_fib(fd, & fib);
#line 1471
  if (! tmp___1) {
#line 1472
    close(fd);
#line 1473
    return ((vba_project_t *)((void *)0));
  }
#line 1475
  wm_print_fib(& fib);
#line 1477
  tmp___2 = lseek(fd, (long )fib.macro_offset, 0);
#line 1477
  if ((long long )tmp___2 != (long long )fib.macro_offset) {
#line 1478
    cli_dbgmsg("lseek macro_offset failed\n");
#line 1479
    close(fd);
#line 1480
    return ((vba_project_t *)((void *)0));
  }
#line 1483
  end_offset = (long )(fib.macro_offset + fib.macro_len);
#line 1485
  tmp___3 = cli_readn(fd, (void *)(& start_id), 1U);
#line 1485
  if (tmp___3 != 1) {
#line 1486
    cli_dbgmsg("read start_id failed\n");
#line 1487
    close(fd);
#line 1488
    return ((vba_project_t *)((void *)0));
  }
#line 1490
  cli_dbgmsg("start_id: %d\n", start_id);
#line 1492
  while (1) {
#line 1492
    tmp___6 = lseek(fd, 0L, 1);
#line 1492
    if (tmp___6 < end_offset) {
#line 1492
      if (! (! done)) {
#line 1492
        break;
      }
    } else {
#line 1492
      break;
    }
#line 1493
    tmp___4 = cli_readn(fd, (void *)(& info_id), 1U);
#line 1493
    if (tmp___4 != 1) {
#line 1494
      cli_dbgmsg("read macro_info failed\n");
#line 1495
      close(fd);
#line 1496
      return ((vba_project_t *)((void *)0));
    }
#line 1498
    switch ((int )info_id) {
    case 1: 
#line 1500
    macro_info = wm_read_macro_info(fd);
#line 1501
    if ((unsigned int )macro_info == (unsigned int )((void *)0)) {
#line 1502
      done = 1;
    }
#line 1504
    break;
    case 3: 
#line 1506
    tmp___5 = wm_read_oxo3(fd);
#line 1506
    if (! tmp___5) {
#line 1507
      done = 1;
    }
#line 1509
    break;
    case 5: 
#line 1511
    menu_info = wm_read_menu_info(fd);
#line 1512
    if ((unsigned int )menu_info == (unsigned int )((void *)0)) {
#line 1513
      done = 1;
    }
#line 1515
    break;
    case 16: 
#line 1517
    macro_extnames = wm_read_macro_extnames(fd);
#line 1518
    if ((unsigned int )macro_extnames == (unsigned int )((void *)0)) {
#line 1519
      done = 1;
    }
#line 1521
    break;
    case 17: 
#line 1523
    macro_intnames = wm_read_macro_intnames(fd);
#line 1524
    if ((unsigned int )macro_intnames == (unsigned int )((void *)0)) {
#line 1525
      done = 1;
    }
#line 1527
    break;
    case 18: 
#line 1532
    done = 1;
#line 1533
    break;
    case 64: 
#line 1536
    done = 1;
#line 1537
    break;
    default: 
#line 1539
    cli_dbgmsg("\nunknown type: 0x%x\n", info_id);
#line 1540
    done = 1;
    }
  }
#line 1544
  if (macro_info) {
#line 1545
    vba_project = (vba_project_t *)cli_malloc(sizeof(struct vba_project_tag ));
#line 1546
    if (! vba_project) {
      goto abort;
    }
#line 1549
    vba_project->name = (char **)cli_malloc(sizeof(char *) * (unsigned int )macro_info->count);
#line 1550
    if (! vba_project->name) {
#line 1551
      free((void *)vba_project);
#line 1552
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
#line 1555
    tmp___28 = __builtin_constant_p((int )dir);
#line 1555
    if (tmp___28) {
#line 1555
      if ((unsigned int )((void const   *)(dir + 1)) - (unsigned int )((void const   *)dir) ==
          1U) {
#line 1555
        if ((int const   )(*(dir + 0)) == 0) {
#line 1555
          vba_project->dir = (char *)calloc(1U, 1U);
        } else {
#line 1555
          tmp___25 = strlen(dir);
#line 1555
          __len___2 = tmp___25 + 1U;
#line 1555
          tmp___26 = (char *)malloc(__len___2);
#line 1555
          __retval___2 = tmp___26;
#line 1555
          if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 1555
            __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )dir,
                                          __len___2);
          }
#line 1555
          vba_project->dir = __retval___2;
        }
      } else {
#line 1555
        vba_project->dir = __strdup(dir);
      }
    } else {
#line 1555
      vba_project->dir = __strdup(dir);
    }
#line 1556
    vba_project->offset = (uint32_t *)cli_malloc(sizeof(uint32_t ) * (unsigned int )macro_info->count);
#line 1558
    if (! vba_project->offset) {
#line 1559
      free((void *)vba_project->name);
#line 1560
      free((void *)vba_project->dir);
#line 1561
      free((void *)vba_project);
#line 1562
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
#line 1565
    vba_project->length = (uint32_t *)cli_malloc(sizeof(uint32_t ) * (unsigned int )macro_info->count);
#line 1567
    if (! vba_project->length) {
#line 1568
      free((void *)vba_project->offset);
#line 1569
      free((void *)vba_project->name);
#line 1570
      free((void *)vba_project->dir);
#line 1571
      free((void *)vba_project);
#line 1572
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
#line 1575
    vba_project->key = (unsigned char *)cli_malloc(sizeof(unsigned char ) * (unsigned int )macro_info->count);
#line 1577
    if (! vba_project->key) {
#line 1578
      free((void *)vba_project->length);
#line 1579
      free((void *)vba_project->offset);
#line 1580
      free((void *)vba_project->name);
#line 1581
      free((void *)vba_project->dir);
#line 1582
      free((void *)vba_project);
#line 1583
      vba_project = (vba_project_t *)((void *)0);
      goto abort;
    }
#line 1586
    vba_project->count = (int )macro_info->count;
#line 1587
    i = 0;
#line 1587
    while (i < (int )macro_info->count) {
#line 1588
      tmp___51 = __builtin_constant_p((int )"WordDocument");
#line 1588
      if (tmp___51) {
#line 1588
        if ((unsigned int )((void const   *)("WordDocument" + 1)) - (unsigned int )((void const   *)"WordDocument") ==
            1U) {
#line 1588
          if ((int const   )(*("WordDocument" + 0)) == 0) {
#line 1588
            (*(vba_project->name + i)) = (char *)calloc(1U, 1U);
          } else {
#line 1588
            tmp___48 = strlen("WordDocument");
#line 1588
            __len___6 = tmp___48 + 1U;
#line 1588
            tmp___49 = (char *)malloc(__len___6);
#line 1588
            __retval___6 = tmp___49;
#line 1588
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 1588
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"WordDocument",
                                            __len___6);
            }
#line 1588
            (*(vba_project->name + i)) = __retval___6;
          }
        } else {
#line 1588
          (*(vba_project->name + i)) = __strdup("WordDocument");
        }
      } else {
#line 1588
        (*(vba_project->name + i)) = __strdup("WordDocument");
      }
#line 1589
      (*(vba_project->offset + i)) = (macro_info->macro_entry + i)->offset;
#line 1590
      (*(vba_project->length + i)) = (macro_info->macro_entry + i)->len;
#line 1591
      (*(vba_project->key + i)) = (macro_info->macro_entry + i)->key;
#line 1587
      i ++;
    }
  }
  abort: 
#line 1596
  if (macro_info) {
#line 1597
    wm_free_macro_info(macro_info);
  }
#line 1599
  if (menu_info) {
#line 1600
    wm_free_menu_info(menu_info);
  }
#line 1602
  if (macro_extnames) {
#line 1603
    wm_free_extnames(macro_extnames);
  }
#line 1605
  if (macro_intnames) {
#line 1606
    wm_free_intnames(macro_intnames);
  }
#line 1608
  close(fd);
#line 1609
  return (vba_project);
}
}
#line 1612 "vba_extract.c"
unsigned char *wm_decrypt_macro(int fd , uint32_t offset , uint32_t len , unsigned char key ) 
{ unsigned char *buff ;
  uint32_t i ;
  __off_t tmp ;
  int tmp___1 ;

  {
#line 1618
  tmp = lseek(fd, (long )offset, 0);
#line 1618
  if ((long long )tmp != (long long )offset) {
#line 1619
    return ((unsigned char *)((void *)0));
  }
#line 1621
  buff = (unsigned char *)cli_malloc(len);
#line 1622
  if (! buff) {
#line 1623
    return ((unsigned char *)((void *)0));
  }
#line 1626
  tmp___1 = cli_readn(fd, (void *)buff, len);
#line 1626
  if ((long long )tmp___1 != (long long )len) {
#line 1627
    free((void *)buff);
#line 1628
    return ((unsigned char *)((void *)0));
  }
#line 1630
  if ((int )key != 0) {
#line 1631
    i = 0U;
#line 1631
    while (i < len) {
#line 1632
      (*(buff + i)) = (unsigned char )((int )(*(buff + i)) ^ (int )key);
#line 1631
      i ++;
    }
  }
#line 1635
  return (buff);
}
}
#line 1 "msexpand.lo"
#pragma merger(0,"/tmp/cil-TsTYMxSq.i","-g -O2 -fPIC")
#line 437 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 35 "msexpand.c"
int cli_msexpand(FILE *in , FILE *out ) 
{ int bits ;
  int ch ;
  int i ;
  int j ;
  int len ;
  int mask ;
  unsigned char *buffer ;
  uint32_t magic1 ;
  uint32_t magic2 ;
  uint32_t magic3 ;
  uint32_t filesize ;
  uint16_t reserved ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
#line 43
  tmp = fread((void * __restrict  )(& magic1), sizeof(magic1), 1U, (FILE * __restrict  )in);
#line 43
  if (tmp != 1U) {
#line 44
    return (-1);
  }
#line 48
  if ((unsigned long )magic1 == 1398424644UL) {
#line 53
    tmp___0 = fread((void * __restrict  )(& magic2), sizeof(magic2), 1U, (FILE * __restrict  )in);
#line 53
    if (tmp___0 != 1U) {
#line 54
      return (-1);
    }
#line 57
    tmp___1 = fread((void * __restrict  )(& reserved), sizeof(reserved), 1U, (FILE * __restrict  )in);
#line 57
    if (tmp___1 != 1U) {
#line 58
      return (-1);
    }
#line 61
    tmp___2 = fread((void * __restrict  )(& filesize), sizeof(filesize), 1U, (FILE * __restrict  )in);
#line 61
    if (tmp___2 != 1U) {
#line 62
      return (-1);
    }
#line 66
    if ((unsigned long )magic2 != 2297440051UL) {
#line 71
      cli_warnmsg("msexpand: Not a MS-compressed file\n");
#line 72
      return (-1);
    }
  } else {
#line 77
    if ((unsigned long )magic1 == 1264009546UL) {
#line 82
      tmp___3 = fread((void * __restrict  )(& magic2), sizeof(magic2), 1U, (FILE * __restrict  )in);
#line 82
      if (tmp___3 != 1U) {
#line 83
        return (-1);
      }
#line 86
      tmp___4 = fread((void * __restrict  )(& magic3), sizeof(magic3), 1U, (FILE * __restrict  )in);
#line 86
      if (tmp___4 != 1U) {
#line 87
        return (-1);
      }
#line 90
      tmp___5 = fread((void * __restrict  )(& reserved), sizeof(reserved), 1U, (FILE * __restrict  )in);
#line 90
      if (tmp___5 != 1U) {
#line 91
        return (-1);
      }
#line 95
      if ((unsigned long )magic2 != 2297440209UL) {
#line 100
        cli_warnmsg("msexpand: Not a MS-compressed file\n");
#line 101
        return (-1);
      } else {
#line 95
        if ((unsigned long )magic3 != 50336256UL) {
#line 100
          cli_warnmsg("msexpand: Not a MS-compressed file\n");
#line 101
          return (-1);
        }
      }
#line 104
      cli_warnmsg("msexpand: unsupported version 6.22\n");
#line 105
      return (-1);
    } else {
#line 108
      cli_warnmsg("msexpand: Not a MS-compressed file\n");
#line 109
      return (-1);
    }
  }
#line 112
  buffer = (unsigned char *)cli_calloc(4096U, sizeof(char ));
#line 112
  if ((unsigned int )buffer == (unsigned int )((void *)0)) {
#line 113
    cli_errmsg("msexpand: Can\'t allocate memory\n");
#line 114
    return (-1);
  }
#line 117
  i = 4080;
#line 119
  while (1) {
#line 120
    bits = fgetc(in);
#line 120
    if (bits == -1) {
#line 121
      break;
    }
#line 123
    mask = 1;
#line 123
    while (mask & 255) {
#line 124
      if (! (bits & mask)) {
#line 125
        j = fgetc(in);
#line 125
        if (j == -1) {
#line 126
          break;
        }
#line 127
        len = fgetc(in);
#line 128
        j += (len & 240) << 4;
#line 129
        len = (len & 15) + 3;
#line 130
        while (1) {
#line 130
          tmp___8 = len;
#line 130
          len --;
#line 130
          if (! tmp___8) {
#line 130
            break;
          }
#line 131
          (*(buffer + i)) = (*(buffer + j));
#line 132
          tmp___7 = fwrite((void const   * __restrict  )(buffer + i), sizeof(unsigned char ),
                           1U, (FILE * __restrict  )out);
#line 132
          if (tmp___7 != 1U) {
#line 133
            free((void *)buffer);
#line 134
            return (-1);
          }
#line 136
          j ++;
#line 137
          j %= 4096;
#line 138
          i ++;
#line 139
          i %= 4096;
        }
      } else {
#line 142
        ch = fgetc(in);
#line 142
        if (ch == -1) {
#line 143
          break;
        }
#line 145
        (*(buffer + i)) = (unsigned char )ch;
#line 146
        tmp___9 = fwrite((void const   * __restrict  )(buffer + i), sizeof(unsigned char ),
                         1U, (FILE * __restrict  )out);
#line 146
        if (tmp___9 != 1U) {
#line 147
          free((void *)buffer);
#line 148
          return (-1);
        }
#line 150
        i ++;
#line 151
        i %= 4096;
      }
#line 123
      mask <<= 1;
    }
  }
#line 156
  free((void *)buffer);
#line 157
  return (0);
}
}
#line 1 "pe.lo"
#pragma merger(0,"/tmp/cil-zQxPNCTc.i","-g -O2 -fPIC")
#line 24 "upx.h"
int upx_inflate2b(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) ;
#line 25
int upx_inflate2d(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) ;
#line 26
int upx_inflate2e(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) ;
#line 25 "petite.h"
int petite_inflate2x_1to9(char *buf , uint32_t minrva , int bufsz , struct pe_image_section_hdr *sections ,
                          int sectcount , uint32_t Imagebase , uint32_t pep , int desc ,
                          int version , uint32_t ResRva , uint32_t ResSize ) ;
#line 25 "fsg.h"
int unfsg_200(char *source , char *dest , int ssize , int dsize ) ;
#line 26
int unfsg_133(char *source , char *dest , int ssize , int dsize , struct SECTION *sections ,
              int sectcount , uint32_t base , uint32_t ep , int file ) ;
#line 60 "pe.c"
__inline static uint16_t EC16(uint16_t v ) 
{ 

  {
#line 62
  return ((unsigned short )(((int )v >> 8) + ((int )v << 8)));
}
}
#line 65 "pe.c"
__inline static uint32_t EC32(uint32_t v ) 
{ 

  {
#line 67
  return ((((v >> 24) | ((v & 16711680U) >> 8)) | ((v & 65280U) << 8)) | (v << 24));
}
}
#line 73 "pe.c"
static uint32_t cli_rawaddr(uint32_t rva , struct pe_image_section_hdr *shp , uint16_t nos ,
                            unsigned int *err ) 
{ int i ;
  int found ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 75
  found = 0;
#line 78
  i = 0;
#line 78
  while (i < (int )nos) {
#line 79
    tmp = EC32((shp + i)->VirtualAddress);
#line 79
    if (tmp <= rva) {
#line 79
      tmp___0 = EC32((shp + i)->VirtualAddress);
#line 79
      tmp___1 = EC32((shp + i)->SizeOfRawData);
#line 79
      if (tmp___0 + tmp___1 > rva) {
#line 80
        found = 1;
#line 81
        break;
      }
    }
#line 78
    i ++;
  }
#line 85
  if (! found) {
#line 86
    cli_dbgmsg("Can\'t calculate raw address from RVA 0x%x\n", rva);
#line 87
    (*err) = 1U;
#line 88
    return (0U);
  }
#line 91
  (*err) = 0U;
#line 92
  tmp___2 = EC32((shp + i)->VirtualAddress);
#line 92
  tmp___3 = EC32((shp + i)->PointerToRawData);
#line 92
  return ((rva - tmp___2) + tmp___3);
}
}
#line 149 "pe.c"
int cli_scanpe(int desc , char const   **virname , long *scanned , struct cl_node  const  *root ,
               struct cl_limits  const  *limits , unsigned int options , unsigned int arec ,
               unsigned int mrec ) 
{ uint16_t e_magic ;
  uint16_t nsections ;
  uint32_t e_lfanew ;
  uint32_t ep ;
  time_t timestamp ;
  struct pe_image_file_hdr file_hdr ;
  struct pe_image_optional_hdr optional_hdr ;
  struct pe_image_section_hdr *section_hdr ;
  struct stat sb ;
  char sname[9] ;
  char buff[4096] ;
  char *tempfile ;
  unsigned int i ;
  unsigned int found ;
  unsigned int upx_success ;
  unsigned int min ;
  unsigned int max ;
  unsigned int err ;
  unsigned int broken ;
  unsigned int ssize ;
  unsigned int dsize ;
  unsigned int dll ;
  int (*upxfn)(char * , int  , char * , int * , uint32_t  , uint32_t  , uint32_t  ) ;
  char *src ;
  char *dest ;
  int ndesc ;
  int ret ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  ssize_t tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___9 ;
  char *tmp___11 ;
  uint16_t tmp___12 ;
  uint16_t tmp___13 ;
  ssize_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint16_t tmp___21 ;
  uint16_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  int tmp___25 ;
  uint16_t tmp___26 ;
  uint32_t tmp___27 ;
  int tmp___28 ;
  ssize_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  uint32_t tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  char const   *pt ;
  char const   *tmp___53 ;
  uint32_t dw1 ;
  uint32_t dw2 ;
  ssize_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t rsize ;
  uint32_t vsize ;
  int bw ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  char const   *tmp___58 ;
  ssize_t tmp___59 ;
  int bw___0 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  char const   *tmp___62 ;
  ssize_t tmp___63 ;
  uint32_t tmp___64 ;
  __off_t tmp___65 ;
  ssize_t tmp___66 ;
  uint32_t newesi ;
  uint32_t newedi ;
  uint32_t newebx ;
  uint32_t newedx ;
  int32_t tmp___67 ;
  uint32_t tmp___68 ;
  uint32_t tmp___69 ;
  uint32_t tmp___70 ;
  uint32_t tmp___71 ;
  __off_t tmp___73 ;
  ssize_t tmp___74 ;
  uint32_t tmp___75 ;
  uint32_t tmp___76 ;
  uint32_t tmp___77 ;
  uint32_t tmp___78 ;
  int32_t tmp___79 ;
  uint32_t tmp___80 ;
  uint32_t tmp___81 ;
  uint32_t tmp___82 ;
  uint32_t tmp___83 ;
  uint32_t tmp___84 ;
  uint32_t tmp___85 ;
  uint32_t tmp___86 ;
  int32_t tmp___87 ;
  uint32_t tmp___88 ;
  int32_t tmp___89 ;
  uint32_t tmp___90 ;
  int32_t tmp___91 ;
  uint32_t tmp___92 ;
  uint32_t tmp___93 ;
  uint32_t tmp___94 ;
  uint32_t tmp___95 ;
  uint32_t tmp___96 ;
  uint32_t tmp___97 ;
  uint32_t tmp___98 ;
  uint32_t tmp___99 ;
  uint32_t tmp___100 ;
  uint32_t tmp___101 ;
  int32_t tmp___102 ;
  uint32_t tmp___103 ;
  uint32_t tmp___105 ;
  uint32_t tmp___106 ;
  int tmp___107 ;
  int gp ;
  int t ;
  int sectcnt ;
  char *support ;
  uint32_t newesi___0 ;
  uint32_t newedi___0 ;
  uint32_t newebx___0 ;
  uint32_t oldep ;
  struct SECTION *sections ;
  uint32_t tmp___108 ;
  int32_t tmp___109 ;
  uint32_t tmp___110 ;
  uint32_t tmp___111 ;
  uint32_t tmp___112 ;
  ssize_t tmp___114 ;
  int32_t tmp___115 ;
  uint32_t tmp___116 ;
  int32_t tmp___117 ;
  uint32_t tmp___118 ;
  int32_t tmp___119 ;
  uint32_t tmp___120 ;
  uint32_t tmp___121 ;
  uint32_t tmp___122 ;
  uint32_t tmp___123 ;
  uint32_t tmp___124 ;
  uint32_t tmp___125 ;
  uint32_t rva ;
  uint32_t tmp___126 ;
  uint32_t tmp___127 ;
  uint32_t tmp___128 ;
  uint32_t tmp___129 ;
  uint32_t tmp___130 ;
  int32_t tmp___131 ;
  int32_t tmp___133 ;
  uint32_t tmp___134 ;
  __off_t tmp___136 ;
  ssize_t tmp___137 ;
  uint32_t tmp___139 ;
  int32_t tmp___140 ;
  uint32_t tmp___141 ;
  uint32_t tmp___142 ;
  uint32_t tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int32_t tmp___146 ;
  uint32_t tmp___147 ;
  int gp___0 ;
  int32_t tmp___148 ;
  uint32_t tmp___149 ;
  int t___0 ;
  int sectcnt___0 ;
  char *support___0 ;
  uint32_t newesi___1 ;
  int32_t tmp___150 ;
  uint32_t tmp___151 ;
  uint32_t newedi___1 ;
  int32_t tmp___152 ;
  uint32_t tmp___153 ;
  uint32_t oldep___0 ;
  uint32_t tmp___154 ;
  struct SECTION *sections___0 ;
  uint32_t tmp___155 ;
  uint32_t tmp___156 ;
  uint32_t tmp___157 ;
  uint32_t tmp___158 ;
  uint32_t tmp___159 ;
  uint32_t tmp___160 ;
  uint32_t tmp___161 ;
  uint32_t tmp___162 ;
  uint32_t tmp___163 ;
  uint32_t tmp___164 ;
  uint32_t tmp___165 ;
  uint32_t tmp___166 ;
  ssize_t tmp___168 ;
  uint32_t rva___0 ;
  uint32_t tmp___169 ;
  uint32_t tmp___170 ;
  uint32_t tmp___171 ;
  uint32_t tmp___172 ;
  int32_t tmp___173 ;
  uint32_t tmp___175 ;
  __off_t tmp___177 ;
  ssize_t tmp___178 ;
  uint32_t tmp___180 ;
  int32_t tmp___181 ;
  uint32_t tmp___182 ;
  uint32_t tmp___183 ;
  uint32_t tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int32_t tmp___187 ;
  uint32_t tmp___188 ;
  int tmp___263 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___299 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___318 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  size_t tmp___334 ;
  int tmp___335 ;
  size_t tmp___336 ;
  int tmp___411 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___447 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___466 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___475 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  size_t tmp___482 ;
  int tmp___483 ;
  size_t tmp___484 ;
  uint32_t tmp___485 ;
  uint32_t tmp___486 ;
  __off_t tmp___489 ;
  ssize_t tmp___490 ;
  __off_t tmp___491 ;
  char const   *tmp___492 ;
  char const   *tmp___493 ;
  char const   *tmp___494 ;
  char const   *tmp___495 ;
  char const   *tmp___496 ;
  char const   *tmp___497 ;
  ssize_t tmp___498 ;
  int skew ;
  int32_t tmp___499 ;
  uint32_t tmp___500 ;
  uint32_t tmp___501 ;
  uint32_t tmp___502 ;
  uint32_t tmp___503 ;
  uint32_t tmp___504 ;
  int tmp___505 ;
  uint32_t tmp___506 ;
  uint32_t tmp___507 ;
  uint32_t tmp___508 ;
  int tmp___509 ;
  uint32_t tmp___510 ;
  uint32_t tmp___511 ;
  uint32_t tmp___512 ;
  int tmp___513 ;
  uint32_t tmp___514 ;
  uint32_t tmp___515 ;
  uint32_t tmp___516 ;
  int tmp___517 ;
  uint32_t tmp___518 ;
  uint32_t tmp___519 ;
  uint32_t tmp___520 ;
  int tmp___521 ;
  uint32_t tmp___522 ;
  uint32_t tmp___523 ;
  uint32_t tmp___524 ;
  int tmp___525 ;
  uint32_t tmp___526 ;
  uint32_t tmp___527 ;
  uint32_t tmp___528 ;
  int tmp___529 ;
  uint32_t tmp___530 ;
  uint32_t tmp___531 ;
  uint32_t tmp___532 ;
  int tmp___533 ;
  uint32_t tmp___534 ;
  uint32_t tmp___535 ;
  uint32_t tmp___536 ;
  int tmp___537 ;
  ssize_t tmp___538 ;
  ssize_t tmp___539 ;
  int32_t tmp___540 ;
  uint32_t tmp___541 ;
  uint32_t tmp___542 ;
  int32_t tmp___543 ;
  uint32_t tmp___544 ;
  uint32_t tmp___545 ;
  uint32_t offset ;
  uint32_t tmp___547 ;
  uint32_t tmp___548 ;
  __off_t tmp___549 ;
  size_t tmp___550 ;
  uint32_t tmp___551 ;
  ssize_t tmp___552 ;
  uint32_t tmp___553 ;
  uint32_t tmp___554 ;
  uint32_t tmp___555 ;
  uint32_t tmp___556 ;
  uint32_t tmp___557 ;
  int tmp___558 ;
  int tmp___559 ;
  int tmp___560 ;
  int32_t tmp___561 ;

  {
#line 161
  upx_success = 0U;
#line 161
  min = 0U;
#line 161
  max = 0U;
#line 161
  broken = 0U;
#line 162
  ssize = 0U;
#line 162
  dsize = 0U;
#line 162
  dll = 0U;
#line 163
  upxfn = (int (*)(char * , int  , char * , int * , uint32_t  , uint32_t  , uint32_t  ))((void *)0);
#line 164
  src = (char *)((void *)0);
#line 164
  dest = (char *)((void *)0);
#line 168
  tmp = read(desc, (void *)(& e_magic), sizeof(e_magic));
#line 168
  if ((unsigned int )tmp != sizeof(e_magic)) {
#line 169
    cli_dbgmsg("Can\'t read DOS signature\n");
#line 170
    return (0);
  }
#line 173
  tmp___0 = EC16(e_magic);
#line 173
  if ((int )tmp___0 != 23117) {
#line 173
    tmp___1 = EC16(e_magic);
#line 173
    if ((int )tmp___1 != 19802) {
#line 174
      cli_dbgmsg("Invalid DOS signature\n");
#line 175
      return (0);
    }
  }
#line 178
  lseek(desc, 58L, 1);
#line 180
  tmp___2 = read(desc, (void *)(& e_lfanew), sizeof(e_lfanew));
#line 180
  if ((unsigned int )tmp___2 != sizeof(e_lfanew)) {
#line 181
    cli_dbgmsg("Can\'t read new header address\n");
#line 183
    if (options & 128U) {
#line 184
      if (virname) {
#line 185
        (*virname) = "Broken.Executable";
      }
#line 186
      return (1);
    }
#line 188
    return (0);
  }
#line 191
  e_lfanew = EC32(e_lfanew);
#line 192
  cli_dbgmsg("e_lfanew == %d\n", e_lfanew);
#line 193
  if (! e_lfanew) {
#line 194
    cli_dbgmsg("Not a PE file\n");
#line 195
    return (0);
  }
#line 198
  tmp___3 = lseek(desc, (long )e_lfanew, 0);
#line 198
  if (tmp___3 < 0L) {
#line 200
    cli_dbgmsg("Can\'t lseek to e_lfanew\n");
#line 201
    return (0);
  }
#line 204
  tmp___4 = read(desc, (void *)(& file_hdr), sizeof(struct pe_image_file_hdr ));
#line 204
  if ((unsigned int )tmp___4 != sizeof(struct pe_image_file_hdr )) {
#line 206
    cli_dbgmsg("Can\'t read file header\n");
#line 207
    return (0);
  }
#line 210
  tmp___5 = EC32(file_hdr.Magic);
#line 210
  if (tmp___5 != 17744U) {
#line 211
    cli_dbgmsg("Invalid PE signature (probably NE file)\n");
#line 212
    return (0);
  }
#line 215
  tmp___7 = EC16(file_hdr.Characteristics);
#line 215
  if ((int )tmp___7 & 8192) {
#line 216
    cli_dbgmsg("File type: DLL\n");
#line 217
    dll = 1U;
  } else {
#line 218
    tmp___6 = EC16(file_hdr.Characteristics);
#line 218
    if ((int )tmp___6 & 1) {
#line 219
      cli_dbgmsg("File type: Executable\n");
    }
  }
#line 222
  tmp___8 = (int )EC16(file_hdr.Machine);
#line 222
  switch (tmp___8) {
  case 0: 
#line 224
  cli_dbgmsg("Machine type: Unknown\n");
  case 332: 
#line 226
  cli_dbgmsg("Machine type: 80386\n");
#line 227
  break;
  case 333: 
#line 229
  cli_dbgmsg("Machine type: 80486\n");
#line 230
  break;
  case 334: 
#line 232
  cli_dbgmsg("Machine type: 80586\n");
#line 233
  break;
  case 352: 
#line 235
  cli_dbgmsg("Machine type: R30000 (big-endian)\n");
#line 236
  break;
  case 354: 
#line 238
  cli_dbgmsg("Machine type: R3000\n");
#line 239
  break;
  case 358: 
#line 241
  cli_dbgmsg("Machine type: R4000\n");
#line 242
  break;
  case 360: 
#line 244
  cli_dbgmsg("Machine type: R10000\n");
#line 245
  break;
  case 388: 
#line 247
  cli_dbgmsg("Machine type: DEC Alpha AXP\n");
#line 248
  break;
  case 644: 
#line 250
  cli_dbgmsg("Machine type: DEC Alpha AXP 64bit\n");
#line 251
  break;
  case 496: 
#line 253
  cli_dbgmsg("Machine type: PowerPC\n");
#line 254
  break;
  case 512: 
#line 256
  cli_dbgmsg("Machine type: IA64\n");
#line 257
  break;
  case 616: 
#line 259
  cli_dbgmsg("Machine type: M68k\n");
#line 260
  break;
  case 614: 
#line 262
  cli_dbgmsg("Machine type: MIPS16\n");
#line 263
  break;
  case 870: 
#line 265
  cli_dbgmsg("Machine type: MIPS+FPU\n");
#line 266
  break;
  case 1126: 
#line 268
  cli_dbgmsg("Machine type: MIPS16+FPU\n");
#line 269
  break;
  case 418: 
#line 271
  cli_dbgmsg("Machine type: Hitachi SH3\n");
#line 272
  break;
  case 419: 
#line 274
  cli_dbgmsg("Machine type: Hitachi SH3-DSP\n");
#line 275
  break;
  case 420: 
#line 277
  cli_dbgmsg("Machine type: Hitachi SH3-E\n");
#line 278
  break;
  case 422: 
#line 280
  cli_dbgmsg("Machine type: Hitachi SH4\n");
#line 281
  break;
  case 424: 
#line 283
  cli_dbgmsg("Machine type: Hitachi SH5\n");
#line 284
  break;
  case 448: 
#line 286
  cli_dbgmsg("Machine type: ARM\n");
#line 287
  break;
  case 450: 
#line 289
  cli_dbgmsg("Machine type: THUMB\n");
#line 290
  break;
  case 467: 
#line 292
  cli_dbgmsg("Machine type: AM33\n");
#line 293
  break;
  case 1312: 
#line 295
  cli_dbgmsg("Machine type: Infineon TriCore\n");
#line 296
  break;
  case 3311: 
#line 298
  cli_dbgmsg("Machine type: CEF\n");
#line 299
  break;
  case 3772: 
#line 301
  cli_dbgmsg("Machine type: EFI Byte Code\n");
#line 302
  break;
  case 36929: 
#line 304
  cli_dbgmsg("Machine type: M32R\n");
#line 305
  break;
  case 49390: 
#line 307
  cli_dbgmsg("Machine type: CEE\n");
#line 308
  break;
  case 34404: 
#line 310
  cli_dbgmsg("Machine type: AMD64\n");
#line 311
  break;
  default: 
#line 313
  tmp___9 = EC16(file_hdr.Machine);
#line 313
  cli_warnmsg("Unknown machine type in PE header (0x%x)\n", tmp___9);
  }
#line 316
  nsections = EC16(file_hdr.NumberOfSections);
#line 317
  if ((int )nsections < 1) {
#line 318
    if (options & 128U) {
#line 319
      if (virname) {
#line 320
        (*virname) = "Broken.Executable";
      }
#line 321
      return (1);
    }
#line 323
    cli_warnmsg("PE file contains no sections\n");
#line 324
    return (0);
  }
#line 327
  cli_dbgmsg("NumberOfSections: %d\n", nsections);
#line 329
  timestamp = (time_t )EC32(file_hdr.TimeDateStamp);
#line 330
  tmp___11 = ctime((time_t const   *)(& timestamp));
#line 330
  cli_dbgmsg("TimeDateStamp: %s", tmp___11);
#line 332
  tmp___12 = EC16(file_hdr.SizeOfOptionalHeader);
#line 332
  cli_dbgmsg("SizeOfOptionalHeader: %d\n", tmp___12);
#line 334
  tmp___13 = EC16(file_hdr.SizeOfOptionalHeader);
#line 334
  if ((unsigned int )tmp___13 != sizeof(struct pe_image_optional_hdr )) {
#line 335
    cli_warnmsg("Broken PE header detected.\n");
#line 336
    if (options & 128U) {
#line 337
      if (virname) {
#line 338
        (*virname) = "Broken.Executable";
      }
#line 339
      return (1);
    }
#line 341
    return (0);
  }
#line 344
  tmp___14 = read(desc, (void *)(& optional_hdr), sizeof(struct pe_image_optional_hdr ));
#line 344
  if ((unsigned int )tmp___14 != sizeof(struct pe_image_optional_hdr )) {
#line 345
    cli_dbgmsg("Can\'t optional file header\n");
#line 346
    if (options & 128U) {
#line 347
      if (virname) {
#line 348
        (*virname) = "Broken.Executable";
      }
#line 349
      return (1);
    }
#line 351
    return (0);
  }
#line 354
  cli_dbgmsg("MajorLinkerVersion: %d\n", optional_hdr.MajorLinkerVersion);
#line 355
  cli_dbgmsg("MinorLinkerVersion: %d\n", optional_hdr.MinorLinkerVersion);
#line 356
  tmp___15 = EC32(optional_hdr.SizeOfCode);
#line 356
  cli_dbgmsg("SizeOfCode: %d\n", tmp___15);
#line 357
  tmp___16 = EC32(optional_hdr.SizeOfInitializedData);
#line 357
  cli_dbgmsg("SizeOfInitializedData: %d\n", tmp___16);
#line 358
  tmp___17 = EC32(optional_hdr.SizeOfUninitializedData);
#line 358
  cli_dbgmsg("SizeOfUninitializedData: %d\n", tmp___17);
#line 359
  tmp___18 = EC32(optional_hdr.AddressOfEntryPoint);
#line 359
  cli_dbgmsg("AddressOfEntryPoint: 0x%x\n", tmp___18);
#line 360
  tmp___19 = EC32(optional_hdr.SectionAlignment);
#line 360
  cli_dbgmsg("SectionAlignment: %d\n", tmp___19);
#line 361
  tmp___20 = EC32(optional_hdr.FileAlignment);
#line 361
  cli_dbgmsg("FileAlignment: %d\n", tmp___20);
#line 362
  tmp___21 = EC16(optional_hdr.MajorSubsystemVersion);
#line 362
  cli_dbgmsg("MajorSubsystemVersion: %d\n", tmp___21);
#line 363
  tmp___22 = EC16(optional_hdr.MinorSubsystemVersion);
#line 363
  cli_dbgmsg("MinorSubsystemVersion: %d\n", tmp___22);
#line 364
  tmp___23 = EC32(optional_hdr.SizeOfImage);
#line 364
  cli_dbgmsg("SizeOfImage: %d\n", tmp___23);
#line 365
  tmp___24 = EC32(optional_hdr.SizeOfHeaders);
#line 365
  cli_dbgmsg("SizeOfHeaders: %d\n", tmp___24);
#line 367
  tmp___25 = (int )EC16(optional_hdr.Subsystem);
#line 367
  switch (tmp___25) {
  case 0: 
#line 369
  cli_dbgmsg("Subsystem: Unknown\n");
#line 370
  break;
  case 1: 
#line 372
  cli_dbgmsg("Subsystem: Native (a driver ?)\n");
#line 373
  break;
  case 2: 
#line 375
  cli_dbgmsg("Subsystem: Win32 GUI\n");
#line 376
  break;
  case 3: 
#line 378
  cli_dbgmsg("Subsystem: Win32 console\n");
#line 379
  break;
  case 5: 
#line 381
  cli_dbgmsg("Subsystem: OS/2 console\n");
#line 382
  break;
  case 7: 
#line 384
  cli_dbgmsg("Subsystem: POSIX console\n");
#line 385
  break;
  case 8: 
#line 387
  cli_dbgmsg("Subsystem: Native Win9x driver\n");
#line 388
  break;
  case 9: 
#line 390
  cli_dbgmsg("Subsystem: WinCE GUI\n");
#line 391
  break;
  case 10: 
#line 393
  cli_dbgmsg("Subsystem: EFI application\n");
#line 394
  break;
  case 11: 
#line 396
  cli_dbgmsg("Subsystem: EFI driver\n");
#line 397
  break;
  case 12: 
#line 399
  cli_dbgmsg("Subsystem: EFI runtime driver\n");
#line 400
  break;
  default: 
#line 402
  tmp___26 = EC16(optional_hdr.Subsystem);
#line 402
  cli_warnmsg("Unknown subsystem in PE header (0x%x)\n", tmp___26);
  }
#line 405
  tmp___27 = EC32(optional_hdr.NumberOfRvaAndSizes);
#line 405
  cli_dbgmsg("NumberOfRvaAndSizes: %d\n", tmp___27);
#line 406
  cli_dbgmsg("------------------------------------\n");
#line 408
  tmp___28 = fstat__extinline(desc, & sb);
#line 408
  if (tmp___28 == -1) {
#line 409
    cli_dbgmsg("fstat failed\n");
#line 410
    return (-12);
  }
#line 413
  section_hdr = (struct pe_image_section_hdr *)cli_calloc((unsigned int )nsections,
                                                          sizeof(struct pe_image_section_hdr ));
#line 415
  if (! section_hdr) {
#line 416
    cli_dbgmsg("Can\'t allocate memory for section headers\n");
#line 417
    return (-3);
  }
#line 420
  i = 0U;
#line 420
  while (i < (unsigned int )nsections) {
#line 422
    tmp___30 = read(desc, (void *)(section_hdr + i), sizeof(struct pe_image_section_hdr ));
#line 422
    if ((unsigned int )tmp___30 != sizeof(struct pe_image_section_hdr )) {
#line 423
      cli_dbgmsg("Can\'t read section header\n");
#line 424
      cli_dbgmsg("Possibly broken PE file\n");
#line 425
      free((void *)section_hdr);
#line 426
      if (options & 128U) {
#line 427
        if (virname) {
#line 428
          (*virname) = "Broken.Executable";
        }
#line 429
        return (1);
      }
#line 431
      return (0);
    }
#line 434
    __builtin_strncpy(sname, (section_hdr + i)->Name, 8);
#line 435
    sname[8] = (char)0;
#line 436
    cli_dbgmsg("Section %d\n", i);
#line 437
    cli_dbgmsg("Section name: %s\n", sname);
#line 438
    tmp___31 = EC32((section_hdr + i)->VirtualSize);
#line 438
    cli_dbgmsg("VirtualSize: %d\n", tmp___31);
#line 439
    tmp___32 = EC32((section_hdr + i)->VirtualAddress);
#line 439
    cli_dbgmsg("VirtualAddress: 0x%x\n", tmp___32);
#line 440
    tmp___33 = EC32((section_hdr + i)->SizeOfRawData);
#line 440
    cli_dbgmsg("SizeOfRawData: %d\n", tmp___33);
#line 441
    tmp___34 = EC32((section_hdr + i)->PointerToRawData);
#line 441
    tmp___35 = EC32((section_hdr + i)->PointerToRawData);
#line 441
    cli_dbgmsg("PointerToRawData: 0x%x (%d)\n", tmp___35, tmp___34);
#line 443
    tmp___38 = EC32((section_hdr + i)->Characteristics);
#line 443
    if (tmp___38 & 32U) {
#line 444
      cli_dbgmsg("Section contains executable code\n");
#line 446
      tmp___36 = EC32((section_hdr + i)->VirtualSize);
#line 446
      tmp___37 = EC32((section_hdr + i)->SizeOfRawData);
#line 446
      if (tmp___36 < tmp___37) {
#line 447
        cli_dbgmsg("Section contains free space\n");
      }
    }
#line 456
    tmp___39 = EC32((section_hdr + i)->Characteristics);
#line 456
    if (tmp___39 & 536870912U) {
#line 457
      cli_dbgmsg("Section\'s memory is executable\n");
    }
#line 459
    tmp___40 = EC32((section_hdr + i)->Characteristics);
#line 459
    if (tmp___40 & 2147483648U) {
#line 460
      cli_dbgmsg("Section\'s memory is writeable\n");
    }
#line 462
    cli_dbgmsg("------------------------------------\n");
#line 464
    tmp___43 = EC32((section_hdr + i)->PointerToRawData);
#line 464
    tmp___44 = EC32((section_hdr + i)->SizeOfRawData);
#line 464
    if ((unsigned long )(tmp___43 + tmp___44) > (unsigned long )sb.st_size) {
#line 465
      tmp___41 = EC32((section_hdr + i)->SizeOfRawData);
#line 465
      tmp___42 = EC32((section_hdr + i)->PointerToRawData);
#line 465
      cli_dbgmsg("Possibly broken PE file - Section %d out of file (Offset@ %d, Rsize %d, Total filesize %d)\n",
                 i, tmp___42, tmp___41, sb.st_size);
#line 466
      if (options & 128U) {
#line 467
        if (virname) {
#line 468
          (*virname) = "Broken.Executable";
        }
#line 469
        free((void *)section_hdr);
#line 470
        return (1);
      }
#line 472
      broken = 1U;
    }
#line 475
    if (! i) {
#line 476
      min = EC32((section_hdr + i)->VirtualAddress);
#line 477
      tmp___45 = EC32((section_hdr + i)->VirtualAddress);
#line 477
      tmp___46 = EC32((section_hdr + i)->SizeOfRawData);
#line 477
      max = tmp___45 + tmp___46;
    } else {
#line 479
      tmp___47 = EC32((section_hdr + i)->VirtualAddress);
#line 479
      if (tmp___47 < min) {
#line 480
        min = EC32((section_hdr + i)->VirtualAddress);
      }
#line 482
      tmp___50 = EC32((section_hdr + i)->VirtualAddress);
#line 482
      tmp___51 = EC32((section_hdr + i)->SizeOfRawData);
#line 482
      if (tmp___50 + tmp___51 > max) {
#line 483
        tmp___48 = EC32((section_hdr + i)->VirtualAddress);
#line 483
        tmp___49 = EC32((section_hdr + i)->SizeOfRawData);
#line 483
        max = tmp___48 + tmp___49;
      }
    }
#line 420
    i ++;
  }
#line 488
  ep = EC32(optional_hdr.AddressOfEntryPoint);
#line 488
  if (ep >= min) {
#line 488
    tmp___52 = EC32(optional_hdr.AddressOfEntryPoint);
#line 488
    ep = cli_rawaddr(tmp___52, section_hdr, nsections, & err);
#line 488
    if (! ep) {
#line 488
      if (err) {
#line 489
        cli_dbgmsg("Possibly broken PE file\n");
#line 490
        free((void *)section_hdr);
#line 491
        if (options & 128U) {
#line 492
          if (virname) {
#line 493
            (*virname) = "Broken.Executable";
          }
#line 494
          return (1);
        }
#line 496
        return (0);
      }
    }
  }
#line 499
  cli_dbgmsg("EntryPoint offset: 0x%x (%d)\n", ep, ep);
#line 504
  if (! dll) {
#line 504
    tmp___55 = EC32((section_hdr + ((int )nsections - 1))->PointerToRawData);
#line 504
    if (ep == tmp___55) {
#line 505
      lseek(desc, (long )ep, 0);
#line 506
      tmp___54 = read(desc, (void *)(buff), 4096U);
#line 506
      if (tmp___54 == 4096) {
#line 507
        tmp___53 = cli_memstr((char const   *)(buff), 4040, "GetProcAddress\000",
                              15);
#line 507
        pt = tmp___53;
#line 508
        if (pt) {
#line 511
          pt += 15;
#line 512
          dw1 = (uint32_t )cli_readint32(pt);
#line 512
          dw2 = (uint32_t )cli_readint32(pt + 4);
#line 512
          if ((dw1 ^ dw2) == 5265999U) {
#line 512
            dw1 = (uint32_t )cli_readint32(pt + 8);
#line 512
            dw2 = (uint32_t )cli_readint32(pt + 12);
#line 512
            if ((dw1 ^ dw2) == 1048571U) {
#line 512
              dw1 = (uint32_t )cli_readint32(pt + 16);
#line 512
              dw2 = (uint32_t )cli_readint32(pt + 20);
#line 512
              if ((dw1 ^ dw2) == 184U) {
#line 513
                (*virname) = "W32.Parite.B";
#line 514
                free((void *)section_hdr);
#line 515
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 522
  if (! dll) {
#line 522
    tmp___64 = EC32((section_hdr + ((int )nsections - 1))->Characteristics);
#line 522
    if (tmp___64 & 2147483648U) {
#line 525
      rsize = EC32((section_hdr + ((int )nsections - 1))->SizeOfRawData);
#line 526
      vsize = EC32((section_hdr + ((int )nsections - 1))->VirtualSize);
#line 528
      if (rsize >= 24876U) {
#line 528
        if (vsize >= 24876U) {
#line 528
          if ((vsize & 255U) == 236U) {
#line 529
            if (rsize < 28672U) {
#line 529
              tmp___56 = rsize;
            } else {
#line 529
              tmp___56 = 28672U;
            }
#line 529
            bw = (int )tmp___56;
#line 531
            tmp___57 = EC32((section_hdr + ((int )nsections - 1))->PointerToRawData);
#line 531
            lseek(desc, (long )((tmp___57 + rsize) - (unsigned int )bw), 0);
#line 532
            tmp___59 = read(desc, (void *)(buff), 4096U);
#line 532
            if (tmp___59 == 4096) {
#line 533
              tmp___58 = cli_memstr((char const   *)(buff), 4091, "\350,a\000\000",
                                    5);
#line 533
              if (tmp___58) {
#line 534
                (*virname) = "W32.Magistr.A";
#line 535
                free((void *)section_hdr);
#line 536
                return (1);
              }
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
#line 540
        if (rsize >= 28672U) {
#line 540
          if (vsize >= 28672U) {
#line 540
            if ((vsize & 255U) == 237U) {
#line 541
              if (rsize < 32768U) {
#line 541
                tmp___60 = rsize;
              } else {
#line 541
                tmp___60 = 32768U;
              }
#line 541
              bw___0 = (int )tmp___60;
#line 543
              tmp___61 = EC32((section_hdr + ((int )nsections - 1))->PointerToRawData);
#line 543
              lseek(desc, (long )((tmp___61 + rsize) - (unsigned int )bw___0), 0);
#line 544
              tmp___63 = read(desc, (void *)(buff), 4096U);
#line 544
              if (tmp___63 == 4096) {
#line 545
                tmp___62 = cli_memstr((char const   *)(buff), 4091, "\350\004r\000\000",
                                      5);
#line 545
                if (tmp___62) {
#line 546
                  (*virname) = "W32.Magistr.B";
#line 547
                  free((void *)section_hdr);
#line 548
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 554
  if (broken) {
#line 555
    free((void *)section_hdr);
#line 556
    return (0);
  }
#line 562
  found = 0U;
#line 563
  i = 0U;
#line 563
  while (i < (unsigned int )nsections - 1U) {
#line 564
    if (! (section_hdr + i)->SizeOfRawData) {
#line 564
      if ((section_hdr + i)->VirtualSize) {
#line 564
        if ((section_hdr + (i + 1U))->SizeOfRawData) {
#line 564
          if ((section_hdr + (i + 1U))->VirtualSize) {
#line 565
            found = 1U;
#line 566
            cli_dbgmsg("UPX/FSG: empty section found - assuming compression\n");
#line 567
            break;
          }
        }
      }
    }
#line 563
    i ++;
  }
#line 571
  if (found) {
#line 574
    tmp___65 = lseek(desc, (long )ep, 0);
#line 574
    if (tmp___65 == -1L) {
#line 575
      cli_dbgmsg("UPX/FSG: lseek() failed\n");
#line 576
      free((void *)section_hdr);
#line 577
      return (-12);
    }
#line 580
    tmp___66 = read(desc, (void *)(buff), 168U);
#line 580
    if (tmp___66 != 168) {
#line 581
      cli_dbgmsg("UPX/FSG: Can\'t read 168 bytes at 0x%x (%d)\n", ep, ep);
#line 582
      cli_dbgmsg("UPX/FSG: Broken or not UPX/FSG compressed file\n");
#line 583
      free((void *)section_hdr);
#line 584
      return (0);
    }
#line 587
    if ((int )buff[0] == -121) {
#line 587
      if ((int )buff[1] == 37) {
#line 591
        ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 592
        dsize = EC32((section_hdr + i)->VirtualSize);
#line 594
        while (found) {
#line 597
          if (limits) {
#line 597
            if (limits->maxfilesize) {
#line 597
              if ((unsigned long )ssize > limits->maxfilesize) {
#line 598
                cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                           ssize, dsize, limits->maxfilesize);
#line 599
                free((void *)section_hdr);
#line 600
                return (0);
              } else {
#line 597
                if ((unsigned long )dsize > limits->maxfilesize) {
#line 598
                  cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                             ssize, dsize, limits->maxfilesize);
#line 599
                  free((void *)section_hdr);
#line 600
                  return (0);
                }
              }
            }
          }
#line 603
          if (ssize <= 25U) {
#line 604
            cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
#line 605
            free((void *)section_hdr);
#line 606
            return (0);
          } else {
#line 603
            if (dsize <= ssize) {
#line 604
              cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
#line 605
              free((void *)section_hdr);
#line 606
              return (0);
            }
          }
#line 609
          tmp___67 = cli_readint32((char const   *)(buff + 2));
#line 609
          tmp___68 = EC32(optional_hdr.ImageBase);
#line 609
          newedx = (unsigned int )tmp___67 - tmp___68;
#line 609
          tmp___69 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 609
          if (newedx < tmp___69) {
#line 610
            cli_dbgmsg("FSG: xchg out of bounds (%x), giving up\n", newedx);
#line 611
            break;
          } else {
#line 609
            tmp___70 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 609
            tmp___71 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 609
            if (newedx >= (tmp___70 + tmp___71) - 4U) {
#line 610
              cli_dbgmsg("FSG: xchg out of bounds (%x), giving up\n", newedx);
#line 611
              break;
            }
          }
#line 614
          src = (char *)cli_malloc(ssize);
#line 614
          if ((unsigned int )src == (unsigned int )((void *)0)) {
#line 615
            free((void *)section_hdr);
#line 616
            return (-3);
          }
#line 619
          tmp___73 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 619
          lseek(desc, tmp___73, 0);
#line 620
          tmp___74 = read(desc, (void *)src, ssize);
#line 620
          if ((unsigned int )tmp___74 != ssize) {
#line 621
            cli_dbgmsg("Can\'t read raw data of section %d\n", i);
#line 622
            free((void *)section_hdr);
#line 623
            free((void *)src);
#line 624
            return (-12);
          }
#line 627
          tmp___75 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 627
          if (newedx < tmp___75) {
#line 628
            cli_dbgmsg("FSG: New ESP out of bounds\n");
#line 629
            free((void *)src);
#line 630
            break;
          } else {
#line 627
            tmp___76 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 627
            dest = (src + newedx) - tmp___76;
#line 627
            if ((unsigned int )dest < (unsigned int )src) {
#line 627
              tmp___77 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 627
              tmp___78 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 627
              if ((unsigned int )dest >= (unsigned int )(((src + tmp___77) + tmp___78) -
                                                         4)) {
#line 628
                cli_dbgmsg("FSG: New ESP out of bounds\n");
#line 629
                free((void *)src);
#line 630
                break;
              }
            }
          }
#line 633
          tmp___79 = cli_readint32((char const   *)dest);
#line 633
          tmp___80 = EC32(optional_hdr.ImageBase);
#line 633
          newedx = (unsigned int )tmp___79 - tmp___80;
#line 633
          tmp___81 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 633
          if (newedx <= tmp___81) {
#line 634
            cli_dbgmsg("FSG: New ESP (%x) is wrong\n", newedx);
#line 635
            free((void *)src);
#line 636
            break;
          } else {
#line 633
            tmp___82 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 633
            tmp___83 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 633
            if (newedx >= (tmp___82 + tmp___83) - 4U) {
#line 634
              cli_dbgmsg("FSG: New ESP (%x) is wrong\n", newedx);
#line 635
              free((void *)src);
#line 636
              break;
            }
          }
#line 639
          tmp___84 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 639
          dest = (src + newedx) - tmp___84;
#line 639
          if ((unsigned int )dest < (unsigned int )src) {
#line 640
            cli_dbgmsg("FSG: New stack out of bounds\n");
#line 641
            free((void *)src);
#line 642
            break;
          } else {
#line 639
            tmp___85 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 639
            tmp___86 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 639
            if ((unsigned int )dest >= (unsigned int )(((src + tmp___85) + tmp___86) -
                                                       32)) {
#line 640
              cli_dbgmsg("FSG: New stack out of bounds\n");
#line 641
              free((void *)src);
#line 642
              break;
            }
          }
#line 645
          tmp___87 = cli_readint32((char const   *)dest);
#line 645
          tmp___88 = EC32(optional_hdr.ImageBase);
#line 645
          newedi = (unsigned int )tmp___87 - tmp___88;
#line 646
          tmp___89 = cli_readint32((char const   *)(dest + 4));
#line 646
          tmp___90 = EC32(optional_hdr.ImageBase);
#line 646
          newesi = (unsigned int )tmp___89 - tmp___90;
#line 647
          tmp___91 = cli_readint32((char const   *)(dest + 16));
#line 647
          tmp___92 = EC32(optional_hdr.ImageBase);
#line 647
          newebx = (unsigned int )tmp___91 - tmp___92;
#line 648
          newedx = (uint32_t )cli_readint32((char const   *)(dest + 20));
#line 650
          tmp___94 = EC32((section_hdr + i)->VirtualAddress);
#line 650
          if (newedi != tmp___94) {
#line 651
            tmp___93 = EC32((section_hdr + i)->VirtualAddress);
#line 651
            cli_dbgmsg("FSG: Bad destination buffer (edi is %x should be %x)\n", newedi,
                       tmp___93);
#line 652
            free((void *)src);
#line 653
            break;
          }
#line 656
          tmp___95 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 656
          if (newesi < tmp___95) {
#line 657
            cli_dbgmsg("FSG: Source buffer out of section bounds\n");
#line 658
            free((void *)src);
#line 659
            break;
          } else {
#line 656
            tmp___96 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 656
            tmp___97 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 656
            if (newesi >= tmp___96 + tmp___97) {
#line 657
              cli_dbgmsg("FSG: Source buffer out of section bounds\n");
#line 658
              free((void *)src);
#line 659
              break;
            }
          }
#line 662
          tmp___98 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 662
          if (newebx < tmp___98) {
#line 663
            cli_dbgmsg("FSG: Array of functions out of bounds\n");
#line 664
            free((void *)src);
#line 665
            break;
          } else {
#line 662
            tmp___99 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 662
            tmp___100 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 662
            if (newebx >= (tmp___99 + tmp___100) - 16U) {
#line 663
              cli_dbgmsg("FSG: Array of functions out of bounds\n");
#line 664
              free((void *)src);
#line 665
              break;
            }
          }
#line 669
          tmp___101 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 669
          tmp___102 = cli_readint32((char const   *)(src + ((newebx + 12U) - tmp___101)));
#line 669
          tmp___103 = EC32(optional_hdr.ImageBase);
#line 669
          cli_dbgmsg("FSG: found old EP @%x\n", (unsigned int )tmp___102 - tmp___103);
#line 671
          dest = (char *)cli_calloc(dsize, sizeof(char ));
#line 671
          if ((unsigned int )dest == (unsigned int )((void *)0)) {
#line 672
            free((void *)section_hdr);
#line 673
            free((void *)src);
#line 674
            return (-3);
          }
#line 677
          tmp___105 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 677
          tmp___106 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 677
          tmp___107 = unfsg_200(src + (newesi - tmp___106), dest, (int )((ssize +
                                                                          tmp___105) -
                                                                         newesi),
                                (int )dsize);
#line 677
          if (tmp___107 == -1) {
#line 678
            cli_dbgmsg("FSG: Unpacking failed\n");
#line 679
            free((void *)src);
#line 680
            free((void *)dest);
#line 681
            break;
          }
#line 684
          found = 0U;
#line 685
          upx_success = 1U;
#line 686
          cli_dbgmsg("FSG: Successfully decompressed\n");
        }
      }
    }
#line 690
    if (found) {
#line 690
      if ((int )buff[0] == -66) {
#line 690
        tmp___146 = cli_readint32((char const   *)(buff + 1));
#line 690
        tmp___147 = EC32(optional_hdr.ImageBase);
#line 690
        if ((unsigned int )tmp___146 - tmp___147 < min) {
#line 694
          ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 695
          dsize = EC32((section_hdr + i)->VirtualSize);
#line 697
          while (found) {
#line 698
            sectcnt = 0;
#line 704
            if (limits) {
#line 704
              if (limits->maxfilesize) {
#line 704
                if ((unsigned long )ssize > limits->maxfilesize) {
#line 705
                  cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                             ssize, dsize, limits->maxfilesize);
#line 706
                  free((void *)section_hdr);
#line 707
                  return (0);
                } else {
#line 704
                  if ((unsigned long )dsize > limits->maxfilesize) {
#line 705
                    cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                               ssize, dsize, limits->maxfilesize);
#line 706
                    free((void *)section_hdr);
#line 707
                    return (0);
                  }
                }
              }
            }
#line 710
            if (ssize <= 25U) {
#line 711
              cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
#line 712
              free((void *)section_hdr);
#line 713
              return (0);
            } else {
#line 710
              if (dsize <= ssize) {
#line 711
                cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
#line 712
                free((void *)section_hdr);
#line 713
                return (0);
              }
            }
#line 716
            tmp___109 = cli_readint32((char const   *)(buff + 1));
#line 716
            tmp___110 = EC32(optional_hdr.ImageBase);
#line 716
            gp = (int )((unsigned int )tmp___109 - tmp___110);
#line 716
            tmp___111 = EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 716
            if (gp >= (int )tmp___111) {
#line 717
              tmp___108 = EC32((section_hdr + i)->VirtualAddress);
#line 717
              cli_dbgmsg("FSG: Support data out of padding area (vaddr: %d)\n", tmp___108);
#line 718
              break;
            } else {
#line 716
              if (gp < 0) {
#line 717
                tmp___108 = EC32((section_hdr + i)->VirtualAddress);
#line 717
                cli_dbgmsg("FSG: Support data out of padding area (vaddr: %d)\n",
                           tmp___108);
#line 718
                break;
              }
            }
#line 721
            lseek(desc, (long )gp, 0);
#line 722
            tmp___112 = EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 722
            gp = (int )(tmp___112 - (unsigned int )gp);
#line 724
            if (limits) {
#line 724
              if (limits->maxfilesize) {
#line 724
                if ((unsigned long )((unsigned int )gp) > limits->maxfilesize) {
#line 725
                  cli_dbgmsg("FSG: Buffer size exceeded (size: %d, max: %lu)\n", gp,
                             limits->maxfilesize);
#line 726
                  free((void *)section_hdr);
#line 727
                  return (0);
                }
              }
            }
#line 730
            support = (char *)cli_malloc((unsigned int )gp);
#line 730
            if ((unsigned int )support == (unsigned int )((void *)0)) {
#line 731
              free((void *)section_hdr);
#line 732
              return (-3);
            }
#line 735
            tmp___114 = read(desc, (void *)support, (unsigned int )gp);
#line 735
            if (tmp___114 != gp) {
#line 736
              cli_dbgmsg("Can\'t read %d bytes from padding area\n", gp);
#line 737
              free((void *)section_hdr);
#line 738
              free((void *)support);
#line 739
              return (-12);
            }
#line 742
            tmp___115 = cli_readint32((char const   *)support);
#line 742
            tmp___116 = EC32(optional_hdr.ImageBase);
#line 742
            newebx___0 = (unsigned int )tmp___115 - tmp___116;
#line 743
            tmp___117 = cli_readint32((char const   *)(support + 4));
#line 743
            tmp___118 = EC32(optional_hdr.ImageBase);
#line 743
            newedi___0 = (unsigned int )tmp___117 - tmp___118;
#line 744
            tmp___119 = cli_readint32((char const   *)(support + 8));
#line 744
            tmp___120 = EC32(optional_hdr.ImageBase);
#line 744
            newesi___0 = (unsigned int )tmp___119 - tmp___120;
#line 746
            tmp___121 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 746
            if (newesi___0 < tmp___121) {
#line 747
              cli_dbgmsg("FSG: Source buffer out of section bounds\n");
#line 748
              free((void *)support);
#line 749
              break;
            } else {
#line 746
              tmp___122 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 746
              tmp___123 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 746
              if (newesi___0 >= tmp___122 + tmp___123) {
#line 747
                cli_dbgmsg("FSG: Source buffer out of section bounds\n");
#line 748
                free((void *)support);
#line 749
                break;
              }
            }
#line 752
            tmp___125 = EC32((section_hdr + i)->VirtualAddress);
#line 752
            if (newedi___0 != tmp___125) {
#line 753
              tmp___124 = EC32((section_hdr + i)->VirtualAddress);
#line 753
              cli_dbgmsg("FSG: Bad destination (is %x should be %x)\n", newedi___0,
                         tmp___124);
#line 754
              free((void *)support);
#line 755
              break;
            }
#line 759
            t = 12;
#line 759
            while (t < gp - 4) {
#line 760
              tmp___126 = (uint32_t )cli_readint32((char const   *)(support + t));
#line 760
              rva = tmp___126;
#line 762
              if (! rva) {
#line 763
                break;
              }
#line 765
              tmp___127 = EC32(optional_hdr.ImageBase);
#line 765
              rva -= tmp___127 + 1U;
#line 766
              sectcnt ++;
#line 768
              if (rva % 4096U) {
#line 770
                cli_dbgmsg("FSG: Original section %d is misaligned\n", sectcnt);
              }
#line 772
              tmp___128 = EC32((section_hdr + i)->VirtualAddress);
#line 772
              if (rva < tmp___128) {
#line 773
                cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt);
#line 774
                break;
              } else {
#line 772
                tmp___129 = EC32((section_hdr + i)->VirtualAddress);
#line 772
                tmp___130 = EC32((section_hdr + i)->VirtualSize);
#line 772
                if (rva >= tmp___129 + tmp___130) {
#line 773
                  cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt);
#line 774
                  break;
                }
              }
#line 759
              t += 4;
            }
#line 778
            if (t >= gp - 4) {
#line 779
              free((void *)support);
#line 780
              break;
            } else {
#line 778
              tmp___131 = cli_readint32((char const   *)(support + t));
#line 778
              if (tmp___131) {
#line 779
                free((void *)support);
#line 780
                break;
              }
            }
#line 783
            sections = (struct SECTION *)cli_malloc((unsigned int )(sectcnt + 1) *
                                                    sizeof(struct SECTION ));
#line 783
            if ((unsigned int )sections == (unsigned int )((void *)0)) {
#line 784
              free((void *)section_hdr);
#line 785
              free((void *)support);
#line 786
              return (-3);
            }
#line 789
            (sections + 0)->rva = newedi___0;
#line 790
            t = 1;
#line 790
            while (t <= sectcnt) {
#line 791
              tmp___133 = cli_readint32((char const   *)((support + 8) + t * 4));
#line 791
              tmp___134 = EC32(optional_hdr.ImageBase);
#line 791
              (sections + t)->rva = (unsigned int )(tmp___133 - 1) - tmp___134;
#line 790
              t ++;
            }
#line 793
            free((void *)support);
#line 795
            src = (char *)cli_malloc(ssize);
#line 795
            if ((unsigned int )src == (unsigned int )((void *)0)) {
#line 796
              free((void *)section_hdr);
#line 797
              free((void *)sections);
#line 798
              return (-3);
            }
#line 801
            tmp___136 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 801
            lseek(desc, tmp___136, 0);
#line 802
            tmp___137 = read(desc, (void *)src, ssize);
#line 802
            if ((unsigned int )tmp___137 != ssize) {
#line 803
              cli_dbgmsg("Can\'t read raw data of section %d\n", i);
#line 804
              free((void *)section_hdr);
#line 805
              free((void *)sections);
#line 806
              free((void *)src);
#line 807
              return (-12);
            }
#line 810
            dest = (char *)cli_calloc(dsize, sizeof(char ));
#line 810
            if ((unsigned int )dest == (unsigned int )((void *)0)) {
#line 811
              free((void *)section_hdr);
#line 812
              free((void *)src);
#line 813
              free((void *)sections);
#line 814
              return (-3);
            }
#line 817
            tmp___139 = EC32(optional_hdr.AddressOfEntryPoint);
#line 817
            tmp___140 = cli_readint32((char const   *)(buff + 163));
#line 817
            oldep = ((tmp___139 + 161U) + 6U) + (unsigned int )tmp___140;
#line 818
            cli_dbgmsg("FSG: found old EP @%x\n", oldep);
#line 820
            tempfile = cli_gentemp((char const   *)((void *)0));
#line 821
            ndesc = open((char const   *)tempfile, 578, 448);
#line 821
            if (ndesc < 0) {
#line 822
              cli_dbgmsg("FSG: Can\'t create file %s\n", tempfile);
#line 823
              free((void *)tempfile);
#line 824
              free((void *)section_hdr);
#line 825
              free((void *)src);
#line 826
              free((void *)dest);
#line 827
              free((void *)sections);
#line 828
              return (-12);
            }
#line 831
            tmp___141 = EC32(optional_hdr.ImageBase);
#line 831
            tmp___142 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 831
            tmp___143 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 831
            tmp___144 = unfsg_133((src + newesi___0) - tmp___143, dest, (int )((ssize +
                                                                                tmp___142) -
                                                                               newesi___0),
                                  (int )dsize, sections, sectcnt, tmp___141, oldep,
                                  ndesc);
#line 831
            switch (tmp___144) {
            case 1: 
#line 833
            cli_dbgmsg("FSG: Unpacked and rebuilt executable saved in %s\n", tempfile);
#line 834
            free((void *)src);
#line 835
            free((void *)dest);
#line 836
            free((void *)sections);
#line 837
            fsync(ndesc);
#line 838
            lseek(ndesc, 0L, 0);
#line 840
            cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
#line 841
            tmp___145 = cli_magic_scandesc(ndesc, virname, scanned, root, limits,
                                           options, arec, mrec);
#line 841
            if (tmp___145 == 1) {
#line 842
              free((void *)section_hdr);
#line 843
              close(ndesc);
#line 844
              if (! cli_leavetemps_flag) {
#line 845
                unlink((char const   *)tempfile);
              }
#line 846
              free((void *)tempfile);
#line 847
              return (1);
            }
#line 850
            close(ndesc);
#line 851
            if (! cli_leavetemps_flag) {
#line 852
              unlink((char const   *)tempfile);
            }
#line 853
            free((void *)tempfile);
#line 854
            free((void *)section_hdr);
#line 855
            return (0);
            case 0: 
#line 858
            cli_dbgmsg("FSG: FSG: Successfully decompressed\n");
#line 859
            close(ndesc);
#line 860
            unlink((char const   *)tempfile);
#line 861
            free((void *)tempfile);
#line 862
            free((void *)sections);
#line 863
            found = 0U;
#line 864
            upx_success = 1U;
#line 865
            break;
            default: 
#line 868
            cli_dbgmsg("FSG: Unpacking failed\n");
#line 869
            close(ndesc);
#line 870
            unlink((char const   *)tempfile);
#line 871
            free((void *)tempfile);
#line 872
            free((void *)src);
#line 873
            free((void *)dest);
#line 874
            free((void *)sections);
#line 875
            break;
            }
#line 878
            break;
          }
        }
      }
    }
#line 883
    if (found) {
#line 883
      if ((int )buff[0] == -69) {
#line 883
        tmp___187 = cli_readint32((char const   *)(buff + 1));
#line 883
        tmp___188 = EC32(optional_hdr.ImageBase);
#line 883
        if ((unsigned int )tmp___187 - tmp___188 < min) {
#line 883
          if ((int )buff[5] == -65) {
#line 883
            if ((int )buff[10] == -66) {
#line 887
              ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 888
              dsize = EC32((section_hdr + i)->VirtualSize);
#line 890
              while (found) {
#line 891
                tmp___148 = cli_readint32((char const   *)(buff + 1));
#line 891
                tmp___149 = EC32(optional_hdr.ImageBase);
#line 891
                gp___0 = (int )((unsigned int )tmp___148 - tmp___149);
#line 891
                sectcnt___0 = 0;
#line 893
                tmp___150 = cli_readint32((char const   *)(buff + 11));
#line 893
                tmp___151 = EC32(optional_hdr.ImageBase);
#line 893
                newesi___1 = (unsigned int )tmp___150 - tmp___151;
#line 894
                tmp___152 = cli_readint32((char const   *)(buff + 6));
#line 894
                tmp___153 = EC32(optional_hdr.ImageBase);
#line 894
                newedi___1 = (unsigned int )tmp___152 - tmp___153;
#line 895
                tmp___154 = EC32(optional_hdr.AddressOfEntryPoint);
#line 895
                oldep___0 = tmp___154;
#line 898
                tmp___155 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 898
                if (oldep___0 <= tmp___155) {
#line 899
                  cli_dbgmsg("FSG: EP not in section %d\n", i + 1U);
#line 900
                  break;
                } else {
#line 898
                  tmp___156 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 898
                  tmp___157 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 898
                  if (oldep___0 > (tmp___156 + tmp___157) - 224U) {
#line 899
                    cli_dbgmsg("FSG: EP not in section %d\n", i + 1U);
#line 900
                    break;
                  }
                }
#line 902
                tmp___158 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 902
                oldep___0 -= tmp___158;
#line 904
                tmp___159 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 904
                if (newesi___1 < tmp___159) {
#line 905
                  cli_dbgmsg("FSG: Source buffer out of section bounds\n");
#line 906
                  break;
                } else {
#line 904
                  tmp___160 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 904
                  tmp___161 = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 904
                  if (newesi___1 >= tmp___160 + tmp___161) {
#line 905
                    cli_dbgmsg("FSG: Source buffer out of section bounds\n");
#line 906
                    break;
                  }
                }
#line 909
                tmp___163 = EC32((section_hdr + i)->VirtualAddress);
#line 909
                if (newedi___1 != tmp___163) {
#line 910
                  tmp___162 = EC32((section_hdr + i)->VirtualAddress);
#line 910
                  cli_dbgmsg("FSG: Bad destination (is %x should be %x)\n", newedi___1,
                             tmp___162);
#line 911
                  break;
                }
#line 914
                if (limits) {
#line 914
                  if (limits->maxfilesize) {
#line 914
                    if ((unsigned long )ssize > limits->maxfilesize) {
#line 915
                      cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                                 ssize, dsize, limits->maxfilesize);
#line 916
                      free((void *)section_hdr);
#line 917
                      return (0);
                    } else {
#line 914
                      if ((unsigned long )dsize > limits->maxfilesize) {
#line 915
                        cli_dbgmsg("FSG: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                                   ssize, dsize, limits->maxfilesize);
#line 916
                        free((void *)section_hdr);
#line 917
                        return (0);
                      }
                    }
                  }
                }
#line 920
                if (ssize <= 25U) {
#line 921
                  cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize,
                             dsize);
#line 922
                  free((void *)section_hdr);
#line 923
                  return (0);
                } else {
#line 920
                  if (dsize <= ssize) {
#line 921
                    cli_dbgmsg("FSG: Size mismatch (ssize: %d, dsize: %d)\n", ssize,
                               dsize);
#line 922
                    free((void *)section_hdr);
#line 923
                    return (0);
                  }
                }
#line 926
                tmp___165 = EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 926
                if (gp___0 >= (int )tmp___165) {
#line 927
                  tmp___164 = EC32((section_hdr + i)->VirtualAddress);
#line 927
                  cli_dbgmsg("FSG: Support data out of padding area (newedi: %d, vaddr: %d)\n",
                             newedi___1, tmp___164);
#line 928
                  break;
                } else {
#line 926
                  if (gp___0 < 0) {
#line 927
                    tmp___164 = EC32((section_hdr + i)->VirtualAddress);
#line 927
                    cli_dbgmsg("FSG: Support data out of padding area (newedi: %d, vaddr: %d)\n",
                               newedi___1, tmp___164);
#line 928
                    break;
                  }
                }
#line 931
                lseek(desc, (long )gp___0, 0);
#line 932
                tmp___166 = EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 932
                gp___0 = (int )(tmp___166 - (unsigned int )gp___0);
#line 934
                if (limits) {
#line 934
                  if (limits->maxfilesize) {
#line 934
                    if ((unsigned long )((unsigned int )gp___0) > limits->maxfilesize) {
#line 935
                      cli_dbgmsg("FSG: Buffer size exceeded (size: %d, max: %lu)\n",
                                 gp___0, limits->maxfilesize);
#line 936
                      free((void *)section_hdr);
#line 937
                      return (0);
                    }
                  }
                }
#line 940
                support___0 = (char *)cli_malloc((unsigned int )gp___0);
#line 940
                if ((unsigned int )support___0 == (unsigned int )((void *)0)) {
#line 941
                  free((void *)section_hdr);
#line 942
                  return (-3);
                }
#line 945
                tmp___168 = read(desc, (void *)support___0, (unsigned int )gp___0);
#line 945
                if (tmp___168 != gp___0) {
#line 946
                  cli_dbgmsg("Can\'t read %d bytes from padding area\n", gp___0);
#line 947
                  free((void *)section_hdr);
#line 948
                  free((void *)support___0);
#line 949
                  return (-12);
                }
#line 953
                t___0 = 0;
#line 953
                while (t___0 < gp___0 - 2) {
#line 954
                  rva___0 = (unsigned int )((int )(*(support___0 + t___0)) + 256 *
                                                                             (int )(*(support___0 +
                                                                                      (t___0 +
                                                                                       1))));
#line 956
                  if (rva___0 == 2U) {
#line 957
                    break;
                  } else {
#line 956
                    if (rva___0 == 1U) {
#line 957
                      break;
                    }
                  }
#line 959
                  tmp___169 = EC32(optional_hdr.ImageBase);
#line 959
                  rva___0 = ((rva___0 - 2U) << 12) - tmp___169;
#line 960
                  sectcnt___0 ++;
#line 962
                  tmp___170 = EC32((section_hdr + i)->VirtualAddress);
#line 962
                  if (rva___0 < tmp___170) {
#line 963
                    cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt___0);
#line 964
                    break;
                  } else {
#line 962
                    tmp___171 = EC32((section_hdr + i)->VirtualAddress);
#line 962
                    tmp___172 = EC32((section_hdr + i)->VirtualSize);
#line 962
                    if (rva___0 >= tmp___171 + tmp___172) {
#line 963
                      cli_dbgmsg("FSG: Original section %d is out of bounds\n", sectcnt___0);
#line 964
                      break;
                    }
                  }
#line 953
                  t___0 += 2;
                }
#line 968
                if (t___0 >= gp___0 - 10) {
#line 969
                  free((void *)support___0);
#line 970
                  break;
                } else {
#line 968
                  tmp___173 = cli_readint32((char const   *)((support___0 + t___0) +
                                                             6));
#line 968
                  if (tmp___173 != 2) {
#line 969
                    free((void *)support___0);
#line 970
                    break;
                  }
                }
#line 973
                sections___0 = (struct SECTION *)cli_malloc((unsigned int )(sectcnt___0 +
                                                                            1) * sizeof(struct SECTION ));
#line 973
                if ((unsigned int )sections___0 == (unsigned int )((void *)0)) {
#line 974
                  free((void *)section_hdr);
#line 975
                  free((void *)support___0);
#line 976
                  return (-3);
                }
#line 979
                (sections___0 + 0)->rva = newedi___1;
#line 980
                t___0 = 0;
#line 980
                while (t___0 <= sectcnt___0 - 1) {
#line 981
                  tmp___175 = EC32(optional_hdr.ImageBase);
#line 981
                  (sections___0 + (t___0 + 1))->rva = (unsigned int )((((int )(*(support___0 +
                                                                                 t___0 *
                                                                                 2)) +
                                                                        256 * (int )(*(support___0 +
                                                                                       (t___0 *
                                                                                        2 +
                                                                                        1)))) -
                                                                       2) << 12) -
                                                      tmp___175;
#line 980
                  t___0 ++;
                }
#line 984
                free((void *)support___0);
#line 986
                src = (char *)cli_malloc(ssize);
#line 986
                if ((unsigned int )src == (unsigned int )((void *)0)) {
#line 987
                  free((void *)section_hdr);
#line 988
                  free((void *)sections___0);
#line 989
                  return (-3);
                }
#line 992
                tmp___177 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 992
                lseek(desc, tmp___177, 0);
#line 993
                tmp___178 = read(desc, (void *)src, ssize);
#line 993
                if ((unsigned int )tmp___178 != ssize) {
#line 994
                  cli_dbgmsg("Can\'t read raw data of section %d\n", i);
#line 995
                  free((void *)section_hdr);
#line 996
                  free((void *)sections___0);
#line 997
                  free((void *)src);
#line 998
                  return (-12);
                }
#line 1001
                dest = (char *)cli_calloc(dsize, sizeof(char ));
#line 1001
                if ((unsigned int )dest == (unsigned int )((void *)0)) {
#line 1002
                  free((void *)section_hdr);
#line 1003
                  free((void *)src);
#line 1004
                  free((void *)sections___0);
#line 1005
                  return (-3);
                }
#line 1009
                gp___0 = 218 + 6 * ((int )buff[16] == -24);
#line 1010
                tmp___180 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1010
                tmp___181 = cli_readint32((char const   *)(((src + gp___0) + 2) +
                                                           oldep___0));
#line 1010
                oldep___0 = ((tmp___180 + (unsigned int )gp___0) + 6U) + (unsigned int )tmp___181;
#line 1011
                cli_dbgmsg("FSG: found old EP @%x\n", oldep___0);
#line 1013
                tempfile = cli_gentemp((char const   *)((void *)0));
#line 1014
                ndesc = open((char const   *)tempfile, 578, 448);
#line 1014
                if (ndesc < 0) {
#line 1015
                  cli_dbgmsg("FSG: Can\'t create file %s\n", tempfile);
#line 1016
                  free((void *)tempfile);
#line 1017
                  free((void *)section_hdr);
#line 1018
                  free((void *)src);
#line 1019
                  free((void *)dest);
#line 1020
                  free((void *)sections___0);
#line 1021
                  return (-12);
                }
#line 1024
                tmp___182 = EC32(optional_hdr.ImageBase);
#line 1024
                tmp___183 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1024
                tmp___184 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1024
                tmp___185 = unfsg_133((src + newesi___1) - tmp___184, dest, (int )((ssize +
                                                                                    tmp___183) -
                                                                                   newesi___1),
                                      (int )dsize, sections___0, sectcnt___0, tmp___182,
                                      oldep___0, ndesc);
#line 1024
                switch (tmp___185) {
                case 1: 
#line 1026
                cli_dbgmsg("FSG: Unpacked and rebuilt executable saved in %s\n", tempfile);
#line 1027
                free((void *)src);
#line 1028
                free((void *)dest);
#line 1029
                free((void *)sections___0);
#line 1030
                fsync(ndesc);
#line 1031
                lseek(ndesc, 0L, 0);
#line 1033
                cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
#line 1034
                tmp___186 = cli_magic_scandesc(ndesc, virname, scanned, root, limits,
                                               options, arec, mrec);
#line 1034
                if (tmp___186 == 1) {
#line 1035
                  free((void *)section_hdr);
#line 1036
                  close(ndesc);
#line 1037
                  if (! cli_leavetemps_flag) {
#line 1038
                    unlink((char const   *)tempfile);
                  }
#line 1039
                  free((void *)tempfile);
#line 1040
                  return (1);
                }
#line 1043
                close(ndesc);
#line 1044
                if (! cli_leavetemps_flag) {
#line 1045
                  unlink((char const   *)tempfile);
                }
#line 1046
                free((void *)tempfile);
#line 1047
                free((void *)section_hdr);
#line 1048
                return (0);
                case 0: 
#line 1051
                cli_dbgmsg("FSG: FSG: Successfully decompressed\n");
#line 1052
                close(ndesc);
#line 1053
                unlink((char const   *)tempfile);
#line 1054
                free((void *)tempfile);
#line 1055
                free((void *)sections___0);
#line 1056
                found = 0U;
#line 1057
                upx_success = 1U;
#line 1058
                break;
                default: 
#line 1061
                cli_dbgmsg("FSG: Unpacking failed\n");
#line 1062
                close(ndesc);
#line 1063
                unlink((char const   *)tempfile);
#line 1064
                free((void *)tempfile);
#line 1065
                free((void *)src);
#line 1066
                free((void *)dest);
#line 1067
                free((void *)sections___0);
#line 1068
                break;
                }
#line 1071
                break;
              }
            }
          }
        }
      }
    }
#line 1076
    if (found) {
#line 1080
      __builtin_strncpy(sname, (section_hdr + i)->Name, 8);
#line 1081
      sname[8] = (char)0;
#line 1082
      cli_dbgmsg("UPX: Section %d name: %s\n", i, sname);
#line 1083
      __builtin_strncpy(sname, (section_hdr + (i + 1U))->Name, 8);
#line 1084
      sname[8] = (char)0;
#line 1085
      cli_dbgmsg("UPX: Section %d name: %s\n", i + 1U, sname);
#line 1087
      tmp___333 = __builtin_constant_p((int )((section_hdr + i)->Name));
#line 1087
      if (tmp___333) {
#line 1087
        tmp___334 = strlen((char const   *)((section_hdr + i)->Name));
#line 1087
        if (tmp___334 < 4U) {
          goto _L___41;
        } else {
          goto _L___42;
        }
      } else {
        _L___42: 
#line 1087
        tmp___335 = __builtin_constant_p((int )"UPX0");
#line 1087
        if (tmp___335) {
#line 1087
          tmp___336 = strlen("UPX0");
#line 1087
          if (tmp___336 < 4U) {
            _L___41: 
#line 1087
            tmp___330 = __builtin_constant_p((int )((section_hdr + i)->Name));
#line 1087
            if (tmp___330) {
#line 1087
              tmp___331 = __builtin_constant_p((int )"UPX0");
#line 1087
              if (tmp___331) {
#line 1087
                __s1_len___0 = strlen((char const   *)((section_hdr + i)->Name));
#line 1087
                __s2_len___0 = strlen("UPX0");
#line 1087
                if (! ((unsigned int )((void const   *)((section_hdr + i)->Name +
                                                        1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                i)->Name)) ==
                       1U)) {
                  goto _L___38;
                } else {
#line 1087
                  if (__s1_len___0 >= 4U) {
                    _L___38: 
#line 1087
                    if (! ((unsigned int )((void const   *)("UPX0" + 1)) - (unsigned int )((void const   *)"UPX0") ==
                           1U)) {
#line 1087
                      tmp___332 = 1;
                    } else {
#line 1087
                      if (__s2_len___0 >= 4U) {
#line 1087
                        tmp___332 = 1;
                      } else {
#line 1087
                        tmp___332 = 0;
                      }
                    }
                  } else {
#line 1087
                    tmp___332 = 0;
                  }
                }
#line 1087
                if (tmp___332) {
#line 1087
                  tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                } else {
                  goto _L___40;
                }
              } else {
                goto _L___40;
              }
            } else {
              _L___40: 
#line 1087
              tmp___329 = __builtin_constant_p((int )((section_hdr + i)->Name));
#line 1087
              if (tmp___329) {
#line 1087
                if ((unsigned int )((void const   *)((section_hdr + i)->Name + 1)) -
                    (unsigned int )((void const   *)((section_hdr + i)->Name)) ==
                    1U) {
#line 1087
                  __s1_len___0 = strlen((char const   *)((section_hdr + i)->Name));
#line 1087
                  if (__s1_len___0 < 4U) {
#line 1087
                    tmp___318 = __builtin_constant_p((int )"UPX0");
#line 1087
                    if (tmp___318) {
#line 1087
                      if ((unsigned int )((void const   *)("UPX0" + 1)) - (unsigned int )((void const   *)"UPX0") ==
                          1U) {
#line 1087
                        tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                      } else {
                        goto _L___33;
                      }
                    } else {
                      _L___33: 
#line 1087
                      __s2___14 = (unsigned char const   *)"UPX0";
#line 1087
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                          i)->Name)) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
#line 1087
                      if (__s1_len___0 > 0U) {
#line 1087
                        if (__result___42 == 0) {
#line 1087
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                              i)->Name)) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
#line 1087
                          if (__s1_len___0 > 1U) {
#line 1087
                            if (__result___42 == 0) {
#line 1087
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                  i)->Name)) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
#line 1087
                              if (__s1_len___0 > 2U) {
#line 1087
                                if (__result___42 == 0) {
#line 1087
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                      i)->Name)) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 1087
                      tmp___299 = __result___42;
                    }
                  } else {
                    goto _L___37;
                  }
                } else {
                  goto _L___37;
                }
              } else {
                _L___37: 
#line 1087
                tmp___328 = __builtin_constant_p((int )"UPX0");
#line 1087
                if (tmp___328) {
#line 1087
                  if ((unsigned int )((void const   *)("UPX0" + 1)) - (unsigned int )((void const   *)"UPX0") ==
                      1U) {
#line 1087
                    __s2_len___0 = strlen("UPX0");
#line 1087
                    if (__s2_len___0 < 4U) {
#line 1087
                      tmp___327 = __builtin_constant_p((int )((section_hdr + i)->Name));
#line 1087
                      if (tmp___327) {
#line 1087
                        if ((unsigned int )((void const   *)((section_hdr + i)->Name +
                                                             1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                     i)->Name)) ==
                            1U) {
#line 1087
                          tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                        } else {
                          goto _L___35;
                        }
                      } else {
                        _L___35: 
#line 1087
                        __s1___30 = (unsigned char const   *)((char const   *)((section_hdr +
                                                                                i)->Name));
#line 1087
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)"UPX0" +
                                                                0)));
#line 1087
                        if (__s2_len___0 > 0U) {
#line 1087
                          if (__result___46 == 0) {
#line 1087
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"UPX0" +
                                                                    1)));
#line 1087
                            if (__s2_len___0 > 1U) {
#line 1087
                              if (__result___46 == 0) {
#line 1087
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"UPX0" +
                                                                                               2)));
#line 1087
                                if (__s2_len___0 > 2U) {
#line 1087
                                  if (__result___46 == 0) {
#line 1087
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"UPX0" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 1087
                        tmp___299 = __result___46;
                      }
                    } else {
#line 1087
                      tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                    }
                  } else {
#line 1087
                    tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                  }
                } else {
#line 1087
                  tmp___299 = __builtin_strcmp((section_hdr + i)->Name, "UPX0");
                }
              }
            }
#line 1087
            tmp___263 = tmp___299;
          } else {
#line 1087
            tmp___263 = strncmp((char const   *)((section_hdr + i)->Name), "UPX0",
                                4U);
          }
        } else {
#line 1087
          tmp___263 = strncmp((char const   *)((section_hdr + i)->Name), "UPX0", 4U);
        }
      }
#line 1087
      if (tmp___263) {
#line 1088
        cli_dbgmsg("UPX: Possibly hacked UPX section headers\n");
      } else {
#line 1087
        tmp___481 = __builtin_constant_p((int )((section_hdr + (i + 1U))->Name));
#line 1087
        if (tmp___481) {
#line 1087
          tmp___482 = strlen((char const   *)((section_hdr + (i + 1U))->Name));
#line 1087
          if (tmp___482 < 4U) {
            goto _L___83;
          } else {
            goto _L___84;
          }
        } else {
          _L___84: 
#line 1087
          tmp___483 = __builtin_constant_p((int )"UPX1");
#line 1087
          if (tmp___483) {
#line 1087
            tmp___484 = strlen("UPX1");
#line 1087
            if (tmp___484 < 4U) {
              _L___83: 
#line 1087
              tmp___478 = __builtin_constant_p((int )((section_hdr + (i + 1U))->Name));
#line 1087
              if (tmp___478) {
#line 1087
                tmp___479 = __builtin_constant_p((int )"UPX1");
#line 1087
                if (tmp___479) {
#line 1087
                  __s1_len___2 = strlen((char const   *)((section_hdr + (i + 1U))->Name));
#line 1087
                  __s2_len___2 = strlen("UPX1");
#line 1087
                  if (! ((unsigned int )((void const   *)((section_hdr + (i + 1U))->Name +
                                                          1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                  (i +
                                                                                                   1U))->Name)) ==
                         1U)) {
                    goto _L___80;
                  } else {
#line 1087
                    if (__s1_len___2 >= 4U) {
                      _L___80: 
#line 1087
                      if (! ((unsigned int )((void const   *)("UPX1" + 1)) - (unsigned int )((void const   *)"UPX1") ==
                             1U)) {
#line 1087
                        tmp___480 = 1;
                      } else {
#line 1087
                        if (__s2_len___2 >= 4U) {
#line 1087
                          tmp___480 = 1;
                        } else {
#line 1087
                          tmp___480 = 0;
                        }
                      }
                    } else {
#line 1087
                      tmp___480 = 0;
                    }
                  }
#line 1087
                  if (tmp___480) {
#line 1087
                    tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name, "UPX1");
                  } else {
                    goto _L___82;
                  }
                } else {
                  goto _L___82;
                }
              } else {
                _L___82: 
#line 1087
                tmp___477 = __builtin_constant_p((int )((section_hdr + (i + 1U))->Name));
#line 1087
                if (tmp___477) {
#line 1087
                  if ((unsigned int )((void const   *)((section_hdr + (i + 1U))->Name +
                                                       1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                               (i +
                                                                                                1U))->Name)) ==
                      1U) {
#line 1087
                    __s1_len___2 = strlen((char const   *)((section_hdr + (i + 1U))->Name));
#line 1087
                    if (__s1_len___2 < 4U) {
#line 1087
                      tmp___466 = __builtin_constant_p((int )"UPX1");
#line 1087
                      if (tmp___466) {
#line 1087
                        if ((unsigned int )((void const   *)("UPX1" + 1)) - (unsigned int )((void const   *)"UPX1") ==
                            1U) {
#line 1087
                          tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                       "UPX1");
                        } else {
                          goto _L___75;
                        }
                      } else {
                        _L___75: 
#line 1087
                        __s2___30 = (unsigned char const   *)"UPX1";
#line 1087
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                            (i +
                                                                                                             1U))->Name)) +
                                                                0)) - (int const   )(*(__s2___30 +
                                                                                       0)));
#line 1087
                        if (__s1_len___2 > 0U) {
#line 1087
                          if (__result___90 == 0) {
#line 1087
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                (i +
                                                                                                                 1U))->Name)) +
                                                                    1)) - (int const   )(*(__s2___30 +
                                                                                           1)));
#line 1087
                            if (__s1_len___2 > 1U) {
#line 1087
                              if (__result___90 == 0) {
#line 1087
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                    (i +
                                                                                                                     1U))->Name)) +
                                                                        2)) - (int const   )(*(__s2___30 +
                                                                                               2)));
#line 1087
                                if (__s1_len___2 > 2U) {
#line 1087
                                  if (__result___90 == 0) {
#line 1087
                                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)((section_hdr +
                                                                                                                        (i +
                                                                                                                         1U))->Name)) +
                                                                            3)) -
                                                           (int const   )(*(__s2___30 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 1087
                        tmp___447 = __result___90;
                      }
                    } else {
                      goto _L___79;
                    }
                  } else {
                    goto _L___79;
                  }
                } else {
                  _L___79: 
#line 1087
                  tmp___476 = __builtin_constant_p((int )"UPX1");
#line 1087
                  if (tmp___476) {
#line 1087
                    if ((unsigned int )((void const   *)("UPX1" + 1)) - (unsigned int )((void const   *)"UPX1") ==
                        1U) {
#line 1087
                      __s2_len___2 = strlen("UPX1");
#line 1087
                      if (__s2_len___2 < 4U) {
#line 1087
                        tmp___475 = __builtin_constant_p((int )((section_hdr + (i +
                                                                                1U))->Name));
#line 1087
                        if (tmp___475) {
#line 1087
                          if ((unsigned int )((void const   *)((section_hdr + (i +
                                                                               1U))->Name +
                                                               1)) - (unsigned int )((void const   *)((section_hdr +
                                                                                                       (i +
                                                                                                        1U))->Name)) ==
                              1U) {
#line 1087
                            tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                         "UPX1");
                          } else {
                            goto _L___77;
                          }
                        } else {
                          _L___77: 
#line 1087
                          __s1___62 = (unsigned char const   *)((char const   *)((section_hdr +
                                                                                  (i +
                                                                                   1U))->Name));
#line 1087
                          __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                                 (int const   )(*((unsigned char const   *)"UPX1" +
                                                                  0)));
#line 1087
                          if (__s2_len___2 > 0U) {
#line 1087
                            if (__result___94 == 0) {
#line 1087
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      1)) - (int const   )(*((unsigned char const   *)"UPX1" +
                                                                                             1)));
#line 1087
                              if (__s2_len___2 > 1U) {
#line 1087
                                if (__result___94 == 0) {
#line 1087
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          2)) - (int const   )(*((unsigned char const   *)"UPX1" +
                                                                                                 2)));
#line 1087
                                  if (__s2_len___2 > 2U) {
#line 1087
                                    if (__result___94 == 0) {
#line 1087
                                      __result___94 = (int )((int const   )(*(__s1___62 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)"UPX1" +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 1087
                          tmp___447 = __result___94;
                        }
                      } else {
#line 1087
                        tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                     "UPX1");
                      }
                    } else {
#line 1087
                      tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name,
                                                   "UPX1");
                    }
                  } else {
#line 1087
                    tmp___447 = __builtin_strcmp((section_hdr + (i + 1U))->Name, "UPX1");
                  }
                }
              }
#line 1087
              tmp___411 = tmp___447;
            } else {
#line 1087
              tmp___411 = strncmp((char const   *)((section_hdr + (i + 1U))->Name),
                                  "UPX1", 4U);
            }
          } else {
#line 1087
            tmp___411 = strncmp((char const   *)((section_hdr + (i + 1U))->Name),
                                "UPX1", 4U);
          }
        }
#line 1087
        if (tmp___411) {
#line 1088
          cli_dbgmsg("UPX: Possibly hacked UPX section headers\n");
        }
      }
#line 1091
      ssize = EC32((section_hdr + (i + 1U))->SizeOfRawData);
#line 1092
      tmp___485 = EC32((section_hdr + i)->VirtualSize);
#line 1092
      tmp___486 = EC32((section_hdr + (i + 1U))->VirtualSize);
#line 1092
      dsize = tmp___485 + tmp___486;
#line 1094
      if (limits) {
#line 1094
        if (limits->maxfilesize) {
#line 1094
          if ((unsigned long )ssize > limits->maxfilesize) {
#line 1095
            cli_dbgmsg("UPX: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n", ssize,
                       dsize, limits->maxfilesize);
#line 1096
            free((void *)section_hdr);
#line 1097
            return (0);
          } else {
#line 1094
            if ((unsigned long )dsize > limits->maxfilesize) {
#line 1095
              cli_dbgmsg("UPX: Sizes exceeded (ssize: %d, dsize: %d, max: %lu)\n",
                         ssize, dsize, limits->maxfilesize);
#line 1096
              free((void *)section_hdr);
#line 1097
              return (0);
            }
          }
        }
      }
#line 1100
      if (ssize <= 25U) {
#line 1101
        cli_dbgmsg("UPX: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
#line 1102
        free((void *)section_hdr);
#line 1103
        return (0);
      } else {
#line 1100
        if (dsize <= ssize) {
#line 1101
          cli_dbgmsg("UPX: Size mismatch (ssize: %d, dsize: %d)\n", ssize, dsize);
#line 1102
          free((void *)section_hdr);
#line 1103
          return (0);
        }
      }
#line 1107
      src = (char *)cli_malloc(ssize);
#line 1107
      if ((unsigned int )src == (unsigned int )((void *)0)) {
#line 1108
        free((void *)section_hdr);
#line 1109
        return (-3);
      }
#line 1112
      dest = (char *)cli_calloc((dsize + 1024U) + (unsigned int )((int )nsections *
                                                                  40), sizeof(char ));
#line 1112
      if ((unsigned int )dest == (unsigned int )((void *)0)) {
#line 1113
        free((void *)section_hdr);
#line 1114
        free((void *)src);
#line 1115
        return (-3);
      }
#line 1118
      tmp___489 = (__off_t )EC32((section_hdr + (i + 1U))->PointerToRawData);
#line 1118
      lseek(desc, tmp___489, 0);
#line 1119
      tmp___490 = read(desc, (void *)src, ssize);
#line 1119
      if ((unsigned int )tmp___490 != ssize) {
#line 1120
        cli_dbgmsg("Can\'t read raw data of section %d\n", i);
#line 1121
        free((void *)section_hdr);
#line 1122
        free((void *)src);
#line 1123
        free((void *)dest);
#line 1124
        return (-12);
      }
#line 1129
      tmp___491 = lseek(desc, (long )ep, 0);
#line 1129
      if (tmp___491 == -1L) {
#line 1130
        cli_dbgmsg("lseek() failed\n");
#line 1131
        free((void *)section_hdr);
#line 1132
        free((void *)src);
#line 1133
        free((void *)dest);
#line 1134
        return (-12);
      }
#line 1137
      tmp___498 = read(desc, (void *)(buff), 126U);
#line 1137
      if (tmp___498 != 126) {
#line 1138
        cli_dbgmsg("UPX: Can\'t read 126 bytes at 0x%x (%d)\n", ep, ep);
#line 1139
        cli_dbgmsg("UPX/FSG: Broken or not UPX/FSG compressed file\n");
#line 1140
        free((void *)section_hdr);
#line 1141
        free((void *)src);
#line 1142
        free((void *)dest);
#line 1143
        return (0);
      } else {
#line 1145
        tmp___496 = cli_memstr("\021\333\021\311\001\333u\a\213\036\203\356\374\021\333\021\311\021\311u A\001\333",
                               24, (char const   *)(buff + 105), 13);
#line 1145
        if (tmp___496) {
#line 1146
          cli_dbgmsg("UPX: Looks like a NRV2B decompression routine\n");
#line 1147
          upxfn = & upx_inflate2b;
        } else {
#line 1145
          tmp___497 = cli_memstr("\021\333\021\311\001\333u\a\213\036\203\356\374\021\333\021\311\021\311u A\001\333",
                                 24, (char const   *)((buff + 105) + 8), 13);
#line 1145
          if (tmp___497) {
#line 1146
            cli_dbgmsg("UPX: Looks like a NRV2B decompression routine\n");
#line 1147
            upxfn = & upx_inflate2b;
          } else {
#line 1148
            tmp___494 = cli_memstr("\203\360\377tx\321\370\211\305\353\v\001\333u\a\213\036\203\356\374\021\333\021\311",
                                   24, (char const   *)(buff + 105), 13);
#line 1148
            if (tmp___494) {
#line 1149
              cli_dbgmsg("UPX: Looks like a NRV2D decompression routine\n");
#line 1150
              upxfn = & upx_inflate2d;
            } else {
#line 1148
              tmp___495 = cli_memstr("\203\360\377tx\321\370\211\305\353\v\001\333u\a\213\036\203\356\374\021\333\021\311",
                                     24, (char const   *)((buff + 105) + 8), 13);
#line 1148
              if (tmp___495) {
#line 1149
                cli_dbgmsg("UPX: Looks like a NRV2D decompression routine\n");
#line 1150
                upxfn = & upx_inflate2d;
              } else {
#line 1151
                tmp___492 = cli_memstr("\353R1\311\203\350\003r\021\301\340\b\212\006F\203\360\377tu\321\370\211\305",
                                       24, (char const   *)(buff + 105), 13);
#line 1151
                if (tmp___492) {
#line 1152
                  cli_dbgmsg("UPX: Looks like a NRV2E decompression routine\n");
#line 1153
                  upxfn = & upx_inflate2e;
                } else {
#line 1151
                  tmp___493 = cli_memstr("\353R1\311\203\350\003r\021\301\340\b\212\006F\203\360\377tu\321\370\211\305",
                                         24, (char const   *)((buff + 105) + 8), 13);
#line 1151
                  if (tmp___493) {
#line 1152
                    cli_dbgmsg("UPX: Looks like a NRV2E decompression routine\n");
#line 1153
                    upxfn = & upx_inflate2e;
                  }
                }
              }
            }
          }
        }
      }
#line 1157
      if (upxfn) {
#line 1158
        tmp___499 = cli_readint32((char const   *)(buff + 2));
#line 1158
        tmp___500 = EC32(optional_hdr.ImageBase);
#line 1158
        tmp___501 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1158
        skew = (int )(((unsigned int )tmp___499 - tmp___500) - tmp___501);
#line 1160
        if ((int )buff[1] != -66) {
          goto _L___85;
        } else {
#line 1160
          if (skew <= 0) {
            goto _L___85;
          } else {
#line 1160
            if (skew > 4095) {
              _L___85: 
#line 1161
              skew = 0;
#line 1162
              tmp___502 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1162
              tmp___503 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1162
              tmp___504 = EC32((section_hdr + i)->VirtualAddress);
#line 1162
              tmp___505 = ((*upxfn))(src, (int )ssize, dest, (int *)(& dsize), tmp___504,
                                     tmp___503, tmp___502);
#line 1162
              if (tmp___505 >= 0) {
#line 1163
                upx_success = 1U;
              }
            } else {
#line 1166
              cli_dbgmsg("UPX: UPX1 seems skewed by %d bytes\n", skew);
#line 1167
              tmp___506 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1167
              tmp___507 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1167
              tmp___508 = EC32((section_hdr + i)->VirtualAddress);
#line 1167
              tmp___509 = ((*upxfn))(src + skew, (int )(ssize - (unsigned int )skew),
                                     dest, (int *)(& dsize), tmp___508, tmp___507,
                                     tmp___506 - (unsigned int )skew);
#line 1167
              if (tmp___509 >= 0) {
#line 1168
                upx_success = 1U;
              } else {
#line 1167
                tmp___510 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1167
                tmp___511 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1167
                tmp___512 = EC32((section_hdr + i)->VirtualAddress);
#line 1167
                tmp___513 = ((*upxfn))(src, (int )ssize, dest, (int *)(& dsize), tmp___512,
                                       tmp___511, tmp___510);
#line 1167
                if (tmp___513 >= 0) {
#line 1168
                  upx_success = 1U;
                }
              }
            }
          }
        }
#line 1171
        if (upx_success) {
#line 1172
          cli_dbgmsg("UPX: Successfully decompressed\n");
        } else {
#line 1174
          cli_dbgmsg("UPX: Prefered decompressor failed\n");
        }
      }
#line 1177
      if (! upx_success) {
#line 1177
        if ((unsigned int )upxfn != (unsigned int )(& upx_inflate2b)) {
#line 1178
          tmp___514 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1178
          tmp___515 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1178
          tmp___516 = EC32((section_hdr + i)->VirtualAddress);
#line 1178
          tmp___517 = upx_inflate2b(src, (int )ssize, dest, (int *)(& dsize), tmp___516,
                                    tmp___515, tmp___514);
#line 1178
          if (tmp___517 == -1) {
#line 1178
            tmp___518 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1178
            tmp___519 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1178
            tmp___520 = EC32((section_hdr + i)->VirtualAddress);
#line 1178
            tmp___521 = upx_inflate2b(src + 21, (int )(ssize - 21U), dest, (int *)(& dsize),
                                      tmp___520, tmp___519, tmp___518 - 21U);
#line 1178
            if (tmp___521 == -1) {
#line 1180
              cli_dbgmsg("UPX: NRV2B decompressor failed\n");
            } else {
#line 1182
              upx_success = 1U;
#line 1183
              cli_dbgmsg("UPX: Successfully decompressed with NRV2B\n");
            }
          } else {
#line 1182
            upx_success = 1U;
#line 1183
            cli_dbgmsg("UPX: Successfully decompressed with NRV2B\n");
          }
        }
      }
#line 1187
      if (! upx_success) {
#line 1187
        if ((unsigned int )upxfn != (unsigned int )(& upx_inflate2d)) {
#line 1188
          tmp___522 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1188
          tmp___523 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1188
          tmp___524 = EC32((section_hdr + i)->VirtualAddress);
#line 1188
          tmp___525 = upx_inflate2d(src, (int )ssize, dest, (int *)(& dsize), tmp___524,
                                    tmp___523, tmp___522);
#line 1188
          if (tmp___525 == -1) {
#line 1188
            tmp___526 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1188
            tmp___527 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1188
            tmp___528 = EC32((section_hdr + i)->VirtualAddress);
#line 1188
            tmp___529 = upx_inflate2d(src + 21, (int )(ssize - 21U), dest, (int *)(& dsize),
                                      tmp___528, tmp___527, tmp___526 - 21U);
#line 1188
            if (tmp___529 == -1) {
#line 1190
              cli_dbgmsg("UPX: NRV2D decompressor failed\n");
            } else {
#line 1192
              upx_success = 1U;
#line 1193
              cli_dbgmsg("UPX: Successfully decompressed with NRV2D\n");
            }
          } else {
#line 1192
            upx_success = 1U;
#line 1193
            cli_dbgmsg("UPX: Successfully decompressed with NRV2D\n");
          }
        }
      }
#line 1197
      if (! upx_success) {
#line 1197
        if ((unsigned int )upxfn != (unsigned int )(& upx_inflate2e)) {
#line 1198
          tmp___530 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1198
          tmp___531 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1198
          tmp___532 = EC32((section_hdr + i)->VirtualAddress);
#line 1198
          tmp___533 = upx_inflate2e(src, (int )ssize, dest, (int *)(& dsize), tmp___532,
                                    tmp___531, tmp___530);
#line 1198
          if (tmp___533 == -1) {
#line 1198
            tmp___534 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1198
            tmp___535 = EC32((section_hdr + (i + 1U))->VirtualAddress);
#line 1198
            tmp___536 = EC32((section_hdr + i)->VirtualAddress);
#line 1198
            tmp___537 = upx_inflate2e(src + 21, (int )(ssize - 21U), dest, (int *)(& dsize),
                                      tmp___536, tmp___535, tmp___534 - 21U);
#line 1198
            if (tmp___537 == -1) {
#line 1199
              cli_dbgmsg("UPX: NRV2E decompressor failed\n");
            } else {
#line 1201
              upx_success = 1U;
#line 1202
              cli_dbgmsg("UPX: Successfully decompressed with NRV2E\n");
            }
          } else {
#line 1201
            upx_success = 1U;
#line 1202
            cli_dbgmsg("UPX: Successfully decompressed with NRV2E\n");
          }
        }
      }
#line 1206
      if (! upx_success) {
#line 1207
        cli_dbgmsg("UPX: All decompressors failed\n");
#line 1208
        free((void *)src);
#line 1209
        free((void *)dest);
      }
    }
#line 1213
    if (upx_success) {
#line 1214
      free((void *)src);
#line 1215
      free((void *)section_hdr);
#line 1217
      tempfile = cli_gentemp((char const   *)((void *)0));
#line 1218
      ndesc = open((char const   *)tempfile, 578, 448);
#line 1218
      if (ndesc < 0) {
#line 1219
        cli_dbgmsg("UPX/FSG: Can\'t create file %s\n", tempfile);
#line 1220
        free((void *)tempfile);
#line 1221
        free((void *)dest);
#line 1222
        return (-12);
      }
#line 1225
      tmp___538 = write(ndesc, (void const   *)dest, dsize);
#line 1225
      if ((unsigned int )tmp___538 != dsize) {
#line 1226
        cli_dbgmsg("UPX/FSG: Can\'t write %d bytes\n", dsize);
#line 1227
        free((void *)tempfile);
#line 1228
        free((void *)dest);
#line 1229
        close(ndesc);
#line 1230
        return (-12);
      }
#line 1233
      free((void *)dest);
#line 1234
      fsync(ndesc);
#line 1235
      lseek(ndesc, 0L, 0);
#line 1237
      if (cli_leavetemps_flag) {
#line 1238
        cli_dbgmsg("UPX/FSG: Decompressed data saved in %s\n", tempfile);
      }
#line 1240
      cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
#line 1241
      ret = cli_magic_scandesc(ndesc, virname, scanned, root, limits, options, arec,
                               mrec);
#line 1241
      if (ret == 1) {
#line 1242
        close(ndesc);
#line 1243
        if (! cli_leavetemps_flag) {
#line 1244
          unlink((char const   *)tempfile);
        }
#line 1245
        free((void *)tempfile);
#line 1246
        return (1);
      }
#line 1249
      close(ndesc);
#line 1250
      if (! cli_leavetemps_flag) {
#line 1251
        unlink((char const   *)tempfile);
      }
#line 1252
      free((void *)tempfile);
#line 1253
      return (ret);
    }
  }
#line 1259
  found = 2U;
#line 1261
  lseek(desc, (long )ep, 0);
#line 1262
  tmp___539 = read(desc, (void *)(buff), 200U);
#line 1262
  if (tmp___539 != 200) {
#line 1263
    cli_dbgmsg("Can\'t read 200 bytes\n");
#line 1264
    free((void *)section_hdr);
#line 1265
    return (-12);
  }
#line 1268
  if ((int )buff[0] != -72) {
    goto _L___86;
  } else {
#line 1268
    tmp___543 = cli_readint32((char const   *)(buff + 1));
#line 1268
    tmp___544 = EC32((section_hdr + ((int )nsections - 1))->VirtualAddress);
#line 1268
    tmp___545 = EC32(optional_hdr.ImageBase);
#line 1268
    if ((unsigned int )tmp___543 != tmp___544 + tmp___545) {
      _L___86: 
#line 1269
      if ((int )nsections < 2) {
#line 1270
        found = 0U;
      } else {
#line 1269
        if ((int )buff[0] != -72) {
#line 1270
          found = 0U;
        } else {
#line 1269
          tmp___540 = cli_readint32((char const   *)(buff + 1));
#line 1269
          tmp___541 = EC32((section_hdr + ((int )nsections - 2))->VirtualAddress);
#line 1269
          tmp___542 = EC32(optional_hdr.ImageBase);
#line 1269
          if ((unsigned int )tmp___540 != tmp___541 + tmp___542) {
#line 1270
            found = 0U;
          } else {
#line 1272
            found = 1U;
          }
        }
      }
    }
  }
#line 1275
  if (found) {
#line 1276
    cli_dbgmsg("Petite: v2.%d compression detected\n", found);
#line 1278
    tmp___561 = cli_readint32((char const   *)(buff + 128));
#line 1278
    if (tmp___561 == 373069965) {
#line 1279
      cli_dbgmsg("Petite: level zero compression is not supported yet\n");
    } else {
#line 1281
      dsize = max - min;
#line 1283
      if (limits) {
#line 1283
        if (limits->maxfilesize) {
#line 1283
          if ((unsigned long )dsize > limits->maxfilesize) {
#line 1284
            cli_dbgmsg("Petite: Size exceeded (dsize: %d, max: %lu)\n", dsize, limits->maxfilesize);
#line 1285
            free((void *)section_hdr);
#line 1286
            return (0);
          }
        }
      }
#line 1289
      dest = (char *)cli_calloc(dsize, sizeof(char ));
#line 1289
      if ((unsigned int )dest == (unsigned int )((void *)0)) {
#line 1290
        cli_dbgmsg("Petite: Can\'t allocate %d bytes\n", dsize);
#line 1291
        free((void *)section_hdr);
#line 1292
        return (-3);
      }
#line 1295
      i = 0U;
#line 1295
      while (i < (unsigned int )nsections) {
#line 1296
        if ((section_hdr + i)->SizeOfRawData) {
#line 1297
          tmp___547 = EC32((section_hdr + i)->VirtualAddress);
#line 1297
          tmp___548 = cli_rawaddr(tmp___547, section_hdr, nsections, & err);
#line 1297
          offset = tmp___548;
#line 1299
          if (err) {
#line 1300
            free((void *)section_hdr);
#line 1301
            free((void *)dest);
#line 1302
            return (-12);
          } else {
#line 1299
            tmp___549 = lseek(desc, (long )offset, 0);
#line 1299
            if (tmp___549 == -1L) {
#line 1300
              free((void *)section_hdr);
#line 1301
              free((void *)dest);
#line 1302
              return (-12);
            } else {
#line 1299
              tmp___550 = EC32((section_hdr + i)->SizeOfRawData);
#line 1299
              tmp___551 = EC32((section_hdr + i)->VirtualAddress);
#line 1299
              tmp___552 = read(desc, (void *)((dest + tmp___551) - min), tmp___550);
#line 1299
              tmp___553 = EC32((section_hdr + i)->SizeOfRawData);
#line 1299
              if ((unsigned int )tmp___552 != tmp___553) {
#line 1300
                free((void *)section_hdr);
#line 1301
                free((void *)dest);
#line 1302
                return (-12);
              }
            }
          }
        }
#line 1295
        i ++;
      }
#line 1307
      tempfile = cli_gentemp((char const   *)((void *)0));
#line 1308
      ndesc = open((char const   *)tempfile, 578, 448);
#line 1308
      if (ndesc < 0) {
#line 1309
        cli_dbgmsg("Petite: Can\'t create file %s\n", tempfile);
#line 1310
        free((void *)tempfile);
#line 1311
        free((void *)section_hdr);
#line 1312
        free((void *)dest);
#line 1313
        return (-12);
      }
#line 1317
      tmp___554 = EC32(optional_hdr.DataDirectory[2].Size);
#line 1317
      tmp___555 = EC32(optional_hdr.DataDirectory[2].VirtualAddress);
#line 1317
      tmp___556 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1317
      tmp___557 = EC32(optional_hdr.ImageBase);
#line 1317
      if (found == 1U) {
#line 1317
        tmp___558 = 1;
      } else {
#line 1317
        tmp___558 = 0;
      }
#line 1317
      tmp___559 = petite_inflate2x_1to9(dest, min, (int )(max - min), section_hdr,
                                        (int )nsections - tmp___558, tmp___557, tmp___556,
                                        ndesc, (int )found, tmp___555, tmp___554);
#line 1317
      switch (tmp___559) {
      case 1: 
#line 1323
      cli_dbgmsg("Petite: Unpacked and rebuilt executable saved in %s\n", tempfile);
#line 1324
      cli_dbgmsg("***** Scanning rebuilt PE file *****\n");
#line 1325
      break;
      case 0: 
#line 1328
      cli_dbgmsg("Petite: Unpacked data saved in %s\n", tempfile);
#line 1329
      break;
      default: 
#line 1332
      cli_dbgmsg("Petite: Unpacking failed\n");
      }
#line 1335
      free((void *)dest);
#line 1336
      fsync(ndesc);
#line 1337
      lseek(ndesc, 0L, 0);
#line 1339
      tmp___560 = cli_magic_scandesc(ndesc, virname, scanned, root, limits, options,
                                     arec, mrec);
#line 1339
      if (tmp___560 == 1) {
#line 1340
        free((void *)section_hdr);
#line 1341
        close(ndesc);
#line 1342
        if (! cli_leavetemps_flag) {
#line 1343
          unlink((char const   *)tempfile);
#line 1344
          free((void *)tempfile);
        } else {
#line 1346
          free((void *)tempfile);
        }
#line 1348
        return (1);
      }
#line 1351
      close(ndesc);
#line 1353
      if (! cli_leavetemps_flag) {
#line 1354
        unlink((char const   *)tempfile);
#line 1355
        free((void *)tempfile);
      } else {
#line 1357
        free((void *)tempfile);
      }
    }
  }
#line 1364
  free((void *)section_hdr);
#line 1365
  return (0);
}
}
#line 1368 "pe.c"
int cli_peheader(int desc , struct cli_pe_info *peinfo ) 
{ uint16_t e_magic ;
  uint32_t e_lfanew ;
  struct pe_image_file_hdr file_hdr ;
  struct pe_image_optional_hdr optional_hdr ;
  struct pe_image_section_hdr *section_hdr ;
  struct stat sb ;
  int i ;
  unsigned int err ;
  ssize_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  ssize_t tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___9 ;
  ssize_t tmp___11 ;
  uint32_t tmp___12 ;

  {
#line 1380
  cli_dbgmsg("in cli_peheader\n");
#line 1382
  tmp = read(desc, (void *)(& e_magic), sizeof(e_magic));
#line 1382
  if ((unsigned int )tmp != sizeof(e_magic)) {
#line 1383
    cli_dbgmsg("Can\'t read DOS signature\n");
#line 1384
    return (-1);
  }
#line 1387
  tmp___0 = EC16(e_magic);
#line 1387
  if ((int )tmp___0 != 23117) {
#line 1387
    tmp___1 = EC16(e_magic);
#line 1387
    if ((int )tmp___1 != 19802) {
#line 1388
      cli_dbgmsg("Invalid DOS signature\n");
#line 1389
      return (-1);
    }
  }
#line 1392
  lseek(desc, 58L, 1);
#line 1394
  tmp___2 = read(desc, (void *)(& e_lfanew), sizeof(e_lfanew));
#line 1394
  if ((unsigned int )tmp___2 != sizeof(e_lfanew)) {
#line 1395
    cli_dbgmsg("Can\'t read new header address\n");
#line 1397
    return (-1);
  }
#line 1400
  e_lfanew = EC32(e_lfanew);
#line 1401
  if (! e_lfanew) {
#line 1402
    cli_dbgmsg("Not a PE file\n");
#line 1403
    return (-1);
  }
#line 1406
  tmp___3 = lseek(desc, (long )e_lfanew, 0);
#line 1406
  if (tmp___3 < 0L) {
#line 1408
    cli_dbgmsg("Can\'t lseek to e_lfanew\n");
#line 1409
    return (-1);
  }
#line 1412
  tmp___4 = read(desc, (void *)(& file_hdr), sizeof(struct pe_image_file_hdr ));
#line 1412
  if ((unsigned int )tmp___4 != sizeof(struct pe_image_file_hdr )) {
#line 1414
    cli_dbgmsg("Can\'t read file header\n");
#line 1415
    return (-1);
  }
#line 1418
  tmp___5 = EC32(file_hdr.Magic);
#line 1418
  if (tmp___5 != 17744U) {
#line 1419
    cli_dbgmsg("Invalid PE signature (probably NE file)\n");
#line 1420
    return (-1);
  }
#line 1423
  tmp___6 = EC16(file_hdr.SizeOfOptionalHeader);
#line 1423
  if ((unsigned int )tmp___6 != sizeof(struct pe_image_optional_hdr )) {
#line 1424
    cli_warnmsg("Broken PE header detected.\n");
#line 1425
    return (-1);
  }
#line 1428
  peinfo->nsections = EC16(file_hdr.NumberOfSections);
#line 1430
  tmp___7 = read(desc, (void *)(& optional_hdr), sizeof(struct pe_image_optional_hdr ));
#line 1430
  if ((unsigned int )tmp___7 != sizeof(struct pe_image_optional_hdr )) {
#line 1431
    cli_dbgmsg("Can\'t optional file header\n");
#line 1432
    return (-1);
  }
#line 1435
  peinfo->section = (struct SECTION *)cli_calloc((unsigned int )peinfo->nsections,
                                                 sizeof(struct SECTION ));
#line 1437
  if (! peinfo->section) {
#line 1438
    cli_dbgmsg("Can\'t allocate memory for section headers\n");
#line 1439
    return (-1);
  }
#line 1442
  tmp___9 = fstat__extinline(desc, & sb);
#line 1442
  if (tmp___9 == -1) {
#line 1443
    cli_dbgmsg("fstat failed\n");
#line 1444
    free((void *)peinfo->section);
#line 1445
    return (-1);
  }
#line 1448
  section_hdr = (struct pe_image_section_hdr *)cli_calloc((unsigned int )peinfo->nsections,
                                                          sizeof(struct pe_image_section_hdr ));
#line 1450
  if (! section_hdr) {
#line 1451
    cli_dbgmsg("Can\'t allocate memory for section headers\n");
#line 1452
    free((void *)peinfo->section);
#line 1453
    return (-1);
  }
#line 1456
  i = 0;
#line 1456
  while (i < (int )peinfo->nsections) {
#line 1458
    tmp___11 = read(desc, (void *)(section_hdr + i), sizeof(struct pe_image_section_hdr ));
#line 1458
    if ((unsigned int )tmp___11 != sizeof(struct pe_image_section_hdr )) {
#line 1459
      cli_dbgmsg("Can\'t read section header\n");
#line 1460
      cli_dbgmsg("Possibly broken PE file\n");
#line 1461
      free((void *)section_hdr);
#line 1462
      free((void *)peinfo->section);
#line 1463
      return (-1);
    }
#line 1466
    (peinfo->section + i)->rva = EC32((section_hdr + i)->VirtualAddress);
#line 1467
    (peinfo->section + i)->vsz = EC32((section_hdr + i)->VirtualSize);
#line 1468
    (peinfo->section + i)->raw = EC32((section_hdr + i)->PointerToRawData);
#line 1469
    (peinfo->section + i)->rsz = EC32((section_hdr + i)->SizeOfRawData);
#line 1456
    i ++;
  }
#line 1472
  tmp___12 = EC32(optional_hdr.AddressOfEntryPoint);
#line 1472
  peinfo->ep = cli_rawaddr(tmp___12, section_hdr, peinfo->nsections, & err);
#line 1474
  if (err) {
#line 1475
    cli_dbgmsg("Possibly broken PE file\n");
#line 1476
    free((void *)section_hdr);
#line 1477
    free((void *)peinfo->section);
#line 1478
    return (-1);
  }
#line 1481
  free((void *)section_hdr);
#line 1482
  return (0);
}
}
#line 1 "cabd.lo"
#pragma merger(0,"/tmp/cil-QQT0Lwuj.i","-g -O2 -fPIC")
#line 33 "mspack/system.h"
struct mspack_system *mspack_default_system ;
#line 36
int mspack_sys_filelen(struct mspack_system *system___0 , struct mspack_file *file ,
                       off_t *length ) ;
#line 40
int mspack_valid_system(struct mspack_system *sys ) ;
#line 82 "mspack/mszip.h"
struct mszipd_stream *mszipd_init(struct mspack_system *system , struct mspack_file *input ,
                                  struct mspack_file *output , int input_buffer_size ,
                                  int repair_mode ) ;
#line 106
int mszipd_decompress(struct mszipd_stream *zip , off_t out_bytes ) ;
#line 112
void mszipd_free(struct mszipd_stream *zip ) ;
#line 88 "mspack/qtm.h"
struct qtmd_stream *qtmd_init(struct mspack_system *system , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int input_buffer_size ) ;
#line 112
int qtmd_decompress(struct qtmd_stream *qtm , off_t out_bytes ) ;
#line 118
void qtmd_free(struct qtmd_stream *qtm ) ;
#line 123 "mspack/lzx.h"
struct lzxd_stream *lzxd_init(struct mspack_system *system , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int reset_interval ,
                              int input_buffer_size , off_t output_length ) ;
#line 132
void lzxd_set_output_length(struct lzxd_stream *lzx , off_t out_bytes ) ;
#line 159
int lzxd_decompress(struct lzxd_stream *lzx , off_t out_bytes ) ;
#line 165
void lzxd_free(struct lzxd_stream *lzx ) ;
#line 81 "mspack/cabd.c"
static struct mscabd_cabinet *cabd_open(struct mscab_decompressor *base , char *filename ) ;
#line 83
static struct mscabd_cabinet *cabd_dopen(struct mscab_decompressor *base , int desc ) ;
#line 85
static void cabd_close(struct mscab_decompressor *base , struct mscabd_cabinet *origcab ) ;
#line 87
static int cabd_read_headers(struct mspack_system *sys , struct mspack_file *fh ,
                             struct mscabd_cabinet_p *cab , off_t offset , int quiet ) ;
#line 90
static char *cabd_read_string(struct mspack_system *sys , struct mspack_file *fh ,
                              struct mscabd_cabinet_p *cab , int *error ) ;
#line 94
static struct mscabd_cabinet *cabd_search(struct mscab_decompressor *base , char *filename ) ;
#line 96
static struct mscabd_cabinet *cabd_dsearch(struct mscab_decompressor *base , int desc ) ;
#line 98
static int cabd_find(struct mscab_decompressor_p *this , unsigned char *buf , struct mspack_file *fh ,
                     char *filename , int desc , off_t flen , unsigned int *firstlen ,
                     struct mscabd_cabinet_p **firstcab ) ;
#line 103
static int cabd_prepend(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                        struct mscabd_cabinet *prevcab ) ;
#line 106
static int cabd_append(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                       struct mscabd_cabinet *nextcab ) ;
#line 109
static int cabd_merge(struct mscab_decompressor *base , struct mscabd_cabinet *lcab ,
                      struct mscabd_cabinet *rcab ) ;
#line 113
static int cabd_extract(struct mscab_decompressor *base , struct mscabd_file *file ,
                        char *filename ) ;
#line 115
static int cabd_init_decomp(struct mscab_decompressor_p *this , unsigned int ct ) ;
#line 117
static void cabd_free_decomp(struct mscab_decompressor_p *this ) ;
#line 119
static int cabd_sys_read(struct mspack_file *file , void *buffer , int bytes ) ;
#line 121
static int cabd_sys_write(struct mspack_file *file , void *buffer , int bytes ) ;
#line 123
static int cabd_sys_read_block(struct mspack_system *sys , struct mscabd_decompress_state *d ,
                               int *out , int ignore_cksum ) ;
#line 126
static unsigned int cabd_checksum(unsigned char *data , unsigned int bytes , unsigned int cksum ) ;
#line 128
static struct noned_state *noned_init(struct mspack_system *sys , struct mspack_file *in ,
                                      struct mspack_file *out , int bufsize ) ;
#line 132
static int noned_decompress(struct noned_state *s , off_t bytes ) ;
#line 134
static void noned_free(struct noned_state *state ) ;
#line 137
static int cabd_param(struct mscab_decompressor *base , int param , int value ) ;
#line 140
static int cabd_error(struct mscab_decompressor *base ) ;
#line 149 "mspack/cabd.c"
struct mscab_decompressor *mspack_create_cab_decompressor(struct mspack_system *sys ) 
{ struct mscab_decompressor_p *this ;
  int tmp ;

  {
#line 152
  this = (struct mscab_decompressor_p *)((void *)0);
#line 154
  if (! sys) {
#line 154
    sys = mspack_default_system;
  }
#line 155
  tmp = mspack_valid_system(sys);
#line 155
  if (! tmp) {
#line 155
    return ((struct mscab_decompressor *)((void *)0));
  }
#line 157
  this = (struct mscab_decompressor_p *)((*(sys->alloc)))(sys, sizeof(struct mscab_decompressor_p ));
#line 157
  if (this) {
#line 158
    this->base.open = & cabd_open;
#line 159
    this->base.dopen = & cabd_dopen;
#line 160
    this->base.close = & cabd_close;
#line 161
    this->base.search = & cabd_search;
#line 162
    this->base.dsearch = & cabd_dsearch;
#line 163
    this->base.extract = & cabd_extract;
#line 164
    this->base.prepend = & cabd_prepend;
#line 165
    this->base.append = & cabd_append;
#line 166
    this->base.set_param = & cabd_param;
#line 167
    this->base.last_error = & cabd_error;
#line 168
    this->system = sys;
#line 169
    this->d = (struct mscabd_decompress_state *)((void *)0);
#line 170
    this->error = 0;
#line 172
    this->param[0] = 32768;
#line 173
    this->param[1] = 0;
#line 174
    this->param[2] = 4096;
  }
#line 176
  return ((struct mscab_decompressor *)this);
}
}
#line 184 "mspack/cabd.c"
void mspack_destroy_cab_decompressor(struct mscab_decompressor *base ) 
{ struct mscab_decompressor_p *this ;
  struct mspack_system *sys ;

  {
#line 185
  this = (struct mscab_decompressor_p *)base;
#line 186
  if (this) {
#line 187
    sys = this->system;
#line 188
    cabd_free_decomp(this);
#line 189
    if (this->d) {
#line 190
      if ((this->d)->infh) {
#line 190
        ((*(sys->close)))((this->d)->infh);
      }
#line 191
      ((*(sys->free)))((void *)this->d);
    }
#line 193
    ((*(sys->free)))((void *)this);
  }
#line 195
  return;
}
}
#line 203 "mspack/cabd.c"
static struct mscabd_cabinet *cabd_open(struct mscab_decompressor *base , char *filename ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  struct mspack_file *fh ;
  int error ;

  {
#line 206
  this = (struct mscab_decompressor_p *)base;
#line 207
  cab = (struct mscabd_cabinet_p *)((void *)0);
#line 212
  if (! base) {
#line 212
    return ((struct mscabd_cabinet *)((void *)0));
  }
#line 213
  sys = this->system;
#line 215
  fh = ((*(sys->open)))(sys, filename, 0);
#line 215
  if (fh) {
#line 216
    cab = (struct mscabd_cabinet_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_cabinet_p ));
#line 216
    if (cab) {
#line 217
      cab->base.filename = filename;
#line 219
      error = cabd_read_headers(sys, fh, cab, 0L, 0);
#line 220
      if (error) {
#line 221
        cabd_close(base, (struct mscabd_cabinet *)cab);
#line 222
        cab = (struct mscabd_cabinet_p *)((void *)0);
      }
#line 224
      this->error = error;
    } else {
#line 227
      this->error = 6;
    }
#line 229
    ((*(sys->close)))(fh);
  } else {
#line 232
    this->error = 2;
  }
#line 234
  return ((struct mscabd_cabinet *)cab);
}
}
#line 237 "mspack/cabd.c"
static struct mscabd_cabinet *cabd_dopen(struct mscab_decompressor *base , int desc ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  struct mspack_file *fh ;
  int error ;

  {
#line 240
  this = (struct mscab_decompressor_p *)base;
#line 241
  cab = (struct mscabd_cabinet_p *)((void *)0);
#line 246
  if (! base) {
#line 246
    return ((struct mscabd_cabinet *)((void *)0));
  }
#line 247
  sys = this->system;
#line 249
  fh = ((*(sys->dopen)))(sys, desc, 0);
#line 249
  if (fh) {
#line 250
    cab = (struct mscabd_cabinet_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_cabinet_p ));
#line 250
    if (cab) {
#line 251
      cab->base.filename = (char *)"descriptor";
#line 252
      cab->base.desc = dup(desc);
#line 253
      error = cabd_read_headers(sys, fh, cab, 0L, 0);
#line 254
      if (error) {
#line 255
        cabd_close(base, (struct mscabd_cabinet *)cab);
#line 256
        cab = (struct mscabd_cabinet_p *)((void *)0);
      }
#line 258
      this->error = error;
    } else {
#line 261
      this->error = 6;
    }
#line 263
    ((*(sys->close)))(fh);
  } else {
#line 266
    this->error = 2;
  }
#line 268
  return ((struct mscabd_cabinet *)cab);
}
}
#line 276 "mspack/cabd.c"
static void cabd_close(struct mscab_decompressor *base , struct mscabd_cabinet *origcab ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_folder_data *dat ;
  struct mscabd_folder_data *ndat ;
  struct mscabd_cabinet *cab ;
  struct mscabd_cabinet *ncab ;
  struct mscabd_folder *fol ;
  struct mscabd_folder *nfol ;
  struct mscabd_file *fi ;
  struct mscabd_file *nfi ;
  struct mspack_system *sys ;

  {
#line 279
  this = (struct mscab_decompressor_p *)base;
#line 287
  if (origcab->desc) {
#line 288
    close(origcab->desc);
  }
#line 290
  if (! base) {
#line 290
    return;
  }
#line 291
  sys = this->system;
#line 293
  this->error = 0;
#line 295
  while (origcab) {
#line 297
    fi = origcab->files;
#line 297
    while (fi) {
#line 298
      nfi = fi->next;
#line 299
      ((*(sys->free)))((void *)fi->filename);
#line 300
      ((*(sys->free)))((void *)fi);
#line 297
      fi = nfi;
    }
#line 304
    fol = origcab->folders;
#line 304
    while (fol) {
#line 305
      nfol = fol->next;
#line 308
      if (this->d) {
#line 308
        if ((unsigned int )(this->d)->folder == (unsigned int )((struct mscabd_folder_p *)fol)) {
#line 309
          if ((this->d)->infh) {
#line 309
            ((*(sys->close)))((this->d)->infh);
          }
#line 310
          cabd_free_decomp(this);
#line 311
          ((*(sys->free)))((void *)this->d);
#line 312
          this->d = (struct mscabd_decompress_state *)((void *)0);
        }
      }
#line 316
      dat = ((struct mscabd_folder_p *)fol)->data.next;
#line 316
      while (dat) {
#line 317
        ndat = dat->next;
#line 318
        ((*(sys->free)))((void *)dat);
#line 316
        dat = ndat;
      }
#line 320
      ((*(sys->free)))((void *)fol);
#line 304
      fol = nfol;
    }
#line 324
    cab = origcab;
#line 324
    while (cab) {
#line 325
      ncab = cab->prevcab;
#line 326
      ((*(sys->free)))((void *)cab->prevname);
#line 327
      ((*(sys->free)))((void *)cab->nextname);
#line 328
      ((*(sys->free)))((void *)cab->previnfo);
#line 329
      ((*(sys->free)))((void *)cab->nextinfo);
#line 330
      if ((unsigned int )cab != (unsigned int )origcab) {
#line 330
        ((*(sys->free)))((void *)cab);
      }
#line 324
      cab = ncab;
    }
#line 334
    cab = origcab->nextcab;
#line 334
    while (cab) {
#line 335
      ncab = cab->nextcab;
#line 336
      ((*(sys->free)))((void *)cab->prevname);
#line 337
      ((*(sys->free)))((void *)cab->nextname);
#line 338
      ((*(sys->free)))((void *)cab->previnfo);
#line 339
      ((*(sys->free)))((void *)cab->nextinfo);
#line 340
      ((*(sys->free)))((void *)cab);
#line 334
      cab = ncab;
    }
#line 344
    cab = origcab->next;
#line 345
    ((*(sys->free)))((void *)origcab);
#line 348
    origcab = cab;
  }
#line 350
  return;
}
}
#line 359 "mspack/cabd.c"
static int cabd_read_headers(struct mspack_system *sys , struct mspack_file *fh ,
                             struct mscabd_cabinet_p *cab , off_t offset , int quiet ) 
{ int num_folders ;
  int num_files ;
  int folder_resv ;
  int i ;
  int x ;
  struct mscabd_folder_p *fol ;
  struct mscabd_folder_p *linkfol ;
  struct mscabd_file *file ;
  struct mscabd_file *linkfile ;
  unsigned char buf[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct mscabd_folder *ifol ;
  int tmp___6 ;
  struct mscabd_folder *ifol___0 ;

  {
#line 365
  linkfol = (struct mscabd_folder_p *)((void *)0);
#line 366
  linkfile = (struct mscabd_file *)((void *)0);
#line 370
  cab->base.next = (struct mscabd_cabinet *)((void *)0);
#line 371
  cab->base.files = (struct mscabd_file *)((void *)0);
#line 372
  cab->base.folders = (struct mscabd_folder *)((void *)0);
#line 373
  cab->base.nextcab = (struct mscabd_cabinet *)((void *)0);
#line 373
  cab->base.prevcab = cab->base.nextcab;
#line 374
  cab->base.nextname = (char *)((void *)0);
#line 374
  cab->base.prevname = cab->base.nextname;
#line 375
  cab->base.nextinfo = (char *)((void *)0);
#line 375
  cab->base.previnfo = cab->base.nextinfo;
#line 377
  cab->base.base_offset = offset;
#line 380
  tmp = ((*(sys->seek)))(fh, offset, 0);
#line 380
  if (tmp) {
#line 381
    return (5);
  }
#line 385
  tmp___0 = ((*(sys->read)))(fh, (void *)(buf), 36);
#line 385
  if (tmp___0 != 36) {
#line 386
    return (3);
  }
#line 390
  if ((((((int )buf[3] << 24) | ((int )buf[2] << 16)) | ((int )buf[1] << 8)) | (int )buf[0]) !=
      1178817357) {
#line 391
    return (7);
  }
#line 395
  cab->base.length = (unsigned int )(((((int )(*(& buf[8] + 3)) << 24) | ((int )(*(& buf[8] +
                                                                                   2)) <<
                                                                          16)) | ((int )(*(& buf[8] +
                                                                                           1)) <<
                                                                                  8)) |
                                     (int )(*(& buf[8] + 0)));
#line 396
  cab->base.set_id = (unsigned short )(((int )(*(& buf[32] + 1)) << 8) | (int )(*(& buf[32] +
                                                                                  0)));
#line 397
  cab->base.set_index = (unsigned short )(((int )(*(& buf[34] + 1)) << 8) | (int )(*(& buf[34] +
                                                                                     0)));
#line 400
  num_folders = ((int )(*(& buf[26] + 1)) << 8) | (int )(*(& buf[26] + 0));
#line 401
  if (num_folders == 0) {
#line 402
    if (! quiet) {
#line 402
      ((*(sys->message)))(fh, (char *)"no folders in cabinet.");
    }
#line 403
    return (8);
  }
#line 407
  num_files = ((int )(*(& buf[28] + 1)) << 8) | (int )(*(& buf[28] + 0));
#line 408
  if (num_files == 0) {
#line 409
    if (! quiet) {
#line 409
      ((*(sys->message)))(fh, (char *)"no files in cabinet.");
    }
#line 410
    return (8);
  }
#line 414
  if ((int )buf[25] != 1) {
#line 414
    if ((int )buf[24] != 3) {
#line 415
      if (! quiet) {
#line 415
        ((*(sys->message)))(fh, (char *)"WARNING; cabinet version is not 1.3");
      }
    }
  }
#line 419
  cab->base.flags = ((int )(*(& buf[30] + 1)) << 8) | (int )(*(& buf[30] + 0));
#line 420
  if (cab->base.flags & 4) {
#line 421
    tmp___1 = ((*(sys->read)))(fh, (void *)(buf), 4);
#line 421
    if (tmp___1 != 4) {
#line 422
      return (3);
    }
#line 424
    cab->base.header_resv = (unsigned short )(((int )buf[1] << 8) | (int )buf[0]);
#line 425
    folder_resv = (int )buf[2];
#line 426
    cab->block_resv = (int )buf[3];
#line 428
    if ((int )cab->base.header_resv > 60000) {
#line 429
      if (! quiet) {
#line 429
        ((*(sys->message)))(fh, (char *)"WARNING; reserved header > 60000.");
      }
    }
#line 433
    if (cab->base.header_resv) {
#line 434
      tmp___2 = ((*(sys->seek)))(fh, (long )cab->base.header_resv, 1);
#line 434
      if (tmp___2) {
#line 435
        return (5);
      }
    }
  } else {
#line 440
    cab->base.header_resv = (unsigned short)0;
#line 441
    folder_resv = 0;
#line 442
    cab->block_resv = 0;
  }
#line 446
  if (cab->base.flags & 1) {
#line 447
    cab->base.prevname = cabd_read_string(sys, fh, cab, & x);
#line 447
    if (x) {
#line 447
      return (x);
    }
#line 448
    cab->base.previnfo = cabd_read_string(sys, fh, cab, & x);
#line 448
    if (x) {
#line 448
      return (x);
    }
  }
#line 452
  if (cab->base.flags & 2) {
#line 453
    cab->base.nextname = cabd_read_string(sys, fh, cab, & x);
#line 453
    if (x) {
#line 453
      return (x);
    }
#line 454
    cab->base.nextinfo = cabd_read_string(sys, fh, cab, & x);
#line 454
    if (x) {
#line 454
      return (x);
    }
  }
#line 458
  i = 0;
#line 458
  while (i < num_folders) {
#line 459
    tmp___3 = ((*(sys->read)))(fh, (void *)(buf), 8);
#line 459
    if (tmp___3 != 8) {
#line 460
      return (3);
    }
#line 462
    if (folder_resv) {
#line 463
      tmp___4 = ((*(sys->seek)))(fh, (long )folder_resv, 1);
#line 463
      if (tmp___4) {
#line 464
        return (5);
      }
    }
#line 468
    fol = (struct mscabd_folder_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_folder_p ));
#line 468
    if (! fol) {
#line 469
      return (6);
    }
#line 471
    fol->base.next = (struct mscabd_folder *)((void *)0);
#line 472
    fol->base.comp_type = ((int )(*(& buf[6] + 1)) << 8) | (int )(*(& buf[6] + 0));
#line 473
    fol->base.num_blocks = (unsigned int )(((int )(*(& buf[4] + 1)) << 8) | (int )(*(& buf[4] +
                                                                                     0)));
#line 474
    fol->data.next = (struct mscabd_folder_data *)((void *)0);
#line 475
    fol->data.cab = cab;
#line 476
    fol->data.offset = offset + (long )((unsigned int )(((((int )buf[3] << 24) | ((int )buf[2] <<
                                                                                  16)) |
                                                         ((int )buf[1] << 8)) | (int )buf[0]));
#line 478
    fol->merge_prev = (struct mscabd_file *)((void *)0);
#line 479
    fol->merge_next = (struct mscabd_file *)((void *)0);
#line 482
    if (! linkfol) {
#line 482
      cab->base.folders = (struct mscabd_folder *)fol;
    } else {
#line 483
      linkfol->base.next = (struct mscabd_folder *)fol;
    }
#line 484
    linkfol = fol;
#line 458
    i ++;
  }
#line 488
  i = 0;
#line 488
  while (i < num_files) {
#line 489
    tmp___5 = ((*(sys->read)))(fh, (void *)(buf), 16);
#line 489
    if (tmp___5 != 16) {
#line 490
      return (3);
    }
#line 493
    file = (struct mscabd_file *)((*(sys->alloc)))(sys, sizeof(struct mscabd_file ));
#line 493
    if (! file) {
#line 494
      return (6);
    }
#line 497
    file->next = (struct mscabd_file *)((void *)0);
#line 498
    file->length = (unsigned int )(((((int )buf[3] << 24) | ((int )buf[2] << 16)) |
                                    ((int )buf[1] << 8)) | (int )buf[0]);
#line 499
    file->attribs = ((int )(*(& buf[14] + 1)) << 8) | (int )(*(& buf[14] + 0));
#line 500
    file->offset = (unsigned int )(((((int )(*(& buf[4] + 3)) << 24) | ((int )(*(& buf[4] +
                                                                                 2)) <<
                                                                        16)) | ((int )(*(& buf[4] +
                                                                                         1)) <<
                                                                                8)) |
                                   (int )(*(& buf[4] + 0)));
#line 503
    x = ((int )(*(& buf[8] + 1)) << 8) | (int )(*(& buf[8] + 0));
#line 504
    if (x < 65533) {
#line 507
      ifol = cab->base.folders;
#line 508
      while (1) {
#line 508
        tmp___6 = x;
#line 508
        x --;
#line 508
        if (! tmp___6) {
#line 508
          break;
        }
#line 508
        if (ifol) {
#line 508
          ifol = ifol->next;
        }
      }
#line 509
      file->folder = ifol;
#line 511
      if (! ifol) {
#line 512
        ((*(sys->free)))((void *)file);
#line 514
        return (8);
      }
    } else {
#line 520
      if (x == 65534) {
        goto _L;
      } else {
#line 520
        if (x == 65535) {
          _L: 
#line 524
          ifol___0 = cab->base.folders;
#line 525
          while (ifol___0->next) {
#line 525
            ifol___0 = ifol___0->next;
          }
#line 526
          file->folder = ifol___0;
#line 529
          fol = (struct mscabd_folder_p *)ifol___0;
#line 530
          if (! fol->merge_next) {
#line 530
            fol->merge_next = file;
          }
        }
      }
#line 533
      if (x == 65533) {
        goto _L___0;
      } else {
#line 533
        if (x == 65535) {
          _L___0: 
#line 537
          file->folder = cab->base.folders;
#line 540
          fol = (struct mscabd_folder_p *)file->folder;
#line 541
          if (! fol->merge_prev) {
#line 541
            fol->merge_prev = file;
          }
        }
      }
    }
#line 546
    x = ((int )(*(& buf[12] + 1)) << 8) | (int )(*(& buf[12] + 0));
#line 547
    file->time_h = (char )(x >> 11);
#line 548
    file->time_m = (char )((x >> 5) & 63);
#line 549
    file->time_s = (char )((x << 1) & 62);
#line 552
    x = ((int )(*(& buf[10] + 1)) << 8) | (int )(*(& buf[10] + 0));
#line 553
    file->date_d = (char )(x & 31);
#line 554
    file->date_m = (char )((x >> 5) & 15);
#line 555
    file->date_y = (x >> 9) + 1980;
#line 558
    file->filename = cabd_read_string(sys, fh, cab, & x);
#line 559
    if (x) {
#line 560
      ((*(sys->free)))((void *)file);
#line 561
      return (x);
    }
#line 565
    if (! linkfile) {
#line 565
      cab->base.files = file;
    } else {
#line 566
      linkfile->next = file;
    }
#line 567
    linkfile = file;
#line 488
    i ++;
  }
#line 570
  return (0);
}
}
#line 573 "mspack/cabd.c"
static char *cabd_read_string(struct mspack_system *sys , struct mspack_file *fh ,
                              struct mscabd_cabinet_p *cab , int *error ) 
{ off_t base ;
  off_t tmp ;
  char buf[256] ;
  char *str ;
  unsigned int len ;
  unsigned int i ;
  unsigned int ok ;
  int tmp___0 ;

  {
#line 577
  tmp = ((*(sys->tell)))(fh);
#line 577
  base = tmp;
#line 582
  len = (unsigned int )((*(sys->read)))(fh, (void *)(buf), 256);
#line 585
  i = 0U;
#line 585
  ok = 0U;
#line 585
  while (i < len) {
#line 585
    if (! buf[i]) {
#line 585
      ok = 1U;
#line 585
      break;
    }
#line 585
    i ++;
  }
#line 586
  if (! ok) {
#line 587
    (*error) = 8;
#line 588
    return ((char *)((void *)0));
  }
#line 591
  len = i + 1U;
#line 594
  tmp___0 = ((*(sys->seek)))(fh, base + (long )len, 0);
#line 594
  if (tmp___0) {
#line 595
    (*error) = 5;
#line 596
    return ((char *)((void *)0));
  }
#line 599
  str = (char *)((*(sys->alloc)))(sys, len);
#line 599
  if (! str) {
#line 600
    (*error) = 6;
#line 601
    return ((char *)((void *)0));
  }
#line 604
  ((*(sys->copy)))((void *)(buf), (void *)str, len);
#line 605
  (*error) = 0;
#line 606
  return (str);
}
}
#line 620 "mspack/cabd.c"
static struct mscabd_cabinet *cabd_search(struct mscab_decompressor *base , char *filename ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  unsigned char *search_buf ;
  struct mspack_file *fh ;
  unsigned int firstlen ;
  off_t filelen ;

  {
#line 623
  this = (struct mscab_decompressor_p *)base;
#line 624
  cab = (struct mscabd_cabinet_p *)((void *)0);
#line 628
  firstlen = 0U;
#line 631
  if (! base) {
#line 631
    return ((struct mscabd_cabinet *)((void *)0));
  }
#line 632
  sys = this->system;
#line 635
  search_buf = (unsigned char *)((*(sys->alloc)))(sys, (unsigned int )this->param[0]);
#line 636
  if (! search_buf) {
#line 637
    this->error = 6;
#line 638
    return ((struct mscabd_cabinet *)((void *)0));
  }
#line 642
  fh = ((*(sys->open)))(sys, filename, 0);
#line 642
  if (fh) {
#line 643
    this->error = mspack_sys_filelen(sys, fh, & filelen);
#line 643
    if (! this->error) {
#line 644
      this->error = cabd_find(this, search_buf, fh, filename, 0, filelen, & firstlen,
                              & cab);
    }
#line 649
    if (firstlen) {
#line 649
      if ((unsigned long )firstlen != (unsigned long )filelen) {
#line 649
        if (! cab) {
          goto _L;
        } else {
#line 649
          if (cab->base.base_offset == 0L) {
            _L: 
#line 652
            if ((unsigned long )firstlen < (unsigned long )filelen) {
#line 653
              ((*(sys->message)))(fh, (char *)"WARNING; possible %u extra bytes at end of file.",
                                  (unsigned int )((unsigned long )filelen - (unsigned long )firstlen));
            } else {
#line 657
              ((*(sys->message)))(fh, (char *)"WARNING; file possibly truncated by %u bytes.",
                                  (unsigned int )((unsigned long )firstlen - (unsigned long )filelen));
            }
          }
        }
      }
    }
#line 662
    ((*(sys->close)))(fh);
  } else {
#line 665
    this->error = 2;
  }
#line 669
  ((*(sys->free)))((void *)search_buf);
#line 671
  return ((struct mscabd_cabinet *)cab);
}
}
#line 674 "mspack/cabd.c"
static struct mscabd_cabinet *cabd_dsearch(struct mscab_decompressor *base , int desc ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_cabinet_p *cab ;
  struct mspack_system *sys ;
  unsigned char *search_buf ;
  struct mspack_file *fh ;
  unsigned int firstlen ;
  off_t filelen ;
  char *filename ;

  {
#line 677
  this = (struct mscab_decompressor_p *)base;
#line 678
  cab = (struct mscabd_cabinet_p *)((void *)0);
#line 682
  firstlen = 0U;
#line 684
  filename = (char *)"descriptor";
#line 686
  if (! base) {
#line 686
    return ((struct mscabd_cabinet *)((void *)0));
  }
#line 687
  sys = this->system;
#line 690
  search_buf = (unsigned char *)((*(sys->alloc)))(sys, (unsigned int )this->param[0]);
#line 691
  if (! search_buf) {
#line 692
    this->error = 6;
#line 693
    return ((struct mscabd_cabinet *)((void *)0));
  }
#line 697
  fh = ((*(sys->dopen)))(sys, desc, 0);
#line 697
  if (fh) {
#line 698
    this->error = mspack_sys_filelen(sys, fh, & filelen);
#line 698
    if (! this->error) {
#line 699
      this->error = cabd_find(this, search_buf, fh, filename, desc, filelen, & firstlen,
                              & cab);
    }
#line 704
    if (firstlen) {
#line 704
      if ((unsigned long )firstlen != (unsigned long )filelen) {
#line 704
        if (! cab) {
          goto _L;
        } else {
#line 704
          if (cab->base.base_offset == 0L) {
            _L: 
#line 707
            if ((unsigned long )firstlen < (unsigned long )filelen) {
#line 708
              ((*(sys->message)))(fh, (char *)"WARNING; possible %u extra bytes at end of file.",
                                  (unsigned int )((unsigned long )filelen - (unsigned long )firstlen));
            } else {
#line 712
              ((*(sys->message)))(fh, (char *)"WARNING; file possibly truncated by %u bytes.",
                                  (unsigned int )((unsigned long )firstlen - (unsigned long )filelen));
            }
          }
        }
      }
    }
#line 717
    ((*(sys->close)))(fh);
  } else {
#line 720
    this->error = 2;
  }
#line 724
  ((*(sys->free)))((void *)search_buf);
#line 726
  return ((struct mscabd_cabinet *)cab);
}
}
#line 730 "mspack/cabd.c"
static int cabd_find(struct mscab_decompressor_p *this , unsigned char *buf , struct mspack_file *fh ,
                     char *filename , int desc , off_t flen , unsigned int *firstlen ,
                     struct mscabd_cabinet_p **firstcab ) 
{ struct mscabd_cabinet_p *cab ;
  struct mscabd_cabinet_p *link___0 ;
  off_t caboff ;
  off_t offset ;
  off_t foffset ;
  off_t cablen ;
  struct mspack_system *sys ;
  unsigned char *p ;
  unsigned char *pend ;
  unsigned char state ;
  int false_cabs ;
  int length ;
  int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 735
  link___0 = (struct mscabd_cabinet_p *)((void *)0);
#line 736
  foffset = 0L;
#line 736
  cablen = 0L;
#line 737
  sys = this->system;
#line 738
  state = (unsigned char)0;
#line 739
  false_cabs = 0;
#line 742
  offset = 0L;
#line 742
  while (offset < flen) {
#line 745
    length = (int )(flen - offset);
#line 746
    if (length > this->param[0]) {
#line 747
      length = this->param[0];
    }
#line 751
    tmp = ((*(sys->read)))(fh, (void *)(buf + 0), length);
#line 751
    if (tmp != length) {
#line 752
      return (3);
    }
#line 756
    if (offset == 0L) {
#line 756
      if ((((((int )(*((buf + 0) + 3)) << 24) | ((int )(*((buf + 0) + 2)) << 16)) |
            ((int )(*((buf + 0) + 1)) << 8)) | (int )(*((buf + 0) + 0))) == 677598025) {
#line 757
        ((*(sys->message)))(fh, (char *)"WARNING; found InstallShield header. This is probably an InstallShield file. Use UNSHIELD (http://synce.sf.net) to unpack it.");
      }
    }
#line 763
    p = buf + 0;
#line 763
    pend = buf + length;
#line 763
    while ((unsigned int )p < (unsigned int )pend) {
#line 764
      switch ((int )state) {
      case 0: ;
#line 769
      while (1) {
#line 769
        if ((unsigned int )p < (unsigned int )pend) {
#line 769
          if (! ((int )(*p) != 77)) {
#line 769
            break;
          }
        } else {
#line 769
          break;
        }
#line 769
        p ++;
      }
#line 771
      tmp___0 = p;
#line 771
      p ++;
#line 771
      if ((unsigned int )tmp___0 < (unsigned int )pend) {
#line 771
        state = (unsigned char)1;
      }
#line 772
      break;
      case 1: 
#line 775
      tmp___2 = p;
#line 775
      p ++;
#line 775
      if ((int )(*tmp___2) == 83) {
#line 775
        state = (unsigned char)2;
      } else {
#line 775
        state = (unsigned char)0;
      }
#line 775
      break;
      case 2: 
#line 776
      tmp___4 = p;
#line 776
      p ++;
#line 776
      if ((int )(*tmp___4) == 67) {
#line 776
        state = (unsigned char)3;
      } else {
#line 776
        state = (unsigned char)0;
      }
#line 776
      break;
      case 3: 
#line 777
      tmp___6 = p;
#line 777
      p ++;
#line 777
      if ((int )(*tmp___6) == 70) {
#line 777
        state = (unsigned char)4;
      } else {
#line 777
        state = (unsigned char)0;
      }
#line 777
      break;
      case 8: 
#line 782
      tmp___7 = p;
#line 782
      p ++;
#line 782
      cablen = (long )(*tmp___7);
#line 782
      state = (unsigned char )((int )state + 1);
#line 782
      break;
      case 9: 
#line 783
      tmp___8 = p;
#line 783
      p ++;
#line 783
      cablen |= (long )((int )(*tmp___8) << 8);
#line 783
      state = (unsigned char )((int )state + 1);
#line 783
      break;
      case 10: 
#line 784
      tmp___9 = p;
#line 784
      p ++;
#line 784
      cablen |= (long )((int )(*tmp___9) << 16);
#line 784
      state = (unsigned char )((int )state + 1);
#line 784
      break;
      case 11: 
#line 785
      tmp___10 = p;
#line 785
      p ++;
#line 785
      cablen |= (long )((int )(*tmp___10) << 24);
#line 785
      state = (unsigned char )((int )state + 1);
#line 785
      break;
      case 16: 
#line 790
      tmp___11 = p;
#line 790
      p ++;
#line 790
      foffset = (long )(*tmp___11);
#line 790
      state = (unsigned char )((int )state + 1);
#line 790
      break;
      case 17: 
#line 791
      tmp___12 = p;
#line 791
      p ++;
#line 791
      foffset |= (long )((int )(*tmp___12) << 8);
#line 791
      state = (unsigned char )((int )state + 1);
#line 791
      break;
      case 18: 
#line 792
      tmp___13 = p;
#line 792
      p ++;
#line 792
      foffset |= (long )((int )(*tmp___13) << 16);
#line 792
      state = (unsigned char )((int )state + 1);
#line 792
      break;
      case 19: 
#line 793
      tmp___14 = p;
#line 793
      p ++;
#line 793
      foffset |= (long )((int )(*tmp___14) << 24);
#line 796
      caboff = (offset + (long )(p - (buf + 0))) - 20L;
#line 799
      offset = caboff + 4L;
#line 804
      if (caboff == 0L) {
#line 804
        (*firstlen) = (unsigned int )cablen;
      }
#line 809
      if (foffset < cablen) {
#line 809
        if (caboff + foffset < flen + 32L) {
#line 809
          if (caboff + cablen < flen + 32L) {
#line 814
            cab = (struct mscabd_cabinet_p *)((*(sys->alloc)))(sys, sizeof(struct mscabd_cabinet_p ));
#line 814
            if (! cab) {
#line 815
              return (6);
            }
#line 817
            cab->base.filename = filename;
#line 818
            cab->base.desc = dup(desc);
#line 819
            tmp___15 = cabd_read_headers(sys, fh, cab, caboff, 1);
#line 819
            if (tmp___15) {
#line 821
              cabd_close((struct mscab_decompressor *)this, (struct mscabd_cabinet *)cab);
#line 823
              false_cabs ++;
            } else {
#line 829
              offset = caboff + cablen;
#line 832
              if (! link___0) {
#line 832
                (*firstcab) = cab;
              } else {
#line 833
                link___0->base.next = (struct mscabd_cabinet *)cab;
              }
#line 834
              link___0 = cab;
            }
          }
        }
      }
#line 839
      if (offset >= flen) {
#line 839
        return (0);
      }
#line 840
      tmp___16 = ((*(sys->seek)))(fh, offset, 0);
#line 840
      if (tmp___16) {
#line 841
        return (5);
      }
#line 842
      length = 0;
#line 843
      p = pend;
#line 844
      state = (unsigned char)0;
#line 845
      break;
      default: 
#line 849
      p ++;
#line 849
      state = (unsigned char )((int )state + 1);
      }
    }
#line 742
    offset += (long )length;
  }
#line 854
  if (false_cabs) {

  }
#line 858
  return (0);
}
}
#line 869 "mspack/cabd.c"
static int cabd_prepend(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                        struct mscabd_cabinet *prevcab ) 
{ int tmp ;

  {
#line 873
  tmp = cabd_merge(base, prevcab, cab);
#line 873
  return (tmp);
}
}
#line 876 "mspack/cabd.c"
static int cabd_append(struct mscab_decompressor *base , struct mscabd_cabinet *cab ,
                       struct mscabd_cabinet *nextcab ) 
{ int tmp ;

  {
#line 880
  tmp = cabd_merge(base, cab, nextcab);
#line 880
  return (tmp);
}
}
#line 883 "mspack/cabd.c"
static int cabd_merge(struct mscab_decompressor *base , struct mscabd_cabinet *lcab ,
                      struct mscabd_cabinet *rcab ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_folder_data *data ;
  struct mscabd_folder_data *ndata ;
  struct mscabd_folder_p *lfol ;
  struct mscabd_folder_p *rfol ;
  struct mscabd_file *fi ;
  struct mscabd_file *rfi ;
  struct mscabd_file *lfi ;
  struct mscabd_cabinet *cab ;
  struct mspack_system *sys ;

  {
#line 887
  this = (struct mscab_decompressor_p *)base;
#line 894
  if (! this) {
#line 894
    return (1);
  }
#line 895
  sys = this->system;
#line 898
  if (! lcab) {
#line 900
    this->error = 1;
#line 900
    return (this->error);
  } else {
#line 898
    if (! rcab) {
#line 900
      this->error = 1;
#line 900
      return (this->error);
    } else {
#line 898
      if ((unsigned int )lcab == (unsigned int )rcab) {
#line 900
        this->error = 1;
#line 900
        return (this->error);
      }
    }
  }
#line 904
  if (lcab->nextcab) {
#line 906
    this->error = 1;
#line 906
    return (this->error);
  } else {
#line 904
    if (rcab->prevcab) {
#line 906
      this->error = 1;
#line 906
      return (this->error);
    }
  }
#line 910
  cab = lcab->prevcab;
#line 910
  while (cab) {
#line 911
    if ((unsigned int )cab == (unsigned int )rcab) {
#line 911
      this->error = 1;
#line 911
      return (this->error);
    }
#line 910
    cab = cab->prevcab;
  }
#line 913
  cab = rcab->nextcab;
#line 913
  while (cab) {
#line 914
    if ((unsigned int )cab == (unsigned int )lcab) {
#line 914
      this->error = 1;
#line 914
      return (this->error);
    }
#line 913
    cab = cab->nextcab;
  }
#line 918
  if ((int )lcab->set_id != (int )rcab->set_id) {
#line 919
    ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"WARNING; merged cabinets with differing Set IDs.");
  }
#line 922
  if ((int )lcab->set_index > (int )rcab->set_index) {
#line 923
    ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"WARNING; merged cabinets with odd order.");
  }
#line 927
  lfol = (struct mscabd_folder_p *)lcab->folders;
#line 928
  rfol = (struct mscabd_folder_p *)rcab->folders;
#line 929
  while (lfol->base.next) {
#line 929
    lfol = (struct mscabd_folder_p *)lfol->base.next;
  }
#line 932
  if (! lfol->merge_next) {
#line 932
    if (! rfol->merge_prev) {
#line 936
      lcab->nextcab = rcab;
#line 937
      rcab->prevcab = lcab;
#line 940
      lfol->base.next = (struct mscabd_folder *)rfol;
#line 943
      fi = lcab->files;
#line 944
      while (fi->next) {
#line 944
        fi = fi->next;
      }
#line 945
      fi->next = rcab->files;
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 950
    if (! lfol->merge_next) {
#line 952
      this->error = 8;
#line 952
      return (this->error);
    }
#line 955
    if (! rfol->merge_prev) {
#line 957
      this->error = 8;
#line 957
      return (this->error);
    }
#line 961
    if (lfol->base.comp_type != rfol->base.comp_type) {
#line 963
      this->error = 8;
#line 963
      return (this->error);
    }
#line 969
    lfi = lfol->merge_next;
#line 970
    rfi = rfol->merge_prev;
#line 971
    while (lfi) {
#line 972
      if (! rfi) {
#line 974
        this->error = 8;
#line 974
        return (this->error);
      } else {
#line 972
        if (lfi->offset != rfi->offset) {
#line 974
          this->error = 8;
#line 974
          return (this->error);
        }
      }
#line 976
      lfi = lfi->next;
#line 977
      rfi = rfi->next;
    }
#line 981
    data = (struct mscabd_folder_data *)((*(sys->alloc)))(sys, sizeof(struct mscabd_folder_data ));
#line 981
    if (! data) {
#line 982
      this->error = 6;
#line 982
      return (this->error);
    }
#line 986
    lcab->nextcab = rcab;
#line 987
    rcab->prevcab = lcab;
#line 990
    ndata = & lfol->data;
#line 991
    while (ndata->next) {
#line 991
      ndata = ndata->next;
    }
#line 992
    ndata->next = data;
#line 993
    (*data) = rfol->data;
#line 994
    rfol->data.next = (struct mscabd_folder_data *)((void *)0);
#line 1000
    lfol->base.num_blocks = lfol->base.num_blocks + (rfol->base.num_blocks - 1U);
#line 1001
    if ((unsigned int )rfol->merge_next == (unsigned int )((void *)0)) {
#line 1004
      lfol->merge_next = rfol->merge_next;
    } else {
#line 1001
      if ((unsigned int )(rfol->merge_next)->folder != (unsigned int )((struct mscabd_folder *)rfol)) {
#line 1004
        lfol->merge_next = rfol->merge_next;
      }
    }
#line 1008
    while (lfol->base.next) {
#line 1008
      lfol = (struct mscabd_folder_p *)lfol->base.next;
    }
#line 1009
    lfol->base.next = rfol->base.next;
#line 1012
    ((*(sys->free)))((void *)rfol);
#line 1015
    fi = lcab->files;
#line 1016
    while (fi->next) {
#line 1016
      fi = fi->next;
    }
#line 1017
    fi->next = rcab->files;
#line 1020
    lfi = (struct mscabd_file *)((void *)0);
#line 1021
    fi = lcab->files;
#line 1021
    while (fi) {
#line 1022
      rfi = fi->next;
#line 1024
      if ((unsigned int )fi->folder == (unsigned int )((struct mscabd_folder *)rfol)) {
#line 1025
        if (lfi) {
#line 1025
          lfi->next = rfi;
        } else {
#line 1025
          lcab->files = rfi;
        }
#line 1026
        ((*(sys->free)))((void *)fi->filename);
#line 1027
        ((*(sys->free)))((void *)fi);
      } else {
#line 1029
        lfi = fi;
      }
#line 1021
      fi = rfi;
    }
  }
#line 1035
  cab = lcab->prevcab;
#line 1035
  while (cab) {
#line 1036
    cab->files = lcab->files;
#line 1037
    cab->folders = lcab->folders;
#line 1035
    cab = cab->prevcab;
  }
#line 1040
  cab = lcab->nextcab;
#line 1040
  while (cab) {
#line 1041
    cab->files = lcab->files;
#line 1042
    cab->folders = lcab->folders;
#line 1040
    cab = cab->nextcab;
  }
#line 1045
  this->error = 0;
#line 1045
  return (this->error);
}
}
#line 1053 "mspack/cabd.c"
static int cabd_extract(struct mscab_decompressor *base , struct mscabd_file *file ,
                        char *filename ) 
{ struct mscab_decompressor_p *this ;
  struct mscabd_folder_p *fol ;
  struct mspack_system *sys ;
  struct mspack_file *fh ;
  int tmp ;
  int tmp___0 ;
  off_t bytes ;
  int error ;

  {
#line 1056
  this = (struct mscab_decompressor_p *)base;
#line 1061
  if (! this) {
#line 1061
    return (1);
  }
#line 1062
  if (! file) {
#line 1062
    this->error = 1;
#line 1062
    return (this->error);
  }
#line 1064
  sys = this->system;
#line 1065
  fol = (struct mscabd_folder_p *)file->folder;
#line 1068
  if (! fol) {
#line 1071
    ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"ERROR; file \"%s\" cannot be extracted, cabinet set is incomplete.",
                        file->filename);
#line 1073
    this->error = 8;
#line 1073
    return (this->error);
  } else {
#line 1068
    if (fol->merge_prev) {
#line 1071
      ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"ERROR; file \"%s\" cannot be extracted, cabinet set is incomplete.",
                          file->filename);
#line 1073
      this->error = 8;
#line 1073
      return (this->error);
    } else {
#line 1068
      if ((file->offset + file->length) / 32768U > fol->base.num_blocks) {
#line 1071
        ((*(sys->message)))((struct mspack_file *)((void *)0), (char *)"ERROR; file \"%s\" cannot be extracted, cabinet set is incomplete.",
                            file->filename);
#line 1073
        this->error = 8;
#line 1073
        return (this->error);
      }
    }
  }
#line 1077
  if (! this->d) {
#line 1078
    this->d = (struct mscabd_decompress_state *)((*(sys->alloc)))(sys, sizeof(struct mscabd_decompress_state ));
#line 1079
    if (! this->d) {
#line 1079
      this->error = 6;
#line 1079
      return (this->error);
    }
#line 1080
    (this->d)->folder = (struct mscabd_folder_p *)((void *)0);
#line 1081
    (this->d)->data = (struct mscabd_folder_data *)((void *)0);
#line 1082
    (this->d)->sys = (*sys);
#line 1083
    (this->d)->sys.read = & cabd_sys_read;
#line 1084
    (this->d)->sys.write = & cabd_sys_write;
#line 1085
    (this->d)->state = (void *)0;
#line 1086
    (this->d)->infh = (struct mspack_file *)((void *)0);
#line 1087
    (this->d)->incab = (struct mscabd_cabinet_p *)((void *)0);
  }
#line 1091
  if ((unsigned int )(this->d)->folder != (unsigned int )fol) {
    goto _L___0;
  } else {
#line 1091
    if ((this->d)->offset > file->offset) {
      _L___0: 
#line 1094
      if (! (this->d)->infh) {
        goto _L;
      } else {
#line 1094
        if ((unsigned int )fol->data.cab != (unsigned int )(this->d)->incab) {
          _L: 
#line 1095
          if ((this->d)->infh) {
#line 1095
            ((*(sys->close)))((this->d)->infh);
          }
#line 1096
          (this->d)->incab = fol->data.cab;
#line 1098
          if ((fol->data.cab)->base.desc) {
#line 1099
            (this->d)->infh = ((*(sys->dopen)))(sys, (fol->data.cab)->base.desc, 0);
          } else {
#line 1102
            (this->d)->infh = ((*(sys->open)))(sys, (fol->data.cab)->base.filename,
                                               0);
          }
#line 1105
          if (! (this->d)->infh) {
#line 1105
            this->error = 2;
#line 1105
            return (this->error);
          }
        }
      }
#line 1109
      tmp = ((*(sys->seek)))((this->d)->infh, fol->data.offset, 0);
#line 1109
      if (tmp) {
#line 1110
        this->error = 5;
#line 1110
        return (this->error);
      }
#line 1114
      tmp___0 = cabd_init_decomp(this, (unsigned int )fol->base.comp_type);
#line 1114
      if (tmp___0) {
#line 1115
        return (this->error);
      }
#line 1119
      (this->d)->folder = fol;
#line 1120
      (this->d)->data = & fol->data;
#line 1121
      (this->d)->offset = 0U;
#line 1122
      (this->d)->block = 0U;
#line 1123
      (this->d)->i_end = & (this->d)->input[0];
#line 1123
      (this->d)->i_ptr = (this->d)->i_end;
    }
  }
#line 1127
  fh = ((*(sys->open)))(sys, filename, 1);
#line 1127
  if (! fh) {
#line 1128
    this->error = 2;
#line 1128
    return (this->error);
  }
#line 1131
  this->error = 0;
#line 1134
  if (file->length) {
#line 1142
    (this->d)->outfh = (struct mspack_file *)((void *)0);
#line 1143
    bytes = (long )(file->offset - (this->d)->offset);
#line 1143
    if (bytes) {
#line 1144
      error = ((*((this->d)->decompress)))((this->d)->state, bytes);
#line 1145
      if (error != 3) {
#line 1145
        this->error = error;
      }
    }
#line 1149
    if (! this->error) {
#line 1150
      (this->d)->outfh = fh;
#line 1151
      error = ((*((this->d)->decompress)))((this->d)->state, (long )file->length);
#line 1152
      if (error != 3) {
#line 1152
        this->error = error;
      }
    }
  }
#line 1157
  ((*(sys->close)))(fh);
#line 1158
  (this->d)->outfh = (struct mspack_file *)((void *)0);
#line 1160
  return (this->error);
}
}
#line 1173 "mspack/cabd.c"
static int cabd_init_decomp(struct mscab_decompressor_p *this , unsigned int ct ) 
{ struct mspack_file *fh ;

  {
#line 1175
  fh = (struct mspack_file *)this;
#line 1177
  if (! this) {
#line 1178
    this->error = 1;
#line 1178
    return (this->error);
  } else {
#line 1177
    if (! this->d) {
#line 1178
      this->error = 1;
#line 1178
      return (this->error);
    }
  }
#line 1182
  cabd_free_decomp(this);
#line 1184
  (this->d)->comp_type = (int )ct;
#line 1186
  switch ((int )(ct & 15U)) {
  case 0: 
#line 1188
  (this->d)->decompress = (int (*)(void * , off_t  ))(& noned_decompress);
#line 1189
  (this->d)->state = (void *)noned_init(& (this->d)->sys, fh, fh, this->param[2]);
#line 1191
  break;
  case 1: 
#line 1193
  (this->d)->decompress = (int (*)(void * , off_t  ))(& mszipd_decompress);
#line 1194
  (this->d)->state = (void *)mszipd_init(& (this->d)->sys, fh, fh, this->param[2],
                                         this->param[1]);
#line 1197
  break;
  case 2: 
#line 1199
  (this->d)->decompress = (int (*)(void * , off_t  ))(& qtmd_decompress);
#line 1200
  (this->d)->state = (void *)qtmd_init(& (this->d)->sys, fh, fh, (int )(ct >> 8) &
                                                                 31, this->param[2]);
#line 1202
  break;
  case 3: 
#line 1204
  (this->d)->decompress = (int (*)(void * , off_t  ))(& lzxd_decompress);
#line 1205
  (this->d)->state = (void *)lzxd_init(& (this->d)->sys, fh, fh, (int )(ct >> 8) &
                                                                 31, 0, this->param[2],
                                       0L);
#line 1207
  break;
  default: 
#line 1209
  this->error = 8;
#line 1209
  return (this->error);
  }
#line 1211
  if ((this->d)->state) {
#line 1211
    this->error = 0;
  } else {
#line 1211
    this->error = 6;
  }
#line 1211
  return (this->error);
}
}
#line 1214 "mspack/cabd.c"
static void cabd_free_decomp(struct mscab_decompressor_p *this ) 
{ 

  {
#line 1215
  if (! this) {
#line 1215
    return;
  } else {
#line 1215
    if (! this->d) {
#line 1215
      return;
    } else {
#line 1215
      if (! (this->d)->folder) {
#line 1215
        return;
      } else {
#line 1215
        if (! (this->d)->state) {
#line 1215
          return;
        }
      }
    }
  }
#line 1217
  switch ((this->d)->comp_type & 15) {
  case 0: 
#line 1218
  noned_free((struct noned_state *)(this->d)->state);
#line 1218
  break;
  case 1: 
#line 1219
  mszipd_free((struct mszipd_stream *)(this->d)->state);
#line 1219
  break;
  case 2: 
#line 1220
  qtmd_free((struct qtmd_stream *)(this->d)->state);
#line 1220
  break;
  case 3: 
#line 1221
  lzxd_free((struct lzxd_stream *)(this->d)->state);
#line 1221
  break;
  }
#line 1223
  (this->d)->decompress = (int (*)(void * , off_t  ))((void *)0);
#line 1224
  (this->d)->state = (void *)0;
#line 1225
  return;
}
}
#line 1239 "mspack/cabd.c"
static int cabd_sys_read(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mscab_decompressor_p *this ;
  unsigned char *buf ;
  struct mspack_system *sys ;
  int avail ;
  int todo ;
  int outlen ;
  int ignore_cksum ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 1240
  this = (struct mscab_decompressor_p *)file;
#line 1241
  buf = (unsigned char *)buffer;
#line 1242
  sys = this->system;
#line 1245
  if (this->param[1]) {
#line 1245
    if (((this->d)->comp_type & 15) == 1) {
#line 1245
      tmp = 1;
    } else {
#line 1245
      tmp = 0;
    }
  } else {
#line 1245
    tmp = 0;
  }
#line 1245
  ignore_cksum = tmp;
#line 1248
  todo = bytes;
#line 1249
  while (todo > 0) {
#line 1250
    avail = (this->d)->i_end - (this->d)->i_ptr;
#line 1253
    if (avail) {
#line 1255
      if (avail > todo) {
#line 1255
        avail = todo;
      }
#line 1256
      ((*(sys->copy)))((void *)(this->d)->i_ptr, (void *)buf, (unsigned int )avail);
#line 1257
      (this->d)->i_ptr += avail;
#line 1258
      buf += avail;
#line 1259
      todo -= avail;
    } else {
#line 1265
      tmp___0 = (this->d)->block;
#line 1265
      (this->d)->block ++;
#line 1265
      if (tmp___0 >= ((this->d)->folder)->base.num_blocks) {
#line 1266
        this->error = 8;
#line 1267
        break;
      }
#line 1271
      this->error = cabd_sys_read_block(sys, this->d, & outlen, ignore_cksum);
#line 1272
      if (this->error) {
#line 1272
        return (-1);
      }
#line 1277
      if (((this->d)->comp_type & 15) == 2) {
#line 1278
        tmp___1 = (this->d)->i_end;
#line 1278
        (this->d)->i_end ++;
#line 1278
        (*tmp___1) = (unsigned char)255;
      }
#line 1282
      if ((this->d)->block >= ((this->d)->folder)->base.num_blocks) {
#line 1284
        if (((this->d)->comp_type & 15) == 3) {
#line 1287
          lzxd_set_output_length((struct lzxd_stream *)(this->d)->state, (long )(((this->d)->block -
                                                                                  1U) *
                                                                                 32768U +
                                                                                 (unsigned int )outlen));
        }
      } else {
#line 1293
        if (outlen != 32768) {
#line 1294
          ((*((this->system)->message)))((this->d)->infh, (char *)"WARNING; non-maximal data block");
        }
      }
    }
  }
#line 1300
  return (bytes - todo);
}
}
#line 1303 "mspack/cabd.c"
static int cabd_sys_write(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mscab_decompressor_p *this ;
  int tmp ;

  {
#line 1304
  this = (struct mscab_decompressor_p *)file;
#line 1305
  (this->d)->offset += (unsigned int )bytes;
#line 1306
  if ((this->d)->outfh) {
#line 1307
    tmp = ((*((this->system)->write)))((this->d)->outfh, buffer, bytes);
#line 1307
    return (tmp);
  }
#line 1309
  return (bytes);
}
}
#line 1318 "mspack/cabd.c"
static int cabd_sys_read_block(struct mspack_system *sys , struct mscabd_decompress_state *d ,
                               int *out , int ignore_cksum ) 
{ unsigned char hdr[8] ;
  unsigned int cksum ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int sum2 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
#line 1327
  d->i_end = & d->input[0];
#line 1327
  d->i_ptr = d->i_end;
#line 1329
  while (1) {
#line 1331
    tmp = ((*(sys->read)))(d->infh, (void *)(hdr), 8);
#line 1331
    if (tmp != 8) {
#line 1332
      return (3);
    }
#line 1336
    if (((d->data)->cab)->block_resv) {
#line 1336
      tmp___0 = ((*(sys->seek)))(d->infh, (long )((d->data)->cab)->block_resv, 1);
#line 1336
      if (tmp___0) {
#line 1340
        return (5);
      }
    }
#line 1344
    len = ((int )(*(& hdr[4] + 1)) << 8) | (int )(*(& hdr[4] + 0));
#line 1345
    if ((d->i_end - d->i_ptr) + len > 38912) {
#line 1347
      return (8);
    }
#line 1351
    if ((((int )(*(& hdr[6] + 1)) << 8) | (int )(*(& hdr[6] + 0))) > 32768) {
#line 1353
      return (8);
    }
#line 1357
    tmp___1 = ((*(sys->read)))(d->infh, (void *)d->i_end, len);
#line 1357
    if (tmp___1 != len) {
#line 1358
      return (3);
    }
#line 1362
    cksum = (unsigned int )(((((int )hdr[3] << 24) | ((int )hdr[2] << 16)) | ((int )hdr[1] <<
                                                                              8)) |
                            (int )hdr[0]);
#line 1362
    if (cksum) {
#line 1363
      tmp___2 = cabd_checksum(d->i_end, (unsigned int )len, 0U);
#line 1363
      sum2 = tmp___2;
#line 1364
      tmp___3 = cabd_checksum(& hdr[4], 4U, sum2);
#line 1364
      if (tmp___3 != cksum) {
#line 1365
        if (! ignore_cksum) {
#line 1365
          return (9);
        }
#line 1366
        ((*(sys->message)))(d->infh, (char *)"WARNING; bad block checksum found");
      }
    }
#line 1371
    d->i_end += len;
#line 1379
    (*out) = ((int )(*(& hdr[6] + 1)) << 8) | (int )(*(& hdr[6] + 0));
#line 1379
    if ((*out)) {
#line 1380
      return (0);
    }
#line 1386
    ((*(sys->close)))(d->infh);
#line 1387
    d->infh = (struct mspack_file *)((void *)0);
#line 1390
    d->data = (d->data)->next;
#line 1390
    if (! d->data) {
#line 1392
      return (8);
    }
#line 1396
    d->incab = (d->data)->cab;
#line 1397
    d->infh = ((*(sys->open)))(sys, (d->incab)->base.filename, 0);
#line 1397
    if (! d->infh) {
#line 1400
      return (2);
    }
#line 1404
    tmp___4 = ((*(sys->seek)))(d->infh, (d->data)->offset, 0);
#line 1404
    if (tmp___4) {
#line 1405
      return (5);
    }
  }
#line 1410
  return (0);
}
}
#line 1413 "mspack/cabd.c"
static unsigned int cabd_checksum(unsigned char *data , unsigned int bytes , unsigned int cksum ) 
{ unsigned int len ;
  unsigned int ul ;
  unsigned int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 1416
  ul = 0U;
#line 1418
  len = bytes >> 2;
#line 1418
  while (1) {
#line 1418
    tmp = len;
#line 1418
    len --;
#line 1418
    if (! tmp) {
#line 1418
      break;
    }
#line 1419
    cksum ^= (unsigned int )((((int )(*(data + 0)) | ((int )(*(data + 1)) << 8)) |
                              ((int )(*(data + 2)) << 16)) | ((int )(*(data + 3)) <<
                                                              24));
#line 1418
    data += 4;
  }
#line 1422
  switch ((int )(bytes & 3U)) {
  case 3: 
#line 1423
  tmp___0 = data;
#line 1423
  data ++;
#line 1423
  ul |= (unsigned int )((int )(*tmp___0) << 16);
  case 2: 
#line 1424
  tmp___1 = data;
#line 1424
  data ++;
#line 1424
  ul |= (unsigned int )((int )(*tmp___1) << 8);
  case 1: 
#line 1425
  ul |= (unsigned int )(*data);
  }
#line 1427
  cksum ^= ul;
#line 1429
  return (cksum);
}
}
#line 1445 "mspack/cabd.c"
static struct noned_state *noned_init(struct mspack_system *sys , struct mspack_file *in ,
                                      struct mspack_file *out , int bufsize ) 
{ struct noned_state *state ;
  struct noned_state *tmp ;
  unsigned char *buf ;
  unsigned char *tmp___0 ;

  {
#line 1450
  tmp = (struct noned_state *)((*(sys->alloc)))(sys, sizeof(struct noned_state ));
#line 1450
  state = tmp;
#line 1451
  tmp___0 = (unsigned char *)((*(sys->alloc)))(sys, (unsigned int )bufsize);
#line 1451
  buf = tmp___0;
#line 1452
  if (state) {
#line 1452
    if (buf) {
#line 1453
      state->sys = sys;
#line 1454
      state->i = in;
#line 1455
      state->o = out;
#line 1456
      state->buf = buf;
#line 1457
      state->bufsize = bufsize;
    } else {
#line 1460
      ((*(sys->free)))((void *)buf);
#line 1461
      ((*(sys->free)))((void *)state);
#line 1462
      state = (struct noned_state *)((void *)0);
    }
  } else {
#line 1460
    ((*(sys->free)))((void *)buf);
#line 1461
    ((*(sys->free)))((void *)state);
#line 1462
    state = (struct noned_state *)((void *)0);
  }
#line 1464
  return (state);
}
}
#line 1467 "mspack/cabd.c"
static int noned_decompress(struct noned_state *s , off_t bytes ) 
{ int run ;
  int tmp ;
  int tmp___0 ;

  {
#line 1469
  while (bytes > 0L) {
#line 1470
    if (bytes > (long )s->bufsize) {
#line 1470
      run = s->bufsize;
    } else {
#line 1470
      run = (int )bytes;
    }
#line 1471
    tmp = ((*((s->sys)->read)))(s->i, (void *)(s->buf + 0), run);
#line 1471
    if (tmp != run) {
#line 1471
      return (3);
    }
#line 1472
    tmp___0 = ((*((s->sys)->write)))(s->o, (void *)(s->buf + 0), run);
#line 1472
    if (tmp___0 != run) {
#line 1472
      return (4);
    }
#line 1473
    bytes -= (long )run;
  }
#line 1475
  return (0);
}
}
#line 1478 "mspack/cabd.c"
static void noned_free(struct noned_state *state ) 
{ struct mspack_system *sys ;

  {
#line 1480
  if (state) {
#line 1481
    sys = state->sys;
#line 1482
    ((*(sys->free)))((void *)state->buf);
#line 1483
    ((*(sys->free)))((void *)state);
  }
#line 1485
  return;
}
}
#line 1493 "mspack/cabd.c"
static int cabd_param(struct mscab_decompressor *base , int param , int value ) 
{ struct mscab_decompressor_p *this ;

  {
#line 1494
  this = (struct mscab_decompressor_p *)base;
#line 1495
  if (! this) {
#line 1495
    return (1);
  }
#line 1497
  switch (param) {
  case 0: ;
#line 1499
  if (value < 4) {
#line 1499
    return (1);
  }
#line 1500
  this->param[0] = value;
#line 1501
  break;
  case 1: 
#line 1503
  this->param[1] = value;
#line 1504
  break;
  case 2: ;
#line 1506
  if (value < 4) {
#line 1506
    return (1);
  }
#line 1507
  this->param[2] = value;
#line 1508
  break;
  default: ;
#line 1510
  return (1);
  }
#line 1512
  return (0);
}
}
#line 1520 "mspack/cabd.c"
static int cabd_error(struct mscab_decompressor *base ) 
{ struct mscab_decompressor_p *this ;
  int tmp ;

  {
#line 1521
  this = (struct mscab_decompressor_p *)base;
#line 1522
  if (this) {
#line 1522
    tmp = this->error;
  } else {
#line 1522
    tmp = 1;
  }
#line 1522
  return (tmp);
}
}
#line 1 "lzxd.lo"
#pragma merger(0,"/tmp/cil-0WhonlKa.i","-g -O2 -fPIC")
#line 133 "mspack/lzxd.c"
static int lzxd_read_input(struct lzxd_stream *lzx ) 
{ int read___0 ;
  int tmp ;

  {
#line 134
  tmp = ((*((lzx->sys)->read)))(lzx->input, (void *)(lzx->inbuf + 0), (int )lzx->inbuf_size);
#line 134
  read___0 = tmp;
#line 135
  if (read___0 < 0) {
#line 135
    lzx->error = 3;
#line 135
    return (lzx->error);
  }
#line 139
  if (read___0 == 0) {
#line 140
    if (lzx->input_end) {
#line 142
      lzx->error = 3;
#line 142
      return (lzx->error);
    } else {
#line 145
      read___0 = 2;
#line 146
      (*(lzx->inbuf + 1)) = (unsigned char)0;
#line 146
      (*(lzx->inbuf + 0)) = (*(lzx->inbuf + 1));
#line 147
      lzx->input_end = (unsigned char)1;
    }
  }
#line 151
  lzx->i_ptr = lzx->inbuf + 0;
#line 152
  lzx->i_end = lzx->inbuf + read___0;
#line 154
  return (0);
}
}
#line 215 "mspack/lzxd.c"
static int make_decode_table(unsigned int nsyms , unsigned int nbits , unsigned char *length ,
                             unsigned short *table ) 
{ register unsigned short sym ;
  register unsigned int leaf ;
  register unsigned int fill ;
  register unsigned char bit_num ;
  unsigned int pos ;
  unsigned int table_mask ;
  unsigned int bit_mask___0 ;
  unsigned int next_symbol ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 221
  pos = 0U;
#line 222
  table_mask = (unsigned int )(1 << nbits);
#line 223
  bit_mask___0 = table_mask >> 1;
#line 224
  next_symbol = bit_mask___0;
#line 227
  bit_num = (unsigned char)1;
#line 227
  while ((unsigned int )bit_num <= nbits) {
#line 228
    sym = (unsigned short)0;
#line 228
    while ((unsigned int )sym < nsyms) {
#line 229
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont;
      }
#line 230
      leaf = pos;
#line 231
      pos += bit_mask___0;
#line 231
      if (pos > table_mask) {
#line 231
        return (1);
      }
#line 233
      fill = bit_mask___0;
#line 233
      while (1) {
#line 233
        tmp___0 = fill;
#line 233
        fill --;
#line 233
        if (! (tmp___0 > 0U)) {
#line 233
          break;
        }
#line 233
        tmp = leaf;
#line 233
        leaf ++;
#line 233
        (*(table + tmp)) = sym;
      }
      __Cont: 
#line 228
      sym = (unsigned short )((int )sym + 1);
    }
#line 235
    bit_mask___0 >>= 1;
#line 227
    bit_num = (unsigned char )((int )bit_num + 1);
  }
#line 239
  if (pos == table_mask) {
#line 239
    return (0);
  }
#line 242
  sym = (unsigned short )pos;
#line 242
  while ((unsigned int )sym < table_mask) {
#line 242
    (*(table + (int )sym)) = (unsigned short)65535;
#line 242
    sym = (unsigned short )((int )sym + 1);
  }
#line 245
  pos <<= 16;
#line 246
  table_mask <<= 16;
#line 247
  bit_mask___0 = 32768U;
#line 249
  bit_num = (unsigned char )(nbits + 1U);
#line 249
  while ((int )bit_num <= 16) {
#line 250
    sym = (unsigned short)0;
#line 250
    while ((unsigned int )sym < nsyms) {
#line 251
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont___0;
      }
#line 253
      leaf = pos >> 16;
#line 254
      fill = 0U;
#line 254
      while (fill < (unsigned int )bit_num - nbits) {
#line 256
        if ((int )(*(table + leaf)) == 65535) {
#line 257
          (*(table + (next_symbol << 1))) = (unsigned short)65535;
#line 258
          (*(table + ((next_symbol << 1) + 1U))) = (unsigned short)65535;
#line 259
          tmp___1 = next_symbol;
#line 259
          next_symbol ++;
#line 259
          (*(table + leaf)) = (unsigned short )tmp___1;
        }
#line 262
        leaf = (unsigned int )((int )(*(table + leaf)) << 1);
#line 263
        if ((pos >> (15U - fill)) & 1U) {
#line 263
          leaf ++;
        }
#line 254
        fill ++;
      }
#line 265
      (*(table + leaf)) = sym;
#line 267
      pos += bit_mask___0;
#line 267
      if (pos > table_mask) {
#line 267
        return (1);
      }
      __Cont___0: 
#line 250
      sym = (unsigned short )((int )sym + 1);
    }
#line 269
    bit_mask___0 >>= 1;
#line 249
    bit_num = (unsigned char )((int )bit_num + 1);
  }
#line 273
  if (pos == table_mask) {
#line 273
    return (0);
  }
#line 276
  sym = (unsigned short)0;
#line 276
  while ((unsigned int )sym < nsyms) {
#line 276
    if ((*(length + (int )sym))) {
#line 276
      return (1);
    }
#line 276
    sym = (unsigned short )((int )sym + 1);
  }
#line 277
  return (0);
}
}
#line 292 "mspack/lzxd.c"
static int lzxd_read_lens(struct lzxd_stream *lzx , unsigned char *lens , unsigned int first ,
                          unsigned int last ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  register int i ;
  register unsigned short sym ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  unsigned int x ;
  unsigned int y ;
  int z ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;

  {
#line 304
  while (1) {
#line 304
    i_ptr = lzx->i_ptr;
#line 304
    i_end = lzx->i_end;
#line 304
    bit_buffer = lzx->bit_buffer;
#line 304
    bits_left = (int )lzx->bits_left;
#line 304
    break;
  }
#line 307
  x = 0U;
#line 307
  while (x < 20U) {
#line 308
    while (1) {
#line 308
      while (bits_left < 4) {
#line 308
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 308
          tmp = lzxd_read_input(lzx);
#line 308
          if (tmp) {
#line 308
            return (lzx->error);
          }
#line 308
          i_ptr = lzx->i_ptr;
#line 308
          i_end = lzx->i_end;
        }
#line 308
        bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                              0))) <<
                                      ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 308
        bits_left += 16;
#line 308
        i_ptr += 2;
      }
#line 308
      y = bit_buffer >> (sizeof(bit_buffer) * 8U - 4U);
#line 308
      bit_buffer <<= 4;
#line 308
      bits_left -= 4;
#line 308
      break;
    }
#line 309
    lzx->PRETREE_len[x] = (unsigned char )y;
#line 307
    x ++;
  }
#line 311
  tmp___0 = make_decode_table(20U, 6U, & lzx->PRETREE_len[0], & lzx->PRETREE_table[0]);
#line 311
  if (tmp___0) {
#line 311
    lzx->error = 11;
#line 311
    return (lzx->error);
  }
#line 313
  x = first;
#line 313
  while (x < last) {
#line 314
    while (1) {
#line 314
      while (bits_left < 16) {
#line 314
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 314
          tmp___1 = lzxd_read_input(lzx);
#line 314
          if (tmp___1) {
#line 314
            return (lzx->error);
          }
#line 314
          i_ptr = lzx->i_ptr;
#line 314
          i_end = lzx->i_end;
        }
#line 314
        bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                              0))) <<
                                      ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 314
        bits_left += 16;
#line 314
        i_ptr += 2;
      }
#line 314
      sym = lzx->PRETREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 6U)];
#line 314
      if ((int )sym >= 20) {
#line 314
        i = 1 << (sizeof(bit_buffer) * 8U - 6U);
#line 314
        while (1) {
#line 314
          i >>= 1;
#line 314
          if (i == 0) {
#line 314
            lzx->error = 11;
#line 314
            return (lzx->error);
          }
#line 314
          sym = (unsigned short )((int )sym << 1);
#line 314
          if (bit_buffer & (unsigned int )i) {
#line 314
            tmp___2 = 1;
          } else {
#line 314
            tmp___2 = 0;
          }
#line 314
          sym = (unsigned short )((int )sym | tmp___2);
#line 314
          sym = lzx->PRETREE_table[sym];
#line 314
          if (! ((int )sym >= 20)) {
#line 314
            break;
          }
        }
      }
#line 314
      z = (int )sym;
#line 314
      i = (int )lzx->PRETREE_len[sym];
#line 314
      bit_buffer <<= i;
#line 314
      bits_left -= i;
#line 314
      break;
    }
#line 315
    if (z == 17) {
#line 317
      while (1) {
#line 317
        while (bits_left < 4) {
#line 317
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 317
            tmp___3 = lzxd_read_input(lzx);
#line 317
            if (tmp___3) {
#line 317
              return (lzx->error);
            }
#line 317
            i_ptr = lzx->i_ptr;
#line 317
            i_end = lzx->i_end;
          }
#line 317
          bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                0))) <<
                                        ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 317
          bits_left += 16;
#line 317
          i_ptr += 2;
        }
#line 317
        y = bit_buffer >> (sizeof(bit_buffer) * 8U - 4U);
#line 317
        bit_buffer <<= 4;
#line 317
        bits_left -= 4;
#line 317
        break;
      }
#line 317
      y += 4U;
#line 318
      while (1) {
#line 318
        tmp___5 = y;
#line 318
        y --;
#line 318
        if (! tmp___5) {
#line 318
          break;
        }
#line 318
        tmp___4 = x;
#line 318
        x ++;
#line 318
        (*(lens + tmp___4)) = (unsigned char)0;
      }
    } else {
#line 320
      if (z == 18) {
#line 322
        while (1) {
#line 322
          while (bits_left < 5) {
#line 322
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 322
              tmp___6 = lzxd_read_input(lzx);
#line 322
              if (tmp___6) {
#line 322
                return (lzx->error);
              }
#line 322
              i_ptr = lzx->i_ptr;
#line 322
              i_end = lzx->i_end;
            }
#line 322
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 322
            bits_left += 16;
#line 322
            i_ptr += 2;
          }
#line 322
          y = bit_buffer >> (sizeof(bit_buffer) * 8U - 5U);
#line 322
          bit_buffer <<= 5;
#line 322
          bits_left -= 5;
#line 322
          break;
        }
#line 322
        y += 20U;
#line 323
        while (1) {
#line 323
          tmp___8 = y;
#line 323
          y --;
#line 323
          if (! tmp___8) {
#line 323
            break;
          }
#line 323
          tmp___7 = x;
#line 323
          x ++;
#line 323
          (*(lens + tmp___7)) = (unsigned char)0;
        }
      } else {
#line 325
        if (z == 19) {
#line 327
          while (1) {
#line 327
            while (bits_left < 1) {
#line 327
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 327
                tmp___9 = lzxd_read_input(lzx);
#line 327
                if (tmp___9) {
#line 327
                  return (lzx->error);
                }
#line 327
                i_ptr = lzx->i_ptr;
#line 327
                i_end = lzx->i_end;
              }
#line 327
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 327
              bits_left += 16;
#line 327
              i_ptr += 2;
            }
#line 327
            y = bit_buffer >> (sizeof(bit_buffer) * 8U - 1U);
#line 327
            bit_buffer <<= 1;
#line 327
            bits_left --;
#line 327
            break;
          }
#line 327
          y += 4U;
#line 328
          while (1) {
#line 328
            while (bits_left < 16) {
#line 328
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 328
                tmp___10 = lzxd_read_input(lzx);
#line 328
                if (tmp___10) {
#line 328
                  return (lzx->error);
                }
#line 328
                i_ptr = lzx->i_ptr;
#line 328
                i_end = lzx->i_end;
              }
#line 328
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 328
              bits_left += 16;
#line 328
              i_ptr += 2;
            }
#line 328
            sym = lzx->PRETREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 6U)];
#line 328
            if ((int )sym >= 20) {
#line 328
              i = 1 << (sizeof(bit_buffer) * 8U - 6U);
#line 328
              while (1) {
#line 328
                i >>= 1;
#line 328
                if (i == 0) {
#line 328
                  lzx->error = 11;
#line 328
                  return (lzx->error);
                }
#line 328
                sym = (unsigned short )((int )sym << 1);
#line 328
                if (bit_buffer & (unsigned int )i) {
#line 328
                  tmp___11 = 1;
                } else {
#line 328
                  tmp___11 = 0;
                }
#line 328
                sym = (unsigned short )((int )sym | tmp___11);
#line 328
                sym = lzx->PRETREE_table[sym];
#line 328
                if (! ((int )sym >= 20)) {
#line 328
                  break;
                }
              }
            }
#line 328
            z = (int )sym;
#line 328
            i = (int )lzx->PRETREE_len[sym];
#line 328
            bit_buffer <<= i;
#line 328
            bits_left -= i;
#line 328
            break;
          }
#line 329
          z = (int )(*(lens + x)) - z;
#line 329
          if (z < 0) {
#line 329
            z += 17;
          }
#line 330
          while (1) {
#line 330
            tmp___13 = y;
#line 330
            y --;
#line 330
            if (! tmp___13) {
#line 330
              break;
            }
#line 330
            tmp___12 = x;
#line 330
            x ++;
#line 330
            (*(lens + tmp___12)) = (unsigned char )z;
          }
        } else {
#line 334
          z = (int )(*(lens + x)) - z;
#line 334
          if (z < 0) {
#line 334
            z += 17;
          }
#line 335
          tmp___14 = x;
#line 335
          x ++;
#line 335
          (*(lens + tmp___14)) = (unsigned char )z;
        }
      }
    }
  }
#line 339
  while (1) {
#line 339
    lzx->i_ptr = i_ptr;
#line 339
    lzx->i_end = i_end;
#line 339
    lzx->bit_buffer = bit_buffer;
#line 339
    lzx->bits_left = (unsigned int )bits_left;
#line 339
    break;
  }
#line 341
  return (0);
}
}
#line 354 "mspack/lzxd.c"
static unsigned int position_base[51]  ;
#line 355 "mspack/lzxd.c"
static unsigned char extra_bits[51]  ;
#line 357 "mspack/lzxd.c"
static void lzxd_static_init(void) 
{ int i ;
  int j ;

  {
#line 360
  i = 0;
#line 360
  j = 0;
#line 360
  while (i < 51) {
#line 361
    extra_bits[i] = (unsigned char )j;
#line 362
    if (i < 50) {
#line 363
      extra_bits[i + 1] = (unsigned char )j;
    }
#line 364
    if (i != 0) {
#line 364
      if (j < 17) {
#line 364
        j ++;
      }
    }
#line 360
    i += 2;
  }
#line 367
  i = 0;
#line 367
  j = 0;
#line 367
  while (i < 51) {
#line 368
    position_base[i] = (unsigned int )j;
#line 369
    j += 1 << (int )extra_bits[i];
#line 367
    i ++;
  }
#line 371
  return;
}
}
#line 373 "mspack/lzxd.c"
static void lzxd_reset_state(struct lzxd_stream *lzx ) 
{ int i ;

  {
#line 376
  lzx->R0 = 1U;
#line 377
  lzx->R1 = 1U;
#line 378
  lzx->R2 = 1U;
#line 379
  lzx->header_read = (unsigned char)0;
#line 380
  lzx->block_remaining = 0U;
#line 381
  lzx->block_type = (unsigned char)0;
#line 384
  i = 0;
#line 384
  while (i < 656) {
#line 384
    lzx->MAINTREE_len[i] = (unsigned char)0;
#line 384
    i ++;
  }
#line 385
  i = 0;
#line 385
  while (i < 250) {
#line 385
    lzx->LENGTH_len[i] = (unsigned char)0;
#line 385
    i ++;
  }
#line 386
  return;
}
}
#line 390 "mspack/lzxd.c"
struct lzxd_stream *lzxd_init(struct mspack_system *system , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int reset_interval ,
                              int input_buffer_size , off_t output_length ) 
{ unsigned int window_size ;
  struct lzxd_stream *lzx ;

  {
#line 398
  window_size = (unsigned int )(1 << window_bits);
#line 401
  if (! system) {
#line 401
    return ((struct lzxd_stream *)((void *)0));
  }
#line 404
  if (window_bits < 15) {
#line 404
    return ((struct lzxd_stream *)((void *)0));
  } else {
#line 404
    if (window_bits > 21) {
#line 404
      return ((struct lzxd_stream *)((void *)0));
    }
  }
#line 406
  input_buffer_size = (input_buffer_size + 1) & -2;
#line 407
  if (! input_buffer_size) {
#line 407
    return ((struct lzxd_stream *)((void *)0));
  }
#line 410
  lzxd_static_init();
#line 413
  lzx = (struct lzxd_stream *)((*(system->alloc)))(system, sizeof(struct lzxd_stream ));
#line 413
  if (! lzx) {
#line 414
    return ((struct lzxd_stream *)((void *)0));
  }
#line 418
  lzx->window = (unsigned char *)((*(system->alloc)))(system, window_size);
#line 419
  lzx->inbuf = (unsigned char *)((*(system->alloc)))(system, (unsigned int )input_buffer_size);
#line 420
  if (! lzx->window) {
#line 421
    ((*(system->free)))((void *)lzx->window);
#line 422
    ((*(system->free)))((void *)lzx->inbuf);
#line 423
    ((*(system->free)))((void *)lzx);
#line 424
    return ((struct lzxd_stream *)((void *)0));
  } else {
#line 420
    if (! lzx->inbuf) {
#line 421
      ((*(system->free)))((void *)lzx->window);
#line 422
      ((*(system->free)))((void *)lzx->inbuf);
#line 423
      ((*(system->free)))((void *)lzx);
#line 424
      return ((struct lzxd_stream *)((void *)0));
    }
  }
#line 428
  lzx->sys = system;
#line 429
  lzx->input = input;
#line 430
  lzx->output = output;
#line 431
  lzx->offset = 0L;
#line 432
  lzx->length = output_length;
#line 434
  lzx->inbuf_size = (unsigned int )input_buffer_size;
#line 435
  lzx->window_size = (unsigned int )(1 << window_bits);
#line 436
  lzx->window_posn = 0U;
#line 437
  lzx->frame_posn = 0U;
#line 438
  lzx->frame = 0U;
#line 439
  lzx->reset_interval = (unsigned int )reset_interval;
#line 440
  lzx->intel_filesize = 0;
#line 441
  lzx->intel_curpos = 0;
#line 445
  if (window_bits == 21) {
#line 445
    lzx->posn_slots = (unsigned char)50;
  } else {
#line 445
    if (window_bits == 20) {
#line 445
      lzx->posn_slots = (unsigned char)42;
    } else {
#line 445
      lzx->posn_slots = (unsigned char )(window_bits << 1);
    }
  }
#line 447
  lzx->intel_started = (unsigned char)0;
#line 448
  lzx->input_end = (unsigned char)0;
#line 450
  lzx->error = 0;
#line 452
  lzx->i_end = lzx->inbuf + 0;
#line 452
  lzx->i_ptr = lzx->i_end;
#line 453
  lzx->o_end = & lzx->e8_buf[0];
#line 453
  lzx->o_ptr = lzx->o_end;
#line 454
  lzx->bits_left = 0U;
#line 454
  lzx->bit_buffer = lzx->bits_left;
#line 456
  lzxd_reset_state(lzx);
#line 457
  return (lzx);
}
}
#line 460 "mspack/lzxd.c"
void lzxd_set_output_length(struct lzxd_stream *lzx , off_t out_bytes ) 
{ 

  {
#line 461
  if (lzx) {
#line 461
    lzx->length = out_bytes;
  }
#line 462
  return;
}
}
#line 464 "mspack/lzxd.c"
int lzxd_decompress(struct lzxd_stream *lzx , off_t out_bytes ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  register int i ;
  register unsigned short sym ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  int match_length ;
  int length_footer ;
  int extra ;
  int verbatim_bits ;
  int bytes_todo ;
  int this_run ;
  int main_element ;
  int aligned_bits ;
  int j ;
  unsigned char *window ;
  unsigned char *runsrc ;
  unsigned char *rundest ;
  unsigned char buf[12] ;
  unsigned int frame_size ;
  unsigned int end_frame ;
  unsigned int match_offset ;
  unsigned int window_posn ;
  unsigned int R0 ;
  unsigned int R1 ;
  unsigned int R2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  int tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;
  int tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned char *tmp___48 ;
  int tmp___49 ;
  unsigned char *tmp___50 ;
  unsigned char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  unsigned char *data ;
  unsigned char *dataend ;
  int curpos ;
  int filesize ;
  int abs_off ;
  int rel_off ;
  unsigned char *tmp___55 ;
  int tmp___56 ;

  {
#line 467
  i = 0;
#line 474
  frame_size = 0U;
#line 478
  if (! lzx) {
#line 478
    return (1);
  } else {
#line 478
    if (out_bytes < 0L) {
#line 478
      return (1);
    }
  }
#line 479
  if (lzx->error) {
#line 479
    return (lzx->error);
  }
#line 482
  i = lzx->o_end - lzx->o_ptr;
#line 483
  if ((long )i > out_bytes) {
#line 483
    i = (int )out_bytes;
  }
#line 484
  if (i) {
#line 485
    tmp = ((*((lzx->sys)->write)))(lzx->output, (void *)lzx->o_ptr, i);
#line 485
    if (tmp != i) {
#line 486
      lzx->error = 4;
#line 486
      return (lzx->error);
    }
#line 488
    lzx->o_ptr = lzx->o_ptr + i;
#line 489
    lzx->offset = lzx->offset + (long )i;
#line 490
    out_bytes -= (long )i;
  }
#line 492
  if (out_bytes == 0L) {
#line 492
    return (0);
  }
#line 495
  while (1) {
#line 495
    i_ptr = lzx->i_ptr;
#line 495
    i_end = lzx->i_end;
#line 495
    bit_buffer = lzx->bit_buffer;
#line 495
    bits_left = (int )lzx->bits_left;
#line 495
    break;
  }
#line 496
  window = lzx->window;
#line 497
  window_posn = lzx->window_posn;
#line 498
  R0 = lzx->R0;
#line 499
  R1 = lzx->R1;
#line 500
  R2 = lzx->R2;
#line 502
  end_frame = (unsigned int )((lzx->offset + out_bytes) / 32768L) + 1U;
#line 504
  while (lzx->frame < end_frame) {
#line 506
    if (lzx->reset_interval) {
#line 506
      if (lzx->frame % lzx->reset_interval == 0U) {
#line 507
        if (lzx->block_remaining) {
#line 509
          lzx->error = 11;
#line 509
          return (lzx->error);
        }
#line 513
        lzxd_reset_state(lzx);
      }
    }
#line 517
    if (! lzx->header_read) {
#line 520
      j = 0;
#line 520
      while (1) {
#line 520
        while (bits_left < 1) {
#line 520
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 520
            tmp___0 = lzxd_read_input(lzx);
#line 520
            if (tmp___0) {
#line 520
              return (lzx->error);
            }
#line 520
            i_ptr = lzx->i_ptr;
#line 520
            i_end = lzx->i_end;
          }
#line 520
          bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                0))) <<
                                        ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 520
          bits_left += 16;
#line 520
          i_ptr += 2;
        }
#line 520
        i = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 1U));
#line 520
        bit_buffer <<= 1;
#line 520
        bits_left --;
#line 520
        break;
      }
#line 520
      if (i) {
#line 520
        while (1) {
#line 520
          while (bits_left < 16) {
#line 520
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 520
              tmp___1 = lzxd_read_input(lzx);
#line 520
              if (tmp___1) {
#line 520
                return (lzx->error);
              }
#line 520
              i_ptr = lzx->i_ptr;
#line 520
              i_end = lzx->i_end;
            }
#line 520
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 520
            bits_left += 16;
#line 520
            i_ptr += 2;
          }
#line 520
          i = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 16U));
#line 520
          bit_buffer <<= 16;
#line 520
          bits_left -= 16;
#line 520
          break;
        }
#line 520
        while (1) {
#line 520
          while (bits_left < 16) {
#line 520
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 520
              tmp___2 = lzxd_read_input(lzx);
#line 520
              if (tmp___2) {
#line 520
                return (lzx->error);
              }
#line 520
              i_ptr = lzx->i_ptr;
#line 520
              i_end = lzx->i_end;
            }
#line 520
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 520
            bits_left += 16;
#line 520
            i_ptr += 2;
          }
#line 520
          j = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 16U));
#line 520
          bit_buffer <<= 16;
#line 520
          bits_left -= 16;
#line 520
          break;
        }
      }
#line 521
      lzx->intel_filesize = (i << 16) | j;
#line 522
      lzx->header_read = (unsigned char)1;
    }
#line 528
    frame_size = 32768U;
#line 529
    if (lzx->length) {
#line 529
      if (lzx->length - lzx->offset < (long )frame_size) {
#line 530
        frame_size = (unsigned int )(lzx->length - lzx->offset);
      }
    }
#line 534
    bytes_todo = (int )((lzx->frame_posn + frame_size) - window_posn);
#line 535
    while (bytes_todo > 0) {
#line 537
      if (lzx->block_remaining == 0U) {
#line 539
        if ((int )lzx->block_type == 3) {
#line 539
          if (lzx->block_length & 1U) {
#line 542
            if ((unsigned int )i_ptr == (unsigned int )i_end) {
#line 543
              tmp___3 = lzxd_read_input(lzx);
#line 543
              if (tmp___3) {
#line 543
                return (lzx->error);
              }
#line 544
              i_ptr = lzx->i_ptr;
#line 545
              i_end = lzx->i_end;
            }
#line 547
            i_ptr ++;
          }
        }
#line 551
        while (1) {
#line 551
          while (bits_left < 3) {
#line 551
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 551
              tmp___4 = lzxd_read_input(lzx);
#line 551
              if (tmp___4) {
#line 551
                return (lzx->error);
              }
#line 551
              i_ptr = lzx->i_ptr;
#line 551
              i_end = lzx->i_end;
            }
#line 551
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 551
            bits_left += 16;
#line 551
            i_ptr += 2;
          }
#line 551
          lzx->block_type = (unsigned char )(bit_buffer >> (sizeof(bit_buffer) * 8U -
                                                            3U));
#line 551
          bit_buffer <<= 3;
#line 551
          bits_left -= 3;
#line 551
          break;
        }
#line 552
        while (1) {
#line 552
          while (bits_left < 16) {
#line 552
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 552
              tmp___5 = lzxd_read_input(lzx);
#line 552
              if (tmp___5) {
#line 552
                return (lzx->error);
              }
#line 552
              i_ptr = lzx->i_ptr;
#line 552
              i_end = lzx->i_end;
            }
#line 552
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 552
            bits_left += 16;
#line 552
            i_ptr += 2;
          }
#line 552
          i = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 16U));
#line 552
          bit_buffer <<= 16;
#line 552
          bits_left -= 16;
#line 552
          break;
        }
#line 552
        while (1) {
#line 552
          while (bits_left < 8) {
#line 552
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 552
              tmp___6 = lzxd_read_input(lzx);
#line 552
              if (tmp___6) {
#line 552
                return (lzx->error);
              }
#line 552
              i_ptr = lzx->i_ptr;
#line 552
              i_end = lzx->i_end;
            }
#line 552
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 552
            bits_left += 16;
#line 552
            i_ptr += 2;
          }
#line 552
          j = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 8U));
#line 552
          bit_buffer <<= 8;
#line 552
          bits_left -= 8;
#line 552
          break;
        }
#line 553
        lzx->block_length = (unsigned int )((i << 8) | j);
#line 553
        lzx->block_remaining = lzx->block_length;
#line 557
        switch ((int )lzx->block_type) {
        case 2: 
#line 560
        i = 0;
#line 560
        while (i < 8) {
#line 560
          while (1) {
#line 560
            while (bits_left < 3) {
#line 560
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 560
                tmp___7 = lzxd_read_input(lzx);
#line 560
                if (tmp___7) {
#line 560
                  return (lzx->error);
                }
#line 560
                i_ptr = lzx->i_ptr;
#line 560
                i_end = lzx->i_end;
              }
#line 560
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 560
              bits_left += 16;
#line 560
              i_ptr += 2;
            }
#line 560
            j = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - 3U));
#line 560
            bit_buffer <<= 3;
#line 560
            bits_left -= 3;
#line 560
            break;
          }
#line 560
          lzx->ALIGNED_len[i] = (unsigned char )j;
#line 560
          i ++;
        }
#line 561
        tmp___8 = make_decode_table(8U, 7U, & lzx->ALIGNED_len[0], & lzx->ALIGNED_table[0]);
#line 561
        if (tmp___8) {
#line 561
          lzx->error = 11;
#line 561
          return (lzx->error);
        }
        case 1: ;
#line 565
        while (1) {
#line 565
          while (1) {
#line 565
            lzx->i_ptr = i_ptr;
#line 565
            lzx->i_end = i_end;
#line 565
            lzx->bit_buffer = bit_buffer;
#line 565
            lzx->bits_left = (unsigned int )bits_left;
#line 565
            break;
          }
#line 565
          tmp___9 = lzxd_read_lens(lzx, & lzx->MAINTREE_len[0], 0U, 256U);
#line 565
          if (tmp___9) {
#line 565
            return (lzx->error);
          }
#line 565
          while (1) {
#line 565
            i_ptr = lzx->i_ptr;
#line 565
            i_end = lzx->i_end;
#line 565
            bit_buffer = lzx->bit_buffer;
#line 565
            bits_left = (int )lzx->bits_left;
#line 565
            break;
          }
#line 565
          break;
        }
#line 566
        while (1) {
#line 566
          while (1) {
#line 566
            lzx->i_ptr = i_ptr;
#line 566
            lzx->i_end = i_end;
#line 566
            lzx->bit_buffer = bit_buffer;
#line 566
            lzx->bits_left = (unsigned int )bits_left;
#line 566
            break;
          }
#line 566
          tmp___10 = lzxd_read_lens(lzx, & lzx->MAINTREE_len[0], 256U, (unsigned int )(256 +
                                                                                       ((int )lzx->posn_slots <<
                                                                                        3)));
#line 566
          if (tmp___10) {
#line 566
            return (lzx->error);
          }
#line 566
          while (1) {
#line 566
            i_ptr = lzx->i_ptr;
#line 566
            i_end = lzx->i_end;
#line 566
            bit_buffer = lzx->bit_buffer;
#line 566
            bits_left = (int )lzx->bits_left;
#line 566
            break;
          }
#line 566
          break;
        }
#line 567
        tmp___11 = make_decode_table(656U, 12U, & lzx->MAINTREE_len[0], & lzx->MAINTREE_table[0]);
#line 567
        if (tmp___11) {
#line 567
          lzx->error = 11;
#line 567
          return (lzx->error);
        }
#line 569
        if ((int )lzx->MAINTREE_len[232] != 0) {
#line 569
          lzx->intel_started = (unsigned char)1;
        }
#line 571
        while (1) {
#line 571
          while (1) {
#line 571
            lzx->i_ptr = i_ptr;
#line 571
            lzx->i_end = i_end;
#line 571
            lzx->bit_buffer = bit_buffer;
#line 571
            lzx->bits_left = (unsigned int )bits_left;
#line 571
            break;
          }
#line 571
          tmp___12 = lzxd_read_lens(lzx, & lzx->LENGTH_len[0], 0U, 249U);
#line 571
          if (tmp___12) {
#line 571
            return (lzx->error);
          }
#line 571
          while (1) {
#line 571
            i_ptr = lzx->i_ptr;
#line 571
            i_end = lzx->i_end;
#line 571
            bit_buffer = lzx->bit_buffer;
#line 571
            bits_left = (int )lzx->bits_left;
#line 571
            break;
          }
#line 571
          break;
        }
#line 572
        tmp___13 = make_decode_table(250U, 12U, & lzx->LENGTH_len[0], & lzx->LENGTH_table[0]);
#line 572
        if (tmp___13) {
#line 572
          lzx->error = 11;
#line 572
          return (lzx->error);
        }
#line 573
        break;
        case 3: 
#line 577
        lzx->intel_started = (unsigned char)1;
#line 580
        while (bits_left < 16) {
#line 580
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 580
            tmp___14 = lzxd_read_input(lzx);
#line 580
            if (tmp___14) {
#line 580
              return (lzx->error);
            }
#line 580
            i_ptr = lzx->i_ptr;
#line 580
            i_end = lzx->i_end;
          }
#line 580
          bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                0))) <<
                                        ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 580
          bits_left += 16;
#line 580
          i_ptr += 2;
        }
#line 581
        if (bits_left > 16) {
#line 581
          i_ptr -= 2;
        }
#line 582
        bits_left = 0;
#line 582
        bit_buffer = 0U;
#line 585
        rundest = buf;
#line 585
        i = 0;
#line 585
        while (i < 12) {
#line 586
          if ((unsigned int )i_ptr == (unsigned int )i_end) {
#line 587
            tmp___15 = lzxd_read_input(lzx);
#line 587
            if (tmp___15) {
#line 587
              return (lzx->error);
            }
#line 588
            i_ptr = lzx->i_ptr;
#line 589
            i_end = lzx->i_end;
          }
#line 591
          tmp___16 = rundest;
#line 591
          rundest ++;
#line 591
          tmp___17 = i_ptr;
#line 591
          i_ptr ++;
#line 591
          (*tmp___16) = (*tmp___17);
#line 585
          i ++;
        }
#line 593
        R0 = (unsigned int )((((int )buf[0] | ((int )buf[1] << 8)) | ((int )buf[2] <<
                                                                      16)) | ((int )buf[3] <<
                                                                              24));
#line 594
        R1 = (unsigned int )((((int )buf[4] | ((int )buf[5] << 8)) | ((int )buf[6] <<
                                                                      16)) | ((int )buf[7] <<
                                                                              24));
#line 595
        R2 = (unsigned int )((((int )buf[8] | ((int )buf[9] << 8)) | ((int )buf[10] <<
                                                                      16)) | ((int )buf[11] <<
                                                                              24));
#line 596
        break;
        default: 
#line 600
        lzx->error = 11;
#line 600
        return (lzx->error);
        }
      }
#line 606
      this_run = (int )lzx->block_remaining;
#line 607
      if (this_run > bytes_todo) {
#line 607
        this_run = bytes_todo;
      }
#line 610
      bytes_todo -= this_run;
#line 611
      lzx->block_remaining = lzx->block_remaining - (unsigned int )this_run;
#line 614
      switch ((int )lzx->block_type) {
      case 1: ;
#line 616
      while (this_run > 0) {
#line 617
        while (1) {
#line 617
          while (bits_left < 16) {
#line 617
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 617
              tmp___18 = lzxd_read_input(lzx);
#line 617
              if (tmp___18) {
#line 617
                return (lzx->error);
              }
#line 617
              i_ptr = lzx->i_ptr;
#line 617
              i_end = lzx->i_end;
            }
#line 617
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 617
            bits_left += 16;
#line 617
            i_ptr += 2;
          }
#line 617
          sym = lzx->MAINTREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
#line 617
          if ((int )sym >= 656) {
#line 617
            i = 1 << (sizeof(bit_buffer) * 8U - 12U);
#line 617
            while (1) {
#line 617
              i >>= 1;
#line 617
              if (i == 0) {
#line 617
                lzx->error = 11;
#line 617
                return (lzx->error);
              }
#line 617
              sym = (unsigned short )((int )sym << 1);
#line 617
              if (bit_buffer & (unsigned int )i) {
#line 617
                tmp___19 = 1;
              } else {
#line 617
                tmp___19 = 0;
              }
#line 617
              sym = (unsigned short )((int )sym | tmp___19);
#line 617
              sym = lzx->MAINTREE_table[sym];
#line 617
              if (! ((int )sym >= 656)) {
#line 617
                break;
              }
            }
          }
#line 617
          main_element = (int )sym;
#line 617
          i = (int )lzx->MAINTREE_len[sym];
#line 617
          bit_buffer <<= i;
#line 617
          bits_left -= i;
#line 617
          break;
        }
#line 618
        if (main_element < 256) {
#line 620
          tmp___20 = window_posn;
#line 620
          window_posn ++;
#line 620
          (*(window + tmp___20)) = (unsigned char )main_element;
#line 621
          this_run --;
        } else {
#line 625
          main_element -= 256;
#line 628
          match_length = main_element & 7;
#line 629
          if (match_length == 7) {
#line 630
            while (1) {
#line 630
              while (bits_left < 16) {
#line 630
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 630
                  tmp___21 = lzxd_read_input(lzx);
#line 630
                  if (tmp___21) {
#line 630
                    return (lzx->error);
                  }
#line 630
                  i_ptr = lzx->i_ptr;
#line 630
                  i_end = lzx->i_end;
                }
#line 630
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 630
                bits_left += 16;
#line 630
                i_ptr += 2;
              }
#line 630
              sym = lzx->LENGTH_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
#line 630
              if ((int )sym >= 250) {
#line 630
                i = 1 << (sizeof(bit_buffer) * 8U - 12U);
#line 630
                while (1) {
#line 630
                  i >>= 1;
#line 630
                  if (i == 0) {
#line 630
                    lzx->error = 11;
#line 630
                    return (lzx->error);
                  }
#line 630
                  sym = (unsigned short )((int )sym << 1);
#line 630
                  if (bit_buffer & (unsigned int )i) {
#line 630
                    tmp___22 = 1;
                  } else {
#line 630
                    tmp___22 = 0;
                  }
#line 630
                  sym = (unsigned short )((int )sym | tmp___22);
#line 630
                  sym = lzx->LENGTH_table[sym];
#line 630
                  if (! ((int )sym >= 250)) {
#line 630
                    break;
                  }
                }
              }
#line 630
              length_footer = (int )sym;
#line 630
              i = (int )lzx->LENGTH_len[sym];
#line 630
              bit_buffer <<= i;
#line 630
              bits_left -= i;
#line 630
              break;
            }
#line 631
            match_length += length_footer;
          }
#line 633
          match_length += 2;
#line 636
          match_offset = (unsigned int )(main_element >> 3);
#line 636
          switch ((int )match_offset) {
          case 0: 
#line 637
          match_offset = R0;
#line 637
          break;
          case 1: 
#line 638
          match_offset = R1;
#line 638
          R1 = R0;
#line 638
          R0 = match_offset;
#line 638
          break;
          case 2: 
#line 639
          match_offset = R2;
#line 639
          R2 = R0;
#line 639
          R0 = match_offset;
#line 639
          break;
          case 3: 
#line 640
          match_offset = 1U;
#line 640
          R2 = R1;
#line 640
          R1 = R0;
#line 640
          R0 = match_offset;
#line 640
          break;
          default: 
#line 642
          extra = (int )extra_bits[match_offset];
#line 643
          while (1) {
#line 643
            while (bits_left < extra) {
#line 643
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 643
                tmp___23 = lzxd_read_input(lzx);
#line 643
                if (tmp___23) {
#line 643
                  return (lzx->error);
                }
#line 643
                i_ptr = lzx->i_ptr;
#line 643
                i_end = lzx->i_end;
              }
#line 643
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                    0))) <<
                                            ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 643
              bits_left += 16;
#line 643
              i_ptr += 2;
            }
#line 643
            verbatim_bits = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - (unsigned int )extra));
#line 643
            bit_buffer <<= extra;
#line 643
            bits_left -= extra;
#line 643
            break;
          }
#line 644
          match_offset = (position_base[match_offset] - 2U) + (unsigned int )verbatim_bits;
#line 645
          R2 = R1;
#line 645
          R1 = R0;
#line 645
          R0 = match_offset;
          }
#line 648
          if (window_posn + (unsigned int )match_length > lzx->window_size) {
#line 650
            lzx->error = 11;
#line 650
            return (lzx->error);
          }
#line 654
          rundest = window + window_posn;
#line 655
          i = match_length;
#line 657
          if (match_offset > window_posn) {
#line 659
            j = (int )(match_offset - window_posn);
#line 660
            if (j > (int )lzx->window_size) {
#line 662
              lzx->error = 11;
#line 662
              return (lzx->error);
            }
#line 664
            runsrc = window + (lzx->window_size - (unsigned int )j);
#line 665
            if (j < i) {
#line 667
              i -= j;
#line 667
              while (1) {
#line 667
                tmp___26 = j;
#line 667
                j --;
#line 667
                if (! (tmp___26 > 0)) {
#line 667
                  break;
                }
#line 667
                tmp___24 = rundest;
#line 667
                rundest ++;
#line 667
                tmp___25 = runsrc;
#line 667
                runsrc ++;
#line 667
                (*tmp___24) = (*tmp___25);
              }
#line 668
              runsrc = window;
            }
#line 670
            while (1) {
#line 670
              tmp___29 = i;
#line 670
              i --;
#line 670
              if (! (tmp___29 > 0)) {
#line 670
                break;
              }
#line 670
              tmp___27 = rundest;
#line 670
              rundest ++;
#line 670
              tmp___28 = runsrc;
#line 670
              runsrc ++;
#line 670
              (*tmp___27) = (*tmp___28);
            }
          } else {
#line 673
            runsrc = rundest - match_offset;
#line 674
            while (1) {
#line 674
              tmp___32 = i;
#line 674
              i --;
#line 674
              if (! (tmp___32 > 0)) {
#line 674
                break;
              }
#line 674
              tmp___30 = rundest;
#line 674
              rundest ++;
#line 674
              tmp___31 = runsrc;
#line 674
              runsrc ++;
#line 674
              (*tmp___30) = (*tmp___31);
            }
          }
#line 677
          this_run -= match_length;
#line 678
          window_posn += (unsigned int )match_length;
        }
      }
#line 681
      break;
      case 2: ;
#line 684
      while (this_run > 0) {
#line 685
        while (1) {
#line 685
          while (bits_left < 16) {
#line 685
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 685
              tmp___33 = lzxd_read_input(lzx);
#line 685
              if (tmp___33) {
#line 685
                return (lzx->error);
              }
#line 685
              i_ptr = lzx->i_ptr;
#line 685
              i_end = lzx->i_end;
            }
#line 685
            bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                  0))) <<
                                          ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 685
            bits_left += 16;
#line 685
            i_ptr += 2;
          }
#line 685
          sym = lzx->MAINTREE_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
#line 685
          if ((int )sym >= 656) {
#line 685
            i = 1 << (sizeof(bit_buffer) * 8U - 12U);
#line 685
            while (1) {
#line 685
              i >>= 1;
#line 685
              if (i == 0) {
#line 685
                lzx->error = 11;
#line 685
                return (lzx->error);
              }
#line 685
              sym = (unsigned short )((int )sym << 1);
#line 685
              if (bit_buffer & (unsigned int )i) {
#line 685
                tmp___34 = 1;
              } else {
#line 685
                tmp___34 = 0;
              }
#line 685
              sym = (unsigned short )((int )sym | tmp___34);
#line 685
              sym = lzx->MAINTREE_table[sym];
#line 685
              if (! ((int )sym >= 656)) {
#line 685
                break;
              }
            }
          }
#line 685
          main_element = (int )sym;
#line 685
          i = (int )lzx->MAINTREE_len[sym];
#line 685
          bit_buffer <<= i;
#line 685
          bits_left -= i;
#line 685
          break;
        }
#line 686
        if (main_element < 256) {
#line 688
          tmp___35 = window_posn;
#line 688
          window_posn ++;
#line 688
          (*(window + tmp___35)) = (unsigned char )main_element;
#line 689
          this_run --;
        } else {
#line 693
          main_element -= 256;
#line 696
          match_length = main_element & 7;
#line 697
          if (match_length == 7) {
#line 698
            while (1) {
#line 698
              while (bits_left < 16) {
#line 698
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 698
                  tmp___36 = lzxd_read_input(lzx);
#line 698
                  if (tmp___36) {
#line 698
                    return (lzx->error);
                  }
#line 698
                  i_ptr = lzx->i_ptr;
#line 698
                  i_end = lzx->i_end;
                }
#line 698
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 698
                bits_left += 16;
#line 698
                i_ptr += 2;
              }
#line 698
              sym = lzx->LENGTH_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 12U)];
#line 698
              if ((int )sym >= 250) {
#line 698
                i = 1 << (sizeof(bit_buffer) * 8U - 12U);
#line 698
                while (1) {
#line 698
                  i >>= 1;
#line 698
                  if (i == 0) {
#line 698
                    lzx->error = 11;
#line 698
                    return (lzx->error);
                  }
#line 698
                  sym = (unsigned short )((int )sym << 1);
#line 698
                  if (bit_buffer & (unsigned int )i) {
#line 698
                    tmp___37 = 1;
                  } else {
#line 698
                    tmp___37 = 0;
                  }
#line 698
                  sym = (unsigned short )((int )sym | tmp___37);
#line 698
                  sym = lzx->LENGTH_table[sym];
#line 698
                  if (! ((int )sym >= 250)) {
#line 698
                    break;
                  }
                }
              }
#line 698
              length_footer = (int )sym;
#line 698
              i = (int )lzx->LENGTH_len[sym];
#line 698
              bit_buffer <<= i;
#line 698
              bits_left -= i;
#line 698
              break;
            }
#line 699
            match_length += length_footer;
          }
#line 701
          match_length += 2;
#line 704
          match_offset = (unsigned int )(main_element >> 3);
#line 704
          switch ((int )match_offset) {
          case 0: 
#line 705
          match_offset = R0;
#line 705
          break;
          case 1: 
#line 706
          match_offset = R1;
#line 706
          R1 = R0;
#line 706
          R0 = match_offset;
#line 706
          break;
          case 2: 
#line 707
          match_offset = R2;
#line 707
          R2 = R0;
#line 707
          R0 = match_offset;
#line 707
          break;
          default: 
#line 709
          extra = (int )extra_bits[match_offset];
#line 710
          match_offset = position_base[match_offset] - 2U;
#line 711
          if (extra > 3) {
#line 713
            extra -= 3;
#line 714
            while (1) {
#line 714
              while (bits_left < extra) {
#line 714
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 714
                  tmp___38 = lzxd_read_input(lzx);
#line 714
                  if (tmp___38) {
#line 714
                    return (lzx->error);
                  }
#line 714
                  i_ptr = lzx->i_ptr;
#line 714
                  i_end = lzx->i_end;
                }
#line 714
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 714
                bits_left += 16;
#line 714
                i_ptr += 2;
              }
#line 714
              verbatim_bits = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U - (unsigned int )extra));
#line 714
              bit_buffer <<= extra;
#line 714
              bits_left -= extra;
#line 714
              break;
            }
#line 715
            match_offset += (unsigned int )(verbatim_bits << 3);
#line 716
            while (1) {
#line 716
              while (bits_left < 16) {
#line 716
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 716
                  tmp___39 = lzxd_read_input(lzx);
#line 716
                  if (tmp___39) {
#line 716
                    return (lzx->error);
                  }
#line 716
                  i_ptr = lzx->i_ptr;
#line 716
                  i_end = lzx->i_end;
                }
#line 716
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                      0))) <<
                                              ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 716
                bits_left += 16;
#line 716
                i_ptr += 2;
              }
#line 716
              sym = lzx->ALIGNED_table[bit_buffer >> (sizeof(bit_buffer) * 8U - 7U)];
#line 716
              if ((int )sym >= 8) {
#line 716
                i = 1 << (sizeof(bit_buffer) * 8U - 7U);
#line 716
                while (1) {
#line 716
                  i >>= 1;
#line 716
                  if (i == 0) {
#line 716
                    lzx->error = 11;
#line 716
                    return (lzx->error);
                  }
#line 716
                  sym = (unsigned short )((int )sym << 1);
#line 716
                  if (bit_buffer & (unsigned int )i) {
#line 716
                    tmp___40 = 1;
                  } else {
#line 716
                    tmp___40 = 0;
                  }
#line 716
                  sym = (unsigned short )((int )sym | tmp___40);
#line 716
                  sym = lzx->ALIGNED_table[sym];
#line 716
                  if (! ((int )sym >= 8)) {
#line 716
                    break;
                  }
                }
              }
#line 716
              aligned_bits = (int )sym;
#line 716
              i = (int )lzx->ALIGNED_len[sym];
#line 716
              bit_buffer <<= i;
#line 716
              bits_left -= i;
#line 716
              break;
            }
#line 717
            match_offset += (unsigned int )aligned_bits;
          } else {
#line 719
            if (extra == 3) {
#line 721
              while (1) {
#line 721
                while (bits_left < 16) {
#line 721
                  if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 721
                    tmp___41 = lzxd_read_input(lzx);
#line 721
                    if (tmp___41) {
#line 721
                      return (lzx->error);
                    }
#line 721
                    i_ptr = lzx->i_ptr;
#line 721
                    i_end = lzx->i_end;
                  }
#line 721
                  bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                        0))) <<
                                                ((sizeof(bit_buffer) * 8U - 16U) -
                                                 (unsigned int )bits_left));
#line 721
                  bits_left += 16;
#line 721
                  i_ptr += 2;
                }
#line 721
                sym = lzx->ALIGNED_table[bit_buffer >> (sizeof(bit_buffer) * 8U -
                                                        7U)];
#line 721
                if ((int )sym >= 8) {
#line 721
                  i = 1 << (sizeof(bit_buffer) * 8U - 7U);
#line 721
                  while (1) {
#line 721
                    i >>= 1;
#line 721
                    if (i == 0) {
#line 721
                      lzx->error = 11;
#line 721
                      return (lzx->error);
                    }
#line 721
                    sym = (unsigned short )((int )sym << 1);
#line 721
                    if (bit_buffer & (unsigned int )i) {
#line 721
                      tmp___42 = 1;
                    } else {
#line 721
                      tmp___42 = 0;
                    }
#line 721
                    sym = (unsigned short )((int )sym | tmp___42);
#line 721
                    sym = lzx->ALIGNED_table[sym];
#line 721
                    if (! ((int )sym >= 8)) {
#line 721
                      break;
                    }
                  }
                }
#line 721
                aligned_bits = (int )sym;
#line 721
                i = (int )lzx->ALIGNED_len[sym];
#line 721
                bit_buffer <<= i;
#line 721
                bits_left -= i;
#line 721
                break;
              }
#line 722
              match_offset += (unsigned int )aligned_bits;
            } else {
#line 724
              if (extra > 0) {
#line 726
                while (1) {
#line 726
                  while (bits_left < extra) {
#line 726
                    if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 726
                      tmp___43 = lzxd_read_input(lzx);
#line 726
                      if (tmp___43) {
#line 726
                        return (lzx->error);
                      }
#line 726
                      i_ptr = lzx->i_ptr;
#line 726
                      i_end = lzx->i_end;
                    }
#line 726
                    bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                                          0))) <<
                                                  ((sizeof(bit_buffer) * 8U - 16U) -
                                                   (unsigned int )bits_left));
#line 726
                    bits_left += 16;
#line 726
                    i_ptr += 2;
                  }
#line 726
                  verbatim_bits = (int )(bit_buffer >> (sizeof(bit_buffer) * 8U -
                                                        (unsigned int )extra));
#line 726
                  bit_buffer <<= extra;
#line 726
                  bits_left -= extra;
#line 726
                  break;
                }
#line 727
                match_offset += (unsigned int )verbatim_bits;
              } else {
#line 731
                match_offset = 1U;
              }
            }
          }
#line 734
          R2 = R1;
#line 734
          R1 = R0;
#line 734
          R0 = match_offset;
          }
#line 737
          if (window_posn + (unsigned int )match_length > lzx->window_size) {
#line 739
            lzx->error = 11;
#line 739
            return (lzx->error);
          }
#line 743
          rundest = window + window_posn;
#line 744
          i = match_length;
#line 746
          if (match_offset > window_posn) {
#line 748
            j = (int )(match_offset - window_posn);
#line 749
            if (j > (int )lzx->window_size) {
#line 751
              lzx->error = 11;
#line 751
              return (lzx->error);
            }
#line 753
            runsrc = window + (lzx->window_size - (unsigned int )j);
#line 754
            if (j < i) {
#line 756
              i -= j;
#line 756
              while (1) {
#line 756
                tmp___46 = j;
#line 756
                j --;
#line 756
                if (! (tmp___46 > 0)) {
#line 756
                  break;
                }
#line 756
                tmp___44 = rundest;
#line 756
                rundest ++;
#line 756
                tmp___45 = runsrc;
#line 756
                runsrc ++;
#line 756
                (*tmp___44) = (*tmp___45);
              }
#line 757
              runsrc = window;
            }
#line 759
            while (1) {
#line 759
              tmp___49 = i;
#line 759
              i --;
#line 759
              if (! (tmp___49 > 0)) {
#line 759
                break;
              }
#line 759
              tmp___47 = rundest;
#line 759
              rundest ++;
#line 759
              tmp___48 = runsrc;
#line 759
              runsrc ++;
#line 759
              (*tmp___47) = (*tmp___48);
            }
          } else {
#line 762
            runsrc = rundest - match_offset;
#line 763
            while (1) {
#line 763
              tmp___52 = i;
#line 763
              i --;
#line 763
              if (! (tmp___52 > 0)) {
#line 763
                break;
              }
#line 763
              tmp___50 = rundest;
#line 763
              rundest ++;
#line 763
              tmp___51 = runsrc;
#line 763
              runsrc ++;
#line 763
              (*tmp___50) = (*tmp___51);
            }
          }
#line 766
          this_run -= match_length;
#line 767
          window_posn += (unsigned int )match_length;
        }
      }
#line 770
      break;
      case 3: 
#line 775
      rundest = window + window_posn;
#line 776
      window_posn += (unsigned int )this_run;
#line 777
      while (this_run > 0) {
#line 778
        i = i_end - i_ptr;
#line 778
        if (i) {
#line 779
          if (i > this_run) {
#line 779
            i = this_run;
          }
#line 780
          ((*((lzx->sys)->copy)))((void *)i_ptr, (void *)rundest, (unsigned int )i);
#line 781
          rundest += i;
#line 782
          i_ptr += i;
#line 783
          this_run -= i;
        } else {
#line 786
          tmp___53 = lzxd_read_input(lzx);
#line 786
          if (tmp___53) {
#line 786
            return (lzx->error);
          }
#line 787
          i_ptr = lzx->i_ptr;
#line 788
          i_end = lzx->i_end;
        }
      }
#line 791
      break;
      default: 
#line 794
      lzx->error = 11;
#line 794
      return (lzx->error);
      }
#line 798
      if (this_run < 0) {
#line 799
        if ((unsigned int )(- this_run) > lzx->block_remaining) {
#line 802
          lzx->error = 11;
#line 802
          return (lzx->error);
        }
#line 804
        lzx->block_remaining = lzx->block_remaining - (unsigned int )(- this_run);
      }
    }
#line 809
    if (window_posn - lzx->frame_posn != frame_size) {
#line 812
      lzx->error = 11;
#line 812
      return (lzx->error);
    }
#line 816
    if (bits_left > 0) {
#line 816
      while (bits_left < 16) {
#line 816
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 816
          tmp___54 = lzxd_read_input(lzx);
#line 816
          if (tmp___54) {
#line 816
            return (lzx->error);
          }
#line 816
          i_ptr = lzx->i_ptr;
#line 816
          i_end = lzx->i_end;
        }
#line 816
        bit_buffer |= (unsigned int )((((int )(*(i_ptr + 1)) << 8) | (int )(*(i_ptr +
                                                                              0))) <<
                                      ((sizeof(bit_buffer) * 8U - 16U) - (unsigned int )bits_left));
#line 816
        bits_left += 16;
#line 816
        i_ptr += 2;
      }
    }
#line 817
    if (bits_left & 15) {
#line 817
      bit_buffer <<= bits_left & 15;
#line 817
      bits_left -= bits_left & 15;
    }
#line 820
    if ((unsigned int )lzx->o_ptr != (unsigned int )lzx->o_end) {
#line 822
      lzx->error = 11;
#line 822
      return (lzx->error);
    }
#line 826
    if (lzx->intel_started) {
#line 826
      if (lzx->intel_filesize) {
#line 826
        if (lzx->frame <= 32768U) {
#line 826
          if (frame_size > 10U) {
#line 829
            data = & lzx->e8_buf[0];
#line 830
            dataend = & lzx->e8_buf[frame_size - 10U];
#line 831
            curpos = lzx->intel_curpos;
#line 832
            filesize = lzx->intel_filesize;
#line 836
            lzx->o_ptr = data;
#line 837
            ((*((lzx->sys)->copy)))((void *)(lzx->window + lzx->frame_posn), (void *)data,
                                    frame_size);
#line 839
            while ((unsigned int )data < (unsigned int )dataend) {
#line 840
              tmp___55 = data;
#line 840
              data ++;
#line 840
              if ((int )(*tmp___55) != 232) {
#line 840
                curpos ++;
#line 840
                continue;
              }
#line 841
              abs_off = (((int )(*(data + 0)) | ((int )(*(data + 1)) << 8)) | ((int )(*(data +
                                                                                        2)) <<
                                                                               16)) |
                        ((int )(*(data + 3)) << 24);
#line 842
              if (abs_off >= - curpos) {
#line 842
                if (abs_off < filesize) {
#line 843
                  if (abs_off >= 0) {
#line 843
                    rel_off = abs_off - curpos;
                  } else {
#line 843
                    rel_off = abs_off + filesize;
                  }
#line 844
                  (*(data + 0)) = (unsigned char )rel_off;
#line 845
                  (*(data + 1)) = (unsigned char )(rel_off >> 8);
#line 846
                  (*(data + 2)) = (unsigned char )(rel_off >> 16);
#line 847
                  (*(data + 3)) = (unsigned char )(rel_off >> 24);
                }
              }
#line 849
              data += 4;
#line 850
              curpos += 5;
            }
#line 852
            lzx->intel_curpos = (int )((unsigned int )lzx->intel_curpos + frame_size);
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 855
      lzx->o_ptr = lzx->window + lzx->frame_posn;
#line 856
      if (lzx->intel_filesize) {
#line 856
        lzx->intel_curpos = (int )((unsigned int )lzx->intel_curpos + frame_size);
      }
    }
#line 858
    lzx->o_end = lzx->o_ptr + frame_size;
#line 861
    if (out_bytes < (long )frame_size) {
#line 861
      i = (int )((unsigned int )out_bytes);
    } else {
#line 861
      i = (int )frame_size;
    }
#line 862
    tmp___56 = ((*((lzx->sys)->write)))(lzx->output, (void *)lzx->o_ptr, i);
#line 862
    if (tmp___56 != i) {
#line 863
      lzx->error = 4;
#line 863
      return (lzx->error);
    }
#line 865
    lzx->o_ptr = lzx->o_ptr + i;
#line 866
    lzx->offset = lzx->offset + (long )i;
#line 867
    out_bytes -= (long )i;
#line 870
    lzx->frame_posn = lzx->frame_posn + frame_size;
#line 871
    lzx->frame = lzx->frame + 1U;
#line 874
    if (window_posn == lzx->window_size) {
#line 874
      window_posn = 0U;
    }
#line 875
    if (lzx->frame_posn == lzx->window_size) {
#line 875
      lzx->frame_posn = 0U;
    }
  }
#line 879
  if (out_bytes) {
#line 881
    lzx->error = 11;
#line 881
    return (lzx->error);
  }
#line 885
  while (1) {
#line 885
    lzx->i_ptr = i_ptr;
#line 885
    lzx->i_end = i_end;
#line 885
    lzx->bit_buffer = bit_buffer;
#line 885
    lzx->bits_left = (unsigned int )bits_left;
#line 885
    break;
  }
#line 886
  lzx->window_posn = window_posn;
#line 887
  lzx->R0 = R0;
#line 888
  lzx->R1 = R1;
#line 889
  lzx->R2 = R2;
#line 891
  return (0);
}
}
#line 894 "mspack/lzxd.c"
void lzxd_free(struct lzxd_stream *lzx ) 
{ struct mspack_system *sys ;

  {
#line 896
  if (lzx) {
#line 897
    sys = lzx->sys;
#line 898
    ((*(sys->free)))((void *)lzx->inbuf);
#line 899
    ((*(sys->free)))((void *)lzx->window);
#line 900
    ((*(sys->free)))((void *)lzx);
  }
#line 902
  return;
}
}
#line 1 "mszipd.lo"
#pragma merger(0,"/tmp/cil-MJAy2Y9W.i","-g -O2 -fPIC")
#line 24 "mspack/mszipd.c"
static unsigned short const   lit_lengths[29]  = 
#line 24
  {      (unsigned short const   )3,      (unsigned short const   )4,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )7,      (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )10, 
        (unsigned short const   )11,      (unsigned short const   )13,      (unsigned short const   )15,      (unsigned short const   )17, 
        (unsigned short const   )19,      (unsigned short const   )23,      (unsigned short const   )27,      (unsigned short const   )31, 
        (unsigned short const   )35,      (unsigned short const   )43,      (unsigned short const   )51,      (unsigned short const   )59, 
        (unsigned short const   )67,      (unsigned short const   )83,      (unsigned short const   )99,      (unsigned short const   )115, 
        (unsigned short const   )131,      (unsigned short const   )163,      (unsigned short const   )195,      (unsigned short const   )227, 
        (unsigned short const   )258};
#line 30 "mspack/mszipd.c"
static unsigned short const   dist_offsets[30]  = 
#line 30
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )4, 
        (unsigned short const   )5,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )13, 
        (unsigned short const   )17,      (unsigned short const   )25,      (unsigned short const   )33,      (unsigned short const   )49, 
        (unsigned short const   )65,      (unsigned short const   )97,      (unsigned short const   )129,      (unsigned short const   )193, 
        (unsigned short const   )257,      (unsigned short const   )385,      (unsigned short const   )513,      (unsigned short const   )769, 
        (unsigned short const   )1025,      (unsigned short const   )1537,      (unsigned short const   )2049,      (unsigned short const   )3073, 
        (unsigned short const   )4097,      (unsigned short const   )6145,      (unsigned short const   )8193,      (unsigned short const   )12289, 
        (unsigned short const   )16385,      (unsigned short const   )24577};
#line 36 "mspack/mszipd.c"
static unsigned char const   lit_extrabits[29]  = 
#line 36
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5, 
        (unsigned char const   )0};
#line 42 "mspack/mszipd.c"
static unsigned char const   dist_extrabits[30]  = 
#line 42
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )13};
#line 48 "mspack/mszipd.c"
static unsigned char const   bitlen_order[19]  = 
#line 48
  {      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )7,      (unsigned char const   )9,      (unsigned char const   )6, 
        (unsigned char const   )10,      (unsigned char const   )5,      (unsigned char const   )11,      (unsigned char const   )4, 
        (unsigned char const   )12,      (unsigned char const   )3,      (unsigned char const   )13,      (unsigned char const   )2, 
        (unsigned char const   )14,      (unsigned char const   )1,      (unsigned char const   )15};
#line 53 "mspack/mszipd.c"
static unsigned short const   bit_mask[17]  = 
#line 53
  {      (unsigned short const   )0,      (unsigned short const   )1,      (unsigned short const   )3,      (unsigned short const   )7, 
        (unsigned short const   )15,      (unsigned short const   )31,      (unsigned short const   )63,      (unsigned short const   )127, 
        (unsigned short const   )255,      (unsigned short const   )511,      (unsigned short const   )1023,      (unsigned short const   )2047, 
        (unsigned short const   )4095,      (unsigned short const   )8191,      (unsigned short const   )16383,      (unsigned short const   )32767, 
        (unsigned short const   )65535};
#line 96 "mspack/mszipd.c"
static int zipd_read_input(struct mszipd_stream *zip ) 
{ int read___0 ;
  int tmp ;

  {
#line 97
  tmp = ((*((zip->sys)->read)))(zip->input, (void *)(zip->inbuf + 0), (int )zip->inbuf_size);
#line 97
  read___0 = tmp;
#line 98
  if (read___0 < 0) {
#line 98
    zip->error = 3;
#line 98
    return (zip->error);
  }
#line 99
  zip->i_ptr = zip->inbuf + 0;
#line 100
  zip->i_end = zip->inbuf + read___0;
#line 102
  return (0);
}
}
#line 138 "mspack/mszipd.c"
static int make_decode_table___0(unsigned int nsyms , unsigned int nbits , unsigned char *length ,
                                 unsigned short *table ) 
{ register unsigned int leaf ;
  register unsigned int reverse ;
  register unsigned int fill ;
  register unsigned short sym ;
  register unsigned short next_sym ;
  register unsigned char bit_num ;
  unsigned int pos ;
  unsigned int table_mask ;
  unsigned int bit_mask___0 ;
  unsigned short tmp ;
  int tmp___0 ;

  {
#line 144
  pos = 0U;
#line 145
  table_mask = (unsigned int )(1 << nbits);
#line 146
  bit_mask___0 = table_mask >> 1;
#line 149
  bit_num = (unsigned char)1;
#line 149
  while ((unsigned int )bit_num <= nbits) {
#line 150
    sym = (unsigned short)0;
#line 150
    while ((unsigned int )sym < nsyms) {
#line 151
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont;
      }
#line 154
      fill = (unsigned int )(*(length + (int )sym));
#line 154
      reverse = pos >> (nbits - fill);
#line 154
      leaf = 0U;
#line 155
      while (1) {
#line 155
        leaf <<= 1;
#line 155
        leaf |= reverse & 1U;
#line 155
        reverse >>= 1;
#line 155
        fill --;
#line 155
        if (! fill) {
#line 155
          break;
        }
      }
#line 157
      pos += bit_mask___0;
#line 157
      if (pos > table_mask) {
#line 157
        return (1);
      }
#line 160
      fill = bit_mask___0;
#line 160
      next_sym = (unsigned short )(1 << (int )bit_num);
#line 161
      while (1) {
#line 161
        (*(table + leaf)) = sym;
#line 161
        leaf += (unsigned int )next_sym;
#line 161
        fill --;
#line 161
        if (! fill) {
#line 161
          break;
        }
      }
      __Cont: 
#line 150
      sym = (unsigned short )((int )sym + 1);
    }
#line 163
    bit_mask___0 >>= 1;
#line 149
    bit_num = (unsigned char )((int )bit_num + 1);
  }
#line 167
  if (pos == table_mask) {
#line 167
    return (0);
  }
#line 170
  sym = (unsigned short )pos;
#line 170
  while ((unsigned int )sym < table_mask) {
#line 171
    reverse = (unsigned int )sym;
#line 171
    leaf = 0U;
#line 171
    fill = nbits;
#line 172
    while (1) {
#line 172
      leaf <<= 1;
#line 172
      leaf |= reverse & 1U;
#line 172
      reverse >>= 1;
#line 172
      fill --;
#line 172
      if (! fill) {
#line 172
        break;
      }
    }
#line 173
    (*(table + leaf)) = (unsigned short)65535;
#line 170
    sym = (unsigned short )((int )sym + 1);
  }
#line 177
  if (table_mask >> 1 < nsyms) {
#line 177
    next_sym = (unsigned short )nsyms;
  } else {
#line 177
    next_sym = (unsigned short )(table_mask >> 1);
  }
#line 181
  pos <<= 16;
#line 182
  table_mask <<= 16;
#line 183
  bit_mask___0 = 32768U;
#line 185
  bit_num = (unsigned char )(nbits + 1U);
#line 185
  while ((int )bit_num <= 16) {
#line 186
    sym = (unsigned short)0;
#line 186
    while ((unsigned int )sym < nsyms) {
#line 187
      if ((int )(*(length + (int )sym)) != (int )bit_num) {
        goto __Cont___0;
      }
#line 190
      reverse = pos >> 16;
#line 190
      leaf = 0U;
#line 190
      fill = nbits;
#line 191
      while (1) {
#line 191
        leaf <<= 1;
#line 191
        leaf |= reverse & 1U;
#line 191
        reverse >>= 1;
#line 191
        fill --;
#line 191
        if (! fill) {
#line 191
          break;
        }
      }
#line 193
      fill = 0U;
#line 193
      while (fill < (unsigned int )bit_num - nbits) {
#line 195
        if ((int )(*(table + leaf)) == 65535) {
#line 196
          (*(table + ((int )next_sym << 1))) = (unsigned short)65535;
#line 197
          (*(table + (((int )next_sym << 1) + 1))) = (unsigned short)65535;
#line 198
          tmp = next_sym;
#line 198
          next_sym = (unsigned short )((int )next_sym + 1);
#line 198
          (*(table + leaf)) = tmp;
        }
#line 201
        leaf = (unsigned int )((int )(*(table + leaf)) << 1) | ((pos >> (15U - fill)) &
                                                                1U);
#line 193
        fill ++;
      }
#line 203
      (*(table + leaf)) = sym;
#line 205
      pos += bit_mask___0;
#line 205
      if (pos > table_mask) {
#line 205
        return (1);
      }
      __Cont___0: 
#line 186
      sym = (unsigned short )((int )sym + 1);
    }
#line 207
    bit_mask___0 >>= 1;
#line 185
    bit_num = (unsigned char )((int )bit_num + 1);
  }
#line 211
  if (pos != table_mask) {
#line 211
    tmp___0 = 1;
  } else {
#line 211
    tmp___0 = 0;
  }
#line 211
  return (tmp___0);
}
}
#line 244 "mspack/mszipd.c"
static int zip_read_lens(struct mszipd_stream *zip ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  unsigned short bl_table[128] ;
  unsigned char bl_len[19] ;
  unsigned char lens[320] ;
  unsigned int lit_codes ;
  unsigned int dist_codes ;
  unsigned int code ;
  unsigned int last_code ;
  unsigned int bitlen_codes ;
  unsigned int i ;
  unsigned int run ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  unsigned char *tmp___12 ;
  int tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 255
  last_code = 0U;
#line 257
  while (1) {
#line 257
    i_ptr = zip->i_ptr;
#line 257
    i_end = zip->i_end;
#line 257
    bit_buffer = zip->bit_buffer;
#line 257
    bits_left = (int )zip->bits_left;
#line 257
    break;
  }
#line 260
  while (1) {
#line 260
    while (1) {
#line 260
      while (bits_left < 5) {
#line 260
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 260
          tmp = zipd_read_input(zip);
#line 260
          if (tmp) {
#line 260
            return (zip->error);
          }
#line 260
          i_ptr = zip->i_ptr;
#line 260
          i_end = zip->i_end;
        }
#line 260
        tmp___0 = i_ptr;
#line 260
        i_ptr ++;
#line 260
        bit_buffer |= (unsigned int )((int )(*tmp___0) << bits_left);
#line 260
        bits_left += 8;
      }
#line 260
      break;
    }
#line 260
    lit_codes = bit_buffer & 31U;
#line 260
    bit_buffer >>= 5;
#line 260
    bits_left -= 5;
#line 260
    break;
  }
#line 260
  lit_codes += 257U;
#line 261
  while (1) {
#line 261
    while (1) {
#line 261
      while (bits_left < 5) {
#line 261
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 261
          tmp___1 = zipd_read_input(zip);
#line 261
          if (tmp___1) {
#line 261
            return (zip->error);
          }
#line 261
          i_ptr = zip->i_ptr;
#line 261
          i_end = zip->i_end;
        }
#line 261
        tmp___2 = i_ptr;
#line 261
        i_ptr ++;
#line 261
        bit_buffer |= (unsigned int )((int )(*tmp___2) << bits_left);
#line 261
        bits_left += 8;
      }
#line 261
      break;
    }
#line 261
    dist_codes = bit_buffer & 31U;
#line 261
    bit_buffer >>= 5;
#line 261
    bits_left -= 5;
#line 261
    break;
  }
#line 261
  dist_codes ++;
#line 262
  while (1) {
#line 262
    while (1) {
#line 262
      while (bits_left < 4) {
#line 262
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 262
          tmp___3 = zipd_read_input(zip);
#line 262
          if (tmp___3) {
#line 262
            return (zip->error);
          }
#line 262
          i_ptr = zip->i_ptr;
#line 262
          i_end = zip->i_end;
        }
#line 262
        tmp___4 = i_ptr;
#line 262
        i_ptr ++;
#line 262
        bit_buffer |= (unsigned int )((int )(*tmp___4) << bits_left);
#line 262
        bits_left += 8;
      }
#line 262
      break;
    }
#line 262
    bitlen_codes = bit_buffer & 15U;
#line 262
    bit_buffer >>= 4;
#line 262
    bits_left -= 4;
#line 262
    break;
  }
#line 262
  bitlen_codes += 4U;
#line 263
  if (lit_codes > 288U) {
#line 263
    return (-5);
  }
#line 264
  if (dist_codes > 32U) {
#line 264
    return (-5);
  }
#line 267
  i = 0U;
#line 267
  while (i < bitlen_codes) {
#line 267
    while (1) {
#line 267
      while (1) {
#line 267
        while (bits_left < 3) {
#line 267
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 267
            tmp___5 = zipd_read_input(zip);
#line 267
            if (tmp___5) {
#line 267
              return (zip->error);
            }
#line 267
            i_ptr = zip->i_ptr;
#line 267
            i_end = zip->i_end;
          }
#line 267
          tmp___6 = i_ptr;
#line 267
          i_ptr ++;
#line 267
          bit_buffer |= (unsigned int )((int )(*tmp___6) << bits_left);
#line 267
          bits_left += 8;
        }
#line 267
        break;
      }
#line 267
      bl_len[bitlen_order[i]] = (unsigned char )(bit_buffer & 7U);
#line 267
      bit_buffer >>= 3;
#line 267
      bits_left -= 3;
#line 267
      break;
    }
#line 267
    i ++;
  }
#line 268
  while (i < 19U) {
#line 268
    tmp___7 = i;
#line 268
    i ++;
#line 268
    bl_len[bitlen_order[tmp___7]] = (unsigned char)0;
  }
#line 271
  tmp___8 = make_decode_table___0(19U, 7U, bl_len, bl_table);
#line 271
  if (tmp___8) {
#line 272
    return (-6);
  }
#line 276
  i = 0U;
#line 276
  while (i < lit_codes + dist_codes) {
#line 278
    while (1) {
#line 278
      while (bits_left < 7) {
#line 278
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 278
          tmp___9 = zipd_read_input(zip);
#line 278
          if (tmp___9) {
#line 278
            return (zip->error);
          }
#line 278
          i_ptr = zip->i_ptr;
#line 278
          i_end = zip->i_end;
        }
#line 278
        tmp___10 = i_ptr;
#line 278
        i_ptr ++;
#line 278
        bit_buffer |= (unsigned int )((int )(*tmp___10) << bits_left);
#line 278
        bits_left += 8;
      }
#line 278
      break;
    }
#line 279
    code = (unsigned int )bl_table[bit_buffer & 127U];
#line 280
    bit_buffer >>= (int )bl_len[code];
#line 280
    bits_left -= (int )bl_len[code];
#line 282
    if (code < 16U) {
#line 282
      last_code = code;
#line 282
      lens[i] = (unsigned char )last_code;
    } else {
#line 284
      switch ((int )code) {
      case 16: ;
#line 285
      while (1) {
#line 285
        while (1) {
#line 285
          while (bits_left < 2) {
#line 285
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 285
              tmp___11 = zipd_read_input(zip);
#line 285
              if (tmp___11) {
#line 285
                return (zip->error);
              }
#line 285
              i_ptr = zip->i_ptr;
#line 285
              i_end = zip->i_end;
            }
#line 285
            tmp___12 = i_ptr;
#line 285
            i_ptr ++;
#line 285
            bit_buffer |= (unsigned int )((int )(*tmp___12) << bits_left);
#line 285
            bits_left += 8;
          }
#line 285
          break;
        }
#line 285
        run = bit_buffer & 3U;
#line 285
        bit_buffer >>= 2;
#line 285
        bits_left -= 2;
#line 285
        break;
      }
#line 285
      run += 3U;
#line 285
      code = last_code;
#line 285
      break;
      case 17: ;
#line 286
      while (1) {
#line 286
        while (1) {
#line 286
          while (bits_left < 3) {
#line 286
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 286
              tmp___13 = zipd_read_input(zip);
#line 286
              if (tmp___13) {
#line 286
                return (zip->error);
              }
#line 286
              i_ptr = zip->i_ptr;
#line 286
              i_end = zip->i_end;
            }
#line 286
            tmp___14 = i_ptr;
#line 286
            i_ptr ++;
#line 286
            bit_buffer |= (unsigned int )((int )(*tmp___14) << bits_left);
#line 286
            bits_left += 8;
          }
#line 286
          break;
        }
#line 286
        run = bit_buffer & 7U;
#line 286
        bit_buffer >>= 3;
#line 286
        bits_left -= 3;
#line 286
        break;
      }
#line 286
      run += 3U;
#line 286
      code = 0U;
#line 286
      break;
      case 18: ;
#line 287
      while (1) {
#line 287
        while (1) {
#line 287
          while (bits_left < 7) {
#line 287
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 287
              tmp___15 = zipd_read_input(zip);
#line 287
              if (tmp___15) {
#line 287
                return (zip->error);
              }
#line 287
              i_ptr = zip->i_ptr;
#line 287
              i_end = zip->i_end;
            }
#line 287
            tmp___16 = i_ptr;
#line 287
            i_ptr ++;
#line 287
            bit_buffer |= (unsigned int )((int )(*tmp___16) << bits_left);
#line 287
            bits_left += 8;
          }
#line 287
          break;
        }
#line 287
        run = bit_buffer & 127U;
#line 287
        bit_buffer >>= 7;
#line 287
        bits_left -= 7;
#line 287
        break;
      }
#line 287
      run += 11U;
#line 287
      code = 0U;
#line 287
      break;
      default: ;
#line 288
      return (-10);
      }
#line 290
      if (i + run > lit_codes + dist_codes) {
#line 290
        return (-9);
      }
#line 291
      while (1) {
#line 291
        tmp___18 = run;
#line 291
        run --;
#line 291
        if (! tmp___18) {
#line 291
          break;
        }
#line 291
        tmp___17 = i;
#line 291
        i ++;
#line 291
        lens[tmp___17] = (unsigned char )code;
      }
#line 292
      i --;
    }
#line 276
    i ++;
  }
#line 297
  i = lit_codes;
#line 298
  ((*((zip->sys)->copy)))((void *)(lens), (void *)(& zip->LITERAL_len[0]), i);
#line 299
  while (i < 288U) {
#line 299
    tmp___19 = i;
#line 299
    i ++;
#line 299
    zip->LITERAL_len[tmp___19] = (unsigned char)0;
  }
#line 301
  i = dist_codes;
#line 302
  ((*((zip->sys)->copy)))((void *)(& lens[lit_codes]), (void *)(& zip->DISTANCE_len[0]),
                          i);
#line 303
  while (i < 32U) {
#line 303
    tmp___20 = i;
#line 303
    i ++;
#line 303
    zip->DISTANCE_len[tmp___20] = (unsigned char)0;
  }
#line 305
  while (1) {
#line 305
    zip->i_ptr = i_ptr;
#line 305
    zip->i_end = i_end;
#line 305
    zip->bit_buffer = bit_buffer;
#line 305
    zip->bits_left = (unsigned int )bits_left;
#line 305
    break;
  }
#line 306
  return (0);
}
}
#line 310 "mspack/mszipd.c"
static int inflate___0(struct mszipd_stream *zip ) 
{ unsigned int last_block ;
  unsigned int block_type ;
  unsigned int distance ;
  unsigned int length ;
  unsigned int this_run ;
  unsigned int i ;
  register unsigned int bit_buffer ;
  register int bits_left ;
  register unsigned short sym ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char lens_buf[4] ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int window_posn ;
  unsigned int match_posn ;
  unsigned int code ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char *tmp___20 ;
  int tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned int tmp___23 ;
  int tmp___24 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned char *runsrc ;
  unsigned char *rundest ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 319
  while (1) {
#line 319
    i_ptr = zip->i_ptr;
#line 319
    i_end = zip->i_end;
#line 319
    bit_buffer = zip->bit_buffer;
#line 319
    bits_left = (int )zip->bits_left;
#line 319
    break;
  }
#line 321
  while (1) {
#line 323
    while (1) {
#line 323
      while (1) {
#line 323
        while (bits_left < 1) {
#line 323
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 323
            tmp = zipd_read_input(zip);
#line 323
            if (tmp) {
#line 323
              return (zip->error);
            }
#line 323
            i_ptr = zip->i_ptr;
#line 323
            i_end = zip->i_end;
          }
#line 323
          tmp___0 = i_ptr;
#line 323
          i_ptr ++;
#line 323
          bit_buffer |= (unsigned int )((int )(*tmp___0) << bits_left);
#line 323
          bits_left += 8;
        }
#line 323
        break;
      }
#line 323
      last_block = bit_buffer & 1U;
#line 323
      bit_buffer >>= 1;
#line 323
      bits_left --;
#line 323
      break;
    }
#line 326
    while (1) {
#line 326
      while (1) {
#line 326
        while (bits_left < 2) {
#line 326
          if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 326
            tmp___1 = zipd_read_input(zip);
#line 326
            if (tmp___1) {
#line 326
              return (zip->error);
            }
#line 326
            i_ptr = zip->i_ptr;
#line 326
            i_end = zip->i_end;
          }
#line 326
          tmp___2 = i_ptr;
#line 326
          i_ptr ++;
#line 326
          bit_buffer |= (unsigned int )((int )(*tmp___2) << bits_left);
#line 326
          bits_left += 8;
        }
#line 326
        break;
      }
#line 326
      block_type = bit_buffer & 3U;
#line 326
      bit_buffer >>= 2;
#line 326
      bits_left -= 2;
#line 326
      break;
    }
#line 329
    if (block_type == 0U) {
#line 334
      i = (unsigned int )(bits_left & 7);
#line 334
      bit_buffer >>= i;
#line 334
      bits_left = (int )((unsigned int )bits_left - i);
#line 337
      i = 0U;
#line 337
      while (bits_left >= 8) {
#line 338
        if (i == 4U) {
#line 338
          return (-4);
        }
#line 339
        lens_buf[i] = (unsigned char )(bit_buffer & 255U);
#line 340
        bit_buffer >>= 8;
#line 340
        bits_left -= 8;
#line 337
        i ++;
      }
#line 342
      if (bits_left != 0) {
#line 342
        return (-4);
      }
#line 343
      while (i < 4U) {
#line 344
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 345
          tmp___3 = zipd_read_input(zip);
#line 345
          if (tmp___3) {
#line 345
            return (zip->error);
          }
#line 346
          i_ptr = zip->i_ptr;
#line 347
          i_end = zip->i_end;
        }
#line 349
        tmp___4 = i;
#line 349
        i ++;
#line 349
        tmp___5 = i_ptr;
#line 349
        i_ptr ++;
#line 349
        lens_buf[tmp___4] = (*tmp___5);
      }
#line 353
      length = (unsigned int )((int )lens_buf[0] | ((int )lens_buf[1] << 8));
#line 354
      i = (unsigned int )((int )lens_buf[2] | ((int )lens_buf[3] << 8));
#line 355
      if (length != (~ i & 65535U)) {
#line 355
        return (-2);
      }
#line 358
      while (length > 0U) {
#line 359
        if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 360
          tmp___6 = zipd_read_input(zip);
#line 360
          if (tmp___6) {
#line 360
            return (zip->error);
          }
#line 361
          i_ptr = zip->i_ptr;
#line 362
          i_end = zip->i_end;
        }
#line 365
        this_run = length;
#line 366
        if (this_run > (unsigned int )(i_end - i_ptr)) {
#line 366
          this_run = (unsigned int )(i_end - i_ptr);
        }
#line 367
        if (this_run > 32768U - zip->window_posn) {
#line 368
          this_run = 32768U - zip->window_posn;
        }
#line 370
        ((*((zip->sys)->copy)))((void *)i_ptr, (void *)(& zip->window[zip->window_posn]),
                                this_run);
#line 371
        zip->window_posn = zip->window_posn + this_run;
#line 372
        i_ptr += this_run;
#line 373
        length -= this_run;
#line 375
        if (zip->window_posn == 32768U) {
#line 376
          tmp___7 = ((*(zip->flush_window)))(zip, 32768U);
#line 376
          if (tmp___7) {
#line 376
            return (-3);
          }
#line 377
          zip->window_posn = 0U;
        }
      }
    } else {
#line 381
      if (block_type == 1U) {
        goto _L;
      } else {
#line 381
        if (block_type == 2U) {
          _L: 
#line 385
          if (block_type == 1U) {
#line 387
            i = 0U;
#line 388
            while (i < 144U) {
#line 388
              tmp___8 = i;
#line 388
              i ++;
#line 388
              zip->LITERAL_len[tmp___8] = (unsigned char)8;
            }
#line 389
            while (i < 256U) {
#line 389
              tmp___9 = i;
#line 389
              i ++;
#line 389
              zip->LITERAL_len[tmp___9] = (unsigned char)9;
            }
#line 390
            while (i < 280U) {
#line 390
              tmp___10 = i;
#line 390
              i ++;
#line 390
              zip->LITERAL_len[tmp___10] = (unsigned char)7;
            }
#line 391
            while (i < 288U) {
#line 391
              tmp___11 = i;
#line 391
              i ++;
#line 391
              zip->LITERAL_len[tmp___11] = (unsigned char)8;
            }
#line 392
            i = 0U;
#line 392
            while (i < 32U) {
#line 392
              zip->DISTANCE_len[i] = (unsigned char)5;
#line 392
              i ++;
            }
          } else {
#line 396
            while (1) {
#line 396
              zip->i_ptr = i_ptr;
#line 396
              zip->i_end = i_end;
#line 396
              zip->bit_buffer = bit_buffer;
#line 396
              zip->bits_left = (unsigned int )bits_left;
#line 396
              break;
            }
#line 397
            i = (unsigned int )zip_read_lens(zip);
#line 397
            if (i) {
#line 397
              return ((int )i);
            }
#line 398
            while (1) {
#line 398
              i_ptr = zip->i_ptr;
#line 398
              i_end = zip->i_end;
#line 398
              bit_buffer = zip->bit_buffer;
#line 398
              bits_left = (int )zip->bits_left;
#line 398
              break;
            }
          }
#line 403
          tmp___12 = make_decode_table___0(288U, 9U, & zip->LITERAL_len[0], & zip->LITERAL_table[0]);
#line 403
          if (tmp___12) {
#line 406
            return (-7);
          }
#line 409
          tmp___13 = make_decode_table___0(32U, 6U, & zip->DISTANCE_len[0], & zip->DISTANCE_table[0]);
#line 409
          if (tmp___13) {
#line 412
            return (-8);
          }
#line 416
          window_posn = zip->window_posn;
#line 417
          while (1) {
#line 418
            while (1) {
#line 418
              while (1) {
#line 418
                while (bits_left < 16) {
#line 418
                  if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 418
                    tmp___14 = zipd_read_input(zip);
#line 418
                    if (tmp___14) {
#line 418
                      return (zip->error);
                    }
#line 418
                    i_ptr = zip->i_ptr;
#line 418
                    i_end = zip->i_end;
                  }
#line 418
                  tmp___15 = i_ptr;
#line 418
                  i_ptr ++;
#line 418
                  bit_buffer |= (unsigned int )((int )(*tmp___15) << bits_left);
#line 418
                  bits_left += 8;
                }
#line 418
                break;
              }
#line 418
              sym = zip->LITERAL_table[bit_buffer & 511U];
#line 418
              if ((int )sym >= 288) {
#line 418
                i = 8U;
#line 418
                while (1) {
#line 418
                  tmp___16 = i;
#line 418
                  i ++;
#line 418
                  if (tmp___16 > 16U) {
#line 418
                    return (-14);
                  }
#line 418
                  sym = zip->LITERAL_table[(unsigned int )((int )sym << 1) | ((bit_buffer >>
                                                                               i) &
                                                                              1U)];
#line 418
                  if (! ((int )sym >= 288)) {
#line 418
                    break;
                  }
                }
              }
#line 418
              code = (unsigned int )sym;
#line 418
              i = (unsigned int )zip->LITERAL_len[sym];
#line 418
              bit_buffer >>= i;
#line 418
              bits_left = (int )((unsigned int )bits_left - i);
#line 418
              break;
            }
#line 419
            if (code < 256U) {
#line 420
              tmp___17 = window_posn;
#line 420
              window_posn ++;
#line 420
              zip->window[tmp___17] = (unsigned char )code;
#line 421
              if (window_posn == 32768U) {
#line 422
                tmp___18 = ((*(zip->flush_window)))(zip, 32768U);
#line 422
                if (tmp___18) {
#line 422
                  return (-3);
                }
#line 423
                window_posn = 0U;
              }
            } else {
#line 426
              if (code == 256U) {
#line 428
                break;
              } else {
#line 431
                code -= 257U;
#line 432
                if (code > 29U) {
#line 432
                  return (-11);
                }
#line 433
                while (1) {
#line 433
                  while (1) {
#line 433
                    while (bits_left < (int )lit_extrabits[code]) {
#line 433
                      if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 433
                        tmp___19 = zipd_read_input(zip);
#line 433
                        if (tmp___19) {
#line 433
                          return (zip->error);
                        }
#line 433
                        i_ptr = zip->i_ptr;
#line 433
                        i_end = zip->i_end;
                      }
#line 433
                      tmp___20 = i_ptr;
#line 433
                      i_ptr ++;
#line 433
                      bit_buffer |= (unsigned int )((int )(*tmp___20) << bits_left);
#line 433
                      bits_left += 8;
                    }
#line 433
                    break;
                  }
#line 433
                  length = bit_buffer & (unsigned int )bit_mask[lit_extrabits[code]];
#line 433
                  bit_buffer >>= (int const   )lit_extrabits[code];
#line 433
                  bits_left -= (int )lit_extrabits[code];
#line 433
                  break;
                }
#line 434
                length += (unsigned int )lit_lengths[code];
#line 436
                while (1) {
#line 436
                  while (1) {
#line 436
                    while (bits_left < 16) {
#line 436
                      if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 436
                        tmp___21 = zipd_read_input(zip);
#line 436
                        if (tmp___21) {
#line 436
                          return (zip->error);
                        }
#line 436
                        i_ptr = zip->i_ptr;
#line 436
                        i_end = zip->i_end;
                      }
#line 436
                      tmp___22 = i_ptr;
#line 436
                      i_ptr ++;
#line 436
                      bit_buffer |= (unsigned int )((int )(*tmp___22) << bits_left);
#line 436
                      bits_left += 8;
                    }
#line 436
                    break;
                  }
#line 436
                  sym = zip->DISTANCE_table[bit_buffer & 63U];
#line 436
                  if ((int )sym >= 32) {
#line 436
                    i = 5U;
#line 436
                    while (1) {
#line 436
                      tmp___23 = i;
#line 436
                      i ++;
#line 436
                      if (tmp___23 > 16U) {
#line 436
                        return (-14);
                      }
#line 436
                      sym = zip->DISTANCE_table[(unsigned int )((int )sym << 1) |
                                                ((bit_buffer >> i) & 1U)];
#line 436
                      if (! ((int )sym >= 32)) {
#line 436
                        break;
                      }
                    }
                  }
#line 436
                  code = (unsigned int )sym;
#line 436
                  i = (unsigned int )zip->DISTANCE_len[sym];
#line 436
                  bit_buffer >>= i;
#line 436
                  bits_left = (int )((unsigned int )bits_left - i);
#line 436
                  break;
                }
#line 437
                if (code > 30U) {
#line 437
                  return (-12);
                }
#line 438
                while (1) {
#line 438
                  while (1) {
#line 438
                    while (bits_left < (int )dist_extrabits[code]) {
#line 438
                      if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 438
                        tmp___24 = zipd_read_input(zip);
#line 438
                        if (tmp___24) {
#line 438
                          return (zip->error);
                        }
#line 438
                        i_ptr = zip->i_ptr;
#line 438
                        i_end = zip->i_end;
                      }
#line 438
                      tmp___25 = i_ptr;
#line 438
                      i_ptr ++;
#line 438
                      bit_buffer |= (unsigned int )((int )(*tmp___25) << bits_left);
#line 438
                      bits_left += 8;
                    }
#line 438
                    break;
                  }
#line 438
                  distance = bit_buffer & (unsigned int )bit_mask[dist_extrabits[code]];
#line 438
                  bit_buffer >>= (int const   )dist_extrabits[code];
#line 438
                  bits_left -= (int )dist_extrabits[code];
#line 438
                  break;
                }
#line 439
                distance += (unsigned int )dist_offsets[code];
#line 444
                if (distance > window_posn) {
#line 444
                  tmp___26 = 32768;
                } else {
#line 444
                  tmp___26 = 0;
                }
#line 444
                match_posn = ((unsigned int )tmp___26 + window_posn) - distance;
#line 448
                if (length < 12U) {
#line 450
                  while (1) {
#line 450
                    tmp___30 = length;
#line 450
                    length --;
#line 450
                    if (! tmp___30) {
#line 450
                      break;
                    }
#line 451
                    tmp___27 = window_posn;
#line 451
                    window_posn ++;
#line 451
                    tmp___28 = match_posn;
#line 451
                    match_posn ++;
#line 451
                    zip->window[tmp___27] = zip->window[tmp___28];
#line 452
                    match_posn &= 32767U;
#line 454
                    if (window_posn == 32768U) {
#line 455
                      tmp___29 = ((*(zip->flush_window)))(zip, 32768U);
#line 455
                      if (tmp___29) {
#line 456
                        return (-3);
                      }
#line 457
                      window_posn = 0U;
                    }
                  }
                } else {
#line 464
                  while (1) {
#line 465
                    this_run = length;
#line 466
                    if (match_posn + this_run > 32768U) {
#line 467
                      this_run = 32768U - match_posn;
                    }
#line 468
                    if (window_posn + this_run > 32768U) {
#line 469
                      this_run = 32768U - window_posn;
                    }
#line 471
                    rundest = & zip->window[window_posn];
#line 471
                    window_posn += this_run;
#line 472
                    runsrc = & zip->window[match_posn];
#line 472
                    match_posn += this_run;
#line 473
                    length -= this_run;
#line 474
                    while (1) {
#line 474
                      tmp___33 = this_run;
#line 474
                      this_run --;
#line 474
                      if (! tmp___33) {
#line 474
                        break;
                      }
#line 474
                      tmp___31 = rundest;
#line 474
                      rundest ++;
#line 474
                      tmp___32 = runsrc;
#line 474
                      runsrc ++;
#line 474
                      (*tmp___31) = (*tmp___32);
                    }
#line 477
                    if (window_posn == 32768U) {
#line 478
                      tmp___34 = ((*(zip->flush_window)))(zip, 32768U);
#line 478
                      if (tmp___34) {
#line 479
                        return (-3);
                      }
#line 480
                      window_posn = 0U;
                    }
#line 482
                    if (match_posn == 32768U) {
#line 482
                      match_posn = 0U;
                    }
#line 464
                    if (! (length > 0U)) {
#line 464
                      break;
                    }
                  }
                }
              }
            }
          }
#line 489
          zip->window_posn = window_posn;
        } else {
#line 493
          return (-1);
        }
      }
    }
#line 321
    if (! (! last_block)) {
#line 321
      break;
    }
  }
#line 498
  if (zip->window_posn) {
#line 499
    tmp___35 = ((*(zip->flush_window)))(zip, zip->window_posn);
#line 499
    if (tmp___35) {
#line 499
      return (-3);
    }
  }
#line 501
  while (1) {
#line 501
    zip->i_ptr = i_ptr;
#line 501
    zip->i_end = i_end;
#line 501
    zip->bit_buffer = bit_buffer;
#line 501
    zip->bits_left = (unsigned int )bits_left;
#line 501
    break;
  }
#line 504
  return (0);
}
}
#line 512 "mspack/mszipd.c"
static int mszipd_flush_window(struct mszipd_stream *zip , unsigned int data_flushed ) 
{ 

  {
#line 515
  zip->bytes_output = (int )((unsigned int )zip->bytes_output + data_flushed);
#line 516
  if (zip->bytes_output > 32768) {
#line 519
    return (1);
  }
#line 521
  return (0);
}
}
#line 524 "mspack/mszipd.c"
struct mszipd_stream *mszipd_init(struct mspack_system *system , struct mspack_file *input ,
                                  struct mspack_file *output , int input_buffer_size ,
                                  int repair_mode ) 
{ struct mszipd_stream *zip ;

  {
#line 532
  if (! system) {
#line 532
    return ((struct mszipd_stream *)((void *)0));
  }
#line 534
  input_buffer_size = (input_buffer_size + 1) & -2;
#line 535
  if (! input_buffer_size) {
#line 535
    return ((struct mszipd_stream *)((void *)0));
  }
#line 538
  zip = (struct mszipd_stream *)((*(system->alloc)))(system, sizeof(struct mszipd_stream ));
#line 538
  if (! zip) {
#line 539
    return ((struct mszipd_stream *)((void *)0));
  }
#line 543
  zip->inbuf = (unsigned char *)((*(system->alloc)))(system, (unsigned int )input_buffer_size);
#line 544
  if (! zip->inbuf) {
#line 545
    ((*(system->free)))((void *)zip);
#line 546
    return ((struct mszipd_stream *)((void *)0));
  }
#line 550
  zip->sys = system;
#line 551
  zip->input = input;
#line 552
  zip->output = output;
#line 553
  zip->inbuf_size = (unsigned int )input_buffer_size;
#line 554
  zip->error = 0;
#line 555
  zip->repair_mode = repair_mode;
#line 556
  zip->flush_window = & mszipd_flush_window;
#line 558
  zip->i_end = zip->inbuf + 0;
#line 558
  zip->i_ptr = zip->i_end;
#line 559
  zip->o_end = (unsigned char *)((void *)0);
#line 559
  zip->o_ptr = zip->o_end;
#line 560
  zip->bit_buffer = 0U;
#line 560
  zip->bits_left = 0U;
#line 561
  return (zip);
}
}
#line 564 "mspack/mszipd.c"
int mszipd_decompress(struct mszipd_stream *zip , off_t out_bytes ) 
{ register unsigned int bit_buffer ;
  register int bits_left ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  int i ;
  int state ;
  int error ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;

  {
#line 573
  if (! zip) {
#line 573
    return (1);
  } else {
#line 573
    if (out_bytes < 0L) {
#line 573
      return (1);
    }
  }
#line 574
  if (zip->error) {
#line 574
    return (zip->error);
  }
#line 577
  i = zip->o_end - zip->o_ptr;
#line 578
  if ((long )i > out_bytes) {
#line 578
    i = (int )out_bytes;
  }
#line 579
  if (i) {
#line 580
    tmp = ((*((zip->sys)->write)))(zip->output, (void *)zip->o_ptr, i);
#line 580
    if (tmp != i) {
#line 581
      zip->error = 4;
#line 581
      return (zip->error);
    }
#line 583
    zip->o_ptr = zip->o_ptr + i;
#line 584
    out_bytes -= (long )i;
  }
#line 586
  if (out_bytes == 0L) {
#line 586
    return (0);
  }
#line 589
  while (out_bytes > 0L) {
#line 591
    while (1) {
#line 591
      i_ptr = zip->i_ptr;
#line 591
      i_end = zip->i_end;
#line 591
      bit_buffer = zip->bit_buffer;
#line 591
      bits_left = (int )zip->bits_left;
#line 591
      break;
    }
#line 594
    i = bits_left & 7;
#line 594
    bit_buffer >>= i;
#line 594
    bits_left -= i;
#line 595
    state = 0;
#line 596
    while (1) {
#line 597
      while (1) {
#line 597
        while (1) {
#line 597
          while (bits_left < 8) {
#line 597
            if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 597
              tmp___0 = zipd_read_input(zip);
#line 597
              if (tmp___0) {
#line 597
                return (zip->error);
              }
#line 597
              i_ptr = zip->i_ptr;
#line 597
              i_end = zip->i_end;
            }
#line 597
            tmp___1 = i_ptr;
#line 597
            i_ptr ++;
#line 597
            bit_buffer |= (unsigned int )((int )(*tmp___1) << bits_left);
#line 597
            bits_left += 8;
          }
#line 597
          break;
        }
#line 597
        i = (int )(bit_buffer & 255U);
#line 597
        bit_buffer >>= 8;
#line 597
        bits_left -= 8;
#line 597
        break;
      }
#line 598
      if (i == 67) {
#line 598
        state = 1;
      } else {
#line 599
        if (state == 1) {
#line 599
          if (i == 75) {
#line 599
            state = 2;
          } else {
#line 600
            state = 0;
          }
        } else {
#line 600
          state = 0;
        }
      }
#line 596
      if (! (state != 2)) {
#line 596
        break;
      }
    }
#line 604
    zip->window_posn = 0U;
#line 605
    zip->bytes_output = 0;
#line 606
    while (1) {
#line 606
      zip->i_ptr = i_ptr;
#line 606
      zip->i_end = i_end;
#line 606
      zip->bit_buffer = bit_buffer;
#line 606
      zip->bits_left = (unsigned int )bits_left;
#line 606
      break;
    }
#line 607
    error = inflate___0(zip);
#line 607
    if (error) {
#line 609
      if (zip->repair_mode) {
#line 610
        ((*((zip->sys)->message)))((struct mspack_file *)((void *)0), (char *)"MSZIP error, %u bytes of data lost.",
                                   32768 - zip->bytes_output);
#line 612
        i = zip->bytes_output;
#line 612
        while (i < 32768) {
#line 613
          zip->window[i] = (unsigned char )'\000';
#line 612
          i ++;
        }
#line 615
        zip->bytes_output = 32768;
      } else {
#line 618
        if (error > 0) {
#line 618
          zip->error = error;
        } else {
#line 618
          zip->error = 11;
        }
#line 618
        return (zip->error);
      }
    }
#line 621
    zip->o_ptr = & zip->window[0];
#line 622
    zip->o_end = zip->o_ptr + zip->bytes_output;
#line 625
    if (out_bytes < (long )zip->bytes_output) {
#line 625
      i = (int )out_bytes;
    } else {
#line 625
      i = zip->bytes_output;
    }
#line 627
    tmp___2 = ((*((zip->sys)->write)))(zip->output, (void *)zip->o_ptr, i);
#line 627
    if (tmp___2 != i) {
#line 628
      zip->error = 4;
#line 628
      return (zip->error);
    }
#line 632
    if (error > 0) {
#line 632
      if (zip->repair_mode) {
#line 632
        return (error);
      }
    }
#line 634
    zip->o_ptr = zip->o_ptr + i;
#line 635
    out_bytes -= (long )i;
  }
#line 638
  if (out_bytes) {
#line 640
    zip->error = 11;
#line 640
    return (zip->error);
  }
#line 642
  return (0);
}
}
#line 645 "mspack/mszipd.c"
void mszipd_free(struct mszipd_stream *zip ) 
{ struct mspack_system *sys ;

  {
#line 647
  if (zip) {
#line 648
    sys = zip->sys;
#line 649
    ((*(sys->free)))((void *)zip->inbuf);
#line 650
    ((*(sys->free)))((void *)zip);
  }
#line 652
  return;
}
}
#line 1 "qtmd.lo"
#pragma merger(0,"/tmp/cil-TXJ8mQKq.i","-g -O2 -fPIC")
#line 96 "mspack/qtmd.c"
static int qtmd_read_input(struct qtmd_stream *qtm ) 
{ int read___0 ;
  int tmp ;

  {
#line 97
  tmp = ((*((qtm->sys)->read)))(qtm->input, (void *)(qtm->inbuf + 0), (int )qtm->inbuf_size);
#line 97
  read___0 = tmp;
#line 98
  if (read___0 < 0) {
#line 98
    qtm->error = 3;
#line 98
    return (qtm->error);
  }
#line 100
  qtm->i_ptr = qtm->inbuf + 0;
#line 101
  qtm->i_end = qtm->inbuf + read___0;
#line 102
  return (0);
}
}
#line 119 "mspack/qtmd.c"
static unsigned int position_base___0[42]  ;
#line 120 "mspack/qtmd.c"
static unsigned char extra_bits___0[42]  ;
#line 120 "mspack/qtmd.c"
static unsigned char length_base[27]  ;
#line 120 "mspack/qtmd.c"
static unsigned char length_extra[27]  ;
#line 122 "mspack/qtmd.c"
static void qtmd_static_init(void) 
{ unsigned int i ;
  unsigned int offset ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 125
  i = 0U;
#line 125
  offset = 0U;
#line 125
  while (i < 42U) {
#line 126
    position_base___0[i] = offset;
#line 127
    if (i < 2U) {
#line 127
      tmp = 0U;
    } else {
#line 127
      tmp = i - 2U;
    }
#line 127
    extra_bits___0[i] = (unsigned char )(tmp >> 1);
#line 128
    offset += (unsigned int )(1 << (int )extra_bits___0[i]);
#line 125
    i ++;
  }
#line 131
  i = 0U;
#line 131
  offset = 0U;
#line 131
  while (i < 26U) {
#line 132
    length_base[i] = (unsigned char )offset;
#line 133
    if (i < 2U) {
#line 133
      tmp___0 = 0U;
    } else {
#line 133
      tmp___0 = i - 2U;
    }
#line 133
    length_extra[i] = (unsigned char )(tmp___0 >> 2);
#line 134
    offset += (unsigned int )(1 << (int )length_extra[i]);
#line 131
    i ++;
  }
#line 136
  length_base[26] = (unsigned char)254;
#line 136
  length_extra[26] = (unsigned char)0;
#line 137
  return;
}
}
#line 179 "mspack/qtmd.c"
static void qtmd_update_model(struct qtmd_model *model ) 
{ struct qtmd_modelsym tmp ;
  int i ;
  int j ;

  {
#line 183
  model->shiftsleft = model->shiftsleft - 1;
#line 183
  if (model->shiftsleft) {
#line 184
    i = model->entries - 1;
#line 184
    while (i >= 0) {
#line 186
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq >>
                                                     1);
#line 187
      if ((int )(model->syms + i)->cumfreq <= (int )(model->syms + (i + 1))->cumfreq) {
#line 188
        (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + (i + 1))->cumfreq +
                                                       1);
      }
#line 184
      i --;
    }
  } else {
#line 193
    model->shiftsleft = 50;
#line 194
    i = 0;
#line 194
    while (i < model->entries) {
#line 197
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq -
                                                     (int )(model->syms + (i + 1))->cumfreq);
#line 198
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq +
                                                     1);
#line 199
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq >>
                                                     1);
#line 194
      i ++;
    }
#line 205
    i = 0;
#line 205
    while (i < model->entries - 1) {
#line 206
      j = i + 1;
#line 206
      while (j < model->entries) {
#line 207
        if ((int )(model->syms + i)->cumfreq < (int )(model->syms + j)->cumfreq) {
#line 208
          tmp = (*(model->syms + i));
#line 209
          (*(model->syms + i)) = (*(model->syms + j));
#line 210
          (*(model->syms + j)) = tmp;
        }
#line 206
        j ++;
      }
#line 205
      i ++;
    }
#line 216
    i = model->entries - 1;
#line 216
    while (i >= 0) {
#line 217
      (model->syms + i)->cumfreq = (unsigned short )((int )(model->syms + i)->cumfreq +
                                                     (int )(model->syms + (i + 1))->cumfreq);
#line 216
      i --;
    }
  }
#line 220
  return;
}
}
#line 223 "mspack/qtmd.c"
static void qtmd_init_model(struct qtmd_model *model , struct qtmd_modelsym *syms ,
                            int start , int len ) 
{ int i ;

  {
#line 228
  model->shiftsleft = 4;
#line 229
  model->entries = len;
#line 230
  model->syms = syms;
#line 232
  i = 0;
#line 232
  while (i <= len) {
#line 233
    (syms + i)->sym = (unsigned short )(start + i);
#line 234
    (syms + i)->cumfreq = (unsigned short )(len - i);
#line 232
    i ++;
  }
#line 236
  return;
}
}
#line 241 "mspack/qtmd.c"
struct qtmd_stream *qtmd_init(struct mspack_system *system , struct mspack_file *input ,
                              struct mspack_file *output , int window_bits , int input_buffer_size ) 
{ unsigned int window_size ;
  struct qtmd_stream *qtm ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 246
  window_size = (unsigned int )(1 << window_bits);
#line 250
  if (! system) {
#line 250
    return ((struct qtmd_stream *)((void *)0));
  }
#line 253
  if (window_bits < 10) {
#line 253
    return ((struct qtmd_stream *)((void *)0));
  } else {
#line 253
    if (window_bits > 21) {
#line 253
      return ((struct qtmd_stream *)((void *)0));
    }
  }
#line 255
  input_buffer_size = (input_buffer_size + 1) & -2;
#line 256
  if (input_buffer_size < 2) {
#line 256
    return ((struct qtmd_stream *)((void *)0));
  }
#line 259
  qtmd_static_init();
#line 262
  qtm = (struct qtmd_stream *)((*(system->alloc)))(system, sizeof(struct qtmd_stream ));
#line 262
  if (! qtm) {
#line 263
    return ((struct qtmd_stream *)((void *)0));
  }
#line 267
  qtm->window = (unsigned char *)((*(system->alloc)))(system, window_size);
#line 268
  qtm->inbuf = (unsigned char *)((*(system->alloc)))(system, (unsigned int )input_buffer_size);
#line 269
  if (! qtm->window) {
#line 270
    ((*(system->free)))((void *)qtm->window);
#line 271
    ((*(system->free)))((void *)qtm->inbuf);
#line 272
    ((*(system->free)))((void *)qtm);
#line 273
    return ((struct qtmd_stream *)((void *)0));
  } else {
#line 269
    if (! qtm->inbuf) {
#line 270
      ((*(system->free)))((void *)qtm->window);
#line 271
      ((*(system->free)))((void *)qtm->inbuf);
#line 272
      ((*(system->free)))((void *)qtm);
#line 273
      return ((struct qtmd_stream *)((void *)0));
    }
  }
#line 277
  qtm->sys = system;
#line 278
  qtm->input = input;
#line 279
  qtm->output = output;
#line 280
  qtm->inbuf_size = (unsigned int )input_buffer_size;
#line 281
  qtm->window_size = window_size;
#line 282
  qtm->window_posn = 0U;
#line 283
  qtm->frame_start = 0U;
#line 284
  qtm->header_read = (unsigned char)0;
#line 285
  qtm->error = 0;
#line 287
  qtm->i_end = qtm->inbuf + 0;
#line 287
  qtm->i_ptr = qtm->i_end;
#line 288
  qtm->o_end = qtm->window + 0;
#line 288
  qtm->o_ptr = qtm->o_end;
#line 289
  qtm->bits_left = (unsigned char)0;
#line 290
  qtm->bit_buffer = 0U;
#line 297
  i = window_bits * 2;
#line 298
  qtmd_init_model(& qtm->model0, & qtm->m0sym[0], 0, 64);
#line 299
  qtmd_init_model(& qtm->model1, & qtm->m1sym[0], 64, 64);
#line 300
  qtmd_init_model(& qtm->model2, & qtm->m2sym[0], 128, 64);
#line 301
  qtmd_init_model(& qtm->model3, & qtm->m3sym[0], 192, 64);
#line 302
  if (i > 24) {
#line 302
    tmp = 24;
  } else {
#line 302
    tmp = i;
  }
#line 302
  qtmd_init_model(& qtm->model4, & qtm->m4sym[0], 0, tmp);
#line 303
  if (i > 36) {
#line 303
    tmp___0 = 36;
  } else {
#line 303
    tmp___0 = i;
  }
#line 303
  qtmd_init_model(& qtm->model5, & qtm->m5sym[0], 0, tmp___0);
#line 304
  qtmd_init_model(& qtm->model6, & qtm->m6sym[0], 0, i);
#line 305
  qtmd_init_model(& qtm->model6len, & qtm->m6lsym[0], 0, 27);
#line 306
  qtmd_init_model(& qtm->model7, & qtm->m7sym[0], 0, 7);
#line 309
  return (qtm);
}
}
#line 312 "mspack/qtmd.c"
int qtmd_decompress(struct qtmd_stream *qtm , off_t out_bytes ) 
{ unsigned int frame_start ;
  unsigned int frame_end ;
  unsigned int window_posn ;
  unsigned int match_offset ;
  unsigned int range ;
  unsigned char *window ;
  unsigned char *i_ptr ;
  unsigned char *i_end ;
  unsigned char *runsrc ;
  unsigned char *rundest ;
  int i ;
  int j ;
  int selector ;
  int extra ;
  int sym ;
  int match_length ;
  unsigned short H ;
  unsigned short L ;
  unsigned short C ;
  unsigned short symf ;
  register unsigned int bit_buffer ;
  register unsigned char bits_left ;
  unsigned char bits_needed ;
  unsigned char bit_run ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct qtmd_model *mdl ;
  struct qtmd_model *tmp___4 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  int tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
#line 323
  if (! qtm) {
#line 323
    return (1);
  } else {
#line 323
    if (out_bytes < 0L) {
#line 323
      return (1);
    }
  }
#line 324
  if (qtm->error) {
#line 324
    return (qtm->error);
  }
#line 327
  i = qtm->o_end - qtm->o_ptr;
#line 328
  if ((long )i > out_bytes) {
#line 328
    i = (int )out_bytes;
  }
#line 329
  if (i) {
#line 330
    tmp = ((*((qtm->sys)->write)))(qtm->output, (void *)qtm->o_ptr, i);
#line 330
    if (tmp != i) {
#line 331
      qtm->error = 4;
#line 331
      return (qtm->error);
    }
#line 333
    qtm->o_ptr = qtm->o_ptr + i;
#line 334
    out_bytes -= (long )i;
  }
#line 336
  if (out_bytes == 0L) {
#line 336
    return (0);
  }
#line 339
  while (1) {
#line 339
    i_ptr = qtm->i_ptr;
#line 339
    i_end = qtm->i_end;
#line 339
    bit_buffer = qtm->bit_buffer;
#line 339
    bits_left = qtm->bits_left;
#line 339
    break;
  }
#line 340
  window = qtm->window;
#line 341
  window_posn = qtm->window_posn;
#line 342
  frame_start = qtm->frame_start;
#line 343
  H = qtm->H;
#line 344
  L = qtm->L;
#line 345
  C = qtm->C;
#line 348
  while ((long )(qtm->o_end - qtm->o_ptr) < out_bytes) {
#line 351
    if (! qtm->header_read) {
#line 352
      H = (unsigned short)65535;
#line 352
      L = (unsigned short)0;
#line 352
      while (1) {
#line 352
        C = (unsigned short)0;
#line 352
        bits_needed = (unsigned char)16;
#line 352
        while ((int )bits_needed > 0) {
#line 352
          while (1) {
#line 352
            if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 352
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 352
                tmp___0 = qtmd_read_input(qtm);
#line 352
                if (tmp___0) {
#line 352
                  return (qtm->error);
                }
#line 352
                i_ptr = qtm->i_ptr;
#line 352
                i_end = qtm->i_end;
              }
#line 352
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                    1))) <<
                                            ((sizeof(unsigned int ) * 8U - 16U) -
                                             (unsigned int )bits_left));
#line 352
              bits_left = (unsigned char )((int )bits_left + 16);
#line 352
              i_ptr += 2;
            }
#line 352
            break;
          }
#line 352
          if ((int )bits_left < (int )bits_needed) {
#line 352
            bit_run = bits_left;
          } else {
#line 352
            bit_run = bits_needed;
          }
#line 352
          C = (unsigned short )((unsigned int )((int )C << (int )bit_run) | (bit_buffer >>
                                                                             (sizeof(unsigned int ) *
                                                                              8U -
                                                                              (unsigned int )bit_run)));
#line 352
          bit_buffer <<= (int )bit_run;
#line 352
          bits_left = (unsigned char )((int )bits_left - (int )bit_run);
#line 352
          bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
        }
#line 352
        break;
      }
#line 353
      qtm->header_read = (unsigned char)1;
    }
#line 357
    frame_end = (unsigned int )((unsigned long )window_posn + (unsigned long )(out_bytes -
                                                                               (long )(qtm->o_end -
                                                                                       qtm->o_ptr)));
#line 358
    if (frame_start + 32768U < frame_end) {
#line 359
      frame_end = frame_start + 32768U;
    }
#line 362
    while (window_posn < frame_end) {
#line 363
      while (1) {
#line 363
        range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
#line 363
        symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model7.syms +
                                                                                    0)->cumfreq -
                                                 1) / range & 65535U);
#line 363
        i = 1;
#line 363
        while (i < qtm->model7.entries) {
#line 363
          if ((int )(qtm->model7.syms + i)->cumfreq <= (int )symf) {
#line 363
            break;
          }
#line 363
          i ++;
        }
#line 363
        selector = (int )(qtm->model7.syms + (i - 1))->sym;
#line 363
        range = (unsigned int )(((int )H - (int )L) + 1);
#line 363
        symf = (qtm->model7.syms + 0)->cumfreq;
#line 363
        H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model7.syms +
                                                                   (i - 1))->cumfreq *
                                                   range) / (unsigned int )symf) -
                              1U);
#line 363
        L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model7.syms +
                                                                  i)->cumfreq * range) /
                                                 (unsigned int )symf);
#line 363
        while (1) {
#line 363
          i --;
#line 363
          (qtm->model7.syms + i)->cumfreq = (unsigned short )((int )(qtm->model7.syms +
                                                                     i)->cumfreq +
                                                              8);
#line 363
          if (! (i > 0)) {
#line 363
            break;
          }
        }
#line 363
        if ((int )(qtm->model7.syms + 0)->cumfreq > 3800) {
#line 363
          qtmd_update_model(& qtm->model7);
        }
#line 363
        while (1) {
#line 363
          if (((int )L & 32768) != ((int )H & 32768)) {
#line 363
            if ((int )L & 16384) {
#line 363
              if (! ((int )H & 16384)) {
#line 363
                C = (unsigned short )((int )C ^ 16384);
#line 363
                L = (unsigned short )((int )L & 16383);
#line 363
                H = (unsigned short )((int )H | 16384);
              } else {
#line 363
                break;
              }
            } else {
#line 363
              break;
            }
          }
#line 363
          L = (unsigned short )((int )L << 1);
#line 363
          H = (unsigned short )(((int )H << 1) | 1);
#line 363
          while (1) {
#line 363
            if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 363
              if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 363
                tmp___1 = qtmd_read_input(qtm);
#line 363
                if (tmp___1) {
#line 363
                  return (qtm->error);
                }
#line 363
                i_ptr = qtm->i_ptr;
#line 363
                i_end = qtm->i_end;
              }
#line 363
              bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                    1))) <<
                                            ((sizeof(unsigned int ) * 8U - 16U) -
                                             (unsigned int )bits_left));
#line 363
              bits_left = (unsigned char )((int )bits_left + 16);
#line 363
              i_ptr += 2;
            }
#line 363
            break;
          }
#line 363
          C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                8U -
                                                                                1U)));
#line 363
          bit_buffer <<= 1;
#line 363
          bits_left = (unsigned char )((int )bits_left - 1);
        }
#line 363
        break;
      }
#line 364
      if (selector < 4) {
#line 365
        if (selector == 0) {
#line 365
          tmp___4 = & qtm->model0;
        } else {
#line 365
          if (selector == 1) {
#line 365
            tmp___4 = & qtm->model1;
          } else {
#line 365
            if (selector == 2) {
#line 365
              tmp___4 = & qtm->model2;
            } else {
#line 365
              tmp___4 = & qtm->model3;
            }
          }
        }
#line 365
        mdl = tmp___4;
#line 369
        while (1) {
#line 369
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
#line 369
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(mdl->syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
#line 369
          i = 1;
#line 369
          while (i < mdl->entries) {
#line 369
            if ((int )(mdl->syms + i)->cumfreq <= (int )symf) {
#line 369
              break;
            }
#line 369
            i ++;
          }
#line 369
          sym = (int )(mdl->syms + (i - 1))->sym;
#line 369
          range = (unsigned int )(((int )H - (int )L) + 1);
#line 369
          symf = (mdl->syms + 0)->cumfreq;
#line 369
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(mdl->syms + (i -
                                                                                  1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
#line 369
          L = (unsigned short )((unsigned int )L + ((unsigned int )(mdl->syms + i)->cumfreq *
                                                    range) / (unsigned int )symf);
#line 369
          while (1) {
#line 369
            i --;
#line 369
            (mdl->syms + i)->cumfreq = (unsigned short )((int )(mdl->syms + i)->cumfreq +
                                                         8);
#line 369
            if (! (i > 0)) {
#line 369
              break;
            }
          }
#line 369
          if ((int )(mdl->syms + 0)->cumfreq > 3800) {
#line 369
            qtmd_update_model(mdl);
          }
#line 369
          while (1) {
#line 369
            if (((int )L & 32768) != ((int )H & 32768)) {
#line 369
              if ((int )L & 16384) {
#line 369
                if (! ((int )H & 16384)) {
#line 369
                  C = (unsigned short )((int )C ^ 16384);
#line 369
                  L = (unsigned short )((int )L & 16383);
#line 369
                  H = (unsigned short )((int )H | 16384);
                } else {
#line 369
                  break;
                }
              } else {
#line 369
                break;
              }
            }
#line 369
            L = (unsigned short )((int )L << 1);
#line 369
            H = (unsigned short )(((int )H << 1) | 1);
#line 369
            while (1) {
#line 369
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 369
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 369
                  tmp___6 = qtmd_read_input(qtm);
#line 369
                  if (tmp___6) {
#line 369
                    return (qtm->error);
                  }
#line 369
                  i_ptr = qtm->i_ptr;
#line 369
                  i_end = qtm->i_end;
                }
#line 369
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 369
                bits_left = (unsigned char )((int )bits_left + 16);
#line 369
                i_ptr += 2;
              }
#line 369
              break;
            }
#line 369
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
#line 369
            bit_buffer <<= 1;
#line 369
            bits_left = (unsigned char )((int )bits_left - 1);
          }
#line 369
          break;
        }
#line 370
        tmp___7 = window_posn;
#line 370
        window_posn ++;
#line 370
        (*(window + tmp___7)) = (unsigned char )sym;
      } else {
#line 373
        switch (selector) {
        case 4: ;
#line 375
        while (1) {
#line 375
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
#line 375
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model4.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
#line 375
          i = 1;
#line 375
          while (i < qtm->model4.entries) {
#line 375
            if ((int )(qtm->model4.syms + i)->cumfreq <= (int )symf) {
#line 375
              break;
            }
#line 375
            i ++;
          }
#line 375
          sym = (int )(qtm->model4.syms + (i - 1))->sym;
#line 375
          range = (unsigned int )(((int )H - (int )L) + 1);
#line 375
          symf = (qtm->model4.syms + 0)->cumfreq;
#line 375
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model4.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
#line 375
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model4.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
#line 375
          while (1) {
#line 375
            i --;
#line 375
            (qtm->model4.syms + i)->cumfreq = (unsigned short )((int )(qtm->model4.syms +
                                                                       i)->cumfreq +
                                                                8);
#line 375
            if (! (i > 0)) {
#line 375
              break;
            }
          }
#line 375
          if ((int )(qtm->model4.syms + 0)->cumfreq > 3800) {
#line 375
            qtmd_update_model(& qtm->model4);
          }
#line 375
          while (1) {
#line 375
            if (((int )L & 32768) != ((int )H & 32768)) {
#line 375
              if ((int )L & 16384) {
#line 375
                if (! ((int )H & 16384)) {
#line 375
                  C = (unsigned short )((int )C ^ 16384);
#line 375
                  L = (unsigned short )((int )L & 16383);
#line 375
                  H = (unsigned short )((int )H | 16384);
                } else {
#line 375
                  break;
                }
              } else {
#line 375
                break;
              }
            }
#line 375
            L = (unsigned short )((int )L << 1);
#line 375
            H = (unsigned short )(((int )H << 1) | 1);
#line 375
            while (1) {
#line 375
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 375
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 375
                  tmp___8 = qtmd_read_input(qtm);
#line 375
                  if (tmp___8) {
#line 375
                    return (qtm->error);
                  }
#line 375
                  i_ptr = qtm->i_ptr;
#line 375
                  i_end = qtm->i_end;
                }
#line 375
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 375
                bits_left = (unsigned char )((int )bits_left + 16);
#line 375
                i_ptr += 2;
              }
#line 375
              break;
            }
#line 375
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
#line 375
            bit_buffer <<= 1;
#line 375
            bits_left = (unsigned char )((int )bits_left - 1);
          }
#line 375
          break;
        }
#line 376
        while (1) {
#line 376
          extra = 0;
#line 376
          bits_needed = extra_bits___0[sym];
#line 376
          while ((int )bits_needed > 0) {
#line 376
            while (1) {
#line 376
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 376
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 376
                  tmp___9 = qtmd_read_input(qtm);
#line 376
                  if (tmp___9) {
#line 376
                    return (qtm->error);
                  }
#line 376
                  i_ptr = qtm->i_ptr;
#line 376
                  i_end = qtm->i_end;
                }
#line 376
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 376
                bits_left = (unsigned char )((int )bits_left + 16);
#line 376
                i_ptr += 2;
              }
#line 376
              break;
            }
#line 376
            if ((int )bits_left < (int )bits_needed) {
#line 376
              bit_run = bits_left;
            } else {
#line 376
              bit_run = bits_needed;
            }
#line 376
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
#line 376
            bit_buffer <<= (int )bit_run;
#line 376
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
#line 376
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
#line 376
          break;
        }
#line 377
        match_offset = (position_base___0[sym] + (unsigned int )extra) + 1U;
#line 378
        match_length = 3;
#line 379
        break;
        case 5: ;
#line 382
        while (1) {
#line 382
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
#line 382
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model5.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
#line 382
          i = 1;
#line 382
          while (i < qtm->model5.entries) {
#line 382
            if ((int )(qtm->model5.syms + i)->cumfreq <= (int )symf) {
#line 382
              break;
            }
#line 382
            i ++;
          }
#line 382
          sym = (int )(qtm->model5.syms + (i - 1))->sym;
#line 382
          range = (unsigned int )(((int )H - (int )L) + 1);
#line 382
          symf = (qtm->model5.syms + 0)->cumfreq;
#line 382
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model5.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
#line 382
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model5.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
#line 382
          while (1) {
#line 382
            i --;
#line 382
            (qtm->model5.syms + i)->cumfreq = (unsigned short )((int )(qtm->model5.syms +
                                                                       i)->cumfreq +
                                                                8);
#line 382
            if (! (i > 0)) {
#line 382
              break;
            }
          }
#line 382
          if ((int )(qtm->model5.syms + 0)->cumfreq > 3800) {
#line 382
            qtmd_update_model(& qtm->model5);
          }
#line 382
          while (1) {
#line 382
            if (((int )L & 32768) != ((int )H & 32768)) {
#line 382
              if ((int )L & 16384) {
#line 382
                if (! ((int )H & 16384)) {
#line 382
                  C = (unsigned short )((int )C ^ 16384);
#line 382
                  L = (unsigned short )((int )L & 16383);
#line 382
                  H = (unsigned short )((int )H | 16384);
                } else {
#line 382
                  break;
                }
              } else {
#line 382
                break;
              }
            }
#line 382
            L = (unsigned short )((int )L << 1);
#line 382
            H = (unsigned short )(((int )H << 1) | 1);
#line 382
            while (1) {
#line 382
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 382
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 382
                  tmp___10 = qtmd_read_input(qtm);
#line 382
                  if (tmp___10) {
#line 382
                    return (qtm->error);
                  }
#line 382
                  i_ptr = qtm->i_ptr;
#line 382
                  i_end = qtm->i_end;
                }
#line 382
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 382
                bits_left = (unsigned char )((int )bits_left + 16);
#line 382
                i_ptr += 2;
              }
#line 382
              break;
            }
#line 382
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
#line 382
            bit_buffer <<= 1;
#line 382
            bits_left = (unsigned char )((int )bits_left - 1);
          }
#line 382
          break;
        }
#line 383
        while (1) {
#line 383
          extra = 0;
#line 383
          bits_needed = extra_bits___0[sym];
#line 383
          while ((int )bits_needed > 0) {
#line 383
            while (1) {
#line 383
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 383
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 383
                  tmp___11 = qtmd_read_input(qtm);
#line 383
                  if (tmp___11) {
#line 383
                    return (qtm->error);
                  }
#line 383
                  i_ptr = qtm->i_ptr;
#line 383
                  i_end = qtm->i_end;
                }
#line 383
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 383
                bits_left = (unsigned char )((int )bits_left + 16);
#line 383
                i_ptr += 2;
              }
#line 383
              break;
            }
#line 383
            if ((int )bits_left < (int )bits_needed) {
#line 383
              bit_run = bits_left;
            } else {
#line 383
              bit_run = bits_needed;
            }
#line 383
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
#line 383
            bit_buffer <<= (int )bit_run;
#line 383
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
#line 383
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
#line 383
          break;
        }
#line 384
        match_offset = (position_base___0[sym] + (unsigned int )extra) + 1U;
#line 385
        match_length = 4;
#line 386
        break;
        case 6: ;
#line 389
        while (1) {
#line 389
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
#line 389
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model6len.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
#line 389
          i = 1;
#line 389
          while (i < qtm->model6len.entries) {
#line 389
            if ((int )(qtm->model6len.syms + i)->cumfreq <= (int )symf) {
#line 389
              break;
            }
#line 389
            i ++;
          }
#line 389
          sym = (int )(qtm->model6len.syms + (i - 1))->sym;
#line 389
          range = (unsigned int )(((int )H - (int )L) + 1);
#line 389
          symf = (qtm->model6len.syms + 0)->cumfreq;
#line 389
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model6len.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
#line 389
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model6len.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
#line 389
          while (1) {
#line 389
            i --;
#line 389
            (qtm->model6len.syms + i)->cumfreq = (unsigned short )((int )(qtm->model6len.syms +
                                                                          i)->cumfreq +
                                                                   8);
#line 389
            if (! (i > 0)) {
#line 389
              break;
            }
          }
#line 389
          if ((int )(qtm->model6len.syms + 0)->cumfreq > 3800) {
#line 389
            qtmd_update_model(& qtm->model6len);
          }
#line 389
          while (1) {
#line 389
            if (((int )L & 32768) != ((int )H & 32768)) {
#line 389
              if ((int )L & 16384) {
#line 389
                if (! ((int )H & 16384)) {
#line 389
                  C = (unsigned short )((int )C ^ 16384);
#line 389
                  L = (unsigned short )((int )L & 16383);
#line 389
                  H = (unsigned short )((int )H | 16384);
                } else {
#line 389
                  break;
                }
              } else {
#line 389
                break;
              }
            }
#line 389
            L = (unsigned short )((int )L << 1);
#line 389
            H = (unsigned short )(((int )H << 1) | 1);
#line 389
            while (1) {
#line 389
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 389
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 389
                  tmp___12 = qtmd_read_input(qtm);
#line 389
                  if (tmp___12) {
#line 389
                    return (qtm->error);
                  }
#line 389
                  i_ptr = qtm->i_ptr;
#line 389
                  i_end = qtm->i_end;
                }
#line 389
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 389
                bits_left = (unsigned char )((int )bits_left + 16);
#line 389
                i_ptr += 2;
              }
#line 389
              break;
            }
#line 389
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
#line 389
            bit_buffer <<= 1;
#line 389
            bits_left = (unsigned char )((int )bits_left - 1);
          }
#line 389
          break;
        }
#line 390
        while (1) {
#line 390
          extra = 0;
#line 390
          bits_needed = length_extra[sym];
#line 390
          while ((int )bits_needed > 0) {
#line 390
            while (1) {
#line 390
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 390
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 390
                  tmp___13 = qtmd_read_input(qtm);
#line 390
                  if (tmp___13) {
#line 390
                    return (qtm->error);
                  }
#line 390
                  i_ptr = qtm->i_ptr;
#line 390
                  i_end = qtm->i_end;
                }
#line 390
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 390
                bits_left = (unsigned char )((int )bits_left + 16);
#line 390
                i_ptr += 2;
              }
#line 390
              break;
            }
#line 390
            if ((int )bits_left < (int )bits_needed) {
#line 390
              bit_run = bits_left;
            } else {
#line 390
              bit_run = bits_needed;
            }
#line 390
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
#line 390
            bit_buffer <<= (int )bit_run;
#line 390
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
#line 390
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
#line 390
          break;
        }
#line 391
        match_length = ((int )length_base[sym] + extra) + 5;
#line 393
        while (1) {
#line 393
          range = (unsigned int )((((int )H - (int )L) & 65535) + 1);
#line 393
          symf = (unsigned short )((unsigned int )((((int )C - (int )L) + 1) * (int )(qtm->model6.syms +
                                                                                      0)->cumfreq -
                                                   1) / range & 65535U);
#line 393
          i = 1;
#line 393
          while (i < qtm->model6.entries) {
#line 393
            if ((int )(qtm->model6.syms + i)->cumfreq <= (int )symf) {
#line 393
              break;
            }
#line 393
            i ++;
          }
#line 393
          sym = (int )(qtm->model6.syms + (i - 1))->sym;
#line 393
          range = (unsigned int )(((int )H - (int )L) + 1);
#line 393
          symf = (qtm->model6.syms + 0)->cumfreq;
#line 393
          H = (unsigned short )(((unsigned int )L + ((unsigned int )(qtm->model6.syms +
                                                                     (i - 1))->cumfreq *
                                                     range) / (unsigned int )symf) -
                                1U);
#line 393
          L = (unsigned short )((unsigned int )L + ((unsigned int )(qtm->model6.syms +
                                                                    i)->cumfreq *
                                                    range) / (unsigned int )symf);
#line 393
          while (1) {
#line 393
            i --;
#line 393
            (qtm->model6.syms + i)->cumfreq = (unsigned short )((int )(qtm->model6.syms +
                                                                       i)->cumfreq +
                                                                8);
#line 393
            if (! (i > 0)) {
#line 393
              break;
            }
          }
#line 393
          if ((int )(qtm->model6.syms + 0)->cumfreq > 3800) {
#line 393
            qtmd_update_model(& qtm->model6);
          }
#line 393
          while (1) {
#line 393
            if (((int )L & 32768) != ((int )H & 32768)) {
#line 393
              if ((int )L & 16384) {
#line 393
                if (! ((int )H & 16384)) {
#line 393
                  C = (unsigned short )((int )C ^ 16384);
#line 393
                  L = (unsigned short )((int )L & 16383);
#line 393
                  H = (unsigned short )((int )H | 16384);
                } else {
#line 393
                  break;
                }
              } else {
#line 393
                break;
              }
            }
#line 393
            L = (unsigned short )((int )L << 1);
#line 393
            H = (unsigned short )(((int )H << 1) | 1);
#line 393
            while (1) {
#line 393
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 393
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 393
                  tmp___14 = qtmd_read_input(qtm);
#line 393
                  if (tmp___14) {
#line 393
                    return (qtm->error);
                  }
#line 393
                  i_ptr = qtm->i_ptr;
#line 393
                  i_end = qtm->i_end;
                }
#line 393
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 393
                bits_left = (unsigned char )((int )bits_left + 16);
#line 393
                i_ptr += 2;
              }
#line 393
              break;
            }
#line 393
            C = (unsigned short )((unsigned int )((int )C << 1) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                                  8U -
                                                                                  1U)));
#line 393
            bit_buffer <<= 1;
#line 393
            bits_left = (unsigned char )((int )bits_left - 1);
          }
#line 393
          break;
        }
#line 394
        while (1) {
#line 394
          extra = 0;
#line 394
          bits_needed = extra_bits___0[sym];
#line 394
          while ((int )bits_needed > 0) {
#line 394
            while (1) {
#line 394
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 394
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 394
                  tmp___15 = qtmd_read_input(qtm);
#line 394
                  if (tmp___15) {
#line 394
                    return (qtm->error);
                  }
#line 394
                  i_ptr = qtm->i_ptr;
#line 394
                  i_end = qtm->i_end;
                }
#line 394
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 394
                bits_left = (unsigned char )((int )bits_left + 16);
#line 394
                i_ptr += 2;
              }
#line 394
              break;
            }
#line 394
            if ((int )bits_left < (int )bits_needed) {
#line 394
              bit_run = bits_left;
            } else {
#line 394
              bit_run = bits_needed;
            }
#line 394
            extra = (int )((unsigned int )(extra << (int )bit_run) | (bit_buffer >>
                                                                      (sizeof(unsigned int ) *
                                                                       8U - (unsigned int )bit_run)));
#line 394
            bit_buffer <<= (int )bit_run;
#line 394
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
#line 394
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
#line 394
          break;
        }
#line 395
        match_offset = (position_base___0[sym] + (unsigned int )extra) + 1U;
#line 396
        break;
        default: 
#line 400
        qtm->error = 11;
#line 400
        return (qtm->error);
        }
#line 403
        rundest = window + window_posn;
#line 404
        i = match_length;
#line 406
        if (match_offset > window_posn) {
#line 408
          j = (int )(match_offset - window_posn);
#line 409
          if (j > (int )qtm->window_size) {
#line 411
            qtm->error = 11;
#line 411
            return (qtm->error);
          }
#line 413
          runsrc = window + (qtm->window_size - (unsigned int )j);
#line 414
          if (j < i) {
#line 416
            i -= j;
#line 416
            while (1) {
#line 416
              tmp___18 = j;
#line 416
              j --;
#line 416
              if (! (tmp___18 > 0)) {
#line 416
                break;
              }
#line 416
              tmp___16 = rundest;
#line 416
              rundest ++;
#line 416
              tmp___17 = runsrc;
#line 416
              runsrc ++;
#line 416
              (*tmp___16) = (*tmp___17);
            }
#line 417
            runsrc = window;
          }
#line 419
          while (1) {
#line 419
            tmp___21 = i;
#line 419
            i --;
#line 419
            if (! (tmp___21 > 0)) {
#line 419
              break;
            }
#line 419
            tmp___19 = rundest;
#line 419
            rundest ++;
#line 419
            tmp___20 = runsrc;
#line 419
            runsrc ++;
#line 419
            (*tmp___19) = (*tmp___20);
          }
        } else {
#line 422
          runsrc = rundest - match_offset;
#line 423
          while (1) {
#line 423
            tmp___24 = i;
#line 423
            i --;
#line 423
            if (! (tmp___24 > 0)) {
#line 423
              break;
            }
#line 423
            tmp___22 = rundest;
#line 423
            rundest ++;
#line 423
            tmp___23 = runsrc;
#line 423
            runsrc ++;
#line 423
            (*tmp___22) = (*tmp___23);
          }
        }
#line 425
        window_posn += (unsigned int )match_length;
      }
    }
#line 429
    qtm->o_end = window + window_posn;
#line 432
    if (window_posn - frame_start >= 32768U) {
#line 433
      if (window_posn - frame_start != 32768U) {
#line 435
        qtm->error = 11;
#line 435
        return (qtm->error);
      }
#line 439
      if ((int )bits_left & 7) {
#line 439
        bit_buffer <<= (int )bits_left & 7;
#line 439
        bits_left = (unsigned char )((int )bits_left - ((int )bits_left & 7));
      }
#line 440
      while (1) {
#line 440
        while (1) {
#line 440
          i = 0;
#line 440
          bits_needed = (unsigned char)8;
#line 440
          while ((int )bits_needed > 0) {
#line 440
            while (1) {
#line 440
              if ((unsigned int )bits_left <= sizeof(unsigned int ) * 8U - 16U) {
#line 440
                if ((unsigned int )i_ptr >= (unsigned int )i_end) {
#line 440
                  tmp___25 = qtmd_read_input(qtm);
#line 440
                  if (tmp___25) {
#line 440
                    return (qtm->error);
                  }
#line 440
                  i_ptr = qtm->i_ptr;
#line 440
                  i_end = qtm->i_end;
                }
#line 440
                bit_buffer |= (unsigned int )((((int )(*(i_ptr + 0)) << 8) | (int )(*(i_ptr +
                                                                                      1))) <<
                                              ((sizeof(unsigned int ) * 8U - 16U) -
                                               (unsigned int )bits_left));
#line 440
                bits_left = (unsigned char )((int )bits_left + 16);
#line 440
                i_ptr += 2;
              }
#line 440
              break;
            }
#line 440
            if ((int )bits_left < (int )bits_needed) {
#line 440
              bit_run = bits_left;
            } else {
#line 440
              bit_run = bits_needed;
            }
#line 440
            i = (int )((unsigned int )(i << (int )bit_run) | (bit_buffer >> (sizeof(unsigned int ) *
                                                                             8U -
                                                                             (unsigned int )bit_run)));
#line 440
            bit_buffer <<= (int )bit_run;
#line 440
            bits_left = (unsigned char )((int )bits_left - (int )bit_run);
#line 440
            bits_needed = (unsigned char )((int )bits_needed - (int )bit_run);
          }
#line 440
          break;
        }
#line 440
        if (! (i != 255)) {
#line 440
          break;
        }
      }
#line 441
      qtm->header_read = (unsigned char)0;
#line 444
      if (window_posn == qtm->window_size) {
#line 446
        i = qtm->o_end - qtm->o_ptr;
#line 447
        tmp___26 = ((*((qtm->sys)->write)))(qtm->output, (void *)qtm->o_ptr, i);
#line 447
        if (tmp___26 != i) {
#line 448
          qtm->error = 4;
#line 448
          return (qtm->error);
        }
#line 450
        out_bytes -= (long )i;
#line 451
        qtm->o_ptr = window + 0;
#line 452
        qtm->o_end = window + 0;
#line 453
        window_posn = 0U;
      }
#line 456
      frame_start = window_posn;
    }
  }
#line 461
  if (out_bytes) {
#line 462
    i = (int )out_bytes;
#line 463
    tmp___27 = ((*((qtm->sys)->write)))(qtm->output, (void *)qtm->o_ptr, i);
#line 463
    if (tmp___27 != i) {
#line 464
      qtm->error = 4;
#line 464
      return (qtm->error);
    }
#line 466
    qtm->o_ptr = qtm->o_ptr + i;
  }
#line 470
  while (1) {
#line 470
    qtm->i_ptr = i_ptr;
#line 470
    qtm->i_end = i_end;
#line 470
    qtm->bit_buffer = bit_buffer;
#line 470
    qtm->bits_left = bits_left;
#line 470
    break;
  }
#line 471
  qtm->window_posn = window_posn;
#line 472
  qtm->frame_start = frame_start;
#line 473
  qtm->H = H;
#line 474
  qtm->L = L;
#line 475
  qtm->C = C;
#line 477
  return (0);
}
}
#line 480 "mspack/qtmd.c"
void qtmd_free(struct qtmd_stream *qtm ) 
{ struct mspack_system *sys ;

  {
#line 482
  if (qtm) {
#line 483
    sys = qtm->sys;
#line 484
    ((*(sys->free)))((void *)qtm->window);
#line 485
    ((*(sys->free)))((void *)qtm->inbuf);
#line 486
    ((*(sys->free)))((void *)qtm);
  }
#line 488
  return;
}
}
#line 1 "system.lo"
#pragma merger(0,"/tmp/cil-wx2gl0sH.i","-g -O2 -fPIC")
#line 159 "mspack/mspack.h"
int mspack_sys_selftest_internal(int offt_size ) ;
#line 190
int mspack_version(int entity ) ;
#line 17 "mspack/system.c"
int mspack_version(int entity ) 
{ 

  {
#line 18
  switch (entity) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 4: ;
#line 23
  return (1);
  case 3: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  case 9: ;
  case 10: ;
  case 11: ;
  case 12: ;
  case 13: ;
#line 34
  return (0);
  }
#line 36
  return (-1);
}
}
#line 39 "mspack/system.c"
int mspack_sys_selftest_internal(int offt_size ) 
{ int tmp ;

  {
#line 40
  if (sizeof(off_t ) == (unsigned int )offt_size) {
#line 40
    tmp = 0;
  } else {
#line 40
    tmp = 5;
  }
#line 40
  return (tmp);
}
}
#line 44 "mspack/system.c"
int mspack_valid_system(struct mspack_system *sys ) 
{ int tmp ;

  {
#line 45
  if ((unsigned int )sys != (unsigned int )((void *)0)) {
#line 45
    if ((unsigned int )sys->open != (unsigned int )((void *)0)) {
#line 45
      if ((unsigned int )sys->close != (unsigned int )((void *)0)) {
#line 45
        if ((unsigned int )sys->read != (unsigned int )((void *)0)) {
#line 45
          if ((unsigned int )sys->write != (unsigned int )((void *)0)) {
#line 45
            if ((unsigned int )sys->seek != (unsigned int )((void *)0)) {
#line 45
              if ((unsigned int )sys->tell != (unsigned int )((void *)0)) {
#line 45
                if ((unsigned int )sys->message != (unsigned int )((void *)0)) {
#line 45
                  if ((unsigned int )sys->alloc != (unsigned int )((void *)0)) {
#line 45
                    if ((unsigned int )sys->free != (unsigned int )((void *)0)) {
#line 45
                      if ((unsigned int )sys->copy != (unsigned int )((void *)0)) {
#line 45
                        if ((unsigned int )sys->null_ptr == (unsigned int )((void *)0)) {
#line 45
                          tmp = 1;
                        } else {
#line 45
                          tmp = 0;
                        }
                      } else {
#line 45
                        tmp = 0;
                      }
                    } else {
#line 45
                      tmp = 0;
                    }
                  } else {
#line 45
                    tmp = 0;
                  }
                } else {
#line 45
                  tmp = 0;
                }
              } else {
#line 45
                tmp = 0;
              }
            } else {
#line 45
              tmp = 0;
            }
          } else {
#line 45
            tmp = 0;
          }
        } else {
#line 45
          tmp = 0;
        }
      } else {
#line 45
        tmp = 0;
      }
    } else {
#line 45
      tmp = 0;
    }
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return (tmp);
}
}
#line 52 "mspack/system.c"
int mspack_sys_filelen(struct mspack_system *system___0 , struct mspack_file *file ,
                       off_t *length ) 
{ off_t current ;
  int tmp ;
  int tmp___0 ;

  {
#line 57
  if (! system___0) {
#line 57
    return (2);
  } else {
#line 57
    if (! file) {
#line 57
      return (2);
    } else {
#line 57
      if (! length) {
#line 57
        return (2);
      }
    }
  }
#line 60
  current = ((*(system___0->tell)))(file);
#line 63
  tmp = ((*(system___0->seek)))(file, 0L, 2);
#line 63
  if (tmp) {
#line 64
    return (5);
  }
#line 68
  (*length) = ((*(system___0->tell)))(file);
#line 71
  tmp___0 = ((*(system___0->seek)))(file, current, 0);
#line 71
  if (tmp___0) {
#line 72
    return (5);
  }
#line 75
  return (0);
}
}
#line 103 "mspack/system.c"
static struct mspack_file *msp_open(struct mspack_system *this , char *filename ,
                                    int mode ) 
{ struct mspack_file_p *fh ;
  char *fmode ;

  {
#line 109
  switch (mode) {
  case 0: 
#line 110
  fmode = (char *)"rb";
#line 110
  break;
  case 1: 
#line 111
  fmode = (char *)"wb";
#line 111
  break;
  case 2: 
#line 112
  fmode = (char *)"r+b";
#line 112
  break;
  case 3: 
#line 113
  fmode = (char *)"ab";
#line 113
  break;
  default: ;
#line 114
  return ((struct mspack_file *)((void *)0));
  }
#line 117
  fh = (struct mspack_file_p *)malloc(sizeof(struct mspack_file_p ));
#line 117
  if (fh) {
#line 118
    fh->name = (char const   *)filename;
#line 119
    fh->desc = 0;
#line 120
    fh->fh = fopen((char const   * __restrict  )filename, (char const   * __restrict  )fmode);
#line 120
    if (fh->fh) {
#line 120
      return ((struct mspack_file *)fh);
    }
#line 121
    free((void *)fh);
  }
#line 123
  return ((struct mspack_file *)((void *)0));
}
}
#line 126 "mspack/system.c"
static struct mspack_file *msp_dopen(struct mspack_system *this , int desc , int mode ) 
{ struct mspack_file_p *fh ;
  char *fmode ;

  {
#line 132
  switch (mode) {
  case 0: 
#line 133
  fmode = (char *)"rb";
#line 133
  break;
  case 1: 
#line 134
  fmode = (char *)"wb";
#line 134
  break;
  case 2: 
#line 135
  fmode = (char *)"r+b";
#line 135
  break;
  case 3: 
#line 136
  fmode = (char *)"ab";
#line 136
  break;
  default: ;
#line 137
  return ((struct mspack_file *)((void *)0));
  }
#line 140
  fh = (struct mspack_file_p *)malloc(sizeof(struct mspack_file_p ));
#line 140
  if (fh) {
#line 141
    fh->name = "descriptor";
#line 142
    fh->desc = desc;
#line 143
    fh->fh = fdopen(desc, (char const   *)fmode);
#line 143
    if (fh->fh) {
#line 143
      return ((struct mspack_file *)fh);
    }
#line 144
    free((void *)fh);
  }
#line 146
  return ((struct mspack_file *)((void *)0));
}
}
#line 149 "mspack/system.c"
static void msp_close(struct mspack_file *file ) 
{ struct mspack_file_p *this ;

  {
#line 150
  this = (struct mspack_file_p *)file;
#line 151
  if (this) {
#line 152
    fclose(this->fh);
#line 153
    free((void *)this);
  }
#line 155
  return;
}
}
#line 157 "mspack/system.c"
static int msp_read(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mspack_file_p *this ;
  size_t count ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 158
  this = (struct mspack_file_p *)file;
#line 159
  if (this) {
#line 160
    tmp = fread((void * __restrict  )buffer, 1U, (unsigned int )bytes, (FILE * __restrict  )this->fh);
#line 160
    count = tmp;
#line 161
    tmp___0 = ferror(this->fh);
#line 161
    if (! tmp___0) {
#line 161
      return ((int )count);
    }
  }
#line 163
  return (-1);
}
}
#line 166 "mspack/system.c"
static int msp_write(struct mspack_file *file , void *buffer , int bytes ) 
{ struct mspack_file_p *this ;
  size_t count ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 167
  this = (struct mspack_file_p *)file;
#line 168
  if (this) {
#line 169
    tmp = fwrite((void const   * __restrict  )buffer, 1U, (unsigned int )bytes, (FILE * __restrict  )this->fh);
#line 169
    count = tmp;
#line 170
    tmp___0 = ferror(this->fh);
#line 170
    if (! tmp___0) {
#line 170
      return ((int )count);
    }
  }
#line 172
  return (-1);
}
}
#line 175 "mspack/system.c"
static int msp_seek(struct mspack_file *file , off_t offset , int mode ) 
{ struct mspack_file_p *this ;
  int tmp ;

  {
#line 176
  this = (struct mspack_file_p *)file;
#line 177
  if (this) {
#line 178
    switch (mode) {
    case 0: 
#line 179
    mode = 0;
#line 179
    break;
    case 1: 
#line 180
    mode = 1;
#line 180
    break;
    case 2: 
#line 181
    mode = 2;
#line 181
    break;
    default: ;
#line 182
    return (-1);
    }
#line 187
    tmp = fseek(this->fh, offset, mode);
#line 187
    return (tmp);
  }
#line 190
  return (-1);
}
}
#line 193 "mspack/system.c"
static off_t msp_tell(struct mspack_file *file ) 
{ struct mspack_file_p *this ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 194
  this = (struct mspack_file_p *)file;
#line 198
  if (this) {
#line 198
    tmp___1 = ftell(this->fh);
#line 198
    tmp___0 = tmp___1;
  } else {
#line 198
    tmp___0 = 0L;
  }
#line 198
  return (tmp___0);
}
}
#line 202 "mspack/system.c"
static void msp_msg(struct mspack_file *file , char *format  , ...) 
{ va_list ap ;
  char buff[512] ;

  {
#line 206
  __builtin_va_start(ap, format);
#line 207
  vsnprintf((char * __restrict  )(buff), 512U, (char const   * __restrict  )format,
            ap);
#line 208
  __builtin_va_end(ap);
#line 209
  cli_dbgmsg("libmspack: %s\n", buff);
#line 210
  return;
}
}
#line 212 "mspack/system.c"
static void *msp_alloc(struct mspack_system *this , size_t bytes ) 
{ void *tmp ;

  {
#line 220
  tmp = cli_calloc(bytes, 1U);
#line 220
  return (tmp);
}
}
#line 224 "mspack/system.c"
static void msp_free(void *buffer ) 
{ 

  {
#line 236
  free(buffer);
#line 238
  return;
}
}
#line 240 "mspack/system.c"
static void msp_copy(void *src , void *dest , size_t bytes ) 
{ 

  {
#line 241
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, bytes);
#line 242
  return;
}
}
#line 244 "mspack/system.c"
static struct mspack_system msp_system  = 
#line 244
     {& msp_open, & msp_dopen, & msp_close, & msp_read, & msp_write, & msp_seek, & msp_tell,
    & msp_msg, & msp_alloc, & msp_free, & msp_copy, (void *)0};
#line 249 "mspack/system.c"
struct mspack_system *mspack_default_system  =    & msp_system;
#line 1 "upx.lo"
#pragma merger(0,"/tmp/cil-l3M8Ejrq.i","-g -O2 -fPIC")
#line 73 "upx.c"
int pefromupx(char *src , char *dst , int *dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 ,
              uint32_t magic ) 
{ char *imports ;
  char *sections ;
  char *pehdr ;
  char *newbuf ;
  int sectcnt ;
  int upd ;
  int realstuffsz ;
  int foffset ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  uint32_t vsize ;
  int32_t tmp___3 ;
  uint32_t rsize ;
  uint32_t tmp___4 ;
  uint32_t urva ;
  uint32_t tmp___5 ;
  int32_t tmp___6 ;
  size_t tmp___8 ;
  int32_t tmp___9 ;
  int32_t tmp___10 ;

  {
#line 76
  upd = 1;
#line 77
  foffset = 456;
#line 79
  if ((unsigned int )dst == (unsigned int )((void *)0)) {
#line 80
    return (0);
  } else {
#line 79
    if ((unsigned int )src == (unsigned int )((void *)0)) {
#line 80
      return (0);
    }
  }
#line 82
  tmp = cli_readint32((char const   *)(((src + ep) - upx1) + magic));
#line 82
  imports = dst + tmp;
#line 84
  realstuffsz = imports - dst;
#line 86
  if (realstuffsz < 0) {
#line 87
    cli_dbgmsg("UPX: wrong realstuff size - giving up rebuild\n");
#line 88
    return (0);
  } else {
#line 86
    if (realstuffsz > (*dsize)) {
#line 87
      cli_dbgmsg("UPX: wrong realstuff size - giving up rebuild\n");
#line 88
      return (0);
    }
  }
#line 91
  pehdr = imports;
#line 92
  while (1) {
#line 92
    if ((unsigned int )(pehdr + 7) < (unsigned int )(dst + (*dsize))) {
#line 92
      tmp___0 = cli_readint32((char const   *)pehdr);
#line 92
      if (! tmp___0) {
#line 92
        break;
      }
    } else {
#line 92
      break;
    }
#line 93
    pehdr += 8;
#line 94
    while (1) {
#line 94
      if ((unsigned int )(pehdr + 1) < (unsigned int )(dst + (*dsize))) {
#line 94
        if (! (*pehdr)) {
#line 94
          break;
        }
      } else {
#line 94
        break;
      }
#line 95
      pehdr ++;
#line 96
      while (1) {
#line 96
        if ((unsigned int )(pehdr + 1) < (unsigned int )(dst + (*dsize))) {
#line 96
          if (! (*pehdr)) {
#line 96
            break;
          }
        } else {
#line 96
          break;
        }
#line 97
        pehdr ++;
      }
#line 98
      pehdr ++;
    }
#line 100
    pehdr ++;
  }
#line 103
  pehdr += 4;
#line 104
  if ((unsigned int )(pehdr + 248) > (unsigned int )(dst + (*dsize))) {
#line 105
    cli_dbgmsg("UPX: sections out of bounds - giving up rebuild\n");
#line 106
    return (0);
  }
#line 109
  tmp___1 = cli_readint32((char const   *)pehdr);
#line 109
  if (tmp___1 != 17744) {
#line 110
    cli_dbgmsg("UPX: No magic for PE - giving up rebuild\n");
#line 111
    return (0);
  }
#line 114
  tmp___2 = cli_readint32((char const   *)(pehdr + 56));
#line 114
  if (! tmp___2) {
#line 115
    cli_dbgmsg("UPX: Cant align to a NULL bound - giving up rebuild\n");
#line 116
    return (0);
  }
#line 119
  sections = pehdr + 248;
#line 120
  sectcnt = (int )(*(pehdr + 6)) + 256 * (int )(*(pehdr + 7));
#line 120
  if (! sectcnt) {
#line 121
    cli_dbgmsg("UPX: No sections? - giving up rebuild\n");
#line 122
    return (0);
  }
#line 125
  foffset += 40 * sectcnt;
#line 127
  if ((unsigned int )((pehdr + 248) + 40 * sectcnt) >= (unsigned int )(dst + (*dsize))) {
#line 128
    cli_dbgmsg("UPX: Not enough space for all sects - giving up rebuild\n");
#line 129
    return (0);
  }
#line 132
  upd = 0;
#line 132
  while (upd < sectcnt) {
#line 133
    tmp___3 = cli_readint32((char const   *)(sections + 8));
#line 133
    vsize = (unsigned int )(tmp___3 - 1);
#line 134
    tmp___4 = (uint32_t )cli_readint32((char const   *)(sections + 16));
#line 134
    rsize = tmp___4;
#line 135
    tmp___5 = (uint32_t )cli_readint32((char const   *)(sections + 12));
#line 135
    urva = tmp___5;
#line 137
    vsize = (vsize / 4096U + 1U) * 4096U;
#line 140
    if (urva < upx0) {
#line 141
      cli_dbgmsg("UPX: Sect %d out of bounds - giving up rebuild\n", upd);
#line 142
      return (0);
    } else {
#line 140
      if (urva + vsize > upx0 + (unsigned int )realstuffsz) {
#line 141
        cli_dbgmsg("UPX: Sect %d out of bounds - giving up rebuild\n", upd);
#line 142
        return (0);
      }
    }
#line 146
    if (rsize > vsize) {
#line 147
      cli_dbgmsg("UPX: Raw size for sect %d is greater than virtual (%x / %x) - giving up rebuild\n",
                 upd, rsize, vsize);
#line 148
      return (0);
    }
#line 152
    if (rsize + 4U < vsize) {
#line 152
      tmp___6 = cli_readint32((char const   *)(((dst + urva) - upx0) + rsize));
#line 152
      if (tmp___6) {
#line 153
        cli_dbgmsg("UPX: Am i been fooled? - giving up rebuild\n", upd);
#line 154
        return (0);
      }
    }
#line 157
    cli_writeint32(sections + 8, vsize);
#line 158
    cli_writeint32(sections + 20, (unsigned int )foffset);
#line 159
    foffset = (int )((unsigned int )foffset + rsize);
#line 161
    sections += 40;
#line 132
    upd ++;
  }
#line 164
  cli_writeint32(pehdr + 8, 1296124995U);
#line 166
  newbuf = (char *)cli_malloc((unsigned int )foffset);
#line 166
  if (! newbuf) {
#line 167
    cli_dbgmsg("UPX: malloc failed - giving up rebuild\n", upd);
#line 168
    return (0);
  }
#line 171
  memcpy((void * __restrict  )newbuf, (void const   * __restrict  )"MZ\220\000\002\000\000\000\004\000\017\000\377\377\000\000\260\000\000\000\000\000\000\000@\000\032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\320\000\000\000\016\037\264\t\272\r\000\315!\264L\315!This file was created by ClamAV for internal use and should not be run.\r\nClamAV - A GPL virus scanner - http://www.clamav.net\r\n$\000\000\000",
         208U);
#line 172
  memcpy((void * __restrict  )(newbuf + 208), (void const   * __restrict  )pehdr,
         (unsigned int )(248 + 40 * sectcnt));
#line 173
  sections = pehdr + 248;
#line 174
  upd = 0;
#line 174
  while (upd < sectcnt) {
#line 175
    tmp___8 = (size_t )cli_readint32((char const   *)(sections + 16));
#line 175
    tmp___9 = cli_readint32((char const   *)(sections + 12));
#line 175
    tmp___10 = cli_readint32((char const   *)(sections + 20));
#line 175
    memcpy((void * __restrict  )(newbuf + tmp___10), (void const   * __restrict  )((dst +
                                                                                    tmp___9) -
                                                                                   upx0),
           tmp___8);
#line 176
    sections += 40;
#line 174
    upd ++;
  }
#line 182
  memcpy((void * __restrict  )dst, (void const   * __restrict  )newbuf, (unsigned int )foffset);
#line 183
  (*dsize) = foffset;
#line 184
  free((void *)newbuf);
#line 186
  cli_dbgmsg("UPX: PE structure rebuilt from compressed file\n");
#line 187
  return (1);
}
}
#line 193 "upx.c"
static int doubleebx(char *src , int32_t *myebx , int *scur , int ssize ) 
{ int32_t oldebx ;
  char *pt ;
  int32_t shift ;
  int32_t i ;

  {
#line 195
  oldebx = (*myebx);
#line 198
  i = 0;
#line 201
  (*myebx) *= 2;
#line 202
  if (! (oldebx & 2147483647)) {
#line 203
    if ((*scur) < 0) {
#line 204
      return (-1);
    } else {
#line 203
      if (ssize - (*scur) < 4) {
#line 204
        return (-1);
      }
    }
#line 208
    oldebx = 0;
#line 209
    pt = src + (*scur);
#line 210
    shift = 0;
#line 210
    while (shift < 32) {
#line 211
      oldebx |= ((int )(*(pt + i)) & 255) << shift;
#line 212
      i ++;
#line 210
      shift += 8;
    }
#line 216
    (*myebx) = oldebx * 2 + 1;
#line 217
    (*scur) += 4;
  }
#line 219
  return ((oldebx >> 31) & 1);
}
}
#line 224 "upx.c"
int upx_inflate2b(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) 
{ int32_t backbytes ;
  int32_t unp_offset ;
  int32_t myebx ;
  int scur ;
  int dcur ;
  int i ;
  int backsize ;
  int oob ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 226
  unp_offset = -1;
#line 226
  myebx = 0;
#line 227
  scur = 0;
#line 227
  dcur = 0;
#line 229
  while (1) {
#line 230
    while (1) {
#line 230
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 230
      if (! (oob == 1)) {
#line 230
        break;
      }
#line 231
      if (scur < 0) {
#line 232
        return (-1);
      } else {
#line 231
        if (scur >= ssize) {
#line 232
          return (-1);
        } else {
#line 231
          if (dcur < 0) {
#line 232
            return (-1);
          } else {
#line 231
            if (dcur >= (*dsize)) {
#line 232
              return (-1);
            }
          }
        }
      }
#line 233
      tmp = dcur;
#line 233
      dcur ++;
#line 233
      tmp___0 = scur;
#line 233
      scur ++;
#line 233
      (*(dst + tmp)) = (*(src + tmp___0));
    }
#line 236
    if (oob == -1) {
#line 237
      return (-1);
    }
#line 239
    backbytes = 1;
#line 241
    while (1) {
#line 242
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 242
      if (oob == -1) {
#line 243
        return (-1);
      }
#line 244
      backbytes = backbytes * 2 + oob;
#line 245
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 245
      if (oob == -1) {
#line 246
        return (-1);
      }
#line 247
      if (oob) {
#line 248
        break;
      }
    }
#line 251
    backsize = 0;
#line 252
    backbytes -= 3;
#line 254
    if (backbytes >= 0) {
#line 256
      if (scur < 0) {
#line 257
        return (-1);
      } else {
#line 256
        if (scur >= ssize) {
#line 257
          return (-1);
        }
      }
#line 258
      backbytes <<= 8;
#line 259
      tmp___1 = scur;
#line 259
      scur ++;
#line 259
      backbytes += (int )((unsigned char )(*(src + tmp___1)));
#line 260
      backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
#line 262
      if (! backbytes) {
#line 263
        break;
      }
#line 264
      unp_offset = backbytes;
    }
#line 267
    oob = doubleebx(src, & myebx, & scur, ssize);
#line 267
    if (oob == -1) {
#line 268
      return (-1);
    }
#line 269
    backsize = oob;
#line 270
    oob = doubleebx(src, & myebx, & scur, ssize);
#line 270
    if (oob == -1) {
#line 271
      return (-1);
    }
#line 272
    backsize = backsize * 2 + oob;
#line 273
    if (! backsize) {
#line 274
      backsize ++;
#line 275
      while (1) {
#line 276
        oob = doubleebx(src, & myebx, & scur, ssize);
#line 276
        if (oob == -1) {
#line 277
          return (-1);
        }
#line 278
        backsize = backsize * 2 + oob;
#line 275
        oob = doubleebx(src, & myebx, & scur, ssize);
#line 275
        if (! (oob == 0)) {
#line 275
          break;
        }
      }
#line 280
      if (oob == -1) {
#line 281
        return (-1);
      }
#line 282
      backsize += 2;
    }
#line 285
    if ((unsigned int )unp_offset < 4294963968U) {
#line 286
      backsize ++;
    }
#line 288
    backsize ++;
#line 290
    i = 0;
#line 290
    while (i < backsize) {
#line 291
      if (dcur + i < 0) {
#line 292
        return (-1);
      } else {
#line 291
        if (dcur + i >= (*dsize)) {
#line 292
          return (-1);
        } else {
#line 291
          if ((dcur + unp_offset) + i < 0) {
#line 292
            return (-1);
          } else {
#line 291
            if ((dcur + unp_offset) + i >= (*dsize)) {
#line 292
              return (-1);
            }
          }
        }
      }
#line 293
      (*(dst + (dcur + i))) = (*(dst + ((dcur + unp_offset) + i)));
#line 290
      i ++;
    }
#line 295
    dcur += backsize;
  }
#line 299
  if ((ep - upx1) + 264U <= (unsigned int )(ssize - 5)) {
#line 299
    if ((int )(*(src + ((ep - upx1) + 262U))) == -115) {
#line 299
      if ((int )(*(src + ((ep - upx1) + 263U))) == -66) {
#line 302
        tmp___2 = pefromupx(src, dst, dsize, ep, upx0, upx1, 264U);
#line 302
        return (tmp___2);
      }
    }
  }
#line 304
  cli_dbgmsg("UPX: bad magic for 2b\n");
#line 305
  return (0);
}
}
#line 308 "upx.c"
int upx_inflate2d(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) 
{ int32_t backbytes ;
  int32_t unp_offset ;
  int32_t myebx ;
  int scur ;
  int dcur ;
  int i ;
  int backsize ;
  int oob ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 310
  unp_offset = -1;
#line 310
  myebx = 0;
#line 311
  scur = 0;
#line 311
  dcur = 0;
#line 313
  while (1) {
#line 314
    while (1) {
#line 314
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 314
      if (! (oob == 1)) {
#line 314
        break;
      }
#line 315
      if (scur < 0) {
#line 316
        return (-1);
      } else {
#line 315
        if (scur >= ssize) {
#line 316
          return (-1);
        } else {
#line 315
          if (dcur < 0) {
#line 316
            return (-1);
          } else {
#line 315
            if (dcur >= (*dsize)) {
#line 316
              return (-1);
            }
          }
        }
      }
#line 317
      tmp = dcur;
#line 317
      dcur ++;
#line 317
      tmp___0 = scur;
#line 317
      scur ++;
#line 317
      (*(dst + tmp)) = (*(src + tmp___0));
    }
#line 320
    if (oob == -1) {
#line 321
      return (-1);
    }
#line 323
    backbytes = 1;
#line 325
    while (1) {
#line 326
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 326
      if (oob == -1) {
#line 327
        return (-1);
      }
#line 328
      backbytes = backbytes * 2 + oob;
#line 329
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 329
      if (oob == -1) {
#line 330
        return (-1);
      }
#line 331
      if (oob) {
#line 332
        break;
      }
#line 333
      backbytes --;
#line 334
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 334
      if (oob == -1) {
#line 335
        return (-1);
      }
#line 336
      backbytes = backbytes * 2 + oob;
    }
#line 339
    backsize = 0;
#line 340
    backbytes -= 3;
#line 342
    if (backbytes >= 0) {
#line 344
      if (scur < 0) {
#line 345
        return (-1);
      } else {
#line 344
        if (scur >= ssize) {
#line 345
          return (-1);
        }
      }
#line 346
      backbytes <<= 8;
#line 347
      tmp___1 = scur;
#line 347
      scur ++;
#line 347
      backbytes += (int )((unsigned char )(*(src + tmp___1)));
#line 348
      backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
#line 350
      if (! backbytes) {
#line 351
        break;
      }
#line 352
      backsize = backbytes & 1;
#line 353
      backbytes >>= 1;
#line 354
      unp_offset = backbytes;
    } else {
#line 357
      backsize = doubleebx(src, & myebx, & scur, ssize);
#line 357
      if (backsize == -1) {
#line 358
        return (-1);
      }
    }
#line 361
    oob = doubleebx(src, & myebx, & scur, ssize);
#line 361
    if (oob == -1) {
#line 362
      return (-1);
    }
#line 363
    backsize = backsize * 2 + oob;
#line 364
    if (! backsize) {
#line 365
      backsize ++;
#line 366
      while (1) {
#line 367
        oob = doubleebx(src, & myebx, & scur, ssize);
#line 367
        if (oob == -1) {
#line 368
          return (-1);
        }
#line 369
        backsize = backsize * 2 + oob;
#line 366
        oob = doubleebx(src, & myebx, & scur, ssize);
#line 366
        if (! (oob == 0)) {
#line 366
          break;
        }
      }
#line 371
      if (oob == -1) {
#line 372
        return (-1);
      }
#line 373
      backsize += 2;
    }
#line 376
    if ((unsigned int )unp_offset < 4294966016U) {
#line 377
      backsize ++;
    }
#line 379
    backsize ++;
#line 380
    i = 0;
#line 380
    while (i < backsize) {
#line 381
      if (dcur + i < 0) {
#line 382
        return (-1);
      } else {
#line 381
        if (dcur + i >= (*dsize)) {
#line 382
          return (-1);
        } else {
#line 381
          if ((dcur + unp_offset) + i < 0) {
#line 382
            return (-1);
          } else {
#line 381
            if ((dcur + unp_offset) + i >= (*dsize)) {
#line 382
              return (-1);
            }
          }
        }
      }
#line 383
      (*(dst + (dcur + i))) = (*(dst + ((dcur + unp_offset) + i)));
#line 380
      i ++;
    }
#line 385
    dcur += backsize;
  }
#line 388
  if ((ep - upx1) + 292U <= (unsigned int )(ssize - 5)) {
#line 389
    if ((int )(*(src + ((ep - upx1) + 282U))) == -115) {
#line 389
      if ((int )(*(src + ((ep - upx1) + 283U))) == -66) {
#line 390
        tmp___2 = pefromupx(src, dst, dsize, ep, upx0, upx1, 284U);
#line 390
        return (tmp___2);
      }
    }
#line 391
    if ((int )(*(src + ((ep - upx1) + 290U))) == -115) {
#line 391
      if ((int )(*(src + ((ep - upx1) + 291U))) == -66) {
#line 392
        tmp___3 = pefromupx(src, dst, dsize, ep, upx0, upx1, 292U);
#line 392
        return (tmp___3);
      }
    }
  }
#line 394
  cli_dbgmsg("UPX: bad magic for 2d\n");
#line 395
  return (0);
}
}
#line 398 "upx.c"
int upx_inflate2e(char *src , int ssize , char *dst , int *dsize , uint32_t upx0 ,
                  uint32_t upx1 , uint32_t ep ) 
{ int32_t backbytes ;
  int32_t unp_offset ;
  int32_t myebx ;
  int scur ;
  int dcur ;
  int i ;
  int backsize ;
  int oob ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 400
  unp_offset = -1;
#line 400
  myebx = 0;
#line 401
  scur = 0;
#line 401
  dcur = 0;
#line 403
  while (1) {
#line 404
    while (1) {
#line 404
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 404
      if (! oob) {
#line 404
        break;
      }
#line 405
      if (oob == -1) {
#line 406
        return (-1);
      }
#line 407
      if (scur < 0) {
#line 408
        return (-1);
      } else {
#line 407
        if (scur >= ssize) {
#line 408
          return (-1);
        } else {
#line 407
          if (dcur < 0) {
#line 408
            return (-1);
          } else {
#line 407
            if (dcur >= (*dsize)) {
#line 408
              return (-1);
            }
          }
        }
      }
#line 409
      tmp = dcur;
#line 409
      dcur ++;
#line 409
      tmp___0 = scur;
#line 409
      scur ++;
#line 409
      (*(dst + tmp)) = (*(src + tmp___0));
    }
#line 412
    backbytes = 1;
#line 414
    while (1) {
#line 415
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 415
      if (oob == -1) {
#line 416
        return (-1);
      }
#line 417
      backbytes = backbytes * 2 + oob;
#line 418
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 418
      if (oob == -1) {
#line 419
        return (-1);
      }
#line 420
      if (oob) {
#line 421
        break;
      }
#line 422
      backbytes --;
#line 423
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 423
      if (oob == -1) {
#line 424
        return (-1);
      }
#line 425
      backbytes = backbytes * 2 + oob;
    }
#line 428
    backsize = 0;
#line 429
    backbytes -= 3;
#line 431
    if (backbytes >= 0) {
#line 433
      if (scur < 0) {
#line 434
        return (-1);
      } else {
#line 433
        if (scur >= ssize) {
#line 434
          return (-1);
        }
      }
#line 435
      backbytes <<= 8;
#line 436
      tmp___1 = scur;
#line 436
      scur ++;
#line 436
      backbytes += (int )((unsigned char )(*(src + tmp___1)));
#line 437
      backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
#line 439
      if (! backbytes) {
#line 440
        break;
      }
#line 441
      backsize = backbytes & 1;
#line 442
      backbytes >>= 1;
#line 443
      unp_offset = backbytes;
    } else {
#line 446
      backsize = doubleebx(src, & myebx, & scur, ssize);
#line 446
      if (backsize == -1) {
#line 447
        return (-1);
      }
    }
#line 450
    if (backsize) {
#line 451
      backsize = doubleebx(src, & myebx, & scur, ssize);
#line 451
      if (backsize == -1) {
#line 452
        return (-1);
      }
    } else {
#line 455
      backsize = 1;
#line 456
      oob = doubleebx(src, & myebx, & scur, ssize);
#line 456
      if (oob == -1) {
#line 457
        return (-1);
      }
#line 458
      if (oob) {
#line 459
        oob = doubleebx(src, & myebx, & scur, ssize);
#line 459
        if (oob == -1) {
#line 460
          return (-1);
        }
#line 461
        backsize = 2 + oob;
      } else {
#line 464
        while (1) {
#line 465
          oob = doubleebx(src, & myebx, & scur, ssize);
#line 465
          if (oob == -1) {
#line 466
            return (-1);
          }
#line 467
          backsize = backsize * 2 + oob;
#line 464
          oob = doubleebx(src, & myebx, & scur, ssize);
#line 464
          if (! (oob == 0)) {
#line 464
            break;
          }
        }
#line 469
        if (oob == -1) {
#line 470
          return (-1);
        }
#line 471
        backsize += 2;
      }
    }
#line 475
    if ((unsigned int )unp_offset < 4294966016U) {
#line 476
      backsize ++;
    }
#line 478
    backsize += 2;
#line 479
    i = 0;
#line 479
    while (i < backsize) {
#line 480
      if (dcur + i < 0) {
#line 481
        return (-1);
      } else {
#line 480
        if (dcur + i >= (*dsize)) {
#line 481
          return (-1);
        } else {
#line 480
          if ((dcur + unp_offset) + i < 0) {
#line 481
            return (-1);
          } else {
#line 480
            if ((dcur + unp_offset) + i >= (*dsize)) {
#line 481
              return (-1);
            }
          }
        }
      }
#line 482
      (*(dst + (dcur + i))) = (*(dst + ((dcur + unp_offset) + i)));
#line 479
      i ++;
    }
#line 484
    dcur += backsize;
  }
#line 487
  if ((ep - upx1) + 304U <= (unsigned int )(ssize - 5)) {
#line 488
    if ((int )(*(src + ((ep - upx1) + 294U))) == -115) {
#line 488
      if ((int )(*(src + ((ep - upx1) + 295U))) == -66) {
#line 489
        tmp___2 = pefromupx(src, dst, dsize, ep, upx0, upx1, 296U);
#line 489
        return (tmp___2);
      }
    }
#line 490
    if ((int )(*(src + ((ep - upx1) + 302U))) == -115) {
#line 490
      if ((int )(*(src + ((ep - upx1) + 303U))) == -66) {
#line 491
        tmp___3 = pefromupx(src, dst, dsize, ep, upx0, upx1, 304U);
#line 491
        return (tmp___3);
      }
    }
  }
#line 493
  cli_dbgmsg("UPX: bad magic for 2e\n");
#line 494
  return (0);
}
}
#line 1 "htmlnorm.lo"
#pragma merger(0,"/tmp/cil-ZglX7f5I.i","-g -O2 -fPIC")
#line 99 "htmlnorm.c"
static int const   base64_chars[256]  = 
#line 99
  {      (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )62, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )63, 
        (int const   )52,      (int const   )53,      (int const   )54,      (int const   )55, 
        (int const   )56,      (int const   )57,      (int const   )58,      (int const   )59, 
        (int const   )60,      (int const   )61,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )9,      (int const   )10, 
        (int const   )11,      (int const   )12,      (int const   )13,      (int const   )14, 
        (int const   )15,      (int const   )16,      (int const   )17,      (int const   )18, 
        (int const   )19,      (int const   )20,      (int const   )21,      (int const   )22, 
        (int const   )23,      (int const   )24,      (int const   )25,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )32, 
        (int const   )33,      (int const   )34,      (int const   )35,      (int const   )36, 
        (int const   )37,      (int const   )38,      (int const   )39,      (int const   )40, 
        (int const   )41,      (int const   )42,      (int const   )43,      (int const   )44, 
        (int const   )45,      (int const   )46,      (int const   )47,      (int const   )48, 
        (int const   )49,      (int const   )50,      (int const   )51,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1};
#line 118 "htmlnorm.c"
int table_order[64]  = 
#line 118
  {      0,      2,      1,      0, 
        2,      1,      2,      1, 
        1,      2,      1,      2, 
        0,      1,      2,      1, 
        0,      1,      2,      1, 
        0,      0,      2,      1, 
        1,      2,      0,      1, 
        2,      1,      1,      2, 
        0,      0,      1,      2, 
        1,      2,      1,      0, 
        1,      0,      0,      2, 
        1,      0,      1,      2, 
        0,      1,      2,      1, 
        0,      0,      2,      1, 
        1,      0,      0,      2, 
        1,      0,      1,      2};
#line 125 "htmlnorm.c"
int decrypt_tables[3][128]  = { {        0,        1,        2,        3, 
            4,        5,        6,        7, 
            8,        87,        10,        11, 
            12,        13,        14,        15, 
            16,        17,        18,        19, 
            20,        21,        22,        23, 
            24,        25,        26,        27, 
            28,        29,        30,        31, 
            46,        71,        122,        86, 
            66,        106,        47,        38, 
            73,        65,        52,        50, 
            91,        118,        114,        67, 
            56,        57,        112,        69, 
            104,        113,        79,        9, 
            98,        68,        35,        117, 
            60,        126,        62,        94, 
            255,        119,        74,        97, 
            93,        34,        75,        111, 
            78,        59,        76,        80, 
            103,        42,        125,        116, 
            84,        43,        45,        44, 
            48,        110,        107,        102, 
            53,        37,        33,        100, 
            77,        82,        99,        63, 
            123,        120,        41,        40, 
            115,        89,        51,        127, 
            109,        85,        83,        124, 
            58,        95,        101,        70, 
            88,        49,        105,        108, 
            90,        72,        39,        92, 
            61,        36,        121,        55, 
            96,        81,        32,        54}, 
   {        0,        1,        2,        3, 
            4,        5,        6,        7, 
            8,        123,        10,        11, 
            12,        13,        14,        15, 
            16,        17,        18,        19, 
            20,        21,        22,        23, 
            24,        25,        26,        27, 
            28,        29,        30,        31, 
            50,        48,        33,        41, 
            91,        56,        51,        61, 
            88,        58,        53,        101, 
            57,        92,        86,        115, 
            102,        78,        69,        107, 
            98,        89,        120,        94, 
            125,        74,        109,        113, 
            60,        96,        62,        83, 
            255,        66,        39,        72, 
            114,        117,        49,        55, 
            77,        82,        34,        84, 
            106,        71,        100,        45, 
            32,        127,        46,        76, 
            93,        126,        108,        111, 
            121,        116,        67,        38, 
            118,        37,        36,        43, 
            40,        35,        65,        52, 
            9,        42,        68,        63, 
            119,        59,        85,        105, 
            97,        99,        80,        103, 
            81,        73,        79,        70, 
            104,        124,        54,        112, 
            110,        122,        47,        95, 
            75,        90,        44,        87}, 
   {        0,        1,        2,        3, 
            4,        5,        6,        7, 
            8,        110,        10,        11, 
            12,        6,        14,        15, 
            16,        17,        18,        19, 
            20,        21,        22,        23, 
            24,        25,        26,        27, 
            28,        29,        30,        31, 
            45,        117,        82,        96, 
            113,        94,        73,        92, 
            98,        125,        41,        54, 
            32,        124,        122,        127, 
            107,        99,        51,        43, 
            104,        81,        102,        118, 
            49,        100,        84,        67, 
            60,        58,        62,        126, 
            255,        69,        44,        42, 
            116,        39,        55,        68, 
            121,        89,        47,        111, 
            38,        114,        106,        57, 
            123,        63,        56,        119, 
            103,        83,        71,        52, 
            120,        93,        48,        35, 
            90,        91,        108,        72, 
            85,        112,        105,        46, 
            76,        33,        36,        78, 
            80,        9,        86,        115, 
            53,        97,        75,        88, 
            59,        87,        34,        109, 
            77,        37,        40,        70, 
            74,        50,        65,        61, 
            95,        79,        66,        101}};
#line 154 "htmlnorm.c"
static unsigned char *cli_readline(FILE *stream , m_area_t *m_area , unsigned int max_len ) 
{ unsigned char *line ;
  unsigned char *ptr ;
  unsigned char *start ;
  unsigned char *end ;
  unsigned int line_len ;
  unsigned int count ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 159
  line = (unsigned char *)cli_malloc(max_len);
#line 160
  if (! line) {
#line 161
    return ((unsigned char *)((void *)0));
  }
#line 165
  if (m_area) {
#line 166
    ptr = m_area->buffer + m_area->offset;
#line 166
    start = ptr;
#line 167
    end = m_area->buffer + m_area->length;
#line 168
    if ((unsigned int )start >= (unsigned int )end) {
#line 169
      free((void *)line);
#line 170
      return ((unsigned char *)((void *)0));
    }
#line 172
    line_len = 1U;
#line 173
    while (1) {
#line 173
      if ((unsigned int )ptr < (unsigned int )end) {
#line 173
        if ((int )(*ptr) != 10) {
#line 173
          if (! (line_len < max_len - 1U)) {
#line 173
            break;
          }
        } else {
#line 173
          break;
        }
      } else {
#line 173
        break;
      }
#line 174
      ptr ++;
#line 175
      line_len ++;
    }
#line 177
    if ((unsigned int )ptr == (unsigned int )end) {
#line 178
      line_len --;
#line 179
      memcpy((void * __restrict  )line, (void const   * __restrict  )start, line_len);
#line 180
      (*(line + line_len)) = (unsigned char )'\000';
    } else {
#line 181
      if ((int )(*ptr) == 10) {
#line 182
        memcpy((void * __restrict  )line, (void const   * __restrict  )start, line_len);
#line 183
        (*(line + line_len)) = (unsigned char )'\000';
      } else {
#line 187
        count = line_len;
#line 188
        while (1) {
#line 188
          tmp___0 = __ctype_b_loc();
#line 188
          if ((int const   )(*((*tmp___0) + (int )(*ptr))) & 8192) {
#line 188
            break;
          } else {
#line 188
            if (! (line_len > 1U)) {
#line 188
              break;
            }
          }
#line 189
          ptr --;
#line 190
          line_len --;
        }
#line 192
        if (line_len == 1U) {
#line 193
          line_len = count;
        }
#line 195
        memcpy((void * __restrict  )line, (void const   * __restrict  )start, line_len);
#line 196
        (*(line + line_len)) = (unsigned char )'\000';
      }
    }
#line 198
    m_area->offset = (long )((unsigned long )m_area->offset + (unsigned long )line_len);
  } else {
#line 200
    if (! stream) {
#line 201
      cli_dbgmsg("No HTML stream\n");
#line 202
      free((void *)line);
#line 203
      return ((unsigned char *)((void *)0));
    }
#line 205
    tmp___1 = fgets((char * __restrict  )line, (int )max_len, (FILE * __restrict  )stream);
#line 205
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 206
      free((void *)line);
#line 207
      return ((unsigned char *)((void *)0));
    }
#line 210
    line_len = strlen((char const   *)line);
#line 211
    if (line_len == 0U) {
#line 212
      free((void *)line);
#line 213
      return ((unsigned char *)((void *)0));
    }
#line 215
    if (line_len == max_len - 1U) {
#line 217
      count = 0U;
#line 218
      while (1) {
#line 218
        tmp___2 = __ctype_b_loc();
#line 218
        line_len --;
#line 218
        if ((int const   )(*((*tmp___2) + (int )(*(line + line_len)))) & 8192) {
#line 218
          break;
        }
#line 219
        count --;
#line 220
        if (line_len == 0U) {
#line 221
          return (line);
        }
      }
#line 224
      fseek(stream, (long )count, 1);
#line 225
      (*(line + (line_len + 1U))) = (unsigned char )'\000';
    }
  }
#line 228
  return (line);
}
}
#line 231 "htmlnorm.c"
static void html_output_flush(file_buff_t *fbuff ) 
{ 

  {
#line 233
  if (fbuff) {
#line 233
    if (fbuff->length > 0) {
#line 234
      cli_writen(fbuff->fd, (void *)(fbuff->buffer), (unsigned int )fbuff->length);
#line 235
      fbuff->length = 0;
    }
  }
#line 237
  return;
}
}
#line 239 "htmlnorm.c"
static void html_output_c(file_buff_t *fbuff1 , file_buff_t *fbuff2 , unsigned char c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 241
  if (fbuff1) {
#line 242
    if (fbuff1->length == 8192) {
#line 243
      html_output_flush(fbuff1);
    }
#line 245
    tmp = fbuff1->length;
#line 245
    fbuff1->length ++;
#line 245
    fbuff1->buffer[tmp] = c;
  }
#line 247
  if (fbuff2) {
#line 248
    if (fbuff2->length == 8192) {
#line 249
      html_output_flush(fbuff2);
    }
#line 251
    tmp___0 = fbuff2->length;
#line 251
    fbuff2->length ++;
#line 251
    fbuff2->buffer[tmp___0] = c;
  }
#line 253
  return;
}
}
#line 255 "htmlnorm.c"
static void html_output_str(file_buff_t *fbuff , unsigned char *str , int len ) 
{ 

  {
#line 257
  if (fbuff) {
#line 258
    if (fbuff->length + len >= 8192) {
#line 259
      html_output_flush(fbuff);
    }
#line 261
    if (len >= 8192) {
#line 262
      html_output_flush(fbuff);
#line 263
      cli_writen(fbuff->fd, (void *)str, (unsigned int )len);
    } else {
#line 265
      memcpy((void * __restrict  )(fbuff->buffer + fbuff->length), (void const   * __restrict  )str,
             (unsigned int )len);
#line 266
      fbuff->length += len;
    }
  }
#line 269
  return;
}
}
#line 271 "htmlnorm.c"
static char *html_tag_arg_value(tag_arguments_t *tags , char *tag ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
#line 275
  i = 0;
#line 275
  while (i < tags->count) {
#line 276
    tmp___65 = __builtin_constant_p((int )(*(tags->tag + i)));
#line 276
    if (tmp___65) {
#line 276
      tmp___66 = __builtin_constant_p((int )tag);
#line 276
      if (tmp___66) {
#line 276
        __s1_len = strlen((char const   *)(*(tags->tag + i)));
#line 276
        __s2_len = strlen((char const   *)tag);
#line 276
        if (! ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                              i))) ==
               1U)) {
          goto _L___16;
        } else {
#line 276
          if (__s1_len >= 4U) {
            _L___16: 
#line 276
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                   1U)) {
#line 276
              tmp___67 = 1;
            } else {
#line 276
              if (__s2_len >= 4U) {
#line 276
                tmp___67 = 1;
              } else {
#line 276
                tmp___67 = 0;
              }
            }
          } else {
#line 276
            tmp___67 = 0;
          }
        }
#line 276
        if (tmp___67) {
#line 276
          tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: 
#line 276
      tmp___64 = __builtin_constant_p((int )(*(tags->tag + i)));
#line 276
      if (tmp___64) {
#line 276
        if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                           i))) ==
            1U) {
#line 276
          __s1_len = strlen((char const   *)(*(tags->tag + i)));
#line 276
          if (__s1_len < 4U) {
#line 276
            tmp___53 = __builtin_constant_p((int )tag);
#line 276
            if (tmp___53) {
#line 276
              if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                  1U) {
#line 276
                tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: 
#line 276
              __s2___6 = (unsigned char const   *)((char const   *)tag);
#line 276
              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                   i))) +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
#line 276
              if (__s1_len > 0U) {
#line 276
                if (__result___18 == 0) {
#line 276
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                       i))) +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
#line 276
                  if (__s1_len > 1U) {
#line 276
                    if (__result___18 == 0) {
#line 276
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                           i))) +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
#line 276
                      if (__s1_len > 2U) {
#line 276
                        if (__result___18 == 0) {
#line 276
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                               i))) +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
#line 276
              tmp___34 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: 
#line 276
        tmp___63 = __builtin_constant_p((int )tag);
#line 276
        if (tmp___63) {
#line 276
          if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
              1U) {
#line 276
            __s2_len = strlen((char const   *)tag);
#line 276
            if (__s2_len < 4U) {
#line 276
              tmp___62 = __builtin_constant_p((int )(*(tags->tag + i)));
#line 276
              if (tmp___62) {
#line 276
                if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                                   i))) ==
                    1U) {
#line 276
                  tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: 
#line 276
                __s1___14 = (unsigned char const   *)((char const   *)(*(tags->tag +
                                                                         i)));
#line 276
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                           0)));
#line 276
                if (__s2_len > 0U) {
#line 276
                  if (__result___22 == 0) {
#line 276
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                               1)));
#line 276
                    if (__s2_len > 1U) {
#line 276
                      if (__result___22 == 0) {
#line 276
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                2)));
#line 276
                        if (__s2_len > 2U) {
#line 276
                          if (__result___22 == 0) {
#line 276
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 276
                tmp___34 = __result___22;
              }
            } else {
#line 276
              tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
            }
          } else {
#line 276
            tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
          }
        } else {
#line 276
          tmp___34 = __builtin_strcmp((*(tags->tag + i)), tag);
        }
      }
    }
#line 276
    if (tmp___34 == 0) {
#line 277
      return ((char *)(*(tags->value + i)));
    }
#line 275
    i ++;
  }
#line 280
  return ((char *)((void *)0));
}
}
#line 283 "htmlnorm.c"
static void html_tag_arg_set(tag_arguments_t *tags , char *tag , char *value ) 
{ int i ;
  void *tmp___14 ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___54 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___73 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;

  {
#line 287
  i = 0;
#line 287
  while (i < tags->count) {
#line 288
    tmp___85 = __builtin_constant_p((int )(*(tags->tag + i)));
#line 288
    if (tmp___85) {
#line 288
      tmp___86 = __builtin_constant_p((int )tag);
#line 288
      if (tmp___86) {
#line 288
        __s1_len = strlen((char const   *)(*(tags->tag + i)));
#line 288
        __s2_len = strlen((char const   *)tag);
#line 288
        if (! ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                              i))) ==
               1U)) {
          goto _L___16;
        } else {
#line 288
          if (__s1_len >= 4U) {
            _L___16: 
#line 288
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                   1U)) {
#line 288
              tmp___87 = 1;
            } else {
#line 288
              if (__s2_len >= 4U) {
#line 288
                tmp___87 = 1;
              } else {
#line 288
                tmp___87 = 0;
              }
            }
          } else {
#line 288
            tmp___87 = 0;
          }
        }
#line 288
        if (tmp___87) {
#line 288
          tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: 
#line 288
      tmp___84 = __builtin_constant_p((int )(*(tags->tag + i)));
#line 288
      if (tmp___84) {
#line 288
        if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                           i))) ==
            1U) {
#line 288
          __s1_len = strlen((char const   *)(*(tags->tag + i)));
#line 288
          if (__s1_len < 4U) {
#line 288
            tmp___73 = __builtin_constant_p((int )tag);
#line 288
            if (tmp___73) {
#line 288
              if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
                  1U) {
#line 288
                tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
              } else {
                goto _L___11;
              }
            } else {
              _L___11: 
#line 288
              __s2___6 = (unsigned char const   *)((char const   *)tag);
#line 288
              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                   i))) +
                                                      0)) - (int const   )(*(__s2___6 +
                                                                             0)));
#line 288
              if (__s1_len > 0U) {
#line 288
                if (__result___18 == 0) {
#line 288
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                       i))) +
                                                          1)) - (int const   )(*(__s2___6 +
                                                                                 1)));
#line 288
                  if (__s1_len > 1U) {
#line 288
                    if (__result___18 == 0) {
#line 288
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                           i))) +
                                                              2)) - (int const   )(*(__s2___6 +
                                                                                     2)));
#line 288
                      if (__s1_len > 2U) {
#line 288
                        if (__result___18 == 0) {
#line 288
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(tags->tag +
                                                                                                               i))) +
                                                                  3)) - (int const   )(*(__s2___6 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
#line 288
              tmp___54 = __result___18;
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: 
#line 288
        tmp___83 = __builtin_constant_p((int )tag);
#line 288
        if (tmp___83) {
#line 288
          if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
              1U) {
#line 288
            __s2_len = strlen((char const   *)tag);
#line 288
            if (__s2_len < 4U) {
#line 288
              tmp___82 = __builtin_constant_p((int )(*(tags->tag + i)));
#line 288
              if (tmp___82) {
#line 288
                if ((unsigned int )((void const   *)((*(tags->tag + i)) + 1)) - (unsigned int )((void const   *)(*(tags->tag +
                                                                                                                   i))) ==
                    1U) {
#line 288
                  tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
                } else {
                  goto _L___13;
                }
              } else {
                _L___13: 
#line 288
                __s1___14 = (unsigned char const   *)((char const   *)(*(tags->tag +
                                                                         i)));
#line 288
                __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                           0)));
#line 288
                if (__s2_len > 0U) {
#line 288
                  if (__result___22 == 0) {
#line 288
                    __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                                               1)));
#line 288
                    if (__s2_len > 1U) {
#line 288
                      if (__result___22 == 0) {
#line 288
                        __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                2)));
#line 288
                        if (__s2_len > 2U) {
#line 288
                          if (__result___22 == 0) {
#line 288
                            __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)tag) +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 288
                tmp___54 = __result___22;
              }
            } else {
#line 288
              tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
            }
          } else {
#line 288
            tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
          }
        } else {
#line 288
          tmp___54 = __builtin_strcmp((*(tags->tag + i)), tag);
        }
      }
    }
#line 288
    if (tmp___54 == 0) {
#line 289
      free((void *)(*(tags->value + i)));
#line 290
      tmp___18 = __builtin_constant_p((int )value);
#line 290
      if (tmp___18) {
#line 290
        if ((unsigned int )((void const   *)(value + 1)) - (unsigned int )((void const   *)value) ==
            1U) {
#line 290
          if ((int const   )(*((char const   *)value + 0)) == 0) {
#line 290
            tmp___14 = calloc(1U, 1U);
#line 290
            (*(tags->value + i)) = (unsigned char *)((char *)tmp___14);
          } else {
#line 290
            tmp___15 = strlen((char const   *)value);
#line 290
            __len___2 = tmp___15 + 1U;
#line 290
            tmp___16 = (char *)malloc(__len___2);
#line 290
            __retval___2 = tmp___16;
#line 290
            if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 290
              __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )value,
                                            __len___2);
            }
#line 290
            (*(tags->value + i)) = (unsigned char *)__retval___2;
          }
        } else {
#line 290
          (*(tags->value + i)) = (unsigned char *)__strdup((char const   *)value);
        }
      } else {
#line 290
        (*(tags->value + i)) = (unsigned char *)__strdup((char const   *)value);
      }
#line 291
      return;
    }
#line 287
    i ++;
  }
#line 294
  return;
}
}
#line 296 "htmlnorm.c"
static void html_tag_arg_add(tag_arguments_t *tags , unsigned char *tag , unsigned char *value ) 
{ int len ;
  int i ;
  void *tmp___16 ;
  size_t __len___2 ;
  size_t tmp___17 ;
  char *__retval___2 ;
  char *tmp___18 ;
  int tmp___20 ;
  void *tmp___36 ;
  size_t __len___6 ;
  size_t tmp___37 ;
  char *__retval___6 ;
  char *tmp___38 ;
  int tmp___40 ;
  void *tmp___56 ;
  size_t __len___10 ;
  size_t tmp___57 ;
  char *__retval___10 ;
  char *tmp___58 ;
  int tmp___60 ;

  {
#line 300
  tags->count = tags->count + 1;
#line 301
  tags->tag = (unsigned char **)cli_realloc((void *)tags->tag, (unsigned int )tags->count *
                                                               sizeof(char *));
#line 303
  if (! tags->tag) {
    goto abort;
  }
#line 306
  tags->value = (unsigned char **)cli_realloc((void *)tags->value, (unsigned int )tags->count *
                                                                   sizeof(char *));
#line 308
  if (! tags->value) {
    goto abort;
  }
#line 311
  tmp___20 = __builtin_constant_p((int )tag);
#line 311
  if (tmp___20) {
#line 311
    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)tag) ==
        1U) {
#line 311
      if ((int const   )(*((char const   *)tag + 0)) == 0) {
#line 311
        tmp___16 = calloc(1U, 1U);
#line 311
        (*(tags->tag + (tags->count - 1))) = (unsigned char *)((char *)tmp___16);
      } else {
#line 311
        tmp___17 = strlen((char const   *)tag);
#line 311
        __len___2 = tmp___17 + 1U;
#line 311
        tmp___18 = (char *)malloc(__len___2);
#line 311
        __retval___2 = tmp___18;
#line 311
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 311
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )tag,
                                        __len___2);
        }
#line 311
        (*(tags->tag + (tags->count - 1))) = (unsigned char *)__retval___2;
      }
    } else {
#line 311
      (*(tags->tag + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)tag);
    }
  } else {
#line 311
    (*(tags->tag + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)tag);
  }
#line 312
  if (value) {
#line 313
    if ((int )(*value) == 34) {
#line 314
      tmp___40 = __builtin_constant_p((int )(value + 1));
#line 314
      if (tmp___40) {
#line 314
        if ((unsigned int )((void const   *)((value + 1) + 1)) - (unsigned int )((void const   *)(value +
                                                                                                  1)) ==
            1U) {
#line 314
          if ((int const   )(*((char const   *)(value + 1) + 0)) == 0) {
#line 314
            tmp___36 = calloc(1U, 1U);
#line 314
            (*(tags->value + (tags->count - 1))) = (unsigned char *)((char *)tmp___36);
          } else {
#line 314
            tmp___37 = strlen((char const   *)(value + 1));
#line 314
            __len___6 = tmp___37 + 1U;
#line 314
            tmp___38 = (char *)malloc(__len___6);
#line 314
            __retval___6 = tmp___38;
#line 314
            if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 314
              __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )(value +
                                                                                                             1),
                                            __len___6);
            }
#line 314
            (*(tags->value + (tags->count - 1))) = (unsigned char *)__retval___6;
          }
        } else {
#line 314
          (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)(value +
                                                                                            1));
        }
      } else {
#line 314
        (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)(value +
                                                                                          1));
      }
#line 315
      len = (int )strlen((char const   *)(value + 1));
#line 316
      if (len > 0) {
#line 317
        (*((*(tags->value + (tags->count - 1))) + (len - 1))) = (unsigned char )'\000';
      }
    } else {
#line 320
      tmp___60 = __builtin_constant_p((int )value);
#line 320
      if (tmp___60) {
#line 320
        if ((unsigned int )((void const   *)(value + 1)) - (unsigned int )((void const   *)value) ==
            1U) {
#line 320
          if ((int const   )(*((char const   *)value + 0)) == 0) {
#line 320
            tmp___56 = calloc(1U, 1U);
#line 320
            (*(tags->value + (tags->count - 1))) = (unsigned char *)((char *)tmp___56);
          } else {
#line 320
            tmp___57 = strlen((char const   *)value);
#line 320
            __len___10 = tmp___57 + 1U;
#line 320
            tmp___58 = (char *)malloc(__len___10);
#line 320
            __retval___10 = tmp___58;
#line 320
            if ((unsigned int )__retval___10 != (unsigned int )((void *)0)) {
#line 320
              __retval___10 = (char *)memcpy((void * __restrict  )__retval___10, (void const   * __restrict  )value,
                                             __len___10);
            }
#line 320
            (*(tags->value + (tags->count - 1))) = (unsigned char *)__retval___10;
          }
        } else {
#line 320
          (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)value);
        }
      } else {
#line 320
        (*(tags->value + (tags->count - 1))) = (unsigned char *)__strdup((char const   *)value);
      }
    }
  } else {
#line 323
    (*(tags->value + (tags->count - 1))) = (unsigned char *)((void *)0);
  }
#line 325
  return;
  abort: 
#line 329
  tags->count = tags->count - 1;
#line 330
  i = 0;
#line 330
  while (i < tags->count) {
#line 331
    if (tags->tag) {
#line 332
      free((void *)(*(tags->tag + i)));
    }
#line 334
    if (tags->value) {
#line 335
      free((void *)(*(tags->value + i)));
    }
#line 330
    i ++;
  }
#line 338
  if (tags->tag) {
#line 339
    free((void *)tags->tag);
  }
#line 341
  if (tags->value) {
#line 342
    free((void *)tags->value);
  }
#line 344
  tags->value = (unsigned char **)((void *)0);
#line 344
  tags->tag = tags->value;
#line 345
  tags->count = 0;
#line 346
  return;
}
}
#line 349 "htmlnorm.c"
static void html_output_tag(file_buff_t *fbuff , char *tag , tag_arguments_t *tags ) 
{ int i ;
  int j ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___2 ;
  int tmp___3 ;
  __int32_t const   **tmp___4 ;

  {
#line 353
  html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )'<');
#line 354
  tmp = (int )strlen((char const   *)tag);
#line 354
  html_output_str(fbuff, (unsigned char *)tag, tmp);
#line 355
  i = 0;
#line 355
  while (i < tags->count) {
#line 356
    html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )' ');
#line 357
    tmp___0 = (int )strlen((char const   *)(*(tags->tag + i)));
#line 357
    html_output_str(fbuff, (*(tags->tag + i)), tmp___0);
#line 358
    if ((*(tags->value + i))) {
#line 359
      html_output_str(fbuff, (unsigned char *)"=\"", 2);
#line 360
      len = (int )strlen((char const   *)(*(tags->value + i)));
#line 361
      j = 0;
#line 361
      while (j < len) {
#line 362
        if (sizeof((*((*(tags->value + i)) + j))) > 1U) {
#line 362
          tmp___3 = __builtin_constant_p((int )(*((*(tags->value + i)) + j)));
#line 362
          if (tmp___3) {
#line 362
            __c = (int )(*((*(tags->value + i)) + j));
#line 362
            if (__c < -128) {
#line 362
              __res = __c;
            } else {
#line 362
              if (__c > 255) {
#line 362
                __res = __c;
              } else {
#line 362
                tmp___2 = __ctype_tolower_loc();
#line 362
                __res = (*((*tmp___2) + __c));
              }
            }
          } else {
#line 362
            __res = tolower__extinline((int )(*((*(tags->value + i)) + j)));
          }
        } else {
#line 362
          tmp___4 = __ctype_tolower_loc();
#line 362
          __res = (*((*tmp___4) + (int )(*((*(tags->value + i)) + j))));
        }
#line 362
        html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )__res);
#line 361
        j ++;
      }
#line 364
      html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )'\"');
    }
#line 355
    i ++;
  }
#line 367
  html_output_c(fbuff, (file_buff_t *)((void *)0), (unsigned char )'>');
#line 368
  return;
}
}
#line 370 "htmlnorm.c"
void html_tag_arg_free(tag_arguments_t *tags ) 
{ int i ;

  {
#line 374
  i = 0;
#line 374
  while (i < tags->count) {
#line 375
    free((void *)(*(tags->tag + i)));
#line 376
    if ((*(tags->value + i))) {
#line 377
      free((void *)(*(tags->value + i)));
    }
#line 374
    i ++;
  }
#line 380
  if (tags->tag) {
#line 381
    free((void *)tags->tag);
  }
#line 383
  if (tags->value) {
#line 384
    free((void *)tags->value);
  }
#line 386
  tags->value = (unsigned char **)((void *)0);
#line 386
  tags->tag = tags->value;
#line 387
  tags->count = 0;
#line 388
  return;
}
}
#line 390 "htmlnorm.c"
static int cli_html_normalise(int fd , m_area_t *m_area , char const   *dirname ,
                              tag_arguments_t *hrefs ) 
{ int fd_tmp ;
  int tag_length ;
  int tag_arg_length ;
  int binary ;
  int retval ;
  int escape ;
  int value ;
  int hex___0 ;
  int tag_val_length ;
  int table_pos ;
  int in_script ;
  FILE *stream_in ;
  html_state state ;
  html_state next_state ;
  char filename[1024] ;
  char tag[1025] ;
  char tag_arg[1025] ;
  char tag_val[1025] ;
  char *tmp_file ;
  unsigned char *line ;
  unsigned char *ptr ;
  unsigned char *arg_value ;
  tag_arguments_t tag_args ;
  quoted_state quoted ;
  unsigned long length ;
  file_buff_t *file_buff_o1 ;
  file_buff_t *file_buff_o2 ;
  file_buff_t *file_buff_script ;
  file_buff_t *file_tmp_o1 ;
  int tmp ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int __res ;
  int __c ;
  __int32_t const   **tmp___7 ;
  int tmp___8 ;
  __int32_t const   **tmp___9 ;
  int __res___0 ;
  int __c___0 ;
  __int32_t const   **tmp___11 ;
  int tmp___12 ;
  __int32_t const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  int __res___1 ;
  int __c___1 ;
  __int32_t const   **tmp___16 ;
  int tmp___17 ;
  __int32_t const   **tmp___18 ;
  int __res___2 ;
  int __c___2 ;
  __int32_t const   **tmp___20 ;
  int tmp___21 ;
  __int32_t const   **tmp___22 ;
  int tmp___23 ;
  int __res___3 ;
  int __c___3 ;
  __int32_t const   **tmp___25 ;
  int tmp___26 ;
  __int32_t const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  int __res___4 ;
  int __c___4 ;
  __int32_t const   **tmp___30 ;
  int tmp___31 ;
  __int32_t const   **tmp___32 ;
  int tmp___33 ;
  int __res___5 ;
  int __c___5 ;
  __int32_t const   **tmp___35 ;
  int tmp___36 ;
  __int32_t const   **tmp___37 ;
  unsigned short const   **tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  unsigned short const   **tmp___47 ;
  int __res___6 ;
  int __c___6 ;
  __int32_t const   **tmp___49 ;
  int tmp___50 ;
  __int32_t const   **tmp___51 ;
  int tmp___52 ;
  unsigned short const   **tmp___53 ;
  int tmp___128 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___164 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___183 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  size_t tmp___199 ;
  int tmp___200 ;
  size_t tmp___201 ;
  int tmp___276 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___312 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___331 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___340 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  size_t tmp___347 ;
  int tmp___348 ;
  size_t tmp___349 ;
  int __res___7 ;
  int __c___7 ;
  __int32_t const   **tmp___351 ;
  int tmp___352 ;
  __int32_t const   **tmp___353 ;
  int __res___8 ;
  int __c___8 ;
  __int32_t const   **tmp___355 ;
  int tmp___356 ;
  __int32_t const   **tmp___357 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___393 ;
  unsigned char const   *__s2___38 ;
  register int __result___114 ;
  int tmp___412 ;
  unsigned char const   *__s1___78 ;
  register int __result___118 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___423 ;
  int tmp___424 ;
  int tmp___425 ;
  int tmp___426 ;
  int tmp___427 ;
  int tmp___428 ;
  size_t tmp___429 ;
  size_t tmp___430 ;
  size_t tmp___431 ;
  size_t tmp___432 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___468 ;
  unsigned char const   *__s2___46 ;
  register int __result___138 ;
  int tmp___487 ;
  unsigned char const   *__s1___94 ;
  register int __result___142 ;
  int tmp___496 ;
  int tmp___497 ;
  int tmp___498 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___537 ;
  unsigned char const   *__s2___54 ;
  register int __result___162 ;
  int tmp___556 ;
  unsigned char const   *__s1___110 ;
  register int __result___166 ;
  int tmp___565 ;
  int tmp___566 ;
  int tmp___567 ;
  int tmp___568 ;
  int tmp___569 ;
  int tmp___570 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___606 ;
  unsigned char const   *__s2___62 ;
  register int __result___186 ;
  int tmp___625 ;
  unsigned char const   *__s1___126 ;
  register int __result___190 ;
  int tmp___634 ;
  int tmp___635 ;
  int tmp___636 ;
  int tmp___637 ;
  int tmp___638 ;
  int tmp___639 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___675 ;
  unsigned char const   *__s2___70 ;
  register int __result___210 ;
  int tmp___694 ;
  unsigned char const   *__s1___142 ;
  register int __result___214 ;
  int tmp___703 ;
  int tmp___704 ;
  int tmp___705 ;
  int tmp___706 ;
  int tmp___707 ;
  int tmp___708 ;
  int __res___9 ;
  int __c___9 ;
  __int32_t const   **tmp___710 ;
  int tmp___711 ;
  __int32_t const   **tmp___712 ;
  unsigned short const   **tmp___713 ;
  unsigned short const   **tmp___714 ;
  unsigned short const   **tmp___715 ;
  int __res___10 ;
  int __c___10 ;
  __int32_t const   **tmp___717 ;
  int tmp___718 ;
  __int32_t const   **tmp___719 ;
  int __res___11 ;
  int __c___11 ;
  __int32_t const   **tmp___721 ;
  int tmp___722 ;
  __int32_t const   **tmp___723 ;
  int tmp___798 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___834 ;
  unsigned char const   *__s2___86 ;
  register int __result___258 ;
  int tmp___853 ;
  unsigned char const   *__s1___174 ;
  register int __result___262 ;
  int tmp___862 ;
  int tmp___863 ;
  int tmp___864 ;
  int tmp___865 ;
  int tmp___866 ;
  int tmp___867 ;
  int tmp___868 ;
  size_t tmp___869 ;
  int tmp___870 ;
  size_t tmp___871 ;
  size_t tmp___872 ;
  int __res___12 ;
  int __c___12 ;
  __int32_t const   **tmp___874 ;
  int tmp___875 ;
  __int32_t const   **tmp___876 ;
  int tmp___877 ;
  int tmp___878 ;
  int tmp___879 ;
  int tmp___880 ;
  unsigned short const   **tmp___881 ;
  int tmp___882 ;
  int __res___13 ;
  int __c___13 ;
  __int32_t const   **tmp___884 ;
  int tmp___885 ;
  __int32_t const   **tmp___886 ;
  unsigned short const   **tmp___887 ;
  char *tmp___889 ;
  unsigned short const   **tmp___890 ;
  int __res___14 ;
  int __c___14 ;
  __int32_t const   **tmp___892 ;
  int tmp___893 ;
  __int32_t const   **tmp___894 ;
  unsigned short const   **tmp___895 ;
  unsigned short const   **tmp___896 ;

  {
#line 393
  retval = 0;
#line 393
  in_script = 0;
#line 395
  state = (enum __anonenum_html_state_22 )1;
#line 395
  next_state = (enum __anonenum_html_state_22 )0;
#line 405
  if (! m_area) {
#line 406
    if (fd < 0) {
#line 407
      cli_dbgmsg("Invalid HTML fd\n");
#line 408
      return (0);
    }
#line 410
    lseek(fd, 0L, 0);
#line 411
    fd_tmp = dup(fd);
#line 412
    if (fd_tmp < 0) {
#line 413
      return (0);
    }
#line 415
    stream_in = fdopen(fd_tmp, "r");
#line 416
    if (! stream_in) {
#line 417
      close(fd_tmp);
#line 418
      return (0);
    }
  }
#line 422
  tag_args.count = 0;
#line 423
  tag_args.tag = (unsigned char **)((void *)0);
#line 424
  tag_args.value = (unsigned char **)((void *)0);
#line 426
  if (dirname) {
#line 427
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/rfc2397",
             dirname);
#line 428
    tmp = mkdir((char const   *)(filename), 448U);
#line 428
    if (tmp) {
#line 429
      file_buff_script = (file_buff_t *)((void *)0);
#line 429
      file_buff_o2 = file_buff_script;
#line 429
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 432
    file_buff_o1 = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
#line 433
    if (! file_buff_o1) {
#line 434
      file_buff_script = (file_buff_t *)((void *)0);
#line 434
      file_buff_o2 = file_buff_script;
#line 434
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 438
    file_buff_o2 = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
#line 439
    if (! file_buff_o2) {
#line 440
      free((void *)file_buff_o1);
#line 441
      file_buff_script = (file_buff_t *)((void *)0);
#line 441
      file_buff_o2 = file_buff_script;
#line 441
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 445
    file_buff_script = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
#line 446
    if (! file_buff_script) {
#line 447
      free((void *)file_buff_o1);
#line 448
      free((void *)file_buff_o2);
#line 449
      file_buff_script = (file_buff_t *)((void *)0);
#line 449
      file_buff_o2 = file_buff_script;
#line 449
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 453
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/comment.html",
             dirname);
#line 454
    file_buff_o1->fd = open((char const   *)(filename), 577, 384);
#line 455
    if (! file_buff_o1->fd) {
#line 456
      cli_dbgmsg("open failed: %s\n", filename);
#line 457
      free((void *)file_buff_o1);
#line 458
      free((void *)file_buff_o2);
#line 459
      free((void *)file_buff_script);
#line 460
      file_buff_script = (file_buff_t *)((void *)0);
#line 460
      file_buff_o2 = file_buff_script;
#line 460
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 464
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/nocomment.html",
             dirname);
#line 465
    file_buff_o2->fd = open((char const   *)(filename), 577, 384);
#line 466
    if (! file_buff_o2->fd) {
#line 467
      cli_dbgmsg("open failed: %s\n", filename);
#line 468
      close(file_buff_o1->fd);
#line 469
      free((void *)file_buff_o1);
#line 470
      free((void *)file_buff_o2);
#line 471
      free((void *)file_buff_script);
#line 472
      file_buff_script = (file_buff_t *)((void *)0);
#line 472
      file_buff_o2 = file_buff_script;
#line 472
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 476
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/script.html",
             dirname);
#line 477
    file_buff_script->fd = open((char const   *)(filename), 577, 384);
#line 478
    if (! file_buff_script->fd) {
#line 479
      cli_dbgmsg("open failed: %s\n", filename);
#line 480
      close(file_buff_o1->fd);
#line 481
      close(file_buff_o2->fd);
#line 482
      free((void *)file_buff_o1);
#line 483
      free((void *)file_buff_o2);
#line 484
      free((void *)file_buff_script);
#line 485
      file_buff_script = (file_buff_t *)((void *)0);
#line 485
      file_buff_o2 = file_buff_script;
#line 485
      file_buff_o1 = file_buff_o2;
      goto abort;
    }
#line 489
    file_buff_o1->length = 0;
#line 490
    file_buff_o2->length = 0;
#line 491
    file_buff_script->length = 0;
  } else {
#line 493
    file_buff_o1 = (file_buff_t *)((void *)0);
#line 494
    file_buff_o2 = (file_buff_t *)((void *)0);
#line 495
    file_buff_script = (file_buff_t *)((void *)0);
  }
#line 498
  binary = 0;
#line 500
  line = cli_readline(stream_in, m_area, 8192U);
#line 500
  ptr = line;
#line 501
  while (line) {
#line 502
    while (1) {
#line 502
      if ((*ptr)) {
#line 502
        tmp___3 = __ctype_b_loc();
#line 502
        if (! ((int const   )(*((*tmp___3) + (int )(*ptr))) & 8192)) {
#line 502
          break;
        }
      } else {
#line 502
        break;
      }
#line 503
      ptr ++;
    }
#line 505
    while ((*ptr)) {
#line 506
      if (! binary) {
#line 506
        if ((int )(*ptr) == 10) {
#line 508
          (*ptr) = (unsigned char )' ';
#line 509
          continue;
        }
      }
#line 511
      if (! binary) {
#line 511
        if ((int )(*ptr) == 13) {
#line 512
          ptr ++;
#line 513
          continue;
        }
      }
#line 515
      switch ((int )state) {
      case 0: 
#line 518
      cli_dbgmsg("HTML Engine Error\n");
      goto abort;
      case 12: 
#line 521
      length --;
#line 522
      ptr ++;
#line 523
      if (! length) {
#line 524
        state = next_state;
      }
#line 526
      break;
      case 4: 
#line 528
      tmp___4 = __ctype_b_loc();
#line 528
      if ((int const   )(*((*tmp___4) + (int )(*ptr))) & 8192) {
#line 529
        ptr ++;
      } else {
#line 531
        state = next_state;
#line 532
        next_state = (enum __anonenum_html_state_22 )0;
      }
#line 534
      break;
      case 5: 
#line 536
      tmp___5 = __ctype_b_loc();
#line 536
      if ((int const   )(*((*tmp___5) + (int )(*ptr))) & 8192) {
#line 537
        ptr ++;
      } else {
#line 539
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )' ');
#line 540
        state = next_state;
#line 541
        next_state = (enum __anonenum_html_state_22 )0;
      }
#line 543
      break;
      case 1: ;
#line 545
      if ((int )(*ptr) == 60) {
#line 546
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'<');
#line 547
        if (in_script) {
#line 548
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'<');
        }
#line 550
        ptr ++;
#line 551
        state = (enum __anonenum_html_state_22 )4;
#line 552
        tag_length = 0;
#line 553
        next_state = (enum __anonenum_html_state_22 )6;
      } else {
#line 554
        tmp___14 = __ctype_b_loc();
#line 554
        if ((int const   )(*((*tmp___14) + (int )(*ptr))) & 8192) {
#line 555
          state = (enum __anonenum_html_state_22 )5;
#line 556
          next_state = (enum __anonenum_html_state_22 )1;
        } else {
#line 557
          if ((int )(*ptr) == 38) {
#line 558
            state = (enum __anonenum_html_state_22 )3;
#line 559
            next_state = (enum __anonenum_html_state_22 )1;
#line 560
            ptr ++;
          } else {
#line 562
            if (sizeof((*ptr)) > 1U) {
#line 562
              tmp___8 = __builtin_constant_p((int )(*ptr));
#line 562
              if (tmp___8) {
#line 562
                __c = (int )(*ptr);
#line 562
                if (__c < -128) {
#line 562
                  __res = __c;
                } else {
#line 562
                  if (__c > 255) {
#line 562
                    __res = __c;
                  } else {
#line 562
                    tmp___7 = __ctype_tolower_loc();
#line 562
                    __res = (*((*tmp___7) + __c));
                  }
                }
              } else {
#line 562
                __res = tolower__extinline((int )(*ptr));
              }
            } else {
#line 562
              tmp___9 = __ctype_tolower_loc();
#line 562
              __res = (*((*tmp___9) + (int )(*ptr)));
            }
#line 562
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res);
#line 563
            if (in_script) {
#line 564
              if (sizeof((*ptr)) > 1U) {
#line 564
                tmp___12 = __builtin_constant_p((int )(*ptr));
#line 564
                if (tmp___12) {
#line 564
                  __c___0 = (int )(*ptr);
#line 564
                  if (__c___0 < -128) {
#line 564
                    __res___0 = __c___0;
                  } else {
#line 564
                    if (__c___0 > 255) {
#line 564
                      __res___0 = __c___0;
                    } else {
#line 564
                      tmp___11 = __ctype_tolower_loc();
#line 564
                      __res___0 = (*((*tmp___11) + __c___0));
                    }
                  }
                } else {
#line 564
                  __res___0 = tolower__extinline((int )(*ptr));
                }
              } else {
#line 564
                tmp___13 = __ctype_tolower_loc();
#line 564
                __res___0 = (*((*tmp___13) + (int )(*ptr)));
              }
#line 564
              html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___0);
            }
#line 566
            ptr ++;
          }
        }
      }
#line 568
      break;
      case 6: ;
#line 570
      if (tag_length == 0) {
#line 570
        if ((int )(*ptr) == 33) {
#line 572
          html_output_c(file_buff_o1, (file_buff_t *)((void *)0), (unsigned char )'!');
#line 573
          if (in_script) {
#line 574
            html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'!');
          }
#line 577
          if (file_buff_o2) {
#line 577
            if (file_buff_o2->length > 0) {
#line 578
              file_buff_o2->length --;
            }
          }
#line 580
          state = (enum __anonenum_html_state_22 )2;
#line 581
          next_state = (enum __anonenum_html_state_22 )0;
#line 582
          ptr ++;
        } else {
          goto _L;
        }
      } else {
        _L: 
#line 583
        if ((int )(*ptr) == 62) {
#line 584
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'>');
#line 585
          if (in_script) {
#line 586
            html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'>');
          }
#line 588
          ptr ++;
#line 589
          tag[tag_length] = (char )'\000';
#line 590
          state = (enum __anonenum_html_state_22 )4;
#line 591
          next_state = (enum __anonenum_html_state_22 )10;
        } else {
#line 592
          tmp___28 = __ctype_b_loc();
#line 592
          if ((int const   )(*((*tmp___28) + (int )(*ptr))) & 8192) {
#line 602
            tag[tag_length] = (char )'\000';
#line 603
            state = (enum __anonenum_html_state_22 )4;
#line 604
            tag_arg_length = 0;
#line 605
            next_state = (enum __anonenum_html_state_22 )7;
          } else {
#line 593
            if (sizeof((*ptr)) > 1U) {
#line 593
              tmp___17 = __builtin_constant_p((int )(*ptr));
#line 593
              if (tmp___17) {
#line 593
                __c___1 = (int )(*ptr);
#line 593
                if (__c___1 < -128) {
#line 593
                  __res___1 = __c___1;
                } else {
#line 593
                  if (__c___1 > 255) {
#line 593
                    __res___1 = __c___1;
                  } else {
#line 593
                    tmp___16 = __ctype_tolower_loc();
#line 593
                    __res___1 = (*((*tmp___16) + __c___1));
                  }
                }
              } else {
#line 593
                __res___1 = tolower__extinline((int )(*ptr));
              }
            } else {
#line 593
              tmp___18 = __ctype_tolower_loc();
#line 593
              __res___1 = (*((*tmp___18) + (int )(*ptr)));
            }
#line 593
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___1);
#line 594
            if (in_script) {
#line 595
              if (sizeof((*ptr)) > 1U) {
#line 595
                tmp___21 = __builtin_constant_p((int )(*ptr));
#line 595
                if (tmp___21) {
#line 595
                  __c___2 = (int )(*ptr);
#line 595
                  if (__c___2 < -128) {
#line 595
                    __res___2 = __c___2;
                  } else {
#line 595
                    if (__c___2 > 255) {
#line 595
                      __res___2 = __c___2;
                    } else {
#line 595
                      tmp___20 = __ctype_tolower_loc();
#line 595
                      __res___2 = (*((*tmp___20) + __c___2));
                    }
                  }
                } else {
#line 595
                  __res___2 = tolower__extinline((int )(*ptr));
                }
              } else {
#line 595
                tmp___22 = __ctype_tolower_loc();
#line 595
                __res___2 = (*((*tmp___22) + (int )(*ptr)));
              }
#line 595
              html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___2);
            }
#line 597
            if (tag_length < 1024) {
#line 598
              tmp___23 = tag_length;
#line 598
              tag_length ++;
#line 598
              if (sizeof((*ptr)) > 1U) {
#line 598
                tmp___26 = __builtin_constant_p((int )(*ptr));
#line 598
                if (tmp___26) {
#line 598
                  __c___3 = (int )(*ptr);
#line 598
                  if (__c___3 < -128) {
#line 598
                    __res___3 = __c___3;
                  } else {
#line 598
                    if (__c___3 > 255) {
#line 598
                      __res___3 = __c___3;
                    } else {
#line 598
                      tmp___25 = __ctype_tolower_loc();
#line 598
                      __res___3 = (*((*tmp___25) + __c___3));
                    }
                  }
                } else {
#line 598
                  __res___3 = tolower__extinline((int )(*ptr));
                }
              } else {
#line 598
                tmp___27 = __ctype_tolower_loc();
#line 598
                __res___3 = (*((*tmp___27) + (int )(*ptr)));
              }
#line 598
              tag[tmp___23] = (char )__res___3;
            }
#line 600
            ptr ++;
          }
        }
      }
#line 607
      break;
      case 7: ;
#line 609
      if ((int )(*ptr) == 61) {
#line 610
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'=');
#line 611
        tag_arg[tag_arg_length] = (char )'\000';
#line 612
        ptr ++;
#line 613
        state = (enum __anonenum_html_state_22 )4;
#line 614
        escape = 0;
#line 615
        quoted = (enum __anonenum_quoted_state_23 )2;
#line 616
        tag_val_length = 0;
#line 617
        next_state = (enum __anonenum_html_state_22 )8;
      } else {
#line 618
        tmp___38 = __ctype_b_loc();
#line 618
        if ((int const   )(*((*tmp___38) + (int )(*ptr))) & 8192) {
#line 619
          ptr ++;
#line 620
          tag_arg[tag_arg_length] = (char )'\000';
#line 621
          state = (enum __anonenum_html_state_22 )4;
#line 622
          next_state = (enum __anonenum_html_state_22 )9;
        } else {
#line 623
          if ((int )(*ptr) == 62) {
#line 624
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'>');
#line 625
            if (tag_arg_length > 0) {
#line 626
              tag_arg[tag_arg_length] = (char )'\000';
#line 627
              html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)((void *)0));
            }
#line 629
            ptr ++;
#line 630
            state = (enum __anonenum_html_state_22 )10;
#line 631
            next_state = (enum __anonenum_html_state_22 )0;
          } else {
#line 633
            if (tag_arg_length == 0) {
#line 635
              html_output_c(file_buff_o1, file_buff_o2, (unsigned char )' ');
            }
#line 637
            if (sizeof((*ptr)) > 1U) {
#line 637
              tmp___31 = __builtin_constant_p((int )(*ptr));
#line 637
              if (tmp___31) {
#line 637
                __c___4 = (int )(*ptr);
#line 637
                if (__c___4 < -128) {
#line 637
                  __res___4 = __c___4;
                } else {
#line 637
                  if (__c___4 > 255) {
#line 637
                    __res___4 = __c___4;
                  } else {
#line 637
                    tmp___30 = __ctype_tolower_loc();
#line 637
                    __res___4 = (*((*tmp___30) + __c___4));
                  }
                }
              } else {
#line 637
                __res___4 = tolower__extinline((int )(*ptr));
              }
            } else {
#line 637
              tmp___32 = __ctype_tolower_loc();
#line 637
              __res___4 = (*((*tmp___32) + (int )(*ptr)));
            }
#line 637
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___4);
#line 638
            if (tag_arg_length < 1024) {
#line 639
              tmp___33 = tag_arg_length;
#line 639
              tag_arg_length ++;
#line 639
              if (sizeof((*ptr)) > 1U) {
#line 639
                tmp___36 = __builtin_constant_p((int )(*ptr));
#line 639
                if (tmp___36) {
#line 639
                  __c___5 = (int )(*ptr);
#line 639
                  if (__c___5 < -128) {
#line 639
                    __res___5 = __c___5;
                  } else {
#line 639
                    if (__c___5 > 255) {
#line 639
                      __res___5 = __c___5;
                    } else {
#line 639
                      tmp___35 = __ctype_tolower_loc();
#line 639
                      __res___5 = (*((*tmp___35) + __c___5));
                    }
                  }
                } else {
#line 639
                  __res___5 = tolower__extinline((int )(*ptr));
                }
              } else {
#line 639
                tmp___37 = __ctype_tolower_loc();
#line 639
                __res___5 = (*((*tmp___37) + (int )(*ptr)));
              }
#line 639
              tag_arg[tmp___33] = (char )__res___5;
            }
#line 641
            ptr ++;
          }
        }
      }
#line 643
      break;
      case 9: ;
#line 645
      if ((int )(*ptr) == 61) {
#line 646
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'=');
#line 647
        ptr ++;
#line 648
        state = (enum __anonenum_html_state_22 )4;
#line 649
        escape = 0;
#line 650
        quoted = (enum __anonenum_quoted_state_23 )2;
#line 651
        tag_val_length = 0;
#line 652
        next_state = (enum __anonenum_html_state_22 )8;
      } else {
#line 654
        if (tag_arg_length > 0) {
#line 655
          tag_arg[tag_arg_length] = (char )'\000';
#line 656
          html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)((void *)0));
        }
#line 658
        tag_arg_length = 0;
#line 659
        state = (enum __anonenum_html_state_22 )7;
#line 660
        next_state = (enum __anonenum_html_state_22 )0;
      }
#line 662
      break;
      case 8: ;
#line 664
      if (tag_val_length == 5) {
#line 664
        tmp___346 = __builtin_constant_p((int )(tag_val));
#line 664
        if (tmp___346) {
#line 664
          tmp___347 = strlen((char const   *)(tag_val));
#line 664
          if (tmp___347 < 5U) {
            goto _L___86;
          } else {
            goto _L___87;
          }
        } else {
          _L___87: 
#line 664
          tmp___348 = __builtin_constant_p((int )"data:");
#line 664
          if (tmp___348) {
#line 664
            tmp___349 = strlen("data:");
#line 664
            if (tmp___349 < 5U) {
              _L___86: 
#line 664
              tmp___343 = __builtin_constant_p((int )(tag_val));
#line 664
              if (tmp___343) {
#line 664
                tmp___344 = __builtin_constant_p((int )"data:");
#line 664
                if (tmp___344) {
#line 664
                  __s1_len___2 = strlen((char const   *)(tag_val));
#line 664
                  __s2_len___2 = strlen("data:");
#line 664
                  if (! ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                         1U)) {
                    goto _L___83;
                  } else {
#line 664
                    if (__s1_len___2 >= 4U) {
                      _L___83: 
#line 664
                      if (! ((unsigned int )((void const   *)("data:" + 1)) - (unsigned int )((void const   *)"data:") ==
                             1U)) {
#line 664
                        tmp___345 = 1;
                      } else {
#line 664
                        if (__s2_len___2 >= 4U) {
#line 664
                          tmp___345 = 1;
                        } else {
#line 664
                          tmp___345 = 0;
                        }
                      }
                    } else {
#line 664
                      tmp___345 = 0;
                    }
                  }
#line 664
                  if (tmp___345) {
#line 664
                    tmp___312 = __builtin_strcmp(tag_val, "data:");
                  } else {
                    goto _L___85;
                  }
                } else {
                  goto _L___85;
                }
              } else {
                _L___85: 
#line 664
                tmp___342 = __builtin_constant_p((int )(tag_val));
#line 664
                if (tmp___342) {
#line 664
                  if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                      1U) {
#line 664
                    __s1_len___2 = strlen((char const   *)(tag_val));
#line 664
                    if (__s1_len___2 < 4U) {
#line 664
                      tmp___331 = __builtin_constant_p((int )"data:");
#line 664
                      if (tmp___331) {
#line 664
                        if ((unsigned int )((void const   *)("data:" + 1)) - (unsigned int )((void const   *)"data:") ==
                            1U) {
#line 664
                          tmp___312 = __builtin_strcmp(tag_val, "data:");
                        } else {
                          goto _L___78;
                        }
                      } else {
                        _L___78: 
#line 664
                        __s2___30 = (unsigned char const   *)"data:";
#line 664
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                0)) - (int const   )(*(__s2___30 +
                                                                                       0)));
#line 664
                        if (__s1_len___2 > 0U) {
#line 664
                          if (__result___90 == 0) {
#line 664
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                    1)) - (int const   )(*(__s2___30 +
                                                                                           1)));
#line 664
                            if (__s1_len___2 > 1U) {
#line 664
                              if (__result___90 == 0) {
#line 664
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                        2)) - (int const   )(*(__s2___30 +
                                                                                               2)));
#line 664
                                if (__s1_len___2 > 2U) {
#line 664
                                  if (__result___90 == 0) {
#line 664
                                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                            3)) -
                                                           (int const   )(*(__s2___30 +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 664
                        tmp___312 = __result___90;
                      }
                    } else {
                      goto _L___82;
                    }
                  } else {
                    goto _L___82;
                  }
                } else {
                  _L___82: 
#line 664
                  tmp___341 = __builtin_constant_p((int )"data:");
#line 664
                  if (tmp___341) {
#line 664
                    if ((unsigned int )((void const   *)("data:" + 1)) - (unsigned int )((void const   *)"data:") ==
                        1U) {
#line 664
                      __s2_len___2 = strlen("data:");
#line 664
                      if (__s2_len___2 < 4U) {
#line 664
                        tmp___340 = __builtin_constant_p((int )(tag_val));
#line 664
                        if (tmp___340) {
#line 664
                          if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                              1U) {
#line 664
                            tmp___312 = __builtin_strcmp(tag_val, "data:");
                          } else {
                            goto _L___80;
                          }
                        } else {
                          _L___80: 
#line 664
                          __s1___62 = (unsigned char const   *)((char const   *)(tag_val));
#line 664
                          __result___94 = (int )((int const   )(*(__s1___62 + 0)) -
                                                 (int const   )(*((unsigned char const   *)"data:" +
                                                                  0)));
#line 664
                          if (__s2_len___2 > 0U) {
#line 664
                            if (__result___94 == 0) {
#line 664
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      1)) - (int const   )(*((unsigned char const   *)"data:" +
                                                                                             1)));
#line 664
                              if (__s2_len___2 > 1U) {
#line 664
                                if (__result___94 == 0) {
#line 664
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          2)) - (int const   )(*((unsigned char const   *)"data:" +
                                                                                                 2)));
#line 664
                                  if (__s2_len___2 > 2U) {
#line 664
                                    if (__result___94 == 0) {
#line 664
                                      __result___94 = (int )((int const   )(*(__s1___62 +
                                                                              3)) -
                                                             (int const   )(*((unsigned char const   *)"data:" +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 664
                          tmp___312 = __result___94;
                        }
                      } else {
#line 664
                        tmp___312 = __builtin_strcmp(tag_val, "data:");
                      }
                    } else {
#line 664
                      tmp___312 = __builtin_strcmp(tag_val, "data:");
                    }
                  } else {
#line 664
                    tmp___312 = __builtin_strcmp(tag_val, "data:");
                  }
                }
              }
#line 664
              tmp___276 = tmp___312;
            } else {
#line 664
              tmp___276 = strncmp((char const   *)(tag_val), "data:", 5U);
            }
          } else {
#line 664
            tmp___276 = strncmp((char const   *)(tag_val), "data:", 5U);
          }
        }
#line 664
        if (tmp___276 == 0) {
#line 668
          if (file_buff_o1) {
#line 668
            if (file_buff_o1->length > 0) {
#line 669
              file_buff_o1->length --;
            }
          }
#line 671
          if (file_buff_o2) {
#line 671
            if (file_buff_o2->length > 0) {
#line 672
              file_buff_o2->length --;
            }
          }
#line 675
          if ((int )quoted != 2) {
#line 676
            html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
          }
#line 678
          tag_val_length = 0;
#line 679
          state = (enum __anonenum_html_state_22 )17;
#line 680
          next_state = (enum __anonenum_html_state_22 )7;
        } else {
          goto _L___88;
        }
      } else {
        _L___88: 
#line 681
        if (tag_val_length == 6) {
#line 681
          tmp___198 = __builtin_constant_p((int )(tag_val));
#line 681
          if (tmp___198) {
#line 681
            tmp___199 = strlen((char const   *)(tag_val));
#line 681
            if (tmp___199 < 6U) {
              goto _L___43;
            } else {
              goto _L___44;
            }
          } else {
            _L___44: 
#line 681
            tmp___200 = __builtin_constant_p((int )"\"data:");
#line 681
            if (tmp___200) {
#line 681
              tmp___201 = strlen("\"data:");
#line 681
              if (tmp___201 < 6U) {
                _L___43: 
#line 681
                tmp___195 = __builtin_constant_p((int )(tag_val));
#line 681
                if (tmp___195) {
#line 681
                  tmp___196 = __builtin_constant_p((int )"\"data:");
#line 681
                  if (tmp___196) {
#line 681
                    __s1_len___0 = strlen((char const   *)(tag_val));
#line 681
                    __s2_len___0 = strlen("\"data:");
#line 681
                    if (! ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                           1U)) {
                      goto _L___40;
                    } else {
#line 681
                      if (__s1_len___0 >= 4U) {
                        _L___40: 
#line 681
                        if (! ((unsigned int )((void const   *)("\"data:" + 1)) -
                               (unsigned int )((void const   *)"\"data:") == 1U)) {
#line 681
                          tmp___197 = 1;
                        } else {
#line 681
                          if (__s2_len___0 >= 4U) {
#line 681
                            tmp___197 = 1;
                          } else {
#line 681
                            tmp___197 = 0;
                          }
                        }
                      } else {
#line 681
                        tmp___197 = 0;
                      }
                    }
#line 681
                    if (tmp___197) {
#line 681
                      tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                    } else {
                      goto _L___42;
                    }
                  } else {
                    goto _L___42;
                  }
                } else {
                  _L___42: 
#line 681
                  tmp___194 = __builtin_constant_p((int )(tag_val));
#line 681
                  if (tmp___194) {
#line 681
                    if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                        1U) {
#line 681
                      __s1_len___0 = strlen((char const   *)(tag_val));
#line 681
                      if (__s1_len___0 < 4U) {
#line 681
                        tmp___183 = __builtin_constant_p((int )"\"data:");
#line 681
                        if (tmp___183) {
#line 681
                          if ((unsigned int )((void const   *)("\"data:" + 1)) - (unsigned int )((void const   *)"\"data:") ==
                              1U) {
#line 681
                            tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                          } else {
                            goto _L___35;
                          }
                        } else {
                          _L___35: 
#line 681
                          __s2___14 = (unsigned char const   *)"\"data:";
#line 681
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                  0)) - (int const   )(*(__s2___14 +
                                                                                         0)));
#line 681
                          if (__s1_len___0 > 0U) {
#line 681
                            if (__result___42 == 0) {
#line 681
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                      1)) - (int const   )(*(__s2___14 +
                                                                                             1)));
#line 681
                              if (__s1_len___0 > 1U) {
#line 681
                                if (__result___42 == 0) {
#line 681
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                          2)) - (int const   )(*(__s2___14 +
                                                                                                 2)));
#line 681
                                  if (__s1_len___0 > 2U) {
#line 681
                                    if (__result___42 == 0) {
#line 681
                                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag_val)) +
                                                                              3)) -
                                                             (int const   )(*(__s2___14 +
                                                                              3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 681
                          tmp___164 = __result___42;
                        }
                      } else {
                        goto _L___39;
                      }
                    } else {
                      goto _L___39;
                    }
                  } else {
                    _L___39: 
#line 681
                    tmp___193 = __builtin_constant_p((int )"\"data:");
#line 681
                    if (tmp___193) {
#line 681
                      if ((unsigned int )((void const   *)("\"data:" + 1)) - (unsigned int )((void const   *)"\"data:") ==
                          1U) {
#line 681
                        __s2_len___0 = strlen("\"data:");
#line 681
                        if (__s2_len___0 < 4U) {
#line 681
                          tmp___192 = __builtin_constant_p((int )(tag_val));
#line 681
                          if (tmp___192) {
#line 681
                            if ((unsigned int )((void const   *)(tag_val + 1)) - (unsigned int )((void const   *)(tag_val)) ==
                                1U) {
#line 681
                              tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                            } else {
                              goto _L___37;
                            }
                          } else {
                            _L___37: 
#line 681
                            __s1___30 = (unsigned char const   *)((char const   *)(tag_val));
#line 681
                            __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                                   (int const   )(*((unsigned char const   *)"\"data:" +
                                                                    0)));
#line 681
                            if (__s2_len___0 > 0U) {
#line 681
                              if (__result___46 == 0) {
#line 681
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        1)) - (int const   )(*((unsigned char const   *)"\"data:" +
                                                                                               1)));
#line 681
                                if (__s2_len___0 > 1U) {
#line 681
                                  if (__result___46 == 0) {
#line 681
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            2)) -
                                                           (int const   )(*((unsigned char const   *)"\"data:" +
                                                                            2)));
#line 681
                                    if (__s2_len___0 > 2U) {
#line 681
                                      if (__result___46 == 0) {
#line 681
                                        __result___46 = (int )((int const   )(*(__s1___30 +
                                                                                3)) -
                                                               (int const   )(*((unsigned char const   *)"\"data:" +
                                                                                3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
#line 681
                            tmp___164 = __result___46;
                          }
                        } else {
#line 681
                          tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                        }
                      } else {
#line 681
                        tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                      }
                    } else {
#line 681
                      tmp___164 = __builtin_strcmp(tag_val, "\"data:");
                    }
                  }
                }
#line 681
                tmp___128 = tmp___164;
              } else {
#line 681
                tmp___128 = strncmp((char const   *)(tag_val), "\"data:", 6U);
              }
            } else {
#line 681
              tmp___128 = strncmp((char const   *)(tag_val), "\"data:", 6U);
            }
          }
#line 681
          if (tmp___128 == 0) {
#line 685
            if (file_buff_o1) {
#line 685
              if (file_buff_o1->length > 0) {
#line 686
                file_buff_o1->length --;
              }
            }
#line 688
            if (file_buff_o2) {
#line 688
              if (file_buff_o2->length > 0) {
#line 689
                file_buff_o2->length --;
              }
            }
#line 692
            if ((int )quoted != 2) {
#line 693
              html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
            }
#line 696
            tag_val_length = 0;
#line 697
            state = (enum __anonenum_html_state_22 )17;
#line 698
            next_state = (enum __anonenum_html_state_22 )7;
          } else {
            goto _L___45;
          }
        } else {
          _L___45: 
#line 699
          if ((int )(*ptr) == 38) {
#line 700
            state = (enum __anonenum_html_state_22 )3;
#line 701
            next_state = (enum __anonenum_html_state_22 )8;
#line 702
            ptr ++;
          } else {
#line 703
            if ((int )(*ptr) == 39) {
#line 704
              if (tag_val_length == 0) {
#line 705
                quoted = (enum __anonenum_quoted_state_23 )0;
#line 706
                html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
#line 707
                if (tag_val_length < 1024) {
#line 708
                  tmp___39 = tag_val_length;
#line 708
                  tag_val_length ++;
#line 708
                  tag_val[tmp___39] = (char )'\"';
                }
#line 710
                ptr ++;
              } else {
#line 712
                if (! escape) {
#line 712
                  if ((int )quoted == 0) {
#line 713
                    html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
#line 714
                    if (tag_val_length < 1024) {
#line 715
                      tmp___40 = tag_val_length;
#line 715
                      tag_val_length ++;
#line 715
                      tag_val[tmp___40] = (char )'\"';
                    }
#line 717
                    tag_val[tag_val_length] = (char )'\000';
#line 718
                    html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)(tag_val));
#line 719
                    ptr ++;
#line 720
                    state = (enum __anonenum_html_state_22 )4;
#line 721
                    tag_arg_length = 0;
#line 722
                    next_state = (enum __anonenum_html_state_22 )7;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
#line 724
                  html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
#line 725
                  if (tag_val_length < 1024) {
#line 726
                    tmp___41 = tag_val_length;
#line 726
                    tag_val_length ++;
#line 726
                    tag_val[tmp___41] = (char )'\"';
                  }
#line 728
                  ptr ++;
                }
              }
            } else {
#line 731
              if ((int )(*ptr) == 34) {
#line 732
                if (tag_val_length == 0) {
#line 733
                  quoted = (enum __anonenum_quoted_state_23 )1;
#line 734
                  html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
#line 735
                  if (tag_val_length < 1024) {
#line 736
                    tmp___42 = tag_val_length;
#line 736
                    tag_val_length ++;
#line 736
                    tag_val[tmp___42] = (char )'\"';
                  }
#line 738
                  ptr ++;
                } else {
#line 740
                  if (! escape) {
#line 740
                    if ((int )quoted == 1) {
#line 741
                      html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
#line 742
                      if (tag_val_length < 1024) {
#line 743
                        tmp___43 = tag_val_length;
#line 743
                        tag_val_length ++;
#line 743
                        tag_val[tmp___43] = (char )'\"';
                      }
#line 745
                      tag_val[tag_val_length] = (char )'\000';
#line 746
                      html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)(tag_val));
#line 747
                      ptr ++;
#line 748
                      state = (enum __anonenum_html_state_22 )4;
#line 749
                      tag_arg_length = 0;
#line 750
                      next_state = (enum __anonenum_html_state_22 )7;
                    } else {
                      goto _L___1;
                    }
                  } else {
                    _L___1: 
#line 752
                    html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'\"');
#line 753
                    if (tag_val_length < 1024) {
#line 754
                      tmp___44 = tag_val_length;
#line 754
                      tag_val_length ++;
#line 754
                      tag_val[tmp___44] = (char )'\"';
                    }
#line 756
                    ptr ++;
                  }
                }
              } else {
#line 759
                tmp___53 = __ctype_b_loc();
#line 759
                if ((int const   )(*((*tmp___53) + (int )(*ptr))) & 8192) {
                  goto _L___2;
                } else {
#line 759
                  if ((int )(*ptr) == 62) {
                    _L___2: 
#line 760
                    if ((int )quoted == 2) {
#line 761
                      tag_val[tag_val_length] = (char )'\000';
#line 762
                      html_tag_arg_add(& tag_args, (unsigned char *)(tag_arg), (unsigned char *)(tag_val));
#line 763
                      state = (enum __anonenum_html_state_22 )4;
#line 764
                      tag_arg_length = 0;
#line 765
                      next_state = (enum __anonenum_html_state_22 )7;
                    } else {
#line 767
                      html_output_c(file_buff_o1, file_buff_o2, (*ptr));
#line 768
                      if (tag_val_length < 1024) {
#line 769
                        tmp___47 = __ctype_b_loc();
#line 769
                        if ((int const   )(*((*tmp___47) + (int )(*ptr))) & 8192) {
#line 770
                          tmp___45 = tag_val_length;
#line 770
                          tag_val_length ++;
#line 770
                          tag_val[tmp___45] = (char )' ';
                        } else {
#line 772
                          tmp___46 = tag_val_length;
#line 772
                          tag_val_length ++;
#line 772
                          tag_val[tmp___46] = (char )'>';
                        }
                      }
#line 775
                      state = (enum __anonenum_html_state_22 )4;
#line 776
                      escape = 0;
#line 777
                      quoted = (enum __anonenum_quoted_state_23 )2;
#line 778
                      next_state = (enum __anonenum_html_state_22 )8;
#line 779
                      ptr ++;
                    }
                  } else {
#line 782
                    if (sizeof((*ptr)) > 1U) {
#line 782
                      tmp___50 = __builtin_constant_p((int )(*ptr));
#line 782
                      if (tmp___50) {
#line 782
                        __c___6 = (int )(*ptr);
#line 782
                        if (__c___6 < -128) {
#line 782
                          __res___6 = __c___6;
                        } else {
#line 782
                          if (__c___6 > 255) {
#line 782
                            __res___6 = __c___6;
                          } else {
#line 782
                            tmp___49 = __ctype_tolower_loc();
#line 782
                            __res___6 = (*((*tmp___49) + __c___6));
                          }
                        }
                      } else {
#line 782
                        __res___6 = tolower__extinline((int )(*ptr));
                      }
                    } else {
#line 782
                      tmp___51 = __ctype_tolower_loc();
#line 782
                      __res___6 = (*((*tmp___51) + (int )(*ptr)));
                    }
#line 782
                    html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___6);
#line 783
                    if (tag_val_length < 1024) {
#line 784
                      tmp___52 = tag_val_length;
#line 784
                      tag_val_length ++;
#line 784
                      tag_val[tmp___52] = (char )(*ptr);
                    }
#line 786
                    ptr ++;
                  }
                }
              }
            }
          }
        }
      }
#line 789
      if ((int )(*ptr) == 92) {
#line 790
        escape = 1;
      } else {
#line 792
        escape = 0;
      }
#line 794
      break;
      case 2: ;
#line 796
      if (sizeof((*ptr)) > 1U) {
#line 796
        tmp___352 = __builtin_constant_p((int )(*ptr));
#line 796
        if (tmp___352) {
#line 796
          __c___7 = (int )(*ptr);
#line 796
          if (__c___7 < -128) {
#line 796
            __res___7 = __c___7;
          } else {
#line 796
            if (__c___7 > 255) {
#line 796
              __res___7 = __c___7;
            } else {
#line 796
              tmp___351 = __ctype_tolower_loc();
#line 796
              __res___7 = (*((*tmp___351) + __c___7));
            }
          }
        } else {
#line 796
          __res___7 = tolower__extinline((int )(*ptr));
        }
      } else {
#line 796
        tmp___353 = __ctype_tolower_loc();
#line 796
        __res___7 = (*((*tmp___353) + (int )(*ptr)));
      }
#line 796
      html_output_c(file_buff_o1, (file_buff_t *)((void *)0), (unsigned char )__res___7);
#line 797
      if (in_script) {
#line 798
        if (sizeof((*ptr)) > 1U) {
#line 798
          tmp___356 = __builtin_constant_p((int )(*ptr));
#line 798
          if (tmp___356) {
#line 798
            __c___8 = (int )(*ptr);
#line 798
            if (__c___8 < -128) {
#line 798
              __res___8 = __c___8;
            } else {
#line 798
              if (__c___8 > 255) {
#line 798
                __res___8 = __c___8;
              } else {
#line 798
                tmp___355 = __ctype_tolower_loc();
#line 798
                __res___8 = (*((*tmp___355) + __c___8));
              }
            }
          } else {
#line 798
            __res___8 = tolower__extinline((int )(*ptr));
          }
        } else {
#line 798
          tmp___357 = __ctype_tolower_loc();
#line 798
          __res___8 = (*((*tmp___357) + (int )(*ptr)));
        }
#line 798
        html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___8);
      }
#line 800
      if ((int )(*ptr) == 62) {
#line 801
        state = (enum __anonenum_html_state_22 )4;
#line 802
        next_state = (enum __anonenum_html_state_22 )1;
      }
#line 804
      ptr ++;
#line 805
      break;
      case 10: 
#line 809
      state = (enum __anonenum_html_state_22 )4;
#line 810
      next_state = (enum __anonenum_html_state_22 )1;
#line 811
      if ((int )tag[0] == 47) {
#line 813
        state = (enum __anonenum_html_state_22 )4;
#line 814
        next_state = (enum __anonenum_html_state_22 )1;
#line 815
        tmp___424 = __builtin_constant_p((int )(tag));
#line 815
        if (tmp___424) {
#line 815
          tmp___425 = __builtin_constant_p((int )"/script");
#line 815
          if (tmp___425) {
#line 815
            __s1_len___3 = strlen((char const   *)(tag));
#line 815
            __s2_len___3 = strlen("/script");
#line 815
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                   1U)) {
              goto _L___106;
            } else {
#line 815
              if (__s1_len___3 >= 4U) {
                _L___106: 
#line 815
                if (! ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                       1U)) {
#line 815
                  tmp___426 = 1;
                } else {
#line 815
                  if (__s2_len___3 >= 4U) {
#line 815
                    tmp___426 = 1;
                  } else {
#line 815
                    tmp___426 = 0;
                  }
                }
              } else {
#line 815
                tmp___426 = 0;
              }
            }
#line 815
            if (tmp___426) {
#line 815
              tmp___393 = __builtin_strcmp(tag, "/script");
            } else {
              goto _L___108;
            }
          } else {
            goto _L___108;
          }
        } else {
          _L___108: 
#line 815
          tmp___423 = __builtin_constant_p((int )(tag));
#line 815
          if (tmp___423) {
#line 815
            if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                1U) {
#line 815
              __s1_len___3 = strlen((char const   *)(tag));
#line 815
              if (__s1_len___3 < 4U) {
#line 815
                tmp___412 = __builtin_constant_p((int )"/script");
#line 815
                if (tmp___412) {
#line 815
                  if ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                      1U) {
#line 815
                    tmp___393 = __builtin_strcmp(tag, "/script");
                  } else {
                    goto _L___101;
                  }
                } else {
                  _L___101: 
#line 815
                  __s2___38 = (unsigned char const   *)"/script";
#line 815
                  __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                           0)) - (int const   )(*(__s2___38 +
                                                                                  0)));
#line 815
                  if (__s1_len___3 > 0U) {
#line 815
                    if (__result___114 == 0) {
#line 815
                      __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                               1)) - (int const   )(*(__s2___38 +
                                                                                      1)));
#line 815
                      if (__s1_len___3 > 1U) {
#line 815
                        if (__result___114 == 0) {
#line 815
                          __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   2)) - (int const   )(*(__s2___38 +
                                                                                          2)));
#line 815
                          if (__s1_len___3 > 2U) {
#line 815
                            if (__result___114 == 0) {
#line 815
                              __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       3)) - (int const   )(*(__s2___38 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 815
                  tmp___393 = __result___114;
                }
              } else {
                goto _L___105;
              }
            } else {
              goto _L___105;
            }
          } else {
            _L___105: 
#line 815
            tmp___422 = __builtin_constant_p((int )"/script");
#line 815
            if (tmp___422) {
#line 815
              if ((unsigned int )((void const   *)("/script" + 1)) - (unsigned int )((void const   *)"/script") ==
                  1U) {
#line 815
                __s2_len___3 = strlen("/script");
#line 815
                if (__s2_len___3 < 4U) {
#line 815
                  tmp___421 = __builtin_constant_p((int )(tag));
#line 815
                  if (tmp___421) {
#line 815
                    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                        1U) {
#line 815
                      tmp___393 = __builtin_strcmp(tag, "/script");
                    } else {
                      goto _L___103;
                    }
                  } else {
                    _L___103: 
#line 815
                    __s1___78 = (unsigned char const   *)((char const   *)(tag));
#line 815
                    __result___118 = (int )((int const   )(*(__s1___78 + 0)) - (int const   )(*((unsigned char const   *)"/script" +
                                                                                                0)));
#line 815
                    if (__s2_len___3 > 0U) {
#line 815
                      if (__result___118 == 0) {
#line 815
                        __result___118 = (int )((int const   )(*(__s1___78 + 1)) -
                                                (int const   )(*((unsigned char const   *)"/script" +
                                                                 1)));
#line 815
                        if (__s2_len___3 > 1U) {
#line 815
                          if (__result___118 == 0) {
#line 815
                            __result___118 = (int )((int const   )(*(__s1___78 + 2)) -
                                                    (int const   )(*((unsigned char const   *)"/script" +
                                                                     2)));
#line 815
                            if (__s2_len___3 > 2U) {
#line 815
                              if (__result___118 == 0) {
#line 815
                                __result___118 = (int )((int const   )(*(__s1___78 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"/script" +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 815
                    tmp___393 = __result___118;
                  }
                } else {
#line 815
                  tmp___393 = __builtin_strcmp(tag, "/script");
                }
              } else {
#line 815
                tmp___393 = __builtin_strcmp(tag, "/script");
              }
            } else {
#line 815
              tmp___393 = __builtin_strcmp(tag, "/script");
            }
          }
        }
#line 815
        if (tmp___393 == 0) {
#line 816
          in_script = 0;
#line 817
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )'\n');
        }
      } else {
#line 819
        tmp___706 = __builtin_constant_p((int )(tag));
#line 819
        if (tmp___706) {
#line 819
          tmp___707 = __builtin_constant_p((int )"script");
#line 819
          if (tmp___707) {
#line 819
            __s1_len___7 = strlen((char const   *)(tag));
#line 819
            __s2_len___7 = strlen("script");
#line 819
            if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                   1U)) {
              goto _L___187;
            } else {
#line 819
              if (__s1_len___7 >= 4U) {
                _L___187: 
#line 819
                if (! ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                       1U)) {
#line 819
                  tmp___708 = 1;
                } else {
#line 819
                  if (__s2_len___7 >= 4U) {
#line 819
                    tmp___708 = 1;
                  } else {
#line 819
                    tmp___708 = 0;
                  }
                }
              } else {
#line 819
                tmp___708 = 0;
              }
            }
#line 819
            if (tmp___708) {
#line 819
              tmp___675 = __builtin_strcmp(tag, "script");
            } else {
              goto _L___189;
            }
          } else {
            goto _L___189;
          }
        } else {
          _L___189: 
#line 819
          tmp___705 = __builtin_constant_p((int )(tag));
#line 819
          if (tmp___705) {
#line 819
            if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                1U) {
#line 819
              __s1_len___7 = strlen((char const   *)(tag));
#line 819
              if (__s1_len___7 < 4U) {
#line 819
                tmp___694 = __builtin_constant_p((int )"script");
#line 819
                if (tmp___694) {
#line 819
                  if ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                      1U) {
#line 819
                    tmp___675 = __builtin_strcmp(tag, "script");
                  } else {
                    goto _L___182;
                  }
                } else {
                  _L___182: 
#line 819
                  __s2___70 = (unsigned char const   *)"script";
#line 819
                  __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                           0)) - (int const   )(*(__s2___70 +
                                                                                  0)));
#line 819
                  if (__s1_len___7 > 0U) {
#line 819
                    if (__result___210 == 0) {
#line 819
                      __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                               1)) - (int const   )(*(__s2___70 +
                                                                                      1)));
#line 819
                      if (__s1_len___7 > 1U) {
#line 819
                        if (__result___210 == 0) {
#line 819
                          __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   2)) - (int const   )(*(__s2___70 +
                                                                                          2)));
#line 819
                          if (__s1_len___7 > 2U) {
#line 819
                            if (__result___210 == 0) {
#line 819
                              __result___210 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       3)) - (int const   )(*(__s2___70 +
                                                                                              3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 819
                  tmp___675 = __result___210;
                }
              } else {
                goto _L___186;
              }
            } else {
              goto _L___186;
            }
          } else {
            _L___186: 
#line 819
            tmp___704 = __builtin_constant_p((int )"script");
#line 819
            if (tmp___704) {
#line 819
              if ((unsigned int )((void const   *)("script" + 1)) - (unsigned int )((void const   *)"script") ==
                  1U) {
#line 819
                __s2_len___7 = strlen("script");
#line 819
                if (__s2_len___7 < 4U) {
#line 819
                  tmp___703 = __builtin_constant_p((int )(tag));
#line 819
                  if (tmp___703) {
#line 819
                    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                        1U) {
#line 819
                      tmp___675 = __builtin_strcmp(tag, "script");
                    } else {
                      goto _L___184;
                    }
                  } else {
                    _L___184: 
#line 819
                    __s1___142 = (unsigned char const   *)((char const   *)(tag));
#line 819
                    __result___214 = (int )((int const   )(*(__s1___142 + 0)) - (int const   )(*((unsigned char const   *)"script" +
                                                                                                 0)));
#line 819
                    if (__s2_len___7 > 0U) {
#line 819
                      if (__result___214 == 0) {
#line 819
                        __result___214 = (int )((int const   )(*(__s1___142 + 1)) -
                                                (int const   )(*((unsigned char const   *)"script" +
                                                                 1)));
#line 819
                        if (__s2_len___7 > 1U) {
#line 819
                          if (__result___214 == 0) {
#line 819
                            __result___214 = (int )((int const   )(*(__s1___142 +
                                                                     2)) - (int const   )(*((unsigned char const   *)"script" +
                                                                                            2)));
#line 819
                            if (__s2_len___7 > 2U) {
#line 819
                              if (__result___214 == 0) {
#line 819
                                __result___214 = (int )((int const   )(*(__s1___142 +
                                                                         3)) - (int const   )(*((unsigned char const   *)"script" +
                                                                                                3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 819
                    tmp___675 = __result___214;
                  }
                } else {
#line 819
                  tmp___675 = __builtin_strcmp(tag, "script");
                }
              } else {
#line 819
                tmp___675 = __builtin_strcmp(tag, "script");
              }
            } else {
#line 819
              tmp___675 = __builtin_strcmp(tag, "script");
            }
          }
        }
#line 819
        if (tmp___675 == 0) {
#line 820
          arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"language");
#line 821
          if (arg_value) {
#line 821
            tmp___428 = strcasecmp((char const   *)arg_value, "jscript.encode");
#line 821
            if (tmp___428 == 0) {
#line 822
              html_tag_arg_set(& tag_args, (char *)"language", (char *)"javascript");
#line 823
              state = (enum __anonenum_html_state_22 )4;
#line 824
              next_state = (enum __anonenum_html_state_22 )13;
            } else {
              goto _L___109;
            }
          } else {
            _L___109: 
#line 825
            if (arg_value) {
#line 825
              tmp___427 = strcasecmp((char const   *)arg_value, "vbscript.encode");
#line 825
              if (tmp___427 == 0) {
#line 826
                html_tag_arg_set(& tag_args, (char *)"language", (char *)"vbscript");
#line 827
                state = (enum __anonenum_html_state_22 )4;
#line 828
                next_state = (enum __anonenum_html_state_22 )13;
              } else {
#line 830
                in_script = 1;
              }
            } else {
#line 830
              in_script = 1;
            }
          }
#line 832
          html_output_tag(file_buff_script, tag, & tag_args);
        } else {
#line 833
          if (hrefs) {
#line 834
            tmp___637 = __builtin_constant_p((int )(tag));
#line 834
            if (tmp___637) {
#line 834
              tmp___638 = __builtin_constant_p((int )"a");
#line 834
              if (tmp___638) {
#line 834
                __s1_len___6 = strlen((char const   *)(tag));
#line 834
                __s2_len___6 = strlen("a");
#line 834
                if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                       1U)) {
                  goto _L___167;
                } else {
#line 834
                  if (__s1_len___6 >= 4U) {
                    _L___167: 
#line 834
                    if (! ((unsigned int )((void const   *)("a" + 1)) - (unsigned int )((void const   *)"a") ==
                           1U)) {
#line 834
                      tmp___639 = 1;
                    } else {
#line 834
                      if (__s2_len___6 >= 4U) {
#line 834
                        tmp___639 = 1;
                      } else {
#line 834
                        tmp___639 = 0;
                      }
                    }
                  } else {
#line 834
                    tmp___639 = 0;
                  }
                }
#line 834
                if (tmp___639) {
#line 834
                  tmp___606 = __builtin_strcmp(tag, "a");
                } else {
                  goto _L___169;
                }
              } else {
                goto _L___169;
              }
            } else {
              _L___169: 
#line 834
              tmp___636 = __builtin_constant_p((int )(tag));
#line 834
              if (tmp___636) {
#line 834
                if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                    1U) {
#line 834
                  __s1_len___6 = strlen((char const   *)(tag));
#line 834
                  if (__s1_len___6 < 4U) {
#line 834
                    tmp___625 = __builtin_constant_p((int )"a");
#line 834
                    if (tmp___625) {
#line 834
                      if ((unsigned int )((void const   *)("a" + 1)) - (unsigned int )((void const   *)"a") ==
                          1U) {
#line 834
                        tmp___606 = __builtin_strcmp(tag, "a");
                      } else {
                        goto _L___162;
                      }
                    } else {
                      _L___162: 
#line 834
                      __s2___62 = (unsigned char const   *)"a";
#line 834
                      __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                               0)) - (int const   )(*(__s2___62 +
                                                                                      0)));
#line 834
                      if (__s1_len___6 > 0U) {
#line 834
                        if (__result___186 == 0) {
#line 834
                          __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   1)) - (int const   )(*(__s2___62 +
                                                                                          1)));
#line 834
                          if (__s1_len___6 > 1U) {
#line 834
                            if (__result___186 == 0) {
#line 834
                              __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       2)) - (int const   )(*(__s2___62 +
                                                                                              2)));
#line 834
                              if (__s1_len___6 > 2U) {
#line 834
                                if (__result___186 == 0) {
#line 834
                                  __result___186 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                           3)) - (int const   )(*(__s2___62 +
                                                                                                  3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 834
                      tmp___606 = __result___186;
                    }
                  } else {
                    goto _L___166;
                  }
                } else {
                  goto _L___166;
                }
              } else {
                _L___166: 
#line 834
                tmp___635 = __builtin_constant_p((int )"a");
#line 834
                if (tmp___635) {
#line 834
                  if ((unsigned int )((void const   *)("a" + 1)) - (unsigned int )((void const   *)"a") ==
                      1U) {
#line 834
                    __s2_len___6 = strlen("a");
#line 834
                    if (__s2_len___6 < 4U) {
#line 834
                      tmp___634 = __builtin_constant_p((int )(tag));
#line 834
                      if (tmp___634) {
#line 834
                        if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                            1U) {
#line 834
                          tmp___606 = __builtin_strcmp(tag, "a");
                        } else {
                          goto _L___164;
                        }
                      } else {
                        _L___164: 
#line 834
                        __s1___126 = (unsigned char const   *)((char const   *)(tag));
#line 834
                        __result___190 = (int )((int const   )(*(__s1___126 + 0)) -
                                                (int const   )(*((unsigned char const   *)"a" +
                                                                 0)));
#line 834
                        if (__s2_len___6 > 0U) {
#line 834
                          if (__result___190 == 0) {
#line 834
                            __result___190 = (int )((int const   )(*(__s1___126 +
                                                                     1)) - (int const   )(*((unsigned char const   *)"a" +
                                                                                            1)));
#line 834
                            if (__s2_len___6 > 1U) {
#line 834
                              if (__result___190 == 0) {
#line 834
                                __result___190 = (int )((int const   )(*(__s1___126 +
                                                                         2)) - (int const   )(*((unsigned char const   *)"a" +
                                                                                                2)));
#line 834
                                if (__s2_len___6 > 2U) {
#line 834
                                  if (__result___190 == 0) {
#line 834
                                    __result___190 = (int )((int const   )(*(__s1___126 +
                                                                             3)) -
                                                            (int const   )(*((unsigned char const   *)"a" +
                                                                             3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 834
                        tmp___606 = __result___190;
                      }
                    } else {
#line 834
                      tmp___606 = __builtin_strcmp(tag, "a");
                    }
                  } else {
#line 834
                    tmp___606 = __builtin_strcmp(tag, "a");
                  }
                } else {
#line 834
                  tmp___606 = __builtin_strcmp(tag, "a");
                }
              }
            }
#line 834
            if (tmp___606 == 0) {
#line 835
              arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"href");
#line 836
              if (arg_value) {
#line 836
                tmp___429 = strlen((char const   *)arg_value);
#line 836
                if (tmp___429 > 0U) {
#line 837
                  html_tag_arg_add(hrefs, (unsigned char *)"href", arg_value);
                }
              }
            } else {
#line 839
              tmp___568 = __builtin_constant_p((int )(tag));
#line 839
              if (tmp___568) {
#line 839
                tmp___569 = __builtin_constant_p((int )"img");
#line 839
                if (tmp___569) {
#line 839
                  __s1_len___5 = strlen((char const   *)(tag));
#line 839
                  __s2_len___5 = strlen("img");
#line 839
                  if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                         1U)) {
                    goto _L___147;
                  } else {
#line 839
                    if (__s1_len___5 >= 4U) {
                      _L___147: 
#line 839
                      if (! ((unsigned int )((void const   *)("img" + 1)) - (unsigned int )((void const   *)"img") ==
                             1U)) {
#line 839
                        tmp___570 = 1;
                      } else {
#line 839
                        if (__s2_len___5 >= 4U) {
#line 839
                          tmp___570 = 1;
                        } else {
#line 839
                          tmp___570 = 0;
                        }
                      }
                    } else {
#line 839
                      tmp___570 = 0;
                    }
                  }
#line 839
                  if (tmp___570) {
#line 839
                    tmp___537 = __builtin_strcmp(tag, "img");
                  } else {
                    goto _L___149;
                  }
                } else {
                  goto _L___149;
                }
              } else {
                _L___149: 
#line 839
                tmp___567 = __builtin_constant_p((int )(tag));
#line 839
                if (tmp___567) {
#line 839
                  if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                      1U) {
#line 839
                    __s1_len___5 = strlen((char const   *)(tag));
#line 839
                    if (__s1_len___5 < 4U) {
#line 839
                      tmp___556 = __builtin_constant_p((int )"img");
#line 839
                      if (tmp___556) {
#line 839
                        if ((unsigned int )((void const   *)("img" + 1)) - (unsigned int )((void const   *)"img") ==
                            1U) {
#line 839
                          tmp___537 = __builtin_strcmp(tag, "img");
                        } else {
                          goto _L___142;
                        }
                      } else {
                        _L___142: 
#line 839
                        __s2___54 = (unsigned char const   *)"img";
#line 839
                        __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                 0)) - (int const   )(*(__s2___54 +
                                                                                        0)));
#line 839
                        if (__s1_len___5 > 0U) {
#line 839
                          if (__result___162 == 0) {
#line 839
                            __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                     1)) - (int const   )(*(__s2___54 +
                                                                                            1)));
#line 839
                            if (__s1_len___5 > 1U) {
#line 839
                              if (__result___162 == 0) {
#line 839
                                __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                         2)) - (int const   )(*(__s2___54 +
                                                                                                2)));
#line 839
                                if (__s1_len___5 > 2U) {
#line 839
                                  if (__result___162 == 0) {
#line 839
                                    __result___162 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                             3)) -
                                                            (int const   )(*(__s2___54 +
                                                                             3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 839
                        tmp___537 = __result___162;
                      }
                    } else {
                      goto _L___146;
                    }
                  } else {
                    goto _L___146;
                  }
                } else {
                  _L___146: 
#line 839
                  tmp___566 = __builtin_constant_p((int )"img");
#line 839
                  if (tmp___566) {
#line 839
                    if ((unsigned int )((void const   *)("img" + 1)) - (unsigned int )((void const   *)"img") ==
                        1U) {
#line 839
                      __s2_len___5 = strlen("img");
#line 839
                      if (__s2_len___5 < 4U) {
#line 839
                        tmp___565 = __builtin_constant_p((int )(tag));
#line 839
                        if (tmp___565) {
#line 839
                          if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                              1U) {
#line 839
                            tmp___537 = __builtin_strcmp(tag, "img");
                          } else {
                            goto _L___144;
                          }
                        } else {
                          _L___144: 
#line 839
                          __s1___110 = (unsigned char const   *)((char const   *)(tag));
#line 839
                          __result___166 = (int )((int const   )(*(__s1___110 + 0)) -
                                                  (int const   )(*((unsigned char const   *)"img" +
                                                                   0)));
#line 839
                          if (__s2_len___5 > 0U) {
#line 839
                            if (__result___166 == 0) {
#line 839
                              __result___166 = (int )((int const   )(*(__s1___110 +
                                                                       1)) - (int const   )(*((unsigned char const   *)"img" +
                                                                                              1)));
#line 839
                              if (__s2_len___5 > 1U) {
#line 839
                                if (__result___166 == 0) {
#line 839
                                  __result___166 = (int )((int const   )(*(__s1___110 +
                                                                           2)) - (int const   )(*((unsigned char const   *)"img" +
                                                                                                  2)));
#line 839
                                  if (__s2_len___5 > 2U) {
#line 839
                                    if (__result___166 == 0) {
#line 839
                                      __result___166 = (int )((int const   )(*(__s1___110 +
                                                                               3)) -
                                                              (int const   )(*((unsigned char const   *)"img" +
                                                                               3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 839
                          tmp___537 = __result___166;
                        }
                      } else {
#line 839
                        tmp___537 = __builtin_strcmp(tag, "img");
                      }
                    } else {
#line 839
                      tmp___537 = __builtin_strcmp(tag, "img");
                    }
                  } else {
#line 839
                    tmp___537 = __builtin_strcmp(tag, "img");
                  }
                }
              }
#line 839
              if (tmp___537 == 0) {
#line 840
                arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"src");
#line 841
                if (arg_value) {
#line 841
                  tmp___430 = strlen((char const   *)arg_value);
#line 841
                  if (tmp___430 > 0U) {
#line 842
                    html_tag_arg_add(hrefs, (unsigned char *)"src", arg_value);
                  }
                }
#line 844
                arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"dynsrc");
#line 845
                if (arg_value) {
#line 845
                  tmp___431 = strlen((char const   *)arg_value);
#line 845
                  if (tmp___431 > 0U) {
#line 846
                    html_tag_arg_add(hrefs, (unsigned char *)"dynsrc", arg_value);
                  }
                }
              } else {
#line 848
                tmp___499 = __builtin_constant_p((int )(tag));
#line 848
                if (tmp___499) {
#line 848
                  tmp___500 = __builtin_constant_p((int )"iframe");
#line 848
                  if (tmp___500) {
#line 848
                    __s1_len___4 = strlen((char const   *)(tag));
#line 848
                    __s2_len___4 = strlen("iframe");
#line 848
                    if (! ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                           1U)) {
                      goto _L___127;
                    } else {
#line 848
                      if (__s1_len___4 >= 4U) {
                        _L___127: 
#line 848
                        if (! ((unsigned int )((void const   *)("iframe" + 1)) - (unsigned int )((void const   *)"iframe") ==
                               1U)) {
#line 848
                          tmp___501 = 1;
                        } else {
#line 848
                          if (__s2_len___4 >= 4U) {
#line 848
                            tmp___501 = 1;
                          } else {
#line 848
                            tmp___501 = 0;
                          }
                        }
                      } else {
#line 848
                        tmp___501 = 0;
                      }
                    }
#line 848
                    if (tmp___501) {
#line 848
                      tmp___468 = __builtin_strcmp(tag, "iframe");
                    } else {
                      goto _L___129;
                    }
                  } else {
                    goto _L___129;
                  }
                } else {
                  _L___129: 
#line 848
                  tmp___498 = __builtin_constant_p((int )(tag));
#line 848
                  if (tmp___498) {
#line 848
                    if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                        1U) {
#line 848
                      __s1_len___4 = strlen((char const   *)(tag));
#line 848
                      if (__s1_len___4 < 4U) {
#line 848
                        tmp___487 = __builtin_constant_p((int )"iframe");
#line 848
                        if (tmp___487) {
#line 848
                          if ((unsigned int )((void const   *)("iframe" + 1)) - (unsigned int )((void const   *)"iframe") ==
                              1U) {
#line 848
                            tmp___468 = __builtin_strcmp(tag, "iframe");
                          } else {
                            goto _L___122;
                          }
                        } else {
                          _L___122: 
#line 848
                          __s2___46 = (unsigned char const   *)"iframe";
#line 848
                          __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                   0)) - (int const   )(*(__s2___46 +
                                                                                          0)));
#line 848
                          if (__s1_len___4 > 0U) {
#line 848
                            if (__result___138 == 0) {
#line 848
                              __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                       1)) - (int const   )(*(__s2___46 +
                                                                                              1)));
#line 848
                              if (__s1_len___4 > 1U) {
#line 848
                                if (__result___138 == 0) {
#line 848
                                  __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                           2)) - (int const   )(*(__s2___46 +
                                                                                                  2)));
#line 848
                                  if (__s1_len___4 > 2U) {
#line 848
                                    if (__result___138 == 0) {
#line 848
                                      __result___138 = (int )((int const   )(*((unsigned char const   *)((char const   *)(tag)) +
                                                                               3)) -
                                                              (int const   )(*(__s2___46 +
                                                                               3)));
                                    }
                                  }
                                }
                              }
                            }
                          }
#line 848
                          tmp___468 = __result___138;
                        }
                      } else {
                        goto _L___126;
                      }
                    } else {
                      goto _L___126;
                    }
                  } else {
                    _L___126: 
#line 848
                    tmp___497 = __builtin_constant_p((int )"iframe");
#line 848
                    if (tmp___497) {
#line 848
                      if ((unsigned int )((void const   *)("iframe" + 1)) - (unsigned int )((void const   *)"iframe") ==
                          1U) {
#line 848
                        __s2_len___4 = strlen("iframe");
#line 848
                        if (__s2_len___4 < 4U) {
#line 848
                          tmp___496 = __builtin_constant_p((int )(tag));
#line 848
                          if (tmp___496) {
#line 848
                            if ((unsigned int )((void const   *)(tag + 1)) - (unsigned int )((void const   *)(tag)) ==
                                1U) {
#line 848
                              tmp___468 = __builtin_strcmp(tag, "iframe");
                            } else {
                              goto _L___124;
                            }
                          } else {
                            _L___124: 
#line 848
                            __s1___94 = (unsigned char const   *)((char const   *)(tag));
#line 848
                            __result___142 = (int )((int const   )(*(__s1___94 + 0)) -
                                                    (int const   )(*((unsigned char const   *)"iframe" +
                                                                     0)));
#line 848
                            if (__s2_len___4 > 0U) {
#line 848
                              if (__result___142 == 0) {
#line 848
                                __result___142 = (int )((int const   )(*(__s1___94 +
                                                                         1)) - (int const   )(*((unsigned char const   *)"iframe" +
                                                                                                1)));
#line 848
                                if (__s2_len___4 > 1U) {
#line 848
                                  if (__result___142 == 0) {
#line 848
                                    __result___142 = (int )((int const   )(*(__s1___94 +
                                                                             2)) -
                                                            (int const   )(*((unsigned char const   *)"iframe" +
                                                                             2)));
#line 848
                                    if (__s2_len___4 > 2U) {
#line 848
                                      if (__result___142 == 0) {
#line 848
                                        __result___142 = (int )((int const   )(*(__s1___94 +
                                                                                 3)) -
                                                                (int const   )(*((unsigned char const   *)"iframe" +
                                                                                 3)));
                                      }
                                    }
                                  }
                                }
                              }
                            }
#line 848
                            tmp___468 = __result___142;
                          }
                        } else {
#line 848
                          tmp___468 = __builtin_strcmp(tag, "iframe");
                        }
                      } else {
#line 848
                        tmp___468 = __builtin_strcmp(tag, "iframe");
                      }
                    } else {
#line 848
                      tmp___468 = __builtin_strcmp(tag, "iframe");
                    }
                  }
                }
#line 848
                if (tmp___468 == 0) {
#line 849
                  arg_value = (unsigned char *)html_tag_arg_value(& tag_args, (char *)"src");
#line 850
                  if (arg_value) {
#line 850
                    tmp___432 = strlen((char const   *)arg_value);
#line 850
                    if (tmp___432 > 0U) {
#line 851
                      html_tag_arg_add(hrefs, (unsigned char *)"iframe", arg_value);
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 855
      html_tag_arg_free(& tag_args);
#line 856
      break;
      case 3: ;
#line 858
      if ((int )(*ptr) == 35) {
#line 859
        value = 0;
#line 860
        hex___0 = 0;
#line 861
        state = (enum __anonenum_html_state_22 )11;
#line 862
        ptr ++;
      } else {
#line 864
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )'&');
#line 865
        state = next_state;
#line 866
        next_state = (enum __anonenum_html_state_22 )0;
      }
#line 868
      break;
      case 11: ;
#line 870
      if (value == 0) {
#line 870
        if ((int )(*ptr) == 120) {
#line 871
          hex___0 = 1;
#line 872
          ptr ++;
        } else {
#line 870
          if ((int )(*ptr) == 88) {
#line 871
            hex___0 = 1;
#line 872
            ptr ++;
          } else {
            goto _L___191;
          }
        }
      } else {
        _L___191: 
#line 873
        if ((int )(*ptr) == 59) {
#line 874
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
#line 875
          state = next_state;
#line 876
          next_state = (enum __anonenum_html_state_22 )0;
#line 877
          ptr ++;
        } else {
#line 878
          tmp___714 = __ctype_b_loc();
#line 878
          if ((int const   )(*((*tmp___714) + (int )(*ptr))) & 2048) {
            goto _L___190;
          } else {
#line 878
            if (hex___0) {
#line 878
              tmp___715 = __ctype_b_loc();
#line 878
              if ((int const   )(*((*tmp___715) + (int )(*ptr))) & 4096) {
                _L___190: 
#line 879
                if (hex___0) {
#line 880
                  value *= 16;
                } else {
#line 882
                  value *= 10;
                }
#line 884
                tmp___713 = __ctype_b_loc();
#line 884
                if ((int const   )(*((*tmp___713) + (int )(*ptr))) & 2048) {
#line 885
                  value += (int )(*ptr) - 48;
                } else {
#line 887
                  if (sizeof((*ptr)) > 1U) {
#line 887
                    tmp___711 = __builtin_constant_p((int )(*ptr));
#line 887
                    if (tmp___711) {
#line 887
                      __c___9 = (int )(*ptr);
#line 887
                      if (__c___9 < -128) {
#line 887
                        __res___9 = __c___9;
                      } else {
#line 887
                        if (__c___9 > 255) {
#line 887
                          __res___9 = __c___9;
                        } else {
#line 887
                          tmp___710 = __ctype_tolower_loc();
#line 887
                          __res___9 = (*((*tmp___710) + __c___9));
                        }
                      }
                    } else {
#line 887
                      __res___9 = tolower__extinline((int )(*ptr));
                    }
                  } else {
#line 887
                    tmp___712 = __ctype_tolower_loc();
#line 887
                    __res___9 = (*((*tmp___712) + (int )(*ptr)));
                  }
#line 887
                  value += (__res___9 - 97) + 10;
                }
#line 889
                ptr ++;
              } else {
#line 891
                html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
#line 892
                state = next_state;
#line 893
                next_state = (enum __anonenum_html_state_22 )0;
              }
            } else {
#line 891
              html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
#line 892
              state = next_state;
#line 893
              next_state = (enum __anonenum_html_state_22 )0;
            }
          }
        }
      }
#line 895
      break;
      case 13: 
#line 898
      tmp___868 = __builtin_constant_p((int )ptr);
#line 898
      if (tmp___868) {
#line 898
        tmp___869 = strlen((char const   *)ptr);
#line 898
        if (tmp___869 < 4U) {
          goto _L___232;
        } else {
          goto _L___233;
        }
      } else {
        _L___233: 
#line 898
        tmp___870 = __builtin_constant_p((int )"#@~^");
#line 898
        if (tmp___870) {
#line 898
          tmp___871 = strlen("#@~^");
#line 898
          if (tmp___871 < 4U) {
            _L___232: 
#line 898
            tmp___865 = __builtin_constant_p((int )ptr);
#line 898
            if (tmp___865) {
#line 898
              tmp___866 = __builtin_constant_p((int )"#@~^");
#line 898
              if (tmp___866) {
#line 898
                __s1_len___9 = strlen((char const   *)ptr);
#line 898
                __s2_len___9 = strlen("#@~^");
#line 898
                if (! ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                       1U)) {
                  goto _L___229;
                } else {
#line 898
                  if (__s1_len___9 >= 4U) {
                    _L___229: 
#line 898
                    if (! ((unsigned int )((void const   *)("#@~^" + 1)) - (unsigned int )((void const   *)"#@~^") ==
                           1U)) {
#line 898
                      tmp___867 = 1;
                    } else {
#line 898
                      if (__s2_len___9 >= 4U) {
#line 898
                        tmp___867 = 1;
                      } else {
#line 898
                        tmp___867 = 0;
                      }
                    }
                  } else {
#line 898
                    tmp___867 = 0;
                  }
                }
#line 898
                if (tmp___867) {
#line 898
                  tmp___834 = __builtin_strcmp(ptr, "#@~^");
                } else {
                  goto _L___231;
                }
              } else {
                goto _L___231;
              }
            } else {
              _L___231: 
#line 898
              tmp___864 = __builtin_constant_p((int )ptr);
#line 898
              if (tmp___864) {
#line 898
                if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                    1U) {
#line 898
                  __s1_len___9 = strlen((char const   *)ptr);
#line 898
                  if (__s1_len___9 < 4U) {
#line 898
                    tmp___853 = __builtin_constant_p((int )"#@~^");
#line 898
                    if (tmp___853) {
#line 898
                      if ((unsigned int )((void const   *)("#@~^" + 1)) - (unsigned int )((void const   *)"#@~^") ==
                          1U) {
#line 898
                        tmp___834 = __builtin_strcmp(ptr, "#@~^");
                      } else {
                        goto _L___224;
                      }
                    } else {
                      _L___224: 
#line 898
                      __s2___86 = (unsigned char const   *)"#@~^";
#line 898
                      __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                               0)) - (int const   )(*(__s2___86 +
                                                                                      0)));
#line 898
                      if (__s1_len___9 > 0U) {
#line 898
                        if (__result___258 == 0) {
#line 898
                          __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                                   1)) - (int const   )(*(__s2___86 +
                                                                                          1)));
#line 898
                          if (__s1_len___9 > 1U) {
#line 898
                            if (__result___258 == 0) {
#line 898
                              __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                                       2)) - (int const   )(*(__s2___86 +
                                                                                              2)));
#line 898
                              if (__s1_len___9 > 2U) {
#line 898
                                if (__result___258 == 0) {
#line 898
                                  __result___258 = (int )((int const   )(*((unsigned char const   *)((char const   *)ptr) +
                                                                           3)) - (int const   )(*(__s2___86 +
                                                                                                  3)));
                                }
                              }
                            }
                          }
                        }
                      }
#line 898
                      tmp___834 = __result___258;
                    }
                  } else {
                    goto _L___228;
                  }
                } else {
                  goto _L___228;
                }
              } else {
                _L___228: 
#line 898
                tmp___863 = __builtin_constant_p((int )"#@~^");
#line 898
                if (tmp___863) {
#line 898
                  if ((unsigned int )((void const   *)("#@~^" + 1)) - (unsigned int )((void const   *)"#@~^") ==
                      1U) {
#line 898
                    __s2_len___9 = strlen("#@~^");
#line 898
                    if (__s2_len___9 < 4U) {
#line 898
                      tmp___862 = __builtin_constant_p((int )ptr);
#line 898
                      if (tmp___862) {
#line 898
                        if ((unsigned int )((void const   *)(ptr + 1)) - (unsigned int )((void const   *)ptr) ==
                            1U) {
#line 898
                          tmp___834 = __builtin_strcmp(ptr, "#@~^");
                        } else {
                          goto _L___226;
                        }
                      } else {
                        _L___226: 
#line 898
                        __s1___174 = (unsigned char const   *)((char const   *)ptr);
#line 898
                        __result___262 = (int )((int const   )(*(__s1___174 + 0)) -
                                                (int const   )(*((unsigned char const   *)"#@~^" +
                                                                 0)));
#line 898
                        if (__s2_len___9 > 0U) {
#line 898
                          if (__result___262 == 0) {
#line 898
                            __result___262 = (int )((int const   )(*(__s1___174 +
                                                                     1)) - (int const   )(*((unsigned char const   *)"#@~^" +
                                                                                            1)));
#line 898
                            if (__s2_len___9 > 1U) {
#line 898
                              if (__result___262 == 0) {
#line 898
                                __result___262 = (int )((int const   )(*(__s1___174 +
                                                                         2)) - (int const   )(*((unsigned char const   *)"#@~^" +
                                                                                                2)));
#line 898
                                if (__s2_len___9 > 2U) {
#line 898
                                  if (__result___262 == 0) {
#line 898
                                    __result___262 = (int )((int const   )(*(__s1___174 +
                                                                             3)) -
                                                            (int const   )(*((unsigned char const   *)"#@~^" +
                                                                             3)));
                                  }
                                }
                              }
                            }
                          }
                        }
#line 898
                        tmp___834 = __result___262;
                      }
                    } else {
#line 898
                      tmp___834 = __builtin_strcmp(ptr, "#@~^");
                    }
                  } else {
#line 898
                    tmp___834 = __builtin_strcmp(ptr, "#@~^");
                  }
                } else {
#line 898
                  tmp___834 = __builtin_strcmp(ptr, "#@~^");
                }
              }
            }
#line 898
            tmp___798 = tmp___834;
          } else {
#line 898
            tmp___798 = strncmp((char const   *)ptr, "#@~^", 4U);
          }
        } else {
#line 898
          tmp___798 = strncmp((char const   *)ptr, "#@~^", 4U);
        }
      }
#line 898
      if (tmp___798 == 0) {
#line 899
        ptr += 4;
#line 900
        state = (enum __anonenum_html_state_22 )14;
#line 901
        next_state = (enum __anonenum_html_state_22 )0;
      } else {
#line 903
        if (sizeof((*ptr)) > 1U) {
#line 903
          tmp___718 = __builtin_constant_p((int )(*ptr));
#line 903
          if (tmp___718) {
#line 903
            __c___10 = (int )(*ptr);
#line 903
            if (__c___10 < -128) {
#line 903
              __res___10 = __c___10;
            } else {
#line 903
              if (__c___10 > 255) {
#line 903
                __res___10 = __c___10;
              } else {
#line 903
                tmp___717 = __ctype_tolower_loc();
#line 903
                __res___10 = (*((*tmp___717) + __c___10));
              }
            }
          } else {
#line 903
            __res___10 = tolower__extinline((int )(*ptr));
          }
        } else {
#line 903
          tmp___719 = __ctype_tolower_loc();
#line 903
          __res___10 = (*((*tmp___719) + (int )(*ptr)));
        }
#line 903
        html_output_c(file_buff_o1, file_buff_o2, (unsigned char )__res___10);
#line 904
        if (sizeof((*ptr)) > 1U) {
#line 904
          tmp___722 = __builtin_constant_p((int )(*ptr));
#line 904
          if (tmp___722) {
#line 904
            __c___11 = (int )(*ptr);
#line 904
            if (__c___11 < -128) {
#line 904
              __res___11 = __c___11;
            } else {
#line 904
              if (__c___11 > 255) {
#line 904
                __res___11 = __c___11;
              } else {
#line 904
                tmp___721 = __ctype_tolower_loc();
#line 904
                __res___11 = (*((*tmp___721) + __c___11));
              }
            }
          } else {
#line 904
            __res___11 = tolower__extinline((int )(*ptr));
          }
        } else {
#line 904
          tmp___723 = __ctype_tolower_loc();
#line 904
          __res___11 = (*((*tmp___723) + (int )(*ptr)));
        }
#line 904
        html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___11);
#line 905
        ptr ++;
      }
#line 907
      break;
      case 14: 
#line 909
      tmp___872 = strlen((char const   *)ptr);
#line 909
      if (tmp___872 < 8U) {
#line 910
        state = (enum __anonenum_html_state_22 )1;
#line 911
        next_state = (enum __anonenum_html_state_22 )0;
#line 912
        break;
      }
#line 914
      length = (unsigned long )(base64_chars[(*(ptr + 0))] << 2);
#line 915
      length += (unsigned long )(base64_chars[(*(ptr + 1))] >> 4);
#line 916
      length += (unsigned long )((base64_chars[(*(ptr + 1))] & 15) << 12);
#line 917
      length += (unsigned long )((base64_chars[(*(ptr + 2))] >> 2) << 8);
#line 918
      length += (unsigned long )((base64_chars[(*(ptr + 2))] & 3) << 22);
#line 919
      length += (unsigned long )(base64_chars[(*(ptr + 3))] << 16);
#line 920
      length += (unsigned long )((base64_chars[(*(ptr + 4))] << 2) << 24);
#line 921
      length += (unsigned long )((base64_chars[(*(ptr + 5))] >> 4) << 24);
#line 922
      table_pos = 0;
#line 923
      state = (enum __anonenum_html_state_22 )15;
#line 924
      next_state = (enum __anonenum_html_state_22 )0;
#line 925
      ptr += 8;
#line 926
      break;
      case 15: ;
#line 928
      if (length == 0UL) {
#line 929
        html_output_str(file_buff_script, (unsigned char *)"</script>\n", 10);
#line 930
        length = 12UL;
#line 931
        state = (enum __anonenum_html_state_22 )12;
#line 932
        next_state = (enum __anonenum_html_state_22 )1;
#line 933
        break;
      }
#line 935
      if ((int )(*ptr) < 128) {
#line 936
        value = decrypt_tables[table_order[table_pos]][(*ptr)];
#line 937
        if (value == 255) {
#line 938
          ptr ++;
#line 939
          length --;
#line 940
          switch ((int )(*ptr)) {
          case 0: 
#line 943
          ptr --;
#line 944
          break;
          case 33: 
#line 946
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)60);
#line 947
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)60);
#line 948
          break;
          case 35: 
#line 950
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)13);
#line 951
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)13);
#line 952
          break;
          case 36: 
#line 954
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)64);
#line 955
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)64);
#line 956
          break;
          case 38: 
#line 958
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)10);
#line 959
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)10);
#line 960
          break;
          case 42: 
#line 962
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char)62);
#line 963
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char)62);
#line 964
          break;
          }
        } else {
#line 967
          html_output_c(file_buff_o1, file_buff_o2, (unsigned char )value);
#line 968
          if (sizeof(value) > 1U) {
#line 968
            tmp___875 = __builtin_constant_p(value);
#line 968
            if (tmp___875) {
#line 968
              __c___12 = value;
#line 968
              if (__c___12 < -128) {
#line 968
                __res___12 = __c___12;
              } else {
#line 968
                if (__c___12 > 255) {
#line 968
                  __res___12 = __c___12;
                } else {
#line 968
                  tmp___874 = __ctype_tolower_loc();
#line 968
                  __res___12 = (*((*tmp___874) + __c___12));
                }
              }
            } else {
#line 968
              __res___12 = tolower__extinline(value);
            }
          } else {
#line 968
            tmp___876 = __ctype_tolower_loc();
#line 968
            __res___12 = (*((*tmp___876) + value));
          }
#line 968
          html_output_c(file_buff_script, (file_buff_t *)((void *)0), (unsigned char )__res___12);
        }
      }
#line 971
      table_pos = (table_pos + 1) % 64;
#line 972
      ptr ++;
#line 973
      length --;
#line 974
      break;
      case 17: ;
#line 977
      if ((int )(*ptr) == 39) {
#line 978
        if (! escape) {
#line 978
          if ((int )quoted == 0) {
#line 980
            ptr ++;
#line 981
            state = (enum __anonenum_html_state_22 )4;
#line 982
            tag_arg_length = 0;
#line 983
            next_state = (enum __anonenum_html_state_22 )7;
          } else {
            goto _L___234;
          }
        } else {
          _L___234: 
#line 985
          if (tag_val_length < 1024) {
#line 986
            tmp___877 = tag_val_length;
#line 986
            tag_val_length ++;
#line 986
            tag_val[tmp___877] = (char )'\"';
          }
#line 988
          ptr ++;
        }
      } else {
#line 990
        if ((int )(*ptr) == 34) {
#line 991
          if (! escape) {
#line 991
            if ((int )quoted == 1) {
#line 993
              ptr ++;
#line 994
              state = (enum __anonenum_html_state_22 )4;
#line 995
              tag_arg_length = 0;
#line 996
              next_state = (enum __anonenum_html_state_22 )7;
            } else {
              goto _L___235;
            }
          } else {
            _L___235: 
#line 998
            if (tag_val_length < 1024) {
#line 999
              tmp___878 = tag_val_length;
#line 999
              tag_val_length ++;
#line 999
              tag_val[tmp___878] = (char )'\"';
            }
#line 1001
            ptr ++;
          }
        } else {
#line 1003
          tmp___887 = __ctype_b_loc();
#line 1003
          if ((int const   )(*((*tmp___887) + (int )(*ptr))) & 8192) {
            goto _L___236;
          } else {
#line 1003
            if ((int )(*ptr) == 62) {
              _L___236: 
#line 1004
              if ((int )quoted == 2) {
#line 1006
                state = (enum __anonenum_html_state_22 )4;
#line 1007
                tag_arg_length = 0;
#line 1008
                next_state = (enum __anonenum_html_state_22 )7;
              } else {
#line 1010
                if (tag_val_length < 1024) {
#line 1011
                  tmp___881 = __ctype_b_loc();
#line 1011
                  if ((int const   )(*((*tmp___881) + (int )(*ptr))) & 8192) {
#line 1012
                    tmp___879 = tag_val_length;
#line 1012
                    tag_val_length ++;
#line 1012
                    tag_val[tmp___879] = (char )' ';
                  } else {
#line 1014
                    tmp___880 = tag_val_length;
#line 1014
                    tag_val_length ++;
#line 1014
                    tag_val[tmp___880] = (char )'>';
                  }
                }
#line 1017
                state = (enum __anonenum_html_state_22 )4;
#line 1018
                escape = 0;
#line 1019
                quoted = (enum __anonenum_quoted_state_23 )2;
#line 1020
                next_state = (enum __anonenum_html_state_22 )17;
#line 1021
                ptr ++;
              }
            } else {
#line 1023
              if ((int )(*ptr) == 44) {
#line 1025
                tag_val[tag_val_length] = (char )'\000';
#line 1026
                state = (enum __anonenum_html_state_22 )18;
#line 1027
                escape = 0;
#line 1028
                next_state = (enum __anonenum_html_state_22 )0;
#line 1029
                ptr ++;
              } else {
#line 1032
                if (tag_val_length < 1024) {
#line 1033
                  tmp___882 = tag_val_length;
#line 1033
                  tag_val_length ++;
#line 1033
                  if (sizeof((*ptr)) > 1U) {
#line 1033
                    tmp___885 = __builtin_constant_p((int )(*ptr));
#line 1033
                    if (tmp___885) {
#line 1033
                      __c___13 = (int )(*ptr);
#line 1033
                      if (__c___13 < -128) {
#line 1033
                        __res___13 = __c___13;
                      } else {
#line 1033
                        if (__c___13 > 255) {
#line 1033
                          __res___13 = __c___13;
                        } else {
#line 1033
                          tmp___884 = __ctype_tolower_loc();
#line 1033
                          __res___13 = (*((*tmp___884) + __c___13));
                        }
                      }
                    } else {
#line 1033
                      __res___13 = tolower__extinline((int )(*ptr));
                    }
                  } else {
#line 1033
                    tmp___886 = __ctype_tolower_loc();
#line 1033
                    __res___13 = (*((*tmp___886) + (int )(*ptr)));
                  }
#line 1033
                  tag_val[tmp___882] = (char )__res___13;
                }
#line 1035
                ptr ++;
              }
            }
          }
        }
      }
#line 1037
      if ((int )(*ptr) == 92) {
#line 1038
        escape = 1;
      } else {
#line 1040
        escape = 0;
      }
#line 1042
      break;
      case 18: 
#line 1044
      file_tmp_o1 = (file_buff_t *)cli_malloc(sizeof(file_buff_t ));
#line 1045
      if (! file_tmp_o1) {
        goto abort;
      }
#line 1048
      snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/rfc2397",
               dirname);
#line 1049
      tmp_file = cli_gentemp((char const   *)(filename));
#line 1050
      cli_dbgmsg("RFC2397 data file: %s\n", tmp_file);
#line 1051
      file_tmp_o1->fd = open((char const   *)tmp_file, 577, 384);
#line 1052
      free((void *)tmp_file);
#line 1053
      if (! file_tmp_o1->fd) {
#line 1054
        cli_dbgmsg("open failed: %s\n", filename);
#line 1055
        free((void *)file_tmp_o1);
        goto abort;
      }
#line 1058
      file_tmp_o1->length = 0;
#line 1060
      html_output_str(file_tmp_o1, (unsigned char *)"From html-normalise\n", 20);
#line 1061
      html_output_str(file_tmp_o1, (unsigned char *)"Content-type: ", 14);
#line 1062
      if (tag_val_length == 0) {
#line 1062
        if ((int )tag_val[0] == 59) {
#line 1063
          html_output_str(file_tmp_o1, (unsigned char *)"text/plain\n", 11);
        }
      }
#line 1065
      html_output_str(file_tmp_o1, (unsigned char *)(tag_val), tag_val_length);
#line 1066
      html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'\n');
#line 1067
      tmp___889 = strstr((char const   *)(tag_val), ";base64");
#line 1067
      if ((unsigned int )tmp___889 != (unsigned int )((void *)0)) {
#line 1068
        html_output_str(file_tmp_o1, (unsigned char *)"Content-transfer-encoding: base64\n",
                        34);
      }
#line 1070
      html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'\n');
#line 1071
      state = (enum __anonenum_html_state_22 )19;
#line 1072
      binary = 1;
#line 1073
      break;
      case 19: ;
#line 1075
      if ((int )(*ptr) == 38) {
#line 1076
        state = (enum __anonenum_html_state_22 )3;
#line 1077
        next_state = (enum __anonenum_html_state_22 )19;
#line 1078
        ptr ++;
      } else {
#line 1079
        if ((int )(*ptr) == 37) {
#line 1080
          length = 0UL;
#line 1081
          value = 0;
#line 1082
          state = (enum __anonenum_html_state_22 )22;
#line 1083
          next_state = (enum __anonenum_html_state_22 )21;
#line 1084
          ptr ++;
        } else {
#line 1085
          if ((int )(*ptr) == 39) {
#line 1086
            if (! escape) {
#line 1086
              if ((int )quoted == 0) {
#line 1087
                state = (enum __anonenum_html_state_22 )20;
#line 1088
                ptr ++;
              } else {
#line 1090
                html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
#line 1091
                ptr ++;
              }
            } else {
#line 1090
              html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
#line 1091
              ptr ++;
            }
          } else {
#line 1093
            if ((int )(*ptr) == 34) {
#line 1094
              if (! escape) {
#line 1094
                quoted = (enum __anonenum_quoted_state_23 )1;
#line 1094
                if (quoted) {
#line 1095
                  state = (enum __anonenum_html_state_22 )20;
#line 1096
                  ptr ++;
                } else {
#line 1098
                  html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
#line 1099
                  ptr ++;
                }
              } else {
#line 1098
                html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
#line 1099
                ptr ++;
              }
            } else {
#line 1101
              tmp___890 = __ctype_b_loc();
#line 1101
              if ((int const   )(*((*tmp___890) + (int )(*ptr))) & 8192) {
                goto _L___237;
              } else {
#line 1101
                if ((int )(*ptr) == 62) {
                  _L___237: 
#line 1102
                  if ((int )quoted == 2) {
#line 1103
                    state = (enum __anonenum_html_state_22 )20;
#line 1104
                    ptr ++;
                  } else {
#line 1106
                    html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
#line 1107
                    ptr ++;
                  }
                } else {
#line 1110
                  html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (*ptr));
#line 1111
                  ptr ++;
                }
              }
            }
          }
        }
      }
#line 1113
      if ((int )(*ptr) == 92) {
#line 1114
        escape = 1;
      } else {
#line 1116
        escape = 0;
      }
#line 1118
      break;
      case 20: 
#line 1120
      html_output_flush(file_tmp_o1);
#line 1121
      close(file_tmp_o1->fd);
#line 1122
      free((void *)file_tmp_o1);
#line 1123
      state = (enum __anonenum_html_state_22 )4;
#line 1124
      escape = 0;
#line 1125
      quoted = (enum __anonenum_quoted_state_23 )2;
#line 1126
      next_state = (enum __anonenum_html_state_22 )7;
#line 1127
      binary = 0;
#line 1128
      break;
      case 21: ;
#line 1130
      if (length == 2UL) {
#line 1131
        html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )value);
      } else {
#line 1132
        if (length == 1UL) {
#line 1133
          html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'%');
#line 1134
          html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )(value +
                                                                                  48));
        } else {
#line 1136
          html_output_c(file_tmp_o1, (file_buff_t *)((void *)0), (unsigned char )'%');
        }
      }
#line 1138
      state = (enum __anonenum_html_state_22 )19;
#line 1139
      break;
      case 22: 
#line 1141
      value *= 16;
#line 1142
      length ++;
#line 1143
      tmp___896 = __ctype_b_loc();
#line 1143
      if ((int const   )(*((*tmp___896) + (int )(*ptr))) & 4096) {
#line 1144
        tmp___895 = __ctype_b_loc();
#line 1144
        if ((int const   )(*((*tmp___895) + (int )(*ptr))) & 2048) {
#line 1145
          value += (int )(*ptr) - 48;
        } else {
#line 1147
          if (sizeof((*ptr)) > 1U) {
#line 1147
            tmp___893 = __builtin_constant_p((int )(*ptr));
#line 1147
            if (tmp___893) {
#line 1147
              __c___14 = (int )(*ptr);
#line 1147
              if (__c___14 < -128) {
#line 1147
                __res___14 = __c___14;
              } else {
#line 1147
                if (__c___14 > 255) {
#line 1147
                  __res___14 = __c___14;
                } else {
#line 1147
                  tmp___892 = __ctype_tolower_loc();
#line 1147
                  __res___14 = (*((*tmp___892) + __c___14));
                }
              }
            } else {
#line 1147
              __res___14 = tolower__extinline((int )(*ptr));
            }
          } else {
#line 1147
            tmp___894 = __ctype_tolower_loc();
#line 1147
            __res___14 = (*((*tmp___894) + (int )(*ptr)));
          }
#line 1147
          value += (__res___14 - 97) + 10;
        }
      } else {
#line 1150
        state = next_state;
      }
#line 1152
      if (length == 2UL) {
#line 1153
        state = next_state;
      }
#line 1155
      ptr ++;
#line 1156
      break;
      }
    }
#line 1159
    free((void *)line);
#line 1160
    line = cli_readline(stream_in, m_area, 8192U);
#line 1160
    ptr = line;
  }
#line 1163
  retval = 1;
  abort: 
#line 1165
  html_tag_arg_free(& tag_args);
#line 1166
  if (! m_area) {
#line 1167
    fclose(stream_in);
  }
#line 1169
  if (file_buff_o1) {
#line 1170
    html_output_flush(file_buff_o1);
#line 1171
    close(file_buff_o1->fd);
#line 1172
    free((void *)file_buff_o1);
  }
#line 1174
  if (file_buff_o2) {
#line 1175
    html_output_flush(file_buff_o2);
#line 1176
    close(file_buff_o2->fd);
#line 1177
    free((void *)file_buff_o2);
  }
#line 1179
  if (file_buff_script) {
#line 1180
    html_output_flush(file_buff_script);
#line 1181
    close(file_buff_script->fd);
#line 1182
    free((void *)file_buff_script);
  }
#line 1184
  return (retval);
}
}
#line 1187 "htmlnorm.c"
int html_normalise_mem(unsigned char *in_buff , off_t in_size , char const   *dirname ,
                       tag_arguments_t *hrefs ) 
{ m_area_t m_area ;
  int tmp ;

  {
#line 1191
  m_area.buffer = in_buff;
#line 1192
  m_area.length = in_size;
#line 1193
  m_area.offset = 0L;
#line 1195
  tmp = cli_html_normalise(-1, & m_area, dirname, hrefs);
#line 1195
  return (tmp);
}
}
#line 1198 "htmlnorm.c"
int html_normalise_fd(int fd , char const   *dirname , tag_arguments_t *hrefs ) 
{ int retval ;
  m_area_t m_area ;
  struct stat statbuf ;
  int tmp___0 ;

  {
#line 1201
  retval = 0;
#line 1205
  tmp___0 = fstat__extinline(fd, & statbuf);
#line 1205
  if (tmp___0 == 0) {
#line 1206
    m_area.length = statbuf.st_size;
#line 1207
    m_area.buffer = (unsigned char *)mmap((void *)0, (unsigned int )m_area.length,
                                          1, 2, fd, 0L);
#line 1208
    m_area.offset = 0L;
#line 1209
    if ((unsigned int )m_area.buffer == (unsigned int )((void *)-1)) {
#line 1210
      cli_dbgmsg("mmap HTML failed\n");
#line 1211
      retval = cli_html_normalise(fd, (m_area_t *)((void *)0), dirname, hrefs);
    } else {
#line 1213
      cli_dbgmsg("mmap\'ed file\n");
#line 1214
      retval = cli_html_normalise(-1, & m_area, dirname, hrefs);
#line 1215
      munmap((void *)m_area.buffer, (unsigned int )m_area.length);
    }
  } else {
#line 1218
    cli_dbgmsg("fstat HTML failed\n");
#line 1219
    retval = cli_html_normalise(fd, (m_area_t *)((void *)0), dirname, hrefs);
  }
#line 1221
  return (retval);
}
}
#line 1227 "htmlnorm.c"
int html_screnc_decode(int fd , char const   *dirname ) 
{ int fd_tmp ;
  int table_pos ;
  int result ;
  int count ;
  int state ;
  int retval ;
  unsigned char *line ;
  unsigned char tmpstr[6] ;
  unsigned long length ;
  unsigned char *ptr ;
  unsigned char filename[1024] ;
  FILE *stream_in ;
  file_buff_t file_buff ;
  int tmp ;

  {
#line 1229
  table_pos = 0;
#line 1229
  retval = 0;
#line 1236
  lseek(fd, 0L, 0);
#line 1237
  fd_tmp = dup(fd);
#line 1238
  if (fd_tmp < 0) {
#line 1239
    return (0);
  }
#line 1241
  stream_in = fdopen(fd_tmp, "r");
#line 1242
  if (! stream_in) {
#line 1243
    close(fd_tmp);
#line 1244
    return (0);
  }
#line 1247
  snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/screnc.html",
           dirname);
#line 1248
  file_buff.fd = open((char const   *)(filename), 577, 384);
#line 1249
  file_buff.length = 0;
#line 1251
  if (! file_buff.fd) {
#line 1252
    cli_dbgmsg("open failed: %s\n", filename);
#line 1253
    fclose(stream_in);
#line 1254
    return (0);
  }
#line 1257
  while (1) {
#line 1257
    line = cli_readline(stream_in, (m_area_t *)((void *)0), 8192U);
#line 1257
    if (! ((unsigned int )line != (unsigned int )((void *)0))) {
#line 1257
      break;
    }
#line 1258
    ptr = (unsigned char *)strstr((char const   *)line, "#@~^");
#line 1259
    if (ptr) {
#line 1260
      break;
    }
#line 1262
    free((void *)line);
  }
#line 1264
  if (! line) {
    goto abort;
  }
#line 1269
  ptr += 4;
#line 1270
  count = 0;
#line 1271
  while (1) {
#line 1272
    if (! (*ptr)) {
#line 1273
      free((void *)line);
#line 1274
      line = cli_readline(stream_in, (m_area_t *)((void *)0), 8192U);
#line 1274
      ptr = line;
#line 1275
      if (! line) {
        goto abort;
      }
    }
#line 1279
    tmp = count;
#line 1279
    count ++;
#line 1279
    tmpstr[tmp] = (*ptr);
#line 1280
    ptr ++;
#line 1271
    if (! (count < 6)) {
#line 1271
      break;
    }
  }
#line 1283
  length = (unsigned long )(base64_chars[tmpstr[0]] << 2);
#line 1284
  length += (unsigned long )(base64_chars[tmpstr[1]] >> 4);
#line 1285
  length += (unsigned long )((base64_chars[tmpstr[1]] & 15) << 12);
#line 1286
  length += (unsigned long )((base64_chars[tmpstr[2]] >> 2) << 8);
#line 1287
  length += (unsigned long )((base64_chars[tmpstr[2]] & 3) << 22);
#line 1288
  length += (unsigned long )(base64_chars[tmpstr[3]] << 16);
#line 1289
  length += (unsigned long )((base64_chars[tmpstr[4]] << 2) << 24);
#line 1290
  length += (unsigned long )((base64_chars[tmpstr[5]] >> 4) << 24);
#line 1293
  count = 2;
#line 1294
  state = 12;
#line 1296
  while (1) {
#line 1296
    if (length) {
#line 1296
      if (! line) {
#line 1296
        break;
      }
    } else {
#line 1296
      break;
    }
#line 1297
    while (1) {
#line 1297
      if (length) {
#line 1297
        if (! (*ptr)) {
#line 1297
          break;
        }
      } else {
#line 1297
        break;
      }
#line 1298
      if ((int )(*ptr) == 10) {
#line 1299
        ptr ++;
#line 1300
        continue;
      } else {
#line 1298
        if ((int )(*ptr) == 13) {
#line 1299
          ptr ++;
#line 1300
          continue;
        }
      }
#line 1302
      switch (state) {
      case 12: 
#line 1304
      ptr ++;
#line 1305
      count --;
#line 1306
      if (count == 0) {
#line 1307
        state = 1;
      }
#line 1309
      break;
      case 16: ;
#line 1311
      switch ((int )(*ptr)) {
      case 33: 
#line 1313
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)60);
#line 1314
      break;
      case 35: 
#line 1316
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)13);
#line 1317
      break;
      case 36: 
#line 1319
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)64);
#line 1320
      break;
      case 38: 
#line 1322
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)10);
#line 1323
      break;
      case 42: 
#line 1325
      html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char)62);
#line 1326
      break;
      }
#line 1328
      ptr ++;
#line 1329
      length --;
#line 1330
      state = 1;
#line 1331
      break;
      case 1: ;
#line 1333
      if ((int )(*ptr) < 128) {
#line 1334
        result = decrypt_tables[table_order[table_pos]][(*ptr)];
#line 1335
        if (result == 255) {
#line 1336
          state = 16;
        } else {
#line 1338
          html_output_c(& file_buff, (file_buff_t *)((void *)0), (unsigned char )((char )result));
        }
      }
#line 1341
      ptr ++;
#line 1342
      length --;
#line 1343
      table_pos = (table_pos + 1) % 64;
#line 1344
      break;
      }
    }
#line 1347
    free((void *)line);
#line 1348
    if (length) {
#line 1349
      line = cli_readline(stream_in, (m_area_t *)((void *)0), 8192U);
#line 1349
      ptr = line;
    }
  }
#line 1352
  retval = 1;
  abort: 
#line 1355
  fclose(stream_in);
#line 1356
  html_output_flush(& file_buff);
#line 1357
  close(file_buff.fd);
#line 1358
  return (retval);
}
}
#line 1 "chmunpack.lo"
#pragma merger(0,"/tmp/cil-YPKBeo6X.i","-g -O2 -fPIC")
#line 164 "chmunpack.c"
static uint32_t chm_endian_convert_32(uint32_t v ) 
{ 

  {
#line 166
  return ((((v >> 24) | ((v & 16711680U) >> 8)) | ((v & 65280U) << 8)) | (v << 24));
}
}
#line 174 "chmunpack.c"
static uint64_t chm_endian_convert_64(uint64_t v ) 
{ 

  {
#line 176
  return ((((((((v >> 56) | ((v & 71776119061217280ULL) >> 40)) | ((v & 280375465082880ULL) >>
                                                                   24)) | ((v & 1095216660480ULL) >>
                                                                           8)) | ((v &
                                                                                   4278190080ULL) <<
                                                                                  8)) |
            ((v & 16711680ULL) << 24)) | ((v & 65280ULL) << 40)) | (v << 56));
}
}
#line 187 "chmunpack.c"
int chm_read_data(int fd , unsigned char *dest , off_t offset , off_t len , unsigned char *m_area ,
                  off_t m_length ) 
{ __off_t tmp ;
  int tmp___0 ;

  {
#line 190
  if (offset < 0L) {
#line 191
    return (0);
  } else {
#line 190
    if (len < 0L) {
#line 191
      return (0);
    } else {
#line 190
      if (offset + len < 0L) {
#line 191
        return (0);
      }
    }
  }
#line 193
  if ((unsigned int )m_area != (unsigned int )((void *)0)) {
#line 194
    if (offset + len > m_length) {
#line 195
      return (0);
    }
#line 197
    memcpy((void * __restrict  )dest, (void const   * __restrict  )(m_area + offset),
           (unsigned int )len);
  } else {
#line 199
    tmp = lseek(fd, offset, 0);
#line 199
    if (tmp != offset) {
#line 200
      return (0);
    }
#line 202
    tmp___0 = cli_readn(fd, (void *)dest, (unsigned int )len);
#line 202
    if ((long )tmp___0 != len) {
#line 203
      return (0);
    }
  }
#line 206
  return (1);
}
}
#line 209 "chmunpack.c"
uint64_t chm_copy_file_data(int ifd , int ofd , uint64_t len ) 
{ unsigned char data[8192] ;
  uint64_t count ;
  uint64_t rem ;
  unsigned int todo ;
  int tmp ;

  {
#line 215
  rem = len;
#line 217
  while (rem > 0ULL) {
#line 218
    if (8192ULL < rem) {
#line 218
      todo = 8192U;
    } else {
#line 218
      todo = (unsigned int )rem;
    }
#line 219
    count = (uint64_t )cli_readn(ifd, (void *)(data), todo);
#line 220
    if (count != (unsigned long long )todo) {
#line 221
      return (len - rem);
    }
#line 223
    tmp = cli_writen(ofd, (void *)(data), (unsigned int )count);
#line 223
    if ((long long )tmp != (long long )count) {
#line 224
      return ((len - rem) - count);
    }
#line 226
    rem -= count;
  }
#line 228
  return (len);
}
}
#line 231 "chmunpack.c"
static void free_file_list(file_list_t *file_l ) 
{ file_list_t *next ;

  {
#line 235
  while (file_l) {
#line 236
    next = file_l->next;
#line 237
    if (file_l->name) {
#line 238
      free((void *)file_l->name);
    }
#line 240
    free((void *)file_l);
#line 241
    file_l = next;
  }
#line 243
  return;
}
}
#line 245 "chmunpack.c"
static void itsf_print_header(itsf_header_t *itsf_hdr ) 
{ 

  {
#line 247
  if (! itsf_hdr) {
#line 248
    return;
  }
#line 251
  cli_dbgmsg("---- ITSF ----\n");
#line 252
  cli_dbgmsg("Signature:\t%c%c%c%c\n", itsf_hdr->signature[0], itsf_hdr->signature[1],
             itsf_hdr->signature[2], itsf_hdr->signature[3]);
#line 254
  cli_dbgmsg("Version:\t%d\n", itsf_hdr->version);
#line 255
  cli_dbgmsg("Header len:\t%ld\n", itsf_hdr->header_len);
#line 256
  cli_dbgmsg("Lang ID:\t%d\n", itsf_hdr->lang_id);
#line 257
  cli_dbgmsg("Sec0 offset:\t%llu\n", itsf_hdr->sec0_offset);
#line 258
  cli_dbgmsg("Sec0 len:\t%llu\n", itsf_hdr->sec0_len);
#line 259
  cli_dbgmsg("Dir offset:\t%llu\n", itsf_hdr->dir_offset);
#line 260
  cli_dbgmsg("Dir len:\t%llu\n", itsf_hdr->dir_len);
#line 261
  if (itsf_hdr->version > 2) {
#line 262
    cli_dbgmsg("Data offset:\t%llu\n\n", itsf_hdr->data_offset);
  }
#line 264
  return;
}
}
#line 266 "chmunpack.c"
static int itsf_read_header(int fd , itsf_header_t *itsf_hdr , unsigned char *m_area ,
                            off_t m_length ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 269
  tmp = chm_read_data(fd, (unsigned char *)itsf_hdr, 0L, 96L, m_area, m_length);
#line 269
  if (! tmp) {
#line 271
    return (0);
  }
#line 316
  tmp___0 = memcmp((void const   *)(itsf_hdr->signature), (void const   *)"ITSF",
                   4U);
#line 316
  if (tmp___0 != 0) {
#line 317
    cli_dbgmsg("ITSF signature mismatch\n");
#line 318
    return (0);
  }
#line 320
  itsf_hdr->version = (int32_t )chm_endian_convert_32((unsigned int )itsf_hdr->version);
#line 321
  itsf_hdr->header_len = (int32_t )chm_endian_convert_32((unsigned int )itsf_hdr->header_len);
#line 322
  itsf_hdr->last_modified = chm_endian_convert_32(itsf_hdr->last_modified);
#line 323
  itsf_hdr->lang_id = chm_endian_convert_32(itsf_hdr->lang_id);
#line 324
  itsf_hdr->sec0_offset = chm_endian_convert_64(itsf_hdr->sec0_offset);
#line 325
  itsf_hdr->sec0_len = chm_endian_convert_64(itsf_hdr->sec0_len);
#line 326
  itsf_hdr->dir_offset = chm_endian_convert_64(itsf_hdr->dir_offset);
#line 327
  itsf_hdr->dir_len = chm_endian_convert_64(itsf_hdr->dir_len);
#line 328
  if (itsf_hdr->version > 2) {
#line 329
    itsf_hdr->data_offset = chm_endian_convert_64(itsf_hdr->data_offset);
  }
#line 331
  return (1);
}
}
#line 334 "chmunpack.c"
static void itsp_print_header(itsp_header_t *itsp_hdr ) 
{ 

  {
#line 336
  if (! itsp_hdr) {
#line 337
    return;
  }
#line 340
  cli_dbgmsg("---- ITSP ----\n");
#line 341
  cli_dbgmsg("Signature:\t%c%c%c%c\n", itsp_hdr->signature[0], itsp_hdr->signature[1],
             itsp_hdr->signature[2], itsp_hdr->signature[3]);
#line 343
  cli_dbgmsg("Version:\t%d\n", itsp_hdr->version);
#line 344
  cli_dbgmsg("Block len:\t%ld\n", itsp_hdr->block_len);
#line 345
  cli_dbgmsg("Block idx int:\t%d\n", itsp_hdr->blockidx_intvl);
#line 346
  cli_dbgmsg("Index depth:\t%d\n", itsp_hdr->index_depth);
#line 347
  cli_dbgmsg("Index root:\t%d\n", itsp_hdr->index_root);
#line 348
  cli_dbgmsg("Index head:\t%u\n", itsp_hdr->index_head);
#line 349
  cli_dbgmsg("Index tail:\t%u\n", itsp_hdr->index_tail);
#line 350
  cli_dbgmsg("Num Blocks:\t%u\n", itsp_hdr->num_blocks);
#line 351
  cli_dbgmsg("Lang ID:\t%lu\n\n", itsp_hdr->lang_id);
#line 352
  return;
}
}
#line 354 "chmunpack.c"
static int itsp_read_header(int fd , itsp_header_t *itsp_hdr , off_t offset , unsigned char *m_area ,
                            off_t m_length ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 358
  tmp = chm_read_data(fd, (unsigned char *)itsp_hdr, offset, 84L, m_area, m_length);
#line 358
  if (! tmp) {
#line 360
    return (0);
  }
#line 412
  tmp___0 = memcmp((void const   *)(itsp_hdr->signature), (void const   *)"ITSP",
                   4U);
#line 412
  if (tmp___0 != 0) {
#line 413
    cli_dbgmsg("ITSP signature mismatch\n");
#line 414
    return (0);
  }
#line 417
  itsp_hdr->version = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->version);
#line 418
  itsp_hdr->header_len = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->header_len);
#line 419
  itsp_hdr->block_len = chm_endian_convert_32(itsp_hdr->block_len);
#line 420
  itsp_hdr->blockidx_intvl = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->blockidx_intvl);
#line 421
  itsp_hdr->index_depth = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_depth);
#line 422
  itsp_hdr->index_root = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_root);
#line 423
  itsp_hdr->index_head = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_head);
#line 424
  itsp_hdr->index_tail = (int32_t )chm_endian_convert_32((unsigned int )itsp_hdr->index_tail);
#line 425
  itsp_hdr->num_blocks = chm_endian_convert_32(itsp_hdr->num_blocks);
#line 426
  itsp_hdr->lang_id = chm_endian_convert_32(itsp_hdr->lang_id);
#line 428
  if (itsp_hdr->version != 1) {
#line 429
    cli_dbgmsg("ITSP header mismatch\n");
#line 430
    return (0);
  } else {
#line 428
    if (itsp_hdr->header_len != 84) {
#line 429
      cli_dbgmsg("ITSP header mismatch\n");
#line 430
      return (0);
    }
  }
#line 432
  return (1);
}
}
#line 435 "chmunpack.c"
static uint64_t read_enc_int(unsigned char **start , unsigned char *end ) 
{ uint64_t retval ;
  unsigned char *current ;
  unsigned char *tmp ;

  {
#line 437
  retval = 0ULL;
#line 440
  current = (*start);
#line 442
  if ((unsigned int )current > (unsigned int )end) {
#line 443
    return (0ULL);
  }
#line 446
  while (1) {
#line 447
    if ((unsigned int )current > (unsigned int )end) {
#line 448
      return (0ULL);
    }
#line 450
    retval = (retval << 7) | (unsigned long long )((int )(*current) & 127);
#line 446
    tmp = current;
#line 446
    current ++;
#line 446
    if (! ((int )(*tmp) & 128)) {
#line 446
      break;
    }
  }
#line 453
  (*start) = current;
#line 454
  return (retval);
}
}
#line 459 "chmunpack.c"
static int read_chunk_entries(unsigned char *chunk , uint32_t chunk_len , uint16_t num_entries ,
                              file_list_t *file_l , file_list_t *sys_file_l ) 
{ unsigned char *current ;
  unsigned char *end ;
  uint64_t name_len ;
  file_list_t *file_e ;
  uint16_t tmp___1 ;

  {
#line 467
  end = chunk + chunk_len;
#line 468
  current = chunk + 20;
#line 470
  while (1) {
#line 470
    tmp___1 = num_entries;
#line 470
    num_entries = (unsigned short )((int )num_entries - 1);
#line 470
    if (! tmp___1) {
#line 470
      break;
    }
#line 471
    if ((unsigned int )current > (unsigned int )end) {
#line 472
      cli_dbgmsg("read chunk entries failed\n");
#line 473
      return (0);
    }
#line 476
    file_e = (file_list_t *)cli_malloc(sizeof(file_list_t ));
#line 477
    if (! file_e) {
#line 478
      return (0);
    }
#line 480
    file_e->next = (struct file_list_tag *)((void *)0);
#line 482
    name_len = read_enc_int(& current, end);
#line 483
    file_e->name = (unsigned char *)cli_malloc((unsigned int )(name_len + 1ULL));
#line 484
    if (! file_e->name) {
#line 485
      free((void *)file_e);
#line 486
      return (0);
    }
#line 488
    __builtin_strncpy(file_e->name, current, name_len);
#line 489
    (*(file_e->name + name_len)) = (unsigned char )'\000';
#line 490
    current += name_len;
#line 491
    file_e->section = read_enc_int(& current, end);
#line 492
    file_e->offset = read_enc_int(& current, end);
#line 493
    file_e->length = read_enc_int(& current, end);
#line 494
    if (name_len >= 2ULL) {
#line 494
      if ((int )(*(file_e->name + 0)) == 58) {
#line 494
        if ((int )(*(file_e->name + 1)) == 58) {
#line 496
          file_e->next = sys_file_l->next;
#line 497
          sys_file_l->next = file_e;
        } else {
#line 499
          file_e->next = file_l->next;
#line 500
          file_l->next = file_e;
        }
      } else {
#line 499
        file_e->next = file_l->next;
#line 500
        file_l->next = file_e;
      }
    } else {
#line 499
      file_e->next = file_l->next;
#line 500
      file_l->next = file_e;
    }
#line 502
    cli_dbgmsg("Section: %llu Offset: %llu Length: %llu, Name: %s\n", file_e->section,
               file_e->offset, file_e->length, file_e->name);
  }
#line 506
  return (1);
}
}
#line 509 "chmunpack.c"
static void print_chunk(chunk_header_t *chunk ) 
{ int tmp ;

  {
#line 512
  cli_dbgmsg("---- Chunk ----\n");
#line 513
  cli_dbgmsg("Signature:\t%c%c%c%c\n", chunk->signature[0], chunk->signature[1], chunk->signature[2],
             chunk->signature[3]);
#line 515
  cli_dbgmsg("Free Space:\t%u\n", chunk->free_space);
#line 516
  tmp = memcmp((void const   *)(chunk->signature), (void const   *)"PMGL", 4U);
#line 516
  if (tmp == 0) {
#line 517
    cli_dbgmsg("Prev Block:\t%d\n", chunk->block_prev);
#line 518
    cli_dbgmsg("Next Block:\t%d\n", chunk->block_next);
#line 519
    cli_dbgmsg("Num entries:\t%d\n\n", chunk->num_entries);
  }
#line 521
  return;
}
}
#line 524 "chmunpack.c"
static int read_chunk(int fd , off_t offset , uint32_t chunk_len , unsigned char *m_area ,
                      off_t m_length , file_list_t *file_l , file_list_t *sys_file_l ) 
{ chunk_header_t *chunk_hdr ;
  int retval ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 529
  retval = 0;
#line 531
  if (chunk_len < 8U) {
#line 532
    return (0);
  } else {
#line 531
    if (chunk_len > 33554432U) {
#line 532
      return (0);
    }
  }
#line 535
  chunk_hdr = (chunk_header_t *)cli_malloc(sizeof(chunk_header_t ));
#line 536
  if (! chunk_hdr) {
#line 537
    return (0);
  }
#line 540
  chunk_hdr->chunk_data = (unsigned char *)cli_malloc(chunk_len);
#line 541
  if (! chunk_hdr->chunk_data) {
#line 542
    free((void *)chunk_hdr);
#line 543
    return (0);
  }
#line 548
  tmp___1 = chm_read_data(fd, chunk_hdr->signature, offset, 8L, m_area, m_length);
#line 548
  if (! tmp___1) {
    goto abort;
  }
#line 552
  tmp___2 = chm_read_data(fd, chunk_hdr->chunk_data, offset, (long )chunk_len, m_area,
                          m_length);
#line 552
  if (! tmp___2) {
    goto abort;
  }
#line 573
  chunk_hdr->free_space = chm_endian_convert_32(chunk_hdr->free_space);
#line 575
  tmp___5 = memcmp((void const   *)(chunk_hdr->signature), (void const   *)"PMGL",
                   4U);
#line 575
  if (tmp___5 == 0) {
#line 577
    tmp___3 = chm_read_data(fd, (unsigned char *)(& chunk_hdr->unknown), offset +
                                                                         8L, 12L,
                            m_area, m_length);
#line 577
    if (! tmp___3) {
      goto abort;
    }
#line 592
    chunk_hdr->block_next = (int32_t )chm_endian_convert_32((unsigned int )chunk_hdr->block_next);
#line 593
    chunk_hdr->block_prev = (int32_t )chm_endian_convert_32((unsigned int )chunk_hdr->block_prev);
#line 595
    chunk_hdr->num_entries = (unsigned short )(((int const   )(*((uint8_t const   *)chunk_hdr->chunk_data +
                                                                 (chunk_len - 2U))) <<
                                                0) | ((int const   )(*((uint8_t const   *)chunk_hdr->chunk_data +
                                                                       (chunk_len -
                                                                        1U))) << 8));
#line 597
    read_chunk_entries(chunk_hdr->chunk_data, chunk_len, chunk_hdr->num_entries, file_l,
                       sys_file_l);
  } else {
#line 599
    tmp___4 = memcmp((void const   *)(chunk_hdr->signature), (void const   *)"PMGI",
                     4U);
#line 599
    if (tmp___4 != 0) {
      goto abort;
    }
  }
#line 603
  print_chunk(chunk_hdr);
#line 604
  retval = 1;
  abort: 
#line 606
  free((void *)chunk_hdr->chunk_data);
#line 607
  free((void *)chunk_hdr);
#line 608
  return (retval);
}
}
#line 611 "chmunpack.c"
static void print_sys_control(lzx_control_t *lzx_control ) 
{ 

  {
#line 613
  if (! lzx_control) {
#line 614
    return;
  }
#line 617
  cli_dbgmsg("---- Control ----\n");
#line 618
  cli_dbgmsg("Length:\t\t%lu\n", lzx_control->length);
#line 619
  cli_dbgmsg("Signature:\t%c%c%c%c\n", lzx_control->signature[0], lzx_control->signature[1],
             lzx_control->signature[2], lzx_control->signature[3]);
#line 621
  cli_dbgmsg("Version:\t%d\n", lzx_control->version);
#line 622
  cli_dbgmsg("Reset Interval:\t%d\n", lzx_control->reset_interval);
#line 623
  cli_dbgmsg("Window Size:\t%d\n", lzx_control->window_size);
#line 624
  cli_dbgmsg("Cache Size:\t%d\n\n", lzx_control->cache_size);
#line 625
  return;
}
}
#line 627 "chmunpack.c"
static lzx_control_t *read_sys_control(int fd , itsf_header_t *itsf_hdr , file_list_t *file_e ,
                                       unsigned char *m_area , off_t m_length ) 
{ off_t offset ;
  lzx_control_t *lzx_control ;
  int tmp___0 ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  size_t tmp___146 ;
  int tmp___147 ;
  size_t tmp___148 ;

  {
#line 633
  if (file_e->length != 28ULL) {
#line 634
    return ((lzx_control_t *)((void *)0));
  }
#line 636
  offset = (long )(itsf_hdr->data_offset + file_e->offset);
#line 637
  if (offset < 0L) {
#line 638
    return ((lzx_control_t *)((void *)0));
  }
#line 641
  lzx_control = (lzx_control_t *)cli_malloc(sizeof(lzx_control_t ));
#line 642
  if (! lzx_control) {
#line 643
    return ((lzx_control_t *)((void *)0));
  }
#line 646
  tmp___0 = chm_read_data(fd, (unsigned char *)lzx_control, offset, 24L, m_area, m_length);
#line 646
  if (! tmp___0) {
    goto abort;
  }
#line 673
  lzx_control->length = chm_endian_convert_32(lzx_control->length);
#line 674
  lzx_control->version = chm_endian_convert_32(lzx_control->version);
#line 675
  lzx_control->reset_interval = chm_endian_convert_32(lzx_control->reset_interval);
#line 676
  lzx_control->window_size = chm_endian_convert_32(lzx_control->window_size);
#line 677
  lzx_control->cache_size = chm_endian_convert_32(lzx_control->cache_size);
#line 679
  tmp___145 = __builtin_constant_p((int )"LZXC");
#line 679
  if (tmp___145) {
#line 679
    tmp___146 = strlen("LZXC");
#line 679
    if (tmp___146 < 4U) {
      goto _L___39;
    } else {
      goto _L___40;
    }
  } else {
    _L___40: 
#line 679
    tmp___147 = __builtin_constant_p((int )(lzx_control->signature));
#line 679
    if (tmp___147) {
#line 679
      tmp___148 = strlen((char const   *)(lzx_control->signature));
#line 679
      if (tmp___148 < 4U) {
        _L___39: 
#line 679
        tmp___142 = __builtin_constant_p((int )"LZXC");
#line 679
        if (tmp___142) {
#line 679
          tmp___143 = __builtin_constant_p((int )(lzx_control->signature));
#line 679
          if (tmp___143) {
#line 679
            __s1_len___0 = strlen("LZXC");
#line 679
            __s2_len___0 = strlen((char const   *)(lzx_control->signature));
#line 679
            if (! ((unsigned int )((void const   *)("LZXC" + 1)) - (unsigned int )((void const   *)"LZXC") ==
                   1U)) {
              goto _L___36;
            } else {
#line 679
              if (__s1_len___0 >= 4U) {
                _L___36: 
#line 679
                if (! ((unsigned int )((void const   *)(lzx_control->signature + 1)) -
                       (unsigned int )((void const   *)(lzx_control->signature)) ==
                       1U)) {
#line 679
                  tmp___144 = 1;
                } else {
#line 679
                  if (__s2_len___0 >= 4U) {
#line 679
                    tmp___144 = 1;
                  } else {
#line 679
                    tmp___144 = 0;
                  }
                }
              } else {
#line 679
                tmp___144 = 0;
              }
            }
#line 679
            if (tmp___144) {
#line 679
              tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
            } else {
              goto _L___38;
            }
          } else {
            goto _L___38;
          }
        } else {
          _L___38: 
#line 679
          tmp___141 = __builtin_constant_p((int )"LZXC");
#line 679
          if (tmp___141) {
#line 679
            if ((unsigned int )((void const   *)("LZXC" + 1)) - (unsigned int )((void const   *)"LZXC") ==
                1U) {
#line 679
              __s1_len___0 = strlen("LZXC");
#line 679
              if (__s1_len___0 < 4U) {
#line 679
                tmp___130 = __builtin_constant_p((int )(lzx_control->signature));
#line 679
                if (tmp___130) {
#line 679
                  if ((unsigned int )((void const   *)(lzx_control->signature + 1)) -
                      (unsigned int )((void const   *)(lzx_control->signature)) ==
                      1U) {
#line 679
                    tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
                  } else {
                    goto _L___31;
                  }
                } else {
                  _L___31: 
#line 679
                  __s2___14 = (unsigned char const   *)((char const   *)(lzx_control->signature));
#line 679
                  __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                          0)) - (int const   )(*(__s2___14 +
                                                                                 0)));
#line 679
                  if (__s1_len___0 > 0U) {
#line 679
                    if (__result___42 == 0) {
#line 679
                      __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                              1)) - (int const   )(*(__s2___14 +
                                                                                     1)));
#line 679
                      if (__s1_len___0 > 1U) {
#line 679
                        if (__result___42 == 0) {
#line 679
                          __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                                  2)) - (int const   )(*(__s2___14 +
                                                                                         2)));
#line 679
                          if (__s1_len___0 > 2U) {
#line 679
                            if (__result___42 == 0) {
#line 679
                              __result___42 = (int )((int const   )(*((unsigned char const   *)"LZXC" +
                                                                      3)) - (int const   )(*(__s2___14 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 679
                  tmp___111 = __result___42;
                }
              } else {
                goto _L___35;
              }
            } else {
              goto _L___35;
            }
          } else {
            _L___35: 
#line 679
            tmp___140 = __builtin_constant_p((int )(lzx_control->signature));
#line 679
            if (tmp___140) {
#line 679
              if ((unsigned int )((void const   *)(lzx_control->signature + 1)) -
                  (unsigned int )((void const   *)(lzx_control->signature)) == 1U) {
#line 679
                __s2_len___0 = strlen((char const   *)(lzx_control->signature));
#line 679
                if (__s2_len___0 < 4U) {
#line 679
                  tmp___139 = __builtin_constant_p((int )"LZXC");
#line 679
                  if (tmp___139) {
#line 679
                    if ((unsigned int )((void const   *)("LZXC" + 1)) - (unsigned int )((void const   *)"LZXC") ==
                        1U) {
#line 679
                      tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
                    } else {
                      goto _L___33;
                    }
                  } else {
                    _L___33: 
#line 679
                    __s1___30 = (unsigned char const   *)"LZXC";
#line 679
                    __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                                               0)));
#line 679
                    if (__s2_len___0 > 0U) {
#line 679
                      if (__result___46 == 0) {
#line 679
                        __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                1)));
#line 679
                        if (__s2_len___0 > 1U) {
#line 679
                          if (__result___46 == 0) {
#line 679
                            __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                    2)));
#line 679
                            if (__s2_len___0 > 2U) {
#line 679
                              if (__result___46 == 0) {
#line 679
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)(lzx_control->signature)) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 679
                    tmp___111 = __result___46;
                  }
                } else {
#line 679
                  tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
                }
              } else {
#line 679
                tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
              }
            } else {
#line 679
              tmp___111 = __builtin_strcmp("LZXC", lzx_control->signature);
            }
          }
        }
#line 679
        tmp___75 = tmp___111;
      } else {
#line 679
        tmp___75 = strncmp("LZXC", (char const   *)(lzx_control->signature), 4U);
      }
    } else {
#line 679
      tmp___75 = strncmp("LZXC", (char const   *)(lzx_control->signature), 4U);
    }
  }
#line 679
  if (tmp___75 != 0) {
#line 680
    cli_dbgmsg("bad sys_control signature");
    goto abort;
  }
#line 683
  switch ((int )lzx_control->version) {
  case 1: ;
#line 685
  break;
  case 2: 
#line 687
  lzx_control->reset_interval *= 32768U;
#line 688
  lzx_control->window_size *= 32768U;
#line 689
  break;
  default: 
#line 691
  cli_dbgmsg("Unknown sys_control version:%d\n", lzx_control->version);
  goto abort;
  }
#line 695
  print_sys_control(lzx_control);
#line 696
  return (lzx_control);
  abort: 
#line 698
  free((void *)lzx_control);
#line 699
  return ((lzx_control_t *)((void *)0));
}
}
#line 702 "chmunpack.c"
static void print_sys_content(lzx_content_t *lzx_content ) 
{ 

  {
#line 704
  if (! lzx_content) {
#line 705
    return;
  }
#line 708
  cli_dbgmsg("---- Content ----\n");
#line 709
  cli_dbgmsg("Offset:\t%llu\n", lzx_content->offset);
#line 710
  cli_dbgmsg("Length:\t%llu\n\n", lzx_content->length);
#line 711
  return;
}
}
#line 713 "chmunpack.c"
static lzx_content_t *read_sys_content(int fd , itsf_header_t *itsf_hdr , file_list_t *file_e ) 
{ lzx_content_t *lzx_content ;

  {
#line 717
  lzx_content = (lzx_content_t *)cli_malloc(sizeof(lzx_content_t ));
#line 718
  if (! lzx_content) {
#line 719
    return ((lzx_content_t *)((void *)0));
  }
#line 721
  lzx_content->offset = itsf_hdr->data_offset + file_e->offset;
#line 722
  lzx_content->length = file_e->length;
#line 724
  print_sys_content(lzx_content);
#line 725
  return (lzx_content);
}
}
#line 728 "chmunpack.c"
static void print_sys_reset_table(lzx_reset_table_t *lzx_reset_table ) 
{ 

  {
#line 730
  if (! lzx_reset_table) {
#line 731
    return;
  }
#line 734
  cli_dbgmsg("---- Reset Table ----\n");
#line 735
  cli_dbgmsg("Num Entries:\t%lu\n", lzx_reset_table->num_entries);
#line 736
  cli_dbgmsg("Entry Size:\t%lu\n", lzx_reset_table->entry_size);
#line 737
  cli_dbgmsg("Table Offset:\t%lu\n", lzx_reset_table->table_offset);
#line 738
  cli_dbgmsg("Uncom Len:\t%llu\n", lzx_reset_table->uncom_len);
#line 739
  cli_dbgmsg("Com Len:\t%llu\n", lzx_reset_table->com_len);
#line 740
  cli_dbgmsg("Frame Len:\t%llu\n\n", lzx_reset_table->frame_len);
#line 741
  return;
}
}
#line 743 "chmunpack.c"
static lzx_reset_table_t *read_sys_reset_table(int fd , itsf_header_t *itsf_hdr ,
                                               file_list_t *file_e , unsigned char *m_area ,
                                               off_t m_length ) 
{ off_t offset ;
  lzx_reset_table_t *lzx_reset_table ;
  int tmp___0 ;

  {
#line 749
  if (file_e->length < 40ULL) {
#line 750
    return ((lzx_reset_table_t *)((void *)0));
  }
#line 753
  offset = (long )((itsf_hdr->data_offset + file_e->offset) + 4ULL);
#line 755
  if (offset < 0L) {
#line 756
    return ((lzx_reset_table_t *)((void *)0));
  }
#line 759
  lzx_reset_table = (lzx_reset_table_t *)cli_malloc(sizeof(lzx_reset_table_t ));
#line 760
  if (! lzx_reset_table) {
#line 761
    return ((lzx_reset_table_t *)((void *)0));
  }
#line 765
  lzx_reset_table->rt_offset = offset - 4L;
#line 768
  tmp___0 = chm_read_data(fd, (unsigned char *)lzx_reset_table, offset, 36L, m_area,
                          m_length);
#line 768
  if (! tmp___0) {
    goto abort;
  }
#line 795
  lzx_reset_table->num_entries = chm_endian_convert_32(lzx_reset_table->num_entries);
#line 796
  lzx_reset_table->entry_size = chm_endian_convert_32(lzx_reset_table->entry_size);
#line 797
  lzx_reset_table->table_offset = chm_endian_convert_32(lzx_reset_table->table_offset);
#line 798
  lzx_reset_table->uncom_len = chm_endian_convert_64(lzx_reset_table->uncom_len);
#line 799
  lzx_reset_table->com_len = chm_endian_convert_64(lzx_reset_table->com_len);
#line 800
  lzx_reset_table->frame_len = chm_endian_convert_64(lzx_reset_table->frame_len);
#line 802
  if (lzx_reset_table->frame_len != 32768ULL) {
#line 803
    cli_dbgmsg("bad sys_reset_table frame_len: 0x%x\n", lzx_reset_table->frame_len);
    goto abort;
  }
#line 806
  if (lzx_reset_table->entry_size != 4U) {
#line 806
    if (lzx_reset_table->entry_size != 8U) {
#line 807
      cli_dbgmsg("bad sys_reset_table entry_size: 0x%x\n", lzx_reset_table->entry_size);
      goto abort;
    }
  }
#line 810
  print_sys_reset_table(lzx_reset_table);
#line 811
  return (lzx_reset_table);
  abort: 
#line 813
  free((void *)lzx_reset_table);
#line 814
  return ((lzx_reset_table_t *)((void *)0));
}
}
#line 833 "chmunpack.c"
static int chm_decompress_stream(int fd , char const   *dirname , itsf_header_t *itsf_hdr ,
                                 file_list_t *file_l , file_list_t *sys_file_l , unsigned char *m_area ,
                                 off_t m_length ) 
{ file_list_t *entry ;
  lzx_content_t *lzx_content ;
  lzx_reset_table_t *lzx_reset_table ;
  lzx_control_t *lzx_control ;
  int window_bits ;
  int count ;
  int length ;
  int ofd ;
  int retval ;
  uint64_t com_offset ;
  struct mspack_file_p mf_in ;
  struct mspack_file_p mf_out ;
  struct lzxd_stream *stream ;
  unsigned char filename[1024] ;
  size_t __len___2 ;
  size_t tmp___15 ;
  char *__retval___2 ;
  char *tmp___16 ;
  int tmp___18 ;
  size_t __len___6 ;
  size_t tmp___35 ;
  char *__retval___6 ;
  char *tmp___36 ;
  int tmp___38 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___74 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___93 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___143 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___162 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___212 ;
  unsigned char const   *__s2___22 ;
  register int __result___66 ;
  int tmp___231 ;
  unsigned char const   *__s1___46 ;
  register int __result___70 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___242 ;
  int tmp___243 ;
  int tmp___244 ;
  int tmp___245 ;
  __off_t tmp___246 ;
  uint64_t tmp___247 ;

  {
#line 838
  lzx_content = (lzx_content_t *)((void *)0);
#line 839
  lzx_reset_table = (lzx_reset_table_t *)((void *)0);
#line 840
  lzx_control = (lzx_control_t *)((void *)0);
#line 841
  retval = 0;
#line 847
  mf_in.desc = dup(fd);
#line 848
  if (mf_in.desc < 0) {
#line 849
    return (0);
  }
#line 851
  mf_in.fh = fdopen(mf_in.desc, "r");
#line 852
  if (! mf_in.fh) {
#line 853
    close(mf_in.desc);
#line 854
    return (0);
  }
#line 856
  tmp___18 = __builtin_constant_p((int )"input");
#line 856
  if (tmp___18) {
#line 856
    if ((unsigned int )((void const   *)("input" + 1)) - (unsigned int )((void const   *)"input") ==
        1U) {
#line 856
      if ((int const   )(*("input" + 0)) == 0) {
#line 856
        mf_in.name = (char const   *)calloc(1U, 1U);
      } else {
#line 856
        tmp___15 = strlen("input");
#line 856
        __len___2 = tmp___15 + 1U;
#line 856
        tmp___16 = (char *)malloc(__len___2);
#line 856
        __retval___2 = tmp___16;
#line 856
        if ((unsigned int )__retval___2 != (unsigned int )((void *)0)) {
#line 856
          __retval___2 = (char *)memcpy((void * __restrict  )__retval___2, (void const   * __restrict  )"input",
                                        __len___2);
        }
#line 856
        mf_in.name = (char const   *)__retval___2;
      }
    } else {
#line 856
      mf_in.name = __strdup("input");
    }
  } else {
#line 856
    mf_in.name = __strdup("input");
  }
#line 858
  snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/clamav-unchm.bin",
           dirname);
#line 859
  mf_out.desc = open((char const   *)(filename), 577, 448);
#line 860
  if (! mf_out.desc) {
#line 861
    cli_dbgmsg("open failed\n", filename);
#line 862
    free((void *)mf_in.name);
#line 863
    fclose(mf_in.fh);
#line 864
    return (0);
  }
#line 866
  mf_out.fh = fdopen(mf_out.desc, "w");
#line 867
  if (! mf_out.fh) {
#line 868
    cli_dbgmsg("fdopen failed\n", filename);
#line 869
    free((void *)mf_in.name);
#line 870
    fclose(mf_in.fh);
#line 871
    return (0);
  }
#line 874
  tmp___38 = __builtin_constant_p((int )"output");
#line 874
  if (tmp___38) {
#line 874
    if ((unsigned int )((void const   *)("output" + 1)) - (unsigned int )((void const   *)"output") ==
        1U) {
#line 874
      if ((int const   )(*("output" + 0)) == 0) {
#line 874
        mf_out.name = (char const   *)calloc(1U, 1U);
      } else {
#line 874
        tmp___35 = strlen("output");
#line 874
        __len___6 = tmp___35 + 1U;
#line 874
        tmp___36 = (char *)malloc(__len___6);
#line 874
        __retval___6 = tmp___36;
#line 874
        if ((unsigned int )__retval___6 != (unsigned int )((void *)0)) {
#line 874
          __retval___6 = (char *)memcpy((void * __restrict  )__retval___6, (void const   * __restrict  )"output",
                                        __len___6);
        }
#line 874
        mf_out.name = (char const   *)__retval___6;
      }
    } else {
#line 874
      mf_out.name = __strdup("output");
    }
  } else {
#line 874
    mf_out.name = __strdup("output");
  }
#line 876
  entry = sys_file_l->next;
#line 877
  while (entry) {
#line 878
    tmp___243 = __builtin_constant_p((int )entry->name);
#line 878
    if (tmp___243) {
#line 878
      tmp___244 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/ControlData");
#line 878
      if (tmp___244) {
#line 878
        __s1_len___1 = strlen((char const   *)entry->name);
#line 878
        __s2_len___1 = strlen("::DataSpace/Storage/MSCompressed/ControlData");
#line 878
        if (! ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
               1U)) {
          goto _L___56;
        } else {
#line 878
          if (__s1_len___1 >= 4U) {
            _L___56: 
#line 878
            if (! ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/ControlData" +
                                                    1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/ControlData") ==
                   1U)) {
#line 878
              tmp___245 = 1;
            } else {
#line 878
              if (__s2_len___1 >= 4U) {
#line 878
                tmp___245 = 1;
              } else {
#line 878
                tmp___245 = 0;
              }
            }
          } else {
#line 878
            tmp___245 = 0;
          }
        }
#line 878
        if (tmp___245) {
#line 878
          tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
        } else {
          goto _L___58;
        }
      } else {
        goto _L___58;
      }
    } else {
      _L___58: 
#line 878
      tmp___242 = __builtin_constant_p((int )entry->name);
#line 878
      if (tmp___242) {
#line 878
        if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
            1U) {
#line 878
          __s1_len___1 = strlen((char const   *)entry->name);
#line 878
          if (__s1_len___1 < 4U) {
#line 878
            tmp___231 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/ControlData");
#line 878
            if (tmp___231) {
#line 878
              if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/ControlData" +
                                                   1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/ControlData") ==
                  1U) {
#line 878
                tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
              } else {
                goto _L___51;
              }
            } else {
              _L___51: 
#line 878
              __s2___22 = (unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData";
#line 878
              __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                      0)) - (int const   )(*(__s2___22 +
                                                                             0)));
#line 878
              if (__s1_len___1 > 0U) {
#line 878
                if (__result___66 == 0) {
#line 878
                  __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                          1)) - (int const   )(*(__s2___22 +
                                                                                 1)));
#line 878
                  if (__s1_len___1 > 1U) {
#line 878
                    if (__result___66 == 0) {
#line 878
                      __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                              2)) - (int const   )(*(__s2___22 +
                                                                                     2)));
#line 878
                      if (__s1_len___1 > 2U) {
#line 878
                        if (__result___66 == 0) {
#line 878
                          __result___66 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                  3)) - (int const   )(*(__s2___22 +
                                                                                         3)));
                        }
                      }
                    }
                  }
                }
              }
#line 878
              tmp___212 = __result___66;
            }
          } else {
            goto _L___55;
          }
        } else {
          goto _L___55;
        }
      } else {
        _L___55: 
#line 878
        tmp___241 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/ControlData");
#line 878
        if (tmp___241) {
#line 878
          if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/ControlData" +
                                               1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/ControlData") ==
              1U) {
#line 878
            __s2_len___1 = strlen("::DataSpace/Storage/MSCompressed/ControlData");
#line 878
            if (__s2_len___1 < 4U) {
#line 878
              tmp___240 = __builtin_constant_p((int )entry->name);
#line 878
              if (tmp___240) {
#line 878
                if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                    1U) {
#line 878
                  tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
                } else {
                  goto _L___53;
                }
              } else {
                _L___53: 
#line 878
                __s1___46 = (unsigned char const   *)((char const   *)entry->name);
#line 878
                __result___70 = (int )((int const   )(*(__s1___46 + 0)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                                           0)));
#line 878
                if (__s2_len___1 > 0U) {
#line 878
                  if (__result___70 == 0) {
#line 878
                    __result___70 = (int )((int const   )(*(__s1___46 + 1)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                                               1)));
#line 878
                    if (__s2_len___1 > 1U) {
#line 878
                      if (__result___70 == 0) {
#line 878
                        __result___70 = (int )((int const   )(*(__s1___46 + 2)) -
                                               (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                2)));
#line 878
                        if (__s2_len___1 > 2U) {
#line 878
                          if (__result___70 == 0) {
#line 878
                            __result___70 = (int )((int const   )(*(__s1___46 + 3)) -
                                                   (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/ControlData" +
                                                                    3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 878
                tmp___212 = __result___70;
              }
            } else {
#line 878
              tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
            }
          } else {
#line 878
            tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
          }
        } else {
#line 878
          tmp___212 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/ControlData");
        }
      }
    }
#line 878
    if (tmp___212 == 0) {
#line 879
      lzx_control = read_sys_control(fd, itsf_hdr, entry, m_area, m_length);
    } else {
#line 880
      tmp___174 = __builtin_constant_p((int )entry->name);
#line 880
      if (tmp___174) {
#line 880
        tmp___175 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Content");
#line 880
        if (tmp___175) {
#line 880
          __s1_len___0 = strlen((char const   *)entry->name);
#line 880
          __s2_len___0 = strlen("::DataSpace/Storage/MSCompressed/Content");
#line 880
          if (! ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                 1U)) {
            goto _L___36;
          } else {
#line 880
            if (__s1_len___0 >= 4U) {
              _L___36: 
#line 880
              if (! ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Content" +
                                                      1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Content") ==
                     1U)) {
#line 880
                tmp___176 = 1;
              } else {
#line 880
                if (__s2_len___0 >= 4U) {
#line 880
                  tmp___176 = 1;
                } else {
#line 880
                  tmp___176 = 0;
                }
              }
            } else {
#line 880
              tmp___176 = 0;
            }
          }
#line 880
          if (tmp___176) {
#line 880
            tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
          } else {
            goto _L___38;
          }
        } else {
          goto _L___38;
        }
      } else {
        _L___38: 
#line 880
        tmp___173 = __builtin_constant_p((int )entry->name);
#line 880
        if (tmp___173) {
#line 880
          if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
              1U) {
#line 880
            __s1_len___0 = strlen((char const   *)entry->name);
#line 880
            if (__s1_len___0 < 4U) {
#line 880
              tmp___162 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Content");
#line 880
              if (tmp___162) {
#line 880
                if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Content" +
                                                     1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Content") ==
                    1U) {
#line 880
                  tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
                } else {
                  goto _L___31;
                }
              } else {
                _L___31: 
#line 880
                __s2___14 = (unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content";
#line 880
                __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                        0)) - (int const   )(*(__s2___14 +
                                                                               0)));
#line 880
                if (__s1_len___0 > 0U) {
#line 880
                  if (__result___42 == 0) {
#line 880
                    __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                            1)) - (int const   )(*(__s2___14 +
                                                                                   1)));
#line 880
                    if (__s1_len___0 > 1U) {
#line 880
                      if (__result___42 == 0) {
#line 880
                        __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                2)) - (int const   )(*(__s2___14 +
                                                                                       2)));
#line 880
                        if (__s1_len___0 > 2U) {
#line 880
                          if (__result___42 == 0) {
#line 880
                            __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                    3)) - (int const   )(*(__s2___14 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
#line 880
                tmp___143 = __result___42;
              }
            } else {
              goto _L___35;
            }
          } else {
            goto _L___35;
          }
        } else {
          _L___35: 
#line 880
          tmp___172 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Content");
#line 880
          if (tmp___172) {
#line 880
            if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Content" +
                                                 1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Content") ==
                1U) {
#line 880
              __s2_len___0 = strlen("::DataSpace/Storage/MSCompressed/Content");
#line 880
              if (__s2_len___0 < 4U) {
#line 880
                tmp___171 = __builtin_constant_p((int )entry->name);
#line 880
                if (tmp___171) {
#line 880
                  if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                      1U) {
#line 880
                    tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
                  } else {
                    goto _L___33;
                  }
                } else {
                  _L___33: 
#line 880
                  __s1___30 = (unsigned char const   *)((char const   *)entry->name);
#line 880
                  __result___46 = (int )((int const   )(*(__s1___30 + 0)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                                             0)));
#line 880
                  if (__s2_len___0 > 0U) {
#line 880
                    if (__result___46 == 0) {
#line 880
                      __result___46 = (int )((int const   )(*(__s1___30 + 1)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                                                 1)));
#line 880
                      if (__s2_len___0 > 1U) {
#line 880
                        if (__result___46 == 0) {
#line 880
                          __result___46 = (int )((int const   )(*(__s1___30 + 2)) -
                                                 (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                  2)));
#line 880
                          if (__s2_len___0 > 2U) {
#line 880
                            if (__result___46 == 0) {
#line 880
                              __result___46 = (int )((int const   )(*(__s1___30 +
                                                                      3)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Content" +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 880
                  tmp___143 = __result___46;
                }
              } else {
#line 880
                tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
              }
            } else {
#line 880
              tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
            }
          } else {
#line 880
            tmp___143 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Content");
          }
        }
      }
#line 880
      if (tmp___143 == 0) {
#line 881
        lzx_content = read_sys_content(fd, itsf_hdr, entry);
      } else {
#line 882
        tmp___105 = __builtin_constant_p((int )entry->name);
#line 882
        if (tmp___105) {
#line 882
          tmp___106 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
#line 882
          if (tmp___106) {
#line 882
            __s1_len = strlen((char const   *)entry->name);
#line 882
            __s2_len = strlen("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
#line 882
            if (! ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                   1U)) {
              goto _L___16;
            } else {
#line 882
              if (__s1_len >= 4U) {
                _L___16: 
#line 882
                if (! ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                        1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable") ==
                       1U)) {
#line 882
                  tmp___107 = 1;
                } else {
#line 882
                  if (__s2_len >= 4U) {
#line 882
                    tmp___107 = 1;
                  } else {
#line 882
                    tmp___107 = 0;
                  }
                }
              } else {
#line 882
                tmp___107 = 0;
              }
            }
#line 882
            if (tmp___107) {
#line 882
              tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
#line 882
          tmp___104 = __builtin_constant_p((int )entry->name);
#line 882
          if (tmp___104) {
#line 882
            if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                1U) {
#line 882
              __s1_len = strlen((char const   *)entry->name);
#line 882
              if (__s1_len < 4U) {
#line 882
                tmp___93 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
#line 882
                if (tmp___93) {
#line 882
                  if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                       1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable") ==
                      1U) {
#line 882
                    tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
#line 882
                  __s2___6 = (unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable";
#line 882
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 882
                  if (__s1_len > 0U) {
#line 882
                    if (__result___18 == 0) {
#line 882
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 882
                      if (__s1_len > 1U) {
#line 882
                        if (__result___18 == 0) {
#line 882
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 882
                          if (__s1_len > 2U) {
#line 882
                            if (__result___18 == 0) {
#line 882
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)entry->name) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 882
                  tmp___74 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
#line 882
            tmp___103 = __builtin_constant_p((int )"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
#line 882
            if (tmp___103) {
#line 882
              if ((unsigned int )((void const   *)("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                   1)) - (unsigned int )((void const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable") ==
                  1U) {
#line 882
                __s2_len = strlen("::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
#line 882
                if (__s2_len < 4U) {
#line 882
                  tmp___102 = __builtin_constant_p((int )entry->name);
#line 882
                  if (tmp___102) {
#line 882
                    if ((unsigned int )((void const   *)(entry->name + 1)) - (unsigned int )((void const   *)entry->name) ==
                        1U) {
#line 882
                      tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
#line 882
                    __s1___14 = (unsigned char const   *)((char const   *)entry->name);
#line 882
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                                               0)));
#line 882
                    if (__s2_len > 0U) {
#line 882
                      if (__result___22 == 0) {
#line 882
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                1)));
#line 882
                        if (__s2_len > 1U) {
#line 882
                          if (__result___22 == 0) {
#line 882
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                    2)));
#line 882
                            if (__s2_len > 2U) {
#line 882
                              if (__result___22 == 0) {
#line 882
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 882
                    tmp___74 = __result___22;
                  }
                } else {
#line 882
                  tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
                }
              } else {
#line 882
                tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
              }
            } else {
#line 882
              tmp___74 = __builtin_strcmp(entry->name, "::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable");
            }
          }
        }
#line 882
        if (tmp___74 == 0) {
#line 883
          lzx_reset_table = read_sys_reset_table(fd, itsf_hdr, entry, m_area, m_length);
        }
      }
    }
#line 885
    entry = entry->next;
  }
#line 888
  if (! lzx_content) {
    goto abort;
  } else {
#line 888
    if (! lzx_reset_table) {
      goto abort;
    } else {
#line 888
      if (! lzx_control) {
        goto abort;
      }
    }
  }
#line 892
  switch ((int )lzx_control->window_size) {
  case 32768: 
#line 894
  window_bits = 15;
#line 895
  break;
  case 65536: 
#line 897
  window_bits = 16;
#line 898
  break;
  case 131072: 
#line 900
  window_bits = 17;
#line 901
  break;
  case 262144: 
#line 903
  window_bits = 18;
#line 904
  break;
  case 524288: 
#line 906
  window_bits = 19;
#line 907
  break;
  case 1048576: 
#line 909
  window_bits = 20;
#line 910
  break;
  case 2097152: 
#line 912
  window_bits = 21;
#line 913
  break;
  default: 
#line 915
  cli_dbgmsg("bad control window size: 0x%x\n", lzx_control->window_size);
  goto abort;
  }
#line 919
  if (lzx_control->reset_interval % 32768U) {
#line 920
    cli_dbgmsg("bad reset_interval: 0x%x\n", lzx_control->window_size);
    goto abort;
  }
#line 924
  length = (int )lzx_reset_table->uncom_len;
#line 925
  length = (int )((unsigned int )length + lzx_control->reset_interval);
#line 926
  length = (int )((unsigned int )length & - lzx_control->reset_interval);
#line 928
  com_offset = lzx_content->offset;
#line 929
  cli_dbgmsg("Compressed offset: %llu\n", com_offset);
#line 931
  stream = lzxd_init(mspack_default_system, (struct mspack_file *)(& mf_in), (struct mspack_file *)(& mf_out),
                     window_bits, (int )(lzx_control->reset_interval / 32768U), 4096,
                     (long )length);
#line 934
  lseek(fd, (long )com_offset, 0);
#line 935
  if (! stream) {
#line 936
    cli_dbgmsg("lzxd_init failed\n");
    goto abort;
  }
#line 940
  lzxd_decompress(stream, (long )length);
#line 941
  lzxd_free(stream);
#line 943
  entry = file_l->next;
#line 944
  fclose(mf_out.fh);
#line 945
  mf_out.fh = (FILE *)((void *)0);
#line 948
  mf_out.desc = open((char const   *)(filename), 0);
#line 949
  if (mf_out.desc < 0) {
#line 950
    cli_dbgmsg("re-open output failed\n");
    goto abort;
  }
#line 955
  unlink((char const   *)(filename));
#line 957
  count = 0;
#line 958
  while (entry) {
#line 959
    if (entry->section != 1ULL) {
#line 960
      entry = entry->next;
#line 961
      continue;
    }
#line 963
    tmp___246 = lseek(mf_out.desc, (long )entry->offset, 0);
#line 963
    if (tmp___246 != (long )entry->offset) {
#line 964
      cli_dbgmsg("seek in output failed\n");
#line 965
      entry = entry->next;
#line 966
      continue;
    }
#line 969
    snprintf((char * __restrict  )(filename), 1024U, (char const   * __restrict  )"%s/%d-%llu.chm",
             dirname, count, entry->offset);
#line 970
    ofd = open((char const   *)(filename), 577, 448);
#line 971
    if (ofd < 0) {
#line 972
      entry = entry->next;
#line 973
      continue;
    }
#line 975
    tmp___247 = chm_copy_file_data(mf_out.desc, ofd, entry->length);
#line 975
    if (tmp___247 != entry->length) {
#line 976
      cli_dbgmsg("failed to copy %lu bytes\n", entry->length);
    }
#line 979
    close(ofd);
#line 980
    entry = entry->next;
#line 981
    count ++;
  }
#line 983
  close(mf_out.desc);
#line 984
  retval = 1;
  abort: 
#line 987
  if (lzx_content) {
#line 988
    free((void *)lzx_content);
  }
#line 990
  if (lzx_reset_table) {
#line 991
    free((void *)lzx_reset_table);
  }
#line 993
  if (lzx_control) {
#line 994
    free((void *)lzx_control);
  }
#line 996
  free((void *)mf_in.name);
#line 997
  fclose(mf_in.fh);
#line 998
  free((void *)mf_out.name);
#line 999
  if (mf_out.fh) {
#line 1000
    fclose(mf_out.fh);
  }
#line 1002
  return (retval);
}
}
#line 1007 "chmunpack.c"
int chm_unpack(int fd , char const   *dirname ) 
{ int retval ;
  unsigned char *m_area ;
  off_t m_length ;
  off_t offset ;
  file_list_t *file_l ;
  file_list_t *sys_file_l ;
  struct stat statbuf ;
  itsf_header_t itsf_hdr ;
  itsp_header_t itsp_hdr ;
  uint32_t num_chunks ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1009
  retval = 0;
#line 1010
  m_area = (unsigned char *)((void *)0);
#line 1011
  m_length = 0L;
#line 1021
  file_l = (file_list_t *)cli_malloc(sizeof(file_list_t ));
#line 1022
  if (! file_l) {
#line 1023
    return (0);
  }
#line 1025
  file_l->next = (struct file_list_tag *)((void *)0);
#line 1026
  file_l->name = (unsigned char *)((void *)0);
#line 1027
  sys_file_l = (file_list_t *)cli_malloc(sizeof(file_list_t ));
#line 1028
  if (! sys_file_l) {
#line 1029
    free((void *)file_l);
#line 1030
    return (0);
  }
#line 1032
  sys_file_l->next = (struct file_list_tag *)((void *)0);
#line 1033
  sys_file_l->name = (unsigned char *)((void *)0);
#line 1036
  tmp___2 = fstat__extinline(fd, & statbuf);
#line 1036
  if (tmp___2 == 0) {
#line 1037
    if (statbuf.st_size < 96L) {
      goto abort;
    }
#line 1040
    m_length = statbuf.st_size;
#line 1041
    m_area = (unsigned char *)mmap((void *)0, (unsigned int )m_length, 1, 2, fd, 0L);
#line 1042
    if ((unsigned int )m_area == (unsigned int )((void *)-1)) {
#line 1043
      m_area = (unsigned char *)((void *)0);
    }
  }
#line 1048
  tmp___3 = itsf_read_header(fd, & itsf_hdr, m_area, m_length);
#line 1048
  if (! tmp___3) {
    goto abort;
  }
#line 1051
  itsf_print_header(& itsf_hdr);
#line 1053
  tmp___4 = itsp_read_header(fd, & itsp_hdr, (long )itsf_hdr.dir_offset, m_area, m_length);
#line 1053
  if (! tmp___4) {
    goto abort;
  }
#line 1056
  itsp_print_header(& itsp_hdr);
#line 1058
  offset = (long )(itsf_hdr.dir_offset + 84ULL);
#line 1062
  if (itsp_hdr.index_head > 0) {
#line 1063
    offset = (long )((unsigned long )offset + (unsigned long )((unsigned int )itsp_hdr.index_head *
                                                               itsp_hdr.block_len));
  }
#line 1066
  num_chunks = (unsigned int )((itsp_hdr.index_tail - itsp_hdr.index_head) + 1);
#line 1071
  if (itsf_hdr.version < 3) {
#line 1072
    itsf_hdr.data_offset = (itsf_hdr.dir_offset + 84ULL) + (unsigned long long )(itsp_hdr.block_len *
                                                                                 itsp_hdr.num_blocks);
  }
#line 1075
  while (num_chunks) {
#line 1076
    tmp___5 = read_chunk(fd, offset, itsp_hdr.block_len, m_area, m_length, file_l,
                         sys_file_l);
#line 1076
    if (! tmp___5) {
      goto abort;
    }
#line 1081
    num_chunks --;
#line 1082
    offset = (long )((unsigned long )offset + (unsigned long )itsp_hdr.block_len);
  }
#line 1085
  chm_decompress_stream(fd, dirname, & itsf_hdr, file_l, sys_file_l, m_area, m_length);
#line 1088
  retval = 1;
  abort: 
#line 1090
  free_file_list(file_l);
#line 1091
  free_file_list(sys_file_l);
#line 1094
  if (m_area) {
#line 1095
    munmap((void *)m_area, (unsigned int )m_length);
  }
#line 1098
  return (retval);
}
}
#line 1 "rebuildpe.lo"
#pragma merger(0,"/tmp/cil-6Q5ENQwD.i","-g -O2 -fPIC")
#line 31 "rebuildpe.h"
char *rebuildpe(char *buffer , struct SECTION *sections , int sects , uint32_t base ,
                uint32_t ep , uint32_t ResRva , uint32_t ResSize ) ;
#line 131 "rebuildpe.c"
char *rebuildpe(char *buffer , struct SECTION *sections , int sects , uint32_t base ,
                uint32_t ep , uint32_t ResRva , uint32_t ResSize ) 
{ int i ;
  uint32_t datasize ;
  uint32_t rawbase ;
  char *pefile ;
  char *curpe ;
  struct IMAGE_PE_HEADER *fakepe ;

  {
#line 134
  datasize = 0U;
#line 135
  pefile = (char *)((void *)0);
#line 138
  i = 0;
#line 138
  while (i < sects) {
#line 139
    datasize += (sections + i)->rsz;
#line 138
    i ++;
  }
#line 141
  rawbase = (unsigned int )(456 + 40 * sects);
#line 142
  pefile = (char *)cli_malloc(rawbase + datasize);
#line 142
  if (pefile) {
#line 143
    memcpy((void * __restrict  )pefile, (void const   * __restrict  )"MZ\220\000\002\000\000\000\004\000\017\000\377\377\000\000\260\000\000\000\000\000\000\000@\000\032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\320\000\000\000\016\037\264\t\272\r\000\315!\264L\315!This file was created by ClamAV for internal use and should not be run.\r\nClamAV - A GPL virus scanner - http://www.clamav.net\r\n$\000\000\000PE\000\000L\001\377\377CLAM\000\000\000\000\000\000\000\000\340\000\203\217\v\001\000\000\000\020\000\000\000\020\000\000\000\000\000\000\377\377\377\377\000\020\000\000\000\020\000\000\377\377\377\377\000\020\000\000\000\002\000\000\001\000\000\000\000\000\000\000\003\000\n\000\000\000\000\000\000\020\000\000\000\004\000\000\000\000\000\000\002\000\000\000\000\000\020\000\000\020\000\000\000\000\020\000\000\020\000\000\000\000\000\000\020\000\000\000",
           328U);
#line 145
    fakepe = (struct IMAGE_PE_HEADER *)(pefile + 208);
#line 146
    fakepe->NumberOfSections = EC16((unsigned short )sects);
#line 147
    fakepe->AddressOfEntryPoint = EC32(ep);
#line 148
    fakepe->ImageBase = EC32(base);
#line 149
    memset((void *)(pefile + 328), 0, 128U);
#line 150
    cli_writeint32((pefile + 328) + 16, ResRva);
#line 151
    cli_writeint32((pefile + 328) + 20, ResSize);
#line 152
    curpe = (pefile + 328) + 128;
#line 154
    i = 0;
#line 154
    while (i < sects) {
#line 155
      snprintf((char * __restrict  )curpe, 8U, (char const   * __restrict  )".clam%.2d",
               i + 1);
#line 156
      cli_writeint32(curpe + 8, (sections + i)->vsz);
#line 157
      cli_writeint32(curpe + 12, (sections + i)->rva);
#line 158
      cli_writeint32(curpe + 16, (sections + i)->rsz);
#line 159
      cli_writeint32(curpe + 20, (sections + i)->raw + rawbase);
#line 160
      cli_writeint32(curpe + 24, 0U);
#line 161
      cli_writeint32(curpe + 28, 0U);
#line 162
      cli_writeint32(curpe + 32, 0U);
#line 163
      cli_writeint32(curpe + 36, 4294967295U);
#line 164
      curpe += 40;
#line 154
      i ++;
    }
#line 166
    memcpy((void * __restrict  )curpe, (void const   * __restrict  )buffer, datasize);
  }
#line 169
  return (pefile);
}
}
#line 1 "petite.lo"
#pragma merger(0,"/tmp/cil-MIpQCBof.i","-g -O2 -fPIC")
#line 71 "petite.c"
static int doubledl(char **scur , uint8_t *mydlptr , char *buffer , int buffersize ) 
{ unsigned char mydl ;
  unsigned char olddl ;

  {
#line 73
  mydl = (*mydlptr);
#line 74
  olddl = mydl;
#line 76
  mydl = (unsigned char )((int )mydl * 2);
#line 77
  if (! ((int )olddl & 127)) {
#line 78
    if ((unsigned int )(*scur) < (unsigned int )buffer) {
#line 79
      return (-1);
    } else {
#line 78
      if ((unsigned int )(*scur) >= (unsigned int )((buffer + buffersize) - 1)) {
#line 79
        return (-1);
      }
    }
#line 80
    olddl = (unsigned char )(*((*scur)));
#line 81
    mydl = (unsigned char )((int )olddl * 2 + 1);
#line 82
    (*scur) = (*scur) + 1;
  }
#line 84
  (*mydlptr) = mydl;
#line 85
  return (((int )olddl >> 7) & 1);
}
}
#line 88 "petite.c"
int petite_inflate2x_1to9(char *buf , uint32_t minrva , int bufsz , struct pe_image_section_hdr *sections ,
                          int sectcount , uint32_t Imagebase , uint32_t pep , int desc ,
                          int version , uint32_t ResRva , uint32_t ResSize ) 
{ char *adjbuf ;
  char *packed ;
  uint32_t thisrva ;
  uint32_t bottom ;
  uint32_t enc_ep ;
  uint32_t irva ;
  uint32_t workdone ;
  uint32_t grown ;
  uint32_t skew ;
  int j ;
  int oob ;
  int mangled ;
  int check4resources ;
  struct SECTION *usects ;
  void *tmpsct ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  char *ssrc ;
  char *ddst ;
  uint32_t size ;
  uint32_t srva ;
  int backbytes ;
  int oldback ;
  int backsize ;
  int addsize ;
  int t ;
  int upd ;
  uint32_t trva ;
  uint32_t trsz ;
  uint32_t tvsz ;
  uint32_t virtaddr ;
  uint32_t tmpep ;
  int rndm ;
  int dummy ;
  uint32_t *thunk ;
  uint32_t *imports ;
  uint32_t api ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;
  uint32_t check1 ;
  uint32_t check2 ;
  uint8_t mydl ;
  uint8_t goback ;
  int q ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  uint32_t test1 ;
  uint32_t test2 ;
  int reloc ;
  int32_t tmp___17 ;
  int32_t tmp___18 ;
  int32_t tmp___19 ;
  int32_t tmp___20 ;
  int32_t tmp___21 ;
  int32_t tmp___22 ;
  int32_t tmp___23 ;
  int32_t tmp___24 ;
  int32_t tmp___25 ;

  {
#line 90
  adjbuf = buf - minrva;
#line 91
  packed = (char *)((void *)0);
#line 92
  thisrva = 0U;
#line 92
  bottom = 0U;
#line 92
  enc_ep = 0U;
#line 92
  irva = 0U;
#line 92
  workdone = 0U;
#line 92
  grown = 853U;
#line 92
  skew = 53U;
#line 93
  j = 0;
#line 93
  mangled = 0;
#line 93
  check4resources = 0;
#line 94
  usects = (struct SECTION *)((void *)0);
#line 95
  tmpsct = (void *)0;
#line 108
  if (version == 2) {
#line 109
    tmp = EC32((sections + (sectcount - 1))->VirtualAddress);
#line 109
    packed = (adjbuf + tmp) + 440;
  }
#line 110
  if (version == 1) {
#line 111
    tmp___0 = EC32((sections + (sectcount - 1))->VirtualAddress);
#line 111
    packed = (adjbuf + tmp___0) + 376;
#line 112
    grown = 803U;
#line 113
    skew = 52U;
  }
#line 116
  while (1) {
#line 121
    if ((unsigned int )packed < (unsigned int )buf) {
      goto _L;
    } else {
#line 121
      if ((unsigned int )packed >= (unsigned int )((buf + bufsz) - 4)) {
        _L: 
#line 122
        if (usects) {
#line 123
          free((void *)usects);
        }
#line 124
        return (-1);
      }
    }
#line 126
    srva = (uint32_t )cli_readint32((char const   *)packed);
#line 128
    if (! srva) {
#line 130
      upd = 1;
#line 132
      if (j <= 0) {
#line 133
        return (-1);
      }
#line 136
      while (upd) {
#line 137
        upd = 0;
#line 138
        t = 0;
#line 138
        while (t < j - 1) {
#line 141
          if ((usects + t)->rva <= (usects + (t + 1))->rva) {
            goto __Cont;
          }
#line 143
          trva = (usects + t)->rva;
#line 144
          trsz = (usects + t)->rsz;
#line 145
          tvsz = (usects + t)->vsz;
#line 146
          (usects + t)->rva = (usects + (t + 1))->rva;
#line 147
          (usects + t)->rsz = (usects + (t + 1))->rsz;
#line 148
          (usects + t)->vsz = (usects + (t + 1))->vsz;
#line 149
          (usects + (t + 1))->rva = trva;
#line 150
          (usects + (t + 1))->rsz = trsz;
#line 151
          (usects + (t + 1))->vsz = tvsz;
#line 152
          upd = 1;
          __Cont: 
#line 138
          t ++;
        }
      }
#line 157
      t = 0;
#line 157
      while (t < j - 1) {
#line 158
        if ((usects + t)->vsz != (usects + (t + 1))->rva - (usects + t)->rva) {
#line 159
          (usects + t)->vsz = (usects + (t + 1))->rva - (usects + t)->rva;
        }
#line 157
        t ++;
      }
#line 169
      if (enc_ep) {
#line 170
        virtaddr = (pep + 5U) + Imagebase;
#line 171
        rndm = 0;
#line 171
        dummy = 1;
#line 172
        thunk = (uint32_t *)(adjbuf + irva);
#line 175
        if (version == 2) {
#line 177
          while (1) {
#line 177
            if ((unsigned int )((char *)thunk) >= (unsigned int )buf) {
#line 177
              if ((unsigned int )((char *)thunk) < (unsigned int )((buf + bufsz) -
                                                                   4)) {
#line 177
                if (! dummy) {
#line 177
                  break;
                }
              } else {
#line 177
                break;
              }
            } else {
#line 177
              break;
            }
#line 180
            if (! (*thunk)) {
#line 181
              workdone = 1U;
#line 182
              break;
            }
#line 185
            tmp___1 = thunk;
#line 185
            thunk ++;
#line 185
            tmp___2 = EC32((*tmp___1));
#line 185
            imports = (uint32_t *)(adjbuf + tmp___2);
#line 186
            dummy = 0;
#line 188
            while (1) {
#line 188
              if ((unsigned int )((char *)imports) >= (unsigned int )buf) {
#line 188
                if (! ((unsigned int )((char *)imports) < (unsigned int )((buf + bufsz) -
                                                                          4))) {
#line 188
                  break;
                }
              } else {
#line 188
                break;
              }
#line 189
              dummy = 0;
#line 191
              tmp___3 = imports;
#line 191
              imports ++;
#line 191
              api = EC32((*tmp___3));
#line 191
              if (! api) {
#line 192
                dummy = 1;
#line 193
                break;
              }
#line 195
              if (api != (api | 2147483648U)) {
#line 195
                if (mangled) {
#line 195
                  rndm --;
#line 195
                  if (rndm < 0) {
#line 196
                    api = virtaddr;
#line 197
                    virtaddr += 5U;
#line 198
                    rndm = (int )(virtaddr & 7U);
                  } else {
#line 200
                    api = 3220181815U;
                  }
                } else {
#line 200
                  api = 3220181815U;
                }
              } else {
#line 200
                api = 3220181815U;
              }
#line 202
              tmp___4 = EC32((sections + (sectcount - 1))->VirtualAddress);
#line 202
              if (tmp___4 + Imagebase < api) {
#line 203
                enc_ep --;
              }
#line 204
              if (api < virtaddr) {
#line 205
                enc_ep --;
              }
#line 206
              tmpep = ((enc_ep & 4294967288U) >> 3) & 536870911U;
#line 207
              enc_ep = ((enc_ep & 7U) << 29) | tmpep;
            }
          }
        } else {
#line 211
          workdone = 1U;
        }
#line 212
        enc_ep = (pep + 5U) + enc_ep;
#line 213
        if (workdone == 1U) {
#line 214
          cli_dbgmsg("Petite: Old EP: %x\n", enc_ep);
        } else {
#line 216
          cli_dbgmsg("Petite: In troubles while attempting to decrypt old EP\n");
        }
      }
#line 220
      t = 0;
#line 220
      while (t < j) {
#line 221
        (usects + t)->raw = ((usects + (t - 1))->raw + (usects + (t - 1))->rsz) *
                            (unsigned int )(t > 0);
#line 222
        if ((usects + t)->rsz != 0U) {
#line 223
          memmove((void *)(buf + (usects + t)->raw), (void const   *)(adjbuf + (usects +
                                                                                t)->rva),
                  (usects + t)->rsz);
        }
#line 220
        t ++;
      }
#line 227
      cli_dbgmsg("Petite: Sections dump:\n");
#line 228
      t = 0;
#line 228
      while (t < j) {
#line 229
        cli_dbgmsg("Petite: .SECT%d RVA:%x VSize:%x ROffset: %x, RSize:% x\n", t,
                   (usects + t)->rva, (usects + t)->vsz, (usects + t)->raw, (usects +
                                                                             t)->rsz);
#line 228
        t ++;
      }
#line 230
      ssrc = rebuildpe(buf, usects, j, Imagebase, enc_ep, ResRva, ResSize);
#line 230
      if (ssrc) {
#line 231
        write(desc, (void const   *)ssrc, ((unsigned int )(456 + 40 * j) + (usects +
                                                                            (j - 1))->raw) +
                                          (usects + (j - 1))->rsz);
#line 232
        free((void *)ssrc);
      } else {
#line 234
        cli_dbgmsg("Petite: Rebuilding failed\n");
      }
#line 236
      free((void *)usects);
#line 237
      return ((int )workdone);
    }
#line 241
    size = srva & 2147483647U;
#line 242
    if (srva != size) {
#line 243
      check4resources = 0;
#line 251
      if ((unsigned int )packed < (unsigned int )buf) {
        goto _L___0;
      } else {
#line 251
        if ((unsigned int )packed >= (unsigned int )((buf + bufsz) - 12)) {
          _L___0: 
#line 252
          if (usects) {
#line 253
            free((void *)usects);
          }
#line 254
          return (-1);
        }
      }
#line 257
      tmp___5 = cli_readint32((char const   *)(packed + 8));
#line 257
      bottom = (unsigned int )(tmp___5 + 4);
#line 258
      tmp___6 = cli_readint32((char const   *)(packed + 4));
#line 258
      ssrc = (adjbuf + tmp___6) - (size - 1U) * 4U;
#line 259
      tmp___7 = cli_readint32((char const   *)(packed + 8));
#line 259
      ddst = (adjbuf + tmp___7) - (size - 1U) * 4U;
#line 261
      if ((unsigned int )ssrc < (unsigned int )buf) {
        goto _L___1;
      } else {
#line 261
        if ((unsigned int )(ssrc + size * 4U) >= (unsigned int )(buf + bufsz)) {
          goto _L___1;
        } else {
#line 261
          if ((unsigned int )ddst < (unsigned int )buf) {
            goto _L___1;
          } else {
#line 261
            if ((unsigned int )(ddst + size * 4U) >= (unsigned int )(buf + bufsz)) {
              _L___1: 
#line 262
              if (usects) {
#line 263
                free((void *)usects);
              }
#line 264
              return (-1);
            }
          }
        }
      }
#line 268
      memmove((void *)ddst, (void const   *)ssrc, size * 4U);
#line 269
      packed += 12;
    } else {
#line 272
      mydl = (unsigned char)0;
#line 277
      if ((unsigned int )packed < (unsigned int )buf) {
        goto _L___2;
      } else {
#line 277
        if ((unsigned int )packed >= (unsigned int )((buf + bufsz) - 16)) {
          _L___2: 
#line 278
          if (usects) {
#line 279
            free((void *)usects);
          }
#line 280
          return (-1);
        }
      }
#line 283
      size = (uint32_t )cli_readint32((char const   *)(packed + 4));
#line 284
      packed += 16;
#line 285
      thisrva = (uint32_t )cli_readint32((char const   *)(packed - 8));
#line 288
      tmpsct = realloc((void *)usects, sizeof(struct SECTION ) * (unsigned int )(j +
                                                                                 1));
#line 288
      if (! tmpsct) {
#line 289
        if (usects) {
#line 290
          free((void *)usects);
        }
#line 291
        return (-1);
      }
#line 294
      usects = (struct SECTION *)tmpsct;
#line 296
      (usects + j)->rva = thisrva;
#line 297
      (usects + j)->rsz = size;
#line 298
      if ((int )(bottom - thisrva) > 0) {
#line 299
        (usects + j)->vsz = bottom - thisrva;
      } else {
#line 301
        (usects + j)->vsz = size;
      }
#line 302
      (usects + j)->raw = 0U;
#line 304
      if (! size) {
#line 305
        j ++;
#line 306
        continue;
      }
#line 309
      ssrc = adjbuf + srva;
#line 310
      ddst = adjbuf + thisrva;
#line 316
      if (! check4resources) {
#line 318
        q = 0;
#line 318
        while (q < sectcount) {
#line 319
          tmp___8 = EC32((sections + q)->VirtualAddress);
#line 319
          if (thisrva <= tmp___8) {
            goto __Cont___0;
          } else {
#line 319
            tmp___9 = EC32((sections + q)->VirtualAddress);
#line 319
            tmp___10 = EC32((sections + q)->VirtualSize);
#line 319
            if (thisrva >= tmp___9 + tmp___10) {
              goto __Cont___0;
            }
          }
#line 321
          (usects + j)->rva = EC32((sections + q)->VirtualAddress);
#line 322
          tmp___11 = EC32((sections + q)->VirtualAddress);
#line 322
          (usects + j)->rsz = (thisrva - tmp___11) + size;
#line 323
          break;
          __Cont___0: 
#line 318
          q ++;
        }
      }
#line 328
      j ++;
#line 332
      if (size < 65536U) {
#line 333
        check1 = 4294951008U;
#line 334
        check2 = 4294966368U;
#line 335
        goback = (unsigned char)5;
      } else {
#line 336
        if (size < 262144U) {
#line 337
          check1 = 4294934912U;
#line 338
          check2 = 4294965632U;
#line 339
          goback = (unsigned char)7;
        } else {
#line 341
          check1 = 4294935296U;
#line 342
          check2 = 4294966016U;
#line 343
          goback = (unsigned char)8;
        }
      }
#line 352
      if ((unsigned int )ddst < (unsigned int )buf) {
#line 353
        free((void *)usects);
#line 354
        return (-1);
      } else {
#line 352
        if ((unsigned int )ddst >= (unsigned int )((buf + bufsz) - 1)) {
#line 353
          free((void *)usects);
#line 354
          return (-1);
        } else {
#line 352
          if ((unsigned int )ssrc < (unsigned int )buf) {
#line 353
            free((void *)usects);
#line 354
            return (-1);
          } else {
#line 352
            if ((unsigned int )ssrc >= (unsigned int )((buf + bufsz) - 1)) {
#line 353
              free((void *)usects);
#line 354
              return (-1);
            }
          }
        }
      }
#line 357
      size --;
#line 358
      tmp___12 = ddst;
#line 358
      ddst ++;
#line 358
      tmp___13 = ssrc;
#line 358
      ssrc ++;
#line 358
      (*tmp___12) = (*tmp___13);
#line 359
      backbytes = 0;
#line 360
      oldback = 0;
#line 363
      while (size > 0U) {
#line 364
        oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 365
        if (oob == -1) {
#line 366
          free((void *)usects);
#line 367
          return (-1);
        }
#line 369
        if (! oob) {
#line 370
          if ((unsigned int )ddst < (unsigned int )buf) {
#line 371
            free((void *)usects);
#line 372
            return (-1);
          } else {
#line 370
            if ((unsigned int )ddst >= (unsigned int )((buf + bufsz) - 1)) {
#line 371
              free((void *)usects);
#line 372
              return (-1);
            } else {
#line 370
              if ((unsigned int )ssrc < (unsigned int )buf) {
#line 371
                free((void *)usects);
#line 372
                return (-1);
              } else {
#line 370
                if ((unsigned int )ssrc >= (unsigned int )((buf + bufsz) - 1)) {
#line 371
                  free((void *)usects);
#line 372
                  return (-1);
                }
              }
            }
          }
#line 374
          tmp___14 = ddst;
#line 374
          ddst ++;
#line 374
          tmp___15 = ssrc;
#line 374
          ssrc ++;
#line 374
          (*tmp___14) = (char )((unsigned int )(*tmp___15) ^ (size & 255U));
#line 375
          size --;
        } else {
#line 377
          addsize = 0;
#line 378
          backbytes ++;
#line 379
          while (1) {
#line 380
            oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 380
            if (oob == -1) {
#line 381
              free((void *)usects);
#line 382
              return (-1);
            }
#line 384
            backbytes = backbytes * 2 + oob;
#line 385
            oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 385
            if (oob == -1) {
#line 386
              free((void *)usects);
#line 387
              return (-1);
            }
#line 389
            if (! oob) {
#line 390
              break;
            }
          }
#line 392
          backbytes -= 3;
#line 393
          if (backbytes >= 0) {
#line 394
            backsize = (int )goback;
#line 395
            while (1) {
#line 396
              oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 396
              if (oob == -1) {
#line 397
                free((void *)usects);
#line 398
                return (-1);
              }
#line 400
              backbytes = backbytes * 2 + oob;
#line 401
              backsize --;
#line 395
              if (! backsize) {
#line 395
                break;
              }
            }
#line 403
            backbytes = (int )((unsigned int )backbytes ^ 4294967295U);
#line 404
            addsize += (1 + (backbytes < (int )check2)) + (backbytes < (int )check1);
#line 405
            oldback = backbytes;
          } else {
#line 407
            backsize = backbytes + 1;
#line 408
            backbytes = oldback;
          }
#line 411
          oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 411
          if (oob == -1) {
#line 412
            free((void *)usects);
#line 413
            return (-1);
          }
#line 415
          backsize = backsize * 2 + oob;
#line 416
          oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 416
          if (oob == -1) {
#line 417
            free((void *)usects);
#line 418
            return (-1);
          }
#line 420
          backsize = backsize * 2 + oob;
#line 421
          if (! backsize) {
#line 422
            backsize ++;
#line 423
            while (1) {
#line 424
              oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 424
              if (oob == -1) {
#line 425
                free((void *)usects);
#line 426
                return (-1);
              }
#line 428
              backsize = backsize * 2 + oob;
#line 429
              oob = doubledl(& ssrc, & mydl, buf, bufsz);
#line 429
              if (oob == -1) {
#line 430
                free((void *)usects);
#line 431
                return (-1);
              }
#line 433
              if (! oob) {
#line 434
                break;
              }
            }
#line 436
            backsize += 2;
          }
#line 438
          backsize += addsize;
#line 439
          size -= (unsigned int )backsize;
#line 440
          if ((unsigned int )ddst < (unsigned int )buf) {
#line 441
            free((void *)usects);
#line 442
            return (-1);
          } else {
#line 440
            if ((unsigned int )(ddst + backsize) >= (unsigned int )(buf + bufsz)) {
#line 441
              free((void *)usects);
#line 442
              return (-1);
            } else {
#line 440
              if ((unsigned int )(ddst + backbytes) < (unsigned int )buf) {
#line 441
                free((void *)usects);
#line 442
                return (-1);
              } else {
#line 440
                if ((unsigned int )((ddst + backbytes) + backsize) >= (unsigned int )(buf +
                                                                                      bufsz)) {
#line 441
                  free((void *)usects);
#line 442
                  return (-1);
                }
              }
            }
          }
#line 444
          while (1) {
#line 444
            tmp___16 = backsize;
#line 444
            backsize --;
#line 444
            if (! tmp___16) {
#line 444
              break;
            }
#line 445
            (*ddst) = (*(ddst + backbytes));
#line 446
            ddst ++;
          }
#line 448
          backbytes = 0;
#line 449
          backsize = 0;
        }
      }
#line 457
      if (j) {
#line 457
        if ((usects + (j - 1))->rsz > grown) {
#line 457
          tmp___22 = cli_readint32((char const   *)(((ddst - grown) + 5) + 79));
#line 457
          if (tmp___22 == 1683931187) {
#line 457
            tmp___23 = cli_readint32((char const   *)((((ddst - grown) + 5) + 79) +
                                                      4));
#line 457
            if (tmp___23 == 462100619) {
              goto _L___3;
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else {
          _L___5: 
#line 457
          if ((usects + (j - 1))->rsz > grown + skew) {
#line 457
            tmp___24 = cli_readint32((char const   *)((((ddst - grown) + 5) + 79) -
                                                      skew));
#line 457
            if (tmp___24 == 1683931187) {
#line 457
              tmp___25 = cli_readint32((char const   *)(((((ddst - grown) + 5) + 79) +
                                                         4) - skew));
#line 457
              if (tmp___25 == 462100619) {
                _L___3: 
#line 472
                tmp___17 = cli_readint32((char const   *)((((ddst - grown) + 5) +
                                                           79) - skew));
#line 472
                reloc = (int )(skew * (unsigned int )(tmp___17 == 1683931187));
#line 475
                tmp___18 = cli_readint32((char const   *)((((ddst - grown) + 15) -
                                                           8) - reloc));
#line 475
                test1 = (unsigned int )tmp___18 ^ 2640732586U;
#line 476
                tmp___19 = cli_readint32((char const   *)((((ddst - grown) + 15) -
                                                           4) - reloc));
#line 476
                test2 = (unsigned int )tmp___19 ^ 3909665923U;
#line 477
                cli_dbgmsg("Petite: Found petite code in sect%d(%x). Let\'s strip it.\n",
                           j - 1, (usects + (j - 1))->rva);
#line 478
                if (test1 == test2) {
#line 479
                  irva = (uint32_t )cli_readint32((char const   *)(((ddst - grown) +
                                                                    289) - reloc));
#line 480
                  tmp___20 = cli_readint32((char const   *)(((ddst - grown) + 15) -
                                                            reloc));
#line 480
                  enc_ep = (unsigned int )tmp___20 ^ test1;
#line 481
                  tmp___21 = cli_readint32((char const   *)(((ddst - grown) + 448) -
                                                            reloc));
#line 481
                  mangled = (unsigned int )tmp___21 != 2425393296U;
#line 482
                  cli_dbgmsg("Petite: Encrypted EP: %x | Array of imports: %x\n",
                             enc_ep, irva);
                }
#line 484
                (usects + (j - 1))->rsz = (usects + (j - 1))->rsz - (grown + (unsigned int )reloc);
              }
            }
          }
        }
      }
#line 487
      check4resources ++;
    }
  }
#line 490
  return (0);
}
}
#line 1 "fsg.lo"
#pragma merger(0,"/tmp/cil-2VAfpN9j.i","-g -O2 -fPIC")
#line 66 "fsg.c"
static int doubledl___0(char **scur , uint8_t *mydlptr , char *buffer , int buffersize ) 
{ unsigned char mydl ;
  unsigned char olddl ;

  {
#line 68
  mydl = (*mydlptr);
#line 69
  olddl = mydl;
#line 71
  mydl = (unsigned char )((int )mydl * 2);
#line 72
  if (! ((int )olddl & 127)) {
#line 73
    if ((unsigned int )(*scur) < (unsigned int )buffer) {
#line 74
      return (-1);
    } else {
#line 73
      if ((unsigned int )(*scur) >= (unsigned int )((buffer + buffersize) - 1)) {
#line 74
        return (-1);
      }
    }
#line 75
    olddl = (unsigned char )(*((*scur)));
#line 76
    mydl = (unsigned char )((int )olddl * 2 + 1);
#line 77
    (*scur) = (*scur) + 1;
  }
#line 79
  (*mydlptr) = mydl;
#line 80
  return (((int )olddl >> 7) & 1);
}
}
#line 83 "fsg.c"
static int unfsg(char *source , char *dest , int ssize , int dsize , char **endsrc ,
                 char **enddst ) 
{ uint8_t mydl ;
  uint32_t backbytes ;
  uint32_t backsize ;
  uint32_t oldback ;
  char *csrc ;
  char *cdst ;
  int oob ;
  int lostbit ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 84
  mydl = (unsigned char)128;
#line 85
  oldback = 0U;
#line 86
  csrc = source;
#line 86
  cdst = dest;
#line 87
  lostbit = 1;
#line 90
  tmp = cdst;
#line 90
  cdst ++;
#line 90
  tmp___0 = csrc;
#line 90
  csrc ++;
#line 90
  (*tmp) = (*tmp___0);
#line 92
  while (1) {
#line 93
    oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 93
    if (oob) {
#line 94
      if (oob == -1) {
#line 95
        return (-1);
      }
#line 97
      backsize = 0U;
#line 98
      oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 98
      if (oob) {
#line 99
        if (oob == -1) {
#line 100
          return (-1);
        }
#line 102
        backbytes = 0U;
#line 103
        oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 103
        if (oob) {
#line 104
          if (oob == -1) {
#line 105
            return (-1);
          }
#line 107
          lostbit = 1;
#line 108
          backsize ++;
#line 109
          backbytes = 16U;
#line 110
          while (backbytes < 256U) {
#line 111
            oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 111
            if (oob == -1) {
#line 112
              return (-1);
            }
#line 113
            backbytes = backbytes * 2U + (unsigned int )oob;
          }
#line 115
          backbytes &= 255U;
#line 116
          if (! backbytes) {
#line 117
            if ((unsigned int )cdst >= (unsigned int )(dest + dsize)) {
#line 118
              return (-1);
            }
#line 119
            tmp___1 = cdst;
#line 119
            cdst ++;
#line 119
            (*tmp___1) = (char)0;
#line 120
            continue;
          }
        } else {
#line 126
          if ((unsigned int )csrc >= (unsigned int )(source + ssize)) {
#line 127
            return (-1);
          }
#line 128
          backbytes = (unsigned int )(*((unsigned char *)csrc));
#line 129
          backsize = backsize * 2U + (backbytes & 1U);
#line 130
          backbytes = (backbytes & 255U) >> 1;
#line 131
          csrc ++;
#line 132
          if (! backbytes) {
#line 133
            break;
          }
#line 134
          backsize += 2U;
#line 135
          oldback = backbytes;
#line 136
          lostbit = 0;
        }
      } else {
#line 140
        backsize = 1U;
#line 141
        while (1) {
#line 142
          oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 142
          if (oob == -1) {
#line 143
            return (-1);
          }
#line 144
          backsize = backsize * 2U + (unsigned int )oob;
#line 145
          oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 145
          if (oob == -1) {
#line 146
            return (-1);
          }
#line 141
          if (! oob) {
#line 141
            break;
          }
        }
#line 149
        backsize = (backsize - 1U) - (unsigned int )lostbit;
#line 150
        if (! backsize) {
#line 152
          backsize = 1U;
#line 153
          while (1) {
#line 154
            oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 154
            if (oob == -1) {
#line 155
              return (-1);
            }
#line 156
            backsize = backsize * 2U + (unsigned int )oob;
#line 157
            oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 157
            if (oob == -1) {
#line 158
              return (-1);
            }
#line 153
            if (! oob) {
#line 153
              break;
            }
          }
#line 161
          backbytes = oldback;
        } else {
#line 164
          if ((unsigned int )csrc >= (unsigned int )(source + ssize)) {
#line 165
            return (-1);
          }
#line 166
          backbytes = (unsigned int )(*((unsigned char *)csrc));
#line 167
          backbytes += (backsize - 1U) << 8;
#line 168
          backsize = 1U;
#line 169
          csrc ++;
#line 170
          while (1) {
#line 171
            oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 171
            if (oob == -1) {
#line 172
              return (-1);
            }
#line 173
            backsize = backsize * 2U + (unsigned int )oob;
#line 174
            oob = doubledl___0(& csrc, & mydl, source, ssize);
#line 174
            if (oob == -1) {
#line 175
              return (-1);
            }
#line 170
            if (! oob) {
#line 170
              break;
            }
          }
#line 178
          if (backbytes >= 32000U) {
#line 179
            backsize ++;
          }
#line 180
          if (backbytes >= 1280U) {
#line 181
            backsize ++;
          }
#line 182
          if (backbytes <= 127U) {
#line 183
            backsize += 2U;
          }
#line 185
          oldback = backbytes;
        }
#line 187
        lostbit = 0;
      }
#line 189
      if ((unsigned int )(cdst - backbytes) < (unsigned int )dest) {
#line 190
        return (-1);
      } else {
#line 189
        if ((unsigned int )(cdst + backsize) >= (unsigned int )(dest + dsize)) {
#line 190
          return (-1);
        }
      }
#line 191
      while (1) {
#line 191
        tmp___2 = backsize;
#line 191
        backsize --;
#line 191
        if (! tmp___2) {
#line 191
          break;
        }
#line 192
        (*cdst) = (*(cdst - backbytes));
#line 193
        cdst ++;
      }
    } else {
#line 198
      if ((unsigned int )cdst < (unsigned int )dest) {
#line 199
        return (-1);
      } else {
#line 198
        if ((unsigned int )cdst >= (unsigned int )(dest + dsize)) {
#line 199
          return (-1);
        } else {
#line 198
          if ((unsigned int )csrc < (unsigned int )source) {
#line 199
            return (-1);
          } else {
#line 198
            if ((unsigned int )csrc >= (unsigned int )(source + ssize)) {
#line 199
              return (-1);
            }
          }
        }
      }
#line 200
      tmp___3 = cdst;
#line 200
      cdst ++;
#line 200
      tmp___4 = csrc;
#line 200
      csrc ++;
#line 200
      (*tmp___3) = (*tmp___4);
#line 201
      lostbit = 1;
    }
  }
#line 205
  (*endsrc) = csrc;
#line 206
  (*enddst) = cdst;
#line 207
  return (0);
}
}
#line 210 "fsg.c"
int unfsg_200(char *source , char *dest , int ssize , int dsize ) 
{ char *fake ;
  int tmp ;

  {
#line 213
  tmp = unfsg(source, dest, ssize, dsize, & fake, & fake);
#line 213
  return (tmp);
}
}
#line 216 "fsg.c"
int unfsg_133(char *source , char *dest , int ssize , int dsize , struct SECTION *sections ,
              int sectcount , uint32_t base , uint32_t ep , int file ) 
{ char *tsrc ;
  char *tdst ;
  int i ;
  int upd ;
  int offs ;
  int lastsz ;
  char *startd ;
  int tmp ;
  uint32_t trva ;
  uint32_t trsz ;
  uint32_t traw ;

  {
#line 217
  tsrc = source;
#line 217
  tdst = dest;
#line 218
  upd = 1;
#line 218
  offs = 0;
#line 218
  lastsz = dsize;
#line 220
  i = 0;
#line 220
  while (i <= sectcount) {
#line 221
    startd = tdst;
#line 222
    tmp = unfsg(tsrc, tdst, (tsrc - source) + ssize, (tdst - dest) + dsize, & tsrc,
                & tdst);
#line 222
    if (tmp == -1) {
#line 223
      return (-1);
    }
#line 226
    (sections + i)->raw = (unsigned int )offs;
#line 227
    (sections + i)->rsz = (unsigned int )(tdst - startd);
#line 229
    offs += tdst - startd;
#line 220
    i ++;
  }
#line 233
  while (upd) {
#line 234
    upd = 0;
#line 235
    i = 0;
#line 235
    while (i < sectcount) {
#line 238
      if ((sections + i)->rva < (sections + (i + 1))->rva) {
        goto __Cont;
      }
#line 240
      trva = (sections + i)->rva;
#line 241
      traw = (sections + i)->raw;
#line 242
      trsz = (sections + i)->rsz;
#line 243
      (sections + i)->rva = (sections + (i + 1))->rva;
#line 244
      (sections + i)->rsz = (sections + (i + 1))->rsz;
#line 245
      (sections + i)->raw = (sections + (i + 1))->raw;
#line 246
      (sections + (i + 1))->rva = trva;
#line 247
      (sections + (i + 1))->raw = traw;
#line 248
      (sections + (i + 1))->rsz = trsz;
#line 249
      upd = 1;
      __Cont: 
#line 235
      i ++;
    }
  }
#line 254
  i = 0;
#line 254
  while (i <= sectcount) {
#line 255
    if (i != sectcount) {
#line 256
      (sections + i)->vsz = (sections + (i + 1))->rva - (sections + i)->rva;
#line 257
      lastsz = (int )((unsigned int )lastsz - ((sections + (i + 1))->rva - (sections +
                                                                            i)->rva));
    } else {
#line 260
      (sections + i)->vsz = (unsigned int )lastsz;
    }
#line 262
    cli_dbgmsg("FSG: .SECT%d RVA:%x VSize:%x ROffset: %x, RSize:% x\n", i, (sections +
                                                                            i)->rva,
               (sections + i)->vsz, (sections + i)->raw, (sections + i)->rsz);
#line 254
    i ++;
  }
#line 265
  tsrc = rebuildpe(dest, sections, sectcount + 1, base, ep, 0U, 0U);
#line 265
  if (tsrc) {
#line 266
    write(file, (void const   *)tsrc, (unsigned int )((456 + 40 * (sectcount + 1)) +
                                                      offs));
#line 267
    free((void *)tsrc);
  } else {
#line 269
    free((void *)tsrc);
#line 270
    cli_dbgmsg("FSG: Rebuilding failed\n");
#line 271
    return (0);
  }
#line 274
  return (1);
}
}
#line 1 "line.lo"
#pragma merger(0,"/tmp/cil-NCBuzdfd.i","-g -O2 -fPIC")
#line 110 "line.c"
line_t *lineCreate(char const   *data ) 
{ size_t size ;
  size_t tmp ;
  line_t *ret ;
  line_t *tmp___0 ;

  {
#line 113
  tmp = strlen(data);
#line 113
  size = tmp;
#line 114
  tmp___0 = (line_t *)cli_malloc(size + 2U);
#line 114
  ret = tmp___0;
#line 116
  if ((unsigned int )ret == (unsigned int )((void *)0)) {
#line 117
    return ((line_t *)((void *)0));
  }
#line 119
  (*(ret + 0)) = (char)1;
#line 121
  memcpy((void * __restrict  )(ret + 1), (void const   * __restrict  )data, size);
#line 122
  (*(ret + (size + 1U))) = (char )'\000';
#line 124
  return (ret);
}
}
#line 127 "line.c"
line_t *lineLink(line_t *line ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  line_t *tmp___1 ;

  {
#line 131
  if ((int )((unsigned char )(*(line + 0))) == 255) {
#line 132
    tmp = lineGetData((line_t const   *)line);
#line 132
    cli_dbgmsg("lineLink: linkcount too large (%s)\n", tmp);
#line 133
    tmp___0 = lineGetData((line_t const   *)line);
#line 133
    tmp___1 = lineCreate(tmp___0);
#line 133
    return (tmp___1);
  }
#line 135
  (*(line + 0)) = (char )((int )(*(line + 0)) + 1);
#line 137
  return (line);
}
}
#line 140 "line.c"
line_t *lineUnlink(line_t *line ) 
{ 

  {
#line 145
  (*(line + 0)) = (char )((int )(*(line + 0)) - 1);
#line 145
  if ((int )(*(line + 0)) == 0) {
#line 146
    free((void *)line);
#line 147
    return ((line_t *)((void *)0));
  }
#line 149
  return (line);
}
}
#line 152 "line.c"
char const   *lineGetData(line_t const   *line ) 
{ line_t const   *tmp ;

  {
#line 155
  if (line) {
#line 155
    tmp = line + 1;
  } else {
#line 155
    tmp = (line_t const   *)((void *)0);
  }
#line 155
  return (tmp);
}
}
#line 158 "line.c"
unsigned char lineGetRefCount(line_t const   *line ) 
{ 

  {
#line 161
  return ((unsigned char )(*(line + 0)));
}
}
#line 1 "untar.lo"
#pragma merger(0,"/tmp/cil-pBK53o0L.i","-g -O2 -fPIC")
#line 122 "untar.c"
static int octal(char const   *str ) 
{ int ret ;

  {
#line 125
  ret = -1;
#line 127
  sscanf((char const   * __restrict  )str, (char const   * __restrict  )"%o", (unsigned int *)(& ret));
#line 128
  return (ret);
}
}
#line 131 "untar.c"
int cli_untar(char const   *dir , int desc , unsigned int posix ) 
{ int size ;
  int in_block ;
  char fullname[256] ;
  FILE *outfile ;
  char const   *tmp ;
  char block[512] ;
  int nread ;
  int tmp___0 ;
  char type ;
  char const   *suffix ;
  size_t suffixLen ;
  int fd ;
  int directory ;
  char magic[7] ;
  char name[101] ;
  char osize[13] ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___56 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  size_t tmp___74 ;
  int nbytes ;
  int tmp___75 ;
  int nwritten ;
  int tmp___76 ;
  int tmp___77 ;

  {
#line 134
  size = 0;
#line 135
  in_block = 0;
#line 137
  outfile = (FILE *)((void *)0);
#line 139
  if (dir) {
#line 139
    tmp = dir;
  } else {
#line 139
    tmp = "";
  }
#line 139
  cli_dbgmsg("In untar(%s, %d)\n", tmp, desc);
#line 141
  while (1) {
#line 143
    tmp___0 = cli_readn(desc, (void *)(block), sizeof(block));
#line 143
    nread = tmp___0;
#line 145
    if (! in_block) {
#line 145
      if (nread == 0) {
#line 146
        break;
      }
    }
#line 148
    if (nread < 0) {
#line 149
      if (outfile) {
#line 150
        fclose(outfile);
      }
#line 151
      cli_errmsg("cli_untar: block read error\n");
#line 152
      return (-12);
    }
#line 155
    if (! in_block) {
#line 158
      suffixLen = 0U;
#line 162
      if (outfile) {
#line 163
        tmp___1 = fclose(outfile);
#line 163
        if (tmp___1) {
#line 164
          cli_errmsg("cli_untar: cannot close file %s\n", fullname);
#line 166
          return (-12);
        }
#line 168
        outfile = (FILE *)0;
      }
#line 171
      if ((int )block[0] == 0) {
#line 172
        break;
      }
#line 175
      if (posix) {
#line 176
        __builtin_strncpy(magic, block + 257, 5);
#line 177
        magic[5] = (char )'\000';
#line 178
        tmp___68 = __builtin_constant_p((int )(magic));
#line 178
        if (tmp___68) {
#line 178
          tmp___69 = __builtin_constant_p((int )"ustar");
#line 178
          if (tmp___69) {
#line 178
            __s1_len = strlen((char const   *)(magic));
#line 178
            __s2_len = strlen("ustar");
#line 178
            if (! ((unsigned int )((void const   *)(magic + 1)) - (unsigned int )((void const   *)(magic)) ==
                   1U)) {
              goto _L___16;
            } else {
#line 178
              if (__s1_len >= 4U) {
                _L___16: 
#line 178
                if (! ((unsigned int )((void const   *)("ustar" + 1)) - (unsigned int )((void const   *)"ustar") ==
                       1U)) {
#line 178
                  tmp___70 = 1;
                } else {
#line 178
                  if (__s2_len >= 4U) {
#line 178
                    tmp___70 = 1;
                  } else {
#line 178
                    tmp___70 = 0;
                  }
                }
              } else {
#line 178
                tmp___70 = 0;
              }
            }
#line 178
            if (tmp___70) {
#line 178
              tmp___37 = __builtin_strcmp(magic, "ustar");
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
#line 178
          tmp___67 = __builtin_constant_p((int )(magic));
#line 178
          if (tmp___67) {
#line 178
            if ((unsigned int )((void const   *)(magic + 1)) - (unsigned int )((void const   *)(magic)) ==
                1U) {
#line 178
              __s1_len = strlen((char const   *)(magic));
#line 178
              if (__s1_len < 4U) {
#line 178
                tmp___56 = __builtin_constant_p((int )"ustar");
#line 178
                if (tmp___56) {
#line 178
                  if ((unsigned int )((void const   *)("ustar" + 1)) - (unsigned int )((void const   *)"ustar") ==
                      1U) {
#line 178
                    tmp___37 = __builtin_strcmp(magic, "ustar");
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
#line 178
                  __s2___6 = (unsigned char const   *)"ustar";
#line 178
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
#line 178
                  if (__s1_len > 0U) {
#line 178
                    if (__result___18 == 0) {
#line 178
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
#line 178
                      if (__s1_len > 1U) {
#line 178
                        if (__result___18 == 0) {
#line 178
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
#line 178
                          if (__s1_len > 2U) {
#line 178
                            if (__result___18 == 0) {
#line 178
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(magic)) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
#line 178
                  tmp___37 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
#line 178
            tmp___66 = __builtin_constant_p((int )"ustar");
#line 178
            if (tmp___66) {
#line 178
              if ((unsigned int )((void const   *)("ustar" + 1)) - (unsigned int )((void const   *)"ustar") ==
                  1U) {
#line 178
                __s2_len = strlen("ustar");
#line 178
                if (__s2_len < 4U) {
#line 178
                  tmp___65 = __builtin_constant_p((int )(magic));
#line 178
                  if (tmp___65) {
#line 178
                    if ((unsigned int )((void const   *)(magic + 1)) - (unsigned int )((void const   *)(magic)) ==
                        1U) {
#line 178
                      tmp___37 = __builtin_strcmp(magic, "ustar");
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
#line 178
                    __s1___14 = (unsigned char const   *)((char const   *)(magic));
#line 178
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"ustar" +
                                                                                               0)));
#line 178
                    if (__s2_len > 0U) {
#line 178
                      if (__result___22 == 0) {
#line 178
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)"ustar" +
                                                                1)));
#line 178
                        if (__s2_len > 1U) {
#line 178
                          if (__result___22 == 0) {
#line 178
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)"ustar" +
                                                                    2)));
#line 178
                            if (__s2_len > 2U) {
#line 178
                              if (__result___22 == 0) {
#line 178
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)"ustar" +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
#line 178
                    tmp___37 = __result___22;
                  }
                } else {
#line 178
                  tmp___37 = __builtin_strcmp(magic, "ustar");
                }
              } else {
#line 178
                tmp___37 = __builtin_strcmp(magic, "ustar");
              }
            } else {
#line 178
              tmp___37 = __builtin_strcmp(magic, "ustar");
            }
          }
        }
#line 178
        if (tmp___37 != 0) {
#line 179
          cli_dbgmsg("Incorrect magic string \'%s\' in tar header\n", magic);
#line 180
          return (-13);
        }
      }
#line 184
      type = block[156];
#line 189
      switch ((int )type) {
      case 48: ;
      case 0: ;
      case 55: 
#line 193
      directory = 0;
#line 194
      break;
      case 49: ;
      case 53: ;
      case 50: ;
      case 51: ;
      case 52: ;
      case 54: 
#line 201
      directory = 1;
#line 202
      break;
      case 76: 
#line 204
      cli_errmsg("cli_untar: only standard TAR files are currently supported\n", type);
#line 205
      return (-13);
      default: 
#line 212
      cli_dbgmsg("cli_untar: unknown type flag %c\n", type);
#line 219
      return (0);
      }
#line 222
      if (directory) {
#line 223
        in_block = 0;
        goto __Cont;
      }
#line 227
      __builtin_strncpy(name, block, 100);
#line 228
      name[100] = (char )'\000';
#line 234
      sanitiseName(name);
#line 235
      suffix = strrchr((char const   *)(name), '.');
#line 236
      if ((unsigned int )suffix == (unsigned int )((void *)0)) {
#line 237
        suffix = "";
      } else {
#line 239
        suffixLen = strlen(suffix);
#line 240
        if (suffixLen > 4U) {
#line 242
          suffix = "";
#line 243
          suffixLen = 0U;
        }
      }
#line 246
      tmp___71 = strlen(dir);
#line 246
      snprintf((char * __restrict  )(fullname), (sizeof(fullname) - 1U) - suffixLen,
               (char const   * __restrict  )"%s/%.*sXXXXXX", dir, (int )(((sizeof(fullname) -
                                                                           9U) - suffixLen) -
                                                                         tmp___71),
               name);
#line 249
      fd = mkstemp(fullname);
#line 255
      if (fd < 0) {
#line 256
        tmp___72 = __errno_location();
#line 256
        tmp___73 = strerror((*tmp___72));
#line 256
        cli_errmsg("Can\'t create temporary file %s: %s\n", fullname, tmp___73);
#line 257
        tmp___74 = strlen((char const   *)(fullname));
#line 257
        cli_dbgmsg("%lu %d %d\n", suffixLen, sizeof(fullname), tmp___74);
#line 258
        return (-1);
      }
#line 261
      cli_dbgmsg("cli_untar: extracting %s\n", fullname);
#line 263
      in_block = 1;
#line 264
      outfile = fdopen(fd, "wb");
#line 264
      if ((unsigned int )outfile == (unsigned int )((void *)0)) {
#line 265
        cli_errmsg("cli_untar: cannot create file %s\n", fullname);
#line 267
        close(fd);
#line 268
        return (-1);
      }
#line 271
      __builtin_strncpy(osize, block + 124, 12);
#line 272
      osize[12] = (char )'\000';
#line 273
      size = octal((char const   *)(osize));
#line 274
      if (size < 0) {
#line 275
        cli_errmsg("Invalid size in tar header\n");
#line 276
        fclose(outfile);
#line 277
        return (-13);
      }
#line 279
      cli_dbgmsg("cli_untar: size = %d\n", size);
    } else {
#line 281
      if (size > 512) {
#line 281
        tmp___75 = 512;
      } else {
#line 281
        tmp___75 = size;
      }
#line 281
      nbytes = tmp___75;
#line 282
      tmp___76 = (int )fwrite((void const   * __restrict  )(block), 1U, (unsigned int )nbytes,
                              (FILE * __restrict  )outfile);
#line 282
      nwritten = tmp___76;
#line 284
      if (nwritten != nbytes) {
#line 285
        cli_errmsg("cli_untar: only wrote %d bytes to file %s (out of disk space?)\n",
                   nwritten, fullname);
#line 287
        fclose(outfile);
#line 288
        return (-12);
      }
#line 290
      size -= nbytes;
    }
#line 292
    if (size == 0) {
#line 293
      in_block = 0;
    }
    __Cont: ;
  }
#line 295
  if (outfile) {
#line 296
    tmp___77 = fclose(outfile);
#line 296
    return (tmp___77);
  }
#line 298
  return (0);
}
}
#line 1 "special.lo"
#pragma merger(0,"/tmp/cil-UwLK3OeV.i","-g -O2 -fPIC")
#line 56 "special.c"
int cli_check_mydoom_log(int desc , char const   **virname ) 
{ int32_t record[8] ;
  int32_t check ;
  int i ;
  int retval ;
  int j ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___0 ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  int tmp___1 ;

  {
#line 59
  retval = 1;
#line 61
  cli_dbgmsg("in cli_check_mydoom_log()\n");
#line 64
  j = 0;
#line 64
  while (j < 5) {
#line 65
    tmp = cli_readn(desc, (void *)(& record), 32U);
#line 65
    if (tmp != 32) {
#line 66
      break;
    }
#line 70
    __x = (unsigned int )record[0];
#line 70
    tmp___0 = __builtin_constant_p((int )__x);
#line 70
    if (tmp___0) {
#line 70
      __v = ((((__x & 4278190080U) >> 24) | ((__x & 16711680U) >> 8)) | ((__x & 65280U) <<
                                                                         8)) | ((__x &
                                                                                 255U) <<
                                                                                24);
    } else {
#line 70
      __asm__  ("rorw $8, %w0;"
                "rorl $16, %0;"
                "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
    }
#line 70
    record[0] = (int )(~ __v);
#line 71
    cli_dbgmsg("Mydoom: key: %lu\n", record[0]);
#line 72
    check = 0;
#line 73
    i = 1;
#line 73
    while (i < 8) {
#line 74
      __x___0 = (unsigned int )record[i];
#line 74
      tmp___1 = __builtin_constant_p((int )__x___0);
#line 74
      if (tmp___1) {
#line 74
        __v___0 = ((((__x___0 & 4278190080U) >> 24) | ((__x___0 & 16711680U) >> 8)) |
                   ((__x___0 & 65280U) << 8)) | ((__x___0 & 255U) << 24);
      } else {
#line 74
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
      }
#line 74
      record[i] = (int )(__v___0 ^ (unsigned int )record[0]);
#line 75
      check += record[i];
#line 73
      i ++;
    }
#line 77
    cli_dbgmsg("Mydoom: check: %lu\n", ~ check);
#line 78
    if (~ check != record[0]) {
#line 79
      return (0);
    }
#line 64
    j ++;
  }
#line 83
  if (j < 2) {
#line 84
    retval = 0;
  } else {
#line 85
    if (retval == 1) {
#line 86
      if (virname) {
#line 87
        (*virname) = "Worm.Mydoom.M.log";
      }
    }
  }
#line 90
  return (retval);
}
}
#line 93 "special.c"
static int jpeg_check_photoshop_8bim(int fd ) 
{ unsigned char bim[5] ;
  uint16_t id ;
  uint16_t ntmp ;
  uint8_t nlength ;
  uint32_t size ;
  off_t offset ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 102
  tmp = cli_readn(fd, (void *)(bim), 4U);
#line 102
  if (tmp != 4) {
#line 103
    cli_dbgmsg("read bim failed\n");
#line 104
    return (-1);
  }
#line 107
  tmp___0 = memcmp((void const   *)(bim), (void const   *)"8BIM", 4U);
#line 107
  if (tmp___0 != 0) {
#line 108
    bim[4] = (unsigned char )'\000';
#line 109
    cli_dbgmsg("missed 8bim: %s\n", bim);
#line 110
    return (-1);
  }
#line 113
  tmp___1 = cli_readn(fd, (void *)(& id), 2U);
#line 113
  if (tmp___1 != 2) {
#line 114
    return (-1);
  }
#line 116
  id = id;
#line 117
  cli_dbgmsg("ID: 0x%.4x\n", id);
#line 118
  tmp___2 = cli_readn(fd, (void *)(& nlength), 1U);
#line 118
  if (tmp___2 != 1) {
#line 119
    return (-1);
  }
#line 121
  ntmp = (unsigned short )((int )nlength + (((int )((unsigned short )nlength) + 1) &
                                            1));
#line 122
  lseek(fd, (long )ntmp, 1);
#line 124
  tmp___3 = cli_readn(fd, (void *)(& size), 4U);
#line 124
  if (tmp___3 != 4) {
#line 125
    return (-1);
  }
#line 127
  size = size;
#line 128
  if (size == 0U) {
#line 129
    return (-1);
  }
#line 131
  if ((size & 1U) == 1U) {
#line 132
    size ++;
  }
#line 135
  if ((int )id != 1033) {
#line 135
    if ((int )id != 1036) {
#line 137
      lseek(fd, (long )size, 1);
#line 138
      return (0);
    }
  }
#line 141
  cli_dbgmsg("found thumbnail\n");
#line 143
  offset = lseek(fd, 0L, 1);
#line 146
  lseek(fd, 28L, 1);
#line 148
  retval = cli_check_jpeg_exploit(fd);
#line 149
  if (retval == 1) {
#line 150
    cli_dbgmsg("Exploit found in thumbnail\n", retval);
  }
#line 152
  lseek(fd, (long )((unsigned long )offset + (unsigned long )size), 0);
#line 154
  return (retval);
}
}
#line 157 "special.c"
static int jpeg_check_photoshop(int fd ) 
{ int retval ;
  unsigned char buffer[14] ;
  int tmp ;
  int tmp___0 ;

  {
#line 162
  tmp = cli_readn(fd, (void *)(buffer), 14U);
#line 162
  if (tmp != 14) {
#line 163
    return (0);
  }
#line 166
  tmp___0 = memcmp((void const   *)(buffer), (void const   *)"Photoshop 3.0", 14U);
#line 166
  if (tmp___0 != 0) {
#line 167
    return (0);
  }
#line 170
  cli_dbgmsg("Found Photoshop segment\n");
#line 171
  while (1) {
#line 172
    retval = jpeg_check_photoshop_8bim(fd);
#line 171
    if (! (retval == 0)) {
#line 171
      break;
    }
  }
#line 175
  if (retval == -1) {
#line 176
    retval = 0;
  }
#line 178
  return (retval);
}
}
#line 181 "special.c"
int cli_check_jpeg_exploit(int fd ) 
{ unsigned char buffer[4] ;
  off_t offset ;
  int retval ;
  int tmp ;
  __off_t tmp___0 ;
  __off_t tmp___1 ;

  {
#line 188
  cli_dbgmsg("in cli_check_jpeg_exploit()\n");
#line 190
  tmp = cli_readn(fd, (void *)(buffer), 2U);
#line 190
  if (tmp != 2) {
#line 191
    return (0);
  }
#line 194
  if ((int )buffer[0] != 255) {
#line 195
    return (0);
  } else {
#line 194
    if ((int )buffer[1] != 216) {
#line 195
      return (0);
    }
  }
#line 198
  while (1) {
#line 199
    retval = cli_readn(fd, (void *)(buffer), 4U);
#line 199
    if (retval != 4) {
#line 200
      return (0);
    }
#line 203
    if ((int )buffer[0] == 255) {
#line 203
      if ((int )buffer[1] == 255) {
#line 204
        lseek(fd, -3L, 1);
        goto __Cont;
      }
    }
#line 208
    if ((int )buffer[0] == 255) {
#line 208
      if ((int )buffer[1] == 254) {
#line 209
        if ((int )buffer[2] == 0) {
#line 210
          if ((int )buffer[3] == 0) {
#line 211
            return (1);
          } else {
#line 210
            if ((int )buffer[3] == 1) {
#line 211
              return (1);
            }
          }
        }
      }
    }
#line 215
    if ((int )buffer[0] != 255) {
#line 216
      return (-1);
    }
#line 218
    if ((int )buffer[1] == 218) {
#line 220
      return (0);
    }
#line 223
    offset = (long )(((unsigned int )buffer[2] << 8) + (unsigned int )buffer[3]);
#line 224
    if (offset < 2L) {
#line 225
      return (1);
    }
#line 227
    offset -= 2L;
#line 228
    tmp___0 = lseek(fd, 0L, 1);
#line 228
    offset += tmp___0;
#line 230
    if ((int )buffer[1] == 237) {
#line 232
      retval = jpeg_check_photoshop(fd);
#line 232
      if (retval != 0) {
#line 233
        return (retval);
      }
    }
#line 237
    tmp___1 = lseek(fd, offset, 0);
#line 237
    if (tmp___1 != offset) {
#line 238
      return (-1);
    }
    __Cont: ;
  }
#line 241
  return (0);
}
}
#line 243 "special.c"
static uint32_t riff_endian_convert_32(uint32_t value , int big_endian ) 
{ 

  {
#line 245
  if (big_endian) {
#line 250
    return (value);
  } else {
#line 256
    return ((((value >> 24) | ((value & 16711680U) >> 8)) | ((value & 65280U) << 8)) |
            (value << 24));
  }
}
}
#line 262 "special.c"
static int riff_read_chunk(int fd , int big_endian , int rec_level ) 
{ uint32_t chunk_id ;
  uint32_t chunk_size ;
  int length ;
  uint32_t list_type ;
  off_t offset ;
  off_t cur_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __off_t tmp___9 ;

  {
#line 270
  if (rec_level > 1000) {
#line 271
    cli_dbgmsg("riff_read_chunk: recursion level exceeded\n");
#line 272
    return (0);
  }
#line 275
  length = (int )sizeof(uint32_t );
#line 276
  tmp = cli_readn(fd, (void *)(& chunk_id), (unsigned int )length);
#line 276
  if (tmp != length) {
#line 277
    return (0);
  }
#line 279
  tmp___0 = cli_readn(fd, (void *)(& chunk_size), (unsigned int )length);
#line 279
  if (tmp___0 != length) {
#line 280
    return (0);
  }
#line 282
  chunk_size = riff_endian_convert_32(chunk_size, big_endian);
#line 284
  tmp___2 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFF", 4U);
#line 284
  if (tmp___2 == 0) {
#line 285
    return (0);
  } else {
#line 286
    tmp___1 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFX", 4U);
#line 286
    if (tmp___1 == 0) {
#line 287
      return (0);
    }
  }
#line 290
  tmp___5 = memcmp((void const   *)(& chunk_id), (void const   *)"LIST", 4U);
#line 290
  if (tmp___5 == 0) {
    goto _L;
  } else {
#line 290
    tmp___6 = memcmp((void const   *)(& chunk_id), (void const   *)"PROP", 4U);
#line 290
    if (tmp___6 == 0) {
      goto _L;
    } else {
#line 290
      tmp___7 = memcmp((void const   *)(& chunk_id), (void const   *)"FORM", 4U);
#line 290
      if (tmp___7 == 0) {
        goto _L;
      } else {
#line 290
        tmp___8 = memcmp((void const   *)(& chunk_id), (void const   *)"CAT ", 4U);
#line 290
        if (tmp___8 == 0) {
          _L: 
#line 294
          tmp___3 = cli_readn(fd, (void *)(& list_type), sizeof(list_type));
#line 294
          if ((unsigned int )tmp___3 != sizeof(list_type)) {
#line 295
            cli_dbgmsg("riff_read_chunk: read list type failed\n");
#line 296
            return (0);
          }
#line 298
          rec_level ++;
#line 298
          tmp___4 = riff_read_chunk(fd, big_endian, rec_level);
#line 298
          return (tmp___4);
        }
      }
    }
  }
#line 301
  cur_offset = lseek(fd, 0L, 1);
#line 302
  offset = (long )((unsigned long )cur_offset + (unsigned long )chunk_size);
#line 304
  if ((offset & 1L) == 1L) {
#line 305
    offset ++;
  }
#line 307
  if (offset < cur_offset) {
#line 308
    return (0);
  }
#line 310
  tmp___9 = lseek(fd, offset, 0);
#line 310
  if (tmp___9 != offset) {
#line 311
    return (2);
  }
#line 313
  return (1);
}
}
#line 316 "special.c"
int cli_check_riff_exploit(int fd ) 
{ uint32_t chunk_id ;
  uint32_t chunk_size ;
  uint32_t form_type ;
  int length ;
  int big_endian ;
  int retval ;
  off_t offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 324
  cli_dbgmsg("in cli_check_riff_exploit()\n");
#line 326
  length = (int )sizeof(uint32_t );
#line 327
  tmp = cli_readn(fd, (void *)(& chunk_id), (unsigned int )length);
#line 327
  if (tmp != length) {
#line 328
    return (0);
  }
#line 330
  tmp___0 = cli_readn(fd, (void *)(& chunk_size), (unsigned int )length);
#line 330
  if (tmp___0 != length) {
#line 331
    return (0);
  }
#line 333
  tmp___1 = cli_readn(fd, (void *)(& form_type), (unsigned int )length);
#line 333
  if (tmp___1 != length) {
#line 334
    return (0);
  }
#line 337
  tmp___3 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFF", 4U);
#line 337
  if (tmp___3 == 0) {
#line 338
    big_endian = 0;
  } else {
#line 339
    tmp___2 = memcmp((void const   *)(& chunk_id), (void const   *)"RIFX", 4U);
#line 339
    if (tmp___2 == 0) {
#line 340
      big_endian = 1;
    } else {
#line 343
      return (0);
    }
  }
#line 346
  tmp___4 = memcmp((void const   *)(& form_type), (void const   *)"ACON", 4U);
#line 346
  if (tmp___4 != 0) {
#line 349
    return (0);
  }
#line 352
  chunk_size = riff_endian_convert_32(chunk_size, big_endian);
#line 354
  while (1) {
#line 355
    retval = riff_read_chunk(fd, big_endian, 1);
#line 354
    if (! (retval == 1)) {
#line 354
      break;
    }
  }
#line 358
  offset = lseek(fd, 0L, 1);
#line 360
  if ((long long )offset < (long long )chunk_size) {
#line 361
    retval = 2;
  }
#line 363
  return (retval);
}
}
#line 1 "binhex.lo"
#pragma merger(0,"/tmp/cil-qjgrNqZJ.i","-g -O2 -fPIC")
#line 97 "binhex.c"
int cli_binhex(char const   *dir , int desc ) 
{ struct stat statb ;
  char *buf ;
  char *start ;
  char *line ;
  size_t size ;
  long bytesleft ;
  message *m ;
  fileblob *fb ;
  int tmp ;
  int length ;
  char *ptr ;
  int tmp___0 ;
  text const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 111
  tmp = fstat__extinline(desc, & statb);
#line 111
  if (tmp < 0) {
#line 112
    return (-4);
  }
#line 114
  size = (unsigned int )statb.st_size;
#line 116
  if (size == 0U) {
#line 117
    return (0);
  }
#line 119
  m = messageCreate();
#line 120
  if ((unsigned int )m == (unsigned int )((void *)0)) {
#line 121
    return (-3);
  }
#line 123
  buf = (char *)mmap((void *)0, size, 1, 1, desc, 0L);
#line 123
  start = buf;
#line 124
  if ((unsigned int )buf == (unsigned int )((void *)-1)) {
#line 125
    messageDestroy(m);
#line 126
    return (-3);
  }
#line 129
  cli_dbgmsg("mmap\'ed binhex file\n");
#line 131
  bytesleft = (long )((int )size);
#line 132
  line = (char *)((void *)0);
#line 134
  while (bytesleft > 0L) {
#line 135
    length = 0;
#line 140
    ptr = buf;
#line 140
    while (1) {
#line 140
      if (bytesleft) {
#line 140
        if ((int )(*ptr) != 10) {
#line 140
          if (! ((int )(*ptr) != 13)) {
#line 140
            break;
          }
        } else {
#line 140
          break;
        }
      } else {
#line 140
        break;
      }
#line 141
      length ++;
#line 142
      bytesleft --;
#line 140
      ptr ++;
    }
#line 147
    line = (char *)cli_realloc((void *)line, (unsigned int )(length + 1));
#line 149
    memcpy((void * __restrict  )line, (void const   * __restrict  )buf, (unsigned int )length);
#line 150
    (*(line + length)) = (char )'\000';
#line 154
    tmp___0 = messageAddStr(m, (char const   *)line);
#line 154
    if (tmp___0 < 0) {
#line 155
      break;
    }
#line 157
    if (bytesleft > 0L) {
#line 157
      if ((int )(*ptr) == 13) {
#line 158
        ptr ++;
#line 159
        bytesleft --;
      }
    }
#line 161
    ptr ++;
#line 161
    buf = ptr;
#line 162
    bytesleft --;
  }
#line 164
  munmap((void *)start, size);
#line 166
  if (line) {
#line 167
    free((void *)line);
  }
#line 169
  tmp___1 = binhexBegin((message const   *)m);
#line 169
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 170
    messageDestroy(m);
#line 171
    cli_errmsg("No binhex line found\n");
#line 172
    return (-13);
  }
#line 174
  messageSetEncoding(m, "x-binhex");
#line 176
  fb = messageToFileblob(m, dir);
#line 177
  if (fb) {
#line 178
    tmp___2 = fileblobGetFilename((fileblob const   *)fb);
#line 178
    cli_dbgmsg("Binhex file decoded to %s\n", tmp___2);
#line 179
    fileblobDestroy(fb);
  } else {
#line 181
    cli_errmsg("Couldn\'t decode binhex file to %s\n", dir);
  }
#line 182
  messageDestroy(m);
#line 184
  if (fb) {
#line 185
    return (0);
  }
#line 186
  return (-4);
}
}
#line 1 "is_tar.lo"
#pragma merger(0,"/tmp/cil-os3Ku5bd.i","-g -O2 -fPIC")
#line 27 "is_tar.c"
static int from_oct(int digs , char *where ) ;
#line 35 "is_tar.c"
int is_tar(unsigned char *buf , int nbytes ) 
{ union record *header ;
  int i ;
  int sum ;
  int recsum ;
  char *p ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___35 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___54 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;

  {
#line 37
  header = (union record *)buf;
#line 43
  if ((unsigned int )nbytes < sizeof(union record )) {
#line 44
    return (0);
  }
#line 46
  recsum = from_oct(8, header->header.chksum);
#line 48
  sum = 0;
#line 49
  p = header->charptr;
#line 50
  i = (int )sizeof(union record );
#line 50
  while (1) {
#line 50
    i --;
#line 50
    if (! (i >= 0)) {
#line 50
      break;
    }
#line 55
    tmp = p;
#line 55
    p ++;
#line 55
    sum += 255 & (int )(*tmp);
  }
#line 59
  i = (int )sizeof(header->header.chksum);
#line 59
  while (1) {
#line 59
    i --;
#line 59
    if (! (i >= 0)) {
#line 59
      break;
    }
#line 60
    sum -= 255 & (int )header->header.chksum[i];
  }
#line 61
  sum = (int )((unsigned int )sum + 32U * sizeof(header->header.chksum));
#line 63
  if (sum != recsum) {
#line 64
    return (0);
  }
#line 66
  tmp___66 = __builtin_constant_p((int )(header->header.magic));
#line 66
  if (tmp___66) {
#line 66
    tmp___67 = __builtin_constant_p((int )"ustar  ");
#line 66
    if (tmp___67) {
#line 66
      __s1_len = strlen((char const   *)(header->header.magic));
#line 66
      __s2_len = strlen("ustar  ");
#line 66
      if (! ((unsigned int )((void const   *)(header->header.magic + 1)) - (unsigned int )((void const   *)(header->header.magic)) ==
             1U)) {
        goto _L___16;
      } else {
#line 66
        if (__s1_len >= 4U) {
          _L___16: 
#line 66
          if (! ((unsigned int )((void const   *)("ustar  " + 1)) - (unsigned int )((void const   *)"ustar  ") ==
                 1U)) {
#line 66
            tmp___68 = 1;
          } else {
#line 66
            if (__s2_len >= 4U) {
#line 66
              tmp___68 = 1;
            } else {
#line 66
              tmp___68 = 0;
            }
          }
        } else {
#line 66
          tmp___68 = 0;
        }
      }
#line 66
      if (tmp___68) {
#line 66
        tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
      } else {
        goto _L___18;
      }
    } else {
      goto _L___18;
    }
  } else {
    _L___18: 
#line 66
    tmp___65 = __builtin_constant_p((int )(header->header.magic));
#line 66
    if (tmp___65) {
#line 66
      if ((unsigned int )((void const   *)(header->header.magic + 1)) - (unsigned int )((void const   *)(header->header.magic)) ==
          1U) {
#line 66
        __s1_len = strlen((char const   *)(header->header.magic));
#line 66
        if (__s1_len < 4U) {
#line 66
          tmp___54 = __builtin_constant_p((int )"ustar  ");
#line 66
          if (tmp___54) {
#line 66
            if ((unsigned int )((void const   *)("ustar  " + 1)) - (unsigned int )((void const   *)"ustar  ") ==
                1U) {
#line 66
              tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
#line 66
            __s2___6 = (unsigned char const   *)"ustar  ";
#line 66
            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                    0)) - (int const   )(*(__s2___6 +
                                                                           0)));
#line 66
            if (__s1_len > 0U) {
#line 66
              if (__result___18 == 0) {
#line 66
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                        1)) - (int const   )(*(__s2___6 +
                                                                               1)));
#line 66
                if (__s1_len > 1U) {
#line 66
                  if (__result___18 == 0) {
#line 66
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                            2)) - (int const   )(*(__s2___6 +
                                                                                   2)));
#line 66
                    if (__s1_len > 2U) {
#line 66
                      if (__result___18 == 0) {
#line 66
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(header->header.magic)) +
                                                                3)) - (int const   )(*(__s2___6 +
                                                                                       3)));
                      }
                    }
                  }
                }
              }
            }
#line 66
            tmp___35 = __result___18;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: 
#line 66
      tmp___64 = __builtin_constant_p((int )"ustar  ");
#line 66
      if (tmp___64) {
#line 66
        if ((unsigned int )((void const   *)("ustar  " + 1)) - (unsigned int )((void const   *)"ustar  ") ==
            1U) {
#line 66
          __s2_len = strlen("ustar  ");
#line 66
          if (__s2_len < 4U) {
#line 66
            tmp___63 = __builtin_constant_p((int )(header->header.magic));
#line 66
            if (tmp___63) {
#line 66
              if ((unsigned int )((void const   *)(header->header.magic + 1)) - (unsigned int )((void const   *)(header->header.magic)) ==
                  1U) {
#line 66
                tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
#line 66
              __s1___14 = (unsigned char const   *)((char const   *)(header->header.magic));
#line 66
              __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)"ustar  " +
                                                                                         0)));
#line 66
              if (__s2_len > 0U) {
#line 66
                if (__result___22 == 0) {
#line 66
                  __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)"ustar  " +
                                                                                             1)));
#line 66
                  if (__s2_len > 1U) {
#line 66
                    if (__result___22 == 0) {
#line 66
                      __result___22 = (int )((int const   )(*(__s1___14 + 2)) - (int const   )(*((unsigned char const   *)"ustar  " +
                                                                                                 2)));
#line 66
                      if (__s2_len > 2U) {
#line 66
                        if (__result___22 == 0) {
#line 66
                          __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                 (int const   )(*((unsigned char const   *)"ustar  " +
                                                                  3)));
                        }
                      }
                    }
                  }
                }
              }
#line 66
              tmp___35 = __result___22;
            }
          } else {
#line 66
            tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
          }
        } else {
#line 66
          tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
        }
      } else {
#line 66
        tmp___35 = __builtin_strcmp(header->header.magic, "ustar  ");
      }
    }
  }
#line 66
  if (0 == tmp___35) {
#line 67
    return (2);
  }
#line 69
  return (1);
}
}
#line 78 "is_tar.c"
static int from_oct(int digs , char *where ) 
{ int value ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 82
  while (1) {
#line 82
    tmp = __ctype_b_loc();
#line 82
    if (! ((int const   )(*((*tmp) + (int )((unsigned char )(*where)))) & 8192)) {
#line 82
      break;
    }
#line 83
    where ++;
#line 84
    digs --;
#line 84
    if (digs <= 0) {
#line 85
      return (-1);
    }
  }
#line 87
  value = 0;
#line 88
  while (1) {
#line 88
    if (digs > 0) {
#line 88
      if ((int )(*where) >= 48) {
#line 88
        if (! ((int )(*where) <= 55)) {
#line 88
          break;
        }
      } else {
#line 88
        break;
      }
    } else {
#line 88
      break;
    }
#line 89
    tmp___0 = where;
#line 89
    where ++;
#line 89
    value = (value << 3) | ((int )(*tmp___0) - 48);
#line 90
    digs --;
  }
#line 93
  if (digs > 0) {
#line 93
    if ((*where)) {
#line 93
      tmp___1 = __ctype_b_loc();
#line 93
      if (! ((int const   )(*((*tmp___1) + (int )((unsigned char )(*where)))) & 8192)) {
#line 94
        return (-1);
      }
    }
  }
#line 96
  return (value);
}
}
#line 1 "tnef.lo"
#pragma merger(0,"/tmp/cil-5Ws5WnJV.i","-g -O2 -fPIC")
#line 41 "tnef.c"
static int tnef_message(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ) ;
#line 42
static int tnef_attachment(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ,
                           char const   *dir , fileblob **fbref ) ;
#line 43
static int tnef_header(FILE *fp , uint8_t *part , uint16_t *type , uint16_t *tag ,
                       uint32_t *length ) ;
#line 68 "tnef.c"
int cli_tnef(char const   *dir , int desc ) 
{ uint32_t i32 ;
  uint16_t i16 ;
  fileblob *fb ;
  int i ;
  int ret ;
  int alldone ;
  FILE *fp ;
  size_t tmp ;
  size_t tmp___0 ;
  uint8_t part ;
  uint16_t type ;
  uint16_t tag ;
  uint32_t length ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int fout ;
  char *filename ;
  char *tmp___5 ;
  char buffer[8192] ;
  int count ;

  {
#line 77
  lseek(desc, 0L, 0);
#line 79
  i = dup(desc);
#line 80
  fp = fdopen(i, "rb");
#line 80
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 81
    cli_errmsg("Can\'t open descriptor %d\n", desc);
#line 82
    close(i);
#line 83
    return (-4);
  }
#line 86
  tmp = fread((void * __restrict  )(& i32), sizeof(uint32_t ), 1U, (FILE * __restrict  )fp);
#line 86
  if (tmp != 1U) {
#line 87
    fclose(fp);
#line 88
    return (-12);
  }
#line 90
  if (((((i32 >> 24) | ((i32 & 16711680U) >> 8)) | ((i32 & 65280U) << 8)) | (i32 <<
                                                                             24)) !=
      574529400U) {
#line 91
    fclose(fp);
#line 92
    return (-13);
  }
#line 95
  tmp___0 = fread((void * __restrict  )(& i16), sizeof(uint16_t ), 1U, (FILE * __restrict  )fp);
#line 95
  if (tmp___0 != 1U) {
#line 96
    fclose(fp);
#line 97
    return (-12);
  }
#line 100
  fb = (fileblob *)((void *)0);
#line 101
  ret = 0;
#line 102
  alldone = 0;
#line 104
  while (1) {
#line 109
    tmp___1 = tnef_header(fp, & part, & type, & tag, & length);
#line 109
    switch (tmp___1) {
    case 0: 
#line 111
    tmp___2 = ferror(fp);
#line 111
    if (tmp___2) {
#line 112
      perror("read");
#line 113
      ret = -12;
    }
#line 115
    alldone = 1;
#line 116
    break;
    case 1: ;
#line 118
    break;
    default: 
#line 120
    ret = -12;
#line 121
    alldone = 1;
#line 122
    break;
    }
#line 124
    if (alldone) {
#line 125
      break;
    }
#line 126
    switch ((int )part) {
    case 1: 
#line 128
    cli_dbgmsg("TNEF - found message\n");
#line 129
    if ((unsigned int )fb != (unsigned int )((void *)0)) {
#line 130
      fileblobDestroy(fb);
#line 131
      fb = (fileblob *)((void *)0);
    }
#line 133
    fb = fileblobCreate();
#line 134
    tmp___3 = tnef_message(fp, type, tag, length);
#line 134
    if (tmp___3 != 0) {
#line 135
      cli_errmsg("Error reading TNEF message\n");
#line 136
      ret = -13;
#line 137
      alldone = 1;
    }
#line 139
    break;
    case 2: 
#line 141
    cli_dbgmsg("TNEF - found attachment\n");
#line 142
    tmp___4 = tnef_attachment(fp, type, tag, length, dir, & fb);
#line 142
    if (tmp___4 != 0) {
#line 143
      cli_errmsg("Error reading TNEF message\n");
#line 144
      ret = -13;
#line 145
      alldone = 1;
    }
#line 147
    break;
    case 0: ;
#line 149
    break;
    default: 
#line 151
    cli_warnmsg("TNEF - unknown level %d tag 0x%x\n", (int )part, (int )tag);
#line 157
    if (cli_debug_flag) {
#line 159
      tmp___5 = cli_gentemp((char const   *)((void *)0));
#line 159
      filename = tmp___5;
#line 165
      fout = open((char const   *)filename, 705, 384);
#line 168
      if (fout >= 0) {
#line 171
        cli_warnmsg("Saving dump to %s - send to bugs@clamav.net\n", filename);
#line 173
        lseek(desc, 0L, 0);
#line 174
        while (1) {
#line 174
          count = cli_readn(desc, (void *)(buffer), sizeof(buffer));
#line 174
          if (! (count > 0)) {
#line 174
            break;
          }
#line 175
          cli_writen(fout, (void *)(buffer), (unsigned int )count);
        }
#line 176
        close(fout);
      }
#line 178
      free((void *)filename);
    }
#line 180
    ret = -13;
#line 181
    alldone = 1;
#line 182
    break;
    }
#line 104
    if (! (! alldone)) {
#line 104
      break;
    }
  }
#line 186
  if (fb) {
#line 187
    fileblobDestroy(fb);
#line 188
    fb = (fileblob *)((void *)0);
  }
#line 190
  fclose(fp);
#line 192
  cli_dbgmsg("cli_tnef: returning %d\n", ret);
#line 193
  return (ret);
}
}
#line 196 "tnef.c"
static int tnef_message(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ) 
{ uint16_t i16 ;
  off_t offset ;
  size_t tmp ;

  {
#line 206
  cli_dbgmsg("message tag 0x%x, type 0x%x, length %u\n", tag, type, length);
#line 208
  offset = ftell(fp);
#line 213
  switch ((int )tag) {
  case 32780: 
#line 215
  cli_warnmsg("TNEF body not being scanned - if you believe this file contains a virus, submit it to www.clamav.net\n");
#line 216
  break;
  }
#line 254
  fseek(fp, (long )((unsigned long )offset + (unsigned long )length), 0);
#line 257
  tmp = fread((void * __restrict  )(& i16), sizeof(uint16_t ), 1U, (FILE * __restrict  )fp);
#line 257
  if (tmp != 1U) {
#line 258
    return (-1);
  }
#line 260
  return (0);
}
}
#line 263 "tnef.c"
static int tnef_attachment(FILE *fp , uint16_t type , uint16_t tag , uint32_t length ,
                           char const   *dir , fileblob **fbref ) 
{ uint32_t todo ;
  uint16_t i16 ;
  off_t offset ;
  char *string ;
  size_t tmp ;
  int c ;
  unsigned char c2 ;
  size_t tmp___0 ;

  {
#line 271
  cli_dbgmsg("attachment tag 0x%x, type 0x%x, length %u\n", tag, type, length);
#line 273
  offset = ftell(fp);
#line 275
  switch ((int )tag) {
  case 32784: 
#line 277
  string = (char *)cli_malloc(length + 1U);
#line 278
  tmp = fread((void * __restrict  )string, 1U, length, (FILE * __restrict  )fp);
#line 278
  if (tmp != length) {
#line 279
    free((void *)string);
#line 280
    return (-1);
  }
#line 282
  (*(string + length)) = (char )'\000';
#line 283
  cli_dbgmsg("TNEF filename %s\n", string);
#line 284
  if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
#line 285
    (*fbref) = fileblobCreate();
#line 286
    if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
#line 287
      free((void *)string);
#line 288
      return (-1);
    }
  }
#line 291
  fileblobSetFilename((*fbref), dir, (char const   *)string);
#line 292
  free((void *)string);
#line 293
  break;
  case 32783: ;
#line 295
  if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
#line 296
    (*fbref) = fileblobCreate();
#line 297
    if ((unsigned int )(*fbref) == (unsigned int )((void *)0)) {
#line 298
      return (-1);
    }
  }
#line 300
  todo = length;
#line 300
  while (todo) {
#line 305
    c = fgetc(fp);
#line 305
    if (c == -1) {
#line 306
      break;
    }
#line 307
    c2 = (unsigned char )c;
#line 308
    fileblobAddData((*fbref), (unsigned char const   *)(& c2), 1U);
#line 300
    todo --;
  }
#line 317
  break;
  default: 
#line 319
  cli_dbgmsg("TNEF - unsupported attachment tag 0x%x type 0x%d length %u\n", tag,
             type, length);
#line 320
  break;
  }
#line 325
  fseek(fp, (long )((unsigned long )offset + (unsigned long )length), 0);
#line 328
  tmp___0 = fread((void * __restrict  )(& i16), sizeof(uint16_t ), 1U, (FILE * __restrict  )fp);
#line 328
  if (tmp___0 != 1U) {
#line 329
    return (-1);
  }
#line 331
  return (0);
}
}
#line 334 "tnef.c"
static int tnef_header(FILE *fp , uint8_t *part , uint16_t *type , uint16_t *tag ,
                       uint32_t *length ) 
{ uint32_t i32 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 339
  tmp = fread((void * __restrict  )part, sizeof(uint8_t ), 1U, (FILE * __restrict  )fp);
#line 339
  if (tmp != 1U) {
#line 340
    return (0);
  }
#line 342
  if ((int )(*part) == 0) {
#line 343
    return (0);
  }
#line 345
  tmp___0 = fread((void * __restrict  )(& i32), sizeof(uint32_t ), 1U, (FILE * __restrict  )fp);
#line 345
  if (tmp___0 != 1U) {
#line 346
    return (-1);
  }
#line 348
  i32 = (((i32 >> 24) | ((i32 & 16711680U) >> 8)) | ((i32 & 65280U) << 8)) | (i32 <<
                                                                              24);
#line 349
  (*tag) = (unsigned short )(i32 & 65535U);
#line 350
  (*type) = (unsigned short )((i32 & 4294901760U) >> 16);
#line 352
  tmp___1 = fread((void * __restrict  )(& i32), sizeof(uint32_t ), 1U, (FILE * __restrict  )fp);
#line 352
  if (tmp___1 != 1U) {
#line 353
    return (-1);
  }
#line 354
  (*length) = (((i32 >> 24) | ((i32 & 16711680U) >> 8)) | ((i32 & 65280U) << 8)) |
              (i32 << 24);
#line 356
  cli_dbgmsg("message tag 0x%x, type 0x%x, length %u\n", (*tag), (*type), (*length));
#line 358
  return (1);
}
}
