/* Generated by CIL v. 1.3.2 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef long long __quad_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef int __ssize_t;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef int int32_t;
typedef unsigned char u_int8_t;
typedef unsigned int u_int32_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
typedef struct __anonstruct_fd_set_3 fd_set;
struct __sched_param {
   int __sched_priority ;
};
struct __pthread_attr_s {
   int __detachstate ;
   int __schedpolicy ;
   struct __sched_param __schedparam ;
   int __inheritsched ;
   int __scope ;
   size_t __guardsize ;
   int __stackaddr_set ;
   void *__stackaddr ;
   size_t __stacksize ;
};
typedef struct __pthread_attr_s pthread_attr_t;
typedef unsigned long pthread_t;
typedef void (*__sighandler_t)(int  );
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
typedef u_int32_t db_pgno_t;
typedef u_int32_t db_recno_t;
typedef u_int32_t db_timeout_t;
typedef u_int32_t roff_t;
struct __db;
typedef struct __db DB;
struct __db_dbt;
typedef struct __db_dbt DBT;
struct __db_env;
typedef struct __db_env DB_ENV;
struct __db_ilock;
typedef struct __db_ilock DB_LOCK_ILOCK;
struct __db_lock_stat;
typedef struct __db_lock_stat DB_LOCK_STAT;
struct __db_lock_u;
typedef struct __db_lock_u DB_LOCK;
struct __db_lockreq;
typedef struct __db_lockreq DB_LOCKREQ;
struct __db_log_cursor;
typedef struct __db_log_cursor DB_LOGC;
struct __db_log_stat;
typedef struct __db_log_stat DB_LOG_STAT;
struct __db_lsn;
typedef struct __db_lsn DB_LSN;
struct __db_mpool_fstat;
typedef struct __db_mpool_fstat DB_MPOOL_FSTAT;
struct __db_mpool_stat;
typedef struct __db_mpool_stat DB_MPOOL_STAT;
struct __db_mpoolfile;
typedef struct __db_mpoolfile DB_MPOOLFILE;
struct __db_preplist;
typedef struct __db_preplist DB_PREPLIST;
struct __db_rep_stat;
typedef struct __db_rep_stat DB_REP_STAT;
struct __db_txn;
typedef struct __db_txn DB_TXN;
struct __db_txn_active;
typedef struct __db_txn_active DB_TXN_ACTIVE;
struct __db_txn_stat;
typedef struct __db_txn_stat DB_TXN_STAT;
struct __db_txnmgr;
typedef struct __db_txnmgr DB_TXNMGR;
struct __dbc;
typedef struct __dbc DBC;
struct __dbc_internal;
typedef struct __dbc_internal DBC_INTERNAL;
struct __fh_t;
typedef struct __fh_t DB_FH;
struct __fname;
typedef struct __fname FNAME;
struct __key_range;
typedef struct __key_range DB_KEY_RANGE;
struct __mpoolfile;
typedef struct __mpoolfile MPOOLFILE;
struct __mutex_t;
typedef struct __mutex_t DB_MUTEX;
struct __db_dbt {
   void *data ;
   u_int32_t size ;
   u_int32_t ulen ;
   u_int32_t dlen ;
   u_int32_t doff ;
   u_int32_t flags ;
};
enum __anonenum_db_lockmode_t_50 {
    DB_LOCK_NG = 0,
    DB_LOCK_READ = 1,
    DB_LOCK_WRITE = 2,
    DB_LOCK_WAIT = 3,
    DB_LOCK_IWRITE = 4,
    DB_LOCK_IREAD = 5,
    DB_LOCK_IWR = 6,
    DB_LOCK_DIRTY = 7,
    DB_LOCK_WWRITE = 8
};
typedef enum __anonenum_db_lockmode_t_50 db_lockmode_t;
enum __anonenum_db_lockop_t_51 {
    DB_LOCK_DUMP = 0,
    DB_LOCK_GET = 1,
    DB_LOCK_GET_TIMEOUT = 2,
    DB_LOCK_INHERIT = 3,
    DB_LOCK_PUT = 4,
    DB_LOCK_PUT_ALL = 5,
    DB_LOCK_PUT_OBJ = 6,
    DB_LOCK_PUT_READ = 7,
    DB_LOCK_TIMEOUT = 8,
    DB_LOCK_TRADE = 9,
    DB_LOCK_UPGRADE_WRITE = 10
};
typedef enum __anonenum_db_lockop_t_51 db_lockop_t;
struct __db_lock_stat {
   u_int32_t st_id ;
   u_int32_t st_cur_maxid ;
   u_int32_t st_maxlocks ;
   u_int32_t st_maxlockers ;
   u_int32_t st_maxobjects ;
   u_int32_t st_nmodes ;
   u_int32_t st_nlocks ;
   u_int32_t st_maxnlocks ;
   u_int32_t st_nlockers ;
   u_int32_t st_maxnlockers ;
   u_int32_t st_nobjects ;
   u_int32_t st_maxnobjects ;
   u_int32_t st_nconflicts ;
   u_int32_t st_nrequests ;
   u_int32_t st_nreleases ;
   u_int32_t st_nnowaits ;
   u_int32_t st_ndeadlocks ;
   db_timeout_t st_locktimeout ;
   u_int32_t st_nlocktimeouts ;
   db_timeout_t st_txntimeout ;
   u_int32_t st_ntxntimeouts ;
   u_int32_t st_region_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_regsize ;
};
struct __db_ilock {
   db_pgno_t pgno ;
   u_int8_t fileid[20] ;
   u_int32_t type ;
};
struct __db_lock_u {
   size_t off ;
   u_int32_t ndx ;
   u_int32_t gen ;
   db_lockmode_t mode ;
};
struct __db_lockreq {
   db_lockop_t op ;
   db_lockmode_t mode ;
   db_timeout_t timeout ;
   DBT *obj ;
   DB_LOCK lock ;
};
struct __db_lsn {
   u_int32_t file ;
   u_int32_t offset ;
};
struct __db_log_cursor {
   DB_ENV *dbenv ;
   DB_FH *c_fhp ;
   DB_LSN c_lsn ;
   u_int32_t c_len ;
   u_int32_t c_prev ;
   DBT c_dbt ;
   u_int8_t *bp ;
   u_int32_t bp_size ;
   u_int32_t bp_rlen ;
   DB_LSN bp_lsn ;
   u_int32_t bp_maxrec ;
   int (*close)(DB_LOGC * , u_int32_t  ) ;
   int (*get)(DB_LOGC * , DB_LSN * , DBT * , u_int32_t  ) ;
   u_int32_t flags ;
};
struct __db_log_stat {
   u_int32_t st_magic ;
   u_int32_t st_version ;
   int st_mode ;
   u_int32_t st_lg_bsize ;
   u_int32_t st_lg_size ;
   u_int32_t st_w_bytes ;
   u_int32_t st_w_mbytes ;
   u_int32_t st_wc_bytes ;
   u_int32_t st_wc_mbytes ;
   u_int32_t st_wcount ;
   u_int32_t st_wcount_fill ;
   u_int32_t st_scount ;
   u_int32_t st_region_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_cur_file ;
   u_int32_t st_cur_offset ;
   u_int32_t st_disk_file ;
   u_int32_t st_disk_offset ;
   u_int32_t st_regsize ;
   u_int32_t st_maxcommitperflush ;
   u_int32_t st_mincommitperflush ;
};
enum __anonenum_DB_CACHE_PRIORITY_53 {
    DB_PRIORITY_VERY_LOW = 1,
    DB_PRIORITY_LOW = 2,
    DB_PRIORITY_DEFAULT = 3,
    DB_PRIORITY_HIGH = 4,
    DB_PRIORITY_VERY_HIGH = 5
};
typedef enum __anonenum_DB_CACHE_PRIORITY_53 DB_CACHE_PRIORITY;
struct __anonstruct_q_54 {
   struct __db_mpoolfile *tqe_next ;
   struct __db_mpoolfile **tqe_prev ;
};
struct __db_mpoolfile {
   DB_FH *fhp ;
   u_int32_t ref ;
   u_int32_t pinref ;
   struct __anonstruct_q_54 q ;
   DB_ENV *dbenv ;
   MPOOLFILE *mfp ;
   u_int32_t clear_len ;
   u_int8_t fileid[20] ;
   int ftype ;
   int32_t lsn_offset ;
   u_int32_t gbytes ;
   u_int32_t bytes ;
   DBT *pgcookie ;
   DB_CACHE_PRIORITY priority ;
   void *addr ;
   size_t len ;
   u_int32_t config_flags ;
   int (*close)(DB_MPOOLFILE * , u_int32_t  ) ;
   int (*get)(DB_MPOOLFILE * , db_pgno_t * , u_int32_t  , void * ) ;
   int (*open)(DB_MPOOLFILE * , char const   * , u_int32_t  , int  , size_t  ) ;
   int (*put)(DB_MPOOLFILE * , void * , u_int32_t  ) ;
   int (*set)(DB_MPOOLFILE * , void * , u_int32_t  ) ;
   int (*get_clear_len)(DB_MPOOLFILE * , u_int32_t * ) ;
   int (*set_clear_len)(DB_MPOOLFILE * , u_int32_t  ) ;
   int (*get_fileid)(DB_MPOOLFILE * , u_int8_t * ) ;
   int (*set_fileid)(DB_MPOOLFILE * , u_int8_t * ) ;
   int (*get_flags)(DB_MPOOLFILE * , u_int32_t * ) ;
   int (*set_flags)(DB_MPOOLFILE * , u_int32_t  , int  ) ;
   int (*get_ftype)(DB_MPOOLFILE * , int * ) ;
   int (*set_ftype)(DB_MPOOLFILE * , int  ) ;
   int (*get_lsn_offset)(DB_MPOOLFILE * , int32_t * ) ;
   int (*set_lsn_offset)(DB_MPOOLFILE * , int32_t  ) ;
   int (*get_maxsize)(DB_MPOOLFILE * , u_int32_t * , u_int32_t * ) ;
   int (*set_maxsize)(DB_MPOOLFILE * , u_int32_t  , u_int32_t  ) ;
   int (*get_pgcookie)(DB_MPOOLFILE * , DBT * ) ;
   int (*set_pgcookie)(DB_MPOOLFILE * , DBT * ) ;
   int (*get_priority)(DB_MPOOLFILE * , DB_CACHE_PRIORITY * ) ;
   int (*set_priority)(DB_MPOOLFILE * , DB_CACHE_PRIORITY  ) ;
   int (*sync)(DB_MPOOLFILE * ) ;
   u_int32_t flags ;
};
struct __db_mpool_stat {
   u_int32_t st_gbytes ;
   u_int32_t st_bytes ;
   u_int32_t st_ncache ;
   u_int32_t st_regsize ;
   u_int32_t st_map ;
   u_int32_t st_cache_hit ;
   u_int32_t st_cache_miss ;
   u_int32_t st_page_create ;
   u_int32_t st_page_in ;
   u_int32_t st_page_out ;
   u_int32_t st_ro_evict ;
   u_int32_t st_rw_evict ;
   u_int32_t st_page_trickle ;
   u_int32_t st_pages ;
   u_int32_t st_page_clean ;
   u_int32_t st_page_dirty ;
   u_int32_t st_hash_buckets ;
   u_int32_t st_hash_searches ;
   u_int32_t st_hash_longest ;
   u_int32_t st_hash_examined ;
   u_int32_t st_hash_nowait ;
   u_int32_t st_hash_wait ;
   u_int32_t st_hash_max_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_region_wait ;
   u_int32_t st_alloc ;
   u_int32_t st_alloc_buckets ;
   u_int32_t st_alloc_max_buckets ;
   u_int32_t st_alloc_pages ;
   u_int32_t st_alloc_max_pages ;
};
struct __db_mpool_fstat {
   char *file_name ;
   size_t st_pagesize ;
   u_int32_t st_map ;
   u_int32_t st_cache_hit ;
   u_int32_t st_cache_miss ;
   u_int32_t st_page_create ;
   u_int32_t st_page_in ;
   u_int32_t st_page_out ;
};
enum __anonenum_db_recops_55 {
    DB_TXN_ABORT = 0,
    DB_TXN_APPLY = 1,
    DB_TXN_BACKWARD_ALLOC = 2,
    DB_TXN_BACKWARD_ROLL = 3,
    DB_TXN_FORWARD_ROLL = 4,
    DB_TXN_GETPGNOS = 5,
    DB_TXN_OPENFILES = 6,
    DB_TXN_POPENFILES = 7,
    DB_TXN_PRINT = 8
};
typedef enum __anonenum_db_recops_55 db_recops;
struct __anonstruct_links_56 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __anonstruct_xalinks_57 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __txn_event;
struct __anonstruct_events_58 {
   struct __txn_event *tqh_first ;
   struct __txn_event **tqh_last ;
};
struct __txn_logrec;
struct __anonstruct_logs_59 {
   struct __txn_logrec *stqh_first ;
   struct __txn_logrec **stqh_last ;
};
struct __kids {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __anonstruct_klinks_60 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __db_txn {
   DB_TXNMGR *mgrp ;
   DB_TXN *parent ;
   DB_LSN last_lsn ;
   u_int32_t txnid ;
   u_int32_t tid ;
   roff_t off ;
   db_timeout_t lock_timeout ;
   db_timeout_t expire ;
   void *txn_list ;
   struct __anonstruct_links_56 links ;
   struct __anonstruct_xalinks_57 xalinks ;
   struct __anonstruct_events_58 events ;
   struct __anonstruct_logs_59 logs ;
   struct __kids kids ;
   struct __anonstruct_klinks_60 klinks ;
   void *api_internal ;
   u_int32_t cursors ;
   int (*abort)(DB_TXN * ) ;
   int (*commit)(DB_TXN * , u_int32_t  ) ;
   int (*discard)(DB_TXN * , u_int32_t  ) ;
   u_int32_t (*id)(DB_TXN * ) ;
   int (*prepare)(DB_TXN * , u_int8_t * ) ;
   int (*set_timeout)(DB_TXN * , db_timeout_t  , u_int32_t  ) ;
   u_int32_t flags ;
};
struct __db_preplist {
   DB_TXN *txn ;
   u_int8_t gid[128] ;
};
struct __db_txn_active {
   u_int32_t txnid ;
   u_int32_t parentid ;
   DB_LSN lsn ;
   u_int32_t xa_status ;
   u_int8_t xid[128] ;
};
struct __db_txn_stat {
   DB_LSN st_last_ckp ;
   time_t st_time_ckp ;
   u_int32_t st_last_txnid ;
   u_int32_t st_maxtxns ;
   u_int32_t st_naborts ;
   u_int32_t st_nbegins ;
   u_int32_t st_ncommits ;
   u_int32_t st_nactive ;
   u_int32_t st_nrestores ;
   u_int32_t st_maxnactive ;
   DB_TXN_ACTIVE *st_txnarray ;
   u_int32_t st_region_wait ;
   u_int32_t st_region_nowait ;
   u_int32_t st_regsize ;
};
struct __db_rep_stat {
   u_int32_t st_status ;
   DB_LSN st_next_lsn ;
   DB_LSN st_waiting_lsn ;
   u_int32_t st_dupmasters ;
   int st_env_id ;
   int st_env_priority ;
   u_int32_t st_gen ;
   u_int32_t st_in_recovery ;
   u_int32_t st_log_duplicated ;
   u_int32_t st_log_queued ;
   u_int32_t st_log_queued_max ;
   u_int32_t st_log_queued_total ;
   u_int32_t st_log_records ;
   u_int32_t st_log_requested ;
   int st_master ;
   u_int32_t st_master_changes ;
   u_int32_t st_msgs_badgen ;
   u_int32_t st_msgs_processed ;
   u_int32_t st_msgs_recover ;
   u_int32_t st_msgs_send_failures ;
   u_int32_t st_msgs_sent ;
   u_int32_t st_newsites ;
   int st_nsites ;
   u_int32_t st_nthrottles ;
   u_int32_t st_outdated ;
   u_int32_t st_txns_applied ;
   u_int32_t st_elections ;
   u_int32_t st_elections_won ;
   int st_election_cur_winner ;
   u_int32_t st_election_gen ;
   DB_LSN st_election_lsn ;
   int st_election_nsites ;
   int st_election_priority ;
   int st_election_status ;
   int st_election_tiebreaker ;
   int st_election_votes ;
};
enum __anonenum_DBTYPE_61 {
    DB_BTREE = 1,
    DB_HASH = 2,
    DB_RECNO = 3,
    DB_QUEUE = 4,
    DB_UNKNOWN = 5
};
typedef enum __anonenum_DBTYPE_61 DBTYPE;
struct __anonstruct_dblistlinks_62 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
struct __cq_fq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __cq_aq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __cq_jq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __anonstruct_s_secondaries_63 {
   struct __db *lh_first ;
};
struct __anonstruct_s_links_64 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
struct __db {
   u_int32_t pgsize ;
   int (*db_append_recno)(DB * , DBT * , db_recno_t  ) ;
   void (*db_feedback)(DB * , int  , int  ) ;
   int (*dup_compare)(DB * , DBT const   * , DBT const   * ) ;
   void *app_private ;
   DB_ENV *dbenv ;
   DBTYPE type ;
   DB_MPOOLFILE *mpf ;
   DB_MUTEX *mutexp ;
   char *fname ;
   char *dname ;
   u_int32_t open_flags ;
   u_int8_t fileid[20] ;
   u_int32_t adj_fileid ;
   FNAME *log_filename ;
   db_pgno_t meta_pgno ;
   u_int32_t lid ;
   u_int32_t cur_lid ;
   u_int32_t associate_lid ;
   DB_LOCK handle_lock ;
   long cl_id ;
   time_t timestamp ;
   DBT my_rskey ;
   DBT my_rkey ;
   DBT my_rdata ;
   DB_FH *saved_open_fhp ;
   struct __anonstruct_dblistlinks_62 dblistlinks ;
   struct __cq_fq free_queue ;
   struct __cq_aq active_queue ;
   struct __cq_jq join_queue ;
   struct __anonstruct_s_secondaries_63 s_secondaries ;
   struct __anonstruct_s_links_64 s_links ;
   u_int32_t s_refcnt ;
   int (*s_callback)(DB * , DBT const   * , DBT const   * , DBT * ) ;
   DB *s_primary ;
   void *api_internal ;
   void *bt_internal ;
   void *h_internal ;
   void *q_internal ;
   void *xa_internal ;
   int (*associate)(DB * , DB_TXN * , DB * , int (*)(DB * , DBT const   * , DBT const   * ,
                                                     DBT * ) , u_int32_t  ) ;
   int (*close)(DB * , u_int32_t  ) ;
   int (*cursor)(DB * , DB_TXN * , DBC ** , u_int32_t  ) ;
   int (*del)(DB * , DB_TXN * , DBT * , u_int32_t  ) ;
   void (*err)(DB * , int  , char const   *  , ...) ;
   void (*errx)(DB * , char const   *  , ...) ;
   int (*fd)(DB * , int * ) ;
   int (*get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*pget)(DB * , DB_TXN * , DBT * , DBT * , DBT * , u_int32_t  ) ;
   int (*get_byteswapped)(DB * , int * ) ;
   int (*get_cachesize)(DB * , u_int32_t * , u_int32_t * , int * ) ;
   int (*get_dbname)(DB * , char const   ** , char const   ** ) ;
   int (*get_encrypt_flags)(DB * , u_int32_t * ) ;
   int (*get_env)(DB * , DB_ENV ** ) ;
   void (*get_errfile)(DB * , FILE ** ) ;
   void (*get_errpfx)(DB * , char const   ** ) ;
   int (*get_flags)(DB * , u_int32_t * ) ;
   int (*get_lorder)(DB * , int * ) ;
   int (*get_open_flags)(DB * , u_int32_t * ) ;
   int (*get_pagesize)(DB * , u_int32_t * ) ;
   int (*get_transactional)(DB * , int * ) ;
   int (*get_type)(DB * , DBTYPE * ) ;
   int (*join)(DB * , DBC ** , DBC ** , u_int32_t  ) ;
   int (*key_range)(DB * , DB_TXN * , DBT * , DB_KEY_RANGE * , u_int32_t  ) ;
   int (*open)(DB * , DB_TXN * , char const   * , char const   * , DBTYPE  , u_int32_t  ,
               int  ) ;
   int (*put)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*remove)(DB * , char const   * , char const   * , u_int32_t  ) ;
   int (*rename)(DB * , char const   * , char const   * , char const   * , u_int32_t  ) ;
   int (*truncate)(DB * , DB_TXN * , u_int32_t * , u_int32_t  ) ;
   int (*set_append_recno)(DB * , int (*)(DB * , DBT * , db_recno_t  ) ) ;
   int (*set_alloc)(DB * , void *(*)(size_t  ) , void *(*)(void * , size_t  ) , void (*)(void * ) ) ;
   int (*set_cachesize)(DB * , u_int32_t  , u_int32_t  , int  ) ;
   int (*set_dup_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_encrypt)(DB * , char const   * , u_int32_t  ) ;
   void (*set_errcall)(DB * , void (*)(char const   * , char * ) ) ;
   void (*set_errfile)(DB * , FILE * ) ;
   void (*set_errpfx)(DB * , char const   * ) ;
   int (*set_feedback)(DB * , void (*)(DB * , int  , int  ) ) ;
   int (*set_flags)(DB * , u_int32_t  ) ;
   int (*set_lorder)(DB * , int  ) ;
   int (*set_pagesize)(DB * , u_int32_t  ) ;
   int (*set_paniccall)(DB * , void (*)(DB_ENV * , int  ) ) ;
   int (*stat)(DB * , void * , u_int32_t  ) ;
   int (*sync)(DB * , u_int32_t  ) ;
   int (*upgrade)(DB * , char const   * , u_int32_t  ) ;
   int (*verify)(DB * , char const   * , char const   * , FILE * , u_int32_t  ) ;
   int (*get_bt_minkey)(DB * , u_int32_t * ) ;
   int (*set_bt_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_bt_maxkey)(DB * , u_int32_t  ) ;
   int (*set_bt_minkey)(DB * , u_int32_t  ) ;
   int (*set_bt_prefix)(DB * , size_t (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*get_h_ffactor)(DB * , u_int32_t * ) ;
   int (*get_h_nelem)(DB * , u_int32_t * ) ;
   int (*set_h_ffactor)(DB * , u_int32_t  ) ;
   int (*set_h_hash)(DB * , u_int32_t (*)(DB * , void const   * , u_int32_t  ) ) ;
   int (*set_h_nelem)(DB * , u_int32_t  ) ;
   int (*get_re_delim)(DB * , int * ) ;
   int (*get_re_len)(DB * , u_int32_t * ) ;
   int (*get_re_pad)(DB * , int * ) ;
   int (*get_re_source)(DB * , char const   ** ) ;
   int (*set_re_delim)(DB * , int  ) ;
   int (*set_re_len)(DB * , u_int32_t  ) ;
   int (*set_re_pad)(DB * , int  ) ;
   int (*set_re_source)(DB * , char const   * ) ;
   int (*get_q_extentsize)(DB * , u_int32_t * ) ;
   int (*set_q_extentsize)(DB * , u_int32_t  ) ;
   int (*db_am_remove)(DB * , DB_TXN * , char const   * , char const   * , DB_LSN * ) ;
   int (*db_am_rename)(DB * , DB_TXN * , char const   * , char const   * , char const   * ) ;
   int (*stored_get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*stored_close)(DB * , u_int32_t  ) ;
   u_int32_t am_ok ;
   u_int32_t orig_flags ;
   u_int32_t flags ;
};
struct __anonstruct_links_65 {
   DBC *tqe_next ;
   DBC **tqe_prev ;
};
struct __dbc {
   DB *dbp ;
   DB_TXN *txn ;
   struct __anonstruct_links_65 links ;
   DBT *rskey ;
   DBT *rkey ;
   DBT *rdata ;
   DBT my_rskey ;
   DBT my_rkey ;
   DBT my_rdata ;
   u_int32_t lid ;
   u_int32_t locker ;
   DBT lock_dbt ;
   DB_LOCK_ILOCK lock ;
   DB_LOCK mylock ;
   long cl_id ;
   DBTYPE dbtype ;
   DBC_INTERNAL *internal ;
   int (*c_close)(DBC * ) ;
   int (*c_count)(DBC * , db_recno_t * , u_int32_t  ) ;
   int (*c_del)(DBC * , u_int32_t  ) ;
   int (*c_dup)(DBC * , DBC ** , u_int32_t  ) ;
   int (*c_get)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_pget)(DBC * , DBT * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_put)(DBC * , DBT * , DBT * , u_int32_t  ) ;
   int (*c_am_bulk)(DBC * , DBT * , u_int32_t  ) ;
   int (*c_am_close)(DBC * , db_pgno_t  , int * ) ;
   int (*c_am_del)(DBC * ) ;
   int (*c_am_destroy)(DBC * ) ;
   int (*c_am_get)(DBC * , DBT * , DBT * , u_int32_t  , db_pgno_t * ) ;
   int (*c_am_put)(DBC * , DBT * , DBT * , u_int32_t  , db_pgno_t * ) ;
   int (*c_am_writelock)(DBC * ) ;
   u_int32_t flags ;
};
struct __key_range {
   double less ;
   double equal ;
   double greater ;
};
struct __anonstruct_dblist_66 {
   struct __db *lh_first ;
};
struct __anonstruct_links_67 {
   struct __db_env *tqe_next ;
   struct __db_env **tqe_prev ;
};
struct __xa_txn {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __db_env {
   FILE *db_errfile ;
   char const   *db_errpfx ;
   void (*db_errcall)(char const   * , char * ) ;
   void (*db_feedback)(DB_ENV * , int  , int  ) ;
   void (*db_paniccall)(DB_ENV * , int  ) ;
   void *(*db_malloc)(size_t  ) ;
   void *(*db_realloc)(void * , size_t  ) ;
   void (*db_free)(void * ) ;
   u_int32_t verbose ;
   void *app_private ;
   int (*app_dispatch)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ;
   u_int8_t *lk_conflicts ;
   u_int32_t lk_modes ;
   u_int32_t lk_max ;
   u_int32_t lk_max_lockers ;
   u_int32_t lk_max_objects ;
   u_int32_t lk_detect ;
   db_timeout_t lk_timeout ;
   u_int32_t lg_bsize ;
   u_int32_t lg_size ;
   u_int32_t lg_regionmax ;
   u_int32_t mp_gbytes ;
   u_int32_t mp_bytes ;
   size_t mp_size ;
   int mp_ncache ;
   size_t mp_mmapsize ;
   int mp_maxwrite ;
   int mp_maxwrite_sleep ;
   int rep_eid ;
   int (*rep_send)(DB_ENV * , DBT const   * , DBT const   * , DB_LSN const   * , int  ,
                   u_int32_t  ) ;
   u_int32_t tx_max ;
   time_t tx_timestamp ;
   db_timeout_t tx_timeout ;
   char *db_home ;
   char *db_log_dir ;
   char *db_tmp_dir ;
   char **db_data_dir ;
   int data_cnt ;
   int data_next ;
   int db_mode ;
   u_int32_t open_flags ;
   void *reginfo ;
   DB_FH *lockfhp ;
   int (**recover_dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ;
   size_t recover_dtab_size ;
   void *cl_handle ;
   long cl_id ;
   int db_ref ;
   long shm_key ;
   u_int32_t tas_spins ;
   DB_MUTEX *dblist_mutexp ;
   struct __anonstruct_dblist_66 dblist ;
   struct __anonstruct_links_67 links ;
   struct __xa_txn xa_txn ;
   int xa_rmid ;
   void *api1_internal ;
   void *api2_internal ;
   char *passwd ;
   size_t passwd_len ;
   void *crypto_handle ;
   DB_MUTEX *mt_mutexp ;
   int mti ;
   u_long *mt ;
   int (*close)(DB_ENV * , u_int32_t  ) ;
   int (*dbremove)(DB_ENV * , DB_TXN * , char const   * , char const   * , u_int32_t  ) ;
   int (*dbrename)(DB_ENV * , DB_TXN * , char const   * , char const   * , char const   * ,
                   u_int32_t  ) ;
   void (*err)(DB_ENV const   * , int  , char const   *  , ...) ;
   void (*errx)(DB_ENV const   * , char const   *  , ...) ;
   int (*get_home)(DB_ENV * , char const   ** ) ;
   int (*get_open_flags)(DB_ENV * , u_int32_t * ) ;
   int (*open)(DB_ENV * , char const   * , u_int32_t  , int  ) ;
   int (*remove)(DB_ENV * , char const   * , u_int32_t  ) ;
   int (*set_alloc)(DB_ENV * , void *(*)(size_t  ) , void *(*)(void * , size_t  ) ,
                    void (*)(void * ) ) ;
   int (*set_app_dispatch)(DB_ENV * , int (*)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ) ;
   int (*get_data_dirs)(DB_ENV * , char const   *** ) ;
   int (*set_data_dir)(DB_ENV * , char const   * ) ;
   int (*get_encrypt_flags)(DB_ENV * , u_int32_t * ) ;
   int (*set_encrypt)(DB_ENV * , char const   * , u_int32_t  ) ;
   void (*set_errcall)(DB_ENV * , void (*)(char const   * , char * ) ) ;
   void (*get_errfile)(DB_ENV * , FILE ** ) ;
   void (*set_errfile)(DB_ENV * , FILE * ) ;
   void (*get_errpfx)(DB_ENV * , char const   ** ) ;
   void (*set_errpfx)(DB_ENV * , char const   * ) ;
   int (*set_feedback)(DB_ENV * , void (*)(DB_ENV * , int  , int  ) ) ;
   int (*get_flags)(DB_ENV * , u_int32_t * ) ;
   int (*set_flags)(DB_ENV * , u_int32_t  , int  ) ;
   int (*set_paniccall)(DB_ENV * , void (*)(DB_ENV * , int  ) ) ;
   int (*set_rpc_server)(DB_ENV * , void * , char const   * , long  , long  , u_int32_t  ) ;
   int (*get_shm_key)(DB_ENV * , long * ) ;
   int (*set_shm_key)(DB_ENV * , long  ) ;
   int (*get_tas_spins)(DB_ENV * , u_int32_t * ) ;
   int (*set_tas_spins)(DB_ENV * , u_int32_t  ) ;
   int (*get_tmp_dir)(DB_ENV * , char const   ** ) ;
   int (*set_tmp_dir)(DB_ENV * , char const   * ) ;
   int (*get_verbose)(DB_ENV * , u_int32_t  , int * ) ;
   int (*set_verbose)(DB_ENV * , u_int32_t  , int  ) ;
   void *lg_handle ;
   int (*get_lg_bsize)(DB_ENV * , u_int32_t * ) ;
   int (*set_lg_bsize)(DB_ENV * , u_int32_t  ) ;
   int (*get_lg_dir)(DB_ENV * , char const   ** ) ;
   int (*set_lg_dir)(DB_ENV * , char const   * ) ;
   int (*get_lg_max)(DB_ENV * , u_int32_t * ) ;
   int (*set_lg_max)(DB_ENV * , u_int32_t  ) ;
   int (*get_lg_regionmax)(DB_ENV * , u_int32_t * ) ;
   int (*set_lg_regionmax)(DB_ENV * , u_int32_t  ) ;
   int (*log_archive)(DB_ENV * , char *** , u_int32_t  ) ;
   int (*log_cursor)(DB_ENV * , DB_LOGC ** , u_int32_t  ) ;
   int (*log_file)(DB_ENV * , DB_LSN const   * , char * , size_t  ) ;
   int (*log_flush)(DB_ENV * , DB_LSN const   * ) ;
   int (*log_put)(DB_ENV * , DB_LSN * , DBT const   * , u_int32_t  ) ;
   int (*log_stat)(DB_ENV * , DB_LOG_STAT ** , u_int32_t  ) ;
   void *lk_handle ;
   int (*get_lk_conflicts)(DB_ENV * , u_int8_t const   ** , int * ) ;
   int (*set_lk_conflicts)(DB_ENV * , u_int8_t * , int  ) ;
   int (*get_lk_detect)(DB_ENV * , u_int32_t * ) ;
   int (*set_lk_detect)(DB_ENV * , u_int32_t  ) ;
   int (*set_lk_max)(DB_ENV * , u_int32_t  ) ;
   int (*get_lk_max_locks)(DB_ENV * , u_int32_t * ) ;
   int (*set_lk_max_locks)(DB_ENV * , u_int32_t  ) ;
   int (*get_lk_max_lockers)(DB_ENV * , u_int32_t * ) ;
   int (*set_lk_max_lockers)(DB_ENV * , u_int32_t  ) ;
   int (*get_lk_max_objects)(DB_ENV * , u_int32_t * ) ;
   int (*set_lk_max_objects)(DB_ENV * , u_int32_t  ) ;
   int (*lock_detect)(DB_ENV * , u_int32_t  , u_int32_t  , int * ) ;
   int (*lock_dump_region)(DB_ENV * , char const   * , FILE * ) ;
   int (*lock_get)(DB_ENV * , u_int32_t  , u_int32_t  , DBT const   * , db_lockmode_t  ,
                   DB_LOCK * ) ;
   int (*lock_put)(DB_ENV * , DB_LOCK * ) ;
   int (*lock_id)(DB_ENV * , u_int32_t * ) ;
   int (*lock_id_free)(DB_ENV * , u_int32_t  ) ;
   int (*lock_stat)(DB_ENV * , DB_LOCK_STAT ** , u_int32_t  ) ;
   int (*lock_vec)(DB_ENV * , u_int32_t  , u_int32_t  , DB_LOCKREQ * , int  , DB_LOCKREQ ** ) ;
   void *mp_handle ;
   int (*get_cachesize)(DB_ENV * , u_int32_t * , u_int32_t * , int * ) ;
   int (*set_cachesize)(DB_ENV * , u_int32_t  , u_int32_t  , int  ) ;
   int (*get_mp_mmapsize)(DB_ENV * , size_t * ) ;
   int (*set_mp_mmapsize)(DB_ENV * , size_t  ) ;
   int (*get_mp_maxwrite)(DB_ENV * , int * , int * ) ;
   int (*set_mp_maxwrite)(DB_ENV * , int  , int  ) ;
   int (*memp_dump_region)(DB_ENV * , char const   * , FILE * ) ;
   int (*memp_fcreate)(DB_ENV * , DB_MPOOLFILE ** , u_int32_t  ) ;
   int (*memp_register)(DB_ENV * , int  , int (*)(DB_ENV * , db_pgno_t  , void * ,
                                                  DBT * ) , int (*)(DB_ENV * , db_pgno_t  ,
                                                                    void * , DBT * ) ) ;
   int (*memp_stat)(DB_ENV * , DB_MPOOL_STAT ** , DB_MPOOL_FSTAT *** , u_int32_t  ) ;
   int (*memp_sync)(DB_ENV * , DB_LSN * ) ;
   int (*memp_trickle)(DB_ENV * , int  , int * ) ;
   void *rep_handle ;
   int (*rep_elect)(DB_ENV * , int  , int  , u_int32_t  , int * ) ;
   int (*rep_flush)(DB_ENV * ) ;
   int (*rep_process_message)(DB_ENV * , DBT * , DBT * , int * , DB_LSN * ) ;
   int (*rep_start)(DB_ENV * , DBT * , u_int32_t  ) ;
   int (*rep_stat)(DB_ENV * , DB_REP_STAT ** , u_int32_t  ) ;
   int (*get_rep_limit)(DB_ENV * , u_int32_t * , u_int32_t * ) ;
   int (*set_rep_limit)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*set_rep_request)(DB_ENV * , u_int32_t  , u_int32_t  ) ;
   int (*set_rep_transport)(DB_ENV * , int  , int (*)(DB_ENV * , DBT const   * , DBT const   * ,
                                                      DB_LSN const   * , int  , u_int32_t  ) ) ;
   void *tx_handle ;
   int (*get_tx_max)(DB_ENV * , u_int32_t * ) ;
   int (*set_tx_max)(DB_ENV * , u_int32_t  ) ;
   int (*get_tx_timestamp)(DB_ENV * , time_t * ) ;
   int (*set_tx_timestamp)(DB_ENV * , time_t * ) ;
   int (*txn_begin)(DB_ENV * , DB_TXN * , DB_TXN ** , u_int32_t  ) ;
   int (*txn_checkpoint)(DB_ENV * , u_int32_t  , u_int32_t  , u_int32_t  ) ;
   int (*txn_recover)(DB_ENV * , DB_PREPLIST * , long  , long * , u_int32_t  ) ;
   int (*txn_stat)(DB_ENV * , DB_TXN_STAT ** , u_int32_t  ) ;
   int (*get_timeout)(DB_ENV * , db_timeout_t * , u_int32_t  ) ;
   int (*set_timeout)(DB_ENV * , db_timeout_t  , u_int32_t  ) ;
   int test_abort ;
   int test_copy ;
   u_int32_t flags ;
};
struct _statistics {
   int aborted ;
   int aborts ;
   int adds ;
   int deletes ;
   int txns ;
   int found ;
   int notfound ;
};
typedef unsigned short u_int16_t;
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
struct _pthread_descr_struct;
typedef struct _pthread_descr_struct *_pthread_descr;
typedef long long __pthread_cond_align_t;
struct __anonstruct_pthread_cond_t_4 {
   struct _pthread_fastlock __c_lock ;
   _pthread_descr __c_waiting ;
   char __padding[(int )(((48U - sizeof(struct _pthread_fastlock )) - sizeof(_pthread_descr )) -
                         sizeof(__pthread_cond_align_t ))] ;
   __pthread_cond_align_t __align ;
};
typedef struct __anonstruct_pthread_cond_t_4 pthread_cond_t;
struct __anonstruct_pthread_condattr_t_5 {
   int __dummy ;
};
typedef struct __anonstruct_pthread_condattr_t_5 pthread_condattr_t;
struct __anonstruct_pthread_mutex_t_6 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
typedef struct __anonstruct_pthread_mutex_t_6 pthread_mutex_t;
struct __anonstruct_pthread_mutexattr_t_7 {
   int __mutexkind ;
};
typedef struct __anonstruct_pthread_mutexattr_t_7 pthread_mutexattr_t;
typedef u_int16_t db_indx_t;
struct __dbc_internal {
   DBC *opd ;
   void *page ;
   db_pgno_t root ;
   db_pgno_t pgno ;
   db_indx_t indx ;
   DB_LOCK lock ;
   db_lockmode_t lock_mode ;
};
struct __mutex_t {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   u_int32_t locked ;
   u_int32_t mutex_set_wait ;
   u_int32_t mutex_set_nowait ;
   u_int32_t mutex_set_spin ;
   u_int32_t mutex_set_spins ;
   u_int32_t flags ;
};
struct __fh_t {
   DB_MUTEX *mutexp ;
   int ref ;
   int fd ;
   char *name ;
   u_int32_t pgno ;
   u_int32_t pgsize ;
   u_int32_t offset ;
   u_int8_t flags ;
};
struct __pg_chksum {
   u_int8_t unused[2] ;
   u_int8_t chksum[4] ;
};
typedef struct __pg_chksum PG_CHKSUM;
struct __pg_crypto {
   u_int8_t unused[2] ;
   u_int8_t chksum[20] ;
   u_int8_t iv[16] ;
};
typedef struct __pg_crypto PG_CRYPTO;
struct _db_page {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   db_pgno_t prev_pgno ;
   db_pgno_t next_pgno ;
   db_indx_t entries ;
   db_indx_t hf_offset ;
   u_int8_t level ;
   u_int8_t type ;
};
typedef struct _db_page PAGE;
struct _bkeydata {
   db_indx_t len ;
   u_int8_t type ;
   u_int8_t data[1] ;
};
typedef struct _bkeydata BKEYDATA;
struct _boverflow {
   db_indx_t unused1 ;
   u_int8_t type ;
   u_int8_t unused2 ;
   db_pgno_t pgno ;
   u_int32_t tlen ;
};
typedef struct _boverflow BOVERFLOW;
struct _binternal {
   db_indx_t len ;
   u_int8_t type ;
   u_int8_t unused ;
   db_pgno_t pgno ;
   db_recno_t nrecs ;
   u_int8_t data[1] ;
};
typedef struct _binternal BINTERNAL;
struct __dbpginfo {
   size_t db_pagesize ;
   u_int32_t flags ;
   DBTYPE type ;
};
typedef struct __dbpginfo DB_PGINFO;
struct _dbmeta33 {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t pagesize ;
   u_int8_t encrypt_alg ;
   u_int8_t type ;
   u_int8_t metaflags ;
   u_int8_t unused1 ;
   u_int32_t free ;
   db_pgno_t last_pgno ;
   u_int32_t unused3 ;
   u_int32_t key_count ;
   u_int32_t record_count ;
   u_int32_t flags ;
   u_int8_t uid[20] ;
};
typedef struct _dbmeta33 DBMETA;
struct __db_rep;
typedef struct __db_rep DB_REP;
struct __rep {
   DB_MUTEX mutex ;
   roff_t db_mutex_off ;
   u_int32_t tally_off ;
   u_int32_t v2tally_off ;
   int eid ;
   int master_id ;
   u_int32_t egen ;
   u_int32_t gen ;
   u_int32_t recover_gen ;
   int asites ;
   int nsites ;
   int priority ;
   u_int32_t gbytes ;
   u_int32_t bytes ;
   u_int32_t request_gap ;
   u_int32_t max_gap ;
   u_int32_t msg_th ;
   int start_th ;
   u_int32_t handle_cnt ;
   u_int32_t op_cnt ;
   int in_recovery ;
   time_t timestamp ;
   int sites ;
   int winner ;
   int w_priority ;
   u_int32_t w_gen ;
   DB_LSN w_lsn ;
   int w_tiebreaker ;
   int votes ;
   DB_REP_STAT stat ;
   u_int32_t flags ;
};
typedef struct __rep REP;
struct __db_rep {
   DB_MUTEX *rep_mutexp ;
   DB_MUTEX *db_mutexp ;
   DB *rep_db ;
   REP *region ;
};
struct __cursor;
typedef struct __cursor BTREE_CURSOR;
struct __epg;
typedef struct __epg EPG;
struct __epg {
   PAGE *page ;
   db_indx_t indx ;
   db_indx_t entries ;
   DB_LOCK lock ;
   db_lockmode_t lock_mode ;
};
struct __cursor {
   DBC *opd ;
   void *page ;
   db_pgno_t root ;
   db_pgno_t pgno ;
   db_indx_t indx ;
   DB_LOCK lock ;
   db_lockmode_t lock_mode ;
   EPG *sp ;
   EPG *csp ;
   EPG *esp ;
   EPG stack[5] ;
   db_indx_t ovflsize ;
   db_recno_t recno ;
   u_int32_t order ;
   u_int32_t flags ;
};
enum __anonenum_db_ca_mode_54 {
    DB_CA_DI = 1,
    DB_CA_DUP = 2,
    DB_CA_RSPLIT = 3,
    DB_CA_SPLIT = 4
};
typedef enum __anonenum_db_ca_mode_54 db_ca_mode;
struct _rinternal {
   db_pgno_t pgno ;
   db_recno_t nrecs ;
};
typedef struct _rinternal RINTERNAL;
struct __btree;
typedef struct __btree BTREE;
struct __btree {
   db_pgno_t bt_meta ;
   db_pgno_t bt_root ;
   u_int32_t bt_maxkey ;
   u_int32_t bt_minkey ;
   int (*bt_compare)(DB * , DBT const   * , DBT const   * ) ;
   size_t (*bt_prefix)(DB * , DBT const   * , DBT const   * ) ;
   int re_pad ;
   int re_delim ;
   u_int32_t re_len ;
   char *re_source ;
   db_pgno_t bt_lpgno ;
   int re_modified ;
   FILE *re_fp ;
   int re_eof ;
   db_recno_t re_last ;
};
struct __anonstruct_q_74 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __mpoolfile {
   DB_MUTEX mutex ;
   u_int32_t mpf_cnt ;
   u_int32_t block_cnt ;
   roff_t path_off ;
   int32_t deadfile ;
   struct __anonstruct_q_74 q ;
   db_pgno_t last_pgno ;
   db_pgno_t orig_last_pgno ;
   db_pgno_t maxpgno ;
   int32_t ftype ;
   int32_t priority ;
   int32_t file_written ;
   int32_t no_backing_file ;
   int32_t unlink_on_close ;
   DB_MPOOL_FSTAT stat ;
   int32_t lsn_off ;
   u_int32_t clear_len ;
   roff_t fileid_off ;
   roff_t pgcookie_len ;
   roff_t pgcookie_off ;
   u_int32_t flags ;
};
struct __queue;
typedef struct __queue QUEUE;
struct __qmpf {
   int pinref ;
   DB_MPOOLFILE *mpf ;
};
struct __mpfarray {
   u_int32_t n_extent ;
   u_int32_t low_extent ;
   u_int32_t hi_extent ;
   struct __qmpf *mpfarray ;
};
typedef struct __mpfarray MPFARRAY;
struct __queue {
   db_pgno_t q_meta ;
   db_pgno_t q_root ;
   int re_pad ;
   u_int32_t re_len ;
   u_int32_t rec_page ;
   u_int32_t page_ext ;
   MPFARRAY array1 ;
   MPFARRAY array2 ;
   DBT pgcookie ;
   DB_PGINFO pginfo ;
   char *path ;
   char *name ;
   char *dir ;
   int mode ;
};
struct __db_cipher;
typedef struct __db_cipher DB_CIPHER;
enum __anonenum_APPNAME_39 {
    DB_APP_NONE = 0,
    DB_APP_DATA = 1,
    DB_APP_LOG = 2,
    DB_APP_TMP = 3
};
typedef enum __anonenum_APPNAME_39 APPNAME;
struct __db_reginfo_t;
typedef struct __db_reginfo_t REGINFO;
enum __anonenum_reg_type_50 {
    INVALID_REGION_TYPE = 0,
    REGION_TYPE_ENV = 1,
    REGION_TYPE_LOCK = 2,
    REGION_TYPE_LOG = 3,
    REGION_TYPE_MPOOL = 4,
    REGION_TYPE_MUTEX = 5,
    REGION_TYPE_TXN = 6
};
typedef enum __anonenum_reg_type_50 reg_type;
struct __anonstruct_q_51 {
   ssize_t sle_next ;
   ssize_t sle_prev ;
};
struct __db_region {
   DB_MUTEX mutex ;
   struct __anonstruct_q_51 q ;
   reg_type type ;
   u_int32_t id ;
   roff_t size ;
   roff_t primary ;
   long segid ;
};
typedef struct __db_region REGION;
struct __db_reginfo_t {
   reg_type type ;
   u_int32_t id ;
   int mode ;
   REGION *rp ;
   char *name ;
   void *addr ;
   void *primary ;
   u_int32_t flags ;
};
struct __db_cipher {
   u_int (*adj_size)(size_t  ) ;
   int (*close)(DB_ENV * , void * ) ;
   int (*decrypt)(DB_ENV * , void * , void * , u_int8_t * , size_t  ) ;
   int (*encrypt)(DB_ENV * , void * , void * , u_int8_t * , size_t  ) ;
   int (*init)(DB_ENV * , DB_CIPHER * ) ;
   u_int8_t mac_key[20] ;
   void *data ;
   u_int8_t alg ;
   u_int8_t spare[3] ;
   u_int32_t flags ;
};
struct _btmeta33 {
   DBMETA dbmeta ;
   u_int32_t maxkey ;
   u_int32_t minkey ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t root ;
   u_int32_t unused[92] ;
   u_int32_t crypto_magic ;
   u_int32_t trash[3] ;
   u_int8_t iv[16] ;
   u_int8_t chksum[20] ;
};
typedef struct _btmeta33 BTMETA;
struct __db_entry {
   DB *dbp ;
   int deleted ;
};
typedef struct __db_entry DB_ENTRY;
struct __anonstruct_q_74___0 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __fname {
   struct __anonstruct_q_74___0 q ;
   int32_t id ;
   DBTYPE s_type ;
   roff_t name_off ;
   db_pgno_t meta_pgno ;
   u_int8_t ufid[20] ;
   u_int32_t create_txnid ;
   int is_durable ;
};
struct __db_log;
typedef struct __db_log DB_LOG;
struct __db_log {
   DB_MUTEX *mutexp ;
   DB_ENTRY *dbentry ;
   int32_t dbentry_cnt ;
   u_int32_t lfname ;
   DB_FH *lfhp ;
   u_int8_t *bufp ;
   DB_ENV *dbenv ;
   REGINFO reginfo ;
   u_int32_t flags ;
};
enum __anonenum_ca_recno_arg_53 {
    CA_DELETE = 0,
    CA_IAFTER = 1,
    CA_IBEFORE = 2,
    CA_ICURRENT = 3
};
typedef enum __anonenum_ca_recno_arg_53 ca_recno_arg;
struct ___bam_split_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t left ;
   DB_LSN llsn ;
   db_pgno_t right ;
   DB_LSN rlsn ;
   u_int32_t indx ;
   db_pgno_t npgno ;
   DB_LSN nlsn ;
   db_pgno_t root_pgno ;
   DBT pg ;
   u_int32_t opflags ;
};
typedef struct ___bam_split_args __bam_split_args;
struct ___bam_rsplit_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DBT pgdbt ;
   db_pgno_t root_pgno ;
   db_pgno_t nrec ;
   DBT rootent ;
   DB_LSN rootlsn ;
};
typedef struct ___bam_rsplit_args __bam_rsplit_args;
struct ___bam_adj_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN lsn ;
   u_int32_t indx ;
   u_int32_t indx_copy ;
   u_int32_t is_insert ;
};
typedef struct ___bam_adj_args __bam_adj_args;
struct ___bam_cadjust_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN lsn ;
   u_int32_t indx ;
   int32_t adjust ;
   u_int32_t opflags ;
};
typedef struct ___bam_cadjust_args __bam_cadjust_args;
struct ___bam_cdel_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN lsn ;
   u_int32_t indx ;
};
typedef struct ___bam_cdel_args __bam_cdel_args;
struct ___bam_repl_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN lsn ;
   u_int32_t indx ;
   u_int32_t isdeleted ;
   DBT orig ;
   DBT repl ;
   u_int32_t prefix ;
   u_int32_t suffix ;
};
typedef struct ___bam_repl_args __bam_repl_args;
struct ___bam_root_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t meta_pgno ;
   db_pgno_t root_pgno ;
   DB_LSN meta_lsn ;
};
typedef struct ___bam_root_args __bam_root_args;
struct ___bam_curadj_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_ca_mode mode ;
   db_pgno_t from_pgno ;
   db_pgno_t to_pgno ;
   db_pgno_t left_pgno ;
   u_int32_t first_indx ;
   u_int32_t from_indx ;
   u_int32_t to_indx ;
};
typedef struct ___bam_curadj_args __bam_curadj_args;
struct ___bam_rcuradj_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   ca_recno_arg mode ;
   db_pgno_t root ;
   db_recno_t recno ;
   u_int32_t order ;
};
typedef struct ___bam_rcuradj_args __bam_rcuradj_args;
struct __anonstruct_db_trunc_param_55 {
   DBC *dbc ;
   u_int32_t count ;
};
typedef struct __anonstruct_db_trunc_param_55 db_trunc_param;
typedef struct _IO_FILE _IO_FILE;
enum __anonenum_dir_76 {
    UP = 0,
    DOWN = 1
};
struct __db_bt_stat;
typedef struct __db_bt_stat DB_BTREE_STAT;
struct __db_bt_stat {
   u_int32_t bt_magic ;
   u_int32_t bt_version ;
   u_int32_t bt_metaflags ;
   u_int32_t bt_nkeys ;
   u_int32_t bt_ndata ;
   u_int32_t bt_pagesize ;
   u_int32_t bt_maxkey ;
   u_int32_t bt_minkey ;
   u_int32_t bt_re_len ;
   u_int32_t bt_re_pad ;
   u_int32_t bt_levels ;
   u_int32_t bt_int_pg ;
   u_int32_t bt_leaf_pg ;
   u_int32_t bt_dup_pg ;
   u_int32_t bt_over_pg ;
   u_int32_t bt_free ;
   u_int32_t bt_int_pgfree ;
   u_int32_t bt_leaf_pgfree ;
   u_int32_t bt_dup_pgfree ;
   u_int32_t bt_over_pgfree ;
};
struct _dbmeta31 {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t pagesize ;
   u_int8_t unused1[1] ;
   u_int8_t type ;
   u_int8_t unused2[2] ;
   u_int32_t free ;
   DB_LSN unused3 ;
   u_int32_t key_count ;
   u_int32_t record_count ;
   u_int32_t flags ;
   u_int8_t uid[20] ;
};
typedef struct _dbmeta31 DBMETA31;
struct _btmeta31 {
   DBMETA31 dbmeta ;
   u_int32_t maxkey ;
   u_int32_t minkey ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t root ;
};
typedef struct _btmeta31 BTMETA31;
struct _dbmeta30 {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t pagesize ;
   u_int8_t unused1[1] ;
   u_int8_t type ;
   u_int8_t unused2[2] ;
   u_int32_t free ;
   u_int32_t flags ;
   u_int8_t uid[20] ;
};
typedef struct _dbmeta30 DBMETA30;
struct _btmeta30 {
   DBMETA30 dbmeta ;
   u_int32_t maxkey ;
   u_int32_t minkey ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t root ;
};
typedef struct _btmeta30 BTMETA30;
struct _btmeta2X {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t pagesize ;
   u_int32_t maxkey ;
   u_int32_t minkey ;
   u_int32_t free ;
   u_int32_t flags ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int8_t uid[20] ;
};
typedef struct _btmeta2X BTMETA2X;
struct __lsn_page {
   DB_LSN lsn ;
   int32_t fid ;
   DB_LOCK_ILOCK pgdesc ;
   u_int32_t flags ;
};
typedef struct __lsn_page LSN_PAGE;
struct __txn_recs {
   int npages ;
   int nalloc ;
   LSN_PAGE *array ;
   u_int32_t txnid ;
   u_int32_t lockid ;
};
typedef struct __txn_recs TXN_RECS;
typedef struct __txn_logrec DB_TXNLOGREC;
struct _chain {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __db_txnmgr {
   DB_MUTEX *mutexp ;
   struct _chain txn_chain ;
   u_int32_t n_discards ;
   DB_ENV *dbenv ;
   REGINFO reginfo ;
};
struct __anonstruct_links_72 {
   struct __txn_logrec *stqe_next ;
};
struct __txn_logrec {
   struct __anonstruct_links_72 links ;
   u_int8_t data[1] ;
};
struct _hashmeta33 {
   DBMETA dbmeta ;
   u_int32_t max_bucket ;
   u_int32_t high_mask ;
   u_int32_t low_mask ;
   u_int32_t ffactor ;
   u_int32_t nelem ;
   u_int32_t h_charkey ;
   u_int32_t spares[32] ;
   u_int32_t unused[59] ;
   u_int32_t crypto_magic ;
   u_int32_t trash[3] ;
   u_int8_t iv[16] ;
   u_int8_t chksum[20] ;
};
typedef struct _hashmeta33 HMETA;
struct _hkeydata {
   u_int8_t type ;
   u_int8_t data[1] ;
};
typedef struct _hkeydata HKEYDATA;
struct _hoffpage {
   u_int8_t type ;
   u_int8_t unused[3] ;
   db_pgno_t pgno ;
   u_int32_t tlen ;
};
typedef struct _hoffpage HOFFPAGE;
struct _hoffdup {
   u_int8_t type ;
   u_int8_t unused[3] ;
   db_pgno_t pgno ;
};
typedef struct _hoffdup HOFFDUP;
struct hash_t {
   db_pgno_t meta_pgno ;
   u_int32_t h_ffactor ;
   u_int32_t h_nelem ;
   u_int32_t (*h_hash)(DB * , void const   * , u_int32_t  ) ;
};
typedef struct hash_t HASH;
struct cursor_t {
   DBC *opd ;
   void *page ;
   db_pgno_t root ;
   db_pgno_t pgno ;
   db_indx_t indx ;
   DB_LOCK lock ;
   db_lockmode_t lock_mode ;
   DB_LOCK hlock ;
   HMETA *hdr ;
   PAGE *split_buf ;
   db_pgno_t bucket ;
   db_pgno_t lbucket ;
   db_indx_t dup_off ;
   db_indx_t dup_len ;
   db_indx_t dup_tlen ;
   u_int32_t seek_size ;
   db_pgno_t seek_found_page ;
   u_int32_t order ;
   u_int32_t flags ;
};
typedef struct cursor_t HASH_CURSOR;
enum __anonenum_db_ham_mode_65 {
    DB_HAM_CHGPG = 1,
    DB_HAM_DELFIRSTPG = 2,
    DB_HAM_DELMIDPG = 3,
    DB_HAM_DELLASTPG = 4,
    DB_HAM_DUP = 5,
    DB_HAM_SPLIT = 6
};
typedef enum __anonenum_db_ham_mode_65 db_ham_mode;
struct ___ham_insdel_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t fileid ;
   db_pgno_t pgno ;
   u_int32_t ndx ;
   DB_LSN pagelsn ;
   DBT key ;
   DBT data ;
};
typedef struct ___ham_insdel_args __ham_insdel_args;
struct ___ham_newpage_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t fileid ;
   db_pgno_t prev_pgno ;
   DB_LSN prevlsn ;
   db_pgno_t new_pgno ;
   DB_LSN pagelsn ;
   db_pgno_t next_pgno ;
   DB_LSN nextlsn ;
};
typedef struct ___ham_newpage_args __ham_newpage_args;
struct ___ham_splitdata_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   u_int32_t opcode ;
   db_pgno_t pgno ;
   DBT pageimage ;
   DB_LSN pagelsn ;
};
typedef struct ___ham_splitdata_args __ham_splitdata_args;
struct ___ham_replace_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   u_int32_t ndx ;
   DB_LSN pagelsn ;
   int32_t off ;
   DBT olditem ;
   DBT newitem ;
   u_int32_t makedup ;
};
typedef struct ___ham_replace_args __ham_replace_args;
struct ___ham_copypage_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN pagelsn ;
   db_pgno_t next_pgno ;
   DB_LSN nextlsn ;
   db_pgno_t nnext_pgno ;
   DB_LSN nnextlsn ;
   DBT page ;
};
typedef struct ___ham_copypage_args __ham_copypage_args;
struct ___ham_metagroup_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   u_int32_t bucket ;
   db_pgno_t mmpgno ;
   DB_LSN mmetalsn ;
   db_pgno_t mpgno ;
   DB_LSN metalsn ;
   db_pgno_t pgno ;
   DB_LSN pagelsn ;
   u_int32_t newalloc ;
};
typedef struct ___ham_metagroup_args __ham_metagroup_args;
struct ___ham_groupalloc_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   DB_LSN meta_lsn ;
   db_pgno_t start_pgno ;
   u_int32_t num ;
   db_pgno_t free ;
};
typedef struct ___ham_groupalloc_args __ham_groupalloc_args;
struct ___ham_curadj_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   u_int32_t indx ;
   u_int32_t len ;
   u_int32_t dup_off ;
   int add ;
   int is_dup ;
   u_int32_t order ;
};
typedef struct ___ham_curadj_args __ham_curadj_args;
struct ___ham_chgpg_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_ham_mode mode ;
   db_pgno_t old_pgno ;
   db_pgno_t new_pgno ;
   u_int32_t old_indx ;
   u_int32_t new_indx ;
};
typedef struct ___ham_chgpg_args __ham_chgpg_args;
struct __db_h_stat;
typedef struct __db_h_stat DB_HASH_STAT;
struct __db_h_stat {
   u_int32_t hash_magic ;
   u_int32_t hash_version ;
   u_int32_t hash_metaflags ;
   u_int32_t hash_nkeys ;
   u_int32_t hash_ndata ;
   u_int32_t hash_pagesize ;
   u_int32_t hash_ffactor ;
   u_int32_t hash_buckets ;
   u_int32_t hash_free ;
   u_int32_t hash_bfree ;
   u_int32_t hash_bigpages ;
   u_int32_t hash_big_bfree ;
   u_int32_t hash_overflows ;
   u_int32_t hash_ovfl_free ;
   u_int32_t hash_dup ;
   u_int32_t hash_dup_free ;
};
enum __anonenum_DB_OS_SEEK_52 {
    DB_OS_SEEK_CUR = 0,
    DB_OS_SEEK_END = 1,
    DB_OS_SEEK_SET = 2
};
typedef enum __anonenum_DB_OS_SEEK_52 DB_OS_SEEK;
struct _hashmeta31 {
   DBMETA31 dbmeta ;
   u_int32_t max_bucket ;
   u_int32_t high_mask ;
   u_int32_t low_mask ;
   u_int32_t ffactor ;
   u_int32_t nelem ;
   u_int32_t h_charkey ;
   u_int32_t spares[32] ;
};
typedef struct _hashmeta31 HMETA31;
struct _hashmeta30 {
   DBMETA30 dbmeta ;
   u_int32_t max_bucket ;
   u_int32_t high_mask ;
   u_int32_t low_mask ;
   u_int32_t ffactor ;
   u_int32_t nelem ;
   u_int32_t h_charkey ;
   u_int32_t spares[32] ;
};
typedef struct _hashmeta30 HMETA30;
struct hashhdr {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t pagesize ;
   u_int32_t ovfl_point ;
   u_int32_t last_freed ;
   u_int32_t max_bucket ;
   u_int32_t high_mask ;
   u_int32_t low_mask ;
   u_int32_t ffactor ;
   u_int32_t nelem ;
   u_int32_t h_charkey ;
   u_int32_t flags ;
   u_int32_t spares[32] ;
   u_int8_t uid[20] ;
};
typedef struct hashhdr HASHHDR;
struct __vrfy_childinfo;
typedef struct __vrfy_childinfo VRFY_CHILDINFO;
struct __vrfy_dbinfo;
typedef struct __vrfy_dbinfo VRFY_DBINFO;
struct __vrfy_pageinfo;
typedef struct __vrfy_pageinfo VRFY_PAGEINFO;
struct __subdbs {
   struct __vrfy_childinfo *lh_first ;
};
struct __activepips {
   struct __vrfy_pageinfo *lh_first ;
};
struct __vrfy_dbinfo {
   DBTYPE type ;
   struct __subdbs subdbs ;
   DB *pgdbp ;
   DB *cdbp ;
   struct __activepips activepips ;
   DB *pgset ;
   DB *salvage_pages ;
   db_pgno_t last_pgno ;
   db_pgno_t pgs_remaining ;
   db_pgno_t prev_pgno ;
   db_pgno_t next_pgno ;
   u_int8_t leaf_type ;
   u_int32_t re_len ;
   u_int32_t rec_page ;
   u_int32_t page_ext ;
   u_int32_t first_recno ;
   u_int32_t last_recno ;
   int nextents ;
   db_pgno_t *extents ;
   u_int32_t flags ;
};
struct __anonstruct_links_53 {
   struct __vrfy_pageinfo *le_next ;
   struct __vrfy_pageinfo **le_prev ;
};
struct __vrfy_pageinfo {
   u_int8_t type ;
   u_int8_t bt_level ;
   u_int8_t unused1 ;
   u_int8_t unused2 ;
   db_pgno_t pgno ;
   db_pgno_t prev_pgno ;
   db_pgno_t next_pgno ;
   db_pgno_t root ;
   db_pgno_t free ;
   db_indx_t entries ;
   u_int16_t unused ;
   db_recno_t rec_cnt ;
   u_int32_t re_len ;
   u_int32_t bt_minkey ;
   u_int32_t bt_maxkey ;
   u_int32_t h_ffactor ;
   u_int32_t h_nelem ;
   u_int32_t refcount ;
   u_int32_t olen ;
   u_int32_t flags ;
   struct __anonstruct_links_53 links ;
   u_int32_t pi_refcount ;
};
struct __anonstruct_links_54 {
   struct __vrfy_childinfo *le_next ;
   struct __vrfy_childinfo **le_prev ;
};
struct __vrfy_childinfo {
   db_pgno_t pgno ;
   u_int32_t type ;
   db_recno_t nrecs ;
   u_int32_t tlen ;
   u_int32_t refcnt ;
   struct __anonstruct_links_54 links ;
};
struct __db_regionh {
   ssize_t slh_first ;
};
struct __db_reg_env {
   DB_MUTEX mutex ;
   u_int32_t magic ;
   int envpanic ;
   int majver ;
   int minver ;
   int patch ;
   u_int32_t init_flags ;
   roff_t cipher_off ;
   struct __db_regionh regionq ;
   u_int32_t refcnt ;
   roff_t rep_off ;
   size_t pad ;
};
typedef struct __db_reg_env REGENV;
struct _qmeta33 {
   DBMETA dbmeta ;
   u_int32_t first_recno ;
   u_int32_t cur_recno ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t rec_page ;
   u_int32_t page_ext ;
   u_int32_t unused[91] ;
   u_int32_t crypto_magic ;
   u_int32_t trash[3] ;
   u_int8_t iv[16] ;
   u_int8_t chksum[20] ;
};
typedef struct _qmeta33 QMETA;
struct _qpage {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t unused0[3] ;
   u_int8_t unused1[1] ;
   u_int8_t type ;
   u_int8_t unused2[2] ;
   u_int8_t chksum[20] ;
   u_int8_t iv[16] ;
};
typedef struct _qpage QPAGE;
struct _qamdata {
   u_int8_t flags ;
   u_int8_t data[1] ;
};
typedef struct _qamdata QAMDATA;
struct __qcursor;
typedef struct __qcursor QUEUE_CURSOR;
struct __qcursor {
   DBC *opd ;
   void *page ;
   db_pgno_t root ;
   db_pgno_t pgno ;
   db_indx_t indx ;
   DB_LOCK lock ;
   db_lockmode_t lock_mode ;
   db_recno_t recno ;
   u_int32_t flags ;
};
enum __anonenum_qam_position_mode_79 {
    QAM_READ = 0,
    QAM_WRITE = 1,
    QAM_CONSUME = 2
};
typedef enum __anonenum_qam_position_mode_79 qam_position_mode;
enum __anonenum_qam_probe_mode_80 {
    QAM_PROBE_GET = 0,
    QAM_PROBE_PUT = 1,
    QAM_PROBE_MPF = 2
};
typedef enum __anonenum_qam_probe_mode_80 qam_probe_mode;
struct ___qam_incfirst_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_recno_t recno ;
   db_pgno_t meta_pgno ;
};
typedef struct ___qam_incfirst_args __qam_incfirst_args;
struct ___qam_mvptr_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t fileid ;
   db_recno_t old_first ;
   db_recno_t new_first ;
   db_recno_t old_cur ;
   db_recno_t new_cur ;
   DB_LSN metalsn ;
   db_pgno_t meta_pgno ;
};
typedef struct ___qam_mvptr_args __qam_mvptr_args;
struct ___qam_del_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t indx ;
   db_recno_t recno ;
};
typedef struct ___qam_del_args __qam_del_args;
struct ___qam_add_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t indx ;
   db_recno_t recno ;
   DBT data ;
   u_int32_t vflag ;
   DBT olddata ;
};
typedef struct ___qam_add_args __qam_add_args;
struct ___qam_delext_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t indx ;
   db_recno_t recno ;
   DBT data ;
};
typedef struct ___qam_delext_args __qam_delext_args;
struct __qam_filelist {
   DB_MPOOLFILE *mpf ;
   u_int32_t id ;
};
typedef struct __qam_filelist QUEUE_FILELIST;
enum __anonenum_qam_name_op_78 {
    QAM_NAME_DISCARD = 0,
    QAM_NAME_RENAME = 1,
    QAM_NAME_REMOVE = 2
};
typedef enum __anonenum_qam_name_op_78 qam_name_op;
struct __db_txnhead;
typedef struct __db_txnhead DB_TXNHEAD;
struct __db_txnlist;
enum __anonenum_db_txnlist_type_54 {
    TXNLIST_DELETE = 0,
    TXNLIST_LSN = 1,
    TXNLIST_PGNO = 2,
    TXNLIST_TXNID = 3
};
typedef enum __anonenum_db_txnlist_type_54 db_txnlist_type;
struct __anonstruct_gen_array_55 {
   u_int32_t generation ;
   u_int32_t txn_min ;
   u_int32_t txn_max ;
};
struct __db_headlink {
   struct __db_txnlist *lh_first ;
};
struct __db_txnhead {
   u_int32_t maxid ;
   DB_LSN maxlsn ;
   DB_LSN ckplsn ;
   DB_LSN trunc_lsn ;
   u_int32_t generation ;
   u_int32_t gen_alloc ;
   struct __anonstruct_gen_array_55 *gen_array ;
   u_int nslots ;
   struct __db_headlink head[1] ;
};
struct __anonstruct_links_56___0 {
   struct __db_txnlist *le_next ;
   struct __db_txnlist **le_prev ;
};
struct __anonstruct_t_58 {
   u_int32_t txnid ;
   u_int32_t generation ;
   int32_t status ;
};
struct __anonstruct_l_59 {
   u_int32_t ntxns ;
   u_int32_t maxn ;
   DB_LSN *lsn_array ;
};
struct __anonstruct_p_60 {
   u_int32_t nentries ;
   u_int32_t maxentry ;
   int32_t locked ;
   char *fname ;
   int32_t fileid ;
   db_pgno_t *pgno_array ;
   u_int8_t uid[20] ;
};
union __anonunion_u_57 {
   struct __anonstruct_t_58 t ;
   struct __anonstruct_l_59 l ;
   struct __anonstruct_p_60 p ;
};
struct __db_txnlist {
   db_txnlist_type type ;
   struct __anonstruct_links_56___0 links ;
   union __anonunion_u_57 u ;
};
struct __db_qam_stat;
typedef struct __db_qam_stat DB_QUEUE_STAT;
struct __db_qam_stat {
   u_int32_t qs_magic ;
   u_int32_t qs_version ;
   u_int32_t qs_metaflags ;
   u_int32_t qs_nkeys ;
   u_int32_t qs_ndata ;
   u_int32_t qs_pagesize ;
   u_int32_t qs_extentsize ;
   u_int32_t qs_pages ;
   u_int32_t qs_re_len ;
   u_int32_t qs_re_pad ;
   u_int32_t qs_pgfree ;
   u_int32_t qs_first_recno ;
   u_int32_t qs_cur_recno ;
};
struct _qmeta31 {
   DBMETA31 dbmeta ;
   u_int32_t start ;
   u_int32_t first_recno ;
   u_int32_t cur_recno ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t rec_page ;
};
typedef struct _qmeta31 QMETA31;
struct _qmeta32 {
   DBMETA31 dbmeta ;
   u_int32_t first_recno ;
   u_int32_t cur_recno ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t rec_page ;
   u_int32_t page_ext ;
};
typedef struct _qmeta32 QMETA32;
struct _qmeta30 {
   DBMETA30 dbmeta ;
   u_int32_t start ;
   u_int32_t first_recno ;
   u_int32_t cur_recno ;
   u_int32_t re_len ;
   u_int32_t re_pad ;
   u_int32_t rec_page ;
};
typedef struct _qmeta30 QMETA30;
struct __rep_control {
   u_int32_t rep_version ;
   u_int32_t log_version ;
   DB_LSN lsn ;
   u_int32_t rectype ;
   u_int32_t gen ;
   u_int32_t flags ;
};
typedef struct __rep_control REP_CONTROL;
struct __log;
typedef struct __log LOG;
struct __log_persist;
typedef struct __log_persist LOGP;
struct __log_persist {
   u_int32_t magic ;
   u_int32_t version ;
   u_int32_t log_size ;
   u_int32_t mode ;
};
struct __fq1 {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __commit {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __free {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __log {
   DB_MUTEX fq_mutex ;
   LOGP persist ;
   struct __fq1 fq ;
   int32_t fid_max ;
   roff_t free_fid_stack ;
   int free_fids ;
   int free_fids_alloced ;
   DB_LSN lsn ;
   DB_LSN f_lsn ;
   size_t b_off ;
   u_int32_t w_off ;
   u_int32_t len ;
   int in_flush ;
   roff_t flush_mutex_off ;
   DB_LSN s_lsn ;
   DB_LOG_STAT stat ;
   DB_LSN waiting_lsn ;
   DB_LSN verify_lsn ;
   DB_LSN max_wait_lsn ;
   u_int32_t wait_recs ;
   u_int32_t rcvd_recs ;
   DB_LSN ready_lsn ;
   DB_LSN cached_ckp_lsn ;
   roff_t buffer_off ;
   u_int32_t buffer_size ;
   u_int32_t log_size ;
   u_int32_t log_nsize ;
   u_int32_t ncommit ;
   DB_LSN t_lsn ;
   struct __commit commits ;
   struct __free free_commits ;
};
struct __db_txnregion;
typedef struct __db_txnregion DB_TXNREGION;
struct __active {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __db_txnregion {
   u_int32_t maxtxns ;
   u_int32_t last_txnid ;
   u_int32_t cur_maxid ;
   DB_LSN last_ckp ;
   time_t time_ckp ;
   DB_TXN_STAT stat ;
   u_int32_t flags ;
   struct __active active_txn ;
};
struct ___txn_regop_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t timestamp ;
   DBT locks ;
};
typedef struct ___txn_regop_args __txn_regop_args;
struct ___txn_ckp_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DB_LSN ckp_lsn ;
   DB_LSN last_ckp ;
   int32_t timestamp ;
   u_int32_t rep_gen ;
};
typedef struct ___txn_ckp_args __txn_ckp_args;
struct ___txn_xa_regop_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   DBT xid ;
   int32_t formatID ;
   u_int32_t gtrid ;
   u_int32_t bqual ;
   DB_LSN begin_lsn ;
   DBT locks ;
};
typedef struct ___txn_xa_regop_args __txn_xa_regop_args;
struct __rep_vote {
   u_int32_t egen ;
   int nsites ;
   int priority ;
   int tiebreaker ;
};
typedef struct __rep_vote REP_VOTE_INFO;
struct __rep_vtally {
   u_int32_t egen ;
   int eid ;
};
typedef struct __rep_vtally REP_VTALLY;
struct __lsn_collection {
   int nlsns ;
   int nalloc ;
   DB_LSN *array ;
};
typedef struct __lsn_collection LSN_COLLECTION;
struct ___dbreg_register_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   DBT name ;
   DBT uid ;
   int32_t fileid ;
   DBTYPE ftype ;
   db_pgno_t meta_pgno ;
   u_int32_t id ;
};
typedef struct ___dbreg_register_args __dbreg_register_args;
struct ___txn_child_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t child ;
   DB_LSN c_lsn ;
};
typedef struct ___txn_child_args __txn_child_args;
typedef u_int32_t u32;
struct __anonstruct_keyInstance_53 {
   u_int8_t direction ;
   int keyLen ;
   char keyMaterial[65] ;
   int Nr ;
   u32 rk[60] ;
   u32 ek[60] ;
};
typedef struct __anonstruct_keyInstance_53 keyInstance;
struct __anonstruct_cipherInstance_54 {
   u_int8_t mode ;
   u_int8_t IV[16] ;
};
typedef struct __anonstruct_cipherInstance_54 cipherInstance;
struct __aes_cipher {
   keyInstance decrypt_ki ;
   keyInstance encrypt_ki ;
   u_int32_t flags ;
};
typedef struct __aes_cipher AES_CIPHER;
struct __anonstruct_SHA1_CTX_55 {
   u_int32_t state[5] ;
   u_int32_t count[2] ;
   unsigned char buffer[64] ;
};
typedef struct __anonstruct_SHA1_CTX_55 SHA1_CTX;
struct __cipher {
   roff_t passwd ;
   size_t passwd_len ;
   u_int32_t flags ;
};
typedef struct __cipher CIPHER;
typedef u_int8_t u8;
struct ___crdel_metasub_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DBT page ;
   DB_LSN lsn ;
};
typedef struct ___crdel_metasub_args __crdel_metasub_args;
struct __db_mpool;
typedef struct __db_mpool DB_MPOOL;
enum __anonenum_mu_action_40 {
    MU_REMOVE = 0,
    MU_RENAME = 1,
    MU_OPEN = 2
};
typedef enum __anonenum_mu_action_40 mu_action;
struct __db_mpreg;
struct __db_mpregh {
   struct __db_mpreg *lh_first ;
};
struct __db_mpoolfileh {
   struct __db_mpoolfile *tqh_first ;
   struct __db_mpoolfile **tqh_last ;
};
struct __db_mpool {
   DB_MUTEX *mutexp ;
   struct __db_mpregh dbregq ;
   struct __db_mpoolfileh dbmfq ;
   DB_ENV *dbenv ;
   u_int32_t nreg ;
   REGINFO *reginfo ;
};
struct __anonstruct_q_77 {
   struct __db_mpreg *le_next ;
   struct __db_mpreg **le_prev ;
};
struct __db_mpreg {
   struct __anonstruct_q_77 q ;
   int32_t ftype ;
   int (*pgin)(DB_ENV * , db_pgno_t  , void * , DBT * ) ;
   int (*pgout)(DB_ENV * , db_pgno_t  , void * , DBT * ) ;
};
struct ___db_addrem_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t fileid ;
   db_pgno_t pgno ;
   u_int32_t indx ;
   u_int32_t nbytes ;
   DBT hdr ;
   DBT dbt ;
   DB_LSN pagelsn ;
};
typedef struct ___db_addrem_args __db_addrem_args;
struct ___db_big_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t fileid ;
   db_pgno_t pgno ;
   db_pgno_t prev_pgno ;
   db_pgno_t next_pgno ;
   DBT dbt ;
   DB_LSN pagelsn ;
   DB_LSN prevlsn ;
   DB_LSN nextlsn ;
};
typedef struct ___db_big_args __db_big_args;
struct ___db_ovref_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   int32_t adjust ;
   DB_LSN lsn ;
};
typedef struct ___db_ovref_args __db_ovref_args;
struct ___db_relink_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t opcode ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN lsn ;
   db_pgno_t prev ;
   DB_LSN lsn_prev ;
   db_pgno_t next ;
   DB_LSN lsn_next ;
};
typedef struct ___db_relink_args __db_relink_args;
struct ___db_debug_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DBT op ;
   int32_t fileid ;
   DBT key ;
   DBT data ;
   u_int32_t arg_flags ;
};
typedef struct ___db_debug_args __db_debug_args;
struct ___db_noop_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN prevlsn ;
};
typedef struct ___db_noop_args __db_noop_args;
struct ___db_pg_alloc_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   DB_LSN meta_lsn ;
   db_pgno_t meta_pgno ;
   DB_LSN page_lsn ;
   db_pgno_t pgno ;
   u_int32_t ptype ;
   db_pgno_t next ;
};
typedef struct ___db_pg_alloc_args __db_pg_alloc_args;
struct ___db_pg_free_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN meta_lsn ;
   db_pgno_t meta_pgno ;
   DBT header ;
   db_pgno_t next ;
};
typedef struct ___db_pg_free_args __db_pg_free_args;
struct ___db_cksum_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
};
typedef struct ___db_cksum_args __db_cksum_args;
struct ___db_pg_freedata_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN meta_lsn ;
   db_pgno_t meta_pgno ;
   DBT header ;
   db_pgno_t next ;
   DBT data ;
};
typedef struct ___db_pg_freedata_args __db_pg_freedata_args;
struct ___db_pg_prepare_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
};
typedef struct ___db_pg_prepare_args __db_pg_prepare_args;
struct ___db_pg_new_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t fileid ;
   db_pgno_t pgno ;
   DB_LSN meta_lsn ;
   db_pgno_t meta_pgno ;
   DBT header ;
   db_pgno_t next ;
};
typedef struct ___db_pg_new_args __db_pg_new_args;
union __anonunion_u_53 {
   long l ;
   char c[(int )sizeof(long )] ;
};
typedef struct __db_txnlist DB_TXNLIST;
enum __anonenum_db_limbo_state_68 {
    LIMBO_NORMAL = 0,
    LIMBO_PREPARE = 1,
    LIMBO_RECOVER = 2,
    LIMBO_TIMESTAMP = 3,
    LIMBO_COMPENSATE = 4
};
typedef enum __anonenum_db_limbo_state_68 db_limbo_state;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct __join_cursor {
   u_int8_t *j_exhausted ;
   DBC **j_curslist ;
   DBC **j_fdupcurs ;
   DBC **j_workcurs ;
   DB *j_primary ;
   DBT j_key ;
   DBT j_rdata ;
   u_int32_t j_ncurs ;
   u_int32_t flags ;
};
typedef struct __join_cursor JOIN_CURSOR;
struct __db_envq {
   struct __db_env *tqh_first ;
   struct __db_env **tqh_last ;
};
struct __db_globals {
   struct __db_envq db_envq ;
   int (*j_close)(int  ) ;
   void (*j_dirfree)(char ** , int  ) ;
   int (*j_dirlist)(char const   * , char *** , int * ) ;
   int (*j_exists)(char const   * , int * ) ;
   void (*j_free)(void * ) ;
   int (*j_fsync)(int  ) ;
   int (*j_ioinfo)(char const   * , int  , u_int32_t * , u_int32_t * , u_int32_t * ) ;
   void *(*j_malloc)(size_t  ) ;
   int (*j_map)(char * , size_t  , int  , int  , void ** ) ;
   int (*j_open)(char const   * , int   , ...) ;
   ssize_t (*j_read)(int  , void * , size_t  ) ;
   void *(*j_realloc)(void * , size_t  ) ;
   int (*j_rename)(char const   * , char const   * ) ;
   int (*j_seek)(int  , size_t  , db_pgno_t  , u_int32_t  , int  , int  ) ;
   int (*j_sleep)(u_long  , u_long  ) ;
   int (*j_unlink)(char const   * ) ;
   int (*j_unmap)(void * , size_t  ) ;
   ssize_t (*j_write)(int  , void const   * , size_t  ) ;
   int (*j_yield)(void) ;
};
typedef unsigned char __u_char;
typedef __u_char u_char;
struct __fn {
   u_int32_t mask ;
   char const   *name ;
};
typedef struct __fn FN;
typedef unsigned long long db_align_t;
struct __head {
   ssize_t slh_first ;
};
struct __anonstruct_links_59 {
   ssize_t sle_next ;
   ssize_t sle_prev ;
};
struct __data {
   size_t len ;
   struct __anonstruct_links_59 links ;
};
struct __anonstruct_list_53 {
   u_int32_t power ;
   u_int32_t prime ;
};
struct hash_head {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
typedef struct __db DBM;
struct __anonstruct_datum_39 {
   char *dptr ;
   int dsize ;
};
typedef struct __anonstruct_datum_39 datum;
struct __db_reg_env_ref {
   roff_t size ;
   long segid ;
};
typedef struct __db_reg_env_ref REGENV_REF;
struct ___fop_create_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DBT name ;
   u_int32_t appname ;
   u_int32_t mode ;
};
typedef struct ___fop_create_args __fop_create_args;
struct ___fop_remove_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DBT name ;
   DBT fid ;
   u_int32_t appname ;
};
typedef struct ___fop_remove_args __fop_remove_args;
struct ___fop_write_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DBT name ;
   u_int32_t appname ;
   u_int32_t pgsize ;
   db_pgno_t pageno ;
   u_int32_t offset ;
   DBT page ;
   u_int32_t flag ;
};
typedef struct ___fop_write_args __fop_write_args;
struct ___fop_rename_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DBT oldname ;
   DBT newname ;
   DBT fileid ;
   u_int32_t appname ;
};
typedef struct ___fop_rename_args __fop_rename_args;
struct ___fop_file_remove_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   DBT real_fid ;
   DBT tmp_fid ;
   DBT name ;
   u_int32_t appname ;
   u_int32_t child ;
};
typedef struct ___fop_file_remove_args __fop_file_remove_args;
enum __anonenum_ACTION_40 {
    FIND = 0,
    ENTER = 1
};
typedef enum __anonenum_ACTION_40 ACTION;
struct entry {
   char *key ;
   char *data ;
};
typedef struct entry ENTRY;
enum __anonenum_db_status_t_29 {
    DB_LSTAT_ABORTED = 1,
    DB_LSTAT_ERR = 2,
    DB_LSTAT_EXPIRED = 3,
    DB_LSTAT_FREE = 4,
    DB_LSTAT_HELD = 5,
    DB_LSTAT_NOTEXIST = 6,
    DB_LSTAT_PENDING = 7,
    DB_LSTAT_WAITING = 8
};
typedef enum __anonenum_db_status_t_29 db_status_t;
struct __hash_head {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
typedef struct __hash_head DB_HASHTAB;
struct __anonstruct_db_timeval_t_59 {
   u_int32_t tv_sec ;
   u_int32_t tv_usec ;
};
typedef struct __anonstruct_db_timeval_t_59 db_timeval_t;
struct __flock {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __fobj {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __flocker {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __dobj {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __lkrs {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __db_lockregion {
   u_int32_t need_dd ;
   u_int32_t detect ;
   db_timeval_t next_timeout ;
   struct __flock free_locks ;
   struct __fobj free_objs ;
   struct __flocker free_lockers ;
   struct __dobj dd_objs ;
   struct __lkrs lockers ;
   db_timeout_t lk_timeout ;
   db_timeout_t tx_timeout ;
   u_int32_t locker_t_size ;
   u_int32_t object_t_size ;
   roff_t conf_off ;
   roff_t obj_off ;
   roff_t osynch_off ;
   roff_t locker_off ;
   roff_t lsynch_off ;
   DB_LOCK_STAT stat ;
};
typedef struct __db_lockregion DB_LOCKREGION;
struct __sh_dbt {
   u_int32_t size ;
   ssize_t off ;
};
typedef struct __sh_dbt SH_DBT;
struct __anonstruct_links_60 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __anonstruct_dd_links_61 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __waitl {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __holdl {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __db_lockobj {
   SH_DBT lockobj ;
   struct __anonstruct_links_60 links ;
   struct __anonstruct_dd_links_61 dd_links ;
   struct __waitl waiters ;
   struct __holdl holders ;
   u_int8_t objdata[(int )sizeof(struct __db_ilock )] ;
};
typedef struct __db_lockobj DB_LOCKOBJ;
struct _child {
   ssize_t slh_first ;
};
struct __anonstruct_child_link_62 {
   ssize_t sle_next ;
   ssize_t sle_prev ;
};
struct __anonstruct_links_63 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __anonstruct_ulinks_64 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct _held {
   ssize_t slh_first ;
};
struct __db_locker {
   u_int32_t id ;
   u_int32_t dd_id ;
   u_int32_t nlocks ;
   u_int32_t nwrites ;
   size_t master_locker ;
   size_t parent_locker ;
   struct _child child_locker ;
   struct __anonstruct_child_link_62 child_link ;
   struct __anonstruct_links_63 links ;
   struct __anonstruct_ulinks_64 ulinks ;
   struct _held heldby ;
   db_timeval_t lk_expire ;
   db_timeval_t tx_expire ;
   db_timeout_t lk_timeout ;
   u_int32_t flags ;
};
typedef struct __db_locker DB_LOCKER;
struct __db_locktab {
   DB_ENV *dbenv ;
   REGINFO reginfo ;
   u_int8_t *conflicts ;
   DB_HASHTAB *obj_tab ;
   DB_HASHTAB *locker_tab ;
};
typedef struct __db_locktab DB_LOCKTAB;
struct __anonstruct_links_65___0 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __anonstruct_locker_links_66 {
   ssize_t sle_next ;
   ssize_t sle_prev ;
};
struct __db_lock {
   DB_MUTEX mutex ;
   u_int32_t holder ;
   u_int32_t gen ;
   struct __anonstruct_links_65___0 links ;
   struct __anonstruct_locker_links_66 locker_links ;
   u_int32_t refcount ;
   db_lockmode_t mode ;
   ssize_t obj ;
   db_status_t status ;
};
enum __anonenum_action_70 {
    GRANT = 0,
    UPGRADE = 1,
    HEAD = 2,
    SECOND = 3,
    TAIL = 4
};
struct __anonstruct_locker_info_67 {
   int valid ;
   int self_wait ;
   int in_abort ;
   u_int32_t count ;
   u_int32_t id ;
   u_int32_t last_lock ;
   ssize_t last_obj ;
   u_int32_t last_locker_id ;
   db_pgno_t pgno ;
};
typedef struct __anonstruct_locker_info_67 locker_info;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct __hdr;
typedef struct __hdr HDR;
struct __hdr {
   u_int32_t prev ;
   u_int32_t len ;
   u_int8_t chksum[20] ;
   u_int8_t iv[16] ;
   u_int32_t orig_size ;
   size_t size ;
};
enum __anonenum_logfile_validity_65 {
    DB_LV_INCOMPLETE = 0,
    DB_LV_NONEXISTENT = 1,
    DB_LV_NORMAL = 2,
    DB_LV_OLD_READABLE = 3,
    DB_LV_OLD_UNREADABLE = 4
};
typedef enum __anonenum_logfile_validity_65 logfile_validity;
enum __anonenum_RLOCK_69 {
    L_ALREADY = 0,
    L_ACQUIRED = 1,
    L_NONE = 2
};
typedef enum __anonenum_RLOCK_69 RLOCK;
struct __anonstruct_links_57 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __db_commit {
   DB_MUTEX mutex ;
   DB_LSN lsn ;
   struct __anonstruct_links_57 links ;
   u_int32_t flags ;
};
struct __bh;
typedef struct __bh BH;
struct __db_mpool_hash;
typedef struct __db_mpool_hash DB_MPOOL_HASH;
struct __mpool;
typedef struct __mpool MPOOL;
enum __anonenum_db_sync_op_53 {
    DB_SYNC_ALLOC = 0,
    DB_SYNC_CACHE = 1,
    DB_SYNC_FILE = 2,
    DB_SYNC_TRICKLE = 3
};
typedef enum __anonenum_db_sync_op_53 db_sync_op;
struct __mpfq {
   ssize_t stqh_first ;
   ssize_t stqh_last ;
};
struct __mpool {
   DB_LSN lsn ;
   struct __mpfq mpfq ;
   u_int32_t nreg ;
   roff_t regids ;
   int htab_buckets ;
   roff_t htab ;
   u_int32_t last_checked ;
   u_int32_t lru_count ;
   DB_MPOOL_STAT stat ;
   u_int32_t put_counter ;
};
struct __db_mpool_hash {
   DB_MUTEX hash_mutex ;
   DB_HASHTAB hash_bucket ;
   u_int32_t hash_page_dirty ;
   u_int32_t hash_priority ;
};
struct __anonstruct_hq_56 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __bh {
   DB_MUTEX mutex ;
   u_int16_t ref ;
   u_int16_t ref_sync ;
   u_int16_t flags ;
   u_int32_t priority ;
   struct __anonstruct_hq_56 hq ;
   db_pgno_t pgno ;
   roff_t mf_offset ;
   u_int8_t buf[1] ;
};
typedef struct __db_mpreg DB_MPREG;
enum __anonenum_state_60 {
    FIRST_FOUND = 0,
    FIRST_MISS = 1,
    SECOND_FOUND = 2,
    SECOND_MISS = 3
};
struct __anonstruct_BH_TRACK_66 {
   DB_MPOOL_HASH *track_hp ;
   roff_t track_off ;
   db_pgno_t track_pgno ;
};
typedef struct __anonstruct_BH_TRACK_66 BH_TRACK;
struct __db_regmaint_stat_t {
   u_int32_t st_hint_hit ;
   u_int32_t st_hint_miss ;
   u_int32_t st_records ;
   u_int32_t st_clears ;
   u_int32_t st_destroys ;
   u_int32_t st_max_locks ;
};
typedef struct __db_regmaint_stat_t REGMAINT_STAT;
struct __db_regmaint_t {
   u_int32_t reglocks ;
   u_int32_t regmutex_hint ;
   REGMAINT_STAT stat ;
   roff_t regmutexes[1] ;
};
typedef struct __db_regmaint_t REGMAINT;
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
typedef unsigned long __ino_t;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
typedef int __key_t;
typedef __key_t key_t;
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
typedef unsigned long shmatt_t;
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   unsigned long __unused1 ;
   __time_t shm_dtime ;
   unsigned long __unused2 ;
   __time_t shm_ctime ;
   unsigned long __unused3 ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
typedef __off_t off_t;
union __anonunion_CHAR64LONG16_54 {
   unsigned char c[64] ;
   u_int32_t l[16] ;
};
typedef union __anonunion_CHAR64LONG16_54 CHAR64LONG16;
struct __anonstruct_links_88 {
   ssize_t stqe_next ;
   ssize_t stqe_prev ;
};
struct __txn_detail {
   u_int32_t txnid ;
   DB_LSN last_lsn ;
   DB_LSN begin_lsn ;
   roff_t parent ;
   u_int32_t status ;
   u_int32_t flags ;
   struct __anonstruct_links_88 links ;
   u_int32_t xa_status ;
   u_int8_t xid[128] ;
   u_int32_t bqual ;
   u_int32_t gtrid ;
   int32_t format ;
};
typedef struct __txn_detail TXN_DETAIL;
enum __anonenum_txnop_t_90 {
    TXN_OP_ABORT = 0,
    TXN_OP_COMMIT = 1,
    TXN_OP_DISCARD = 2,
    TXN_OP_PREPARE = 3
};
typedef enum __anonenum_txnop_t_90 txnop_t;
struct ___txn_recycle_args {
   u_int32_t type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   u_int32_t min ;
   u_int32_t max ;
};
typedef struct ___txn_recycle_args __txn_recycle_args;
struct xid_t {
   long formatID ;
   long gtrid_length ;
   long bqual_length ;
   char data[128] ;
};
typedef struct xid_t XID;
enum __anonenum_TXN_EVENT_T_65 {
    TXN_CLOSE = 0,
    TXN_REMOVE = 1,
    TXN_TRADE = 2,
    TXN_TRADED = 3
};
typedef enum __anonenum_TXN_EVENT_T_65 TXN_EVENT_T;
typedef struct __txn_event TXN_EVENT;
struct __anonstruct_links_77 {
   struct __txn_event *tqe_next ;
   struct __txn_event **tqe_prev ;
};
struct __anonstruct_c_79 {
   DB *dbp ;
};
struct __anonstruct_r_80 {
   char *name ;
   u_int8_t *fileid ;
};
struct __anonstruct_t_81 {
   DB_LOCK lock ;
   u_int32_t locker ;
   DB *dbp ;
};
union __anonunion_u_78 {
   struct __anonstruct_c_79 c ;
   struct __anonstruct_r_80 r ;
   struct __anonstruct_t_81 t ;
};
struct __txn_event {
   TXN_EVENT_T op ;
   struct __anonstruct_links_77 links ;
   union __anonunion_u_78 u ;
};
struct xa_switch_t {
   char name[32] ;
   long flags ;
   long version ;
   int (*xa_open_entry)(char * , int  , long  ) ;
   int (*xa_close_entry)(char * , int  , long  ) ;
   int (*xa_start_entry)(XID * , int  , long  ) ;
   int (*xa_end_entry)(XID * , int  , long  ) ;
   int (*xa_rollback_entry)(XID * , int  , long  ) ;
   int (*xa_prepare_entry)(XID * , int  , long  ) ;
   int (*xa_commit_entry)(XID * , int  , long  ) ;
   int (*xa_recover_entry)(XID * , long  , int  , long  ) ;
   int (*xa_forget_entry)(XID * , int  , long  ) ;
   int (*xa_complete_entry)(int * , int * , int  , long  ) ;
};
struct __xa_methods {
   int (*close)(DB * , u_int32_t  ) ;
   int (*cursor)(DB * , DB_TXN * , DBC ** , u_int32_t  ) ;
   int (*del)(DB * , DB_TXN * , DBT * , u_int32_t  ) ;
   int (*get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
   int (*open)(DB * , DB_TXN * , char const   * , char const   * , DBTYPE  , u_int32_t  ,
               int  ) ;
   int (*put)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t  ) ;
};
typedef struct __xa_methods XA_METHODS;
#pragma merger(0,"/tmp/cil-eA2jBBN3.i","")
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __threadp ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
int db_create(DB **dbpp , DB_ENV *dbenv___0 , u_int32_t flags ) ;
char *db_strerror(int error ) ;
int db_env_create(DB_ENV **dbenvpp , u_int32_t flags ) ;
int db_env_set_func_yield(int (*func_yield)(void) ) ;
int db_init(char const   *home ) ;
void *deadlock(void *arg ) ;
void fatal(char const   *msg , int err , int syserr ) ;
void onint(int signo ) ;
int main(int argc , char **argv ) ;
int reader(int id ) ;
void stats(void) ;
void *trickle(void *arg ) ;
void *tstart(void *arg ) ;
int usage(void) ;
void word(void) ;
int writer(int id ) ;
int quit  ;
struct _statistics *perf  ;
char const   *progname  =    "ex_thread";
int punish  ;
int nlist  ;
int nreaders  ;
int verbose  ;
int nwriters  ;
DB *dbp  ;
DB_ENV *dbenv  ;
int nthreads  ;
char **list  ;
int main(int argc , char **argv ) 
{ DB_TXN *txnp ;
  pthread_t *tids ;
  int ch ;
  int i ;
  int ret ;
  char const   *home ;
  void *retp ;
  int tmp ;
  __pid_t tmp___0 ;
  time_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  txnp = (DB_TXN *)((void *)0);
  nlist = 1000;
  nwriters = 4;
  nreaders = nwriters;
  home = "TESTDIR";
  while (1) {
    ch = getopt(argc, (char * const  *)argv, "h:pn:r:vw:");
    if (! (ch != -1)) {
      break;
    }
    switch (ch) {
    case 104: 
    home = (char const   *)optarg;
    break;
    case 112: 
    punish = 1;
    break;
    case 110: 
    nlist = atoi((char const   *)optarg);
    break;
    case 114: 
    nreaders = atoi((char const   *)optarg);
    break;
    case 118: 
    verbose = 1;
    break;
    case 119: 
    nwriters = atoi((char const   *)optarg);
    break;
    case 63: ;
    default: 
    tmp = usage();
    return (tmp);
    }
  }
  argc -= optind;
  argv += optind;
  tmp___0 = getpid();
  tmp___1 = time((time_t *)((void *)0));
  srand((unsigned int )((long )tmp___0 | tmp___1));
  signal(2, & onint);
  word();
  remove("access.db");
  ret = db_init(home);
  if (ret != 0) {
    return (ret);
  }
  ret = db_create(& dbp, dbenv, 0U);
  if (ret != 0) {
    ((*(dbenv->err)))((DB_ENV const   *)dbenv, ret, "db_create");
    ((*(dbenv->close)))(dbenv, 0U);
    return (1);
  }
  ret = ((*(dbp->set_pagesize)))(dbp, 1024U);
  if (ret != 0) {
    ((*(dbp->err)))(dbp, ret, "set_pagesize");
    goto err;
  }
  ret = ((*(dbenv->txn_begin)))(dbenv, (DB_TXN *)((void *)0), & txnp, 0U);
  if (ret != 0) {
    fatal("txn_begin", ret, 1);
  }
  ret = ((*(dbp->open)))(dbp, txnp, "access.db", (char const   *)((void *)0), 1, 65U,
                         436);
  if (ret != 0) {
    ((*(dbp->err)))(dbp, ret, "%s: open", "access.db");
    goto err;
  } else {
    ret = ((*(txnp->commit)))(txnp, 0U);
    txnp = (DB_TXN *)((void *)0);
    if (ret != 0) {
      goto err;
    }
  }
  nthreads = (nreaders + nwriters) + 2;
  printf((char const   * __restrict  )"Running: readers %d, writers %d\n", nreaders,
         nwriters);
  fflush(stdout);
  perf = (struct _statistics *)calloc((unsigned int )((nreaders + nwriters) + 1),
                                      sizeof((*perf)));
  if ((unsigned int )perf == (unsigned int )((void *)0)) {
    tmp___2 = __errno_location();
    fatal((char const   *)((void *)0), (*tmp___2), 1);
  }
  tids = (pthread_t *)malloc((unsigned int )nthreads * sizeof(pthread_t ));
  if ((unsigned int )tids == (unsigned int )((void *)0)) {
    tmp___3 = __errno_location();
    fatal((char const   *)((void *)0), (*tmp___3), 1);
  }
  i = 0;
  while (i < nreaders + nwriters) {
    ret = pthread_create((pthread_t * __restrict  )(tids + i), (pthread_attr_t const   * __restrict  )((void *)0),
                         & tstart, (void * __restrict  )((void *)i));
    if (ret != 0) {
      if (ret > 0) {
        tmp___5 = ret;
      } else {
        tmp___6 = __errno_location();
        tmp___5 = (*tmp___6);
      }
      fatal("pthread_create", tmp___5, 1);
    }
    i ++;
  }
  tmp___8 = pthread_create((pthread_t * __restrict  )(tids + i), (pthread_attr_t const   * __restrict  )((void *)0),
                           & trickle, (void * __restrict  )(& i));
  if (tmp___8) {
    tmp___7 = __errno_location();
    fatal("pthread_create", (*tmp___7), 1);
  }
  i ++;
  tmp___10 = pthread_create((pthread_t * __restrict  )(tids + i), (pthread_attr_t const   * __restrict  )((void *)0),
                            & deadlock, (void * __restrict  )(& i));
  if (tmp___10) {
    tmp___9 = __errno_location();
    fatal("pthread_create", (*tmp___9), 1);
  }
  i = 0;
  while (i < nthreads) {
    pthread_join((*(tids + i)), & retp);
    i ++;
  }
  printf((char const   * __restrict  )"Exiting\n");
  stats();
  err: 
  if ((unsigned int )txnp != (unsigned int )((void *)0)) {
    ((*(txnp->abort)))(txnp);
  }
  ((*(dbp->close)))(dbp, 0U);
  ((*(dbenv->close)))(dbenv, 0U);
  return (0);
}
}
int reader(int id ) 
{ DBT key ;
  DBT data ;
  int n ;
  int ret ;
  char buf[64] ;
  int tmp ;
  size_t tmp___0 ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  data.flags = 4U;
  while (! quit) {
    tmp = rand();
    n = tmp % nlist;
    key.data = (void *)(*(list + n));
    key.size = strlen((char const   *)key.data);
    if (verbose) {
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"reader: %d: list entry %d\n",
              id, n);
      tmp___0 = strlen((char const   *)(buf));
      write(1, (void const   *)(buf), tmp___0);
    }
    ret = ((*(dbp->get)))(dbp, (DB_TXN *)((void *)0), & key, & data, 0U);
    switch (ret) {
    case -30995: 
    (perf + id)->aborts = (perf + id)->aborts + 1;
    break;
    case 0: 
    (perf + id)->found = (perf + id)->found + 1;
    free(data.data);
    break;
    case -30990: 
    (perf + id)->notfound = (perf + id)->notfound + 1;
    break;
    default: 
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"reader %d: dbp->get: %s",
            id, (char *)key.data);
    fatal((char const   *)(buf), ret, 0);
    }
  }
  return (0);
}
}
int writer(int id ) 
{ DBT key ;
  DBT data ;
  DB_TXN *tid ;
  time_t now ;
  time_t then ;
  int n ;
  int ret ;
  char buf[256] ;
  char dbuf[10000] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  time(& now);
  then = now;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  data.data = (void *)(dbuf);
  data.ulen = sizeof(dbuf);
  data.flags = 32U;
  while (! quit) {
    tmp = rand();
    n = tmp % nlist;
    key.data = (void *)(*(list + n));
    key.size = strlen((char const   *)key.data);
    if (verbose) {
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"writer: %d: list entry %d\n",
              id, n);
      tmp___0 = strlen((char const   *)(buf));
      write(1, (void const   *)(buf), tmp___0);
    }
    if (0) {
      retry: 
      ret = ((*(tid->abort)))(tid);
      if (ret != 0) {
        fatal("DB_TXN->abort", ret, 1);
      }
      (perf + id)->aborts = (perf + id)->aborts + 1;
      (perf + id)->aborted = (perf + id)->aborted + 1;
    }
    if (id == 1) {
      time(& now);
      if (now - then >= 20L) {
        stats();
        then = now;
      }
    }
    ret = ((*(dbenv->txn_begin)))(dbenv, (DB_TXN *)((void *)0), & tid, 0U);
    if (ret != 0) {
      fatal("txn_begin", ret, 1);
    }
    ret = ((*(dbp->get)))(dbp, tid, & key, & data, 0U);
    switch (ret) {
    case -30995: ;
    goto retry;
    case 0: ;
    goto delete;
    case -30990: ;
    goto add;
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"writer: %d: dbp->get",
            id);
    fatal((char const   *)(buf), ret, 1);
    delete: 
    ret = ((*(dbp->del)))(dbp, tid, & key, 0U);
    switch (ret) {
    case -30995: ;
    goto retry;
    case 0: 
    (perf + id)->deletes = (perf + id)->deletes + 1;
    goto commit;
    }
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"writer: %d: dbp->del",
            id);
    fatal((char const   *)(buf), ret, 1);
    add: 
    tmp___1 = rand();
    data.size = (unsigned int )(20 + tmp___1 % 128);
    tmp___2 = rand();
    if (tmp___2 % 30 == 0) {
      data.size += 8192U;
    }
    ret = ((*(dbp->put)))(dbp, tid, & key, & data, 0U);
    switch (ret) {
    case -30995: ;
    goto retry;
    case 0: 
    (perf + id)->adds = (perf + id)->adds + 1;
    goto commit;
    default: 
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"writer: %d: dbp->put",
            id);
    fatal((char const   *)(buf), ret, 1);
    }
    commit: 
    ret = ((*(tid->commit)))(tid, 0U);
    if (ret != 0) {
      fatal("DB_TXN->commit", ret, 1);
    }
    (perf + id)->txns = (perf + id)->txns + 1;
    if ((perf + id)->txns % 20 == 0) {
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"writer: %2d: adds: %4d: deletes: %4d: aborts: %4d: txns: %4d\n",
              id, (perf + id)->adds, (perf + id)->deletes, (perf + id)->aborts, (perf +
                                                                                 id)->txns);
      tmp___3 = strlen((char const   *)(buf));
      write(1, (void const   *)(buf), tmp___3);
    }
    if ((perf + id)->aborted > 5) {
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"writer: %2d: adds: %4d: deletes: %4d: aborts: %4d: txns: %4d: ABORTED: %2d\n",
              id, (perf + id)->adds, (perf + id)->deletes, (perf + id)->aborts, (perf +
                                                                                 id)->txns,
              (perf + id)->aborted);
      tmp___4 = strlen((char const   *)(buf));
      write(1, (void const   *)(buf), tmp___4);
    }
    (perf + id)->aborted = 0;
  }
  return (0);
}
}
void stats(void) 
{ int id ;
  char *p ;
  char buf[8192] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"-------------\n");
  p = buf + tmp;
  id = 0;
  while (id < nreaders + nwriters) {
    tmp___2 = id;
    id ++;
    if (tmp___2 < nwriters) {
      tmp___0 = sprintf((char * __restrict  )p, (char const   * __restrict  )"writer: %2d: adds: %4d: deletes: %4d: aborts: %4d: txns: %4d\n",
                        id, (perf + id)->adds, (perf + id)->deletes, (perf + id)->aborts,
                        (perf + id)->txns);
      p += tmp___0;
    } else {
      tmp___1 = sprintf((char * __restrict  )p, (char const   * __restrict  )"reader: %2d: found: %5d: notfound: %5d: aborts: %4d\n",
                        id, (perf + id)->found, (perf + id)->notfound, (perf + id)->aborts);
      p += tmp___1;
    }
  }
  tmp___3 = sprintf((char * __restrict  )p, (char const   * __restrict  )"-------------\n");
  p += tmp___3;
  write(1, (void const   *)(buf), (unsigned int )(p - buf));
  return;
}
}
int db_init(char const   *home ) 
{ int ret ;
  char *tmp ;

  {
  ret = db_env_create(& dbenv, 0U);
  if (ret != 0) {
    tmp = db_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: db_env_create: %s\n",
            progname, tmp);
    return (1);
  }
  if (punish) {
    ((*(dbenv->set_flags)))(dbenv, 8388608U, 1);
    db_env_set_func_yield(& sched_yield);
  }
  ((*(dbenv->set_errfile)))(dbenv, stderr);
  ((*(dbenv->set_errpfx)))(dbenv, progname);
  ((*(dbenv->set_cachesize)))(dbenv, 0U, 102400U, 0);
  ((*(dbenv->set_lg_max)))(dbenv, 200000U);
  ret = ((*(dbenv->open)))(dbenv, home, 188481U, 0);
  if (ret != 0) {
    ((*(dbenv->err)))((DB_ENV const   *)dbenv, ret, (char const   *)((void *)0));
    ((*(dbenv->close)))(dbenv, 0U);
    return (1);
  }
  return (0);
}
}
void *tstart(void *arg ) 
{ pthread_t tid ;
  u_int id ;

  {
  id = (unsigned int )arg + 1U;
  tid = pthread_self();
  if (id <= (unsigned int )nwriters) {
    printf((char const   * __restrict  )"write thread %d starting: tid: %lu\n", id,
           tid);
    fflush(stdout);
    writer((int )id);
  } else {
    printf((char const   * __restrict  )"read thread %d starting: tid: %lu\n", id,
           tid);
    fflush(stdout);
    reader((int )id);
  }
  return ((void *)0);
}
}
void *deadlock(void *arg ) 
{ struct timeval t ;
  pthread_t tid ;

  {
  arg = arg;
  tid = pthread_self();
  printf((char const   * __restrict  )"deadlock thread starting: tid: %lu\n", tid);
  fflush(stdout);
  t.tv_sec = 0L;
  t.tv_usec = 100000L;
  while (! quit) {
    ((*(dbenv->lock_detect)))(dbenv, 0U, 8U, (int *)((void *)0));
    select(0, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& t));
  }
  return ((void *)0);
}
}
void *trickle(void *arg ) 
{ pthread_t tid ;
  int wrote ;
  char buf[64] ;
  size_t tmp ;

  {
  arg = arg;
  tid = pthread_self();
  printf((char const   * __restrict  )"trickle thread starting: tid: %lu\n", tid);
  fflush(stdout);
  while (! quit) {
    ((*(dbenv->memp_trickle)))(dbenv, 10, & wrote);
    if (verbose) {
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"trickle: wrote %d\n",
              wrote);
      tmp = strlen((char const   *)(buf));
      write(1, (void const   *)(buf), tmp);
    }
    if (wrote == 0) {
      sleep(1U);
      sched_yield();
    }
  }
  return ((void *)0);
}
}
void word(void) 
{ FILE *fp ;
  int cnt ;
  char buf[256] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  fp = fopen((char const   * __restrict  )"../test/wordlist", (char const   * __restrict  )"r");
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    tmp = __errno_location();
    fatal("../test/wordlist", (*tmp), 1);
  }
  list = (char **)malloc((unsigned int )nlist * sizeof(char *));
  if ((unsigned int )list == (unsigned int )((void *)0)) {
    tmp___0 = __errno_location();
    fatal((char const   *)((void *)0), (*tmp___0), 1);
  }
  cnt = 0;
  while (cnt < nlist) {
    tmp___1 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fp);
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      break;
    }
    (*(list + cnt)) = strdup((char const   *)(buf));
    if ((unsigned int )(*(list + cnt)) == (unsigned int )((void *)0)) {
      tmp___2 = __errno_location();
      fatal((char const   *)((void *)0), (*tmp___2), 1);
    }
    cnt ++;
  }
  nlist = cnt;
  return;
}
}
void fatal(char const   *msg , int err , int syserr ) 
{ char *tmp ;

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
  if ((unsigned int )msg != (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", msg);
    if (syserr) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )": ");
    }
  }
  if (syserr) {
    tmp = strerror(err);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", tmp);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  exit(1);
}
}
int usage(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: %s [-pv] [-h home] [-n words] [-r readers] [-w writers]\n",
          progname);
  return (1);
}
}
void onint(int signo ) 
{ 

  {
  signo = 0;
  quit = 1;
  return;
}
}
#pragma merger(0,"/tmp/cil-2qMjfzUZ.i","")
#pragma merger(0,"/tmp/cil-KUci2E6Q.i","-O2")
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t * __restrict  __mutex ,
                                                            pthread_mutexattr_t const   * __restrict  __mutex_attr ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
int __db_pthread_mutex_init(DB_ENV *dbenv___0 , DB_MUTEX *mutexp , u_int32_t flags ) ;
int __db_pthread_mutex_lock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) ;
int __db_pthread_mutex_unlock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) ;
int __db_pthread_mutex_destroy(DB_MUTEX *mutexp ) ;
void __db_err(DB_ENV const   *dbenv___0 , char const   *fmt  , ...) ;
int __db_pthread_mutex_init(DB_ENV *dbenv___0 , DB_MUTEX *mutexp , u_int32_t flags ) 
{ u_int32_t save ;
  int ret ;
  pthread_condattr_t condattr ;
  pthread_condattr_t *condattrp ;
  pthread_mutexattr_t mutexattr ;
  pthread_mutexattr_t *mutexattrp ;
  char *tmp ;

  {
  ret = 0;
  save = mutexp->flags & 16U;
  memset((void *)mutexp, 0, sizeof((*mutexp)));
  mutexp->flags |= save;
  if (flags & 256U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 32768U) {
      _L: 
      if (! (dbenv___0->flags & 1048576U)) {
        mutexp->flags |= 2U;
        return (0);
      }
    }
  }
  condattrp = (pthread_condattr_t *)((void *)0);
  mutexattrp = (pthread_mutexattr_t *)((void *)0);
  if (! (flags & 256U)) {
    ret = pthread_mutexattr_init(& mutexattr);
    mutexattrp = & mutexattr;
  }
  if (ret == 0) {
    ret = pthread_mutex_init((pthread_mutex_t * __restrict  )(& mutexp->mutex), (pthread_mutexattr_t const   * __restrict  )mutexattrp);
  }
  if ((unsigned int )mutexattrp != (unsigned int )((void *)0)) {
    pthread_mutexattr_destroy(mutexattrp);
  }
  if (ret == 0) {
    if (flags & 128U) {
      if (! (flags & 256U)) {
        ret = pthread_condattr_init(& condattr);
      }
      if (ret == 0) {
        ret = pthread_cond_init((pthread_cond_t * __restrict  )(& mutexp->cond), (pthread_condattr_t const   * __restrict  )condattrp);
      }
      mutexp->flags |= 128U;
      if ((unsigned int )condattrp != (unsigned int )((void *)0)) {
        pthread_condattr_destroy(condattrp);
      }
    }
  }
  if (ret == 0) {
    mutexp->flags |= 4U;
  } else {
    tmp = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "unable to initialize mutex: %s", tmp);
  }
  return (ret);
}
}
int __db_pthread_mutex_lock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) 
{ u_int32_t nspins ;
  int i ;
  int ret ;
  int waited ;
  int tmp ;
  char *tmp___0 ;

  {
  if (dbenv___0->flags & 1024U) {
    return (0);
  } else {
    if (mutexp->flags & 2U) {
      return (0);
    }
  }
  nspins = dbenv___0->tas_spins;
  while (nspins > 0U) {
    tmp = pthread_mutex_trylock(& mutexp->mutex);
    if (tmp == 0) {
      break;
    }
    nspins --;
  }
  if (nspins == 0U) {
    ret = pthread_mutex_lock(& mutexp->mutex);
    if (ret != 0) {
      goto err;
    }
  }
  if (mutexp->flags & 128U) {
    waited = 0;
    while (mutexp->locked != 0U) {
      ret = pthread_cond_wait((pthread_cond_t * __restrict  )(& mutexp->cond), (pthread_mutex_t * __restrict  )(& mutexp->mutex));
      if (ret != 0) {
        if (ret != 4) {
          if (ret != 62) {
            if (ret != 110) {
              pthread_mutex_unlock(& mutexp->mutex);
              return (ret);
            }
          }
        }
      }
      waited = 1;
    }
    if (waited) {
      mutexp->mutex_set_wait ++;
    } else {
      mutexp->mutex_set_nowait ++;
    }
    mutexp->locked = 1U;
    i = 5;
    while (1) {
      ret = pthread_mutex_unlock(& mutexp->mutex);
      if (ret == 14) {
        i --;
        if (! (i > 0)) {
          break;
        }
      } else {
        break;
      }
    }
    if (ret != 0) {
      goto err;
    }
  } else {
    if (nspins == dbenv___0->tas_spins) {
      mutexp->mutex_set_nowait ++;
    } else {
      if (nspins > 0U) {
        mutexp->mutex_set_spin ++;
        mutexp->mutex_set_spins += dbenv___0->tas_spins - nspins;
      } else {
        mutexp->mutex_set_wait ++;
      }
    }
    mutexp->locked = 1U;
  }
  return (0);
  err: 
  tmp___0 = strerror(ret);
  __db_err((DB_ENV const   *)dbenv___0, "unable to lock mutex: %s", tmp___0);
  return (ret);
}
}
int __db_pthread_mutex_unlock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) 
{ int i ;
  int ret ;
  char *tmp ;

  {
  if (dbenv___0->flags & 1024U) {
    return (0);
  } else {
    if (mutexp->flags & 2U) {
      return (0);
    }
  }
  if (mutexp->flags & 128U) {
    ret = pthread_mutex_lock(& mutexp->mutex);
    if (ret != 0) {
      goto err;
    }
    mutexp->locked = 0U;
    ret = pthread_cond_signal(& mutexp->cond);
    if (ret != 0) {
      return (ret);
    }
  } else {
    mutexp->locked = 0U;
  }
  i = 5;
  while (1) {
    ret = pthread_mutex_unlock(& mutexp->mutex);
    if (ret == 14) {
      i --;
      if (! (i > 0)) {
        break;
      }
    } else {
      break;
    }
  }
  return (ret);
  err: 
  tmp = strerror(ret);
  __db_err((DB_ENV const   *)dbenv___0, "unable to unlock mutex: %s", tmp);
  return (ret);
}
}
int __db_pthread_mutex_destroy(DB_MUTEX *mutexp ) 
{ int ret ;
  char *tmp ;

  {
  if (mutexp->flags & 2U) {
    return (0);
  }
  ret = pthread_mutex_destroy(& mutexp->mutex);
  if (ret != 0) {
    tmp = strerror(ret);
    __db_err((DB_ENV const   *)((void *)0), "unable to destroy mutex: %s", tmp);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-RTrOnSR3.i","-O2")
int __db_pgfmt(DB_ENV *dbenv___0 , db_pgno_t pgno ) ;
int __bam_cmp(DB *dbp___1 , DBT const   *dbt , PAGE *h , u_int32_t indx , int (*func)(DB * ,
                                                                                      DBT const   * ,
                                                                                      DBT const   * ) ,
              int *cmpp ) ;
int __bam_defcmp(DB *dbp___1 , DBT const   *a , DBT const   *b ) ;
size_t __bam_defpfx(DB *dbp___1 , DBT const   *a , DBT const   *b ) ;
int __db_moff(DB *dbp___1 , DBT const   *dbt , db_pgno_t pgno , u_int32_t tlen , int (*cmpfunc)(DB * ,
                                                                                                DBT const   * ,
                                                                                                DBT const   * ) ,
              int *cmpp ) ;
int __bam_cmp(DB *dbp___1 , DBT const   *dbt , PAGE *h , u_int32_t indx , int (*func)(DB * ,
                                                                                      DBT const   * ,
                                                                                      DBT const   * ) ,
              int *cmpp ) 
{ BINTERNAL *bi ;
  BKEYDATA *bk ;
  BOVERFLOW *bo ;
  DBT pg_dbt ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int (*tmp___4)(DB * , DBT const   * , DBT const   * ) ;
  int tmp___5 ;

  {
  switch ((int )h->type) {
  case 5: ;
  case 12: ;
  case 6: ;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___0) + indx)));
  if (((int )bk->type & -129) == 3) {
    bo = (BOVERFLOW *)bk;
  } else {
    pg_dbt.data = (void *)(bk->data);
    pg_dbt.size = (unsigned int )bk->len;
    (*cmpp) = ((*func))(dbp___1, dbt, (DBT const   *)(& pg_dbt));
    return (0);
  }
  break;
  case 3: ;
  if (indx == 0U) {
    (*cmpp) = 1;
    return (0);
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                            tmp___2) + indx)));
  if (((int )bi->type & -129) == 3) {
    bo = (BOVERFLOW *)(bi->data);
  } else {
    pg_dbt.data = (void *)(bi->data);
    pg_dbt.size = (unsigned int )bi->len;
    (*cmpp) = ((*func))(dbp___1, dbt, (DBT const   *)(& pg_dbt));
    return (0);
  }
  break;
  default: 
  tmp___3 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___3);
  }
  if ((unsigned int )func == (unsigned int )(& __bam_defcmp)) {
    tmp___4 = (int (*)(DB * , DBT const   * , DBT const   * ))((void *)0);
  } else {
    tmp___4 = func;
  }
  tmp___5 = __db_moff(dbp___1, dbt, bo->pgno, bo->tlen, tmp___4, cmpp);
  return (tmp___5);
}
}
int __bam_defcmp(DB *dbp___1 , DBT const   *a , DBT const   *b ) 
{ size_t len ;
  u_int8_t *p1 ;
  u_int8_t *p2 ;
  size_t tmp ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  if (a->size > b->size) {
    len = b->size;
  } else {
    len = a->size;
  }
  p1 = (u_int8_t *)a->data;
  p2 = (u_int8_t *)b->data;
  while (1) {
    tmp = len;
    len --;
    if (! tmp) {
      break;
    }
    if ((int )(*p1) != (int )(*p2)) {
      return ((int )((long )(*p1) - (long )(*p2)));
    }
    p1 ++;
    p2 ++;
  }
  return ((int )((long )a->size - (long )b->size));
}
}
size_t __bam_defpfx(DB *dbp___1 , DBT const   *a , DBT const   *b ) 
{ size_t cnt ;
  size_t len ;
  u_int8_t *p1 ;
  u_int8_t *p2 ;
  size_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  cnt = 1U;
  if (a->size > b->size) {
    len = b->size;
  } else {
    len = a->size;
  }
  p1 = (u_int8_t *)a->data;
  p2 = (u_int8_t *)b->data;
  while (1) {
    tmp = len;
    len --;
    if (! tmp) {
      break;
    }
    if ((int )(*p1) != (int )(*p2)) {
      return (cnt);
    }
    p1 ++;
    p2 ++;
    cnt ++;
  }
  if (a->size < b->size) {
    tmp___0 = a->size + 1U;
  } else {
    tmp___0 = a->size;
  }
  return (tmp___0);
}
}
#pragma merger(0,"/tmp/cil-T1P5HbKW.i","-O2")
int __bam_pgin(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __bam_pgout(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __bam_mswap(PAGE *pg ) ;
void __db_metaswap(PAGE *pg ) ;
int __db_byteswap(DB_ENV *dbenv___0 , DB *dbp___1 , db_pgno_t pg , PAGE *h , size_t pagesize ,
                  int pgin ) ;
int __bam_pgin(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB_PGINFO *pginfo ;
  PAGE *h ;
  int tmp___1 ;

  {
  pginfo = (DB_PGINFO *)cookie->data;
  if (! (pginfo->flags & 268435456U)) {
    return (0);
  }
  h = (PAGE *)pp;
  if ((int )h->type == 9) {
    tmp___1 = __bam_mswap((PAGE *)pp);
  } else {
    tmp___1 = __db_byteswap(dbenv___0, dummydbp, pg, (PAGE *)pp, pginfo->db_pagesize,
                            1);
  }
  return (tmp___1);
}
}
int __bam_pgout(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB_PGINFO *pginfo ;
  PAGE *h ;
  int tmp___1 ;

  {
  pginfo = (DB_PGINFO *)cookie->data;
  if (! (pginfo->flags & 268435456U)) {
    return (0);
  }
  h = (PAGE *)pp;
  if ((int )h->type == 9) {
    tmp___1 = __bam_mswap((PAGE *)pp);
  } else {
    tmp___1 = __db_byteswap(dbenv___0, dummydbp, pg, (PAGE *)pp, pginfo->db_pagesize,
                            0);
  }
  return (tmp___1);
}
}
int __bam_mswap(PAGE *pg ) 
{ u_int8_t *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;

  {
  __db_metaswap(pg);
  p = (u_int8_t *)pg + sizeof(DBMETA );
  (*((u_int8_t *)(& _tmp) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___0) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___0) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___0) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___0) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___1) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___1) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___1) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___1) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___2) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___2) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___2) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___2) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___2) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___2) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___2) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___2) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___3) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___3) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___3) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___3) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___3) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___3) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___3) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___3) + 0));
  p += sizeof(u_int32_t );
  p += 92U * sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___4) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___4) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___4) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___4) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___4) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___4) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___4) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___4) + 0));
  p += sizeof(u_int32_t );
  return (0);
}
}
#pragma merger(0,"/tmp/cil-fZMG8UhM.i","-O2")
int __bam_ca_delete(DB *dbp___1 , db_pgno_t pgno , u_int32_t indx , int delete ) ;
int __ram_ca_delete(DB *dbp___1 , db_pgno_t root_pgno ) ;
int __bam_ca_di(DBC *my_dbc , db_pgno_t pgno , u_int32_t indx , int adjust ) ;
int __bam_ca_dup(DBC *my_dbc , u_int32_t first , db_pgno_t fpgno , u_int32_t fi ,
                 db_pgno_t tpgno , u_int32_t ti ) ;
int __bam_ca_undodup(DB *dbp___1 , u_int32_t first , db_pgno_t fpgno , u_int32_t fi ,
                     u_int32_t ti ) ;
int __bam_ca_rsplit(DBC *my_dbc , db_pgno_t fpgno , db_pgno_t tpgno ) ;
int __bam_ca_split(DBC *my_dbc , db_pgno_t ppgno , db_pgno_t lpgno , db_pgno_t rpgno ,
                   u_int32_t split_indx , int cleft ) ;
void __bam_ca_undosplit(DB *dbp___1 , db_pgno_t frompgno , db_pgno_t topgno , db_pgno_t lpgno ,
                        u_int32_t split_indx ) ;
int __bam_curadj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_ca_mode mode , db_pgno_t from_pgno , db_pgno_t to_pgno , db_pgno_t left_pgno ,
                     u_int32_t first_indx , u_int32_t from_indx , u_int32_t to_indx ) ;
DB *__dblist_get(DB_ENV *dbenv___0 , u_int32_t adjid ) ;
int __db_c_close(DBC *dbc ) ;
int __db_c_newopd(DBC *dbc_parent , db_pgno_t root , DBC *oldopd , DBC **dbcp ) ;
static int __bam_opd_cursor(DB *dbp___1 , DBC *dbc , unsigned int first , u_int32_t tpgno ,
                            u_int32_t ti ) ;
int __bam_ca_delete(DB *dbp___1 , db_pgno_t pgno , u_int32_t indx , int delete ) 
{ BTREE_CURSOR *cp ;
  DB *ldbp ;
  DB_ENV *dbenv___0 ;
  DBC *dbc ;
  int count ;

  {
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  count = 0;
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      cp = (BTREE_CURSOR *)dbc->internal;
      if (cp->pgno == pgno) {
        if ((unsigned int )cp->indx == indx) {
          if (delete) {
            cp->flags |= 1U;
          } else {
            cp->flags &= 4294967294U;
          }
          count ++;
        }
      }
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (count);
}
}
int __ram_ca_delete(DB *dbp___1 , db_pgno_t root_pgno ) 
{ DB *ldbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  int found ;

  {
  found = 0;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if (found == 0) {
      if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
        if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while (1) {
      if (found == 0) {
        if (! ((unsigned int )dbc != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      if ((dbc->internal)->root == root_pgno) {
        found = 1;
      }
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (found);
}
}
int __bam_ca_di(DBC *my_dbc , db_pgno_t pgno , u_int32_t indx , int adjust ) 
{ DB *dbp___1 ;
  DB *ldbp ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  DBC *dbc ;
  DBC_INTERNAL *cp ;
  int found ;
  int ret ;

  {
  dbp___1 = my_dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(my_dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = my_dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      if ((int )dbc->dbtype == 3) {
        goto __Cont;
      }
      cp = dbc->internal;
      if (cp->pgno == pgno) {
        if ((unsigned int )cp->indx >= indx) {
          cp->indx = (unsigned short )((int )cp->indx + adjust);
          if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
            if ((unsigned int )dbc->txn != (unsigned int )my_txn) {
              found = 1;
            }
          }
        }
      }
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((my_dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (my_dbc->flags & 16U)) {
          if ((unsigned int )((my_dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            DB_REP*tmp = (DB_REP *)(((my_dbc->dbp)->dbenv)->rep_handle);
            if (tmp->region) {
              if (! ((tmp->region)->flags & 516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            ret = __bam_curadj_log(dbp___1, my_dbc->txn, & lsn, 0U, (enum __anonenum_db_ca_mode_54 )1,
                                   pgno, 0U, 0U, (unsigned int )adjust, indx, 0U);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static int __bam_opd_cursor(DB *dbp___1 , DBC *dbc , unsigned int first , u_int32_t tpgno ,
                            u_int32_t ti ) 
{ BTREE_CURSOR *cp ;
  BTREE_CURSOR *orig_cp ;
  DBC *dbc_nopd ;
  int ret ;

  {
  orig_cp = (BTREE_CURSOR *)dbc->internal;
  dbc_nopd = (DBC *)((void *)0);
  ret = __db_c_newopd(dbc, tpgno, orig_cp->opd, & dbc_nopd);
  if (ret != 0) {
    return (ret);
  }
  cp = (BTREE_CURSOR *)dbc_nopd->internal;
  cp->pgno = tpgno;
  cp->indx = (unsigned short )ti;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    cp->recno = ti + 1U;
  }
  if (orig_cp->flags & 1U) {
    cp->flags |= 1U;
    orig_cp->flags &= 4294967294U;
  }
  orig_cp->opd = dbc_nopd;
  orig_cp->indx = (unsigned short )first;
  return (0);
}
}
int __bam_ca_dup(DBC *my_dbc , u_int32_t first , db_pgno_t fpgno , u_int32_t fi ,
                 db_pgno_t tpgno , u_int32_t ti ) 
{ BTREE_CURSOR *orig_cp ;
  DB *dbp___1 ;
  DB *ldbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  int found ;
  int ret ;

  {
  dbp___1 = my_dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(my_dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = my_dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    loop: 
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      orig_cp = (BTREE_CURSOR *)dbc->internal;
      if (orig_cp->pgno != fpgno) {
        goto __Cont;
      } else {
        if ((unsigned int )orig_cp->indx != fi) {
          goto __Cont;
        }
      }
      if ((unsigned int )orig_cp->opd != (unsigned int )((void *)0)) {
        goto __Cont;
      }
      if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbp___1->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
        }
      }
      ret = __bam_opd_cursor(dbp___1, dbc, first, tpgno, ti);
      if (ret != 0) {
        return (ret);
      }
      if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
        if ((unsigned int )dbc->txn != (unsigned int )my_txn) {
          found = 1;
        }
      }
      goto loop;
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((my_dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (my_dbc->flags & 16U)) {
          if ((unsigned int )((my_dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((my_dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((my_dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            ret = __bam_curadj_log(dbp___1, my_dbc->txn, & lsn, 0U, (enum __anonenum_db_ca_mode_54 )2,
                                   fpgno, tpgno, 0U, first, fi, ti);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
int __bam_ca_undodup(DB *dbp___1 , u_int32_t first , db_pgno_t fpgno , u_int32_t fi ,
                     u_int32_t ti ) 
{ BTREE_CURSOR *orig_cp ;
  DB *ldbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    loop: 
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      orig_cp = (BTREE_CURSOR *)dbc->internal;
      if (orig_cp->pgno != fpgno) {
        goto __Cont;
      } else {
        if ((unsigned int )orig_cp->indx != first) {
          goto __Cont;
        } else {
          if ((unsigned int )orig_cp->opd == (unsigned int )((void *)0)) {
            goto __Cont;
          } else {
            if ((unsigned int )((BTREE_CURSOR *)(orig_cp->opd)->internal)->indx !=
                ti) {
              goto __Cont;
            }
          }
        }
      }
      if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbp___1->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
        }
      }
      ret = __db_c_close(orig_cp->opd);
      if (ret != 0) {
        return (ret);
      }
      orig_cp->opd = (DBC *)((void *)0);
      orig_cp->indx = (unsigned short )fi;
      goto loop;
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (0);
}
}
int __bam_ca_rsplit(DBC *my_dbc , db_pgno_t fpgno , db_pgno_t tpgno ) 
{ DB *dbp___1 ;
  DB *ldbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  int found ;
  int ret ;

  {
  dbp___1 = my_dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(my_dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = my_dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      if ((int )dbc->dbtype == 3) {
        goto __Cont;
      }
      if ((dbc->internal)->pgno == fpgno) {
        (dbc->internal)->pgno = tpgno;
        if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
          if ((unsigned int )dbc->txn != (unsigned int )my_txn) {
            found = 1;
          }
        }
      }
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((my_dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (my_dbc->flags & 16U)) {
          if ((unsigned int )((my_dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((my_dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((my_dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            ret = __bam_curadj_log(dbp___1, my_dbc->txn, & lsn, 0U, (enum __anonenum_db_ca_mode_54 )3,
                                   fpgno, tpgno, 0U, 0U, 0U, 0U);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
int __bam_ca_split(DBC *my_dbc , db_pgno_t ppgno , db_pgno_t lpgno , db_pgno_t rpgno ,
                   u_int32_t split_indx , int cleft ) 
{ DB *dbp___1 ;
  DB *ldbp ;
  DBC *dbc ;
  DBC_INTERNAL *cp ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  int found ;
  int ret ;
  db_pgno_t tmp ;

  {
  dbp___1 = my_dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(my_dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = my_dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      if ((int )dbc->dbtype == 3) {
        goto __Cont;
      }
      cp = dbc->internal;
      if (cp->pgno == ppgno) {
        if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
          if ((unsigned int )dbc->txn != (unsigned int )my_txn) {
            found = 1;
          }
        }
        if ((unsigned int )cp->indx < split_indx) {
          if (cleft) {
            cp->pgno = lpgno;
          }
        } else {
          cp->pgno = rpgno;
          cp->indx = (unsigned short )((unsigned int )cp->indx - split_indx);
        }
      }
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )my_dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((my_dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (my_dbc->flags & 16U)) {
          if ((unsigned int )((my_dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((my_dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((my_dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (cleft) {
              tmp = lpgno;
            } else {
              tmp = 0U;
            }
            ret = __bam_curadj_log(dbp___1, my_dbc->txn, & lsn, 0U, (enum __anonenum_db_ca_mode_54 )4,
                                   ppgno, rpgno, tmp, 0U, split_indx, 0U);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
void __bam_ca_undosplit(DB *dbp___1 , db_pgno_t frompgno , db_pgno_t topgno , db_pgno_t lpgno ,
                        u_int32_t split_indx ) 
{ DB *ldbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DBC_INTERNAL *cp ;

  {
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      if ((int )dbc->dbtype == 3) {
        goto __Cont;
      }
      cp = dbc->internal;
      if (cp->pgno == topgno) {
        cp->pgno = frompgno;
        cp->indx = (unsigned short )((unsigned int )cp->indx + split_indx);
      } else {
        if (cp->pgno == lpgno) {
          cp->pgno = frompgno;
        }
      }
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-SGePz8YA.i","-O2")
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
int __os_malloc(DB_ENV *dbenv___0 , size_t size , void *storep ) ;
void __os_free(DB_ENV *dbenv___0 , void *ptr ) ;
int __db_unknown_flag(DB_ENV *dbenv___0 , char *routine , u_int32_t flag ) ;
int __db_unknown_type(DB_ENV *dbenv___0 , char *routine , DBTYPE type ) ;
int __bam_c_init(DBC *dbc , DBTYPE dbtype ) ;
int __bam_c_refresh(DBC *dbc ) ;
int __bam_c_count(DBC *dbc , db_recno_t *recnop ) ;
int __bam_c_dup(DBC *orig_dbc , DBC *new_dbc ) ;
int __bam_bulk_overflow(DBC *dbc , u_int32_t len , db_pgno_t pgno , u_int8_t *dp ) ;
int __bam_bulk_duplicates(DBC *dbc , db_pgno_t pgno , u_int8_t *dbuf , int32_t *keyoff ,
                          int32_t **offpp , u_int8_t **dpp , u_int32_t *spacep , int no_dup ) ;
int __bam_c_rget(DBC *dbc , DBT *data ) ;
int __bam_ditem(DBC *dbc , PAGE *h , u_int32_t indx ) ;
int __bam_dpages(DBC *dbc , EPG *stack_epg ) ;
int __bam_iitem(DBC *dbc , DBT *key , DBT *data , u_int32_t op , u_int32_t flags ) ;
int __ram_c_del(DBC *dbc ) ;
int __ram_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
int __ram_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
int __ram_getno(DBC *dbc , DBT const   *key , db_recno_t *rep , int can_create ) ;
int __bam_rsearch(DBC *dbc , db_recno_t *recnop , u_int32_t flags , int stop , int *exactp ) ;
int __bam_adjust(DBC *dbc , int32_t adjust ) ;
int __bam_search(DBC *dbc , db_pgno_t root_pgno , DBT const   *key , u_int32_t flags ,
                 int stop , db_recno_t *recnop , int *exactp ) ;
int __bam_stkrel(DBC *dbc , u_int32_t flags ) ;
int __bam_stkgrow(DB_ENV *dbenv___0 , BTREE_CURSOR *cp ) ;
int __bam_split(DBC *dbc , void *arg , db_pgno_t *root_pgnop ) ;
int __bam_cdel_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx ) ;
int __db_duperr(DB *dbp___1 , u_int32_t flags ) ;
int __db_c_count_pp(DBC *dbc , db_recno_t *recnop , u_int32_t flags ) ;
int __db_c_del_pp(DBC *dbc , u_int32_t flags ) ;
int __db_c_dup_pp(DBC *dbc , DBC **dbcp , u_int32_t flags ) ;
int __db_c_get_pp(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_c_pget_pp(DBC *dbc , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) ;
int __db_c_put_pp(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_free(DBC *dbc , PAGE *h ) ;
int __db_lget(DBC *dbc , int action , db_pgno_t pgno , db_lockmode_t mode , u_int32_t lkflags ,
              DB_LOCK *lockp ) ;
int __db_lput(DBC *dbc , DB_LOCK *lockp ) ;
int __db_goff(DB *dbp___1 , DBT *dbt , u_int32_t tlen , db_pgno_t pgno , void **bpp ,
              u_int32_t *bpsz ) ;
int __db_ret(DB *dbp___1 , PAGE *h , u_int32_t indx , DBT *dbt , void **memp , u_int32_t *memsize ) ;
int __db_retcopy(DB_ENV *dbenv___0 , DBT *dbt , void *data , u_int32_t len , void **memp ,
                 u_int32_t *memsize ) ;
int __lock_get(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DBT const   *obj ,
               db_lockmode_t lock_mode , DB_LOCK *lock ) ;
int __lock_put(DB_ENV *dbenv___0 , DB_LOCK *lock ) ;
int __lock_downgrade(DB_ENV *dbenv___0 , DB_LOCK *lock , db_lockmode_t new_mode ,
                     u_int32_t flags ) ;
int __memp_fget(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr , u_int32_t flags , void *addrp ) ;
int __memp_fput(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) ;
int __memp_fset(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) ;
static int __bam_bulk(DBC *dbc , DBT *data , u_int32_t flags ) ;
static int __bam_c_close(DBC *dbc , db_pgno_t root_pgno , int *rmroot ) ;
static int __bam_c_del(DBC *dbc ) ;
static int __bam_c_destroy(DBC *dbc ) ;
static int __bam_c_first(DBC *dbc ) ;
static int __bam_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
static int __bam_c_getstack(DBC *dbc ) ;
static int __bam_c_last(DBC *dbc ) ;
static int __bam_c_next(DBC *dbc , int initial_move , int deleted_okay ) ;
static int __bam_c_physdel(DBC *dbc ) ;
static int __bam_c_prev(DBC *dbc ) ;
static int __bam_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
static int __bam_c_search(DBC *dbc , db_pgno_t root_pgno , DBT const   *key , u_int32_t flags ,
                          int *exactp ) ;
static int __bam_c_writelock(DBC *dbc ) ;
static int __bam_getboth_finddatum(DBC *dbc , DBT *data , u_int32_t flags ) ;
static int __bam_getbothc(DBC *dbc , DBT *data ) ;
static int __bam_get_prev(DBC *dbc ) ;
static int __bam_isopd(DBC *dbc , db_pgno_t *pgnop ) ;
int __bam_c_init(DBC *dbc , DBTYPE dbtype ) 
{ DB_ENV *dbenv___0 ;
  int ret ;

  {
  dbenv___0 = (dbc->dbp)->dbenv;
  if ((unsigned int )dbc->internal == (unsigned int )((void *)0)) {
    ret = __os_malloc(dbenv___0, sizeof(BTREE_CURSOR ), (void *)(& dbc->internal));
    if (ret != 0) {
      return (ret);
    }
  }
  dbc->c_close = & __db_c_close;
  dbc->c_count = & __db_c_count_pp;
  dbc->c_del = & __db_c_del_pp;
  dbc->c_dup = & __db_c_dup_pp;
  dbc->c_get = & __db_c_get_pp;
  dbc->c_pget = & __db_c_pget_pp;
  dbc->c_put = & __db_c_put_pp;
  if ((int )dbtype == 1) {
    dbc->c_am_bulk = & __bam_bulk;
    dbc->c_am_close = & __bam_c_close;
    dbc->c_am_del = & __bam_c_del;
    dbc->c_am_destroy = & __bam_c_destroy;
    dbc->c_am_get = & __bam_c_get;
    dbc->c_am_put = & __bam_c_put;
    dbc->c_am_writelock = & __bam_c_writelock;
  } else {
    dbc->c_am_bulk = & __bam_bulk;
    dbc->c_am_close = & __bam_c_close;
    dbc->c_am_del = & __ram_c_del;
    dbc->c_am_destroy = & __bam_c_destroy;
    dbc->c_am_get = & __ram_c_get;
    dbc->c_am_put = & __ram_c_put;
    dbc->c_am_writelock = & __bam_c_writelock;
  }
  return (0);
}
}
int __bam_c_refresh(DBC *dbc ) 
{ BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  unsigned int tmp___0 ;
  u_int32_t tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  t = (BTREE *)dbp___1->bt_internal;
  cp = (BTREE_CURSOR *)dbc->internal;
  if (cp->root == 0U) {
    cp->root = t->bt_root;
  }
  cp->lock.off = 0U;
  cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
  cp->csp = cp->stack;
  cp->sp = cp->csp;
  cp->esp = cp->stack + sizeof(cp->stack) / sizeof(cp->stack[0]);
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  if (dbc->flags & 8U) {
    tmp___1 = 2U;
  } else {
    tmp___1 = t->bt_minkey;
  }
  cp->ovflsize = (unsigned short )((unsigned long long )((dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                             26) +
                                                                                                                                            tmp___0))))) /
                                                         (tmp___1 * 2U)) - ((((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                                     sizeof(u_int32_t )) -
                                                                                                    1U) &
                                                                              ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL)) +
                                                                             (unsigned long long )sizeof(db_indx_t )) +
                                                                            ((unsigned long long )((1U +
                                                                                                    sizeof(int32_t )) -
                                                                                                   1U) &
                                                                             ~ ((unsigned long long )sizeof(int32_t ) -
                                                                                1ULL))));
  cp->recno = 0U;
  cp->order = 0U;
  cp->flags = 0U;
  if (dbc->flags & 8U) {
    goto _L___0;
  } else {
    if ((int )dbc->dbtype == 3) {
      goto _L___0;
    } else {
      if (dbp___1->flags & 1048576U) {
        _L___0: 
        cp->flags = cp->flags | 2U;
        if (dbc->flags & 8U) {
          if ((int )dbc->dbtype == 3) {
            cp->flags = cp->flags | 4U;
          } else {
            goto _L;
          }
        } else {
          _L: 
          if (dbp___1->flags & 5242880U) {
            cp->flags = cp->flags | 4U;
          }
        }
      }
    }
  }
  return (0);
}
}
static int __bam_c_close(DBC *dbc , db_pgno_t root_pgno , int *rmroot ) 
{ BTREE_CURSOR *cp ;
  BTREE_CURSOR *cp_opd ;
  BTREE_CURSOR *cp_c ;
  DB *dbp___1 ;
  DBC *dbc_opd ;
  DBC *dbc_c ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int cdb_lock ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  DB_MPOOLFILE *__mpf ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf___0 ;
  int __t_ret ;
  BTREE_CURSOR *__cp___0 ;
  DB_MPOOLFILE *__mpf___1 ;
  int __t_ret___0 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  dbc_opd = cp->opd;
  if ((unsigned int )dbc_opd == (unsigned int )((void *)0)) {
    cp_opd = (BTREE_CURSOR *)((void *)0);
  } else {
    cp_opd = (BTREE_CURSOR *)dbc_opd->internal;
  }
  ret = 0;
  cdb_lock = ret;
  if (cp->flags & 1U) {
    dbc_c = dbc;
    switch ((int )dbc->dbtype) {
    case 1: 
    tmp = __bam_ca_delete(dbp___1, cp->pgno, (unsigned int )cp->indx, 1);
    if (tmp == 0) {
      goto lock;
    }
    goto err;
    case 3: ;
    if (! (dbc->flags & 8U)) {
      goto err;
    }
    tmp___0 = __ram_ca_delete(dbp___1, cp->root);
    if (tmp___0 == 0) {
      goto lock;
    }
    goto err;
    case 2: ;
    case 4: ;
    case 5: ;
    default: 
    tmp___1 = __db_unknown_type(dbp___1->dbenv, (char *)"__bam_c_close", dbc->dbtype);
    return (tmp___1);
    }
  }
  if ((unsigned int )dbc_opd == (unsigned int )((void *)0)) {
    goto err;
  }
  if (cp_opd->flags & 1U) {
    ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 2048U) {
      tmp___3 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___3 = sizeof(PG_CHKSUM );
      } else {
        tmp___3 = 0U;
      }
    }
    root_pgno = ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                       26) + tmp___3) +
                                                        ((int )cp->indx + 1)))))->pgno;
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      goto err;
    }
    dbc_c = dbc_opd;
    switch ((int )dbc_opd->dbtype) {
    case 1: 
    tmp___4 = __bam_ca_delete(dbp___1, cp_opd->pgno, (unsigned int )cp_opd->indx,
                              1);
    if (tmp___4 == 0) {
      goto lock;
    }
    goto err;
    case 3: 
    tmp___5 = __ram_ca_delete(dbp___1, cp_opd->root);
    if (tmp___5 == 0) {
      goto lock;
    }
    goto err;
    case 2: ;
    case 4: ;
    case 5: ;
    default: 
    tmp___6 = __db_unknown_type(dbp___1->dbenv, (char *)"__bam_c_close", dbc->dbtype);
    return (tmp___6);
    }
  }
  goto err;
  lock: 
  cp_c = (BTREE_CURSOR *)dbc_c->internal;
  if ((dbp___1->dbenv)->flags & 2U) {
    if (dbc->flags & 128U) {
      ret = __lock_get(dbp___1->dbenv, dbc->locker, 32U, (DBT const   *)(& dbc->lock_dbt),
                       (enum __anonenum_db_lockmode_t_50 )2, & dbc->mylock);
      if (ret != 0) {
        goto err;
      }
      cdb_lock = 1;
    }
    ret = __memp_fget(mpf, & cp_c->pgno, 0U, (void *)(& cp_c->page));
    if (ret != 0) {
      goto err;
    }
    goto delete;
  }
  if (dbc->flags & 8U) {
    ret = __memp_fget(mpf, & cp_c->pgno, 0U, (void *)(& cp_c->page));
    if (ret != 0) {
      goto err;
    }
    goto delete;
  }
  __mpf = (dbc->dbp)->mpf;
  if ((unsigned int )cp_c->page != (unsigned int )((void *)0)) {
    ret = __memp_fput(__mpf, cp_c->page, 0U);
    cp_c->page = (void *)0;
  } else {
    ret = 0;
  }
  if (ret == 0) {
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          ret = __db_lget(dbc, 2, cp->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                          0U, & cp_c->lock);
        }
      }
    }
  }
  if (ret == 0) {
    ret = __memp_fget(__mpf, & cp_c->pgno, 0U, (void *)(& cp_c->page));
  }
  if (ret != 0) {
    goto err;
  }
  delete: 
  if ((int )dbc_c->dbtype == 1) {
    ret = __bam_c_physdel(dbc_c);
    if (ret != 0) {
      goto err;
    }
  }
  if (! (dbc_c->flags & 8U)) {
    goto err;
  } else {
    if (root_pgno == 0U) {
      goto err;
    }
  }
  ret = __memp_fget(mpf, & root_pgno, 0U, (void *)(& h));
  if (ret != 0) {
    goto err;
  }
  if ((int )h->entries == 0) {
    ret = __db_free(dbc, h);
    if (ret != 0) {
      goto err;
    }
  } else {
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      goto err;
    }
    goto err;
  }
  if ((unsigned int )dbc_opd != (unsigned int )((void *)0)) {
    ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& cp->page));
    if (ret != 0) {
      goto err;
    }
    ret = __bam_c_physdel(dbc);
    if (ret != 0) {
      goto err;
    }
  } else {
    (*rmroot) = 1;
  }
  err: 
  if ((unsigned int )dbc_opd != (unsigned int )((void *)0)) {
    __cp = (BTREE_CURSOR *)dbc_opd->internal;
    __mpf___0 = (dbc_opd->dbp)->mpf;
    if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(__mpf___0, __cp->page, 0U);
      __cp->page = (void *)0;
    } else {
      t_ret = 0;
    }
    if (__cp->lock.off != 0U) {
      __t_ret = __db_lput(dbc_opd, & __cp->lock);
    } else {
      __t_ret = 0;
    }
    if (__t_ret != 0) {
      if (t_ret == 0) {
        t_ret = __t_ret;
      }
    }
    if (t_ret == 0) {
      if (! (__cp->lock.off != 0U)) {
        __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
      }
    }
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  __cp___0 = (BTREE_CURSOR *)dbc->internal;
  __mpf___1 = (dbc->dbp)->mpf;
  if ((unsigned int )__cp___0->page != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(__mpf___1, __cp___0->page, 0U);
    __cp___0->page = (void *)0;
  } else {
    t_ret = 0;
  }
  if (__cp___0->lock.off != 0U) {
    __t_ret___0 = __db_lput(dbc, & __cp___0->lock);
  } else {
    __t_ret___0 = 0;
  }
  if (__t_ret___0 != 0) {
    if (t_ret == 0) {
      t_ret = __t_ret___0;
    }
  }
  if (t_ret == 0) {
    if (! (__cp___0->lock.off != 0U)) {
      __cp___0->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
    }
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (cdb_lock) {
    __lock_downgrade(dbp___1->dbenv, & dbc->mylock, (enum __anonenum_db_lockmode_t_50 )4,
                     0U);
  }
  return (ret);
}
}
static int __bam_c_destroy(DBC *dbc ) 
{ 

  {
  __os_free((dbc->dbp)->dbenv, (void *)dbc->internal);
  return (0);
}
}
int __bam_c_count(DBC *dbc , db_recno_t *recnop ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  db_indx_t indx ;
  db_indx_t top ;
  db_recno_t recno ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___14 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  if ((unsigned int )cp->opd == (unsigned int )((void *)0)) {
    ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& cp->page));
    if (ret != 0) {
      return (ret);
    }
    indx = cp->indx;
    while (1) {
      if ((int )indx == 0) {
        break;
      } else {
        if ((dbc->dbp)->flags & 2048U) {
          tmp___0 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___0 = sizeof(PG_CHKSUM );
          } else {
            tmp___0 = 0U;
          }
        }
        if ((dbc->dbp)->flags & 2048U) {
          tmp___2 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___2 = sizeof(PG_CHKSUM );
          } else {
            tmp___2 = 0U;
          }
        }
        if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                       26) + tmp___0) + (int )indx)) == (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                                                                                26) +
                                                                                               tmp___2) +
                                                                                 ((int )indx -
                                                                                  2))))) {
          break;
        }
      }
      indx = (unsigned short )((int )indx - 2);
    }
    recno = 0U;
    top = (unsigned short )((int )((PAGE *)cp->page)->entries - 2);
    while (1) {
      if (dbp___1->flags & 2048U) {
        tmp___4 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___4 = sizeof(PG_CHKSUM );
        } else {
          tmp___4 = 0U;
        }
      }
      if ((int )((PAGE *)cp->page)->type == 5) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
      if (! ((int )((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                                26) +
                                                                               tmp___4) +
                                                                 ((int )indx + tmp___5)))))->type &
             128)) {
        recno ++;
      }
      if ((int )indx == (int )top) {
        break;
      } else {
        if ((dbc->dbp)->flags & 2048U) {
          tmp___7 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___7 = sizeof(PG_CHKSUM );
          } else {
            tmp___7 = 0U;
          }
        }
        if ((dbc->dbp)->flags & 2048U) {
          tmp___9 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___9 = sizeof(PG_CHKSUM );
          } else {
            tmp___9 = 0U;
          }
        }
        if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                       26) + tmp___7) + (int )indx)) == (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                                                                                26) +
                                                                                               tmp___9) +
                                                                                 ((int )indx +
                                                                                  2))))) {
          break;
        }
      }
      indx = (unsigned short )((int )indx + 2);
    }
  } else {
    ret = __memp_fget(mpf, & ((cp->opd)->internal)->root, 0U, (void *)(& cp->page));
    if (ret != 0) {
      return (ret);
    }
    if ((int )((PAGE *)cp->page)->type == 12) {
      recno = 0U;
      indx = (unsigned short)0;
      top = (unsigned short )((int )((PAGE *)cp->page)->entries - 1);
      while (1) {
        if (dbp___1->flags & 2048U) {
          tmp___11 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___11 = sizeof(PG_CHKSUM );
          } else {
            tmp___11 = 0U;
          }
        }
        if ((int )((PAGE *)cp->page)->type == 5) {
          tmp___12 = 1;
        } else {
          tmp___12 = 0;
        }
        if (! ((int )((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                                  26) +
                                                                                 tmp___11) +
                                                                   ((int )indx + tmp___12)))))->type &
               128)) {
          recno ++;
        }
        if ((int )indx == (int )top) {
          break;
        }
        indx = (unsigned short )((int )indx + 1);
      }
    } else {
      if ((int )((PAGE *)cp->page)->type == 3) {
        recno = ((PAGE *)cp->page)->prev_pgno;
      } else {
        if ((int )((PAGE *)cp->page)->type == 4) {
          recno = ((PAGE *)cp->page)->prev_pgno;
        } else {
          if ((int )((PAGE *)cp->page)->type == 5) {
            tmp___14 = (int )((PAGE *)cp->page)->entries / 2;
          } else {
            tmp___14 = (int )((PAGE *)cp->page)->entries;
          }
          recno = (unsigned int )tmp___14;
        }
      }
    }
  }
  (*recnop) = recno;
  ret = __memp_fput(mpf, cp->page, 0U);
  cp->page = (void *)0;
  return (ret);
}
}
static int __bam_c_del(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  int ret ;
  int t_ret ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  if (cp->flags & 1U) {
    return (-30997);
  }
  if (cp->flags & 2U) {
    ret = __bam_c_getstack(dbc);
    if (ret != 0) {
      goto err;
    }
    cp->page = (void *)(cp->csp)->page;
  } else {
    __cp = (BTREE_CURSOR *)dbc->internal;
    if (cp->pgno != __cp->pgno) {
      __cp->pgno = 0U;
    }
    __mpf = (dbc->dbp)->mpf;
    if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(__mpf, __cp->page, 0U);
      __cp->page = (void *)0;
    } else {
      ret = 0;
    }
    if (ret == 0) {
      if (! (dbc->flags & 8U)) {
        if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
            ret = __db_lget(dbc, 2, cp->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                            0U, & __cp->lock);
          }
        }
      }
    }
    if (ret == 0) {
      ret = __memp_fget(__mpf, & cp->pgno, 0U, (void *)(& __cp->page));
    }
    if (ret == 0) {
      __cp->pgno = cp->pgno;
      __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
    }
    if (ret != 0) {
      goto err;
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __bam_cdel_log(dbp___1, dbc->txn, & ((PAGE *)cp->page)->lsn, 0U, ((PAGE *)cp->page)->pgno,
                               & ((PAGE *)cp->page)->lsn, (unsigned int )cp->indx);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      ((PAGE *)cp->page)->lsn.file = 0U;
      ((PAGE *)cp->page)->lsn.offset = 1U;
      break;
    }
  }
  if ((int )((PAGE *)cp->page)->type == 5) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    ((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                 26) + tmp___0) +
                                                  ((int )cp->indx + 1)))))->type = (unsigned char )((int )((BKEYDATA *)((u_int8_t *)cp->page +
                                                                                                                        (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                                                                                                26) +
                                                                                                                                               tmp___0) +
                                                                                                                                 ((int )cp->indx +
                                                                                                                                  1)))))->type |
                                                                                                    128);
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    ((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                 26) + tmp___2) +
                                                  (int )cp->indx))))->type = (unsigned char )((int )((BKEYDATA *)((u_int8_t *)cp->page +
                                                                                                                  (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                                                                                          26) +
                                                                                                                                         tmp___2) +
                                                                                                                           (int )cp->indx))))->type |
                                                                                              128);
  }
  ret = __memp_fset(mpf, cp->page, 2U);
  err: 
  if (cp->flags & 2U) {
    if (ret == 0) {
      ret = __bam_adjust(dbc, -1);
    }
    __bam_stkrel(dbc, 0U);
  } else {
    if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(mpf, cp->page, 0U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  cp->page = (void *)0;
  if (ret == 0) {
    __bam_ca_delete(dbp___1, cp->pgno, (unsigned int )cp->indx, 1);
  }
  return (ret);
}
}
int __bam_c_dup(DBC *orig_dbc , DBC *new_dbc ) 
{ BTREE_CURSOR *orig ;
  BTREE_CURSOR *new ;
  int ret ;

  {
  orig = (BTREE_CURSOR *)orig_dbc->internal;
  new = (BTREE_CURSOR *)new_dbc->internal;
  if (orig->lock.off != 0U) {
    if ((unsigned int )orig_dbc->txn == (unsigned int )((void *)0)) {
      ret = __db_lget(new_dbc, 0, new->pgno, new->lock_mode, 0U, & new->lock);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  new->ovflsize = orig->ovflsize;
  new->recno = orig->recno;
  new->flags = orig->flags;
  return (0);
}
}
static int __bam_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  db_pgno_t orig_pgno ;
  db_indx_t orig_indx ;
  int exact ;
  int newopd ;
  int ret ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  int tmp___17 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  orig_pgno = cp->pgno;
  orig_indx = cp->indx;
  newopd = 0;
  switch ((int )flags) {
  case 7: ;
  if (cp->flags & 1U) {
    ret = -30997;
    goto err;
  }
  ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& cp->page));
  if (ret != 0) {
    goto err;
  }
  break;
  case 9: 
  newopd = 1;
  ret = __bam_c_first(dbc);
  if (ret != 0) {
    goto err;
  }
  break;
  case 10: ;
  case 12: ;
  if (dbc->flags & 8U) {
    ret = __bam_c_search(dbc, 0U, (DBT const   *)data, flags, & exact);
    if (ret != 0) {
      goto err;
    }
    if (flags == 10U) {
      if (! exact) {
        ret = -30990;
        goto err;
      }
      break;
    }
    if ((int )cp->indx == (int )((PAGE *)cp->page)->entries) {
      goto _L;
    } else {
      if ((dbc->dbp)->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      if ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                          26) +
                                                                                         tmp___0) +
                                                                           ((int )(dbc->internal)->indx +
                                                                            tmp___1)))))->type &
          128) {
        _L: 
        ret = __bam_c_next(dbc, 1, 0);
        if (ret != 0) {
          goto err;
        }
      }
    }
  } else {
    ret = __bam_c_search(dbc, 0U, (DBT const   *)key, flags, & exact);
    if (ret != 0) {
      return (ret);
    }
    if (! exact) {
      ret = -30990;
      goto err;
    }
    if ((unsigned int )pgnop != (unsigned int )((void *)0)) {
      tmp___2 = __bam_isopd(dbc, pgnop);
      if (tmp___2) {
        newopd = 1;
        break;
      }
    }
    ret = __bam_getboth_finddatum(dbc, data, flags);
    if (ret != 0) {
      goto err;
    }
  }
  break;
  case 11: 
  ret = __bam_getbothc(dbc, data);
  if (ret != 0) {
    goto err;
  }
  break;
  case 17: 
  newopd = 1;
  ret = __bam_c_last(dbc);
  if (ret != 0) {
    goto err;
  }
  break;
  case 18: 
  newopd = 1;
  if (cp->pgno == 0U) {
    ret = __bam_c_first(dbc);
    if (ret != 0) {
      goto err;
    }
  } else {
    ret = __bam_c_next(dbc, 1, 0);
    if (ret != 0) {
      goto err;
    }
  }
  break;
  case 19: 
  ret = __bam_c_next(dbc, 1, 0);
  if (ret != 0) {
    goto err;
  }
  if (! (dbc->flags & 8U)) {
    if (orig_pgno == (dbc->internal)->pgno) {
      if ((dbc->dbp)->flags & 2048U) {
        tmp___4 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___4 = sizeof(PG_CHKSUM );
        } else {
          tmp___4 = 0U;
        }
      }
      if ((dbc->dbp)->flags & 2048U) {
        tmp___6 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___6 = sizeof(PG_CHKSUM );
        } else {
          tmp___6 = 0U;
        }
      }
      if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                     26) + tmp___4) + (int )(dbc->internal)->indx)) ==
             (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                     26) + tmp___6) + (int )orig_indx)))) {
        ret = -30990;
        goto err;
      }
    } else {
      ret = -30990;
      goto err;
    }
  }
  break;
  case 20: 
  newopd = 1;
  if (cp->pgno == 0U) {
    ret = __bam_c_first(dbc);
    if (ret != 0) {
      goto err;
    }
  } else {
    while (1) {
      ret = __bam_c_next(dbc, 1, 0);
      if (ret != 0) {
        goto err;
      }
      if (! (dbc->flags & 8U)) {
        if (orig_pgno == (dbc->internal)->pgno) {
          if ((dbc->dbp)->flags & 2048U) {
            tmp___8 = sizeof(PG_CRYPTO );
          } else {
            if ((dbc->dbp)->flags & 1U) {
              tmp___8 = sizeof(PG_CHKSUM );
            } else {
              tmp___8 = 0U;
            }
          }
          if ((dbc->dbp)->flags & 2048U) {
            tmp___10 = sizeof(PG_CRYPTO );
          } else {
            if ((dbc->dbp)->flags & 1U) {
              tmp___10 = sizeof(PG_CHKSUM );
            } else {
              tmp___10 = 0U;
            }
          }
          if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                         26) + tmp___8) + (int )(dbc->internal)->indx)) ==
                 (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                         26) + tmp___10) + (int )orig_indx)))) {
            break;
          }
        } else {
          break;
        }
      }
    }
  }
  break;
  case 25: 
  newopd = 1;
  if (cp->pgno == 0U) {
    ret = __bam_c_last(dbc);
    if (ret != 0) {
      goto err;
    }
  } else {
    ret = __bam_c_prev(dbc);
    if (ret != 0) {
      goto err;
    }
  }
  break;
  case 26: 
  newopd = 1;
  if (cp->pgno == 0U) {
    ret = __bam_c_last(dbc);
    if (ret != 0) {
      goto err;
    }
  } else {
    while (1) {
      ret = __bam_c_prev(dbc);
      if (ret != 0) {
        goto err;
      }
      if (! (dbc->flags & 8U)) {
        if (orig_pgno == (dbc->internal)->pgno) {
          if ((dbc->dbp)->flags & 2048U) {
            tmp___12 = sizeof(PG_CRYPTO );
          } else {
            if ((dbc->dbp)->flags & 1U) {
              tmp___12 = sizeof(PG_CHKSUM );
            } else {
              tmp___12 = 0U;
            }
          }
          if ((dbc->dbp)->flags & 2048U) {
            tmp___14 = sizeof(PG_CRYPTO );
          } else {
            if ((dbc->dbp)->flags & 1U) {
              tmp___14 = sizeof(PG_CHKSUM );
            } else {
              tmp___14 = 0U;
            }
          }
          if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                         26) + tmp___12) + (int )(dbc->internal)->indx)) ==
                 (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                         26) + tmp___14) + (int )orig_indx)))) {
            break;
          }
        } else {
          break;
        }
      }
    }
  }
  break;
  case 28: ;
  case 31: 
  newopd = 1;
  ret = __bam_c_search(dbc, 0U, (DBT const   *)key, flags, & exact);
  if (ret != 0) {
    goto err;
  }
  break;
  case 30: 
  newopd = 1;
  ret = __bam_c_search(dbc, 0U, (DBT const   *)key, flags, & exact);
  if (ret != 0) {
    goto err;
  }
  if ((int )cp->indx == (int )((PAGE *)cp->page)->entries) {
    goto _L___0;
  } else {
    if ((dbc->dbp)->flags & 2048U) {
      tmp___16 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___16 = sizeof(PG_CHKSUM );
      } else {
        tmp___16 = 0U;
      }
    }
    if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
      tmp___17 = 1;
    } else {
      tmp___17 = 0;
    }
    if ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                        26) +
                                                                                       tmp___16) +
                                                                         ((int )(dbc->internal)->indx +
                                                                          tmp___17)))))->type &
        128) {
      _L___0: 
      ret = __bam_c_next(dbc, 0, 0);
      if (ret != 0) {
        goto err;
      }
    }
  }
  break;
  default: 
  ret = __db_unknown_flag(dbp___1->dbenv, (char *)"__bam_c_get", flags);
  goto err;
  }
  if (newopd) {
    if ((unsigned int )pgnop != (unsigned int )((void *)0)) {
      __bam_isopd(dbc, pgnop);
    }
  }
  if (flags == 10U) {
    key->flags = key->flags | 2U;
  } else {
    if (flags == 12U) {
      key->flags = key->flags | 2U;
    } else {
      if (flags == 28U) {
        key->flags = key->flags | 2U;
      }
    }
  }
  err: 
  if (cp->flags & 1U) {
    if (cp->pgno != orig_pgno) {
      cp->flags = cp->flags & 4294967294U;
    } else {
      if ((int )cp->indx != (int )orig_indx) {
        cp->flags = cp->flags & 4294967294U;
      }
    }
  }
  return (ret);
}
}
static int __bam_get_prev(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  DBT key ;
  DBT data ;
  db_pgno_t pgno ;
  int ret ;
  int tmp ;

  {
  ret = __bam_c_prev(dbc);
  if (ret != 0) {
    return (ret);
  }
  tmp = __bam_isopd(dbc, & pgno);
  if (tmp) {
    cp = (BTREE_CURSOR *)dbc->internal;
    ret = __db_c_newopd(dbc, pgno, cp->opd, & cp->opd);
    if (ret != 0) {
      return (ret);
    }
    ret = ((*((cp->opd)->c_am_get)))(cp->opd, & key, & data, 17U, (db_pgno_t *)((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  return (0);
}
}
static int __bam_bulk(DBC *dbc , DBT *data , u_int32_t flags ) 
{ BKEYDATA *bk ;
  BOVERFLOW *bo ;
  BTREE_CURSOR *cp ;
  PAGE *pg ;
  db_indx_t *inp ;
  db_indx_t indx ;
  db_indx_t pg_keyoff ;
  int32_t *endp ;
  int32_t key_off ;
  int32_t *offp ;
  int32_t *saveoffp ;
  u_int8_t *dbuf ;
  u_int8_t *dp ;
  u_int8_t *np ;
  u_int32_t key_size ;
  u_int32_t pagesize ;
  u_int32_t size ;
  u_int32_t space ;
  int adj ;
  int is_key ;
  int need_pg ;
  int next_key ;
  int no_dup ;
  int rec_key ;
  int ret ;
  int tmp ;
  unsigned int tmp___1 ;
  int32_t *tmp___2 ;
  int32_t *tmp___3 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___11 ;
  int32_t *tmp___12 ;
  int32_t *tmp___13 ;
  int32_t *tmp___14 ;
  int32_t *tmp___15 ;
  int32_t *tmp___16 ;
  int32_t *tmp___17 ;
  int32_t *tmp___18 ;
  int32_t *tmp___19 ;
  int32_t *tmp___20 ;
  int32_t *tmp___21 ;
  int32_t *tmp___22 ;
  int32_t *tmp___23 ;
  int32_t *tmp___24 ;
  int32_t *tmp___25 ;

  {
  ret = 0;
  key_off = 0;
  size = 0U;
  pagesize = (dbc->dbp)->pgsize;
  cp = (BTREE_CURSOR *)dbc->internal;
  dbuf = (u_int8_t *)data->data;
  dp = dbuf;
  np = dp;
  space = data->ulen;
  space -= sizeof((*offp));
  endp = (int32_t *)(dbuf + data->ulen);
  endp --;
  offp = endp;
  key_size = 0U;
  if ((int )dbc->dbtype == 1) {
    if (flags & 134217728U) {
      is_key = 1;
    } else {
      is_key = 0;
    }
    rec_key = 0;
    if (is_key) {
      if ((flags & 255U) != 19U) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    next_key = tmp;
    adj = 2;
  } else {
    is_key = 0;
    if (flags & 134217728U) {
      rec_key = 1;
    } else {
      rec_key = 0;
    }
    next_key = (flags & 255U) != 19U;
    adj = 1;
  }
  no_dup = (flags & 255U) == 20U;
  next_pg: 
  indx = cp->indx;
  pg = (PAGE *)cp->page;
  if ((dbc->dbp)->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if ((dbc->dbp)->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pg + 26) + tmp___1);
  need_pg = 1;
  pg_keyoff = (unsigned short)0;
  if (is_key == 0) {
    pg_keyoff = (*(inp + (int )indx));
  }
  while (1) {
    if ((dbc->dbp)->flags & 2048U) {
      tmp___5 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___5 = sizeof(PG_CHKSUM );
      } else {
        tmp___5 = 0U;
      }
    }
    if ((int )pg->type == 5) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
    if ((int )((BKEYDATA *)((u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                     26) + tmp___5) +
                                                      ((int )indx + tmp___6)))))->type &
        128) {
      if ((int )dbc->dbtype != 3) {
        goto __Cont;
      }
      cp->recno = cp->recno + 1U;
      if (rec_key != 0) {
        goto __Cont;
      }
      space -= 2U * sizeof((*offp));
      if (space > data->ulen) {
        goto back_up;
      }
      tmp___2 = offp;
      offp --;
      (*tmp___2) = 0;
      tmp___3 = offp;
      offp --;
      (*tmp___3) = 0;
      goto __Cont;
    }
    if (is_key) {
      if ((int )pg_keyoff != (int )(*(inp + (int )indx))) {
        if ((dbc->dbp)->flags & 2048U) {
          tmp___8 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___8 = sizeof(PG_CHKSUM );
          } else {
            tmp___8 = 0U;
          }
        }
        bk = (BKEYDATA *)((u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                   26) + tmp___8) +
                                                    (int )indx)));
        if (((int )bk->type & -129) == 3) {
          bo = (BOVERFLOW *)bk;
          key_size = bo->tlen;
          size = key_size;
          if (key_size > space) {
            goto get_key_space;
          }
          ret = __bam_bulk_overflow(dbc, bo->tlen, bo->pgno, np);
          if (ret != 0) {
            return (ret);
          }
          space -= key_size;
          key_off = np - dbuf;
          np += key_size;
        } else {
          if (need_pg) {
            dp = np;
            size = pagesize - (unsigned int )pg->hf_offset;
            if (space < size) {
              get_key_space: 
              if ((unsigned int )offp == (unsigned int )endp) {
                data->size = (unsigned int )((unsigned long long )(((size + pagesize) +
                                                                    1024U) - 1U) &
                                             0xfffffffffffffc00ULL);
                return (12);
              }
              if ((int )indx != 0) {
                indx = (unsigned short )((int )indx - 2);
              } else {
                ret = __bam_get_prev(dbc);
                if (ret != 0) {
                  return (ret);
                }
                indx = cp->indx;
                pg = (PAGE *)cp->page;
              }
              break;
            }
            memcpy((void * __restrict  )dp, (void const   * __restrict  )((u_int8_t *)pg +
                                                                          (int )pg->hf_offset),
                   size);
            need_pg = 0;
            space -= size;
            np += size;
          }
          key_size = (unsigned int )bk->len;
          key_off = (((int )(*(inp + (int )indx)) - (int )pg->hf_offset) + (dp - dbuf)) +
                    (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])));
          pg_keyoff = (*(inp + (int )indx));
        }
      }
    }
    if (is_key) {
      tmp___9 = 4;
    } else {
      tmp___9 = 2;
    }
    space -= (unsigned int )tmp___9 * sizeof((*offp));
    if (rec_key) {
      space -= sizeof((*offp));
    }
    if (space > data->ulen) {
      goto back_up;
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___11 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___11 = sizeof(PG_CHKSUM );
      } else {
        tmp___11 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) +
                                                              tmp___11) + (((int )indx +
                                                                            adj) -
                                                                           1))));
    if (((int )bk->type & -129) == 2) {
      bo = (BOVERFLOW *)bk;
      if (is_key) {
        tmp___12 = offp;
        offp --;
        (*tmp___12) = key_off;
        tmp___13 = offp;
        offp --;
        (*tmp___13) = (int )key_size;
      }
      saveoffp = offp;
      if (is_key) {
        tmp___14 = offp + 2;
      } else {
        tmp___14 = (int32_t *)((void *)0);
      }
      ret = __bam_bulk_duplicates(dbc, bo->pgno, dbuf, tmp___14, & offp, & np, & space,
                                  no_dup);
      if (ret != 0) {
        if (ret == 12) {
          size = space;
          space = 0U;
          if ((unsigned int )offp == (unsigned int )saveoffp) {
            offp += 2;
            goto back_up;
          }
          goto get_space;
        }
        return (ret);
      }
    } else {
      if (((int )bk->type & -129) == 3) {
        bo = (BOVERFLOW *)bk;
        size = bo->tlen;
        if (size > space) {
          goto back_up;
        }
        ret = __bam_bulk_overflow(dbc, bo->tlen, bo->pgno, np);
        if (ret != 0) {
          return (ret);
        }
        space -= size;
        if (is_key) {
          tmp___15 = offp;
          offp --;
          (*tmp___15) = key_off;
          tmp___16 = offp;
          offp --;
          (*tmp___16) = (int )key_size;
        } else {
          if (rec_key) {
            tmp___17 = offp;
            offp --;
            (*tmp___17) = (int )cp->recno;
          }
        }
        tmp___18 = offp;
        offp --;
        (*tmp___18) = np - dbuf;
        np += size;
        tmp___19 = offp;
        offp --;
        (*tmp___19) = (int )size;
      } else {
        if (need_pg) {
          dp = np;
          size = pagesize - (unsigned int )pg->hf_offset;
          if (space < size) {
            back_up: 
            if ((int )indx >= adj) {
              indx = (unsigned short )((int )indx - adj);
            } else {
              ret = __bam_get_prev(dbc);
              if (ret != 0) {
                if (ret != -30990) {
                  return (ret);
                }
              }
              indx = cp->indx;
              pg = (PAGE *)cp->page;
            }
            if ((int )dbc->dbtype == 3) {
              cp->recno = cp->recno - 1U;
            }
            get_space: 
            if (is_key) {
              tmp___20 = endp + -1;
            } else {
              tmp___20 = endp;
            }
            if ((unsigned int )offp >= (unsigned int )tmp___20) {
              data->size = (unsigned int )((unsigned long long )((((size + data->ulen) -
                                                                   space) + 1024U) -
                                                                 1U) & 0xfffffffffffffc00ULL);
              return (12);
            } else {
              if (dbc->flags & 64U) {
                data->size = (unsigned int )((unsigned long long )((((size + data->ulen) -
                                                                     space) + 1024U) -
                                                                   1U) & 0xfffffffffffffc00ULL);
                return (12);
              }
            }
            break;
          }
          memcpy((void * __restrict  )dp, (void const   * __restrict  )((u_int8_t *)pg +
                                                                        (int )pg->hf_offset),
                 size);
          need_pg = 0;
          space -= size;
          np += size;
        }
        if (is_key) {
          tmp___21 = offp;
          offp --;
          (*tmp___21) = key_off;
          tmp___22 = offp;
          offp --;
          (*tmp___22) = (int )key_size;
        } else {
          if (rec_key) {
            tmp___23 = offp;
            offp --;
            (*tmp___23) = (int )cp->recno;
          }
        }
        tmp___24 = offp;
        offp --;
        (*tmp___24) = (((int )(*(inp + (((int )indx + adj) - 1))) - (int )pg->hf_offset) +
                       (dp - dbuf)) + (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])));
        tmp___25 = offp;
        offp --;
        (*tmp___25) = (int )bk->len;
      }
    }
    if ((int )dbc->dbtype == 3) {
      cp->recno = cp->recno + 1U;
    } else {
      if (no_dup) {
        while (1) {
          if ((int )indx + adj < (int )pg->entries) {
            if (! ((int )pg_keyoff == (int )(*(inp + ((int )indx + adj))))) {
              break;
            }
          } else {
            break;
          }
          indx = (unsigned short )((int )indx + adj);
        }
      }
    }
    __Cont: 
    indx = (unsigned short )((int )indx + adj);
    if ((int )indx < (int )pg->entries) {
      if (! next_key) {
        if (! ((int )pg_keyoff == (int )(*(inp + (int )indx)))) {
          break;
        }
      }
    } else {
      break;
    }
  }
  if (ret == 0) {
    if (next_key) {
      if ((int )indx >= (int )pg->entries) {
        cp->indx = indx;
        ret = __bam_c_next(dbc, 0, 1);
        if (ret == 0) {
          goto next_pg;
        }
        if (ret != -30990) {
          return (ret);
        }
      }
    }
  }
  if (ret == 0) {
    if ((int )indx < (int )pg->entries) {
      if (dbc->flags & 64U) {
        if ((int )pg_keyoff == (int )(*(inp + (int )indx))) {
          data->size = (data->ulen - space) + size;
          return (12);
        }
      }
    }
  }
  if (ret == 12) {
    cp->indx = indx;
  } else {
    if (next_key) {
      cp->indx = indx;
    } else {
      if ((int )pg_keyoff == (int )(*(inp + (int )indx))) {
        cp->indx = indx;
      } else {
        cp->indx = (unsigned short )((int )indx - 2);
      }
    }
  }
  if (rec_key == 1) {
    (*offp) = 0;
  } else {
    (*offp) = -1;
  }
  return (0);
}
}
int __bam_bulk_overflow(DBC *dbc , u_int32_t len , db_pgno_t pgno , u_int8_t *dp ) 
{ DBT dbt ;
  int tmp ;

  {
  memset((void *)(& dbt), 0, sizeof(dbt));
  dbt.flags = dbt.flags | 32U;
  dbt.ulen = len;
  dbt.data = (void *)dp;
  tmp = __db_goff(dbc->dbp, & dbt, len, pgno, (void **)((void *)0), (u_int32_t *)((void *)0));
  return (tmp);
}
}
int __bam_bulk_duplicates(DBC *dbc , db_pgno_t pgno , u_int8_t *dbuf , int32_t *keyoff ,
                          int32_t **offpp , u_int8_t **dpp , u_int32_t *spacep , int no_dup ) 
{ DB *dbp___1 ;
  BKEYDATA *bk ;
  BOVERFLOW *bo ;
  BTREE_CURSOR *cp ;
  DBC *opd ;
  DBT key ;
  DBT data ;
  PAGE *pg ;
  db_indx_t indx ;
  db_indx_t *inp ;
  int32_t *offp ;
  u_int32_t pagesize ;
  u_int32_t size ;
  u_int32_t space ;
  u_int8_t *dp ;
  u_int8_t *np ;
  int first ;
  int need_pg ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___5 ;
  int32_t *tmp___6 ;
  int32_t *tmp___7 ;
  int32_t *tmp___8 ;
  int32_t *tmp___9 ;
  int32_t *tmp___10 ;
  int32_t *tmp___11 ;
  int32_t *tmp___12 ;

  {
  ret = 0;
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  opd = cp->opd;
  if ((unsigned int )opd == (unsigned int )((void *)0)) {
    ret = __db_c_newopd(dbc, pgno, (DBC *)((void *)0), & opd);
    if (ret != 0) {
      return (ret);
    }
    cp->opd = opd;
    ret = ((*(opd->c_am_get)))(opd, & key, & data, 9U, (db_pgno_t *)((void *)0));
    if (ret != 0) {
      goto close_opd;
    }
  }
  pagesize = (opd->dbp)->pgsize;
  cp = (BTREE_CURSOR *)opd->internal;
  space = (*spacep);
  offp = (*offpp);
  dp = (*dpp);
  np = dp;
  first = 1;
  indx = cp->indx;
  while (1) {
    ret = __bam_c_next(opd, 0, 0);
    if (ret != 0) {
      break;
    }
    pg = (PAGE *)cp->page;
    indx = cp->indx;
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    inp = (db_indx_t *)(((u_int8_t *)pg + 26) + tmp___0);
    need_pg = 1;
    while (1) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      if ((int )pg->type == 5) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      if ((int )((BKEYDATA *)((u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                       26) + tmp___2) +
                                                        ((int )indx + tmp___3)))))->type &
          128) {
        goto contin;
      }
      if (dbp___1->flags & 2048U) {
        tmp___5 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___5 = sizeof(PG_CHKSUM );
        } else {
          tmp___5 = 0U;
        }
      }
      bk = (BKEYDATA *)((u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                 26) + tmp___5) +
                                                  (int )indx)));
      space -= 2U * sizeof((*offp));
      if (first == 0) {
        if ((unsigned int )keyoff != (unsigned int )((void *)0)) {
          space -= 2U * sizeof((*offp));
        }
      }
      if (space > (*spacep)) {
        ret = 12;
        if (first == 1) {
          space = (unsigned int )(- ((int )space));
          space = (*spacep) + space;
          if (need_pg) {
            space += pagesize - (unsigned int )pg->hf_offset;
          }
        }
        break;
      }
      if (((int )bk->type & -129) == 3) {
        bo = (BOVERFLOW *)bk;
        size = bo->tlen;
        if (size > space) {
          ret = 12;
          space = (*spacep) + size;
          break;
        }
        if (first == 0) {
          if ((unsigned int )keyoff != (unsigned int )((void *)0)) {
            tmp___6 = offp;
            offp --;
            (*tmp___6) = (*(keyoff + 0));
            tmp___7 = offp;
            offp --;
            (*tmp___7) = (*(keyoff + -1));
          }
        }
        ret = __bam_bulk_overflow(dbc, bo->tlen, bo->pgno, np);
        if (ret != 0) {
          return (ret);
        }
        space -= size;
        tmp___8 = offp;
        offp --;
        (*tmp___8) = np - dbuf;
        np += size;
      } else {
        if (need_pg) {
          dp = np;
          size = pagesize - (unsigned int )pg->hf_offset;
          if (space < size) {
            ret = 12;
            space = (*spacep) + size;
            break;
          }
          memcpy((void * __restrict  )dp, (void const   * __restrict  )((u_int8_t *)pg +
                                                                        (int )pg->hf_offset),
                 size);
          need_pg = 0;
          space -= size;
          np += size;
        }
        if (first == 0) {
          if ((unsigned int )keyoff != (unsigned int )((void *)0)) {
            tmp___9 = offp;
            offp --;
            (*tmp___9) = (*(keyoff + 0));
            tmp___10 = offp;
            offp --;
            (*tmp___10) = (*(keyoff + -1));
          }
        }
        size = (unsigned int )bk->len;
        tmp___11 = offp;
        offp --;
        (*tmp___11) = (((int )(*(inp + (int )indx)) - (int )pg->hf_offset) + (dp -
                                                                              dbuf)) +
                      (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])));
      }
      tmp___12 = offp;
      offp --;
      (*tmp___12) = (int )size;
      first = 0;
      if (no_dup) {
        break;
      }
      contin: 
      indx = (unsigned short )((int )indx + 1);
      if ((int )opd->dbtype == 3) {
        cp->recno = cp->recno + 1U;
      }
      if (! ((int )indx < (int )pg->entries)) {
        break;
      }
    }
    if (no_dup) {
      break;
    }
    cp->indx = indx;
    if (! (ret == 0)) {
      break;
    }
  }
  (*spacep) = space;
  (*offpp) = offp;
  (*dpp) = np;
  if (ret == 12) {
    if ((int )opd->dbtype == 3) {
      cp->recno = cp->recno - 1U;
      if (cp->recno == 0U) {
        goto close_opd;
      }
    } else {
      if ((int )indx != 0) {
        cp->indx = (unsigned short )((int )cp->indx - 1);
      } else {
        t_ret = __bam_c_prev(opd);
        if (t_ret == -30990) {
          goto close_opd;
        }
        if (t_ret != 0) {
          ret = t_ret;
        }
      }
    }
  } else {
    if ((unsigned int )keyoff == (unsigned int )((void *)0)) {
      if (ret == -30990) {
        cp->indx = (unsigned short )((int )cp->indx - 1);
        if ((int )opd->dbtype == 3) {
          cp->recno = cp->recno - 1U;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((int )indx == 0) {
        goto close_opd;
      } else {
        if (ret == -30990) {
          close_opd: 
          if (ret == -30990) {
            ret = 0;
          }
          t_ret = __db_c_close(opd);
          if (t_ret != 0) {
            if (ret == 0) {
              ret = t_ret;
            }
          }
          ((BTREE_CURSOR *)dbc->internal)->opd = (DBC *)((void *)0);
        }
      }
    }
  }
  if (ret == -30990) {
    ret = 0;
  }
  return (ret);
}
}
static int __bam_getbothc(DBC *dbc , DBT *data ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  int cmp ;
  int exact ;
  int ret ;
  int (*tmp)(DB * , DBT const   * , DBT const   * ) ;
  int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& cp->page));
  if (ret != 0) {
    return (ret);
  }
  if (dbc->flags & 8U) {
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
      tmp = & __bam_defcmp;
    } else {
      tmp = dbp___1->dup_compare;
    }
    ret = __bam_cmp(dbp___1, (DBT const   *)data, (PAGE *)cp->page, (unsigned int )cp->indx,
                    tmp, & cmp);
    if (ret != 0) {
      return (ret);
    }
    if (cmp <= 0) {
      return (-30990);
    }
    ret = __memp_fput(mpf, cp->page, 0U);
    if (ret != 0) {
      return (ret);
    }
    cp->page = (void *)0;
    tmp___0 = __bam_c_search(dbc, 0U, (DBT const   *)data, 10U, & exact);
    return (tmp___0);
  }
  if ((int )cp->indx + 2 >= (int )((PAGE *)cp->page)->entries) {
    return (-30990);
  } else {
    if ((dbc->dbp)->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) + 26) +
                                  tmp___2) + (int )cp->indx)) == (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                                                                         26) +
                                                                                        tmp___4) +
                                                                          ((int )cp->indx +
                                                                           2))))) {
      return (-30990);
    }
  }
  cp->indx = (unsigned short )((int )cp->indx + 2);
  tmp___5 = __bam_getboth_finddatum(dbc, data, 10U);
  return (tmp___5);
}
}
static int __bam_getboth_finddatum(DBC *dbc , DBT *data , u_int32_t flags ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  db_indx_t base ;
  db_indx_t lim ;
  db_indx_t top ;
  int cmp ;
  int ret ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  cmp = 0;
  cmp = cmp;
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    while (1) {
      if ((dbc->dbp)->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      if (! ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                             26) +
                                                                                            tmp___0) +
                                                                              ((int )(dbc->internal)->indx +
                                                                               tmp___1)))))->type &
             128)) {
        ret = __bam_cmp(dbp___1, (DBT const   *)data, (PAGE *)cp->page, (unsigned int )((int )cp->indx +
                                                                                        1),
                        & __bam_defcmp, & cmp);
        if (ret != 0) {
          return (ret);
        }
      }
      if (cmp == 0) {
        return (0);
      }
      if ((int )cp->indx + 2 >= (int )((PAGE *)cp->page)->entries) {
        break;
      } else {
        if ((dbc->dbp)->flags & 2048U) {
          tmp___3 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___3 = sizeof(PG_CHKSUM );
          } else {
            tmp___3 = 0U;
          }
        }
        if ((dbc->dbp)->flags & 2048U) {
          tmp___5 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___5 = sizeof(PG_CHKSUM );
          } else {
            tmp___5 = 0U;
          }
        }
        if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                       26) + tmp___3) + (int )cp->indx)) == (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                                                                                    26) +
                                                                                                   tmp___5) +
                                                                                     ((int )cp->indx +
                                                                                      2))))) {
          break;
        }
      }
      cp->indx = (unsigned short )((int )cp->indx + 2);
    }
    return (-30990);
  }
  top = cp->indx;
  base = top;
  while ((int )top < (int )((PAGE *)cp->page)->entries) {
    if ((dbc->dbp)->flags & 2048U) {
      tmp___7 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___7 = sizeof(PG_CHKSUM );
      } else {
        tmp___7 = 0U;
      }
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___9 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___9 = sizeof(PG_CHKSUM );
      } else {
        tmp___9 = 0U;
      }
    }
    if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) + 26) +
                                  tmp___7) + (int )cp->indx)) == (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                                                                         26) +
                                                                                        tmp___9) +
                                                                          (int )top)))) {
      break;
    }
    top = (unsigned short )((int )top + 2);
  }
  if ((int )base == (int )top - 2) {
    ret = __bam_cmp(dbp___1, (DBT const   *)data, (PAGE *)cp->page, (unsigned int )((int )cp->indx +
                                                                                    1),
                    dbp___1->dup_compare, & cmp);
    if (ret != 0) {
      return (ret);
    }
    if (cmp == 0) {
      tmp___10 = 0;
    } else {
      if (cmp < 0) {
        if (flags == 12U) {
          tmp___10 = 0;
        } else {
          tmp___10 = -30990;
        }
      } else {
        tmp___10 = -30990;
      }
    }
    return (tmp___10);
  }
  lim = (unsigned short )(((int )top - (int )base) / 2);
  while ((int )lim != 0) {
    cp->indx = (unsigned short )((int )base + ((int )lim >> 1) * 2);
    ret = __bam_cmp(dbp___1, (DBT const   *)data, (PAGE *)cp->page, (unsigned int )((int )cp->indx +
                                                                                    1),
                    dbp___1->dup_compare, & cmp);
    if (ret != 0) {
      return (ret);
    }
    if (cmp == 0) {
      if ((dbc->dbp)->flags & 2048U) {
        tmp___12 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___12 = sizeof(PG_CHKSUM );
        } else {
          tmp___12 = 0U;
        }
      }
      if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
        tmp___13 = 1;
      } else {
        tmp___13 = 0;
      }
      if (! ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                             26) +
                                                                                            tmp___12) +
                                                                              ((int )(dbc->internal)->indx +
                                                                               tmp___13)))))->type &
             128)) {
        return (0);
      }
      break;
    }
    if (cmp > 0) {
      base = (unsigned short )((int )cp->indx + 2);
      lim = (unsigned short )((int )lim - 1);
    }
    lim = (unsigned short )((int )lim >> 1);
  }
  if (flags == 10U) {
    return (-30990);
  }
  cp->indx = base;
  while (1) {
    if ((int )cp->indx < (int )top) {
      if ((dbc->dbp)->flags & 2048U) {
        tmp___15 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___15 = sizeof(PG_CHKSUM );
        } else {
          tmp___15 = 0U;
        }
      }
      if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
        tmp___16 = 1;
      } else {
        tmp___16 = 0;
      }
      if (! ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                             26) +
                                                                                            tmp___15) +
                                                                              ((int )(dbc->internal)->indx +
                                                                               tmp___16)))))->type &
             128)) {
        break;
      }
    } else {
      break;
    }
    cp->indx = (unsigned short )((int )cp->indx + 2);
  }
  if ((int )cp->indx < (int )top) {
    tmp___17 = 0;
  } else {
    tmp___17 = -30990;
  }
  return (tmp___17);
}
}
static int __bam_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT dbt ;
  DB_MPOOLFILE *mpf ;
  db_pgno_t root_pgno ;
  u_int32_t iiop ;
  int cmp ;
  int exact ;
  int own ;
  int ret ;
  int stack ;
  void *arg ;
  BTREE_CURSOR *__cp ;
  int tmp ;
  db_pgno_t tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  db_pgno_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___15 ;
  unsigned int tmp___17 ;
  BTREE_CURSOR *__cp___0 ;
  DB_MPOOLFILE *__mpf ;
  int __t_ret ;
  EPG *tmp___19 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  root_pgno = cp->root;
  split: 
  stack = 0;
  ret = stack;
  switch ((int )flags) {
  case 1: ;
  case 3: ;
  case 7: 
  iiop = flags;
  own = 1;
  if (flags == 7U) {
    if (cp->flags & 2U) {
      if (cp->flags & 1U) {
        ret = __bam_c_getstack(dbc);
        if (ret != 0) {
          goto err;
        }
        cp->page = (void *)(cp->csp)->page;
        cp->lock = (cp->csp)->lock;
        cp->lock_mode = (cp->csp)->lock_mode;
        stack = 1;
        break;
      }
    }
  }
  __cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        if ((int )__cp->lock_mode != 2) {
          if (__cp->lock.off != 0U) {
            tmp = 2;
          } else {
            tmp = 0;
          }
          ret = __db_lget(dbc, tmp, __cp->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                          0U, & __cp->lock);
          if (ret == 0) {
            __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
          }
        }
      }
    }
  }
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& cp->page));
  if (ret != 0) {
    goto err;
  }
  break;
  case 15: ;
  case 16: ;
  case 21: 
  own = 0;
  if (dbc->flags & 8U) {
    if (cp->flags & 2U) {
      tmp___0 = cp->root;
    } else {
      tmp___0 = root_pgno;
    }
    ret = __bam_c_search(dbc, tmp___0, (DBT const   *)data, flags, & exact);
    if (ret != 0) {
      goto err;
    }
    stack = 1;
    if (exact) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      if ((int )((PAGE *)cp->page)->type == 5) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      if ((int )((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                             26) +
                                                                            tmp___2) +
                                                              ((int )cp->indx + tmp___3)))))->type &
          128) {
        iiop = 7U;
        break;
      }
      ret = __db_duperr(dbp___1, flags);
      goto err;
    }
    iiop = 3U;
    break;
  }
  if (flags == 15U) {
    tmp___4 = 15;
  } else {
    if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
      tmp___4 = 15;
    } else {
      tmp___4 = 16;
    }
  }
  if (cp->flags & 2U) {
    tmp___5 = cp->root;
  } else {
    tmp___5 = root_pgno;
  }
  ret = __bam_c_search(dbc, tmp___5, (DBT const   *)key, (unsigned int )tmp___4, & exact);
  if (ret != 0) {
    goto err;
  }
  stack = 1;
  if (! exact) {
    iiop = 15U;
    break;
  }
  if (! (dbp___1->flags & 512U)) {
    iiop = 7U;
    break;
  }
  if ((unsigned int )pgnop != (unsigned int )((void *)0)) {
    tmp___6 = __bam_isopd(dbc, pgnop);
    if (tmp___6) {
      goto err;
    }
  }
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    if (flags == 15U) {
      iiop = 3U;
    } else {
      while (1) {
        if ((int )cp->indx + 2 >= (int )((PAGE *)cp->page)->entries) {
          iiop = 1U;
          break;
        } else {
          if ((dbc->dbp)->flags & 2048U) {
            tmp___8 = sizeof(PG_CRYPTO );
          } else {
            if ((dbc->dbp)->flags & 1U) {
              tmp___8 = sizeof(PG_CHKSUM );
            } else {
              tmp___8 = 0U;
            }
          }
          if ((dbc->dbp)->flags & 2048U) {
            tmp___10 = sizeof(PG_CRYPTO );
          } else {
            if ((dbc->dbp)->flags & 1U) {
              tmp___10 = sizeof(PG_CHKSUM );
            } else {
              tmp___10 = 0U;
            }
          }
          if (! ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                         26) + tmp___8) + (int )cp->indx)) == (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)(dbc->internal)->page) +
                                                                                                      26) +
                                                                                                     tmp___10) +
                                                                                       ((int )cp->indx +
                                                                                        2))))) {
            iiop = 1U;
            break;
          }
        }
        cp->indx = (unsigned short )((int )cp->indx + 2);
      }
    }
    break;
  }
  while (1) {
    ret = __bam_cmp(dbp___1, (DBT const   *)data, (PAGE *)cp->page, (unsigned int )((int )cp->indx +
                                                                                    1),
                    dbp___1->dup_compare, & cmp);
    if (ret != 0) {
      goto err;
    }
    if (cmp < 0) {
      iiop = 3U;
      break;
    }
    if (cmp == 0) {
      if (dbp___1->flags & 2048U) {
        tmp___12 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___12 = sizeof(PG_CHKSUM );
        } else {
          tmp___12 = 0U;
        }
      }
      if ((int )((PAGE *)cp->page)->type == 5) {
        tmp___13 = 1;
      } else {
        tmp___13 = 0;
      }
      if ((int )((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                             26) +
                                                                            tmp___12) +
                                                              ((int )cp->indx + tmp___13)))))->type &
          128) {
        iiop = 7U;
        break;
      }
      ret = __db_duperr(dbp___1, flags);
      goto err;
    }
    if ((int )cp->indx + 2 >= (int )((PAGE *)cp->page)->entries) {
      iiop = 1U;
      break;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___15 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___15 = sizeof(PG_CHKSUM );
        } else {
          tmp___15 = 0U;
        }
      }
      if (dbp___1->flags & 2048U) {
        tmp___17 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___17 = sizeof(PG_CHKSUM );
        } else {
          tmp___17 = 0U;
        }
      }
      if ((int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)cp->page) + 26) + tmp___15) +
                   (int )cp->indx)) != (int )(*((db_indx_t *)(((u_int8_t *)((PAGE *)cp->page) +
                                                               26) + tmp___17) + ((int )cp->indx +
                                                                                  2)))) {
        iiop = 1U;
        break;
      }
    }
    cp->indx = (unsigned short )((int )cp->indx + 2);
  }
  break;
  default: 
  ret = __db_unknown_flag(dbp___1->dbenv, (char *)"__bam_c_put", flags);
  goto err;
  }
  ret = __bam_iitem(dbc, key, data, iiop, 0U);
  switch (ret) {
  case 0: ;
  break;
  case -30896: ;
  if (flags == 1U) {
    goto _L;
  } else {
    if (flags == 3U) {
      goto _L;
    } else {
      if (flags == 7U) {
        _L: 
        memset((void *)(& dbt), 0, sizeof(DBT ));
        ret = __db_ret(dbp___1, (PAGE *)cp->page, 0U, & dbt, & dbc->my_rkey.data,
                       & dbc->my_rkey.ulen);
        if (ret != 0) {
          goto err;
        }
        arg = (void *)(& dbt);
      } else {
        if (dbc->flags & 8U) {
          arg = (void *)data;
        } else {
          arg = (void *)key;
        }
      }
    }
  }
  if (stack) {
    ret = __bam_stkrel(dbc, 3U);
  } else {
    __cp___0 = (BTREE_CURSOR *)dbc->internal;
    __mpf = (dbc->dbp)->mpf;
    if ((unsigned int )__cp___0->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(__mpf, __cp___0->page, 0U);
      __cp___0->page = (void *)0;
    } else {
      ret = 0;
    }
    if (__cp___0->lock.off != 0U) {
      __t_ret = __db_lput(dbc, & __cp___0->lock);
    } else {
      __t_ret = 0;
    }
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
    if (ret == 0) {
      if (! (__cp___0->lock.off != 0U)) {
        __cp___0->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
      }
    }
  }
  if (ret != 0) {
    goto err;
  }
  if (own == 0) {
    cp->pgno = 0U;
    cp->indx = (unsigned short)0;
  }
  ret = __bam_split(dbc, arg, & root_pgno);
  if (ret != 0) {
    return (ret);
  }
  goto split;
  default: ;
  goto err;
  }
  err: 
  if (stack) {
    if ((unsigned int )cp->csp == (unsigned int )cp->sp) {
      tmp___19 = (EPG *)((void *)0);
    } else {
      cp->csp = cp->csp - 1;
      tmp___19 = cp->csp;
    }
    if ((unsigned int )tmp___19 != (unsigned int )((void *)0)) {
      __bam_stkrel(dbc, 0U);
    }
  }
  cp->flags = cp->flags & 4294967294U;
  if ((unsigned int )cp->opd != (unsigned int )((void *)0)) {
    cp = (BTREE_CURSOR *)(cp->opd)->internal;
    cp->flags = cp->flags & 4294967294U;
  }
  return (ret);
}
}
int __bam_c_rget(DBC *dbc , DBT *data ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT dbt ;
  DB_MPOOLFILE *mpf ;
  db_recno_t recno ;
  int exact ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& cp->page));
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& dbt), 0, sizeof(DBT ));
  ret = __db_ret(dbp___1, (PAGE *)cp->page, (unsigned int )cp->indx, & dbt, & dbc->my_rkey.data,
                 & dbc->my_rkey.ulen);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fput(mpf, cp->page, 0U);
  cp->page = (void *)0;
  if (ret != 0) {
    return (ret);
  }
  if (dbc->flags & 32U) {
    tmp = 386;
  } else {
    tmp = 385;
  }
  ret = __bam_search(dbc, 0U, (DBT const   *)(& dbt), (unsigned int )tmp, 1, & recno,
                     & exact);
  if (ret != 0) {
    goto err;
  }
  ret = __db_retcopy(dbp___1->dbenv, data, (void *)(& recno), sizeof(recno), & (dbc->rdata)->data,
                     & (dbc->rdata)->ulen);
  err: 
  t_ret = __bam_stkrel(dbc, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __bam_c_writelock(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  int ret ;
  BTREE_CURSOR *__cp ;
  int tmp ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  if ((int )cp->lock_mode == 2) {
    return (0);
  }
  __cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        if ((int )__cp->lock_mode != 2) {
          if (__cp->lock.off != 0U) {
            tmp = 2;
          } else {
            tmp = 0;
          }
          ret = __db_lget(dbc, tmp, __cp->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                          0U, & __cp->lock);
          if (ret == 0) {
            __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
          }
        }
      }
    }
  }
  return (ret);
}
}
static int __bam_c_first(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  db_pgno_t pgno ;
  int ret ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf ;
  unsigned int tmp___0 ;
  BTREE_CURSOR *__cp___0 ;
  int tmp___1 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  pgno = cp->root;
  while (1) {
    __cp = (BTREE_CURSOR *)dbc->internal;
    if (pgno != __cp->pgno) {
      __cp->pgno = 0U;
    }
    __mpf = (dbc->dbp)->mpf;
    if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(__mpf, __cp->page, 0U);
      __cp->page = (void *)0;
    } else {
      ret = 0;
    }
    if (ret == 0) {
      if (! (dbc->flags & 8U)) {
        if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
            ret = __db_lget(dbc, 3, pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U,
                            & __cp->lock);
          }
        }
      }
    }
    if (ret == 0) {
      ret = __memp_fget(__mpf, & pgno, 0U, (void *)(& __cp->page));
    }
    if (ret == 0) {
      __cp->pgno = pgno;
      __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
    }
    if (ret != 0) {
      return (ret);
    }
    if ((int )((PAGE *)cp->page)->type == 5) {
      break;
    } else {
      if ((int )((PAGE *)cp->page)->type == 6) {
        break;
      } else {
        if ((int )((PAGE *)cp->page)->type == 12) {
          break;
        }
      }
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    pgno = ((BINTERNAL *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                         26) + tmp___0) +
                                                          0))))->pgno;
  }
  if (dbc->flags & 32U) {
    __cp___0 = (BTREE_CURSOR *)dbc->internal;
    ret = 0;
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          if ((int )__cp___0->lock_mode != 2) {
            if (__cp___0->lock.off != 0U) {
              tmp___1 = 2;
            } else {
              tmp___1 = 0;
            }
            ret = __db_lget(dbc, tmp___1, __cp___0->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                            0U, & __cp___0->lock);
            if (ret == 0) {
              __cp___0->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
            }
          }
        }
      }
    }
    if (ret != 0) {
      return (ret);
    }
  }
  cp->indx = (unsigned short)0;
  if ((int )((PAGE *)cp->page)->entries == 0) {
    goto _L;
  } else {
    if ((dbc->dbp)->flags & 2048U) {
      tmp___3 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___3 = sizeof(PG_CHKSUM );
      } else {
        tmp___3 = 0U;
      }
    }
    if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
    if ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                        26) +
                                                                                       tmp___3) +
                                                                         ((int )(dbc->internal)->indx +
                                                                          tmp___4)))))->type &
        128) {
      _L: 
      ret = __bam_c_next(dbc, 0, 0);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  return (0);
}
}
static int __bam_c_last(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  db_pgno_t pgno ;
  int ret ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf ;
  unsigned int tmp___0 ;
  BTREE_CURSOR *__cp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  pgno = cp->root;
  while (1) {
    __cp = (BTREE_CURSOR *)dbc->internal;
    if (pgno != __cp->pgno) {
      __cp->pgno = 0U;
    }
    __mpf = (dbc->dbp)->mpf;
    if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(__mpf, __cp->page, 0U);
      __cp->page = (void *)0;
    } else {
      ret = 0;
    }
    if (ret == 0) {
      if (! (dbc->flags & 8U)) {
        if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
            ret = __db_lget(dbc, 3, pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U,
                            & __cp->lock);
          }
        }
      }
    }
    if (ret == 0) {
      ret = __memp_fget(__mpf, & pgno, 0U, (void *)(& __cp->page));
    }
    if (ret == 0) {
      __cp->pgno = pgno;
      __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
    }
    if (ret != 0) {
      return (ret);
    }
    if ((int )((PAGE *)cp->page)->type == 5) {
      break;
    } else {
      if ((int )((PAGE *)cp->page)->type == 6) {
        break;
      } else {
        if ((int )((PAGE *)cp->page)->type == 12) {
          break;
        }
      }
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    pgno = ((BINTERNAL *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                         26) + tmp___0) +
                                                          ((int )((PAGE *)cp->page)->entries -
                                                           1)))))->pgno;
  }
  if (dbc->flags & 32U) {
    __cp___0 = (BTREE_CURSOR *)dbc->internal;
    ret = 0;
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          if ((int )__cp___0->lock_mode != 2) {
            if (__cp___0->lock.off != 0U) {
              tmp___1 = 2;
            } else {
              tmp___1 = 0;
            }
            ret = __db_lget(dbc, tmp___1, __cp___0->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                            0U, & __cp___0->lock);
            if (ret == 0) {
              __cp___0->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
            }
          }
        }
      }
    }
    if (ret != 0) {
      return (ret);
    }
  }
  if ((int )((PAGE *)cp->page)->entries == 0) {
    cp->indx = (unsigned short)0;
  } else {
    if ((int )((PAGE *)cp->page)->type == 5) {
      tmp___3 = 2;
    } else {
      tmp___3 = 1;
    }
    cp->indx = (unsigned short )((int )((PAGE *)cp->page)->entries - tmp___3);
  }
  if ((int )((PAGE *)cp->page)->entries == 0) {
    goto _L;
  } else {
    if ((dbc->dbp)->flags & 2048U) {
      tmp___5 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___5 = sizeof(PG_CHKSUM );
      } else {
        tmp___5 = 0U;
      }
    }
    if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
    if ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                        26) +
                                                                                       tmp___5) +
                                                                         ((int )(dbc->internal)->indx +
                                                                          tmp___6)))))->type &
        128) {
      _L: 
      ret = __bam_c_prev(dbc);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  return (0);
}
}
static int __bam_c_next(DBC *dbc , int initial_move , int deleted_okay ) 
{ BTREE_CURSOR *cp ;
  db_indx_t adjust ;
  db_lockmode_t lock_mode ;
  db_pgno_t pgno ;
  int ret ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf ;
  BTREE_CURSOR *__cp___0 ;
  DB_MPOOLFILE *__mpf___0 ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  if (dbc->flags & 8U) {
    adjust = (unsigned short)1;
    lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
  } else {
    if ((int )dbc->dbtype == 1) {
      adjust = (unsigned short)2;
    } else {
      adjust = (unsigned short)1;
    }
    if (dbc->flags & 32U) {
      lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
    } else {
      lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
    }
  }
  if ((unsigned int )cp->page == (unsigned int )((void *)0)) {
    __cp = (BTREE_CURSOR *)dbc->internal;
    if (cp->pgno != __cp->pgno) {
      __cp->pgno = 0U;
    }
    __mpf = (dbc->dbp)->mpf;
    if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(__mpf, __cp->page, 0U);
      __cp->page = (void *)0;
    } else {
      ret = 0;
    }
    if (ret == 0) {
      if (! (dbc->flags & 8U)) {
        if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
            ret = __db_lget(dbc, 2, cp->pgno, lock_mode, 0U, & __cp->lock);
          }
        }
      }
    }
    if (ret == 0) {
      ret = __memp_fget(__mpf, & cp->pgno, 0U, (void *)(& __cp->page));
    }
    if (ret == 0) {
      __cp->pgno = cp->pgno;
      __cp->lock_mode = lock_mode;
    }
    if (ret != 0) {
      return (ret);
    }
  }
  if (initial_move) {
    cp->indx = (unsigned short )((int )cp->indx + (int )adjust);
  }
  while (1) {
    if ((int )cp->indx >= (int )((PAGE *)cp->page)->entries) {
      pgno = ((PAGE *)cp->page)->next_pgno;
      if (pgno == 0U) {
        return (-30990);
      }
      __cp___0 = (BTREE_CURSOR *)dbc->internal;
      if (pgno != __cp___0->pgno) {
        __cp___0->pgno = 0U;
      }
      __mpf___0 = (dbc->dbp)->mpf;
      if ((unsigned int )__cp___0->page != (unsigned int )((void *)0)) {
        ret = __memp_fput(__mpf___0, __cp___0->page, 0U);
        __cp___0->page = (void *)0;
      } else {
        ret = 0;
      }
      if (ret == 0) {
        if (! (dbc->flags & 8U)) {
          if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
              ret = __db_lget(dbc, 2, pgno, lock_mode, 0U, & __cp___0->lock);
            }
          }
        }
      }
      if (ret == 0) {
        ret = __memp_fget(__mpf___0, & pgno, 0U, (void *)(& __cp___0->page));
      }
      if (ret == 0) {
        __cp___0->pgno = pgno;
        __cp___0->lock_mode = lock_mode;
      }
      if (ret != 0) {
        return (ret);
      }
      cp->indx = (unsigned short)0;
      goto __Cont;
    }
    if (! deleted_okay) {
      if ((dbc->dbp)->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if ((dbc->dbp)->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      if ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                          26) +
                                                                                         tmp___0) +
                                                                           ((int )(dbc->internal)->indx +
                                                                            tmp___1)))))->type &
          128) {
        cp->indx = (unsigned short )((int )cp->indx + (int )adjust);
        goto __Cont;
      }
    }
    break;
    __Cont: ;
  }
  return (0);
}
}
static int __bam_c_prev(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  db_indx_t adjust ;
  db_lockmode_t lock_mode ;
  db_pgno_t pgno ;
  int ret ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf ;
  BTREE_CURSOR *__cp___0 ;
  DB_MPOOLFILE *__mpf___0 ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  if (dbc->flags & 8U) {
    adjust = (unsigned short)1;
    lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
  } else {
    if ((int )dbc->dbtype == 1) {
      adjust = (unsigned short)2;
    } else {
      adjust = (unsigned short)1;
    }
    if (dbc->flags & 32U) {
      lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
    } else {
      lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
    }
  }
  if ((unsigned int )cp->page == (unsigned int )((void *)0)) {
    __cp = (BTREE_CURSOR *)dbc->internal;
    if (cp->pgno != __cp->pgno) {
      __cp->pgno = 0U;
    }
    __mpf = (dbc->dbp)->mpf;
    if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(__mpf, __cp->page, 0U);
      __cp->page = (void *)0;
    } else {
      ret = 0;
    }
    if (ret == 0) {
      if (! (dbc->flags & 8U)) {
        if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
            ret = __db_lget(dbc, 2, cp->pgno, lock_mode, 0U, & __cp->lock);
          }
        }
      }
    }
    if (ret == 0) {
      ret = __memp_fget(__mpf, & cp->pgno, 0U, (void *)(& __cp->page));
    }
    if (ret == 0) {
      __cp->pgno = cp->pgno;
      __cp->lock_mode = lock_mode;
    }
    if (ret != 0) {
      return (ret);
    }
  }
  while (1) {
    if ((int )cp->indx == 0) {
      pgno = ((PAGE *)cp->page)->prev_pgno;
      if (pgno == 0U) {
        return (-30990);
      }
      __cp___0 = (BTREE_CURSOR *)dbc->internal;
      if (pgno != __cp___0->pgno) {
        __cp___0->pgno = 0U;
      }
      __mpf___0 = (dbc->dbp)->mpf;
      if ((unsigned int )__cp___0->page != (unsigned int )((void *)0)) {
        ret = __memp_fput(__mpf___0, __cp___0->page, 0U);
        __cp___0->page = (void *)0;
      } else {
        ret = 0;
      }
      if (ret == 0) {
        if (! (dbc->flags & 8U)) {
          if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
              ret = __db_lget(dbc, 2, pgno, lock_mode, 0U, & __cp___0->lock);
            }
          }
        }
      }
      if (ret == 0) {
        ret = __memp_fget(__mpf___0, & pgno, 0U, (void *)(& __cp___0->page));
      }
      if (ret == 0) {
        __cp___0->pgno = pgno;
        __cp___0->lock_mode = lock_mode;
      }
      if (ret != 0) {
        return (ret);
      }
      cp->indx = ((PAGE *)cp->page)->entries;
      if ((int )cp->indx == 0) {
        goto __Cont;
      }
    }
    cp->indx = (unsigned short )((int )cp->indx - (int )adjust);
    if ((dbc->dbp)->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    if ((int )((PAGE *)(dbc->internal)->page)->type == 5) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if ((int )((BKEYDATA *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                        26) +
                                                                                       tmp___0) +
                                                                         ((int )(dbc->internal)->indx +
                                                                          tmp___1)))))->type &
        128) {
      goto __Cont;
    }
    break;
    __Cont: ;
  }
  return (0);
}
}
static int __bam_c_search(DBC *dbc , db_pgno_t root_pgno , DBT const   *key , u_int32_t flags ,
                          int *exactp ) 
{ BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  PAGE *h ;
  db_indx_t indx ;
  db_indx_t *inp ;
  db_pgno_t bt_lpgno ;
  db_recno_t recno ;
  u_int32_t sflags ;
  int cmp ;
  int ret ;
  BTREE_CURSOR *__cp ;
  DB_MPOOLFILE *__mpf ;
  int __t_ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  BTREE_CURSOR *__cp___0 ;
  DB_MPOOLFILE *__mpf___0 ;
  unsigned int tmp___4 ;
  BTREE_CURSOR *__cp___1 ;
  DB_MPOOLFILE *__mpf___1 ;
  int __t_ret___0 ;
  int tmp___7 ;

  {
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  t = (BTREE *)dbp___1->bt_internal;
  ret = 0;
  __cp = (BTREE_CURSOR *)dbc->internal;
  __mpf = (dbc->dbp)->mpf;
  if ((unsigned int )__cp->page != (unsigned int )((void *)0)) {
    ret = __memp_fput(__mpf, __cp->page, 0U);
    __cp->page = (void *)0;
  } else {
    ret = 0;
  }
  if (__cp->lock.off != 0U) {
    __t_ret = __db_lput(dbc, & __cp->lock);
  } else {
    __t_ret = 0;
  }
  if (__t_ret != 0) {
    if (ret == 0) {
      ret = __t_ret;
    }
  }
  if (ret == 0) {
    if (! (__cp->lock.off != 0U)) {
      __cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
    }
  }
  if (ret != 0) {
    return (ret);
  }
  switch ((int )flags) {
  case 31: 
  ret = __ram_getno(dbc, key, & recno, 0);
  if (ret != 0) {
    return (ret);
  }
  if (dbc->flags & 32U) {
    tmp___0 = 386;
  } else {
    tmp___0 = 385;
  }
  sflags = (unsigned int )(tmp___0 | 1024);
  ret = __bam_rsearch(dbc, & recno, sflags, 1, exactp);
  if (ret != 0) {
    return (ret);
  }
  break;
  case 28: ;
  case 10: ;
  if (dbc->flags & 32U) {
    tmp___1 = 386;
  } else {
    tmp___1 = 385;
  }
  sflags = (unsigned int )(tmp___1 | 1024);
  goto search;
  case 12: ;
  if (dbc->flags & 32U) {
    sflags = 386U;
  } else {
    sflags = 385U;
  }
  goto search;
  case 30: ;
  if (dbc->flags & 32U) {
    tmp___2 = 2;
  } else {
    tmp___2 = 1;
  }
  sflags = (unsigned int )(tmp___2 | 256);
  goto search;
  case 15: 
  sflags = 12546U;
  goto fast_search;
  case 16: ;
  case 21: 
  sflags = 12802U;
  fast_search: 
  if (cp->flags & 2U) {
    goto search;
  }
  bt_lpgno = t->bt_lpgno;
  if (bt_lpgno == 0U) {
    goto search;
  }
  h = (PAGE *)((void *)0);
  __cp___0 = (BTREE_CURSOR *)dbc->internal;
  if (bt_lpgno != __cp___0->pgno) {
    __cp___0->pgno = 0U;
  }
  __mpf___0 = (dbc->dbp)->mpf;
  if ((unsigned int )__cp___0->page != (unsigned int )((void *)0)) {
    ret = __memp_fput(__mpf___0, __cp___0->page, 0U);
    __cp___0->page = (void *)0;
  } else {
    ret = 0;
  }
  if (ret == 0) {
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          ret = __db_lget(dbc, 2, bt_lpgno, (enum __anonenum_db_lockmode_t_50 )2,
                          0U, & __cp___0->lock);
        }
      }
    }
  }
  if (ret == 0) {
    ret = __memp_fget(__mpf___0, & bt_lpgno, 0U, (void *)(& __cp___0->page));
  }
  if (ret == 0) {
    __cp___0->pgno = bt_lpgno;
    __cp___0->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  }
  if (ret != 0) {
    goto fast_miss;
  }
  h = (PAGE *)cp->page;
  if (dbp___1->flags & 2048U) {
    tmp___4 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___4 = sizeof(PG_CHKSUM );
    } else {
      tmp___4 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___4);
  if ((int )h->type != 5) {
    goto fast_miss;
  } else {
    if ((int )h->entries == 0) {
      goto fast_miss;
    }
  }
  if (h->next_pgno == 0U) {
    indx = (unsigned short )((int )h->entries - 2);
    ret = __bam_cmp(dbp___1, key, h, (unsigned int )indx, t->bt_compare, & cmp);
    if (ret != 0) {
      return (ret);
    }
    if (cmp < 0) {
      goto try_begin;
    }
    if (cmp > 0) {
      indx = (unsigned short )((int )indx + 2);
      goto fast_hit;
    }
    if (flags == 16U) {
      goto fast_hit;
    }
    while (1) {
      if ((int )indx > 0) {
        if (! ((int )(*(inp + ((int )indx - 2))) == (int )(*(inp + (int )indx)))) {
          break;
        }
      } else {
        break;
      }
      indx = (unsigned short )((int )indx - 2);
    }
    goto fast_hit;
  }
  try_begin: 
  if (h->prev_pgno == 0U) {
    indx = (unsigned short)0;
    ret = __bam_cmp(dbp___1, key, h, (unsigned int )indx, t->bt_compare, & cmp);
    if (ret != 0) {
      return (ret);
    }
    if (cmp > 0) {
      goto fast_miss;
    }
    if (cmp < 0) {
      goto fast_hit;
    }
    if (flags == 15U) {
      goto fast_hit;
    }
    while (1) {
      if ((int )indx < (int )((unsigned short )((int )h->entries - 2))) {
        if (! ((int )(*(inp + (int )indx)) == (int )(*(inp + ((int )indx + 2))))) {
          break;
        }
      } else {
        break;
      }
      indx = (unsigned short )((int )indx + 2);
    }
    goto fast_hit;
  }
  goto fast_miss;
  fast_hit: 
  (*exactp) = cmp == 0;
  while (1) {
    cp->csp = cp->sp;
    (cp->csp)->page = (PAGE *)((void *)0);
    (cp->csp)->lock.off = 0U;
    break;
  }
  while (1) {
    if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
      ret = __bam_stkgrow(dbp___1->dbenv, cp);
    } else {
      ret = 0;
    }
    if (ret == 0) {
      (cp->csp)->page = h;
      (cp->csp)->indx = indx;
      (cp->csp)->entries = h->entries;
      (cp->csp)->lock = cp->lock;
      (cp->csp)->lock_mode = cp->lock_mode;
    }
    break;
  }
  if (ret != 0) {
    return (ret);
  }
  break;
  fast_miss: 
  __cp___1 = (BTREE_CURSOR *)dbc->internal;
  __mpf___1 = (dbc->dbp)->mpf;
  if ((unsigned int )__cp___1->page != (unsigned int )((void *)0)) {
    ret = __memp_fput(__mpf___1, __cp___1->page, 0U);
    __cp___1->page = (void *)0;
  } else {
    ret = 0;
  }
  if (__cp___1->lock.off != 0U) {
    __t_ret___0 = __db_lput(dbc, & __cp___1->lock);
  } else {
    __t_ret___0 = 0;
  }
  if (__t_ret___0 != 0) {
    if (ret == 0) {
      ret = __t_ret___0;
    }
  }
  if (ret == 0) {
    if (! (__cp___1->lock.off != 0U)) {
      __cp___1->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
    }
  }
  cp->pgno = 0U;
  if (cp->lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & cp->lock);
  }
  if (ret != 0) {
    return (ret);
  }
  search: 
  ret = __bam_search(dbc, root_pgno, key, sflags, 1, (db_recno_t *)((void *)0), exactp);
  if (ret != 0) {
    return (ret);
  }
  break;
  default: 
  tmp___7 = __db_unknown_flag(dbp___1->dbenv, (char *)"__bam_c_search", flags);
  return (tmp___7);
  }
  cp->page = (void *)(cp->csp)->page;
  cp->pgno = ((cp->csp)->page)->pgno;
  cp->indx = (cp->csp)->indx;
  cp->lock = (cp->csp)->lock;
  cp->lock_mode = (cp->csp)->lock_mode;
  if ((int )((PAGE *)cp->page)->type == 5) {
    if (flags == 15U) {
      goto _L___0;
    } else {
      if (flags == 16U) {
        _L___0: 
        if (((PAGE *)cp->page)->next_pgno == 0U) {
          if ((int )cp->indx >= (int )((PAGE *)cp->page)->entries - 2) {
            t->bt_lpgno = cp->pgno;
          } else {
            goto _L;
          }
        } else {
          _L: 
          if (((PAGE *)cp->page)->prev_pgno == 0U) {
            if ((int )cp->indx == 0) {
              t->bt_lpgno = cp->pgno;
            } else {
              t->bt_lpgno = 0U;
            }
          } else {
            t->bt_lpgno = 0U;
          }
        }
      }
    }
  }
  return (0);
}
}
static int __bam_c_physdel(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT key ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t pgno ;
  int delete_page ;
  int empty_page ;
  int exact ;
  int level ;
  int ret ;
  int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  dbp___1 = dbc->dbp;
  memset((void *)(& key), 0, sizeof(DBT ));
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  empty_page = ret;
  delete_page = empty_page;
  if ((int )((PAGE *)cp->page)->type == 5) {
    tmp = 2;
  } else {
    tmp = 1;
  }
  empty_page = (int )((PAGE *)cp->page)->entries == tmp;
  delete_page = empty_page;
  if (delete_page) {
    if (! (dbc->flags & 8U)) {
      if (dbp___1->flags & 16777216U) {
        delete_page = 0;
      }
    }
  }
  if (delete_page) {
    if (cp->pgno == cp->root) {
      delete_page = 0;
    }
  }
  if (delete_page) {
    ret = __db_ret(dbp___1, (PAGE *)cp->page, 0U, & key, & dbc->my_rkey.data, & dbc->my_rkey.ulen);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((int )((PAGE *)cp->page)->type == 5) {
    ret = __bam_ditem(dbc, (PAGE *)cp->page, (unsigned int )cp->indx);
    if (ret != 0) {
      return (ret);
    }
    if (! empty_page) {
      ret = __bam_ca_di(dbc, ((PAGE *)cp->page)->pgno, (unsigned int )cp->indx, -1);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  ret = __bam_ditem(dbc, (PAGE *)cp->page, (unsigned int )cp->indx);
  if (ret != 0) {
    return (ret);
  }
  if (! empty_page) {
    ret = __bam_ca_di(dbc, ((PAGE *)cp->page)->pgno, (unsigned int )cp->indx, -1);
    if (ret != 0) {
      return (ret);
    }
  }
  if (! delete_page) {
    return (0);
  }
  level = 1;
  while (1) {
    ret = __bam_search(dbc, 0U, (DBT const   *)(& key), 10754U, level, (db_recno_t *)((void *)0),
                       & exact);
    if (ret != 0) {
      return (ret);
    }
    h = (cp->csp + -1)->page;
    if (h->pgno == cp->root) {
      break;
    } else {
      if ((int )h->entries != 1) {
        break;
      }
    }
    __bam_stkrel(dbc, 2U);
    level ++;
  }
  cp->csp = cp->csp + 1;
  h = (cp->csp + -1)->page;
  while (1) {
    if ((int )h->type == 5) {
      goto _L;
    } else {
      if ((int )h->type == 6) {
        goto _L;
      } else {
        if ((int )h->type == 12) {
          _L: 
          if ((int )h->entries != 0) {
            break;
          }
          break;
        } else {
          if ((int )h->entries != 1) {
            break;
          }
        }
      }
    }
    switch ((int )h->type) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___1 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___1 = sizeof(PG_CHKSUM );
      } else {
        tmp___1 = 0U;
      }
    }
    pgno = ((BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                  26) + tmp___1) +
                                                   0))))->pgno;
    break;
    case 4: ;
    if (dbp___1->flags & 2048U) {
      tmp___3 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___3 = sizeof(PG_CHKSUM );
      } else {
        tmp___3 = 0U;
      }
    }
    pgno = ((RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                  26) + tmp___3) +
                                                   0))))->pgno;
    break;
    default: 
    tmp___4 = __db_pgfmt(dbp___1->dbenv, h->pgno);
    return (tmp___4);
    }
    ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & lock);
    if (ret != 0) {
      break;
    }
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      break;
    }
    while (1) {
      while (1) {
        if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
          ret = __bam_stkgrow(dbp___1->dbenv, cp);
        } else {
          ret = 0;
        }
        if (ret == 0) {
          (cp->csp)->page = h;
          (cp->csp)->indx = (unsigned short)0;
          (cp->csp)->entries = h->entries;
          (cp->csp)->lock = lock;
          (cp->csp)->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
        }
        break;
      }
      cp->csp = cp->csp + 1;
      break;
    }
    if (ret != 0) {
      break;
    }
  }
  if (! ((unsigned int )cp->csp == (unsigned int )cp->sp)) {
    cp->csp = cp->csp - 1;
  }
  if (ret == 0) {
    ret = __bam_dpages(dbc, cp->sp);
  } else {
    __bam_stkrel(dbc, 0U);
  }
  return (ret);
}
}
static int __bam_c_getstack(DBC *dbc ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT dbt ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int exact ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = __memp_fget(mpf, & cp->pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& dbt), 0, sizeof(DBT ));
  ret = __db_ret(dbp___1, h, 0U, & dbt, & dbc->my_rkey.data, & dbc->my_rkey.ulen);
  if (ret != 0) {
    goto err;
  }
  exact = 0;
  ret = __bam_search(dbc, 0U, (DBT const   *)(& dbt), 12546U, 1, (db_recno_t *)((void *)0),
                     & exact);
  err: 
  t_ret = __memp_fput(mpf, (void *)h, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __bam_isopd(DBC *dbc , db_pgno_t *pgnop ) 
{ BOVERFLOW *bo ;
  unsigned int tmp___0 ;

  {
  if ((int )((PAGE *)(dbc->internal)->page)->type != 5) {
    return (0);
  }
  if ((dbc->dbp)->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if ((dbc->dbp)->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  bo = (BOVERFLOW *)((u_int8_t *)(dbc->internal)->page + (int )(*((db_indx_t *)(((u_int8_t *)(dbc->internal)->page +
                                                                                 26) +
                                                                                tmp___0) +
                                                                  ((int )(dbc->internal)->indx +
                                                                   1))));
  if (((int )bo->type & -129) == 2) {
    (*pgnop) = bo->pgno;
    return (1);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-oUayyNWN.i","-O2")
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
int __bam_adjindx(DBC *dbc , PAGE *h , u_int32_t indx , u_int32_t indx_copy , int is_insert ) ;
int __bam_rsplit_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_pgno_t pgno , DBT const   *pgdbt , db_pgno_t root_pgno , db_pgno_t nrec ,
                     DBT const   *rootent , DB_LSN *rootlsn ) ;
int __bam_adj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx , u_int32_t indx_copy ,
                  u_int32_t is_insert ) ;
int __db_ditem(DBC *dbc , PAGE *pagep , u_int32_t indx , u_int32_t nbytes ) ;
int __db_relink(DBC *dbc , u_int32_t add_rem , PAGE *pagep , PAGE **new_next , int needlock ) ;
int __db_doff(DBC *dbc , db_pgno_t pgno ) ;
int __bam_ditem(DBC *dbc , PAGE *h , u_int32_t indx ) 
{ BINTERNAL *bi ;
  BKEYDATA *bk ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  u_int32_t nbytes ;
  int ret ;
  db_indx_t *inp ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  switch ((int )h->type) {
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                            tmp___2) + indx)));
  switch ((int )bi->type & -129) {
  case 2: ;
  case 1: 
  nbytes = (unsigned int )((unsigned long long )(((unsigned int )((int )bi->len +
                                                                  (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                  sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL));
  break;
  case 3: 
  nbytes = (unsigned int )((unsigned long long )(((unsigned int )((int )bi->len +
                                                                  (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                  sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL));
  ret = __db_doff(dbc, ((BOVERFLOW *)(bi->data))->pgno);
  if (ret != 0) {
    return (ret);
  }
  break;
  default: 
  tmp___3 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___3);
  }
  break;
  case 4: 
  nbytes = (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) -
                                                 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                          1ULL));
  break;
  case 5: ;
  if (indx % 2U == 0U) {
    if (indx + 2U < (unsigned int )h->entries) {
      if ((int )(*(inp + indx)) == (int )(*(inp + (indx + 2U)))) {
        tmp___4 = __bam_adjindx(dbc, h, indx, indx + 1U, 0);
        return (tmp___4);
      }
    }
    if (indx > 0U) {
      if ((int )(*(inp + indx)) == (int )(*(inp + (indx - 2U)))) {
        tmp___5 = __bam_adjindx(dbc, h, indx, indx - 2U, 0);
        return (tmp___5);
      }
    }
  }
  case 12: ;
  case 6: ;
  if (dbp___1->flags & 2048U) {
    tmp___7 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___7 = sizeof(PG_CHKSUM );
    } else {
      tmp___7 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___7) + indx)));
  switch ((int )bk->type & -129) {
  case 2: 
  nbytes = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                    sizeof(u_int32_t )) -
                                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                            1ULL)));
  break;
  case 3: 
  nbytes = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                    sizeof(u_int32_t )) -
                                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                            1ULL)));
  if (dbp___1->flags & 2048U) {
    tmp___9 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___9 = sizeof(PG_CHKSUM );
    } else {
      tmp___9 = 0U;
    }
  }
  ret = __db_doff(dbc, ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                              26) +
                                                                             tmp___9) +
                                                               indx))))->pgno);
  if (ret != 0) {
    return (ret);
  }
  break;
  case 1: 
  nbytes = (unsigned int )((unsigned long long )(((unsigned int )((int )bk->len +
                                                                  (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                  sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL));
  break;
  default: 
  tmp___10 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___10);
  }
  break;
  default: 
  tmp___11 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___11);
  }
  ret = __db_ditem(dbc, h, indx, nbytes);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fset(mpf, (void *)h, 2U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __bam_adjindx(DBC *dbc , PAGE *h , u_int32_t indx , u_int32_t indx_copy , int is_insert ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  db_indx_t copy ;
  db_indx_t *inp ;
  int ret ;
  unsigned int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __bam_adj_log(dbp___1, dbc->txn, & h->lsn, 0U, h->pgno, & h->lsn,
                              indx, indx_copy, (unsigned int )is_insert);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      h->lsn.file = 0U;
      h->lsn.offset = 1U;
      break;
    }
  }
  if (is_insert) {
    copy = (*(inp + indx_copy));
    if (indx != (unsigned int )h->entries) {
      memmove((void *)(inp + (indx + 1U)), (void const   *)(inp + indx), sizeof(db_indx_t ) *
                                                                         ((unsigned int )h->entries -
                                                                          indx));
    }
    (*(inp + indx)) = copy;
    h->entries = (unsigned short )((int )h->entries + 1);
  } else {
    h->entries = (unsigned short )((int )h->entries - 1);
    if (indx != (unsigned int )h->entries) {
      memmove((void *)(inp + indx), (void const   *)(inp + (indx + 1U)), sizeof(db_indx_t ) *
                                                                         ((unsigned int )h->entries -
                                                                          indx));
    }
  }
  ret = __memp_fset(mpf, (void *)h, 2U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __bam_dpages(DBC *dbc , EPG *stack_epg ) 
{ BTREE_CURSOR *cp ;
  BINTERNAL *bi ;
  DB *dbp___1 ;
  DBT a ;
  DBT b ;
  DB_LOCK c_lock ;
  DB_LOCK p_lock ;
  DB_MPOOLFILE *mpf ;
  EPG *epg ;
  PAGE *child ;
  PAGE *parent ;
  db_indx_t nitems ;
  db_pgno_t pgno ;
  db_pgno_t root_pgno ;
  db_recno_t rcnt ;
  int done ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  db_pgno_t tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  epg = cp->sp;
  while ((unsigned int )epg < (unsigned int )stack_epg) {
    t_ret = __memp_fput(mpf, (void *)epg->page, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (epg->lock.off != 0U) {
      __db_lput(dbc, & epg->lock);
    }
    epg ++;
  }
  if (ret != 0) {
    goto err;
  }
  ret = __db_relink(dbc, 6U, (cp->csp)->page, (PAGE **)((void *)0), 1);
  if (ret != 0) {
    goto err;
  }
  ret = __bam_ditem(dbc, epg->page, (unsigned int )epg->indx);
  if (ret != 0) {
    goto err;
  }
  ret = __bam_ca_di(dbc, (epg->page)->pgno, (unsigned int )epg->indx, -1);
  if (ret != 0) {
    goto err;
  }
  pgno = (epg->page)->pgno;
  nitems = (epg->page)->entries;
  ret = __memp_fput(mpf, (void *)epg->page, 0U);
  if (ret != 0) {
    goto err_inc;
  }
  if (epg->lock.off != 0U) {
    __db_lput(dbc, & epg->lock);
  }
  while (1) {
    epg ++;
    if (! ((unsigned int )epg <= (unsigned int )cp->csp)) {
      break;
    }
    if ((int )(epg->page)->entries != 0) {
      ret = __bam_ditem(dbc, epg->page, (unsigned int )epg->indx);
      if (ret != 0) {
        goto err;
      }
    }
    ret = __db_free(dbc, epg->page);
    if (ret != 0) {
      epg->page = (PAGE *)((void *)0);
      goto err_inc;
    }
    if (epg->lock.off != 0U) {
      __db_lput(dbc, & epg->lock);
    }
  }
  if (0) {
    err_inc: 
    epg ++;
    err: 
    while ((unsigned int )epg <= (unsigned int )cp->csp) {
      if ((unsigned int )epg->page != (unsigned int )((void *)0)) {
        __memp_fput(mpf, (void *)epg->page, 0U);
      }
      if (epg->lock.off != 0U) {
        __db_lput(dbc, & epg->lock);
      }
      epg ++;
    }
    while (1) {
      cp->csp = cp->sp;
      (cp->csp)->page = (PAGE *)((void *)0);
      (cp->csp)->lock.off = 0U;
      break;
    }
    return (ret);
  }
  while (1) {
    cp->csp = cp->sp;
    (cp->csp)->page = (PAGE *)((void *)0);
    (cp->csp)->lock.off = 0U;
    break;
  }
  root_pgno = cp->root;
  if (pgno != root_pgno) {
    return (0);
  } else {
    if ((int )nitems != 1) {
      return (0);
    }
  }
  done = 0;
  while (! done) {
    child = (PAGE *)((void *)0);
    parent = child;
    p_lock.off = 0U;
    c_lock.off = 0U;
    pgno = root_pgno;
    ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & p_lock);
    if (ret != 0) {
      goto stop;
    }
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& parent));
    if (ret != 0) {
      goto stop;
    }
    if ((int )parent->entries != 1) {
      goto stop;
    }
    switch ((int )parent->type) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bi = (BINTERNAL *)((u_int8_t *)parent + (int )(*((db_indx_t *)(((u_int8_t *)parent +
                                                                    26) + tmp___0) +
                                                     0)));
    if (((int )bi->type & -129) == 3) {
      ret = __db_doff(dbc, ((BOVERFLOW *)(bi->data))->pgno);
      if (ret != 0) {
        goto stop;
      }
    }
    pgno = bi->pgno;
    break;
    case 4: ;
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    pgno = ((RINTERNAL *)((u_int8_t *)parent + (int )(*((db_indx_t *)(((u_int8_t *)parent +
                                                                       26) + tmp___2) +
                                                        0))))->pgno;
    break;
    default: ;
    goto stop;
    }
    ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & c_lock);
    if (ret != 0) {
      goto stop;
    }
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& child));
    if (ret != 0) {
      goto stop;
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___3;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            memset((void *)(& a), 0, sizeof(a));
            a.data = (void *)child;
            a.size = dbp___1->pgsize;
            memset((void *)(& b), 0, sizeof(b));
            if (dbp___1->flags & 2048U) {
              tmp___4 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___4 = sizeof(PG_CHKSUM );
              } else {
                tmp___4 = 0U;
              }
            }
            b.data = (void *)((u_int8_t *)parent + (int )(*((db_indx_t *)(((u_int8_t *)parent +
                                                                           26) + tmp___4) +
                                                            0)));
            if ((int )parent->type == 4) {
              b.size = (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) +
                                                              sizeof(u_int32_t )) -
                                                             1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL));
            } else {
              b.size = (unsigned int )((unsigned long long )(((unsigned int )((int )((BINTERNAL *)b.data)->len +
                                                                              (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                              sizeof(u_int32_t )) -
                                                             1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL));
            }
            if ((int )parent->type == 3) {
              tmp___6 = parent->prev_pgno;
            } else {
              if ((int )parent->type == 4) {
                tmp___6 = parent->prev_pgno;
              } else {
                if ((int )parent->type == 5) {
                  tmp___7 = (int )parent->entries / 2;
                } else {
                  tmp___7 = (int )parent->entries;
                }
                tmp___6 = (unsigned int )tmp___7;
              }
            }
            ret = __bam_rsplit_log(dbp___1, dbc->txn, & child->lsn, 0U, child->pgno,
                                   (DBT const   *)(& a), parent->pgno, tmp___6, (DBT const   *)(& b),
                                   & parent->lsn);
            if (ret != 0) {
              goto stop;
            }
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      while (1) {
        child->lsn.file = 0U;
        child->lsn.offset = 1U;
        break;
      }
    }
    rcnt = 0U;
    rcnt = rcnt;
    if (cp->flags & 2U) {
      if ((int )child->level > 1) {
        if ((int )parent->type == 3) {
          rcnt = parent->prev_pgno;
        } else {
          if ((int )parent->type == 4) {
            rcnt = parent->prev_pgno;
          } else {
            if ((int )parent->type == 5) {
              tmp___9 = (int )parent->entries / 2;
            } else {
              tmp___9 = (int )parent->entries;
            }
            rcnt = (unsigned int )tmp___9;
          }
        }
      }
    }
    memcpy((void * __restrict  )parent, (void const   * __restrict  )child, dbp___1->pgsize);
    parent->pgno = root_pgno;
    if (cp->flags & 2U) {
      if ((int )child->level > 1) {
        parent->prev_pgno = rcnt;
      }
    }
    ret = __memp_fset(mpf, (void *)parent, 2U);
    if (ret != 0) {
      goto stop;
    }
    ret = __memp_fset(mpf, (void *)child, 2U);
    if (ret != 0) {
      goto stop;
    }
    ret = __bam_ca_rsplit(dbc, child->pgno, root_pgno);
    if (ret != 0) {
      goto stop;
    }
    ret = __db_free(dbc, child);
    if (ret != 0) {
      child = (PAGE *)((void *)0);
      goto stop;
    }
    child = (PAGE *)((void *)0);
    if (0) {
      stop: 
      done = 1;
    }
    if (p_lock.off != 0U) {
      __db_lput(dbc, & p_lock);
    }
    if ((unsigned int )parent != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(mpf, (void *)parent, 0U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    if (c_lock.off != 0U) {
      __db_lput(dbc, & c_lock);
    }
    if ((unsigned int )child != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(mpf, (void *)child, 0U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-yulGdGGg.i","-O2")
extern int fclose(FILE *__stream ) ;
int __db_mi_open(DB_ENV *dbenv___0 , char const   *name , int after ) ;
int __os_strdup(DB_ENV *dbenv___0 , char const   *str , void *storep ) ;
int __os_calloc(DB_ENV *dbenv___0 , size_t num , size_t size , void *storep ) ;
int __db_ferr(DB_ENV const   *dbenv___0 , char const   *name , int iscombo ) ;
int __bam_db_create(DB *dbp___1 ) ;
int __bam_db_close(DB *dbp___1 ) ;
void __bam_map_flags(DB *dbp___1 , u_int32_t *inflagsp , u_int32_t *outflagsp ) ;
int __bam_set_flags(DB *dbp___1 , u_int32_t *flagsp ) ;
int __bam_set_bt_compare(DB *dbp___1 , int (*func)(DB * , DBT const   * , DBT const   * ) ) ;
void __ram_map_flags(DB *dbp___1 , u_int32_t *inflagsp , u_int32_t *outflagsp ) ;
int __ram_set_flags(DB *dbp___1 , u_int32_t *flagsp ) ;
int __dbh_am_chk(DB *dbp___1 , u_int32_t flags ) ;
static int __bam_set_bt_maxkey(DB *dbp___1 , u_int32_t bt_maxkey ) ;
static int __bam_get_bt_minkey(DB *dbp___1 , u_int32_t *bt_minkeyp ) ;
static int __bam_set_bt_minkey(DB *dbp___1 , u_int32_t bt_minkey ) ;
static int __bam_set_bt_prefix(DB *dbp___1 , size_t (*func)(DB * , DBT const   * ,
                                                            DBT const   * ) ) ;
static int __ram_get_re_delim(DB *dbp___1 , int *re_delimp ) ;
static int __ram_set_re_delim(DB *dbp___1 , int re_delim ) ;
static int __ram_get_re_len(DB *dbp___1 , u_int32_t *re_lenp ) ;
static int __ram_set_re_len(DB *dbp___1 , u_int32_t re_len ) ;
static int __ram_get_re_pad(DB *dbp___1 , int *re_padp ) ;
static int __ram_set_re_pad(DB *dbp___1 , int re_pad ) ;
static int __ram_get_re_source(DB *dbp___1 , char const   **re_sourcep ) ;
static int __ram_set_re_source(DB *dbp___1 , char const   *re_source ) ;
int __bam_db_create(DB *dbp___1 ) 
{ BTREE *t ;
  int ret ;

  {
  ret = __os_calloc(dbp___1->dbenv, 1U, sizeof(BTREE ), (void *)(& t));
  if (ret != 0) {
    return (ret);
  }
  dbp___1->bt_internal = (void *)t;
  t->bt_minkey = 2U;
  t->bt_compare = & __bam_defcmp;
  t->bt_prefix = & __bam_defpfx;
  dbp___1->set_bt_compare = & __bam_set_bt_compare;
  dbp___1->set_bt_maxkey = & __bam_set_bt_maxkey;
  dbp___1->get_bt_minkey = & __bam_get_bt_minkey;
  dbp___1->set_bt_minkey = & __bam_set_bt_minkey;
  dbp___1->set_bt_prefix = & __bam_set_bt_prefix;
  t->re_pad = ' ';
  t->re_delim = '\n';
  t->re_eof = 1;
  dbp___1->get_re_delim = & __ram_get_re_delim;
  dbp___1->set_re_delim = & __ram_set_re_delim;
  dbp___1->get_re_len = & __ram_get_re_len;
  dbp___1->set_re_len = & __ram_set_re_len;
  dbp___1->get_re_pad = & __ram_get_re_pad;
  dbp___1->set_re_pad = & __ram_set_re_pad;
  dbp___1->get_re_source = & __ram_get_re_source;
  dbp___1->set_re_source = & __ram_set_re_source;
  return (0);
}
}
int __bam_db_close(DB *dbp___1 ) 
{ BTREE *t ;

  {
  t = (BTREE *)dbp___1->bt_internal;
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((unsigned int )t->re_fp != (unsigned int )((void *)0)) {
    fclose(t->re_fp);
  }
  if ((unsigned int )t->re_source != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)t->re_source);
  }
  __os_free(dbp___1->dbenv, (void *)t);
  dbp___1->bt_internal = (void *)0;
  return (0);
}
}
void __bam_map_flags(DB *dbp___1 , u_int32_t *inflagsp , u_int32_t *outflagsp ) 
{ 

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  if ((*inflagsp) & 2U) {
    (*outflagsp) |= 512U;
    (*inflagsp) &= 4294967293U;
  }
  if ((*inflagsp) & 4U) {
    (*outflagsp) |= 1536U;
    (*inflagsp) &= 4294967291U;
  }
  if ((*inflagsp) & 16U) {
    (*outflagsp) |= 1048576U;
    (*inflagsp) &= 4294967279U;
  }
  if ((*inflagsp) & 64U) {
    (*outflagsp) |= 16777216U;
    (*inflagsp) &= 4294967231U;
  }
  return;
}
}
int __bam_set_flags(DB *dbp___1 , u_int32_t *flagsp ) 
{ u_int32_t flags ;
  int tmp ;
  int __ret ;
  int __ret___0 ;
  int tmp___0 ;

  {
  flags = (*flagsp);
  if (flags & 86U) {
    if (dbp___1->flags & 65536U) {
      tmp = __db_mi_open(dbp___1->dbenv, "DB->set_flags", 1);
      return (tmp);
    }
  }
  if (flags & 6U) {
    __ret = __dbh_am_chk(dbp___1, 3U);
    if (__ret != 0) {
      return (__ret);
    }
  }
  if (flags & 80U) {
    __ret___0 = __dbh_am_chk(dbp___1, 1U);
    if (__ret___0 != 0) {
      return (__ret___0);
    }
  }
  if (flags & 6U) {
    if (dbp___1->flags & 1048576U) {
      goto incompat;
    }
  }
  if (flags & 16U) {
    if (dbp___1->flags & 512U) {
      goto incompat;
    }
  }
  if (flags & 4U) {
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
      dbp___1->dup_compare = & __bam_defcmp;
    }
  }
  __bam_map_flags(dbp___1, flagsp, & dbp___1->flags);
  return (0);
  incompat: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbp___1->dbenv, "DB->set_flags", 1);
  return (tmp___0);
}
}
int __bam_set_bt_compare(DB *dbp___1 , int (*func)(DB * , DBT const   * , DBT const   * ) ) 
{ BTREE *t ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_bt_compare", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 1U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  t->bt_compare = func;
  if ((unsigned int )t->bt_prefix == (unsigned int )(& __bam_defpfx)) {
    t->bt_prefix = (size_t (*)(DB * , DBT const   * , DBT const   * ))((void *)0);
  }
  return (0);
}
}
static int __bam_set_bt_maxkey(DB *dbp___1 , u_int32_t bt_maxkey ) 
{ BTREE *t ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_bt_maxkey", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 1U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  if (bt_maxkey < 1U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "minimum bt_maxkey value is 1");
    return (22);
  }
  t->bt_maxkey = bt_maxkey;
  return (0);
}
}
static int __bam_get_bt_minkey(DB *dbp___1 , u_int32_t *bt_minkeyp ) 
{ BTREE *t ;
  int __ret ;

  {
  __ret = __dbh_am_chk(dbp___1, 1U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  (*bt_minkeyp) = t->bt_minkey;
  return (0);
}
}
static int __bam_set_bt_minkey(DB *dbp___1 , u_int32_t bt_minkey ) 
{ BTREE *t ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_bt_minkey", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 1U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  if (bt_minkey < 2U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "minimum bt_minkey value is 2");
    return (22);
  }
  t->bt_minkey = bt_minkey;
  return (0);
}
}
static int __bam_set_bt_prefix(DB *dbp___1 , size_t (*func)(DB * , DBT const   * ,
                                                            DBT const   * ) ) 
{ BTREE *t ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_bt_prefix", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 1U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  t->bt_prefix = func;
  return (0);
}
}
void __ram_map_flags(DB *dbp___1 , u_int32_t *inflagsp , u_int32_t *outflagsp ) 
{ 

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  if ((*inflagsp) & 32U) {
    (*outflagsp) |= 4194304U;
    (*inflagsp) &= 4294967263U;
  }
  if ((*inflagsp) & 128U) {
    (*outflagsp) |= 67108864U;
    (*inflagsp) &= 4294967167U;
  }
  return;
}
}
int __ram_set_flags(DB *dbp___1 , u_int32_t *flagsp ) 
{ u_int32_t flags ;
  int tmp ;
  int __ret ;

  {
  flags = (*flagsp);
  if (flags & 160U) {
    if (dbp___1->flags & 65536U) {
      tmp = __db_mi_open(dbp___1->dbenv, "DB->set_flags", 1);
      return (tmp);
    }
    __ret = __dbh_am_chk(dbp___1, 8U);
    if (__ret != 0) {
      return (__ret);
    }
  }
  __ram_map_flags(dbp___1, flagsp, & dbp___1->flags);
  return (0);
}
}
static int __ram_get_re_delim(DB *dbp___1 , int *re_delimp ) 
{ BTREE *t ;
  int __ret ;

  {
  __ret = __dbh_am_chk(dbp___1, 8U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  (*re_delimp) = t->re_delim;
  return (0);
}
}
static int __ram_set_re_delim(DB *dbp___1 , int re_delim ) 
{ BTREE *t ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_re_delim", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 8U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  t->re_delim = re_delim;
  dbp___1->flags = dbp___1->flags | 64U;
  return (0);
}
}
static int __ram_get_re_len(DB *dbp___1 , u_int32_t *re_lenp ) 
{ BTREE *t ;
  int __ret ;

  {
  __ret = __dbh_am_chk(dbp___1, 12U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  (*re_lenp) = t->re_len;
  return (0);
}
}
static int __ram_set_re_len(DB *dbp___1 , u_int32_t re_len ) 
{ BTREE *t ;
  QUEUE *q ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_re_len", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 12U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  t->re_len = re_len;
  q = (QUEUE *)dbp___1->q_internal;
  q->re_len = re_len;
  dbp___1->flags = dbp___1->flags | 4096U;
  return (0);
}
}
static int __ram_get_re_pad(DB *dbp___1 , int *re_padp ) 
{ BTREE *t ;
  int __ret ;

  {
  __ret = __dbh_am_chk(dbp___1, 12U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  (*re_padp) = t->re_pad;
  return (0);
}
}
static int __ram_set_re_pad(DB *dbp___1 , int re_pad ) 
{ BTREE *t ;
  QUEUE *q ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_re_pad", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 12U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  t->re_pad = re_pad;
  q = (QUEUE *)dbp___1->q_internal;
  q->re_pad = re_pad;
  dbp___1->flags = dbp___1->flags | 131072U;
  return (0);
}
}
static int __ram_get_re_source(DB *dbp___1 , char const   **re_sourcep ) 
{ BTREE *t ;
  int __ret ;

  {
  __ret = __dbh_am_chk(dbp___1, 8U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  (*re_sourcep) = (char const   *)t->re_source;
  return (0);
}
}
static int __ram_set_re_source(DB *dbp___1 , char const   *re_source ) 
{ BTREE *t ;
  int tmp ;
  int __ret ;
  int tmp___0 ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_re_source", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 8U);
  if (__ret != 0) {
    return (__ret);
  }
  t = (BTREE *)dbp___1->bt_internal;
  tmp___0 = __os_strdup(dbp___1->dbenv, re_source, (void *)(& t->re_source));
  return (tmp___0);
}
}
#pragma merger(0,"/tmp/cil-Nfz69S5R.i","-O2")
int __db_fchk(DB_ENV *dbenv___0 , char const   *name , u_int32_t flags , u_int32_t ok_flags ) ;
int __db_fcchk(DB_ENV *dbenv___0 , char const   *name , u_int32_t flags , u_int32_t flag1 ,
               u_int32_t flag2 ) ;
int __bam_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               u_int32_t flags ) ;
int __bam_metachk(DB *dbp___1 , char const   *name , BTMETA *btm ) ;
int __bam_read_root(DB *dbp___1 , DB_TXN *txn , db_pgno_t base_pgno , u_int32_t flags ) ;
int __bam_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) ;
int __bam_new_subdb(DB *mdbp , DB *dbp___1 , DB_TXN *txn ) ;
int __bam_root_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t meta_pgno , db_pgno_t root_pgno , DB_LSN *meta_lsn ) ;
int __db_log_page(DB *dbp___1 , DB_TXN *txn , DB_LSN *lsn , db_pgno_t pgno , PAGE *page ) ;
int __db_pgout(DB_ENV *dbenv___0 , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __db_cursor(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t flags ) ;
int __db_new(DBC *dbc , u_int32_t type , PAGE **pagepp ) ;
void __memp_last_pgno(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr ) ;
int __fop_write(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , APPNAME appname ,
                DB_FH *fhp , u_int32_t pgsize , db_pgno_t pageno , u_int32_t off ,
                u_int8_t *buf , u_int32_t size , u_int32_t istmp , u_int32_t flags ) ;
static void __bam_init_meta(DB *dbp___1 , BTMETA *meta , db_pgno_t pgno , DB_LSN *lsnp ) ;
int __bam_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               u_int32_t flags ) 
{ BTREE *t ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  name = (char const   *)((void *)0);
  name = name;
  t = (BTREE *)dbp___1->bt_internal;
  if ((unsigned int )t->bt_compare == (unsigned int )(& __bam_defcmp)) {
    if ((unsigned int )t->bt_prefix != (unsigned int )(& __bam_defpfx)) {
      __db_err((DB_ENV const   *)dbp___1->dbenv, "prefix comparison may not be specified for default comparison routine");
      return (22);
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  if ((int )((unsigned short )((unsigned long long )((dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                         26) +
                                                                                                                                        tmp___0))))) /
                                                     (t->bt_minkey * 2U)) - ((((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                                      sizeof(u_int32_t )) -
                                                                                                     1U) &
                                                                               ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) +
                                                                              (unsigned long long )sizeof(db_indx_t )) +
                                                                             ((unsigned long long )((1U +
                                                                                                     sizeof(int32_t )) -
                                                                                                    1U) &
                                                                              ~ ((unsigned long long )sizeof(int32_t ) -
                                                                                 1ULL))))) >
      (int )((unsigned short )((unsigned long long )((dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                         26) +
                                                                                                                                        tmp___2))))) /
                                                     4U) - ((((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                     sizeof(u_int32_t )) -
                                                                                    1U) &
                                                              ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                 1ULL)) + (unsigned long long )sizeof(db_indx_t )) +
                                                            ((unsigned long long )((1U +
                                                                                    sizeof(int32_t )) -
                                                                                   1U) &
                                                             ~ ((unsigned long long )sizeof(int32_t ) -
                                                                1ULL)))))) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "bt_minkey value of %lu too high for page size of %lu",
             (unsigned long )t->bt_minkey, (unsigned long )dbp___1->pgsize);
    return (22);
  }
  tmp___3 = __bam_read_root(dbp___1, txn, base_pgno, flags);
  return (tmp___3);
}
}
int __bam_metachk(DB *dbp___1 , char const   *name , BTMETA *btm ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t vers ;
  int ret ;
  u_int32_t _tmp ;
  int __ret ;
  int __ret___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  vers = btm->dbmeta.version;
  if (dbp___1->flags & 268435456U) {
    _tmp = vers;
    (*((u_int8_t *)(& vers) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
    (*((u_int8_t *)(& vers) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
    (*((u_int8_t *)(& vers) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
    (*((u_int8_t *)(& vers) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  }
  switch ((int )vers) {
  case 6: ;
  case 7: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: btree version %lu requires a version upgrade",
           name, (unsigned long )vers);
  return (-30989);
  case 8: ;
  case 9: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unsupported btree version: %lu", name,
           (unsigned long )vers);
  return (22);
  }
  if (dbp___1->flags & 268435456U) {
    ret = __bam_mswap((PAGE *)btm);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_fchk(dbenv___0, "DB->open", btm->dbmeta.flags, 127U);
  if (ret != 0) {
    return (ret);
  }
  if (btm->dbmeta.flags & 2U) {
    if ((int )dbp___1->type == 1) {
      goto wrong_type;
    }
    dbp___1->type = (enum __anonenum_DBTYPE_61 )3;
    __ret = __dbh_am_chk(dbp___1, 8U);
    if (__ret != 0) {
      return (__ret);
    }
  } else {
    if ((int )dbp___1->type == 3) {
      goto wrong_type;
    }
    dbp___1->type = (enum __anonenum_DBTYPE_61 )1;
    __ret___0 = __dbh_am_chk(dbp___1, 1U);
    if (__ret___0 != 0) {
      return (__ret___0);
    }
  }
  if (btm->dbmeta.flags & 1U) {
    dbp___1->flags = dbp___1->flags | 512U;
  } else {
    if (dbp___1->flags & 512U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: DB_DUP specified to open method but not set in database",
               name);
      return (22);
    }
  }
  if (btm->dbmeta.flags & 4U) {
    if ((int )dbp___1->type != 1) {
      goto wrong_type;
    }
    dbp___1->flags = dbp___1->flags | 1048576U;
    ret = __db_fcchk(dbenv___0, "DB->open", dbp___1->flags, 512U, 1048576U);
    if (ret != 0) {
      return (ret);
    }
  } else {
    if (dbp___1->flags & 1048576U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: DB_RECNUM specified to open method but not set in database",
               name);
      return (22);
    }
  }
  if (btm->dbmeta.flags & 8U) {
    if ((int )dbp___1->type != 3) {
      goto wrong_type;
    }
    dbp___1->flags = dbp___1->flags | 4096U;
  } else {
    if (dbp___1->flags & 4096U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: DB_FIXEDLEN specified to open method but not set in database",
               name);
      return (22);
    }
  }
  if (btm->dbmeta.flags & 16U) {
    if ((int )dbp___1->type != 3) {
      goto wrong_type;
    }
    dbp___1->flags = dbp___1->flags | 4194304U;
  } else {
    if (dbp___1->flags & 4194304U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: DB_RENUMBER specified to open method but not set in database",
               name);
      return (22);
    }
  }
  if (btm->dbmeta.flags & 32U) {
    dbp___1->flags = dbp___1->flags | 134217728U;
  } else {
    if (dbp___1->flags & 134217728U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: multiple databases specified but not supported by file",
               name);
      return (22);
    }
  }
  if (btm->dbmeta.flags & 64U) {
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
      dbp___1->dup_compare = & __bam_defcmp;
    }
    dbp___1->flags = dbp___1->flags | 1024U;
  } else {
    if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: duplicate sort specified but not supported in database",
               name);
      return (22);
    }
  }
  dbp___1->pgsize = btm->dbmeta.pagesize;
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(btm->dbmeta.uid),
         20U);
  return (0);
  wrong_type: 
  if ((int )dbp___1->type == 1) {
    __db_err((DB_ENV const   *)dbenv___0, "open method type is Btree, database type is Recno");
  } else {
    __db_err((DB_ENV const   *)dbenv___0, "open method type is Recno, database type is Btree");
  }
  return (22);
}
}
int __bam_read_root(DB *dbp___1 , DB_TXN *txn , db_pgno_t base_pgno , u_int32_t flags ) 
{ BTMETA *meta ;
  BTREE *t ;
  DBC *dbc ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  int ret ;
  int t_ret ;

  {
  meta = (BTMETA *)((void *)0);
  t = (BTREE *)dbp___1->bt_internal;
  metalock.off = 0U;
  mpf = dbp___1->mpf;
  ret = 0;
  ret = __db_cursor(dbp___1, txn, & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, base_pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & base_pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  if (meta->dbmeta.magic == 340322U) {
    t->bt_maxkey = meta->maxkey;
    t->bt_minkey = meta->minkey;
    t->re_pad = (int )meta->re_pad;
    t->re_len = meta->re_len;
    t->bt_meta = base_pgno;
    t->bt_root = meta->root;
  }
  t->bt_lpgno = 0U;
  if (! (flags & 16U)) {
    if (dbp___1->meta_pgno == 0U) {
      __memp_last_pgno(mpf, & meta->dbmeta.last_pgno);
      ret = __memp_fput(mpf, (void *)meta, 2U);
    } else {
      ret = __memp_fput(mpf, (void *)meta, 0U);
    }
  } else {
    ret = __memp_fput(mpf, (void *)meta, 0U);
  }
  meta = (BTMETA *)((void *)0);
  err: 
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)meta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (metalock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static void __bam_init_meta(DB *dbp___1 , BTMETA *meta , db_pgno_t pgno , DB_LSN *lsnp ) 
{ BTREE *t ;

  {
  memset((void *)meta, 0, sizeof(BTMETA ));
  meta->dbmeta.lsn = (*lsnp);
  meta->dbmeta.pgno = pgno;
  meta->dbmeta.magic = 340322U;
  meta->dbmeta.version = 9U;
  meta->dbmeta.pagesize = dbp___1->pgsize;
  if (dbp___1->flags & 1U) {
    meta->dbmeta.metaflags = (unsigned char )((int )meta->dbmeta.metaflags | 1);
  }
  if (dbp___1->flags & 2048U) {
    meta->dbmeta.encrypt_alg = ((DB_CIPHER *)(dbp___1->dbenv)->crypto_handle)->alg;
    meta->crypto_magic = meta->dbmeta.magic;
  }
  meta->dbmeta.type = (unsigned char)9;
  meta->dbmeta.free = 0U;
  meta->dbmeta.last_pgno = pgno;
  if (dbp___1->flags & 512U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 1U;
  }
  if (dbp___1->flags & 4096U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 8U;
  }
  if (dbp___1->flags & 1048576U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 4U;
  }
  if (dbp___1->flags & 4194304U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 16U;
  }
  if (dbp___1->flags & 134217728U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 32U;
  }
  if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
    meta->dbmeta.flags = meta->dbmeta.flags | 64U;
  }
  if ((int )dbp___1->type == 3) {
    meta->dbmeta.flags = meta->dbmeta.flags | 2U;
  }
  memcpy((void * __restrict  )(meta->dbmeta.uid), (void const   * __restrict  )(dbp___1->fileid),
         20U);
  t = (BTREE *)dbp___1->bt_internal;
  meta->maxkey = t->bt_maxkey;
  meta->minkey = t->bt_minkey;
  meta->re_len = t->re_len;
  meta->re_pad = (unsigned int )t->re_pad;
  return;
}
}
int __bam_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) 
{ BTMETA *meta ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  DB_PGINFO pginfo ;
  DBT pdbt ;
  PAGE *root ;
  db_pgno_t pgno ;
  int ret ;
  void *buf ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  root = (PAGE *)((void *)0);
  meta = (BTMETA *)((void *)0);
  memset((void *)(& pdbt), 0, sizeof(pdbt));
  buf = (void *)0;
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    pgno = 0U;
    ret = __memp_fget(mpf, & pgno, 1U, (void *)(& meta));
  } else {
    pginfo.db_pagesize = dbp___1->pgsize;
    pginfo.flags = dbp___1->flags & 268437505U;
    pginfo.type = dbp___1->type;
    pdbt.data = (void *)(& pginfo);
    pdbt.size = sizeof(pginfo);
    ret = __os_calloc(dbp___1->dbenv, 1U, dbp___1->pgsize, (void *)(& buf));
    meta = (BTMETA *)buf;
  }
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    lsn.file = 0U;
    lsn.offset = 1U;
    break;
  }
  __bam_init_meta(dbp___1, meta, 0U, & lsn);
  meta->root = 1U;
  meta->dbmeta.last_pgno = 1U;
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ret = __memp_fput(mpf, (void *)meta, 2U);
  } else {
    ret = __db_pgout(dbenv___0, 0U, (void *)meta, & pdbt);
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 32768U) {
      tmp = 16;
    } else {
      tmp = 0;
    }
    ret = __fop_write(dbenv___0, txn, name, (enum __anonenum_APPNAME_39 )1, fhp, dbp___1->pgsize,
                      0U, 0U, (u_int8_t *)buf, dbp___1->pgsize, 1U, (unsigned int )tmp);
  }
  if (ret != 0) {
    goto err;
  }
  meta = (BTMETA *)((void *)0);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    pgno = 1U;
    ret = __memp_fget(mpf, & pgno, 1U, (void *)(& root));
    if (ret != 0) {
      goto err;
    }
  } else {
    root = (PAGE *)buf;
  }
  while (1) {
    root->pgno = 1U;
    root->prev_pgno = 0U;
    root->next_pgno = 0U;
    root->entries = (unsigned short)0;
    root->hf_offset = (unsigned short )dbp___1->pgsize;
    root->level = (unsigned char)1;
    if ((int )dbp___1->type == 3) {
      root->type = (unsigned char)6;
    } else {
      root->type = (unsigned char)5;
    }
    break;
  }
  while (1) {
    root->lsn.file = 0U;
    root->lsn.offset = 1U;
    break;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ret = __memp_fput(mpf, (void *)root, 2U);
  } else {
    ret = __db_pgout(dbenv___0, root->pgno, (void *)root, & pdbt);
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 32768U) {
      tmp___0 = 16;
    } else {
      tmp___0 = 0;
    }
    ret = __fop_write(dbenv___0, txn, name, (enum __anonenum_APPNAME_39 )1, fhp, dbp___1->pgsize,
                      1U, 0U, (u_int8_t *)buf, dbp___1->pgsize, 1U, (unsigned int )tmp___0);
  }
  if (ret != 0) {
    goto err;
  }
  root = (PAGE *)((void *)0);
  err: 
  if ((unsigned int )buf != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, buf);
  } else {
    if ((unsigned int )meta != (unsigned int )((void *)0)) {
      __memp_fput(mpf, (void *)meta, 0U);
    }
    if ((unsigned int )root != (unsigned int )((void *)0)) {
      __memp_fput(mpf, (void *)root, 0U);
    }
  }
  return (ret);
}
}
int __bam_new_subdb(DB *mdbp , DB *dbp___1 , DB_TXN *txn ) 
{ BTMETA *meta ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DB_LOCK metalock ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *root ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = mdbp->dbenv;
  mpf = mdbp->mpf;
  dbc = (DBC *)((void *)0);
  meta = (BTMETA *)((void *)0);
  root = (PAGE *)((void *)0);
  if (dbenv___0->flags & 2U) {
    tmp = 35;
  } else {
    tmp = 0;
  }
  ret = __db_cursor(mdbp, txn, & dbc, (unsigned int )tmp);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, dbp___1->meta_pgno, (enum __anonenum_db_lockmode_t_50 )2,
                  0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & dbp___1->meta_pgno, 1U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  lsn = meta->dbmeta.lsn;
  __bam_init_meta(dbp___1, meta, dbp___1->meta_pgno, & lsn);
  ret = __db_log_page(mdbp, txn, & meta->dbmeta.lsn, dbp___1->meta_pgno, (PAGE *)meta);
  if (ret != 0) {
    goto err;
  }
  if ((int )dbp___1->type == 3) {
    tmp___0 = 6;
  } else {
    tmp___0 = 5;
  }
  ret = __db_new(dbc, (unsigned int )tmp___0, & root);
  if (ret != 0) {
    goto err;
  }
  root->level = (unsigned char)1;
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        ret = __bam_root_log(mdbp, txn, & meta->dbmeta.lsn, 0U, meta->dbmeta.pgno,
                             root->pgno, & meta->dbmeta.lsn);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  meta->root = root->pgno;
  ret = __db_log_page(mdbp, txn, & root->lsn, root->pgno, root);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fput(mpf, (void *)meta, 2U);
  if (ret != 0) {
    goto err;
  }
  meta = (BTMETA *)((void *)0);
  ret = __memp_fput(mpf, (void *)root, 2U);
  if (ret != 0) {
    goto err;
  }
  root = (PAGE *)((void *)0);
  err: 
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)meta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )root != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)root, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (metalock.off != 0U) {
    if (metalock.off != 0U) {
      t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
    } else {
      t_ret = 0;
    }
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-kkrOcws7.i","-O2")
int __os_realloc(DB_ENV *dbenv___0 , size_t size , void *storep ) ;
int __db_rec_toobig(DB_ENV *dbenv___0 , u_int32_t data_len , u_int32_t fixed_rec_len ) ;
int __db_rec_repl(DB_ENV *dbenv___0 , u_int32_t data_size , u_int32_t data_dlen ) ;
int __bam_ritem(DBC *dbc , PAGE *h , u_int32_t indx , DBT *data ) ;
int __bam_repl_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx , u_int32_t isdeleted ,
                   DBT const   *orig , DBT const   *repl , u_int32_t prefix , u_int32_t suffix ) ;
u_int32_t __db_partsize(u_int32_t nbytes , DBT *data ) ;
int __db_pitem(DBC *dbc , PAGE *pagep , u_int32_t indx , u_int32_t nbytes , DBT *hdr ,
               DBT *data ) ;
int __db_poff(DBC *dbc , DBT const   *dbt , db_pgno_t *pgnop ) ;
static int __bam_build(DBC *dbc , u_int32_t op , DBT *dbt , PAGE *h , u_int32_t indx ,
                       u_int32_t nbytes ) ;
static int __bam_dup_convert(DBC *dbc , PAGE *h , u_int32_t indx ) ;
static int __bam_ovput(DBC *dbc , u_int32_t type , db_pgno_t pgno , PAGE *h , u_int32_t indx ,
                       DBT *item ) ;
static u_int32_t __bam_partsize(DB *dbp___1 , u_int32_t op , DBT *data , PAGE *h ,
                                u_int32_t indx ) ;
int __bam_iitem(DBC *dbc , DBT *key , DBT *data , u_int32_t op , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  BKEYDATA *bk ;
  BKEYDATA bk_tmp ;
  BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT bk_hdr ;
  DBT tdbt ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_indx_t indx ;
  u_int32_t data_size ;
  u_int32_t have_bytes ;
  u_int32_t need_bytes ;
  u_int32_t needed ;
  int cmp ;
  int bigkey ;
  int bigdata ;
  int dupadjust ;
  int padrec ;
  int replace ;
  int ret ;
  int was_deleted ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___11 ;

  {
  bk = (BKEYDATA *)((void *)0);
  bk = bk;
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  t = (BTREE *)dbp___1->bt_internal;
  h = (PAGE *)cp->page;
  indx = cp->indx;
  was_deleted = 0;
  replace = was_deleted;
  dupadjust = replace;
  if (dbp___1->flags & 4096U) {
    if (data->flags & 8U) {
      if (data->size != data->dlen) {
        tmp = __db_rec_repl(dbenv___0, data->size, data->dlen);
        return (tmp);
      }
    }
  }
  if (data->flags & 8U) {
    data_size = __bam_partsize(dbp___1, op, data, h, (unsigned int )indx);
  } else {
    data_size = data->size;
  }
  padrec = 0;
  if (dbp___1->flags & 4096U) {
    if (data_size > t->re_len) {
      tmp___1 = __db_rec_toobig(dbenv___0, data_size, t->re_len);
      return (tmp___1);
    }
    if (! (flags & 1U)) {
      if (data_size < t->re_len) {
        padrec = 1;
        data_size = t->re_len;
      }
    }
  }
  if (padrec) {
    goto _L;
  } else {
    if (data->flags & 8U) {
      _L: 
      tdbt = (*data);
      ret = __bam_build(dbc, op, & tdbt, h, (unsigned int )indx, data_size);
      if (ret != 0) {
        return (ret);
      }
      data = & tdbt;
    }
  }
  if (op == 7U) {
    if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
      if ((int )h->type == 5) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
      ret = __bam_cmp(dbp___1, (DBT const   *)data, h, (unsigned int )((int )indx +
                                                                       tmp___2), dbp___1->dup_compare,
                      & cmp);
      if (ret != 0) {
        return (ret);
      }
      if (cmp != 0) {
        __db_err((DB_ENV const   *)dbenv___0, "Existing data sorts differently from put data");
        return (22);
      }
    }
  }
  needed = 0U;
  bigdata = data_size > (unsigned int )cp->ovflsize;
  switch ((int )op) {
  case 15: 
  bigkey = key->size > (unsigned int )cp->ovflsize;
  if (bigkey) {
    needed += (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                       sizeof(u_int32_t )) -
                                                                      1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL))) +
              sizeof(db_indx_t );
  } else {
    needed = (unsigned int )((unsigned long long )needed + (((unsigned long long )(((key->size +
                                                                                     (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                    sizeof(u_int32_t )) -
                                                                                   1U) &
                                                             ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                1ULL)) + (unsigned long long )sizeof(db_indx_t )));
  }
  if (bigdata) {
    needed += (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                       sizeof(u_int32_t )) -
                                                                      1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL))) +
              sizeof(db_indx_t );
  } else {
    needed = (unsigned int )((unsigned long long )needed + (((unsigned long long )(((data_size +
                                                                                     (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                    sizeof(u_int32_t )) -
                                                                                   1U) &
                                                             ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                1ULL)) + (unsigned long long )sizeof(db_indx_t )));
  }
  break;
  case 1: ;
  case 3: ;
  case 7: 
  bigkey = 0;
  if (op == 7U) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if ((int )h->type == 5) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___4) + ((int )indx +
                                                                         tmp___5))));
    if (((int )bk->type & -129) == 1) {
      have_bytes = (unsigned int )(((unsigned long long )(((unsigned int )((int )bk->len +
                                                                           (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                           sizeof(u_int32_t )) - 1U) &
                                    ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL)) +
                                   (unsigned long long )sizeof(db_indx_t ));
    } else {
      have_bytes = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                            sizeof(u_int32_t )) -
                                                                           1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL))) +
                   sizeof(db_indx_t );
    }
    need_bytes = 0U;
  } else {
    have_bytes = 0U;
    need_bytes = sizeof(db_indx_t );
  }
  if (bigdata) {
    need_bytes += (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                           sizeof(u_int32_t )) -
                                                                          1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL))) +
                  sizeof(db_indx_t );
  } else {
    need_bytes = (unsigned int )((unsigned long long )need_bytes + (((unsigned long long )(((data_size +
                                                                                             (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                            sizeof(u_int32_t )) -
                                                                                           1U) &
                                                                     ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                        1ULL)) + (unsigned long long )sizeof(db_indx_t )));
  }
  if (have_bytes < need_bytes) {
    needed += need_bytes - have_bytes;
  }
  break;
  default: 
  tmp___6 = __db_unknown_flag(dbenv___0, (char *)"DB->put", op);
  return (tmp___6);
  }
  if (dbp___1->flags & 2048U) {
    tmp___8 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___8 = sizeof(PG_CHKSUM );
    } else {
      tmp___8 = 0U;
    }
  }
  if ((unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                      26) +
                                                                                                     tmp___8)))) +
                                     (unsigned int )h->entries * sizeof(db_indx_t )) <
      needed) {
    return (-30896);
  }
  switch ((int )op) {
  case 15: ;
  if (bigkey) {
    ret = __bam_ovput(dbc, 3U, 0U, h, (unsigned int )indx, key);
    if (ret != 0) {
      return (ret);
    }
  } else {
    ret = __db_pitem(dbc, h, (unsigned int )indx, (unsigned int )((unsigned long long )(((key->size +
                                                                                          (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                         sizeof(u_int32_t )) -
                                                                                        1U) &
                                                                  ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                     1ULL)), (DBT *)((void *)0),
                     key);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __bam_ca_di(dbc, h->pgno, (unsigned int )indx, 1);
  if (ret != 0) {
    return (ret);
  }
  indx = (unsigned short )((int )indx + 1);
  break;
  case 1: ;
  if ((int )h->type == 5) {
    ret = __bam_adjindx(dbc, h, (unsigned int )((int )indx + 2), (unsigned int )indx,
                        1);
    if (ret != 0) {
      return (ret);
    }
    ret = __bam_ca_di(dbc, h->pgno, (unsigned int )((int )indx + 2), 1);
    if (ret != 0) {
      return (ret);
    }
    indx = (unsigned short )((int )indx + 3);
    dupadjust = 1;
    cp->indx = (unsigned short )((int )cp->indx + 2);
  } else {
    indx = (unsigned short )((int )indx + 1);
    cp->indx = (unsigned short )((int )cp->indx + 1);
  }
  break;
  case 3: ;
  if ((int )h->type == 5) {
    ret = __bam_adjindx(dbc, h, (unsigned int )indx, (unsigned int )indx, 1);
    if (ret != 0) {
      return (ret);
    }
    ret = __bam_ca_di(dbc, h->pgno, (unsigned int )indx, 1);
    if (ret != 0) {
      return (ret);
    }
    indx = (unsigned short )((int )indx + 1);
    dupadjust = 1;
  }
  break;
  case 7: 
  __bam_ca_delete(dbp___1, h->pgno, (unsigned int )indx, 0);
  if ((int )h->type == 5) {
    indx = (unsigned short )((int )indx + 1);
    dupadjust = 1;
  }
  if ((int )h->type == 5) {
    was_deleted = (int )bk->type & 128;
  } else {
    if ((int )h->type == 12) {
      was_deleted = (int )bk->type & 128;
    }
  }
  if (bigdata) {
    goto _L___0;
  } else {
    if (((int )bk->type & -129) != 1) {
      _L___0: 
      ret = __bam_ditem(dbc, h, (unsigned int )indx);
      if (ret != 0) {
        return (ret);
      }
      break;
    }
  }
  replace = 1;
  break;
  default: 
  tmp___9 = __db_unknown_flag(dbenv___0, (char *)"DB->put", op);
  return (tmp___9);
  }
  if (bigdata) {
    ret = __bam_ovput(dbc, 3U, 0U, h, (unsigned int )indx, data);
    if (ret != 0) {
      return (ret);
    }
  } else {
    if (flags & 1U) {
      bk_tmp.type = (unsigned char)1;
      bk_tmp.type = (unsigned char )((int )bk_tmp.type | 128);
      bk_tmp.len = (unsigned short )data->size;
      bk_hdr.data = (void *)(& bk_tmp);
      bk_hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])));
      ret = __db_pitem(dbc, h, (unsigned int )indx, (unsigned int )((unsigned long long )(((data->size +
                                                                                            (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                           sizeof(u_int32_t )) -
                                                                                          1U) &
                                                                    ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                       1ULL)), & bk_hdr,
                       data);
    } else {
      if (replace) {
        ret = __bam_ritem(dbc, h, (unsigned int )indx, data);
      } else {
        ret = __db_pitem(dbc, h, (unsigned int )indx, (unsigned int )((unsigned long long )(((data->size +
                                                                                              (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                             sizeof(u_int32_t )) -
                                                                                            1U) &
                                                                      ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                         1ULL)), (DBT *)((void *)0),
                         data);
      }
    }
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __memp_fset(mpf, (void *)h, 2U);
  if (ret != 0) {
    return (ret);
  }
  if (op != 7U) {
    ret = __bam_ca_di(dbc, h->pgno, (unsigned int )indx, 1);
    if (ret != 0) {
      return (ret);
    }
    if ((int )h->type == 5) {
      cp->indx = (unsigned short )((int )indx - 1);
    } else {
      cp->indx = indx;
    }
  }
  if (cp->flags & 2U) {
    if (op != 7U) {
      goto _L___1;
    } else {
      if (was_deleted) {
        _L___1: 
        ret = __bam_adjust(dbc, 1);
        if (ret != 0) {
          return (ret);
        }
      }
    }
  }
  if (dupadjust) {
    if (dbp___1->flags & 2048U) {
      tmp___11 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___11 = sizeof(PG_CHKSUM );
      } else {
        tmp___11 = 0U;
      }
    }
    if ((unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                        26) +
                                                                                                       tmp___11)))) +
                                       (unsigned int )h->entries * sizeof(db_indx_t )) <=
        dbp___1->pgsize / 2U) {
      ret = __bam_dup_convert(dbc, h, (unsigned int )((int )indx - 1));
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if ((int )dbc->dbtype == 3) {
    t->re_modified = 1;
  }
  return (ret);
}
}
static u_int32_t __bam_partsize(DB *dbp___1 , u_int32_t op , DBT *data , PAGE *h ,
                                u_int32_t indx ) 
{ BKEYDATA *bk ;
  u_int32_t nbytes ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  u_int32_t tmp___2 ;

  {
  if (op != 7U) {
    return (data->doff + data->size);
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  if ((int )h->type == 5) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___0) + (indx + (unsigned int )tmp___1))));
  if (((int )bk->type & -129) == 3) {
    nbytes = ((BOVERFLOW *)bk)->tlen;
  } else {
    nbytes = (unsigned int )bk->len;
  }
  tmp___2 = __db_partsize(nbytes, data);
  return (tmp___2);
}
}
static int __bam_build(DBC *dbc , u_int32_t op , DBT *dbt , PAGE *h , u_int32_t indx ,
                       u_int32_t nbytes ) 
{ BKEYDATA *bk ;
  BKEYDATA tbk ;
  BOVERFLOW *bo ;
  BTREE *t ;
  DB *dbp___1 ;
  DBT copy ;
  DBT *rdata ;
  u_int32_t len ;
  u_int32_t tlen ;
  u_int8_t *p ;
  int ret ;
  int tmp ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;

  {
  bo = (BOVERFLOW *)((void *)0);
  bo = bo;
  dbp___1 = dbc->dbp;
  t = (BTREE *)dbp___1->bt_internal;
  rdata = & dbc->my_rdata;
  if (rdata->ulen < nbytes) {
    ret = __os_realloc(dbp___1->dbenv, nbytes, (void *)(& rdata->data));
    if (ret != 0) {
      rdata->ulen = 0U;
      rdata->data = (void *)0;
      return (ret);
    }
    rdata->ulen = nbytes;
  }
  if (dbp___1->flags & 4096U) {
    tmp = t->re_pad;
  } else {
    tmp = 0;
  }
  memset(rdata->data, tmp, nbytes);
  if (! (dbt->flags & 8U)) {
    p = (u_int8_t *)rdata->data + dbt->doff;
    tlen = dbt->doff;
    goto user_copy;
  } else {
    if (op != 7U) {
      p = (u_int8_t *)rdata->data + dbt->doff;
      tlen = dbt->doff;
      goto user_copy;
    }
  }
  if (indx < (unsigned int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___1 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___1 = sizeof(PG_CHKSUM );
      } else {
        tmp___1 = 0U;
      }
    }
    if ((int )h->type == 5) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___1) + (indx + (unsigned int )tmp___2))));
    bo = (BOVERFLOW *)bk;
  } else {
    bk = & tbk;
    bk->type = (unsigned char)1;
    bk->len = (unsigned short)0;
  }
  if (((int )bk->type & -129) == 3) {
    memset((void *)(& copy), 0, sizeof(copy));
    ret = __db_goff(dbp___1, & copy, bo->tlen, bo->pgno, & rdata->data, & rdata->ulen);
    if (ret != 0) {
      return (ret);
    }
    tlen = dbt->doff;
    p = (u_int8_t *)rdata->data + dbt->doff;
    if (bo->tlen > dbt->doff + dbt->dlen) {
      len = bo->tlen - (dbt->doff + dbt->dlen);
      if (dbt->dlen != dbt->size) {
        memmove((void *)(p + dbt->size), (void const   *)(p + dbt->dlen), len);
      }
      tlen += len;
    }
  } else {
    if (dbt->doff > (unsigned int )bk->len) {
      tmp___3 = (unsigned int )bk->len;
    } else {
      tmp___3 = dbt->doff;
    }
    memcpy((void * __restrict  )rdata->data, (void const   * __restrict  )(bk->data),
           tmp___3);
    tlen = dbt->doff;
    p = (u_int8_t *)rdata->data + dbt->doff;
    len = dbt->doff + dbt->dlen;
    if ((unsigned int )bk->len > len) {
      memcpy((void * __restrict  )(p + dbt->size), (void const   * __restrict  )(bk->data +
                                                                                 len),
             (unsigned int )bk->len - len);
      tlen += (unsigned int )bk->len - len;
    }
  }
  user_copy: 
  memcpy((void * __restrict  )p, (void const   * __restrict  )dbt->data, dbt->size);
  tlen += dbt->size;
  if (dbp___1->flags & 4096U) {
    rdata->size = t->re_len;
  } else {
    rdata->size = tlen;
  }
  rdata->dlen = 0U;
  rdata->doff = 0U;
  rdata->flags = 0U;
  (*dbt) = (*rdata);
  return (0);
}
}
int __bam_ritem(DBC *dbc , PAGE *h , u_int32_t indx , DBT *data ) 
{ BKEYDATA *bk ;
  DB *dbp___1 ;
  DBT orig ;
  DBT repl ;
  db_indx_t cnt ;
  db_indx_t lo ;
  db_indx_t ln ;
  db_indx_t min ;
  db_indx_t off ;
  db_indx_t prefix ;
  db_indx_t suffix ;
  int32_t nbytes ;
  int ret ;
  db_indx_t *inp ;
  u_int8_t *p ;
  u_int8_t *t ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___0) + indx)));
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (data->size < (unsigned int )bk->len) {
            min = (unsigned short )data->size;
          } else {
            min = bk->len;
          }
          prefix = (unsigned short)0;
          p = bk->data;
          t = (u_int8_t *)data->data;
          while (1) {
            if ((int )prefix < (int )min) {
              if (! ((int )(*p) == (int )(*t))) {
                break;
              }
            } else {
              break;
            }
            prefix = (unsigned short )((int )prefix + 1);
            p ++;
            t ++;
          }
          min = (unsigned short )((int )min - (int )prefix);
          suffix = (unsigned short)0;
          p = (bk->data + (int )bk->len) - 1;
          t = ((u_int8_t *)data->data + data->size) - 1;
          while (1) {
            if ((int )suffix < (int )min) {
              if (! ((int )(*p) == (int )(*t))) {
                break;
              }
            } else {
              break;
            }
            suffix = (unsigned short )((int )suffix + 1);
            p --;
            t --;
          }
          orig.data = (void *)(bk->data + (int )prefix);
          orig.size = (unsigned int )((int )bk->len - ((int )prefix + (int )suffix));
          repl.data = (void *)((u_int8_t *)data->data + (int )prefix);
          repl.size = data->size - (unsigned int )((int )prefix + (int )suffix);
          ret = __bam_repl_log(dbp___1, dbc->txn, & h->lsn, 0U, h->pgno, & h->lsn,
                               indx, (unsigned int )((int )bk->type & 128), (DBT const   *)(& orig),
                               (DBT const   *)(& repl), (unsigned int )prefix, (unsigned int )suffix);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      h->lsn.file = 0U;
      h->lsn.offset = 1U;
      break;
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___2);
  p = (u_int8_t *)h + (int )h->hf_offset;
  t = (u_int8_t *)bk;
  lo = (unsigned short )((unsigned long long )(((unsigned int )((int )bk->len + (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL));
  ln = (unsigned short )((unsigned long long )(((data->size + (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL));
  if ((int )lo != (int )ln) {
    nbytes = (int )lo - (int )ln;
    if ((unsigned int )p == (unsigned int )t) {
      (*(inp + indx)) = (unsigned short )((int )(*(inp + indx)) + nbytes);
    } else {
      memmove((void *)(p + nbytes), (void const   *)p, (unsigned int )(t - p));
      off = (*(inp + indx));
      cnt = (unsigned short)0;
      while ((int )cnt < (int )h->entries) {
        if ((int )(*(inp + (int )cnt)) <= (int )off) {
          (*(inp + (int )cnt)) = (unsigned short )((int )(*(inp + (int )cnt)) + nbytes);
        }
        cnt = (unsigned short )((int )cnt + 1);
      }
    }
    h->hf_offset = (unsigned short )((int )h->hf_offset + nbytes);
    t += nbytes;
  }
  bk = (BKEYDATA *)t;
  bk->type = (unsigned char)1;
  bk->len = (unsigned short )data->size;
  memcpy((void * __restrict  )(bk->data), (void const   * __restrict  )data->data,
         data->size);
  return (0);
}
}
static int __bam_dup_convert(DBC *dbc , PAGE *h , u_int32_t indx ) 
{ BKEYDATA *bk ;
  DB *dbp___1 ;
  DBT hdr ;
  DB_MPOOLFILE *mpf ;
  PAGE *dp ;
  db_indx_t cnt ;
  db_indx_t cpindx ;
  db_indx_t dindx ;
  db_indx_t first ;
  db_indx_t *inp ;
  db_indx_t sz ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned long long tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  int tmp___11 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  while (1) {
    if (indx > 0U) {
      if (! ((int )(*(inp + indx)) == (int )(*(inp + (indx - 2U))))) {
        break;
      }
    } else {
      break;
    }
    indx -= 2U;
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___2) + indx)));
  if (((int )bk->type & -129) == 1) {
    sz = (unsigned short )(((unsigned long long )(((unsigned int )((int )bk->len +
                                                                   (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                   sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) +
                           (unsigned long long )sizeof(db_indx_t ));
  } else {
    sz = (unsigned short )((unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                    sizeof(u_int32_t )) -
                                                                                   1U) &
                                                             ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                1ULL))) + sizeof(db_indx_t ));
  }
  cnt = (unsigned short)0;
  first = (unsigned short )indx;
  while (1) {
    if ((int )(*(inp + (int )first)) == (int )(*(inp + indx))) {
      if (! (indx < (unsigned int )h->entries)) {
        break;
      }
    } else {
      break;
    }
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___4) + (indx + 1U))));
    if (((int )bk->type & -129) == 1) {
      tmp___5 = ((unsigned long long )(((unsigned int )((int )bk->len + (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                        sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                       1ULL)) + (unsigned long long )sizeof(db_indx_t );
    } else {
      tmp___5 = (unsigned long long )((unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                               sizeof(u_int32_t )) -
                                                                                              1U) &
                                                                        ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                           1ULL))) +
                                      sizeof(db_indx_t ));
    }
    sz = (unsigned short )((unsigned long long )sz + tmp___5);
    cnt = (unsigned short )((int )cnt + 1);
    indx += 2U;
  }
  if ((int )cnt == 1) {
    return (0);
  }
  if ((unsigned int )sz < dbp___1->pgsize / 4U) {
    return (0);
  }
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    tmp___6 = 6;
  } else {
    tmp___6 = 12;
  }
  ret = __db_new(dbc, (unsigned int )tmp___6, & dp);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    dp->pgno = dp->pgno;
    dp->prev_pgno = 0U;
    dp->next_pgno = 0U;
    dp->entries = (unsigned short)0;
    dp->hf_offset = (unsigned short )dbp___1->pgsize;
    dp->level = (unsigned char)1;
    dp->type = dp->type;
    break;
  }
  memset((void *)(& hdr), 0, sizeof(hdr));
  dindx = first;
  indx = (unsigned int )first;
  cpindx = (unsigned short)0;
  while (1) {
    ret = __bam_ca_dup(dbc, (unsigned int )first, h->pgno, indx, dp->pgno, (unsigned int )cpindx);
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 2048U) {
      tmp___8 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___8 = sizeof(PG_CHKSUM );
      } else {
        tmp___8 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___8) + ((int )dindx +
                                                                         1))));
    hdr.data = (void *)bk;
    if (((int )bk->type & -129) == 1) {
      hdr.size = (unsigned int )((unsigned long long )(((unsigned int )((int )bk->len +
                                                                        (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                        sizeof(u_int32_t )) - 1U) &
                                 ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL));
    } else {
      hdr.size = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)));
    }
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
      if ((int )bk->type & 128) {
        if (((int )bk->type & -129) == 3) {
          if (dbp___1->flags & 2048U) {
            tmp___10 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___10 = sizeof(PG_CHKSUM );
            } else {
              tmp___10 = 0U;
            }
          }
          ret = __db_doff(dbc, ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                      26) +
                                                                                     tmp___10) +
                                                                       ((int )dindx +
                                                                        1)))))->pgno);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      ret = __db_pitem(dbc, dp, (unsigned int )cpindx, hdr.size, & hdr, (DBT *)((void *)0));
      if (ret != 0) {
        goto err;
      }
      cpindx = (unsigned short )((int )cpindx + 1);
    }
    if ((int )cnt != 1) {
      ret = __bam_adjindx(dbc, h, (unsigned int )dindx, (unsigned int )((int )first +
                                                                        1), 0);
      if (ret != 0) {
        goto err;
      }
    } else {
      dindx = (unsigned short )((int )dindx + 1);
    }
    ret = __db_ditem(dbc, h, (unsigned int )dindx, hdr.size);
    if (ret != 0) {
      goto err;
    }
    indx += 2U;
    cnt = (unsigned short )((int )cnt - 1);
    if (! cnt) {
      break;
    }
  }
  ret = __bam_ovput(dbc, 2U, dp->pgno, h, (unsigned int )((int )first + 1), (DBT *)((void *)0));
  if (ret != 0) {
    goto err;
  }
  ret = __bam_ca_di(dbc, h->pgno, (unsigned int )((int )first + 2), (int )((unsigned int )((int )first +
                                                                                           2) -
                                                                           indx));
  if (ret != 0) {
    goto err;
  }
  tmp___11 = __memp_fput(mpf, (void *)dp, 2U);
  return (tmp___11);
  err: 
  __memp_fput(mpf, (void *)dp, 0U);
  return (ret);
}
}
static int __bam_ovput(DBC *dbc , u_int32_t type , db_pgno_t pgno , PAGE *h , u_int32_t indx ,
                       DBT *item ) 
{ BOVERFLOW bo ;
  DBT hdr ;
  int ret ;
  int tmp ;

  {
  bo.type = (unsigned char )type;
  if (type == 3U) {
    ret = __db_poff(dbc, (DBT const   *)item, & bo.pgno);
    if (ret != 0) {
      return (ret);
    }
    bo.tlen = item->size;
  } else {
    bo.pgno = pgno;
    bo.tlen = 0U;
  }
  memset((void *)(& hdr), 0, sizeof(hdr));
  hdr.data = (void *)(& bo);
  hdr.size = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                      sizeof(u_int32_t )) -
                                                                     1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                              1ULL)));
  tmp = __db_pitem(dbc, h, indx, (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                          sizeof(u_int32_t )) -
                                                                                         1U) &
                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL))), & hdr,
                   (DBT *)((void *)0));
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-MV1PhSqQ.i","-O2")
int log_compare(DB_LSN const   *lsn0 , DB_LSN const   *lsn1 ) ;
void *__ua_memcpy(void *dst , void const   *src , size_t len ) ;
int __db_pgerr(DB *dbp___1 , db_pgno_t pgno , int errval ) ;
int __bam_split_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __bam_rsplit_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __bam_adj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) ;
int __bam_cadjust_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) ;
int __bam_cdel_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) ;
int __bam_repl_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) ;
int __bam_root_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) ;
int __bam_curadj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __bam_rcuradj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) ;
int __ram_ca(DBC *dbc_arg , ca_recno_arg op ) ;
db_recno_t __bam_total(DB *dbp___1 , PAGE *h ) ;
int __bam_copy(DB *dbp___1 , PAGE *pp , PAGE *cp , u_int32_t nxt , u_int32_t stop ) ;
int __bam_split_read(DB_ENV *dbenv___0 , void *recbuf , __bam_split_args **argpp ) ;
int __bam_rsplit_read(DB_ENV *dbenv___0 , void *recbuf , __bam_rsplit_args **argpp ) ;
int __bam_adj_read(DB_ENV *dbenv___0 , void *recbuf , __bam_adj_args **argpp ) ;
int __bam_cadjust_read(DB_ENV *dbenv___0 , void *recbuf , __bam_cadjust_args **argpp ) ;
int __bam_cdel_read(DB_ENV *dbenv___0 , void *recbuf , __bam_cdel_args **argpp ) ;
int __bam_repl_read(DB_ENV *dbenv___0 , void *recbuf , __bam_repl_args **argpp ) ;
int __bam_root_read(DB_ENV *dbenv___0 , void *recbuf , __bam_root_args **argpp ) ;
int __bam_curadj_read(DB_ENV *dbenv___0 , void *recbuf , __bam_curadj_args **argpp ) ;
int __bam_rcuradj_read(DB_ENV *dbenv___0 , void *recbuf , __bam_rcuradj_args **argpp ) ;
int __db_cursor_int(DB *dbp___1 , DB_TXN *txn , DBTYPE dbtype , db_pgno_t root , int is_opd ,
                    u_int32_t lockerid , DBC **dbcp ) ;
int __dbreg_id_to_db(DB_ENV *dbenv___0 , DB_TXN *txn , DB **dbpp , int32_t ndx , int inc ) ;
int __bam_split_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __bam_split_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *_lp ;
  PAGE *lp ;
  PAGE *np ;
  PAGE *pp ;
  PAGE *_rp ;
  PAGE *rp ;
  PAGE *sp ;
  db_pgno_t pgno ;
  db_pgno_t root_pgno ;
  u_int32_t ptype ;
  int cmp ;
  int l_update ;
  int p_update ;
  int r_update ;
  int rc ;
  int ret ;
  int ret_l ;
  int rootsplit ;
  int t_ret ;
  int tmp ;
  db_recno_t tmp___2 ;
  db_recno_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  mpf = (DB_MPOOLFILE *)((void *)0);
  rp = (PAGE *)((void *)0);
  _rp = rp;
  pp = _rp;
  np = pp;
  lp = np;
  _lp = lp;
  sp = (PAGE *)((void *)0);
  while (1) {
    argp = (__bam_split_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_split_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __os_malloc(dbenv___0, argp->pg.size, (void *)(& sp));
  if (ret != 0) {
    goto out;
  }
  memcpy((void * __restrict  )sp, (void const   * __restrict  )argp->pg.data, argp->pg.size);
  pgno = sp->pgno;
  root_pgno = argp->root_pgno;
  rootsplit = root_pgno != 0U;
  ret_l = __memp_fget(mpf, & argp->left, 0U, (void *)(& lp));
  if (ret_l != 0) {
    lp = (PAGE *)((void *)0);
  }
  tmp = __memp_fget(mpf, & argp->right, 0U, (void *)(& rp));
  if (tmp != 0) {
    rp = (PAGE *)((void *)0);
  }
  if ((int )op == 4) {
    goto _L___6;
  } else {
    if ((int )op == 1) {
      _L___6: 
      p_update = 0;
      r_update = p_update;
      l_update = r_update;
      if (rootsplit) {
        ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pp));
        if (ret != 0) {
          ret = __db_pgerr(file_dbp, pgno, ret);
          pp = (PAGE *)((void *)0);
          goto out;
        }
        cmp = log_compare((DB_LSN const   *)(& pp->lsn), (DB_LSN const   *)(& ((PAGE *)argp->pg.data)->lsn));
        if ((int )op == 4) {
          goto _L;
        } else {
          if ((int )op == 1) {
            _L: 
            if (cmp < 0) {
              if (pp->lsn.file == 0U) {
                if (! (pp->lsn.offset == 1U)) {
                  __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                           (unsigned long )pp->lsn.file, (unsigned long )pp->lsn.offset,
                           (unsigned long )((PAGE *)argp->pg.data)->lsn.file, (unsigned long )((PAGE *)argp->pg.data)->lsn.offset);
                  ret = 22;
                  goto out;
                }
              } else {
                __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                         (unsigned long )pp->lsn.file, (unsigned long )pp->lsn.offset,
                         (unsigned long )((PAGE *)argp->pg.data)->lsn.file, (unsigned long )((PAGE *)argp->pg.data)->lsn.offset);
                ret = 22;
                goto out;
              }
            }
          }
        }
        p_update = cmp == 0;
      } else {
        if ((unsigned int )lp == (unsigned int )((void *)0)) {
          ret = __db_pgerr(file_dbp, argp->left, ret_l);
          goto out;
        }
      }
      if ((unsigned int )lp != (unsigned int )((void *)0)) {
        cmp = log_compare((DB_LSN const   *)(& lp->lsn), (DB_LSN const   *)(& argp->llsn));
        if ((int )op == 4) {
          goto _L___0;
        } else {
          if ((int )op == 1) {
            _L___0: 
            if (cmp < 0) {
              if (lp->lsn.file == 0U) {
                if (! (lp->lsn.offset == 1U)) {
                  __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                           (unsigned long )lp->lsn.file, (unsigned long )lp->lsn.offset,
                           (unsigned long )argp->llsn.file, (unsigned long )argp->llsn.offset);
                  ret = 22;
                  goto out;
                }
              } else {
                __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                         (unsigned long )lp->lsn.file, (unsigned long )lp->lsn.offset,
                         (unsigned long )argp->llsn.file, (unsigned long )argp->llsn.offset);
                ret = 22;
                goto out;
              }
            }
          }
        }
        if (cmp == 0) {
          l_update = 1;
        }
      } else {
        l_update = 1;
      }
      if ((unsigned int )rp != (unsigned int )((void *)0)) {
        cmp = log_compare((DB_LSN const   *)(& rp->lsn), (DB_LSN const   *)(& argp->rlsn));
        if ((int )op == 4) {
          goto _L___1;
        } else {
          if ((int )op == 1) {
            _L___1: 
            if (cmp < 0) {
              if (rp->lsn.file == 0U) {
                if (! (rp->lsn.offset == 1U)) {
                  __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                           (unsigned long )rp->lsn.file, (unsigned long )rp->lsn.offset,
                           (unsigned long )argp->rlsn.file, (unsigned long )argp->rlsn.offset);
                  ret = 22;
                  goto out;
                }
              } else {
                __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                         (unsigned long )rp->lsn.file, (unsigned long )rp->lsn.offset,
                         (unsigned long )argp->rlsn.file, (unsigned long )argp->rlsn.offset);
                ret = 22;
                goto out;
              }
            }
          }
        }
        if (cmp == 0) {
          r_update = 1;
        }
      } else {
        r_update = 1;
      }
      if (! p_update) {
        if (! l_update) {
          if (! r_update) {
            goto check_next;
          }
        }
      }
      ret = __os_malloc(dbenv___0, file_dbp->pgsize, (void *)(& _lp));
      if (ret != 0) {
        goto out;
      } else {
        ret = __os_malloc(dbenv___0, file_dbp->pgsize, (void *)(& _rp));
        if (ret != 0) {
          goto out;
        }
      }
      if (rootsplit) {
        while (1) {
          _lp->pgno = argp->left;
          _lp->prev_pgno = 0U;
          if ((int )sp->type == 3) {
            _lp->next_pgno = 0U;
          } else {
            if ((int )sp->type == 4) {
              _lp->next_pgno = 0U;
            } else {
              _lp->next_pgno = argp->right;
            }
          }
          _lp->entries = (unsigned short)0;
          _lp->hf_offset = (unsigned short )file_dbp->pgsize;
          _lp->level = sp->level;
          _lp->type = sp->type;
          break;
        }
        while (1) {
          _rp->pgno = argp->right;
          if ((int )sp->type == 3) {
            _rp->prev_pgno = 0U;
          } else {
            if ((int )sp->type == 4) {
              _rp->prev_pgno = 0U;
            } else {
              _rp->prev_pgno = argp->left;
            }
          }
          _rp->next_pgno = 0U;
          _rp->entries = (unsigned short)0;
          _rp->hf_offset = (unsigned short )file_dbp->pgsize;
          _rp->level = sp->level;
          _rp->type = sp->type;
          break;
        }
      } else {
        while (1) {
          _lp->pgno = sp->pgno;
          if ((int )sp->type == 3) {
            _lp->prev_pgno = 0U;
          } else {
            if ((int )sp->type == 4) {
              _lp->prev_pgno = 0U;
            } else {
              _lp->prev_pgno = sp->prev_pgno;
            }
          }
          if ((int )sp->type == 3) {
            _lp->next_pgno = 0U;
          } else {
            if ((int )sp->type == 4) {
              _lp->next_pgno = 0U;
            } else {
              _lp->next_pgno = argp->right;
            }
          }
          _lp->entries = (unsigned short)0;
          _lp->hf_offset = (unsigned short )file_dbp->pgsize;
          _lp->level = sp->level;
          _lp->type = sp->type;
          break;
        }
        while (1) {
          _rp->pgno = argp->right;
          if ((int )sp->type == 3) {
            _rp->prev_pgno = 0U;
          } else {
            if ((int )sp->type == 4) {
              _rp->prev_pgno = 0U;
            } else {
              _rp->prev_pgno = sp->pgno;
            }
          }
          if ((int )sp->type == 3) {
            _rp->next_pgno = 0U;
          } else {
            if ((int )sp->type == 4) {
              _rp->next_pgno = 0U;
            } else {
              _rp->next_pgno = sp->next_pgno;
            }
          }
          _rp->entries = (unsigned short)0;
          _rp->hf_offset = (unsigned short )file_dbp->pgsize;
          _rp->level = sp->level;
          _rp->type = sp->type;
          break;
        }
      }
      ret = __bam_copy(file_dbp, sp, _lp, 0U, argp->indx);
      if (ret != 0) {
        goto out;
      } else {
        ret = __bam_copy(file_dbp, sp, _rp, argp->indx, (unsigned int )sp->entries);
        if (ret != 0) {
          goto out;
        }
      }
      if ((unsigned int )lp == (unsigned int )((void *)0)) {
        ret = __memp_fget(mpf, & argp->left, 1U, (void *)(& lp));
        if (ret != 0) {
          ret = __db_pgerr(file_dbp, argp->left, ret);
          lp = (PAGE *)((void *)0);
          goto out;
        }
      }
      if (l_update) {
        memcpy((void * __restrict  )lp, (void const   * __restrict  )_lp, file_dbp->pgsize);
        lp->lsn = (*lsnp);
        ret = __memp_fput(mpf, (void *)lp, 2U);
        if (ret != 0) {
          goto out;
        }
        lp = (PAGE *)((void *)0);
      }
      if ((unsigned int )rp == (unsigned int )((void *)0)) {
        ret = __memp_fget(mpf, & argp->right, 1U, (void *)(& rp));
        if (ret != 0) {
          ret = __db_pgerr(file_dbp, argp->right, ret);
          rp = (PAGE *)((void *)0);
          goto out;
        }
      }
      if (r_update) {
        memcpy((void * __restrict  )rp, (void const   * __restrict  )_rp, file_dbp->pgsize);
        rp->lsn = (*lsnp);
        ret = __memp_fput(mpf, (void *)rp, 2U);
        if (ret != 0) {
          goto out;
        }
        rp = (PAGE *)((void *)0);
      }
      if (rootsplit) {
        if (p_update) {
          if ((int )sp->type == 3) {
            goto _L___2;
          } else {
            if ((int )sp->type == 5) {
              goto _L___2;
            } else {
              if ((int )sp->type == 12) {
                _L___2: 
                ptype = 3U;
                if (argp->opflags & 1U) {
                  rc = 1;
                } else {
                  rc = 0;
                }
              } else {
                ptype = 4U;
                rc = 1;
              }
            }
          }
          while (1) {
            pp->pgno = root_pgno;
            pp->prev_pgno = 0U;
            pp->next_pgno = 0U;
            pp->entries = (unsigned short)0;
            pp->hf_offset = (unsigned short )file_dbp->pgsize;
            pp->level = (unsigned char )((int )_lp->level + 1);
            pp->type = (unsigned char )ptype;
            break;
          }
          if (rc) {
            tmp___2 = __bam_total(file_dbp, _lp);
            tmp___3 = __bam_total(file_dbp, _rp);
            pp->prev_pgno = tmp___2 + tmp___3;
          } else {
            pp->prev_pgno = 0U;
          }
          pp->lsn = (*lsnp);
          ret = __memp_fput(mpf, (void *)pp, 2U);
          if (ret != 0) {
            goto out;
          }
          pp = (PAGE *)((void *)0);
        }
      }
      check_next: 
      if (! rootsplit) {
        if (! (argp->nlsn.file == 0U)) {
          ret = __memp_fget(mpf, & argp->npgno, 0U, (void *)(& np));
          if (ret != 0) {
            ret = __db_pgerr(file_dbp, argp->npgno, ret);
            np = (PAGE *)((void *)0);
            goto out;
          }
          cmp = log_compare((DB_LSN const   *)(& np->lsn), (DB_LSN const   *)(& argp->nlsn));
          if ((int )op == 4) {
            goto _L___3;
          } else {
            if ((int )op == 1) {
              _L___3: 
              if (cmp < 0) {
                if (np->lsn.file == 0U) {
                  if (! (np->lsn.offset == 1U)) {
                    __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                             (unsigned long )np->lsn.file, (unsigned long )np->lsn.offset,
                             (unsigned long )argp->nlsn.file, (unsigned long )argp->nlsn.offset);
                    ret = 22;
                    goto out;
                  }
                } else {
                  __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                           (unsigned long )np->lsn.file, (unsigned long )np->lsn.offset,
                           (unsigned long )argp->nlsn.file, (unsigned long )argp->nlsn.offset);
                  ret = 22;
                  goto out;
                }
              }
            }
          }
          if (cmp == 0) {
            np->prev_pgno = argp->right;
            np->lsn = (*lsnp);
            ret = __memp_fput(mpf, (void *)np, 2U);
            if (ret != 0) {
              goto out;
            }
            np = (PAGE *)((void *)0);
          }
        }
      }
    } else {
      ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pp));
      if (ret != 0) {
        pp = (PAGE *)((void *)0);
        goto lrundo;
      }
      tmp___4 = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pp->lsn));
      if (tmp___4 == 0) {
        memcpy((void * __restrict  )pp, (void const   * __restrict  )argp->pg.data,
               argp->pg.size);
        ret = __memp_fput(mpf, (void *)pp, 2U);
        if (ret != 0) {
          goto out;
        }
        pp = (PAGE *)((void *)0);
      }
      lrundo: 
      if (rootsplit) {
        if ((unsigned int )lp != (unsigned int )((void *)0)) {
          goto _L___4;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: 
        if ((unsigned int )rp != (unsigned int )((void *)0)) {
          _L___4: 
          if (rootsplit) {
            if ((unsigned int )lp != (unsigned int )((void *)0)) {
              tmp___5 = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& lp->lsn));
              if (tmp___5 == 0) {
                lp->lsn = argp->llsn;
                ret = __memp_fput(mpf, (void *)lp, 2U);
                if (ret != 0) {
                  goto out;
                }
                lp = (PAGE *)((void *)0);
              }
            }
          }
          if ((unsigned int )rp != (unsigned int )((void *)0)) {
            tmp___6 = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& rp->lsn));
            if (tmp___6 == 0) {
              rp->lsn = argp->rlsn;
              ret = __memp_fput(mpf, (void *)rp, 2U);
              if (ret != 0) {
                goto out;
              }
              rp = (PAGE *)((void *)0);
            }
          }
        }
      }
      if (! rootsplit) {
        if (! (argp->nlsn.file == 0U)) {
          ret = __memp_fget(mpf, & argp->npgno, 0U, (void *)(& np));
          if (ret != 0) {
            np = (PAGE *)((void *)0);
            goto done;
          }
          tmp___8 = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& np->lsn));
          if (tmp___8 == 0) {
            np->prev_pgno = argp->left;
            np->lsn = argp->nlsn;
            tmp___7 = __memp_fput(mpf, (void *)np, 2U);
            if (tmp___7) {
              goto out;
            }
            np = (PAGE *)((void *)0);
          }
        }
      }
    }
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pp != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)pp, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )lp != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)lp, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )np != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)np, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)rp, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )_lp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)_lp);
  }
  if ((unsigned int )_rp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)_rp);
  }
  if ((unsigned int )sp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)sp);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_rsplit_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __bam_rsplit_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_LSN copy_lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  db_pgno_t root_pgno ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__bam_rsplit_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_rsplit_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  root_pgno = argp->root_pgno;
  pgno = root_pgno;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, pgno, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, pgno, ret);
        goto out;
      }
    }
    ret = 0;
    goto do_page;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->rootlsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->rootlsn.file, (unsigned long )argp->rootlsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->rootlsn.file, (unsigned long )argp->rootlsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pgdbt.data,
             argp->pgdbt.size);
      pagep->pgno = root_pgno;
      pagep->lsn = (*lsnp);
      modified = 1;
    } else {
      if ((int )op == 1) {
        memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pgdbt.data,
               argp->pgdbt.size);
        pagep->pgno = root_pgno;
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            while (1) {
              pagep->pgno = root_pgno;
              pagep->prev_pgno = argp->nrec;
              pagep->next_pgno = 0U;
              pagep->entries = (unsigned short)0;
              pagep->hf_offset = (unsigned short )file_dbp->pgsize;
              pagep->level = (unsigned char )((int )pagep->level + 1);
              if ((int )pagep->type == 3) {
                pagep->type = (unsigned char)3;
              } else {
                if ((int )pagep->type == 5) {
                  pagep->type = (unsigned char)3;
                } else {
                  if ((int )pagep->type == 12) {
                    pagep->type = (unsigned char)3;
                  } else {
                    pagep->type = (unsigned char)4;
                  }
                }
              }
              break;
            }
            ret = __db_pitem(dbc, pagep, 0U, argp->rootent.size, & argp->rootent,
                             (DBT *)((void *)0));
            if (ret != 0) {
              goto out;
            }
            pagep->lsn = argp->rootlsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp);
  if (ret != 0) {
    goto out;
  }
  do_page: 
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __db_pgerr(file_dbp, argp->pgno, ret);
    goto out;
  }
  modified = 0;
  __ua_memcpy((void *)(& copy_lsn), (void const   *)(& ((PAGE *)argp->pgdbt.data)->lsn),
              sizeof(DB_LSN ));
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& copy_lsn));
  if ((int )op == 4) {
    goto _L___2;
  } else {
    if ((int )op == 1) {
      _L___2: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )copy_lsn.file, (unsigned long )copy_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )copy_lsn.file, (unsigned long )copy_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
      modified = 1;
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___3;
      }
    }
  } else {
    _L___3: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pgdbt.data,
               argp->pgdbt.size);
        modified = 1;
      } else {
        if ((int )op == 3) {
          memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pgdbt.data,
                 argp->pgdbt.size);
          modified = 1;
        } else {
          if ((int )op == 2) {
            memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pgdbt.data,
                   argp->pgdbt.size);
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_adj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) 
{ __bam_adj_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__bam_adj_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_adj_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __db_pgerr(file_dbp, argp->pgno, ret);
    goto out;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___2;
    } else {
      if ((int )op == 1) {
        _L___2: 
        ret = __bam_adjindx(dbc, pagep, argp->indx, argp->indx_copy, (int )argp->is_insert);
        if (ret != 0) {
          goto out;
        }
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            ret = __bam_adjindx(dbc, pagep, argp->indx, argp->indx_copy, (! argp->is_insert !=
                                                                          0) != 0);
            if (ret != 0) {
              goto out;
            }
            pagep->lsn = argp->lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_cadjust_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __bam_cadjust_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__bam_cadjust_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_cadjust_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __db_pgerr(file_dbp, argp->pgno, ret);
    goto out;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___4;
    } else {
      if ((int )op == 1) {
        _L___4: 
        if ((int )pagep->type == 3) {
          goto _L___0;
        } else {
          if ((int )pagep->type == 5) {
            goto _L___0;
          } else {
            if ((int )pagep->type == 12) {
              _L___0: 
              if (file_dbp->flags & 2048U) {
                tmp___0 = sizeof(PG_CRYPTO );
              } else {
                if (file_dbp->flags & 1U) {
                  tmp___0 = sizeof(PG_CHKSUM );
                } else {
                  tmp___0 = 0U;
                }
              }
              ((BINTERNAL *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                         26) + tmp___0) +
                                                          argp->indx))))->nrecs = ((BINTERNAL *)((u_int8_t *)pagep +
                                                                                                 (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                         26) +
                                                                                                                        tmp___0) +
                                                                                                          argp->indx))))->nrecs +
                                                                                  (unsigned int )argp->adjust;
              if (argp->opflags & 1U) {
                pagep->prev_pgno = pagep->prev_pgno + (unsigned int )argp->adjust;
              }
            } else {
              if (file_dbp->flags & 2048U) {
                tmp___2 = sizeof(PG_CRYPTO );
              } else {
                if (file_dbp->flags & 1U) {
                  tmp___2 = sizeof(PG_CHKSUM );
                } else {
                  tmp___2 = 0U;
                }
              }
              ((RINTERNAL *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                         26) + tmp___2) +
                                                          argp->indx))))->nrecs = ((RINTERNAL *)((u_int8_t *)pagep +
                                                                                                 (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                         26) +
                                                                                                                        tmp___2) +
                                                                                                          argp->indx))))->nrecs +
                                                                                  (unsigned int )argp->adjust;
              if (argp->opflags & 1U) {
                pagep->prev_pgno = pagep->prev_pgno + (unsigned int )argp->adjust;
              }
            }
          }
        }
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___3;
      }
    }
  } else {
    _L___3: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___2;
      } else {
        if ((int )op == 3) {
          goto _L___2;
        } else {
          if ((int )op == 2) {
            _L___2: 
            if ((int )pagep->type == 3) {
              goto _L___1;
            } else {
              if ((int )pagep->type == 5) {
                goto _L___1;
              } else {
                if ((int )pagep->type == 12) {
                  _L___1: 
                  if (file_dbp->flags & 2048U) {
                    tmp___4 = sizeof(PG_CRYPTO );
                  } else {
                    if (file_dbp->flags & 1U) {
                      tmp___4 = sizeof(PG_CHKSUM );
                    } else {
                      tmp___4 = 0U;
                    }
                  }
                  ((BINTERNAL *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                             26) +
                                                                            tmp___4) +
                                                              argp->indx))))->nrecs = ((BINTERNAL *)((u_int8_t *)pagep +
                                                                                                     (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                             26) +
                                                                                                                            tmp___4) +
                                                                                                              argp->indx))))->nrecs -
                                                                                      (unsigned int )argp->adjust;
                  if (argp->opflags & 1U) {
                    pagep->prev_pgno = pagep->prev_pgno + (unsigned int )(- argp->adjust);
                  }
                } else {
                  if (file_dbp->flags & 2048U) {
                    tmp___6 = sizeof(PG_CRYPTO );
                  } else {
                    if (file_dbp->flags & 1U) {
                      tmp___6 = sizeof(PG_CHKSUM );
                    } else {
                      tmp___6 = 0U;
                    }
                  }
                  ((RINTERNAL *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                             26) +
                                                                            tmp___6) +
                                                              argp->indx))))->nrecs = ((RINTERNAL *)((u_int8_t *)pagep +
                                                                                                     (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                             26) +
                                                                                                                            tmp___6) +
                                                                                                              argp->indx))))->nrecs -
                                                                                      (unsigned int )argp->adjust;
                  if (argp->opflags & 1U) {
                    pagep->prev_pgno = pagep->prev_pgno + (unsigned int )(- argp->adjust);
                  }
                }
              }
            }
            pagep->lsn = argp->lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___7 = 2;
  } else {
    tmp___7 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___7);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_cdel_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) 
{ __bam_cdel_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t indx ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__bam_cdel_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_cdel_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __db_pgerr(file_dbp, argp->pgno, ret);
    goto out;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___2;
    } else {
      if ((int )op == 1) {
        _L___2: 
        if ((int )pagep->type == 5) {
          tmp = 1;
        } else {
          tmp = 0;
        }
        indx = argp->indx + (unsigned int )tmp;
        if (file_dbp->flags & 2048U) {
          tmp___1 = sizeof(PG_CRYPTO );
        } else {
          if (file_dbp->flags & 1U) {
            tmp___1 = sizeof(PG_CHKSUM );
          } else {
            tmp___1 = 0U;
          }
        }
        ((BKEYDATA *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                  26) + tmp___1) +
                                                   indx))))->type = (unsigned char )((int )((BKEYDATA *)((u_int8_t *)pagep +
                                                                                                         (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                                 26) +
                                                                                                                                tmp___1) +
                                                                                                                  indx))))->type |
                                                                                     128);
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            if ((int )pagep->type == 5) {
              tmp___2 = 1;
            } else {
              tmp___2 = 0;
            }
            indx = argp->indx + (unsigned int )tmp___2;
            if (file_dbp->flags & 2048U) {
              tmp___4 = sizeof(PG_CRYPTO );
            } else {
              if (file_dbp->flags & 1U) {
                tmp___4 = sizeof(PG_CHKSUM );
              } else {
                tmp___4 = 0U;
              }
            }
            ((BKEYDATA *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                      26) + tmp___4) +
                                                       indx))))->type = (unsigned char )((int )((BKEYDATA *)((u_int8_t *)pagep +
                                                                                                             (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                                     26) +
                                                                                                                                    tmp___4) +
                                                                                                                      indx))))->type &
                                                                                         -129);
            __bam_ca_delete(file_dbp, argp->pgno, argp->indx, 0);
            pagep->lsn = argp->lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___5 = 2;
  } else {
    tmp___5 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___5);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_repl_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) 
{ __bam_repl_args *argp ;
  BKEYDATA *bk ;
  DB *file_dbp ;
  DBC *dbc ;
  DBT dbt ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  u_int8_t *p ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__bam_repl_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_repl_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __db_pgerr(file_dbp, argp->pgno, ret);
    goto out;
  }
  if (file_dbp->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (file_dbp->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                26) + tmp___0) + argp->indx)));
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___2;
    } else {
      if ((int )op == 1) {
        _L___2: 
        memset((void *)(& dbt), 0, sizeof(dbt));
        dbt.size = (argp->prefix + argp->suffix) + argp->repl.size;
        ret = __os_malloc(dbenv___0, dbt.size, (void *)(& dbt.data));
        if (ret != 0) {
          goto out;
        }
        p = (u_int8_t *)dbt.data;
        memcpy((void * __restrict  )p, (void const   * __restrict  )(bk->data), argp->prefix);
        p += argp->prefix;
        memcpy((void * __restrict  )p, (void const   * __restrict  )argp->repl.data,
               argp->repl.size);
        p += argp->repl.size;
        memcpy((void * __restrict  )p, (void const   * __restrict  )(bk->data + ((unsigned int )bk->len -
                                                                                 argp->suffix)),
               argp->suffix);
        ret = __bam_ritem(dbc, pagep, argp->indx, & dbt);
        __os_free(dbenv___0, dbt.data);
        if (ret != 0) {
          goto out;
        }
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            memset((void *)(& dbt), 0, sizeof(dbt));
            dbt.size = (argp->prefix + argp->suffix) + argp->orig.size;
            ret = __os_malloc(dbenv___0, dbt.size, (void *)(& dbt.data));
            if (ret != 0) {
              goto out;
            }
            p = (u_int8_t *)dbt.data;
            memcpy((void * __restrict  )p, (void const   * __restrict  )(bk->data),
                   argp->prefix);
            p += argp->prefix;
            memcpy((void * __restrict  )p, (void const   * __restrict  )argp->orig.data,
                   argp->orig.size);
            p += argp->orig.size;
            memcpy((void * __restrict  )p, (void const   * __restrict  )(bk->data +
                                                                         ((unsigned int )bk->len -
                                                                          argp->suffix)),
                   argp->suffix);
            ret = __bam_ritem(dbc, pagep, argp->indx, & dbt);
            __os_free(dbenv___0, dbt.data);
            if (ret != 0) {
              goto out;
            }
            if (argp->isdeleted) {
              if (file_dbp->flags & 2048U) {
                tmp___2 = sizeof(PG_CRYPTO );
              } else {
                if (file_dbp->flags & 1U) {
                  tmp___2 = sizeof(PG_CHKSUM );
                } else {
                  tmp___2 = 0U;
                }
              }
              ((BKEYDATA *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                        26) + tmp___2) +
                                                         argp->indx))))->type = (unsigned char )((int )((BKEYDATA *)((u_int8_t *)pagep +
                                                                                                                     (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                                                             26) +
                                                                                                                                            tmp___2) +
                                                                                                                              argp->indx))))->type |
                                                                                                 128);
            }
            pagep->lsn = argp->lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___3 = 2;
  } else {
    tmp___3 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___3);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_root_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) 
{ __bam_root_args *argp ;
  BTMETA *meta ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int __t_ret ;

  {
  meta = (BTMETA *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__bam_root_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_root_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->meta_pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, argp->meta_pgno, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, argp->meta_pgno, ret);
        goto out;
      } else {
        goto done;
      }
    }
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& argp->meta_lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (((PAGE *)meta)->lsn.file == 0U) {
          if (! (((PAGE *)meta)->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                     (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                   (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      meta->root = argp->root_pgno;
      meta->dbmeta.lsn = (*lsnp);
      ((BTREE *)file_dbp->bt_internal)->bt_root = meta->root;
      modified = 1;
    } else {
      if ((int )op == 1) {
        meta->root = argp->root_pgno;
        meta->dbmeta.lsn = (*lsnp);
        ((BTREE *)file_dbp->bt_internal)->bt_root = meta->root;
        modified = 1;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        meta->dbmeta.lsn = argp->meta_lsn;
        modified = 1;
      } else {
        if ((int )op == 3) {
          meta->dbmeta.lsn = argp->meta_lsn;
          modified = 1;
        } else {
          if ((int )op == 2) {
            meta->dbmeta.lsn = argp->meta_lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp);
  if (ret != 0) {
    goto out;
  }
  meta = (BTMETA *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_curadj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __bam_curadj_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  int ret ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  mpf = (DB_MPOOLFILE *)((void *)0);
  mpf = mpf;
  while (1) {
    argp = (__bam_curadj_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_curadj_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = 0;
  if ((int )op != 0) {
    goto done;
  }
  switch ((int )argp->mode) {
  case 1: 
  ret = __bam_ca_di(dbc, argp->from_pgno, argp->from_indx, - ((int )argp->first_indx));
  if (ret != 0) {
    goto out;
  }
  break;
  case 2: 
  ret = __bam_ca_undodup(file_dbp, argp->first_indx, argp->from_pgno, argp->from_indx,
                         argp->to_indx);
  if (ret != 0) {
    goto out;
  }
  break;
  case 3: 
  ret = __bam_ca_rsplit(dbc, argp->to_pgno, argp->from_pgno);
  if (ret != 0) {
    goto out;
  }
  break;
  case 4: 
  __bam_ca_undosplit(file_dbp, argp->from_pgno, argp->to_pgno, argp->left_pgno, argp->from_indx);
  break;
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_rcuradj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __bam_rcuradj_args *argp ;
  BTREE_CURSOR *cp ;
  DB *file_dbp ;
  DBC *dbc ;
  DBC *rdbc ;
  DB_MPOOLFILE *mpf ;
  int ret ;
  int t_ret ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  mpf = (DB_MPOOLFILE *)((void *)0);
  mpf = mpf;
  rdbc = (DBC *)((void *)0);
  while (1) {
    argp = (__bam_rcuradj_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __bam_rcuradj_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  t_ret = 0;
  ret = t_ret;
  if ((int )op != 0) {
    goto done;
  }
  ret = __db_cursor_int(file_dbp, (DB_TXN *)((void *)0), (enum __anonenum_DBTYPE_61 )3,
                        argp->root, 0, 0U, & rdbc);
  if (ret != 0) {
    goto out;
  }
  cp = (BTREE_CURSOR *)rdbc->internal;
  cp->flags = cp->flags | 4U;
  cp->recno = argp->recno;
  switch ((int )argp->mode) {
  case 0: 
  cp->flags = cp->flags | 1U;
  cp->flags = cp->flags | 4U;
  cp->order = argp->order;
  __ram_ca(rdbc, (enum __anonenum_ca_recno_arg_53 )3);
  break;
  case 1: ;
  case 2: ;
  case 3: 
  cp->flags = cp->flags & 4294967294U;
  cp->order = 0U;
  __ram_ca(rdbc, (enum __anonenum_ca_recno_arg_53 )0);
  break;
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )rdbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(rdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-aSSKqzYq.i","-O2")
int __bam_reclaim(DB *dbp___1 , DB_TXN *txn ) ;
int __bam_truncate(DBC *dbc , u_int32_t *countp ) ;
int __bam_traverse(DBC *dbc , db_lockmode_t mode , db_pgno_t root_pgno , int (*callback)(DB * ,
                                                                                         PAGE * ,
                                                                                         void * ,
                                                                                         int * ) ,
                   void *cookie ) ;
int __db_reclaim_callback(DB *dbp___1 , PAGE *p , void *cookie , int *putp ) ;
int __db_truncate_callback(DB *dbp___1 , PAGE *p , void *cookie , int *putp ) ;
int __bam_reclaim(DB *dbp___1 , DB_TXN *txn ) 
{ DBC *dbc ;
  int ret ;
  int t_ret ;

  {
  ret = __db_cursor(dbp___1, txn, & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __bam_traverse(dbc, (enum __anonenum_db_lockmode_t_50 )2, (dbc->internal)->root,
                       & __db_reclaim_callback, (void *)dbc);
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __bam_truncate(DBC *dbc , u_int32_t *countp ) 
{ db_trunc_param trunc ;
  int ret ;

  {
  trunc.count = 0U;
  trunc.dbc = dbc;
  ret = __bam_traverse(dbc, (enum __anonenum_db_lockmode_t_50 )2, (dbc->internal)->root,
                       & __db_truncate_callback, (void *)(& trunc));
  (*countp) = trunc.count;
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-huDqtj7c.i","-O2")
extern  __attribute__((__nothrow__)) int _IO_getc(_IO_FILE *__fp ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
int __db_appname(DB_ENV *dbenv___0 , APPNAME appname , char const   *file , u_int32_t tmp_oflags ,
                 DB_FH **fhpp , char **namep ) ;
void __os_ufree(DB_ENV *dbenv___0 , void *ptr ) ;
int __ram_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               u_int32_t flags ) ;
int __ram_append(DBC *dbc , DBT *key , DBT *data ) ;
int __ram_writeback(DB *dbp___1 ) ;
int __bam_nrecs(DBC *dbc , db_recno_t *rep ) ;
int __bam_rcuradj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      ca_recno_arg mode , db_pgno_t root , db_recno_t recno , u_int32_t order ) ;
int __db_get(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) ;
static int __ram_add(DBC *dbc , db_recno_t *recnop , DBT *data , u_int32_t flags ,
                     u_int32_t bi_flags ) ;
static int __ram_source(DB *dbp___1 ) ;
static int __ram_sread(DBC *dbc , db_recno_t top ) ;
static int __ram_update(DBC *dbc , db_recno_t recno , int can_create ) ;
int __ram_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               u_int32_t flags ) 
{ BTREE *t ;
  DBC *dbc ;
  int ret ;
  int t_ret ;

  {
  name = (char const   *)((void *)0);
  name = name;
  t = (BTREE *)dbp___1->bt_internal;
  ret = __bam_read_root(dbp___1, txn, base_pgno, flags);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )t->re_source != (unsigned int )((void *)0)) {
    ret = __ram_source(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  if (dbp___1->flags & 67108864U) {
    ret = __db_cursor(dbp___1, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      return (ret);
    }
    ret = __ram_update(dbc, 4294967295U, 0);
    if (ret != 0) {
      if (ret == -30990) {
        ret = 0;
      }
    }
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __ram_append(DBC *dbc , DBT *key , DBT *data ) 
{ BTREE_CURSOR *cp ;
  int ret ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = __ram_update(dbc, 4294967295U, 0);
  if (ret == 0) {
    ret = __ram_add(dbc, & cp->recno, data, 2U, 0U);
  } else {
    if (ret == -30990) {
      ret = __ram_add(dbc, & cp->recno, data, 2U, 0U);
    }
  }
  if (ret == 0) {
    ret = __db_retcopy((dbc->dbp)->dbenv, key, (void *)(& cp->recno), sizeof(cp->recno),
                       & (dbc->rkey)->data, & (dbc->rkey)->ulen);
  }
  return (ret);
}
}
int __ram_c_del(DBC *dbc ) 
{ BKEYDATA bk ;
  BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_LSN lsn ;
  DBT hdr ;
  DBT data ;
  EPG *epg ;
  int exact ;
  int ret ;
  int stack ;
  int t_ret ;
  int tmp ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  t = (BTREE *)dbp___1->bt_internal;
  stack = 0;
  if (cp->flags & 4U) {
    if (cp->flags & 1U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  if (tmp) {
    return (-30997);
  }
  ret = __bam_rsearch(dbc, & cp->recno, 5506U, 1, & exact);
  if (ret != 0) {
    goto err;
  }
  if (! exact) {
    ret = -30990;
    goto err;
  }
  stack = 1;
  cp->page = (void *)(cp->csp)->page;
  cp->pgno = ((cp->csp)->page)->pgno;
  cp->indx = (cp->csp)->indx;
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  cp->lock = (cp->csp)->lock;
  cp->lock_mode = (cp->csp)->lock_mode;
  if (dbp___1->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  if ((int )((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                         26) + tmp___1) +
                                                          (int )cp->indx))))->type &
      128) {
    ret = -30997;
    goto err;
  }
  if (cp->flags & 4U) {
    ret = __bam_ditem(dbc, (PAGE *)cp->page, (unsigned int )cp->indx);
    if (ret != 0) {
      goto err;
    }
    ret = __bam_adjust(dbc, -1);
    if (ret != 0) {
      goto err;
    }
    tmp___2 = __ram_ca(dbc, (enum __anonenum_ca_recno_arg_53 )0);
    if (tmp___2 > 0) {
      if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 16U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                       516U)) {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
                if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                  ret = __bam_rcuradj_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_ca_recno_arg_53 )0,
                                          cp->root, cp->recno, cp->order);
                  if (ret != 0) {
                    goto err;
                  }
                }
              }
            }
          }
        }
      }
    }
    if ((int )((PAGE *)cp->page)->entries == 0) {
      if (((PAGE *)cp->page)->pgno != cp->root) {
        epg = cp->csp;
        while ((unsigned int )epg >= (unsigned int )cp->sp) {
          if ((int )(epg->page)->entries > 1) {
            break;
          }
          epg --;
        }
        ret = __bam_dpages(dbc, epg);
        stack = 0;
        cp->page = (void *)0;
      }
    }
  } else {
    ret = __bam_ditem(dbc, (PAGE *)cp->page, (unsigned int )cp->indx);
    if (ret != 0) {
      goto err;
    }
    bk.type = (unsigned char)1;
    bk.type = (unsigned char )((int )bk.type | 128);
    bk.len = (unsigned short)0;
    memset((void *)(& hdr), 0, sizeof(hdr));
    hdr.data = (void *)(& bk);
    hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])));
    memset((void *)(& data), 0, sizeof(data));
    data.data = (void *)"";
    data.size = 0U;
    ret = __db_pitem(dbc, (PAGE *)cp->page, (unsigned int )cp->indx, (unsigned int )((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                                            sizeof(u_int32_t )) -
                                                                                                           1U) &
                                                                                     ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                        1ULL)),
                     & hdr, & data);
    if (ret != 0) {
      goto err;
    }
  }
  t->re_modified = 1;
  err: 
  if (stack) {
    t_ret = __bam_stkrel(dbc, 1U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __ram_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  int cmp ;
  int exact ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___3 ;

  {
  pgnop = (db_pgno_t *)((void *)0);
  pgnop = pgnop;
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  flags &= 4093640703U;
  retry: 
  switch ((int )flags) {
  case 7: ;
  if (cp->flags & 4U) {
    if (cp->flags & 1U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  if (tmp) {
    return (-30997);
  }
  break;
  case 19: ;
  if (! (dbc->flags & 8U)) {
    return (-30990);
  }
  case 20: ;
  case 18: 
  flags = 18U;
  if (cp->flags & 4U) {
    if (cp->flags & 1U) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  if (tmp___0) {
    if (cp->flags & 4U) {
      cp->flags = cp->flags & 4294967294U;
      cp->order = 0U;
    }
    break;
  }
  if (cp->recno != 0U) {
    cp->recno = cp->recno + 1U;
    break;
  }
  case 9: 
  flags = 18U;
  cp->recno = 1U;
  break;
  case 26: ;
  case 25: 
  flags = 25U;
  if (cp->recno != 0U) {
    if (cp->recno == 1U) {
      ret = -30990;
      goto err;
    }
    cp->recno = cp->recno - 1U;
    break;
  }
  case 17: 
  flags = 25U;
  ret = __ram_update(dbc, 4294967295U, 0);
  if (ret != 0) {
    if (ret != -30990) {
      goto err;
    }
  }
  ret = __bam_nrecs(dbc, & cp->recno);
  if (ret != 0) {
    goto err;
  }
  if (cp->recno == 0U) {
    ret = -30990;
    goto err;
  }
  break;
  case 11: ;
  if (dbc->flags & 8U) {
    cp->recno = cp->recno + 1U;
    break;
  }
  ret = -30990;
  goto err;
  case 10: ;
  case 12: ;
  if (dbc->flags & 8U) {
    cp->recno = 1U;
    break;
  }
  case 28: ;
  case 30: 
  ret = __ram_getno(dbc, (DBT const   *)key, & cp->recno, 0);
  if (ret != 0) {
    goto err;
  }
  break;
  default: 
  ret = __db_unknown_flag(dbp___1->dbenv, (char *)"__ram_c_get", flags);
  goto err;
  }
  if (flags == 18U) {
    goto _L;
  } else {
    if (flags == 7U) {
      _L: 
      ret = __ram_update(dbc, cp->recno, 0);
      if (ret != 0) {
        if (ret != -30990) {
          goto err;
        }
      }
    }
  }
  while (1) {
    if (dbc->flags & 32U) {
      tmp___1 = 386;
    } else {
      tmp___1 = 385;
    }
    ret = __bam_rsearch(dbc, & cp->recno, (unsigned int )tmp___1, 1, & exact);
    if (ret != 0) {
      goto err;
    }
    if (! exact) {
      ret = -30990;
      goto err;
    }
    cp->page = (void *)(cp->csp)->page;
    cp->pgno = ((cp->csp)->page)->pgno;
    cp->indx = (cp->csp)->indx;
    if (cp->lock.off != 0U) {
      __db_lput(dbc, & cp->lock);
    }
    cp->lock = (cp->csp)->lock;
    cp->lock_mode = (cp->csp)->lock_mode;
    if (dbp___1->flags & 2048U) {
      tmp___3 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___3 = sizeof(PG_CHKSUM );
      } else {
        tmp___3 = 0U;
      }
    }
    if ((int )((BKEYDATA *)((u_int8_t *)cp->page + (int )(*((db_indx_t *)(((u_int8_t *)cp->page +
                                                                           26) + tmp___3) +
                                                            (int )cp->indx))))->type &
        128) {
      switch ((int )flags) {
      case 18: ;
      case 25: 
      __bam_stkrel(dbc, 1U);
      goto retry;
      case 10: ;
      case 12: ;
      if (dbc->flags & 8U) {
        __bam_stkrel(dbc, 1U);
        goto __Cont;
      }
      ret = -30990;
      goto err;
      default: 
      ret = -30997;
      goto err;
      }
    }
    if (flags == 10U) {
      goto _L___0;
    } else {
      if (flags == 11U) {
        goto _L___0;
      } else {
        if (flags == 12U) {
          _L___0: 
          ret = __bam_cmp(dbp___1, (DBT const   *)data, (PAGE *)cp->page, (unsigned int )cp->indx,
                          & __bam_defcmp, & cmp);
          if (ret != 0) {
            return (ret);
          }
          if (cmp == 0) {
            break;
          }
          if (! (dbc->flags & 8U)) {
            ret = -30990;
            goto err;
          }
          __bam_stkrel(dbc, 1U);
        } else {
          break;
        }
      }
    }
    __Cont: 
    cp->recno = cp->recno + 1U;
  }
  if (! (dbc->flags & 8U)) {
    if (flags != 10U) {
      if (flags != 12U) {
        if (flags != 28U) {
          if (flags != 30U) {
            ret = __db_retcopy(dbp___1->dbenv, key, (void *)(& cp->recno), sizeof(cp->recno),
                               & (dbc->rkey)->data, & (dbc->rkey)->ulen);
          }
        }
      }
    }
    key->flags = key->flags | 2U;
  }
  err: 
  if (cp->flags & 4U) {
    cp->flags = cp->flags & 4294967294U;
    cp->order = 0U;
  }
  return (ret);
}
}
int __ram_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_LSN lsn ;
  int exact ;
  int nc ;
  int ret ;
  int t_ret ;
  u_int32_t iiflags ;
  void *arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pgnop = (db_pgno_t *)((void *)0);
  pgnop = pgnop;
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  if (dbc->flags & 8U) {
    switch ((int )flags) {
    case 15: 
    cp->recno = 1U;
    flags = 3U;
    break;
    case 16: 
    ret = __ram_add(dbc, & cp->recno, data, 2U, 0U);
    if (ret != 0) {
      return (ret);
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
              if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                ret = __bam_rcuradj_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_ca_recno_arg_53 )3,
                                        cp->root, cp->recno, cp->order);
                if (ret != 0) {
                  return (ret);
                }
              }
            }
          }
        }
      }
    }
    return (0);
    default: ;
    break;
    }
  }
  if (flags == 15U) {
    goto _L___1;
  } else {
    if (flags == 16U) {
      _L___1: 
      ret = __ram_getno(dbc, (DBT const   *)key, & cp->recno, 1);
      if (ret == 0) {
        ret = __ram_add(dbc, & cp->recno, data, 0U, 0U);
      } else {
        if (ret == -30990) {
          ret = __ram_add(dbc, & cp->recno, data, 0U, 0U);
        }
      }
      return (ret);
    }
  }
  if (cp->flags & 4U) {
    if (cp->flags & 1U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  if (tmp) {
    iiflags = 3U;
  } else {
    iiflags = flags;
  }
  split: 
  ret = __bam_rsearch(dbc, & cp->recno, 12802U, 1, & exact);
  if (ret != 0) {
    goto err;
  }
  cp->page = (void *)(cp->csp)->page;
  cp->pgno = ((cp->csp)->page)->pgno;
  cp->indx = (cp->csp)->indx;
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  cp->lock = (cp->csp)->lock;
  cp->lock_mode = (cp->csp)->lock_mode;
  ret = __bam_iitem(dbc, key, data, iiflags, 0U);
  t_ret = __bam_stkrel(dbc, 1U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    } else {
      if (ret == -30896) {
        ret = t_ret;
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: 
    if (ret == -30896) {
      arg = (void *)(& cp->recno);
      ret = __bam_split(dbc, arg, (db_pgno_t *)((void *)0));
      if (ret != 0) {
        goto err;
      }
      goto split;
    }
  }
  if (ret != 0) {
    goto err;
  }
  switch ((int )flags) {
  case 1: 
  nc = __ram_ca(dbc, (enum __anonenum_ca_recno_arg_53 )1);
  if (iiflags == 1U) {
    cp->recno = cp->recno + 1U;
  }
  if (nc > 0) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            _L___4: 
            if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
              if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                ret = __bam_rcuradj_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_ca_recno_arg_53 )1,
                                        cp->root, cp->recno, cp->order);
                if (ret != 0) {
                  goto err;
                }
              }
            }
          }
        }
      }
    }
  }
  break;
  case 3: 
  nc = __ram_ca(dbc, (enum __anonenum_ca_recno_arg_53 )2);
  cp->recno = cp->recno - 1U;
  if (nc > 0) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___6;
              }
            } else {
              goto _L___6;
            }
          } else {
            _L___6: 
            if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
              if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                ret = __bam_rcuradj_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_ca_recno_arg_53 )2,
                                        cp->root, cp->recno, cp->order);
                if (ret != 0) {
                  goto err;
                }
              }
            }
          }
        }
      }
    }
  }
  break;
  case 7: ;
  if (cp->flags & 4U) {
    if (cp->flags & 1U) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  if (tmp___0) {
    tmp___1 = __ram_ca(dbc, (enum __anonenum_ca_recno_arg_53 )3);
    if (tmp___1 > 0) {
      if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 16U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                       516U)) {
                  goto _L___8;
                }
              } else {
                goto _L___8;
              }
            } else {
              _L___8: 
              if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
                if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                  ret = __bam_rcuradj_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_ca_recno_arg_53 )3,
                                          cp->root, cp->recno, cp->order);
                  if (ret != 0) {
                    goto err;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  break;
  default: ;
  break;
  }
  if (! (dbc->flags & 8U)) {
    if (flags == 1U) {
      ret = __db_retcopy(dbp___1->dbenv, key, (void *)(& cp->recno), sizeof(cp->recno),
                         & (dbc->rkey)->data, & (dbc->rkey)->ulen);
    } else {
      if (flags == 3U) {
        ret = __db_retcopy(dbp___1->dbenv, key, (void *)(& cp->recno), sizeof(cp->recno),
                           & (dbc->rkey)->data, & (dbc->rkey)->ulen);
      }
    }
  }
  err: 
  if (cp->flags & 4U) {
    cp->flags = cp->flags & 4294967294U;
    cp->order = 0U;
  }
  return (ret);
}
}
int __ram_ca(DBC *dbc_arg , ca_recno_arg op ) 
{ BTREE_CURSOR *cp ;
  BTREE_CURSOR *cp_arg ;
  DB *dbp___1 ;
  DB *ldbp ;
  DB_ENV *dbenv___0 ;
  DBC *dbc ;
  db_recno_t recno ;
  int adjusted ;
  int found ;
  u_int32_t order ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  dbp___1 = dbc_arg->dbp;
  dbenv___0 = dbp___1->dbenv;
  cp_arg = (BTREE_CURSOR *)dbc_arg->internal;
  recno = cp_arg->recno;
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if ((int )op == 0) {
    order = 1U;
    ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
    while (1) {
      if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
        if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
          break;
        }
      } else {
        break;
      }
      if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbp___1->mutexp)->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
        }
      }
      dbc = ldbp->active_queue.tqh_first;
      while ((unsigned int )dbc != (unsigned int )((void *)0)) {
        cp = (BTREE_CURSOR *)dbc->internal;
        if (cp_arg->root == cp->root) {
          if (recno == cp->recno) {
            if (cp->flags & 4U) {
              if (cp->flags & 1U) {
                tmp = 1;
              } else {
                tmp = 0;
              }
            } else {
              tmp = 0;
            }
            if (tmp) {
              if (order <= cp->order) {
                order = cp->order + 1U;
              }
            }
          }
        }
        dbc = dbc->links.tqe_next;
      }
      if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbp___1->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
        }
      }
      ldbp = ldbp->dblistlinks.le_next;
    }
  } else {
    order = 0U;
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      cp = (BTREE_CURSOR *)dbc->internal;
      if (cp_arg->root != cp->root) {
        goto __Cont;
      }
      found ++;
      adjusted = 0;
      switch ((int )op) {
      case 0: ;
      if (recno < cp->recno) {
        cp->recno = cp->recno - 1U;
        if (recno == cp->recno) {
          if (cp->flags & 4U) {
            if (cp->flags & 1U) {
              tmp___0 = 1;
            } else {
              tmp___0 = 0;
            }
          } else {
            tmp___0 = 0;
          }
          if (tmp___0) {
            cp->order = cp->order + order;
          }
        }
      } else {
        if (recno == cp->recno) {
          if (cp->flags & 4U) {
            if (cp->flags & 1U) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
          } else {
            tmp___1 = 0;
          }
          if (! tmp___1) {
            if (cp->flags & 4U) {
              cp->flags = cp->flags | 1U;
            }
            cp->order = order;
          }
        }
      }
      break;
      case 2: ;
      if (cp_arg->recno == cp->recno) {
        if (cp_arg->flags & 4U) {
          if (cp_arg->flags & 1U) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
        } else {
          tmp___2 = 0;
        }
        if (cp->flags & 4U) {
          if (cp->flags & 1U) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        if (tmp___2 == tmp___3) {
          if (cp_arg->flags & 4U) {
            if (cp_arg->flags & 1U) {
              tmp___4 = 1;
            } else {
              tmp___4 = 0;
            }
          } else {
            tmp___4 = 0;
          }
          if (tmp___4) {
            if (cp_arg->order == cp->order) {
              cp->recno = cp->recno + 1U;
              adjusted = 1;
            }
          } else {
            cp->recno = cp->recno + 1U;
            adjusted = 1;
          }
        }
      }
      goto iafter;
      case 3: ;
      if (cp_arg->recno == cp->recno) {
        if (cp_arg->flags & 4U) {
          if (cp_arg->flags & 1U) {
            tmp___5 = 1;
          } else {
            tmp___5 = 0;
          }
        } else {
          tmp___5 = 0;
        }
        if (cp->flags & 4U) {
          if (cp->flags & 1U) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (tmp___5 == tmp___6) {
          if (cp_arg->flags & 4U) {
            if (cp_arg->flags & 1U) {
              tmp___7 = 1;
            } else {
              tmp___7 = 0;
            }
          } else {
            tmp___7 = 0;
          }
          if (tmp___7) {
            if (cp_arg->order == cp->order) {
              _L: 
              if (cp->flags & 4U) {
                cp->flags = cp->flags & 4294967294U;
                cp->order = 0U;
              }
              break;
            }
          } else {
            goto _L;
          }
        }
      }
      case 1: ;
      iafter: 
      if (! adjusted) {
        if (cp_arg->recno < cp->recno) {
          cp->recno = cp->recno + 1U;
          adjusted = 1;
        } else {
          if (cp_arg->recno == cp->recno) {
            if (cp_arg->flags & 4U) {
              if (cp_arg->flags & 1U) {
                tmp___8 = 1;
              } else {
                tmp___8 = 0;
              }
            } else {
              tmp___8 = 0;
            }
            if (tmp___8) {
              if (cp->flags & 4U) {
                if (cp->flags & 1U) {
                  tmp___9 = 1;
                } else {
                  tmp___9 = 0;
                }
              } else {
                tmp___9 = 0;
              }
              if (tmp___9) {
                if (cp_arg->order < cp->order) {
                  cp->recno = cp->recno + 1U;
                  adjusted = 1;
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            } else {
              _L___1: 
              if (cp_arg->flags & 4U) {
                if (cp_arg->flags & 1U) {
                  tmp___10 = 1;
                } else {
                  tmp___10 = 0;
                }
              } else {
                tmp___10 = 0;
              }
              if (tmp___10) {
                if (cp->flags & 4U) {
                  if (cp->flags & 1U) {
                    tmp___11 = 1;
                  } else {
                    tmp___11 = 0;
                  }
                } else {
                  tmp___11 = 0;
                }
                if (! tmp___11) {
                  cp->recno = cp->recno + 1U;
                  adjusted = 1;
                }
              }
            }
          }
        }
      }
      if (recno == cp->recno) {
        if (adjusted) {
          cp->order = cp->order - (cp_arg->order - 1U);
        }
      }
      break;
      }
      __Cont: 
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbp___1->dbenv, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (found);
}
}
int __ram_getno(DBC *dbc , DBT const   *key , db_recno_t *rep , int can_create ) 
{ DB *dbp___1 ;
  db_recno_t recno ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  recno = (*((db_recno_t *)key->data));
  if (recno == 0U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "illegal record number of 0");
    return (22);
  }
  if ((unsigned int )rep != (unsigned int )((void *)0)) {
    (*rep) = recno;
  }
  if ((int )dbc->dbtype == 3) {
    tmp___0 = __ram_update(dbc, recno, can_create);
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int __ram_update(DBC *dbc , db_recno_t recno , int can_create ) 
{ BTREE *t ;
  DB *dbp___1 ;
  DBT *rdata ;
  db_recno_t nrecs ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  t = (BTREE *)dbp___1->bt_internal;
  if (! can_create) {
    if (t->re_eof) {
      return (0);
    }
  }
  ret = __bam_nrecs(dbc, & nrecs);
  if (ret != 0) {
    return (ret);
  }
  if (! t->re_eof) {
    if (recno > nrecs) {
      ret = __ram_sread(dbc, recno);
      if (ret != 0) {
        if (ret != -30990) {
          return (ret);
        }
      }
      ret = __bam_nrecs(dbc, & nrecs);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if (! can_create) {
    return (0);
  } else {
    if (recno <= nrecs + 1U) {
      return (0);
    }
  }
  rdata = & dbc->my_rdata;
  rdata->flags = 0U;
  rdata->size = 0U;
  while (1) {
    nrecs ++;
    if (! (recno > nrecs)) {
      break;
    }
    ret = __ram_add(dbc, & nrecs, rdata, 0U, 1U);
    if (ret != 0) {
      return (ret);
    }
  }
  return (0);
}
}
static int __ram_source(DB *dbp___1 ) 
{ BTREE *t ;
  char *source ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;

  {
  t = (BTREE *)dbp___1->bt_internal;
  ret = __db_appname(dbp___1->dbenv, (enum __anonenum_APPNAME_39 )1, (char const   *)t->re_source,
                     0U, (DB_FH **)((void *)0), & source);
  if (ret != 0) {
    return (ret);
  }
  __os_free(dbp___1->dbenv, (void *)t->re_source);
  t->re_source = source;
  t->re_fp = fopen((char const   * __restrict  )t->re_source, (char const   * __restrict  )"r");
  if ((unsigned int )t->re_fp == (unsigned int )((void *)0)) {
    tmp = __errno_location();
    ret = (*tmp);
    tmp___0 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbp___1->dbenv, "%s: %s", t->re_source, tmp___0);
    return (ret);
  }
  t->re_eof = 0;
  return (0);
}
}
int __ram_writeback(DB *dbp___1 ) 
{ BTREE *t ;
  DB_ENV *dbenv___0 ;
  DBC *dbc ;
  DBT key ;
  DBT data ;
  FILE *fp ;
  db_recno_t keyno ;
  int ret ;
  int t_ret ;
  u_int8_t delim ;
  u_int8_t *pad ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  t = (BTREE *)dbp___1->bt_internal;
  dbenv___0 = dbp___1->dbenv;
  fp = (FILE *)((void *)0);
  pad = (u_int8_t *)((void *)0);
  if (! t->re_modified) {
    return (0);
  }
  if ((unsigned int )t->re_source == (unsigned int )((void *)0)) {
    t->re_modified = 0;
    return (0);
  }
  ret = __db_cursor(dbp___1, (DB_TXN *)((void *)0), & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __ram_update(dbc, 4294967295U, 0);
  if (ret != 0) {
    if (ret != -30990) {
      return (ret);
    }
  }
  if ((unsigned int )t->re_fp != (unsigned int )((void *)0)) {
    tmp___0 = fclose(t->re_fp);
    if (tmp___0 != 0) {
      tmp = __errno_location();
      ret = (*tmp);
      goto err;
    }
    t->re_fp = (FILE *)((void *)0);
  }
  fp = fopen((char const   * __restrict  )t->re_source, (char const   * __restrict  )"w");
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    tmp___1 = __errno_location();
    ret = (*tmp___1);
    tmp___2 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", t->re_source, tmp___2);
    goto err;
  }
  memset((void *)(& key), 0, sizeof(key));
  key.size = sizeof(db_recno_t );
  key.data = (void *)(& keyno);
  memset((void *)(& data), 0, sizeof(data));
  data.flags = data.flags | 16U;
  delim = (unsigned char )t->re_delim;
  if (dbp___1->flags & 4096U) {
    ret = __os_malloc(dbenv___0, t->re_len, (void *)(& pad));
    if (ret != 0) {
      goto err;
    }
    memset((void *)pad, t->re_pad, t->re_len);
  }
  keyno = 1U;
  while (1) {
    ret = __db_get(dbp___1, (DB_TXN *)((void *)0), & key, & data, 0U);
    switch (ret) {
    case 0: ;
    if (data.size != 0U) {
      tmp___3 = fwrite((void const   * __restrict  )data.data, 1U, data.size, (FILE * __restrict  )fp);
      if (tmp___3 != data.size) {
        goto write_err;
      }
    }
    break;
    case -30997: ;
    if (dbp___1->flags & 4096U) {
      tmp___4 = fwrite((void const   * __restrict  )pad, 1U, t->re_len, (FILE * __restrict  )fp);
      if (tmp___4 != t->re_len) {
        goto write_err;
      }
    }
    break;
    case -30990: 
    ret = 0;
    goto err;
    default: ;
    goto err;
    }
    if (! (dbp___1->flags & 4096U)) {
      tmp___7 = fwrite((void const   * __restrict  )(& delim), 1U, 1U, (FILE * __restrict  )fp);
      if (tmp___7 != 1U) {
        write_err: 
        tmp___5 = __errno_location();
        ret = (*tmp___5);
        tmp___6 = strerror(ret);
        __db_err((DB_ENV const   *)dbp___1->dbenv, "%s: write failed to backing file: %s",
                 t->re_source, tmp___6);
        goto err;
      }
    }
    keyno ++;
  }
  err: 
  if ((unsigned int )fp != (unsigned int )((void *)0)) {
    tmp___11 = fclose(fp);
    if (tmp___11 != 0) {
      if (ret == 0) {
        tmp___8 = __errno_location();
        ret = (*tmp___8);
      }
      tmp___9 = __errno_location();
      tmp___10 = db_strerror((*tmp___9));
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", t->re_source, tmp___10);
    }
  }
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )data.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, data.data);
  }
  if ((unsigned int )pad != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)pad);
  }
  if (ret == 0) {
    t->re_modified = 0;
  }
  return (ret);
}
}
static int __ram_sread(DBC *dbc , db_recno_t top ) 
{ BTREE *t ;
  DB *dbp___1 ;
  DBT data ;
  DBT *rdata ;
  db_recno_t recno ;
  size_t len ;
  int ch ;
  int ret ;
  int was_modified ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  t = (BTREE *)(dbc->dbp)->bt_internal;
  dbp___1 = dbc->dbp;
  was_modified = t->re_modified;
  ret = __bam_nrecs(dbc, & recno);
  if (ret != 0) {
    return (ret);
  }
  if (dbp___1->flags & 4096U) {
    len = t->re_len;
  } else {
    len = 256U;
  }
  rdata = & dbc->my_rkey;
  if (rdata->ulen < len) {
    ret = __os_realloc(dbp___1->dbenv, len, (void *)(& rdata->data));
    if (ret != 0) {
      rdata->ulen = 0U;
      rdata->data = (void *)0;
      return (ret);
    }
    rdata->ulen = len;
  }
  memset((void *)(& data), 0, sizeof(data));
  while (recno < top) {
    data.data = rdata->data;
    data.size = 0U;
    if (dbp___1->flags & 4096U) {
      len = t->re_len;
      while (len > 0U) {
        ch = _IO_getc(t->re_fp);
        if (ch == -1) {
          if (data.size == 0U) {
            goto eof;
          }
          break;
        }
        tmp = data.size;
        data.size = data.size + 1U;
        (*((u_int8_t *)data.data + tmp)) = (unsigned char )ch;
        len --;
      }
    } else {
      while (1) {
        ch = _IO_getc(t->re_fp);
        if (ch == -1) {
          if (data.size == 0U) {
            goto eof;
          }
          break;
        }
        if (ch == t->re_delim) {
          break;
        }
        tmp___0 = data.size;
        data.size = data.size + 1U;
        (*((u_int8_t *)data.data + tmp___0)) = (unsigned char )ch;
        if (data.size == rdata->ulen) {
          rdata->ulen = rdata->ulen * 2U;
          ret = __os_realloc(dbp___1->dbenv, rdata->ulen, (void *)(& rdata->data));
          if (ret != 0) {
            rdata->ulen = 0U;
            rdata->data = (void *)0;
            return (ret);
          } else {
            data.data = rdata->data;
          }
        }
      }
    }
    if (t->re_last >= recno) {
      recno ++;
      ret = __ram_add(dbc, & recno, & data, 0U, 0U);
      if (ret != 0) {
        goto err;
      }
    }
    t->re_last = t->re_last + 1U;
  }
  if (0) {
    eof: 
    t->re_eof = 1;
    ret = -30990;
  }
  err: 
  if (! was_modified) {
    t->re_modified = 0;
  }
  return (ret);
}
}
static int __ram_add(DBC *dbc , db_recno_t *recnop , DBT *data , u_int32_t flags ,
                     u_int32_t bi_flags ) 
{ BTREE_CURSOR *cp ;
  int exact ;
  int ret ;
  int stack ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  retry: 
  if (flags == 2U) {
    tmp = 64;
  } else {
    tmp = 0;
  }
  ret = __bam_rsearch(dbc, recnop, (unsigned int )(12802 | tmp), 1, & exact);
  if (ret != 0) {
    return (ret);
  }
  stack = 1;
  cp->page = (void *)(cp->csp)->page;
  cp->pgno = ((cp->csp)->page)->pgno;
  cp->indx = (cp->csp)->indx;
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  cp->lock = (cp->csp)->lock;
  cp->lock_mode = (cp->csp)->lock_mode;
  if (flags == 2U) {
    if ((unsigned int )(dbc->dbp)->db_append_recno != (unsigned int )((void *)0)) {
      ret = ((*((dbc->dbp)->db_append_recno)))(dbc->dbp, data, (*recnop));
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (exact) {
    tmp___0 = 7;
  } else {
    tmp___0 = 3;
  }
  ret = __bam_iitem(dbc, (DBT *)((void *)0), data, (unsigned int )tmp___0, bi_flags);
  switch (ret) {
  case 0: ;
  break;
  case -30896: 
  __bam_stkrel(dbc, 1U);
  stack = 0;
  ret = __bam_split(dbc, (void *)recnop, (db_pgno_t *)((void *)0));
  if (ret != 0) {
    goto err;
  }
  goto retry;
  default: ;
  goto err;
  }
  err: 
  if (stack) {
    t_ret = __bam_stkrel(dbc, 1U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-6V3mg0F5.i","-O2")
int __bam_cadjust_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx , int32_t adjust ,
                      u_int32_t opflags ) ;
int __bam_rsearch(DBC *dbc , db_recno_t *recnop , u_int32_t flags , int stop , int *exactp ) 
{ BINTERNAL *bi ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  RINTERNAL *ri ;
  db_indx_t adjust ;
  db_indx_t deloffset ;
  db_indx_t indx ;
  db_indx_t top ;
  db_lockmode_t lock_mode ;
  db_pgno_t pg ;
  db_recno_t recno ;
  db_recno_t t_recno ;
  db_recno_t total ;
  int ret ;
  int stack ;
  int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___5 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  while (1) {
    cp->csp = cp->sp;
    (cp->csp)->page = (PAGE *)((void *)0);
    (cp->csp)->lock.off = 0U;
    break;
  }
  pg = cp->root;
  if (flags & 4096U) {
    stack = 1;
  } else {
    stack = 0;
  }
  if (stack) {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  } else {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
  }
  ret = __db_lget(dbc, 0, pg, lock_mode, 0U, & lock);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fget(mpf, & pg, 0U, (void *)(& h));
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    return (ret);
  }
  if (! stack) {
    if (flags & 2048U) {
      if ((int )((unsigned char )(stop + 1)) >= (int )h->level) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (flags & 2U) {
        if ((int )h->level == 1) {
          _L: 
          __memp_fput(mpf, (void *)h, 0U);
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
          ret = __db_lget(dbc, 0, pg, lock_mode, 0U, & lock);
          if (ret != 0) {
            return (ret);
          }
          ret = __memp_fget(mpf, & pg, 0U, (void *)(& h));
          if (ret != 0) {
            if (lock.off != 0U) {
              __lock_put((dbc->dbp)->dbenv, & lock);
            }
            return (ret);
          }
          stack = 1;
        }
      }
    }
  }
  if ((int )h->type == 3) {
    total = h->prev_pgno;
  } else {
    if ((int )h->type == 4) {
      total = h->prev_pgno;
    } else {
      if ((int )h->type == 5) {
        tmp___0 = (int )h->entries / 2;
      } else {
        tmp___0 = (int )h->entries;
      }
      total = (unsigned int )tmp___0;
    }
  }
  if (flags & 64U) {
    (*exactp) = 0;
    recno = total + 1U;
    (*recnop) = recno;
  } else {
    recno = (*recnop);
    if (recno <= total) {
      (*exactp) = 1;
    } else {
      (*exactp) = 0;
      if (! (flags & 8192U)) {
        goto _L___1;
      } else {
        if (recno > total + 1U) {
          _L___1: 
          __memp_fput(mpf, (void *)h, 0U);
          if (lock.off != 0U) {
            __db_lput(dbc, & lock);
          }
          return (-30990);
        }
      }
    }
  }
  total = 0U;
  while (1) {
    switch ((int )h->type) {
    case 5: ;
    case 12: 
    recno -= total;
    if ((int )h->type == 5) {
      adjust = (unsigned short)2;
      deloffset = (unsigned short)1;
    } else {
      adjust = (unsigned short)1;
      deloffset = (unsigned short)0;
    }
    t_recno = 0U;
    indx = (unsigned short)0;
    while (1) {
      if ((int )indx >= (int )h->entries) {
        (*exactp) = 0;
        if (! (flags & 8192U)) {
          goto _L___2;
        } else {
          if (recno > t_recno + 1U) {
            _L___2: 
            __memp_fput(mpf, (void *)h, 0U);
            if (lock.off != 0U) {
              __db_lput(dbc, & lock);
            }
            ret = -30990;
            goto err;
          }
        }
      }
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      if (! ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                         26) + tmp___2) +
                                                          ((int )indx + (int )deloffset)))))->type &
             128)) {
        t_recno ++;
        if (t_recno == recno) {
          break;
        }
      }
      indx = (unsigned short )((int )indx + (int )adjust);
    }
    while (1) {
      if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
        ret = __bam_stkgrow(dbp___1->dbenv, cp);
      } else {
        ret = 0;
      }
      if (ret == 0) {
        (cp->csp)->page = h;
        (cp->csp)->indx = indx;
        (cp->csp)->entries = h->entries;
        (cp->csp)->lock = lock;
        (cp->csp)->lock_mode = lock_mode;
      }
      break;
    }
    if (ret != 0) {
      goto err;
    }
    return (0);
    case 3: 
    indx = (unsigned short)0;
    top = h->entries;
    while (1) {
      if (dbp___1->flags & 2048U) {
        tmp___5 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___5 = sizeof(PG_CHKSUM );
        } else {
          tmp___5 = 0U;
        }
      }
      bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___5) + (int )indx)));
      indx = (unsigned short )((int )indx + 1);
      if ((int )indx == (int )top) {
        break;
      } else {
        if (total + bi->nrecs >= recno) {
          break;
        }
      }
      total += bi->nrecs;
    }
    pg = bi->pgno;
    break;
    case 6: 
    recno -= total;
    recno --;
    while (1) {
      if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
        ret = __bam_stkgrow(dbp___1->dbenv, cp);
      } else {
        ret = 0;
      }
      if (ret == 0) {
        (cp->csp)->page = h;
        (cp->csp)->indx = (unsigned short )recno;
        (cp->csp)->entries = h->entries;
        (cp->csp)->lock = lock;
        (cp->csp)->lock_mode = lock_mode;
      }
      break;
    }
    if (ret != 0) {
      goto err;
    }
    return (0);
    case 4: 
    indx = (unsigned short)0;
    top = h->entries;
    while (1) {
      if (dbp___1->flags & 2048U) {
        tmp___8 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___8 = sizeof(PG_CHKSUM );
        } else {
          tmp___8 = 0U;
        }
      }
      ri = (RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___8) + (int )indx)));
      indx = (unsigned short )((int )indx + 1);
      if ((int )indx == (int )top) {
        break;
      } else {
        if (total + ri->nrecs >= recno) {
          break;
        }
      }
      total += ri->nrecs;
    }
    pg = ri->pgno;
    break;
    default: 
    tmp___9 = __db_pgfmt(dbp___1->dbenv, h->pgno);
    return (tmp___9);
    }
    indx = (unsigned short )((int )indx - 1);
    if (stack) {
      if (flags & 2048U) {
        if (stop == (int )h->level) {
          while (1) {
            if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
              ret = __bam_stkgrow(dbp___1->dbenv, cp);
            } else {
              ret = 0;
            }
            if (ret == 0) {
              (cp->csp)->page = h;
              (cp->csp)->indx = indx;
              (cp->csp)->entries = h->entries;
              (cp->csp)->lock = lock;
              (cp->csp)->lock_mode = lock_mode;
            }
            break;
          }
          if (ret != 0) {
            goto err;
          }
          return (0);
        }
      }
      while (1) {
        while (1) {
          if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
            ret = __bam_stkgrow(dbp___1->dbenv, cp);
          } else {
            ret = 0;
          }
          if (ret == 0) {
            (cp->csp)->page = h;
            (cp->csp)->indx = indx;
            (cp->csp)->entries = h->entries;
            (cp->csp)->lock = lock;
            (cp->csp)->lock_mode = lock_mode;
          }
          break;
        }
        cp->csp = cp->csp + 1;
        break;
      }
      if (ret != 0) {
        goto err;
      }
      lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
      ret = __db_lget(dbc, 0, pg, lock_mode, 0U, & lock);
      if (ret != 0) {
        goto err;
      }
    } else {
      if (flags & 2048U) {
        if ((int )((unsigned char )(stop + 1)) >= (int )((unsigned char )((int )h->level -
                                                                          1))) {
          stack = 1;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        if ((int )h->level - 1 == 1) {
          stack = 1;
        }
      }
      __memp_fput(mpf, (void *)h, 0U);
      if (stack) {
        if (flags & 2U) {
          lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
        } else {
          lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
        }
      } else {
        lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
      }
      ret = __db_lget(dbc, 3, pg, lock_mode, 0U, & lock);
      if (ret != 0) {
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        goto err;
      }
    }
    ret = __memp_fget(mpf, & pg, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
  }
  err: 
  if (! ((unsigned int )cp->csp == (unsigned int )cp->sp)) {
    cp->csp = cp->csp - 1;
  }
  __bam_stkrel(dbc, 0U);
  return (ret);
}
}
int __bam_adjust(DBC *dbc , int32_t adjust ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  EPG *epg ;
  PAGE *h ;
  db_pgno_t root_pgno ;
  int ret ;
  int tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  root_pgno = cp->root;
  epg = cp->sp;
  while ((unsigned int )epg <= (unsigned int )cp->csp) {
    h = epg->page;
    if ((int )h->type == 3) {
      goto _L___4;
    } else {
      if ((int )h->type == 4) {
        _L___4: 
        if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
            if (! (dbc->flags & 16U)) {
              if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
                if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                  if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                      516U) {
                    goto _L___3;
                  } else {
                    goto _L___1;
                  }
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                if (h->pgno == root_pgno) {
                  tmp = 1;
                } else {
                  tmp = 0;
                }
                ret = __bam_cadjust_log(dbp___1, dbc->txn, & h->lsn, 0U, h->pgno,
                                        & h->lsn, (unsigned int )epg->indx, adjust,
                                        (unsigned int )tmp);
                if (ret != 0) {
                  return (ret);
                }
              }
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          while (1) {
            h->lsn.file = 0U;
            h->lsn.offset = 1U;
            break;
          }
        }
        if ((int )h->type == 3) {
          if (dbp___1->flags & 2048U) {
            tmp___1 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___1 = sizeof(PG_CHKSUM );
            } else {
              tmp___1 = 0U;
            }
          }
          ((BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___1) + (int )epg->indx))))->nrecs = ((BINTERNAL *)((u_int8_t *)h +
                                                                                                                       (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                                                                               26) +
                                                                                                                                              tmp___1) +
                                                                                                                                (int )epg->indx))))->nrecs +
                                                                                                        (unsigned int )adjust;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___3 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___3 = sizeof(PG_CHKSUM );
            } else {
              tmp___3 = 0U;
            }
          }
          ((RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___3) + (int )epg->indx))))->nrecs = ((RINTERNAL *)((u_int8_t *)h +
                                                                                                                       (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                                                                               26) +
                                                                                                                                              tmp___3) +
                                                                                                                                (int )epg->indx))))->nrecs +
                                                                                                        (unsigned int )adjust;
        }
        if (h->pgno == root_pgno) {
          h->prev_pgno = h->prev_pgno + (unsigned int )adjust;
        }
        ret = __memp_fset(mpf, (void *)h, 2U);
        if (ret != 0) {
          return (ret);
        }
      }
    }
    epg ++;
  }
  return (0);
}
}
int __bam_nrecs(DBC *dbc , db_recno_t *rep ) 
{ DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t pgno ;
  int ret ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  pgno = (dbc->internal)->root;
  ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & lock);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  if ((int )h->type == 3) {
    (*rep) = h->prev_pgno;
  } else {
    if ((int )h->type == 4) {
      (*rep) = h->prev_pgno;
    } else {
      if ((int )h->type == 5) {
        tmp___0 = (int )h->entries / 2;
      } else {
        tmp___0 = (int )h->entries;
      }
      (*rep) = (unsigned int )tmp___0;
    }
  }
  __memp_fput(mpf, (void *)h, 0U);
  if (lock.off != 0U) {
    __db_lput(dbc, & lock);
  }
  return (0);
}
}
db_recno_t __bam_total(DB *dbp___1 , PAGE *h ) 
{ db_recno_t nrecs ;
  db_indx_t indx ;
  db_indx_t top ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;

  {
  nrecs = 0U;
  top = h->entries;
  switch ((int )h->type) {
  case 5: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    if (! ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                       26) + tmp___0) +
                                                        ((int )indx + 1)))))->type &
           128)) {
      nrecs ++;
    }
    indx = (unsigned short )((int )indx + 2);
  }
  break;
  case 12: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    if (! ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                       26) + tmp___2) +
                                                        (int )indx))))->type & 128)) {
      nrecs ++;
    }
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  case 3: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    nrecs += ((BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                    26) + tmp___4) +
                                                     (int )indx))))->nrecs;
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  case 6: 
  nrecs = (unsigned int )h->entries;
  break;
  case 4: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    nrecs += ((RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                    26) + tmp___6) +
                                                     (int )indx))))->nrecs;
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  }
  return (nrecs);
}
}
#pragma merger(0,"/tmp/cil-VdN3cxV1.i","-O2")
int __bam_search(DBC *dbc , db_pgno_t root_pgno , DBT const   *key , u_int32_t flags ,
                 int stop , db_recno_t *recnop , int *exactp ) 
{ BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_indx_t base ;
  db_indx_t i ;
  db_indx_t indx ;
  db_indx_t *inp ;
  db_indx_t lim ;
  db_lockmode_t lock_mode ;
  db_pgno_t pg ;
  db_recno_t recno ;
  int adjust ;
  int cmp ;
  int deloffset ;
  int ret ;
  int stack ;
  int (*func)(DB * , DBT const   * , DBT const   * ) ;
  int tmp ;
  unsigned int tmp___2 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  unsigned int tmp___18 ;
  unsigned int tmp___20 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  t = (BTREE *)dbp___1->bt_internal;
  recno = 0U;
  while (1) {
    cp->csp = cp->sp;
    (cp->csp)->page = (PAGE *)((void *)0);
    (cp->csp)->lock.off = 0U;
    break;
  }
  try_again: 
  if (root_pgno == 0U) {
    pg = cp->root;
  } else {
    pg = root_pgno;
  }
  if (flags & 4096U) {
    if (cp->flags & 2U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  stack = tmp;
  if (stack) {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  } else {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
  }
  ret = __db_lget(dbc, 0, pg, lock_mode, 0U, & lock);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fget(mpf, & pg, 0U, (void *)(& h));
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    return (ret);
  }
  if (! stack) {
    if (flags & 2048U) {
      if ((int )((unsigned char )(stop + 1)) >= (int )h->level) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if (flags & 2U) {
        if ((int )h->level == 1) {
          _L___1: 
          __memp_fput(mpf, (void *)h, 0U);
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
          ret = __db_lget(dbc, 0, pg, lock_mode, 0U, & lock);
          if (ret != 0) {
            return (ret);
          }
          ret = __memp_fget(mpf, & pg, 0U, (void *)(& h));
          if (ret != 0) {
            if (lock.off != 0U) {
              __lock_put((dbc->dbp)->dbenv, & lock);
            }
            return (ret);
          }
          if (flags & 2048U) {
            if (! ((int )((unsigned char )(stop + 1)) >= (int )h->level)) {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (flags & 2U) {
              if (! ((int )h->level == 1)) {
                goto _L;
              }
            } else {
              _L: 
              __memp_fput(mpf, (void *)h, 0U);
              if (lock.off != 0U) {
                __lock_put((dbc->dbp)->dbenv, & lock);
              }
              goto try_again;
            }
          }
          stack = 1;
        }
      }
    }
  }
  if (dbc->flags & 8U) {
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
      func = & __bam_defcmp;
    } else {
      func = dbp___1->dup_compare;
    }
  } else {
    func = t->bt_compare;
  }
  while (1) {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___2);
    if ((int )h->type == 5) {
      adjust = 2;
    } else {
      adjust = 1;
    }
    base = (unsigned short)0;
    lim = (unsigned short )((int )h->entries / (int )((unsigned short )adjust));
    while ((int )lim != 0) {
      indx = (unsigned short )((int )base + ((int )lim >> 1) * adjust);
      ret = __bam_cmp(dbp___1, key, h, (unsigned int )indx, func, & cmp);
      if (ret != 0) {
        goto err;
      }
      if (cmp == 0) {
        if ((int )h->type == 5) {
          goto found;
        } else {
          if ((int )h->type == 12) {
            goto found;
          }
        }
        goto next;
      }
      if (cmp > 0) {
        base = (unsigned short )((int )indx + adjust);
        lim = (unsigned short )((int )lim - 1);
      }
      lim = (unsigned short )((int )lim >> 1);
    }
    if ((int )h->type == 5) {
      goto _L___3;
    } else {
      if ((int )h->type == 12) {
        _L___3: 
        (*exactp) = 0;
        if (flags & 1024U) {
          goto notfound;
        }
        if (flags & 16384U) {
          while (1) {
            if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
              ret = __bam_stkgrow(dbp___1->dbenv, cp);
            } else {
              ret = 0;
            }
            if (ret == 0) {
              (cp->csp)->page = (PAGE *)((void *)0);
              (cp->csp)->indx = base;
              (cp->csp)->entries = h->entries;
              (cp->csp)->lock.off = 0U;
              (cp->csp)->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
            }
            break;
          }
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          __memp_fput(mpf, (void *)h, 0U);
          return (ret);
        }
        while (1) {
          if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
            ret = __bam_stkgrow(dbp___1->dbenv, cp);
          } else {
            ret = 0;
          }
          if (ret == 0) {
            (cp->csp)->page = h;
            (cp->csp)->indx = base;
            (cp->csp)->entries = h->entries;
            (cp->csp)->lock = lock;
            (cp->csp)->lock_mode = lock_mode;
          }
          break;
        }
        if (ret != 0) {
          goto err;
        }
        return (0);
      }
    }
    if ((int )base > 0) {
      indx = (unsigned short )((int )base - 1);
    } else {
      indx = base;
    }
    next: 
    if ((unsigned int )recnop != (unsigned int )((void *)0)) {
      i = (unsigned short)0;
      while ((int )i < (int )indx) {
        if (dbp___1->flags & 2048U) {
          tmp___6 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___6 = sizeof(PG_CHKSUM );
          } else {
            tmp___6 = 0U;
          }
        }
        recno += ((BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                        26) + tmp___6) +
                                                         (int )i))))->nrecs;
        i = (unsigned short )((int )i + 1);
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___8 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___8 = sizeof(PG_CHKSUM );
      } else {
        tmp___8 = 0U;
      }
    }
    pg = ((BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                               tmp___8) + (int )indx))))->pgno;
    if (flags & 16384U) {
      if (stop == (int )h->level) {
        while (1) {
          if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
            ret = __bam_stkgrow(dbp___1->dbenv, cp);
          } else {
            ret = 0;
          }
          if (ret == 0) {
            (cp->csp)->page = (PAGE *)((void *)0);
            (cp->csp)->indx = indx;
            (cp->csp)->entries = h->entries;
            (cp->csp)->lock.off = 0U;
            (cp->csp)->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
          }
          break;
        }
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        __memp_fput(mpf, (void *)h, 0U);
        return (ret);
      }
      while (1) {
        while (1) {
          if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
            ret = __bam_stkgrow(dbp___1->dbenv, cp);
          } else {
            ret = 0;
          }
          if (ret == 0) {
            (cp->csp)->page = (PAGE *)((void *)0);
            (cp->csp)->indx = indx;
            (cp->csp)->entries = h->entries;
            (cp->csp)->lock.off = 0U;
            (cp->csp)->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
          }
          break;
        }
        cp->csp = cp->csp + 1;
        break;
      }
      __memp_fput(mpf, (void *)h, 0U);
      ret = __db_lget(dbc, 3, pg, lock_mode, 0U, & lock);
      if (ret != 0) {
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        return (ret);
      }
    } else {
      if (stack) {
        if (flags & 2048U) {
          if (stop == (int )h->level) {
            while (1) {
              if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
                ret = __bam_stkgrow(dbp___1->dbenv, cp);
              } else {
                ret = 0;
              }
              if (ret == 0) {
                (cp->csp)->page = h;
                (cp->csp)->indx = indx;
                (cp->csp)->entries = h->entries;
                (cp->csp)->lock = lock;
                (cp->csp)->lock_mode = lock_mode;
              }
              break;
            }
            if (ret != 0) {
              goto err;
            }
            return (0);
          }
        }
        while (1) {
          while (1) {
            if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
              ret = __bam_stkgrow(dbp___1->dbenv, cp);
            } else {
              ret = 0;
            }
            if (ret == 0) {
              (cp->csp)->page = h;
              (cp->csp)->indx = indx;
              (cp->csp)->entries = h->entries;
              (cp->csp)->lock = lock;
              (cp->csp)->lock_mode = lock_mode;
            }
            break;
          }
          cp->csp = cp->csp + 1;
          break;
        }
        if (ret != 0) {
          goto err;
        }
        lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
        ret = __db_lget(dbc, 0, pg, lock_mode, 0U, & lock);
        if (ret != 0) {
          goto err;
        }
      } else {
        if (flags & 2048U) {
          if ((int )((unsigned char )(stop + 1)) >= (int )((unsigned char )((int )h->level -
                                                                            1))) {
            stack = 1;
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          if ((int )h->level - 1 == 1) {
            stack = 1;
          }
        }
        __memp_fput(mpf, (void *)h, 0U);
        if (stack) {
          if (flags & 2U) {
            lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
          } else {
            lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
          }
        } else {
          lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
        }
        ret = __db_lget(dbc, 3, pg, lock_mode, 0U, & lock);
        if (ret != 0) {
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          goto err;
        }
      }
    }
    ret = __memp_fget(mpf, & pg, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
  }
  found: 
  (*exactp) = 1;
  if ((int )h->type == 5) {
    if (flags & 512U) {
      while (1) {
        if ((int )indx < (int )((unsigned short )((int )h->entries - 2))) {
          if (! ((int )(*(inp + (int )indx)) == (int )(*(inp + ((int )indx + 2))))) {
            break;
          }
        } else {
          break;
        }
        indx = (unsigned short )((int )indx + 2);
      }
    } else {
      while (1) {
        if ((int )indx > 0) {
          if (! ((int )(*(inp + (int )indx)) == (int )(*(inp + ((int )indx - 2))))) {
            break;
          }
        } else {
          break;
        }
        indx = (unsigned short )((int )indx - 2);
      }
    }
  }
  if (flags & 128U) {
    if ((int )h->type == 5) {
      deloffset = 1;
    } else {
      deloffset = 0;
    }
    if (flags & 512U) {
      while (1) {
        if (dbp___1->flags & 2048U) {
          tmp___14 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___14 = sizeof(PG_CHKSUM );
          } else {
            tmp___14 = 0U;
          }
        }
        if ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                        26) + tmp___14) +
                                                         ((int )indx + deloffset)))))->type &
            128) {
          if ((int )indx > 0) {
            if (! ((int )(*(inp + (int )indx)) == (int )(*(inp + ((int )indx - adjust))))) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        indx = (unsigned short )((int )indx - adjust);
      }
    } else {
      while (1) {
        if (dbp___1->flags & 2048U) {
          tmp___16 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___16 = sizeof(PG_CHKSUM );
          } else {
            tmp___16 = 0U;
          }
        }
        if ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                        26) + tmp___16) +
                                                         ((int )indx + deloffset)))))->type &
            128) {
          if ((int )indx < (int )((unsigned short )((int )h->entries - adjust))) {
            if (! ((int )(*(inp + (int )indx)) == (int )(*(inp + ((int )indx + adjust))))) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        indx = (unsigned short )((int )indx + adjust);
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___18 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___18 = sizeof(PG_CHKSUM );
      } else {
        tmp___18 = 0U;
      }
    }
    if ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                    26) + tmp___18) +
                                                     ((int )indx + deloffset)))))->type &
        128) {
      goto notfound;
    }
    if ((unsigned int )recnop != (unsigned int )((void *)0)) {
      i = (unsigned short)0;
      while ((int )i < (int )indx) {
        if (dbp___1->flags & 2048U) {
          tmp___20 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___20 = sizeof(PG_CHKSUM );
          } else {
            tmp___20 = 0U;
          }
        }
        if (! ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                           26) + tmp___20) +
                                                            ((int )i + 1)))))->type &
               128)) {
          recno ++;
        }
        i = (unsigned short )((int )i + 2);
      }
      (*recnop) = recno + 1U;
    }
  }
  if (flags & 16384U) {
    while (1) {
      if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
        ret = __bam_stkgrow(dbp___1->dbenv, cp);
      } else {
        ret = 0;
      }
      if (ret == 0) {
        (cp->csp)->page = (PAGE *)((void *)0);
        (cp->csp)->indx = indx;
        (cp->csp)->entries = h->entries;
        (cp->csp)->lock.off = 0U;
        (cp->csp)->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
      }
      break;
    }
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    __memp_fput(mpf, (void *)h, 0U);
  } else {
    while (1) {
      if ((unsigned int )cp->csp == (unsigned int )cp->esp) {
        ret = __bam_stkgrow(dbp___1->dbenv, cp);
      } else {
        ret = 0;
      }
      if (ret == 0) {
        (cp->csp)->page = h;
        (cp->csp)->indx = indx;
        (cp->csp)->entries = h->entries;
        (cp->csp)->lock = lock;
        (cp->csp)->lock_mode = lock_mode;
      }
      break;
    }
    if (ret != 0) {
      goto err;
    }
  }
  return (0);
  notfound: 
  __memp_fput(mpf, (void *)h, 0U);
  if (lock.off != 0U) {
    __db_lput(dbc, & lock);
  }
  ret = -30990;
  err: 
  if (! ((unsigned int )cp->csp == (unsigned int )cp->sp)) {
    cp->csp = cp->csp - 1;
  }
  __bam_stkrel(dbc, 0U);
  return (ret);
}
}
int __bam_stkrel(DBC *dbc , u_int32_t flags ) 
{ BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  EPG *epg ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = 0;
  epg = cp->sp;
  while ((unsigned int )epg <= (unsigned int )cp->csp) {
    if ((unsigned int )epg->page != (unsigned int )((void *)0)) {
      if (flags & 1U) {
        if ((unsigned int )cp->page == (unsigned int )epg->page) {
          cp->page = (void *)0;
          cp->lock.off = 0U;
        }
      }
      t_ret = __memp_fput(mpf, (void *)epg->page, 0U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
      epg->page = (PAGE *)((void *)0);
    }
    if (flags & 2U) {
      if (epg->lock.off != 0U) {
        __lock_put((dbc->dbp)->dbenv, & epg->lock);
      }
    } else {
      if (epg->lock.off != 0U) {
        __db_lput(dbc, & epg->lock);
      }
    }
    epg ++;
  }
  while (1) {
    cp->csp = cp->sp;
    (cp->csp)->page = (PAGE *)((void *)0);
    (cp->csp)->lock.off = 0U;
    break;
  }
  return (ret);
}
}
int __bam_stkgrow(DB_ENV *dbenv___0 , BTREE_CURSOR *cp ) 
{ EPG *p ;
  size_t entries ;
  int ret ;

  {
  entries = (unsigned int )(cp->esp - cp->sp);
  ret = __os_calloc(dbenv___0, entries * 2U, sizeof(EPG ), (void *)(& p));
  if (ret != 0) {
    return (ret);
  }
  memcpy((void * __restrict  )p, (void const   * __restrict  )cp->sp, entries * sizeof(EPG ));
  if ((unsigned int )cp->sp != (unsigned int )(cp->stack)) {
    __os_free(dbenv___0, (void *)cp->sp);
  }
  cp->sp = p;
  cp->csp = p + entries;
  cp->esp = p + entries * 2U;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-rSG6fqIM.i","-O2")
int __bam_split_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    db_pgno_t left , DB_LSN *llsn , db_pgno_t right , DB_LSN *rlsn ,
                    u_int32_t indx , db_pgno_t npgno , DB_LSN *nlsn , db_pgno_t root_pgno ,
                    DBT const   *pg , u_int32_t opflags ) ;
int __db_ovref(DBC *dbc , db_pgno_t pgno , int32_t adjust ) ;
static int __bam_broot(DBC *dbc , PAGE *rootp , PAGE *lp , PAGE *rp ) ;
static int __bam_page(DBC *dbc , EPG *pp , EPG *cp ) ;
static int __bam_pinsert(DBC *dbc , EPG *parent , PAGE *lchild , PAGE *rchild , int space_check ) ;
static int __bam_psplit(DBC *dbc , EPG *cp , PAGE *lp , PAGE *rp , db_indx_t *splitret ) ;
static int __bam_root(DBC *dbc , EPG *cp ) ;
static int __ram_root(DBC *dbc , PAGE *rootp , PAGE *lp , PAGE *rp ) ;
int __bam_split(DBC *dbc , void *arg , db_pgno_t *root_pgnop ) 
{ BTREE_CURSOR *cp ;
  enum __anonenum_dir_76 dir ;
  db_pgno_t root_pgno ;
  int exact ;
  int level ;
  int ret ;
  unsigned long long tmp___1 ;
  unsigned int tmp___3 ;

  {
  cp = (BTREE_CURSOR *)dbc->internal;
  root_pgno = cp->root;
  dir = (enum __anonenum_dir_76 )0;
  level = 1;
  while (1) {
    if ((int )dbc->dbtype == 1) {
      ret = __bam_search(dbc, 0U, (DBT const   *)arg, 10754U, level, (db_recno_t *)((void *)0),
                         & exact);
    } else {
      ret = __bam_rsearch(dbc, (db_recno_t *)arg, 10754U, level, & exact);
    }
    if (ret != 0) {
      return (ret);
    }
    if ((unsigned int )root_pgnop != (unsigned int )((void *)0)) {
      if (((cp->csp + 0)->page)->pgno == root_pgno) {
        (*root_pgnop) = root_pgno;
      } else {
        (*root_pgnop) = ((cp->csp + -1)->page)->pgno;
      }
    }
    if ((unsigned long long )((unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                       sizeof(u_int32_t )) -
                                                                                      1U) &
                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL))) + sizeof(db_indx_t )) >
        ((unsigned long long )(((unsigned int )((int )cp->ovflsize + (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                               1ULL)) + (unsigned long long )sizeof(db_indx_t )) {
      tmp___1 = (unsigned long long )((unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                               sizeof(u_int32_t )) -
                                                                                              1U) &
                                                                        ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                           1ULL))) +
                                      sizeof(db_indx_t ));
    } else {
      tmp___1 = ((unsigned long long )(((unsigned int )((int )cp->ovflsize + (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                        sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                       1ULL)) + (unsigned long long )sizeof(db_indx_t );
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___3 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___3 = sizeof(PG_CHKSUM );
      } else {
        tmp___3 = 0U;
      }
    }
    if (2ULL * tmp___1 <= (unsigned long long )((unsigned short )((unsigned int )((cp->csp +
                                                                                   0)->page)->hf_offset -
                                                                  ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                    26) +
                                                                                                                                   tmp___3)))) +
                                                                   (unsigned int )((cp->csp +
                                                                                    0)->page)->entries *
                                                                   sizeof(db_indx_t ))))) {
      __bam_stkrel(dbc, 2U);
      return (0);
    }
    if (((cp->csp + 0)->page)->pgno == root_pgno) {
      ret = __bam_root(dbc, cp->csp + 0);
    } else {
      ret = __bam_page(dbc, cp->csp + -1, cp->csp + 0);
    }
    while (1) {
      cp->csp = cp->sp;
      (cp->csp)->page = (PAGE *)((void *)0);
      (cp->csp)->lock.off = 0U;
      break;
    }
    switch (ret) {
    case 0: ;
    if (level == 1) {
      return (0);
    }
    if ((int )dir == 0) {
      dir = (enum __anonenum_dir_76 )1;
    }
    break;
    case -30896: ;
    if ((int )dir == 1) {
      dir = (enum __anonenum_dir_76 )0;
    }
    break;
    default: ;
    return (ret);
    }
    if ((int )dir == 0) {
      level ++;
    } else {
      level --;
    }
  }
  return (0);
}
}
static int __bam_root(DBC *dbc , EPG *cp ) 
{ DB *dbp___1 ;
  DBT log_dbt ;
  DB_LSN log_lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *lp ;
  PAGE *rp ;
  db_indx_t split ;
  u_int32_t opflags ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if ((int )(cp->page)->level >= 255) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "Too many btree levels: %d", (cp->page)->level);
    ret = 28;
    goto err;
  }
  rp = (PAGE *)((void *)0);
  lp = rp;
  ret = __db_new(dbc, (unsigned int )(cp->page)->type, & lp);
  if (ret != 0) {
    goto err;
  } else {
    ret = __db_new(dbc, (unsigned int )(cp->page)->type, & rp);
    if (ret != 0) {
      goto err;
    }
  }
  while (1) {
    lp->pgno = lp->pgno;
    lp->prev_pgno = 0U;
    if ((int )(cp->page)->type == 3) {
      lp->next_pgno = 0U;
    } else {
      if ((int )(cp->page)->type == 4) {
        lp->next_pgno = 0U;
      } else {
        lp->next_pgno = rp->pgno;
      }
    }
    lp->entries = (unsigned short)0;
    lp->hf_offset = (unsigned short )dbp___1->pgsize;
    lp->level = (cp->page)->level;
    lp->type = (cp->page)->type;
    break;
  }
  while (1) {
    rp->pgno = rp->pgno;
    if ((int )(cp->page)->type == 3) {
      rp->prev_pgno = 0U;
    } else {
      if ((int )(cp->page)->type == 4) {
        rp->prev_pgno = 0U;
      } else {
        rp->prev_pgno = lp->pgno;
      }
    }
    rp->next_pgno = 0U;
    rp->entries = (unsigned short)0;
    rp->hf_offset = (unsigned short )dbp___1->pgsize;
    rp->level = (cp->page)->level;
    rp->type = (cp->page)->type;
    break;
  }
  ret = __bam_psplit(dbc, cp, lp, rp, & split);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          memset((void *)(& log_dbt), 0, sizeof(log_dbt));
          log_dbt.data = (void *)cp->page;
          log_dbt.size = dbp___1->pgsize;
          while (1) {
            log_lsn.file = 0U;
            log_lsn.offset = 0U;
            break;
          }
          if (((BTREE_CURSOR *)dbc->internal)->flags & 2U) {
            opflags = 1U;
          } else {
            opflags = 0U;
          }
          ret = __bam_split_log(dbp___1, dbc->txn, & (cp->page)->lsn, 0U, lp->pgno,
                                & lp->lsn, rp->pgno, & rp->lsn, (unsigned int )lp->entries,
                                0U, & log_lsn, (dbc->internal)->root, (DBT const   *)(& log_dbt),
                                opflags);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      (cp->page)->lsn.file = 0U;
      (cp->page)->lsn.offset = 1U;
      break;
    }
  }
  lp->lsn = (cp->page)->lsn;
  rp->lsn = (cp->page)->lsn;
  if ((int )dbc->dbtype == 3) {
    ret = __ram_root(dbc, cp->page, lp, rp);
  } else {
    ret = __bam_broot(dbc, cp->page, lp, rp);
  }
  if (ret != 0) {
    goto err;
  }
  ret = __bam_ca_split(dbc, (cp->page)->pgno, lp->pgno, rp->pgno, (unsigned int )split,
                       1);
  if (ret != 0) {
    goto err;
  }
  __memp_fput(mpf, (void *)cp->page, 2U);
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  __memp_fput(mpf, (void *)lp, 2U);
  __memp_fput(mpf, (void *)rp, 2U);
  return (0);
  err: 
  if ((unsigned int )lp != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)lp, 0U);
  }
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)rp, 0U);
  }
  __memp_fput(mpf, (void *)cp->page, 0U);
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  return (ret);
}
}
static int __bam_page(DBC *dbc , EPG *pp , EPG *cp ) 
{ BTREE_CURSOR *bc ;
  DBT log_dbt ;
  DB_LSN log_lsn ;
  DB *dbp___1 ;
  DB_LOCK rplock ;
  DB_LOCK tplock ;
  DB_MPOOLFILE *mpf ;
  DB_LSN save_lsn ;
  PAGE *lp ;
  PAGE *rp ;
  PAGE *alloc_rp ;
  PAGE *tp ;
  db_indx_t split ;
  u_int32_t opflags ;
  int ret ;
  int t_ret ;
  DB_LSN *tmp ;
  db_pgno_t tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  tp = (PAGE *)((void *)0);
  rp = tp;
  lp = rp;
  alloc_rp = lp;
  rplock.off = 0U;
  tplock.off = 0U;
  ret = -1;
  ret = __os_malloc(dbp___1->dbenv, dbp___1->pgsize, (void *)(& rp));
  if (ret != 0) {
    goto err;
  }
  while (1) {
    rp->pgno = 0U;
    if ((int )(cp->page)->type == 3) {
      rp->prev_pgno = 0U;
    } else {
      if ((int )(cp->page)->type == 4) {
        rp->prev_pgno = 0U;
      } else {
        rp->prev_pgno = (cp->page)->pgno;
      }
    }
    if ((int )(cp->page)->type == 3) {
      rp->next_pgno = 0U;
    } else {
      if ((int )(cp->page)->type == 4) {
        rp->next_pgno = 0U;
      } else {
        rp->next_pgno = (cp->page)->next_pgno;
      }
    }
    rp->entries = (unsigned short)0;
    rp->hf_offset = (unsigned short )dbp___1->pgsize;
    rp->level = (cp->page)->level;
    rp->type = (cp->page)->type;
    break;
  }
  ret = __os_malloc(dbp___1->dbenv, dbp___1->pgsize, (void *)(& lp));
  if (ret != 0) {
    goto err;
  }
  while (1) {
    lp->pgno = (cp->page)->pgno;
    if ((int )(cp->page)->type == 3) {
      lp->prev_pgno = 0U;
    } else {
      if ((int )(cp->page)->type == 4) {
        lp->prev_pgno = 0U;
      } else {
        lp->prev_pgno = (cp->page)->prev_pgno;
      }
    }
    if ((int )(cp->page)->type == 3) {
      lp->next_pgno = 0U;
    } else {
      if ((int )(cp->page)->type == 4) {
        lp->next_pgno = 0U;
      } else {
        lp->next_pgno = 0U;
      }
    }
    lp->entries = (unsigned short)0;
    lp->hf_offset = (unsigned short )dbp___1->pgsize;
    lp->level = (cp->page)->level;
    lp->type = (cp->page)->type;
    break;
  }
  ret = __bam_psplit(dbc, cp, lp, rp, & split);
  if (ret != 0) {
    goto err;
  }
  ret = __bam_pinsert(dbc, pp, lp, rp, 1);
  if (ret != 0) {
    goto err;
  }
  if ((int )(cp->page)->type == 5) {
    goto _L;
  } else {
    if ((int )(cp->page)->type == 6) {
      goto _L;
    } else {
      if ((int )(cp->page)->type == 12) {
        _L: 
        if ((cp->page)->next_pgno != 0U) {
          ret = __db_lget(dbc, 0, (cp->page)->next_pgno, (enum __anonenum_db_lockmode_t_50 )2,
                          0U, & tplock);
          if (ret != 0) {
            goto err;
          }
          ret = __memp_fget(mpf, & (cp->page)->next_pgno, 0U, (void *)(& tp));
          if (ret != 0) {
            goto err;
          }
        }
      }
    }
  }
  ret = __db_new(dbc, (unsigned int )(cp->page)->type, & alloc_rp);
  if (ret != 0) {
    goto err;
  }
  ret = __db_lget(dbc, 0, alloc_rp->pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U,
                  & rplock);
  if (ret != 0) {
    goto err;
  }
  lp->next_pgno = alloc_rp->pgno;
  rp->pgno = lp->next_pgno;
  ret = __bam_pinsert(dbc, pp, lp, rp, 0);
  if (ret != 0) {
    goto err;
  }
  bc = (BTREE_CURSOR *)dbc->internal;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___4;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          memset((void *)(& log_dbt), 0, sizeof(log_dbt));
          log_dbt.data = (void *)cp->page;
          log_dbt.size = dbp___1->pgsize;
          if ((unsigned int )tp == (unsigned int )((void *)0)) {
            while (1) {
              log_lsn.file = 0U;
              log_lsn.offset = 0U;
              break;
            }
          }
          if (bc->flags & 2U) {
            opflags = 1U;
          } else {
            opflags = 0U;
          }
          if ((unsigned int )tp == (unsigned int )((void *)0)) {
            tmp = & log_lsn;
          } else {
            tmp = & tp->lsn;
          }
          if ((unsigned int )tp == (unsigned int )((void *)0)) {
            tmp___0 = 0U;
          } else {
            tmp___0 = tp->pgno;
          }
          ret = __bam_split_log(dbp___1, dbc->txn, & (cp->page)->lsn, 0U, (cp->page)->pgno,
                                & (cp->page)->lsn, alloc_rp->pgno, & alloc_rp->lsn,
                                (unsigned int )lp->entries, tmp___0, tmp, 0U, (DBT const   *)(& log_dbt),
                                opflags);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    while (1) {
      (cp->page)->lsn.file = 0U;
      (cp->page)->lsn.offset = 1U;
      break;
    }
  }
  alloc_rp->lsn = (cp->page)->lsn;
  lp->lsn = (cp->page)->lsn;
  rp->lsn = (cp->page)->lsn;
  if ((unsigned int )tp != (unsigned int )((void *)0)) {
    tp->lsn = (cp->page)->lsn;
  }
  save_lsn = alloc_rp->lsn;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  memcpy((void * __restrict  )alloc_rp, (void const   * __restrict  )rp, (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                          26) +
                                                                                                                                         tmp___2)))) +
                                                                         (unsigned int )rp->entries *
                                                                         sizeof(db_indx_t ));
  memcpy((void * __restrict  )((u_int8_t *)alloc_rp + (int )rp->hf_offset), (void const   * __restrict  )((u_int8_t *)rp +
                                                                                                          (int )rp->hf_offset),
         dbp___1->pgsize - (unsigned int )rp->hf_offset);
  alloc_rp->lsn = save_lsn;
  save_lsn = (cp->page)->lsn;
  if (dbp___1->flags & 2048U) {
    tmp___4 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___4 = sizeof(PG_CHKSUM );
    } else {
      tmp___4 = 0U;
    }
  }
  memcpy((void * __restrict  )cp->page, (void const   * __restrict  )lp, (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                          26) +
                                                                                                                                         tmp___4)))) +
                                                                         (unsigned int )lp->entries *
                                                                         sizeof(db_indx_t ));
  memcpy((void * __restrict  )((u_int8_t *)cp->page + (int )lp->hf_offset), (void const   * __restrict  )((u_int8_t *)lp +
                                                                                                          (int )lp->hf_offset),
         dbp___1->pgsize - (unsigned int )lp->hf_offset);
  (cp->page)->lsn = save_lsn;
  if ((unsigned int )tp != (unsigned int )((void *)0)) {
    tp->prev_pgno = rp->pgno;
  }
  ret = __bam_ca_split(dbc, (cp->page)->pgno, (cp->page)->pgno, rp->pgno, (unsigned int )split,
                       0);
  if (ret != 0) {
    goto err;
  }
  __os_free(dbp___1->dbenv, (void *)lp);
  __os_free(dbp___1->dbenv, (void *)rp);
  t_ret = __memp_fput(mpf, (void *)alloc_rp, 2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (rplock.off != 0U) {
    __db_lput(dbc, & rplock);
  }
  t_ret = __memp_fput(mpf, (void *)pp->page, 2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (pp->lock.off != 0U) {
    __db_lput(dbc, & pp->lock);
  }
  t_ret = __memp_fput(mpf, (void *)cp->page, 2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  if ((unsigned int )tp != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)tp, 2U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (tplock.off != 0U) {
      __db_lput(dbc, & tplock);
    }
  }
  return (ret);
  err: 
  if ((unsigned int )lp != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)lp);
  }
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)rp);
  }
  if ((unsigned int )alloc_rp != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)alloc_rp, 0U);
  }
  if ((unsigned int )tp != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)tp, 0U);
  }
  if (rplock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & rplock);
  }
  if (tplock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & tplock);
  }
  __memp_fput(mpf, (void *)pp->page, 0U);
  if (ret == -30896) {
    if (pp->lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & pp->lock);
    }
  } else {
    if (pp->lock.off != 0U) {
      __db_lput(dbc, & pp->lock);
    }
  }
  __memp_fput(mpf, (void *)cp->page, 0U);
  if (ret == -30896) {
    if (cp->lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & cp->lock);
    }
  } else {
    if (cp->lock.off != 0U) {
      __db_lput(dbc, & cp->lock);
    }
  }
  return (ret);
}
}
static int __bam_broot(DBC *dbc , PAGE *rootp , PAGE *lp , PAGE *rp ) 
{ BINTERNAL bi ;
  BINTERNAL *child_bi ;
  BKEYDATA *child_bk ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT hdr ;
  DBT data ;
  db_pgno_t root_pgno ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  root_pgno = cp->root;
  while (1) {
    rootp->pgno = root_pgno;
    rootp->prev_pgno = 0U;
    rootp->next_pgno = 0U;
    rootp->entries = (unsigned short)0;
    rootp->hf_offset = (unsigned short )dbp___1->pgsize;
    rootp->level = (unsigned char )((int )lp->level + 1);
    rootp->type = (unsigned char)3;
    break;
  }
  memset((void *)(& data), 0, sizeof(data));
  memset((void *)(& hdr), 0, sizeof(hdr));
  memset((void *)(& bi), 0, sizeof(bi));
  bi.len = (unsigned short)0;
  bi.type = (unsigned char)1;
  bi.pgno = lp->pgno;
  if (cp->flags & 2U) {
    bi.nrecs = __bam_total(dbp___1, lp);
    rootp->prev_pgno = bi.nrecs;
  }
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  ret = __db_pitem(dbc, rootp, 0U, (unsigned int )((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)),
                   & hdr, (DBT *)((void *)0));
  if (ret != 0) {
    return (ret);
  }
  switch ((int )rp->type) {
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  child_bi = (BINTERNAL *)((u_int8_t *)rp + (int )(*((db_indx_t *)(((u_int8_t *)rp +
                                                                    26) + tmp___0) +
                                                     0)));
  bi.len = child_bi->len;
  bi.type = child_bi->type;
  bi.pgno = rp->pgno;
  if (cp->flags & 2U) {
    bi.nrecs = __bam_total(dbp___1, rp);
    rootp->prev_pgno = rootp->prev_pgno + bi.nrecs;
  }
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  data.data = (void *)(child_bi->data);
  data.size = (unsigned int )child_bi->len;
  ret = __db_pitem(dbc, rootp, 1U, (unsigned int )((unsigned long long )(((unsigned int )((int )child_bi->len +
                                                                                          (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)),
                   & hdr, & data);
  if (ret != 0) {
    return (ret);
  }
  if (((int )child_bi->type & -129) == 3) {
    ret = __db_ovref(dbc, ((BOVERFLOW *)(child_bi->data))->pgno, 1);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  case 12: ;
  case 5: ;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  child_bk = (BKEYDATA *)((u_int8_t *)rp + (int )(*((db_indx_t *)(((u_int8_t *)rp +
                                                                   26) + tmp___2) +
                                                    0)));
  switch ((int )child_bk->type & -129) {
  case 1: 
  bi.len = child_bk->len;
  bi.type = child_bk->type;
  bi.pgno = rp->pgno;
  if (cp->flags & 2U) {
    bi.nrecs = __bam_total(dbp___1, rp);
    rootp->prev_pgno = rootp->prev_pgno + bi.nrecs;
  }
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  data.data = (void *)(child_bk->data);
  data.size = (unsigned int )child_bk->len;
  ret = __db_pitem(dbc, rootp, 1U, (unsigned int )((unsigned long long )(((unsigned int )((int )child_bk->len +
                                                                                          (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)),
                   & hdr, & data);
  if (ret != 0) {
    return (ret);
  }
  break;
  case 2: ;
  case 3: 
  bi.len = (unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) + sizeof(u_int32_t )) -
                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                            1ULL));
  bi.type = child_bk->type;
  bi.pgno = rp->pgno;
  if (cp->flags & 2U) {
    bi.nrecs = __bam_total(dbp___1, rp);
    rootp->prev_pgno = rootp->prev_pgno + bi.nrecs;
  }
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  data.data = (void *)child_bk;
  data.size = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                       sizeof(u_int32_t )) -
                                                                      1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL)));
  ret = __db_pitem(dbc, rootp, 1U, (unsigned int )((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                                          sizeof(u_int32_t )) -
                                                                                                                                         1U) &
                                                                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                                                      1ULL))) +
                                                                                          (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)),
                   & hdr, & data);
  if (ret != 0) {
    return (ret);
  }
  if (((int )child_bk->type & -129) == 3) {
    ret = __db_ovref(dbc, ((BOVERFLOW *)child_bk)->pgno, 1);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  default: 
  tmp___3 = __db_pgfmt(dbp___1->dbenv, rp->pgno);
  return (tmp___3);
  }
  break;
  default: 
  tmp___4 = __db_pgfmt(dbp___1->dbenv, rp->pgno);
  return (tmp___4);
  }
  return (0);
}
}
static int __ram_root(DBC *dbc , PAGE *rootp , PAGE *lp , PAGE *rp ) 
{ DB *dbp___1 ;
  DBT hdr ;
  RINTERNAL ri ;
  db_pgno_t root_pgno ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  root_pgno = (dbc->internal)->root;
  while (1) {
    rootp->pgno = root_pgno;
    rootp->prev_pgno = 0U;
    rootp->next_pgno = 0U;
    rootp->entries = (unsigned short)0;
    rootp->hf_offset = (unsigned short )dbp___1->pgsize;
    rootp->level = (unsigned char )((int )lp->level + 1);
    rootp->type = (unsigned char)4;
    break;
  }
  memset((void *)(& hdr), 0, sizeof(hdr));
  hdr.data = (void *)(& ri);
  hdr.size = (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) -
                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                            1ULL));
  ri.pgno = lp->pgno;
  ri.nrecs = __bam_total(dbp___1, lp);
  ret = __db_pitem(dbc, rootp, 0U, (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)),
                   & hdr, (DBT *)((void *)0));
  if (ret != 0) {
    return (ret);
  }
  rootp->prev_pgno = ri.nrecs;
  ri.pgno = rp->pgno;
  ri.nrecs = __bam_total(dbp___1, rp);
  ret = __db_pitem(dbc, rootp, 1U, (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) +
                                                                          sizeof(u_int32_t )) -
                                                                         1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)),
                   & hdr, (DBT *)((void *)0));
  if (ret != 0) {
    return (ret);
  }
  rootp->prev_pgno = rootp->prev_pgno + ri.nrecs;
  return (0);
}
}
static int __bam_pinsert(DBC *dbc , EPG *parent , PAGE *lchild , PAGE *rchild , int space_check ) 
{ BINTERNAL bi ;
  BINTERNAL *child_bi ;
  BKEYDATA *child_bk ;
  BKEYDATA *tmp_bk ;
  BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DBT a ;
  DBT b ;
  DBT hdr ;
  DBT data ;
  PAGE *ppage ;
  RINTERNAL ri ;
  db_indx_t off ;
  db_recno_t nrecs ;
  size_t (*func)(DB * , DBT const   * , DBT const   * ) ;
  u_int32_t n ;
  u_int32_t nbytes ;
  u_int32_t nksize ;
  int ret ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___21 ;

  {
  dbp___1 = dbc->dbp;
  cp = (BTREE_CURSOR *)dbc->internal;
  t = (BTREE *)dbp___1->bt_internal;
  ppage = parent->page;
  if (cp->flags & 2U) {
    if (! space_check) {
      nrecs = __bam_total(dbp___1, rchild);
    } else {
      nrecs = 0U;
    }
  } else {
    nrecs = 0U;
  }
  off = (unsigned short )((int )parent->indx + 1);
  switch ((int )rchild->type) {
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  child_bi = (BINTERNAL *)((u_int8_t *)rchild + (int )(*((db_indx_t *)(((u_int8_t *)rchild +
                                                                        26) + tmp___1) +
                                                         0)));
  nbytes = (unsigned int )(((unsigned long long )(((unsigned int )((int )child_bi->len +
                                                                   (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                   sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) +
                           (unsigned long long )sizeof(db_indx_t ));
  if (dbp___1->flags & 2048U) {
    tmp___3 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___3 = sizeof(PG_CHKSUM );
    } else {
      tmp___3 = 0U;
    }
  }
  if ((unsigned int )ppage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                          26) +
                                                                                                         tmp___3)))) +
                                         (unsigned int )ppage->entries * sizeof(db_indx_t )) <
      nbytes) {
    return (-30896);
  }
  if (space_check) {
    return (0);
  }
  memset((void *)(& bi), 0, sizeof(bi));
  bi.len = child_bi->len;
  bi.type = child_bi->type;
  bi.pgno = rchild->pgno;
  bi.nrecs = nrecs;
  memset((void *)(& hdr), 0, sizeof(hdr));
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  memset((void *)(& data), 0, sizeof(data));
  data.data = (void *)(child_bi->data);
  data.size = (unsigned int )child_bi->len;
  ret = __db_pitem(dbc, ppage, (unsigned int )off, (unsigned int )((unsigned long long )(((unsigned int )((int )child_bi->len +
                                                                                                          (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                          sizeof(u_int32_t )) -
                                                                                         1U) &
                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL)), & hdr,
                   & data);
  if (ret != 0) {
    return (ret);
  }
  if (((int )child_bi->type & -129) == 3) {
    ret = __db_ovref(dbc, ((BOVERFLOW *)(child_bi->data))->pgno, 1);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  case 12: ;
  case 5: ;
  if (dbp___1->flags & 2048U) {
    tmp___5 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___5 = sizeof(PG_CHKSUM );
    } else {
      tmp___5 = 0U;
    }
  }
  child_bk = (BKEYDATA *)((u_int8_t *)rchild + (int )(*((db_indx_t *)(((u_int8_t *)rchild +
                                                                       26) + tmp___5) +
                                                        0)));
  switch ((int )child_bk->type & -129) {
  case 1: ;
  if (dbc->flags & 8U) {
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )(& __bam_defcmp)) {
      func = & __bam_defpfx;
    } else {
      func = (size_t (*)(DB * , DBT const   * , DBT const   * ))((void *)0);
    }
  } else {
    func = t->bt_prefix;
  }
  nbytes = (unsigned int )(((unsigned long long )(((unsigned int )((int )child_bk->len +
                                                                   (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                   sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) +
                           (unsigned long long )sizeof(db_indx_t ));
  nksize = (unsigned int )child_bk->len;
  if ((unsigned int )func == (unsigned int )((void *)0)) {
    goto noprefix;
  }
  if (ppage->prev_pgno == 0U) {
    if ((int )off <= 1) {
      goto noprefix;
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___7 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___7 = sizeof(PG_CHKSUM );
    } else {
      tmp___7 = 0U;
    }
  }
  if ((int )lchild->type == 12) {
    tmp___8 = 1;
  } else {
    tmp___8 = 2;
  }
  tmp_bk = (BKEYDATA *)((u_int8_t *)lchild + (int )(*((db_indx_t *)(((u_int8_t *)lchild +
                                                                     26) + tmp___7) +
                                                      ((int )lchild->entries - tmp___8))));
  if (((int )tmp_bk->type & -129) != 1) {
    goto noprefix;
  }
  memset((void *)(& a), 0, sizeof(a));
  a.size = (unsigned int )tmp_bk->len;
  a.data = (void *)(tmp_bk->data);
  memset((void *)(& b), 0, sizeof(b));
  b.size = (unsigned int )child_bk->len;
  b.data = (void *)(child_bk->data);
  tmp___9 = ((*func))(dbp___1, (DBT const   *)(& a), (DBT const   *)(& b));
  nksize = tmp___9;
  n = (unsigned int )(((unsigned long long )(((nksize + (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                              sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                             1ULL)) +
                      (unsigned long long )sizeof(db_indx_t ));
  if (n < nbytes) {
    nbytes = n;
  } else {
    noprefix: 
    nksize = (unsigned int )child_bk->len;
  }
  if (dbp___1->flags & 2048U) {
    tmp___11 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___11 = sizeof(PG_CHKSUM );
    } else {
      tmp___11 = 0U;
    }
  }
  if ((unsigned int )ppage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                          26) +
                                                                                                         tmp___11)))) +
                                         (unsigned int )ppage->entries * sizeof(db_indx_t )) <
      nbytes) {
    return (-30896);
  }
  if (space_check) {
    return (0);
  }
  memset((void *)(& bi), 0, sizeof(bi));
  bi.len = (unsigned short )nksize;
  bi.type = child_bk->type;
  bi.pgno = rchild->pgno;
  bi.nrecs = nrecs;
  memset((void *)(& hdr), 0, sizeof(hdr));
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  memset((void *)(& data), 0, sizeof(data));
  data.data = (void *)(child_bk->data);
  data.size = nksize;
  ret = __db_pitem(dbc, ppage, (unsigned int )off, (unsigned int )((unsigned long long )(((nksize +
                                                                                           (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                          sizeof(u_int32_t )) -
                                                                                         1U) &
                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL)), & hdr,
                   & data);
  if (ret != 0) {
    return (ret);
  }
  break;
  case 2: ;
  case 3: 
  nbytes = (unsigned int )(((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                   sizeof(u_int32_t )) -
                                                                                                                  1U) &
                                                                                            ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                               1ULL))) +
                                                                   (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                   sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) +
                           (unsigned long long )sizeof(db_indx_t ));
  if (dbp___1->flags & 2048U) {
    tmp___13 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___13 = sizeof(PG_CHKSUM );
    } else {
      tmp___13 = 0U;
    }
  }
  if ((unsigned int )ppage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                          26) +
                                                                                                         tmp___13)))) +
                                         (unsigned int )ppage->entries * sizeof(db_indx_t )) <
      nbytes) {
    return (-30896);
  }
  if (space_check) {
    return (0);
  }
  memset((void *)(& bi), 0, sizeof(bi));
  bi.len = (unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) + sizeof(u_int32_t )) -
                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                            1ULL));
  bi.type = child_bk->type;
  bi.pgno = rchild->pgno;
  bi.nrecs = nrecs;
  memset((void *)(& hdr), 0, sizeof(hdr));
  hdr.data = (void *)(& bi);
  hdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  memset((void *)(& data), 0, sizeof(data));
  data.data = (void *)child_bk;
  data.size = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                       sizeof(u_int32_t )) -
                                                                      1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL)));
  ret = __db_pitem(dbc, ppage, (unsigned int )off, (unsigned int )((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                                                          sizeof(u_int32_t )) -
                                                                                                                                                         1U) &
                                                                                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                                                                      1ULL))) +
                                                                                                          (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                          sizeof(u_int32_t )) -
                                                                                         1U) &
                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL)), & hdr,
                   & data);
  if (ret != 0) {
    return (ret);
  }
  if (((int )child_bk->type & -129) == 3) {
    ret = __db_ovref(dbc, ((BOVERFLOW *)child_bk)->pgno, 1);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  default: 
  tmp___14 = __db_pgfmt(dbp___1->dbenv, rchild->pgno);
  return (tmp___14);
  }
  break;
  case 4: ;
  case 6: 
  nbytes = (unsigned int )(((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) -
                                                  1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                           1ULL)) + (unsigned long long )sizeof(db_indx_t ));
  if (dbp___1->flags & 2048U) {
    tmp___16 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___16 = sizeof(PG_CHKSUM );
    } else {
      tmp___16 = 0U;
    }
  }
  if ((unsigned int )ppage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                          26) +
                                                                                                         tmp___16)))) +
                                         (unsigned int )ppage->entries * sizeof(db_indx_t )) <
      nbytes) {
    return (-30896);
  }
  if (space_check) {
    return (0);
  }
  memset((void *)(& hdr), 0, sizeof(hdr));
  hdr.data = (void *)(& ri);
  hdr.size = (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) -
                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                            1ULL));
  ri.pgno = rchild->pgno;
  ri.nrecs = nrecs;
  ret = __db_pitem(dbc, ppage, (unsigned int )off, (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) +
                                                                                          sizeof(u_int32_t )) -
                                                                                         1U) &
                                                                   ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL)), & hdr,
                   (DBT *)((void *)0));
  if (ret != 0) {
    return (ret);
  }
  break;
  default: 
  tmp___17 = __db_pgfmt(dbp___1->dbenv, rchild->pgno);
  return (tmp___17);
  }
  if (cp->flags & 2U) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___3;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            ret = __bam_cadjust_log(dbp___1, dbc->txn, & ppage->lsn, 0U, ppage->pgno,
                                    & ppage->lsn, (unsigned int )parent->indx, - ((int )nrecs),
                                    0U);
            if (ret != 0) {
              return (ret);
            }
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      while (1) {
        ppage->lsn.file = 0U;
        ppage->lsn.offset = 1U;
        break;
      }
    }
    if ((int )dbc->dbtype == 3) {
      if (dbp___1->flags & 2048U) {
        tmp___19 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___19 = sizeof(PG_CHKSUM );
        } else {
          tmp___19 = 0U;
        }
      }
      ((RINTERNAL *)((u_int8_t *)ppage + (int )(*((db_indx_t *)(((u_int8_t *)ppage +
                                                                 26) + tmp___19) +
                                                  (int )parent->indx))))->nrecs = ((RINTERNAL *)((u_int8_t *)ppage +
                                                                                                 (int )(*((db_indx_t *)(((u_int8_t *)ppage +
                                                                                                                         26) +
                                                                                                                        tmp___19) +
                                                                                                          (int )parent->indx))))->nrecs -
                                                                                  nrecs;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___21 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___21 = sizeof(PG_CHKSUM );
        } else {
          tmp___21 = 0U;
        }
      }
      ((BINTERNAL *)((u_int8_t *)ppage + (int )(*((db_indx_t *)(((u_int8_t *)ppage +
                                                                 26) + tmp___21) +
                                                  (int )parent->indx))))->nrecs = ((BINTERNAL *)((u_int8_t *)ppage +
                                                                                                 (int )(*((db_indx_t *)(((u_int8_t *)ppage +
                                                                                                                         26) +
                                                                                                                        tmp___21) +
                                                                                                          (int )parent->indx))))->nrecs -
                                                                                  nrecs;
    }
  }
  return (0);
}
}
static int __bam_psplit(DBC *dbc , EPG *cp , PAGE *lp , PAGE *rp , db_indx_t *splitret ) 
{ DB *dbp___1 ;
  PAGE *pp ;
  db_indx_t half ;
  db_indx_t *inp ;
  db_indx_t nbytes ;
  db_indx_t off ;
  db_indx_t splitp ;
  db_indx_t top ;
  int adjust ;
  int cnt ;
  int iflag ;
  int isbigkey ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___15 ;
  unsigned int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___21 ;
  int tmp___26 ;
  unsigned int tmp___28 ;
  unsigned int tmp___30 ;

  {
  dbp___1 = dbc->dbp;
  pp = cp->page;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pp + 26) + tmp___0);
  if ((int )pp->type == 5) {
    adjust = 2;
  } else {
    adjust = 1;
  }
  off = (unsigned short)0;
  if (pp->next_pgno == 0U) {
    if ((int )cp->indx >= (int )pp->entries - adjust) {
      off = (unsigned short )((int )pp->entries - adjust);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (pp->prev_pgno == 0U) {
      if ((int )cp->indx == 0) {
        off = (unsigned short )adjust;
      }
    }
  }
  if ((int )off != 0) {
    goto sort;
  }
  top = (unsigned short )((int )pp->entries - adjust);
  half = (unsigned short )((dbp___1->pgsize - (unsigned int )pp->hf_offset) / 2U);
  nbytes = (unsigned short)0;
  off = (unsigned short)0;
  while (1) {
    if ((int )off < (int )top) {
      if (! ((int )nbytes < (int )half)) {
        break;
      }
    } else {
      break;
    }
    switch ((int )pp->type) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if (((int )((BINTERNAL *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                       26) + tmp___4) +
                                                        (int )off))))->type & -129) ==
        1) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      nbytes = (unsigned short )((unsigned long long )nbytes + ((unsigned long long )(((unsigned int )((int )((BINTERNAL *)((u_int8_t *)pp +
                                                                                                                            (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                                                                                    26) +
                                                                                                                                                   tmp___2) +
                                                                                                                                     (int )off))))->len +
                                                                                                       (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                       sizeof(u_int32_t )) -
                                                                                      1U) &
                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)));
    } else {
      nbytes = (unsigned short )((unsigned long long )nbytes + ((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                                                       sizeof(u_int32_t )) -
                                                                                                                                                      1U) &
                                                                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                                                                   1ULL))) +
                                                                                                       (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                       sizeof(u_int32_t )) -
                                                                                      1U) &
                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)));
    }
    break;
    case 5: ;
    if (dbp___1->flags & 2048U) {
      tmp___8 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___8 = sizeof(PG_CHKSUM );
      } else {
        tmp___8 = 0U;
      }
    }
    if (((int )((BKEYDATA *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                      26) + tmp___8) +
                                                       (int )off))))->type & -129) ==
        1) {
      if (dbp___1->flags & 2048U) {
        tmp___6 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___6 = sizeof(PG_CHKSUM );
        } else {
          tmp___6 = 0U;
        }
      }
      nbytes = (unsigned short )((unsigned long long )nbytes + ((unsigned long long )(((unsigned int )((int )((BKEYDATA *)((u_int8_t *)pp +
                                                                                                                           (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                                                                                   26) +
                                                                                                                                                  tmp___6) +
                                                                                                                                    (int )off))))->len +
                                                                                                       (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                       sizeof(u_int32_t )) -
                                                                                      1U) &
                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)));
    } else {
      nbytes = (unsigned short )((int )nbytes + (int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                sizeof(u_int32_t )) -
                                                                                               1U) &
                                                                         ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                            1ULL))));
    }
    off = (unsigned short )((int )off + 1);
    case 12: ;
    case 6: ;
    if (dbp___1->flags & 2048U) {
      tmp___12 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___12 = sizeof(PG_CHKSUM );
      } else {
        tmp___12 = 0U;
      }
    }
    if (((int )((BKEYDATA *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                      26) + tmp___12) +
                                                       (int )off))))->type & -129) ==
        1) {
      if (dbp___1->flags & 2048U) {
        tmp___10 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___10 = sizeof(PG_CHKSUM );
        } else {
          tmp___10 = 0U;
        }
      }
      nbytes = (unsigned short )((unsigned long long )nbytes + ((unsigned long long )(((unsigned int )((int )((BKEYDATA *)((u_int8_t *)pp +
                                                                                                                           (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                                                                                   26) +
                                                                                                                                                  tmp___10) +
                                                                                                                                    (int )off))))->len +
                                                                                                       (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                       sizeof(u_int32_t )) -
                                                                                      1U) &
                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)));
    } else {
      nbytes = (unsigned short )((int )nbytes + (int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                sizeof(u_int32_t )) -
                                                                                               1U) &
                                                                         ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                            1ULL))));
    }
    break;
    case 4: 
    nbytes = (unsigned short )((unsigned long long )nbytes + ((unsigned long long )((sizeof(RINTERNAL ) +
                                                                                     sizeof(u_int32_t )) -
                                                                                    1U) &
                                                              ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                 1ULL)));
    break;
    default: 
    tmp___13 = __db_pgfmt(dbp___1->dbenv, pp->pgno);
    return (tmp___13);
    }
    off = (unsigned short )((int )off + 1);
  }
  sort: 
  splitp = off;
  switch ((int )pp->type) {
  case 3: 
  iflag = 1;
  if (dbp___1->flags & 2048U) {
    tmp___15 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___15 = sizeof(PG_CHKSUM );
    } else {
      tmp___15 = 0U;
    }
  }
  isbigkey = ((int )((BINTERNAL *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                            26) +
                                                                           tmp___15) +
                                                             (int )off))))->type &
              -129) != 1;
  break;
  case 5: ;
  case 12: 
  iflag = 0;
  if (dbp___1->flags & 2048U) {
    tmp___17 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___17 = sizeof(PG_CHKSUM );
    } else {
      tmp___17 = 0U;
    }
  }
  isbigkey = ((int )((BKEYDATA *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                           26) + tmp___17) +
                                                            (int )off))))->type &
              -129) != 1;
  break;
  default: 
  isbigkey = 0;
  iflag = isbigkey;
  }
  if (isbigkey) {
    cnt = 1;
    while (cnt <= 3) {
      off = (unsigned short )((int )splitp + cnt * adjust);
      if ((int )off < (int )pp->entries) {
        if (iflag) {
          if (dbp___1->flags & 2048U) {
            tmp___19 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___19 = sizeof(PG_CHKSUM );
            } else {
              tmp___19 = 0U;
            }
          }
          if (((int )((BINTERNAL *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                             26) +
                                                                            tmp___19) +
                                                              (int )off))))->type &
               -129) == 1) {
            splitp = off;
            break;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if (dbp___1->flags & 2048U) {
            tmp___21 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___21 = sizeof(PG_CHKSUM );
            } else {
              tmp___21 = 0U;
            }
          }
          if (((int )((BKEYDATA *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                            26) +
                                                                           tmp___21) +
                                                             (int )off))))->type &
               -129) == 1) {
            splitp = off;
            break;
          }
        }
      }
      if ((int )splitp <= (int )((unsigned short )(cnt * adjust))) {
        goto __Cont;
      }
      off = (unsigned short )((int )splitp - cnt * adjust);
      if (iflag) {
        if (dbp___1->flags & 2048U) {
          tmp___28 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___28 = sizeof(PG_CHKSUM );
          } else {
            tmp___28 = 0U;
          }
        }
        tmp___26 = ((int )((BINTERNAL *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                  26) +
                                                                                 tmp___28) +
                                                                   (int )off))))->type &
                    -129) == 1;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___30 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___30 = sizeof(PG_CHKSUM );
          } else {
            tmp___30 = 0U;
          }
        }
        tmp___26 = ((int )((BKEYDATA *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                 26) +
                                                                                tmp___30) +
                                                                  (int )off))))->type &
                    -129) == 1;
      }
      if (tmp___26) {
        splitp = off;
        break;
      }
      __Cont: 
      cnt ++;
    }
  }
  if ((int )pp->type == 5) {
    if ((int )(*(inp + (int )splitp)) == (int )(*(inp + ((int )splitp - adjust)))) {
      cnt = 1;
      while (1) {
        off = (unsigned short )((int )splitp + cnt * adjust);
        if ((int )off < (int )pp->entries) {
          if ((int )(*(inp + (int )splitp)) != (int )(*(inp + (int )off))) {
            splitp = off;
            break;
          }
        }
        if ((int )splitp <= (int )((unsigned short )(cnt * adjust))) {
          goto __Cont___0;
        }
        off = (unsigned short )((int )splitp - cnt * adjust);
        if ((int )(*(inp + (int )splitp)) != (int )(*(inp + (int )off))) {
          splitp = (unsigned short )((int )off + adjust);
          break;
        }
        __Cont___0: 
        cnt ++;
      }
    }
  }
  ret = __bam_copy(dbp___1, pp, lp, 0U, (unsigned int )splitp);
  if (ret != 0) {
    return (ret);
  }
  ret = __bam_copy(dbp___1, pp, rp, (unsigned int )splitp, (unsigned int )pp->entries);
  if (ret != 0) {
    return (ret);
  }
  (*splitret) = splitp;
  return (0);
}
}
int __bam_copy(DB *dbp___1 , PAGE *pp , PAGE *cp , u_int32_t nxt , u_int32_t stop ) 
{ db_indx_t *cinp ;
  db_indx_t nbytes ;
  db_indx_t off ;
  db_indx_t *pinp ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;

  {
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  cinp = (db_indx_t *)(((u_int8_t *)cp + 26) + tmp___0);
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  pinp = (db_indx_t *)(((u_int8_t *)pp + 26) + tmp___2);
  off = (unsigned short)0;
  while (nxt < stop) {
    switch ((int )pp->type) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    if (((int )((BINTERNAL *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                       26) + tmp___6) +
                                                        nxt))))->type & -129) == 1) {
      if (dbp___1->flags & 2048U) {
        tmp___4 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___4 = sizeof(PG_CHKSUM );
        } else {
          tmp___4 = 0U;
        }
      }
      nbytes = (unsigned short )((unsigned long long )(((unsigned int )((int )((BINTERNAL *)((u_int8_t *)pp +
                                                                                             (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                                                     26) +
                                                                                                                    tmp___4) +
                                                                                                      nxt))))->len +
                                                                        (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                        sizeof(u_int32_t )) - 1U) &
                                 ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL));
    } else {
      nbytes = (unsigned short )((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                        sizeof(u_int32_t )) -
                                                                                                                       1U) &
                                                                                                 ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                                    1ULL))) +
                                                                        (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                        sizeof(u_int32_t )) - 1U) &
                                 ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL));
    }
    break;
    case 5: ;
    if ((int )off != 0) {
      if (nxt % 2U == 0U) {
        if ((int )(*(pinp + nxt)) == (int )(*(pinp + (nxt - 2U)))) {
          (*(cinp + (int )off)) = (*(cinp + ((int )off - 2)));
          goto __Cont;
        }
      }
    }
    case 12: ;
    case 6: ;
    if (dbp___1->flags & 2048U) {
      tmp___10 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___10 = sizeof(PG_CHKSUM );
      } else {
        tmp___10 = 0U;
      }
    }
    if (((int )((BKEYDATA *)((u_int8_t *)pp + (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                      26) + tmp___10) +
                                                       nxt))))->type & -129) == 1) {
      if (dbp___1->flags & 2048U) {
        tmp___8 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___8 = sizeof(PG_CHKSUM );
        } else {
          tmp___8 = 0U;
        }
      }
      nbytes = (unsigned short )((unsigned long long )(((unsigned int )((int )((BKEYDATA *)((u_int8_t *)pp +
                                                                                            (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                                                    26) +
                                                                                                                   tmp___8) +
                                                                                                     nxt))))->len +
                                                                        (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                        sizeof(u_int32_t )) - 1U) &
                                 ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL));
    } else {
      nbytes = (unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) + sizeof(u_int32_t )) -
                                                       1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                1ULL));
    }
    break;
    case 4: 
    nbytes = (unsigned short )((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) -
                                                     1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                              1ULL));
    break;
    default: 
    tmp___11 = __db_pgfmt(dbp___1->dbenv, pp->pgno);
    return (tmp___11);
    }
    cp->hf_offset = (unsigned short )((int )cp->hf_offset - (int )nbytes);
    (*(cinp + (int )off)) = cp->hf_offset;
    if (dbp___1->flags & 2048U) {
      tmp___13 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___13 = sizeof(PG_CHKSUM );
      } else {
        tmp___13 = 0U;
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___15 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___15 = sizeof(PG_CHKSUM );
      } else {
        tmp___15 = 0U;
      }
    }
    memcpy((void * __restrict  )((u_int8_t *)cp + (int )(*((db_indx_t *)(((u_int8_t *)cp +
                                                                          26) + tmp___15) +
                                                           (int )off))), (void const   * __restrict  )((u_int8_t *)pp +
                                                                                                       (int )(*((db_indx_t *)(((u_int8_t *)pp +
                                                                                                                               26) +
                                                                                                                              tmp___13) +
                                                                                                                nxt))),
           (unsigned int )nbytes);
    __Cont: 
    nxt ++;
    cp->entries = (unsigned short )((int )cp->entries + 1);
    off = (unsigned short )((int )off + 1);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-KFAQ2I4o.i","-O2")
int __os_umalloc(DB_ENV *dbenv___0 , size_t size , void *storep ) ;
int __bam_stat(DBC *dbc , void *spp , u_int32_t flags ) ;
int __bam_stat_callback(DB *dbp___1 , PAGE *h , void *cookie , int *putp ) ;
int __bam_key_range(DBC *dbc , DBT *dbt , DB_KEY_RANGE *kp , u_int32_t flags ) ;
int __db_traverse_big(DB *dbp___1 , db_pgno_t pgno , int (*callback)(DB * , PAGE * ,
                                                                     void * , int * ) ,
                      void *cookie ) ;
int __bam_stat(DBC *dbc , void *spp , u_int32_t flags ) 
{ BTMETA *meta ;
  BTREE *t ;
  BTREE_CURSOR *cp ;
  DB *dbp___1 ;
  DB_BTREE_STAT *sp ;
  DB_ENV *dbenv___0 ;
  DB_LOCK lock ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t pgno ;
  int ret ;
  int t_ret ;
  int write_meta ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  meta = (BTMETA *)((void *)0);
  t = (BTREE *)dbp___1->bt_internal;
  sp = (DB_BTREE_STAT *)((void *)0);
  metalock.off = 0U;
  lock.off = 0U;
  mpf = dbp___1->mpf;
  h = (PAGE *)((void *)0);
  write_meta = 0;
  ret = write_meta;
  cp = (BTREE_CURSOR *)dbc->internal;
  ret = __os_umalloc(dbenv___0, sizeof((*sp)), (void *)(& sp));
  if (ret != 0) {
    goto err;
  }
  memset((void *)sp, 0, sizeof((*sp)));
  pgno = 0U;
  ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  if (flags == 27U) {
    flags = 8U;
  } else {
    if (flags == 4U) {
      flags = 8U;
    }
  }
  if (flags == 8U) {
    goto meta_only;
  }
  sp->bt_free = 0U;
  pgno = meta->dbmeta.free;
  while (pgno != 0U) {
    sp->bt_free ++;
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
    pgno = h->next_pgno;
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      goto err;
    }
    h = (PAGE *)((void *)0);
  }
  pgno = cp->root;
  ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & lock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    goto err;
  }
  sp->bt_levels = (unsigned int )h->level;
  ret = __memp_fput(mpf, (void *)h, 0U);
  if (ret != 0) {
    goto err;
  }
  h = (PAGE *)((void *)0);
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  ret = __bam_traverse(dbc, (enum __anonenum_db_lockmode_t_50 )1, cp->root, & __bam_stat_callback,
                       (void *)sp);
  if (ret != 0) {
    goto err;
  }
  write_meta = (! (dbp___1->flags & 524288U) != 0) != 0;
  meta_only: 
  if (t->bt_meta != 0U) {
    goto _L;
  } else {
    if (write_meta != 0) {
      _L: 
      ret = __memp_fput(mpf, (void *)meta, 0U);
      if (ret != 0) {
        goto err;
      }
      meta = (BTMETA *)((void *)0);
      if (metalock.off != 0U) {
        __lock_put((dbc->dbp)->dbenv, & metalock);
      }
      if (write_meta == 0) {
        tmp = 1;
      } else {
        tmp = 2;
      }
      ret = __db_lget(dbc, 0, t->bt_meta, (enum __anonenum_db_lockmode_t_50 )tmp,
                      0U, & metalock);
      if (ret != 0) {
        goto err;
      }
      ret = __memp_fget(mpf, & t->bt_meta, 0U, (void *)(& meta));
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (flags == 8U) {
    if ((int )dbp___1->type == 3) {
      goto _L___0;
    } else {
      if ((int )dbp___1->type == 1) {
        if (dbp___1->flags & 1048576U) {
          _L___0: 
          ret = __db_lget(dbc, 0, cp->root, (enum __anonenum_db_lockmode_t_50 )1,
                          0U, & lock);
          if (ret != 0) {
            goto err;
          }
          ret = __memp_fget(mpf, & cp->root, 0U, (void *)(& h));
          if (ret != 0) {
            goto err;
          }
          if ((int )h->type == 3) {
            sp->bt_nkeys = h->prev_pgno;
          } else {
            if ((int )h->type == 4) {
              sp->bt_nkeys = h->prev_pgno;
            } else {
              if ((int )h->type == 5) {
                tmp___1 = (int )h->entries / 2;
              } else {
                tmp___1 = (int )h->entries;
              }
              sp->bt_nkeys = (unsigned int )tmp___1;
            }
          }
        } else {
          sp->bt_nkeys = meta->dbmeta.key_count;
        }
      } else {
        sp->bt_nkeys = meta->dbmeta.key_count;
      }
    }
    sp->bt_ndata = meta->dbmeta.record_count;
  }
  sp->bt_metaflags = meta->dbmeta.flags;
  sp->bt_maxkey = meta->maxkey;
  sp->bt_minkey = meta->minkey;
  sp->bt_re_len = meta->re_len;
  sp->bt_re_pad = meta->re_pad;
  sp->bt_pagesize = meta->dbmeta.pagesize;
  sp->bt_magic = meta->dbmeta.magic;
  sp->bt_version = meta->dbmeta.version;
  if (write_meta != 0) {
    meta->dbmeta.key_count = sp->bt_nkeys;
    meta->dbmeta.record_count = sp->bt_ndata;
  }
  (*((DB_BTREE_STAT **)spp)) = sp;
  err: 
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (metalock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & metalock);
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    if (write_meta == 0) {
      tmp___2 = 0;
    } else {
      tmp___2 = 2;
    }
    t_ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___2);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (ret != 0) {
    if ((unsigned int )sp != (unsigned int )((void *)0)) {
      __os_ufree(dbenv___0, (void *)sp);
      (*((DB_BTREE_STAT **)spp)) = (DB_BTREE_STAT *)((void *)0);
    }
  }
  return (ret);
}
}
int __bam_traverse(DBC *dbc , db_lockmode_t mode , db_pgno_t root_pgno , int (*callback)(DB * ,
                                                                                         PAGE * ,
                                                                                         void * ,
                                                                                         int * ) ,
                   void *cookie ) 
{ BINTERNAL *bi ;
  BKEYDATA *bk ;
  DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  RINTERNAL *ri ;
  db_indx_t indx ;
  int already_put ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  int tmp___17 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  already_put = 0;
  ret = __db_lget(dbc, 0, root_pgno, mode, 0U, & lock);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fget(mpf, & root_pgno, 0U, (void *)(& h));
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    return (ret);
  }
  switch ((int )h->type) {
  case 3: 
  indx = (unsigned short)0;
  while ((int )indx < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___0) + (int )indx)));
    if (((int )bi->type & -129) == 3) {
      ret = __db_traverse_big(dbp___1, ((BOVERFLOW *)(bi->data))->pgno, callback,
                              cookie);
      if (ret != 0) {
        goto err;
      }
    }
    ret = __bam_traverse(dbc, mode, bi->pgno, callback, cookie);
    if (ret != 0) {
      goto err;
    }
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  case 4: 
  indx = (unsigned short)0;
  while ((int )indx < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    ri = (RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___2) + (int )indx)));
    ret = __bam_traverse(dbc, mode, ri->pgno, callback, cookie);
    if (ret != 0) {
      goto err;
    }
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  case 5: 
  indx = (unsigned short)0;
  while ((int )indx < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___4) + (int )indx)));
    if (((int )bk->type & -129) == 3) {
      if (dbp___1->flags & 2048U) {
        tmp___6 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___6 = sizeof(PG_CHKSUM );
        } else {
          tmp___6 = 0U;
        }
      }
      ret = __db_traverse_big(dbp___1, ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                              26) +
                                                                                             tmp___6) +
                                                                               (int )indx))))->pgno,
                              callback, cookie);
      if (ret != 0) {
        goto err;
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___8 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___8 = sizeof(PG_CHKSUM );
      } else {
        tmp___8 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___8) + ((int )indx +
                                                                         1))));
    if (((int )bk->type & -129) == 2) {
      if (dbp___1->flags & 2048U) {
        tmp___10 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___10 = sizeof(PG_CHKSUM );
        } else {
          tmp___10 = 0U;
        }
      }
      ret = __bam_traverse(dbc, mode, ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                             26) +
                                                                                            tmp___10) +
                                                                              ((int )indx +
                                                                               1)))))->pgno,
                           callback, cookie);
      if (ret != 0) {
        goto err;
      }
    }
    if (((int )bk->type & -129) == 3) {
      if (dbp___1->flags & 2048U) {
        tmp___12 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___12 = sizeof(PG_CHKSUM );
        } else {
          tmp___12 = 0U;
        }
      }
      ret = __db_traverse_big(dbp___1, ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                              26) +
                                                                                             tmp___12) +
                                                                               ((int )indx +
                                                                                1)))))->pgno,
                              callback, cookie);
      if (ret != 0) {
        goto err;
      }
    }
    indx = (unsigned short )((int )indx + 2);
  }
  break;
  case 12: ;
  case 6: 
  indx = (unsigned short)0;
  while ((int )indx < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___14 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___14 = sizeof(PG_CHKSUM );
      } else {
        tmp___14 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___14) + (int )indx)));
    if (((int )bk->type & -129) == 3) {
      if (dbp___1->flags & 2048U) {
        tmp___16 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___16 = sizeof(PG_CHKSUM );
        } else {
          tmp___16 = 0U;
        }
      }
      ret = __db_traverse_big(dbp___1, ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                              26) +
                                                                                             tmp___16) +
                                                                               (int )indx))))->pgno,
                              callback, cookie);
      if (ret != 0) {
        goto err;
      }
    }
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  default: 
  tmp___17 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___17);
  }
  ret = ((*callback))(dbp___1, h, cookie, & already_put);
  err: 
  if (! already_put) {
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      if (ret != 0) {
        ret = t_ret;
      }
    }
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  return (ret);
}
}
int __bam_stat_callback(DB *dbp___1 , PAGE *h , void *cookie , int *putp ) 
{ DB_BTREE_STAT *sp ;
  db_indx_t indx ;
  db_indx_t *inp ;
  db_indx_t top ;
  u_int8_t type ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  unsigned int tmp___18 ;
  int tmp___19 ;

  {
  sp = (DB_BTREE_STAT *)cookie;
  (*putp) = 0;
  top = h->entries;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  switch ((int )h->type) {
  case 3: ;
  case 4: 
  sp->bt_int_pg ++;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  sp->bt_int_pgfree += (unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                       26) +
                                                                                                                      tmp___2)))) +
                                                      (unsigned int )h->entries *
                                                      sizeof(db_indx_t ));
  break;
  case 5: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    type = ((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___4) + ((int )indx +
                                                                            1)))))->type;
    if ((int )type & 128) {
      goto __Cont;
    }
    if ((int )indx + 2 >= (int )top) {
      sp->bt_nkeys ++;
    } else {
      if ((int )(*(inp + (int )indx)) != (int )(*(inp + ((int )indx + 2)))) {
        sp->bt_nkeys ++;
      }
    }
    if (((int )type & -129) != 2) {
      sp->bt_ndata ++;
    }
    __Cont: 
    indx = (unsigned short )((int )indx + 2);
  }
  sp->bt_leaf_pg ++;
  if (dbp___1->flags & 2048U) {
    tmp___6 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___6 = sizeof(PG_CHKSUM );
    } else {
      tmp___6 = 0U;
    }
  }
  sp->bt_leaf_pgfree += (unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                        26) +
                                                                                                                       tmp___6)))) +
                                                       (unsigned int )h->entries *
                                                       sizeof(db_indx_t ));
  break;
  case 6: ;
  if ((int )dbp___1->type == 3) {
    sp->bt_nkeys += (unsigned int )top;
    if (dbp___1->flags & 4194304U) {
      sp->bt_ndata += (unsigned int )top;
    } else {
      indx = (unsigned short)0;
      while ((int )indx < (int )top) {
        if (dbp___1->flags & 2048U) {
          tmp___8 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___8 = sizeof(PG_CHKSUM );
          } else {
            tmp___8 = 0U;
          }
        }
        type = ((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                     26) + tmp___8) +
                                                      (int )indx))))->type;
        if (! ((int )type & 128)) {
          sp->bt_ndata ++;
        }
        indx = (unsigned short )((int )indx + 1);
      }
    }
    sp->bt_leaf_pg ++;
    if (dbp___1->flags & 2048U) {
      tmp___10 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___10 = sizeof(PG_CHKSUM );
      } else {
        tmp___10 = 0U;
      }
    }
    sp->bt_leaf_pgfree += (unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                          26) +
                                                                                                                         tmp___10)))) +
                                                         (unsigned int )h->entries *
                                                         sizeof(db_indx_t ));
  } else {
    sp->bt_ndata += (unsigned int )top;
    sp->bt_dup_pg ++;
    if (dbp___1->flags & 2048U) {
      tmp___12 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___12 = sizeof(PG_CHKSUM );
      } else {
        tmp___12 = 0U;
      }
    }
    sp->bt_dup_pgfree += (unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                         26) +
                                                                                                                        tmp___12)))) +
                                                        (unsigned int )h->entries *
                                                        sizeof(db_indx_t ));
  }
  break;
  case 12: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___14 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___14 = sizeof(PG_CHKSUM );
      } else {
        tmp___14 = 0U;
      }
    }
    if (! ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                       26) + tmp___14) +
                                                        (int )indx))))->type & 128)) {
      sp->bt_ndata ++;
    }
    indx = (unsigned short )((int )indx + 1);
  }
  sp->bt_dup_pg ++;
  if (dbp___1->flags & 2048U) {
    tmp___16 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___16 = sizeof(PG_CHKSUM );
    } else {
      tmp___16 = 0U;
    }
  }
  sp->bt_dup_pgfree += (unsigned int )h->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                       26) +
                                                                                                                      tmp___16)))) +
                                                      (unsigned int )h->entries *
                                                      sizeof(db_indx_t ));
  break;
  case 7: 
  sp->bt_over_pg ++;
  if (dbp___1->flags & 2048U) {
    tmp___18 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___18 = sizeof(PG_CHKSUM );
    } else {
      tmp___18 = 0U;
    }
  }
  sp->bt_over_pgfree += (dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                            26) +
                                                                                                           tmp___18))))) -
                        (unsigned int )h->hf_offset;
  break;
  default: 
  tmp___19 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___19);
  }
  return (0);
}
}
int __bam_key_range(DBC *dbc , DBT *dbt , DB_KEY_RANGE *kp , u_int32_t flags ) 
{ BTREE_CURSOR *cp ;
  EPG *sp ;
  double factor ;
  int exact ;
  int ret ;

  {
  flags = 0U;
  flags = flags;
  ret = __bam_search(dbc, 0U, (DBT const   *)dbt, 16384U, 1, (db_recno_t *)((void *)0),
                     & exact);
  if (ret != 0) {
    return (ret);
  }
  cp = (BTREE_CURSOR *)dbc->internal;
  kp->greater = 0.0;
  kp->less = kp->greater;
  factor = 1.0;
  (cp->csp)->entries = (unsigned short )((int )(cp->csp)->entries / 2);
  (cp->csp)->indx = (unsigned short )((int )(cp->csp)->indx / 2);
  sp = cp->sp;
  while ((unsigned int )sp <= (unsigned int )cp->csp) {
    if ((int )sp->indx == 0) {
      kp->greater = kp->greater + (factor * (double )((int )sp->entries - 1)) / (double )sp->entries;
    } else {
      if ((int )sp->indx == (int )sp->entries) {
        kp->less = kp->less + factor;
      } else {
        kp->less = kp->less + (factor * (double )sp->indx) / (double )sp->entries;
        kp->greater = kp->greater + (factor * (double )(((int )sp->entries - (int )sp->indx) -
                                                        1)) / (double )sp->entries;
      }
    }
    factor *= 1.0 / (double )sp->entries;
    sp ++;
  }
  if (exact) {
    kp->equal = factor;
  } else {
    if (kp->less != (double )1) {
      kp->greater = kp->greater + factor;
    }
    kp->equal = (double )0;
  }
  while (1) {
    cp->csp = cp->sp;
    (cp->csp)->page = (PAGE *)((void *)0);
    (cp->csp)->lock.off = 0U;
    break;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-xxGhwCbk.i","-O2")
int __os_fileid(DB_ENV *dbenv___0 , char const   *fname , int unique_okay , u_int8_t *fidp ) ;
int __bam_30_btreemeta(DB *dbp___1 , char *real_name , u_int8_t *buf ) ;
int __bam_31_btreemeta(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp ,
                       PAGE *h , int *dirtyp ) ;
int __bam_31_lbtree(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp ,
                    PAGE *h , int *dirtyp ) ;
int __db_31_offdup(DB *dbp___1 , char *real_name , DB_FH *fhp , int sorted , db_pgno_t *pgnop ) ;
int __bam_30_btreemeta(DB *dbp___1 , char *real_name , u_int8_t *buf ) 
{ BTMETA30 *newmeta ;
  BTMETA2X *oldmeta ;
  DB_ENV *dbenv___0 ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  newmeta = (BTMETA30 *)buf;
  oldmeta = (BTMETA2X *)buf;
  newmeta->re_pad = oldmeta->re_pad;
  newmeta->re_len = oldmeta->re_len;
  newmeta->minkey = oldmeta->minkey;
  newmeta->maxkey = oldmeta->maxkey;
  newmeta->dbmeta.free = oldmeta->free;
  newmeta->dbmeta.flags = oldmeta->flags;
  newmeta->dbmeta.type = (unsigned char)9;
  newmeta->dbmeta.version = 7U;
  ret = __os_fileid(dbenv___0, (char const   *)real_name, 1, buf + 36);
  if (ret != 0) {
    return (ret);
  }
  newmeta->root = 1U;
  return (0);
}
}
int __bam_31_btreemeta(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp ,
                       PAGE *h , int *dirtyp ) 
{ BTMETA31 *newmeta ;
  BTMETA30 *oldmeta ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  real_name = (char *)((void *)0);
  real_name = real_name;
  fhp = (DB_FH *)((void *)0);
  fhp = fhp;
  newmeta = (BTMETA31 *)h;
  oldmeta = (BTMETA30 *)h;
  newmeta->root = oldmeta->root;
  newmeta->re_pad = oldmeta->re_pad;
  newmeta->re_len = oldmeta->re_len;
  newmeta->minkey = oldmeta->minkey;
  newmeta->maxkey = oldmeta->maxkey;
  memmove((void *)(newmeta->dbmeta.uid), (void const   *)(oldmeta->dbmeta.uid), sizeof(oldmeta->dbmeta.uid));
  newmeta->dbmeta.flags = oldmeta->dbmeta.flags;
  newmeta->dbmeta.record_count = 0U;
  newmeta->dbmeta.key_count = 0U;
  while (1) {
    newmeta->dbmeta.unused3.file = 0U;
    newmeta->dbmeta.unused3.offset = 0U;
    break;
  }
  newmeta->dbmeta.version = 8U;
  if (flags & 4U) {
    newmeta->dbmeta.flags |= 64U;
  }
  (*dirtyp) = 1;
  return (0);
}
}
int __bam_31_lbtree(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp ,
                    PAGE *h , int *dirtyp ) 
{ BKEYDATA *bk ;
  db_pgno_t pgno ;
  db_indx_t indx ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;

  {
  ret = 0;
  indx = (unsigned short)1;
  while ((int )indx < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___0) + (int )indx)));
    if (((int )bk->type & -129) == 2) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      pgno = ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                    26) + tmp___2) +
                                                     (int )indx))))->pgno;
      if (flags & 4U) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      ret = __db_31_offdup(dbp___1, real_name, fhp, tmp___3, & pgno);
      if (ret != 0) {
        break;
      }
      if (dbp___1->flags & 2048U) {
        tmp___7 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___7 = sizeof(PG_CHKSUM );
        } else {
          tmp___7 = 0U;
        }
      }
      if (pgno != ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                         26) + tmp___7) +
                                                          (int )indx))))->pgno) {
        (*dirtyp) = 1;
        if (dbp___1->flags & 2048U) {
          tmp___5 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___5 = sizeof(PG_CHKSUM );
          } else {
            tmp___5 = 0U;
          }
        }
        ((BOVERFLOW *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___5) + (int )indx))))->pgno = pgno;
      }
    }
    indx = (unsigned short )((int )indx + 2);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-qgSGUIsz.i","-O2")
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
int __rep_check_alloc(DB_ENV *dbenv___0 , TXN_RECS *r , int n ) ;
int __db_add_recovery(DB_ENV *dbenv___0 , int (***dtab)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsize ,
                      int (*func)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ,
                      u_int32_t ndx ) ;
int __bam_split_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __bam_split_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __bam_rsplit_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __bam_rsplit_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __bam_adj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) ;
int __bam_adj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) ;
int __bam_cadjust_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) ;
int __bam_cadjust_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) ;
int __bam_cdel_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) ;
int __bam_cdel_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) ;
int __bam_repl_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) ;
int __bam_repl_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) ;
int __bam_root_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) ;
int __bam_root_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) ;
int __bam_curadj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __bam_curadj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __bam_rcuradj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) ;
int __bam_rcuradj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) ;
int __bam_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) ;
int __bam_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) ;
int __bam_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __dbreg_lazy_id(DB *dbp___1 ) ;
int __log_put(DB_ENV *dbenv___0 , DB_LSN *lsnp , DBT const   *udbt , u_int32_t flags ) ;
int __txn_activekids(DB_ENV *dbenv___0 , u_int32_t rectype , DB_TXN *txnp ) ;
int __bam_split_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    db_pgno_t left , DB_LSN *llsn , db_pgno_t right , DB_LSN *rlsn ,
                    u_int32_t indx , db_pgno_t npgno , DB_LSN *nlsn , db_pgno_t root_pgno ,
                    DBT const   *pg , u_int32_t opflags ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 62U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )pg == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = pg->size;
  }
  logrec.size = (((((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                           sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*llsn))) +
                        sizeof(u_int32_t )) + sizeof((*rlsn))) + sizeof(u_int32_t )) +
                     sizeof(u_int32_t )) + sizeof((*nlsn))) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = left;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )llsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )llsn, sizeof((*llsn)));
  } else {
    memset((void *)bp, 0, sizeof((*llsn)));
  }
  bp += sizeof((*llsn));
  uinttmp = right;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )rlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )rlsn, sizeof((*rlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*rlsn)));
  }
  bp += sizeof((*rlsn));
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = npgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )nlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )nlsn, sizeof((*nlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*nlsn)));
  }
  bp += sizeof((*nlsn));
  uinttmp = root_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pg == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& pg->size), sizeof(pg->size));
    bp += sizeof(pg->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pg->data, pg->size);
    bp += pg->size;
  }
  uinttmp = opflags;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_split_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_split_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __bam_split_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_split_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_split%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tleft: %lu\n", (unsigned long )argp->left);
  printf((char const   * __restrict  )"\tllsn: [%lu][%lu]\n", (unsigned long )argp->llsn.file,
         (unsigned long )argp->llsn.offset);
  printf((char const   * __restrict  )"\tright: %lu\n", (unsigned long )argp->right);
  printf((char const   * __restrict  )"\trlsn: [%lu][%lu]\n", (unsigned long )argp->rlsn.file,
         (unsigned long )argp->rlsn.offset);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\tnpgno: %lu\n", (unsigned long )argp->npgno);
  printf((char const   * __restrict  )"\tnlsn: [%lu][%lu]\n", (unsigned long )argp->nlsn.file,
         (unsigned long )argp->nlsn.offset);
  printf((char const   * __restrict  )"\troot_pgno: %lu\n", (unsigned long )argp->root_pgno);
  printf((char const   * __restrict  )"\tpg: ");
  i = 0U;
  while (i < argp->pg.size) {
    ch = (int )(*((u_int8_t *)argp->pg.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\topflags: %lu\n", (unsigned long )argp->opflags);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_split_read(DB_ENV *dbenv___0 , void *recbuf , __bam_split_args **argpp ) 
{ __bam_split_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_split_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->left = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->llsn), (void const   * __restrict  )bp, sizeof(argp->llsn));
  bp += sizeof(argp->llsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->right = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->rlsn), (void const   * __restrict  )bp, sizeof(argp->rlsn));
  bp += sizeof(argp->rlsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->npgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->nlsn), (void const   * __restrict  )bp, sizeof(argp->nlsn));
  bp += sizeof(argp->nlsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->root_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->pg), 0, sizeof(argp->pg));
  memcpy((void * __restrict  )(& argp->pg.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->pg.data = (void *)bp;
  bp += argp->pg.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opflags = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_rsplit_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_pgno_t pgno , DBT const   *pgdbt , db_pgno_t root_pgno , db_pgno_t nrec ,
                     DBT const   *rootent , DB_LSN *rootlsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 63U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )pgdbt == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = pgdbt->size;
  }
  if ((unsigned int )rootent == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = rootent->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                     tmp) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                 tmp___0) + sizeof((*rootlsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pgdbt == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& pgdbt->size),
           sizeof(pgdbt->size));
    bp += sizeof(pgdbt->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pgdbt->data, pgdbt->size);
    bp += pgdbt->size;
  }
  uinttmp = root_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = nrec;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )rootent == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rootent->size),
           sizeof(rootent->size));
    bp += sizeof(rootent->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )rootent->data, rootent->size);
    bp += rootent->size;
  }
  if ((unsigned int )rootlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )rootlsn, sizeof((*rootlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*rootlsn)));
  }
  bp += sizeof((*rootlsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_rsplit_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_rsplit_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __bam_rsplit_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_rsplit_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_rsplit%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tpgdbt: ");
  i = 0U;
  while (i < argp->pgdbt.size) {
    ch = (int )(*((u_int8_t *)argp->pgdbt.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\troot_pgno: %lu\n", (unsigned long )argp->root_pgno);
  printf((char const   * __restrict  )"\tnrec: %lu\n", (unsigned long )argp->nrec);
  printf((char const   * __restrict  )"\trootent: ");
  i = 0U;
  while (i < argp->rootent.size) {
    ch = (int )(*((u_int8_t *)argp->rootent.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\trootlsn: [%lu][%lu]\n", (unsigned long )argp->rootlsn.file,
         (unsigned long )argp->rootlsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_rsplit_read(DB_ENV *dbenv___0 , void *recbuf , __bam_rsplit_args **argpp ) 
{ __bam_rsplit_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_rsplit_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->pgdbt), 0, sizeof(argp->pgdbt));
  memcpy((void * __restrict  )(& argp->pgdbt.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->pgdbt.data = (void *)bp;
  bp += argp->pgdbt.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->root_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->nrec = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->rootent), 0, sizeof(argp->rootent));
  memcpy((void * __restrict  )(& argp->rootent.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->rootent.data = (void *)bp;
  bp += argp->rootent.size;
  memcpy((void * __restrict  )(& argp->rootlsn), (void const   * __restrict  )bp,
         sizeof(argp->rootlsn));
  bp += sizeof(argp->rootlsn);
  (*argpp) = argp;
  return (0);
}
}
int __bam_adj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx , u_int32_t indx_copy ,
                  u_int32_t is_insert ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 55U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                    sizeof(u_int32_t )) + sizeof((*lsn))) + sizeof(u_int32_t )) +
                 sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = indx_copy;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = is_insert;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_adj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_adj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) 
{ __bam_adj_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_adj_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_adj%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\tindx_copy: %lu\n", (unsigned long )argp->indx_copy);
  printf((char const   * __restrict  )"\tis_insert: %lu\n", (unsigned long )argp->is_insert);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_adj_read(DB_ENV *dbenv___0 , void *recbuf , __bam_adj_args **argpp ) 
{ __bam_adj_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_adj_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx_copy = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->is_insert = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_cadjust_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx , int32_t adjust ,
                      u_int32_t opflags ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 56U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                    sizeof(u_int32_t )) + sizeof((*lsn))) + sizeof(u_int32_t )) +
                 sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )adjust;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = opflags;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_cadjust_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_cadjust_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) 
{ __bam_cadjust_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_cadjust_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_cadjust%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\tadjust: %ld\n", (long )argp->adjust);
  printf((char const   * __restrict  )"\topflags: %lu\n", (unsigned long )argp->opflags);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_cadjust_read(DB_ENV *dbenv___0 , void *recbuf , __bam_cadjust_args **argpp ) 
{ __bam_cadjust_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_cadjust_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->adjust = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opflags = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_cdel_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 57U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + sizeof((*lsn))) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_cdel_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_cdel_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) 
{ __bam_cdel_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_cdel_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_cdel%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_cdel_read(DB_ENV *dbenv___0 , void *recbuf , __bam_cdel_args **argpp ) 
{ __bam_cdel_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_cdel_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_repl_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t pgno , DB_LSN *lsn , u_int32_t indx , u_int32_t isdeleted ,
                   DBT const   *orig , DBT const   *repl , u_int32_t prefix , u_int32_t suffix ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 58U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )orig == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = orig->size;
  }
  if ((unsigned int )repl == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = repl->size;
  }
  logrec.size = ((((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                          sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*lsn))) +
                       sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                    tmp) + sizeof(u_int32_t )) + tmp___0) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = isdeleted;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )orig == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& orig->size), sizeof(orig->size));
    bp += sizeof(orig->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )orig->data, orig->size);
    bp += orig->size;
  }
  if ((unsigned int )repl == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& repl->size), sizeof(repl->size));
    bp += sizeof(repl->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )repl->data, repl->size);
    bp += repl->size;
  }
  uinttmp = prefix;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = suffix;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_repl_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_repl_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) 
{ __bam_repl_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_repl_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_repl%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\tisdeleted: %lu\n", (unsigned long )argp->isdeleted);
  printf((char const   * __restrict  )"\torig: ");
  i = 0U;
  while (i < argp->orig.size) {
    ch = (int )(*((u_int8_t *)argp->orig.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\trepl: ");
  i = 0U;
  while (i < argp->repl.size) {
    ch = (int )(*((u_int8_t *)argp->repl.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tprefix: %lu\n", (unsigned long )argp->prefix);
  printf((char const   * __restrict  )"\tsuffix: %lu\n", (unsigned long )argp->suffix);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_repl_read(DB_ENV *dbenv___0 , void *recbuf , __bam_repl_args **argpp ) 
{ __bam_repl_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_repl_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->isdeleted = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->orig), 0, sizeof(argp->orig));
  memcpy((void * __restrict  )(& argp->orig.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->orig.data = (void *)bp;
  bp += argp->orig.size;
  memset((void *)(& argp->repl), 0, sizeof(argp->repl));
  memcpy((void * __restrict  )(& argp->repl.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->repl.data = (void *)bp;
  bp += argp->repl.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->prefix = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->suffix = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_root_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t meta_pgno , db_pgno_t root_pgno , DB_LSN *meta_lsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 59U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*meta_lsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = root_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )meta_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )meta_lsn, sizeof((*meta_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*meta_lsn)));
  }
  bp += sizeof((*meta_lsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_root_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_root_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) 
{ __bam_root_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_root_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_root%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\troot_pgno: %lu\n", (unsigned long )argp->root_pgno);
  printf((char const   * __restrict  )"\tmeta_lsn: [%lu][%lu]\n", (unsigned long )argp->meta_lsn.file,
         (unsigned long )argp->meta_lsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_root_read(DB_ENV *dbenv___0 , void *recbuf , __bam_root_args **argpp ) 
{ __bam_root_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_root_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->root_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  (*argpp) = argp;
  return (0);
}
}
int __bam_curadj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_ca_mode mode , db_pgno_t from_pgno , db_pgno_t to_pgno , db_pgno_t left_pgno ,
                     u_int32_t first_indx , u_int32_t from_indx , u_int32_t to_indx ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 64U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )mode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = from_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = to_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = left_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = first_indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = from_indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = to_indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_curadj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_curadj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __bam_curadj_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_curadj_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_curadj%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tmode: %ld\n", (long )argp->mode);
  printf((char const   * __restrict  )"\tfrom_pgno: %lu\n", (unsigned long )argp->from_pgno);
  printf((char const   * __restrict  )"\tto_pgno: %lu\n", (unsigned long )argp->to_pgno);
  printf((char const   * __restrict  )"\tleft_pgno: %lu\n", (unsigned long )argp->left_pgno);
  printf((char const   * __restrict  )"\tfirst_indx: %lu\n", (unsigned long )argp->first_indx);
  printf((char const   * __restrict  )"\tfrom_indx: %lu\n", (unsigned long )argp->from_indx);
  printf((char const   * __restrict  )"\tto_indx: %lu\n", (unsigned long )argp->to_indx);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_curadj_read(DB_ENV *dbenv___0 , void *recbuf , __bam_curadj_args **argpp ) 
{ __bam_curadj_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_curadj_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->mode = (enum __anonenum_db_ca_mode_54 )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->from_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->to_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->left_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->first_indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->from_indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->to_indx = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_rcuradj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      ca_recno_arg mode , db_pgno_t root , db_recno_t recno , u_int32_t order ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 65U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                   sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )mode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = root;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = recno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = order;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __bam_rcuradj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages ++;
  return (0);
}
}
int __bam_rcuradj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) 
{ __bam_rcuradj_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __bam_rcuradj_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__bam_rcuradj%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tmode: %ld\n", (long )argp->mode);
  printf((char const   * __restrict  )"\troot: %ld\n", (long )argp->root);
  printf((char const   * __restrict  )"\trecno: %ld\n", (long )argp->recno);
  printf((char const   * __restrict  )"\torder: %ld\n", (long )argp->order);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __bam_rcuradj_read(DB_ENV *dbenv___0 , void *recbuf , __bam_rcuradj_args **argpp ) 
{ __bam_rcuradj_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__bam_rcuradj_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->mode = (enum __anonenum_ca_recno_arg_53 )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->root = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->recno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->order = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __bam_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_split_print, 62U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_rsplit_print, 63U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_adj_print, 55U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_cadjust_print, 56U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_cdel_print, 57U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_repl_print, 58U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_root_print, 59U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_curadj_print, 64U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_rcuradj_print, 65U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __bam_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_split_getpgnos, 62U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_rsplit_getpgnos, 63U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_adj_getpgnos, 55U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_cadjust_getpgnos, 56U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_cdel_getpgnos, 57U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_repl_getpgnos, 58U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_root_getpgnos, 59U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_curadj_getpgnos, 64U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_rcuradj_getpgnos, 65U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __bam_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_split_recover, 62U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_rsplit_recover, 63U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_adj_recover, 55U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_cadjust_recover, 56U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_cdel_recover, 57U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_repl_recover, 58U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_root_recover, 59U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_curadj_recover, 64U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __bam_rcuradj_recover, 65U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-khcJMGlW.i","-O2")
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
u_int32_t __db_log2(u_int32_t num ) ;
int __ham_quick_delete(DBC *dbc ) ;
int __ham_c_init(DBC *dbc ) ;
int __ham_c_count(DBC *dbc , db_recno_t *recnop ) ;
int __ham_c_dup(DBC *orig_dbc , DBC *new_dbc ) ;
u_int32_t __ham_call_hash(DBC *dbc , u_int8_t *k , int32_t len ) ;
int __ham_init_dbt(DB_ENV *dbenv___0 , DBT *dbt , u_int32_t size , void **bufp , u_int32_t *sizep ) ;
int __ham_c_update(DBC *dbc , u_int32_t len , int add , int is_dup ) ;
int __ham_get_clist(DB *dbp___1 , db_pgno_t pgno , u_int32_t indx , DBC ***listp ) ;
int __ham_metagroup_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        u_int32_t bucket , db_pgno_t mmpgno , DB_LSN *mmetalsn , db_pgno_t mpgno ,
                        DB_LSN *metalsn , db_pgno_t pgno , DB_LSN *pagelsn , u_int32_t newalloc ) ;
int __ham_curadj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_pgno_t pgno , u_int32_t indx , u_int32_t len , u_int32_t dup_off ,
                     int add , int is_dup , u_int32_t order ) ;
int __ham_add_dup(DBC *dbc , DBT *nval , u_int32_t flags , db_pgno_t *pgnop ) ;
int __ham_dup_convert(DBC *dbc ) ;
int __ham_make_dup(DB_ENV *dbenv___0 , DBT const   *notdup , DBT *duplicate , void **bufp ,
                   u_int32_t *sizep ) ;
void __ham_dsearch(DBC *dbc , DBT *dbt , u_int32_t *offp , int *cmpp , u_int32_t flags ) ;
int __ham_get_meta(DBC *dbc ) ;
int __ham_release_meta(DBC *dbc ) ;
int __ham_dirty_meta(DBC *dbc ) ;
int __ham_item(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) ;
int __ham_item_reset(DBC *dbc ) ;
void __ham_item_init(DBC *dbc ) ;
int __ham_item_last(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) ;
int __ham_item_first(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) ;
int __ham_item_prev(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) ;
int __ham_item_next(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) ;
int __ham_del_pair(DBC *dbc , int reclaim_page ) ;
int __ham_replpair(DBC *dbc , DBT *dbt , u_int32_t make_dup ) ;
int __ham_split_page(DBC *dbc , u_int32_t obucket , u_int32_t nbucket ) ;
int __ham_add_el(DBC *dbc , DBT const   *key , DBT const   *val , int type ) ;
int __ham_get_cpage(DBC *dbc , db_lockmode_t mode ) ;
int __ham_lock_bucket(DBC *dbc , db_lockmode_t mode ) ;
static int __ham_bulk(DBC *dbc , DBT *data , u_int32_t flags ) ;
static int __ham_c_close(DBC *dbc , db_pgno_t root_pgno , int *rmroot ) ;
static int __ham_c_del(DBC *dbc ) ;
static int __ham_c_destroy(DBC *dbc ) ;
static int __ham_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
static int __ham_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
static int __ham_c_writelock(DBC *dbc ) ;
static int __ham_dup_return(DBC *dbc , DBT *val , u_int32_t flags ) ;
static int __ham_expand_table(DBC *dbc ) ;
static int __ham_lookup(DBC *dbc , DBT const   *key , u_int32_t sought , db_lockmode_t mode ,
                        db_pgno_t *pgnop ) ;
static int __ham_overwrite(DBC *dbc , DBT *nval , u_int32_t flags ) ;
int __ham_quick_delete(DBC *dbc ) 
{ int ret ;
  int t_ret ;

  {
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    return (ret);
  }
  ret = __ham_del_pair(dbc, 1);
  t_ret = __ham_release_meta(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __ham_c_init(DBC *dbc ) 
{ DB_ENV *dbenv___0 ;
  HASH_CURSOR *new_curs ;
  int ret ;

  {
  dbenv___0 = (dbc->dbp)->dbenv;
  ret = __os_calloc(dbenv___0, 1U, sizeof(struct cursor_t ), (void *)(& new_curs));
  if (ret != 0) {
    return (ret);
  }
  ret = __os_malloc(dbenv___0, (dbc->dbp)->pgsize, (void *)(& new_curs->split_buf));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)new_curs);
    return (ret);
  }
  dbc->internal = (DBC_INTERNAL *)new_curs;
  dbc->c_close = & __db_c_close;
  dbc->c_count = & __db_c_count_pp;
  dbc->c_del = & __db_c_del_pp;
  dbc->c_dup = & __db_c_dup_pp;
  dbc->c_get = & __db_c_get_pp;
  dbc->c_pget = & __db_c_pget_pp;
  dbc->c_put = & __db_c_put_pp;
  dbc->c_am_bulk = & __ham_bulk;
  dbc->c_am_close = & __ham_c_close;
  dbc->c_am_del = & __ham_c_del;
  dbc->c_am_destroy = & __ham_c_destroy;
  dbc->c_am_get = & __ham_c_get;
  dbc->c_am_put = & __ham_c_put;
  dbc->c_am_writelock = & __ham_c_writelock;
  __ham_item_init(dbc);
  return (0);
}
}
static int __ham_c_close(DBC *dbc , db_pgno_t root_pgno , int *rmroot ) 
{ DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  HKEYDATA *dp ;
  int doroot ;
  int gotmeta ;
  int ret ;
  int t_ret ;
  u_int32_t dirty ;
  unsigned int tmp___0 ;

  {
  rmroot = (int *)0;
  rmroot = rmroot;
  mpf = (dbc->dbp)->mpf;
  dirty = 0U;
  ret = 0;
  gotmeta = ret;
  doroot = gotmeta;
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )(dbc->internal)->opd != (unsigned int )((void *)0)) {
    ret = __ham_get_meta(dbc);
    if (ret != 0) {
      goto done;
    }
    gotmeta = 1;
    ret = __ham_get_cpage(dbc, (enum __anonenum_db_lockmode_t_50 )1);
    if (ret != 0) {
      goto out;
    }
    if ((dbc->dbp)->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if ((dbc->dbp)->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    dp = (HKEYDATA *)((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                      26) + tmp___0) +
                                                       ((int )hcp->indx + 1))));
    if ((int )(*((u_int8_t *)dp)) == 4) {
      memcpy((void * __restrict  )(& root_pgno), (void const   * __restrict  )((u_int8_t *)dp +
                                                                               (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
             sizeof(db_pgno_t ));
    } else {
      root_pgno = 0U;
    }
    ret = ((*((hcp->opd)->c_am_close)))(hcp->opd, root_pgno, & doroot);
    if (ret != 0) {
      goto out;
    }
    if (doroot != 0) {
      ret = __ham_del_pair(dbc, 1);
      if (ret != 0) {
        goto out;
      }
      dirty = 2U;
    }
  }
  out: 
  if ((unsigned int )hcp->page != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, hcp->page, dirty);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (gotmeta != 0) {
    t_ret = __ham_release_meta(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  done: 
  __ham_item_init(dbc);
  return (ret);
}
}
static int __ham_c_destroy(DBC *dbc ) 
{ HASH_CURSOR *hcp ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )hcp->split_buf != (unsigned int )((void *)0)) {
    __os_free((dbc->dbp)->dbenv, (void *)hcp->split_buf);
  }
  __os_free((dbc->dbp)->dbenv, (void *)hcp);
  return (0);
}
}
int __ham_c_count(DBC *dbc , db_recno_t *recnop ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  db_indx_t len ;
  db_recno_t recno ;
  int ret ;
  int t_ret ;
  u_int8_t *p ;
  u_int8_t *pend ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  u_int32_t tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  recno = 0U;
  ret = __ham_get_cpage(dbc, (enum __anonenum_db_lockmode_t_50 )1);
  if (ret != 0) {
    return (ret);
  }
  if ((int )hcp->indx >= (int )((PAGE *)hcp->page)->entries) {
    (*recnop) = 0U;
    goto err;
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  switch ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                   26) + tmp___0) +
                                                    ((int )hcp->indx + 1)))))) {
  case 1: ;
  case 3: 
  recno = 1U;
  break;
  case 2: ;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  p = ((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                      tmp___2) + ((int )hcp->indx +
                                                                  1)))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
  if ((int )hcp->indx + 1 == 0) {
    tmp___5 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___7 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___7 = sizeof(PG_CHKSUM );
      } else {
        tmp___7 = 0U;
      }
    }
    tmp___5 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___7) +
                                (((int )hcp->indx + 1) - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___9 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___9 = sizeof(PG_CHKSUM );
    } else {
      tmp___9 = 0U;
    }
  }
  pend = p + (int )((unsigned short )((tmp___5 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                  26) +
                                                                                 tmp___9) +
                                                                   ((int )hcp->indx +
                                                                    1)))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
  while ((unsigned int )p < (unsigned int )pend) {
    memcpy((void * __restrict  )(& len), (void const   * __restrict  )p, sizeof(db_indx_t ));
    p += 2U * sizeof(db_indx_t ) + (unsigned int )len;
    recno ++;
  }
  break;
  default: 
  ret = __db_pgfmt(dbp___1->dbenv, hcp->pgno);
  goto err;
  }
  (*recnop) = recno;
  err: 
  t_ret = __memp_fput(mpf, hcp->page, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  hcp->page = (void *)0;
  return (ret);
}
}
static int __ham_c_del(DBC *dbc ) 
{ DB *dbp___1 ;
  DBT repldbt ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  u_int32_t tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  int tmp___10 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (hcp->flags & 2U) {
    return (-30990);
  }
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    goto out;
  }
  ret = __ham_get_cpage(dbc, (enum __anonenum_db_lockmode_t_50 )2);
  if (ret != 0) {
    goto out;
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  if ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                               26) + tmp___0) + ((int )hcp->indx +
                                                                                 1))))) ==
      4) {
    goto out;
  }
  if (hcp->flags & 32U) {
    if ((int )hcp->dup_off == 0) {
      if ((int )hcp->indx + 1 == 0) {
        tmp___5 = (hcp->hdr)->dbmeta.pagesize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___7 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___7 = sizeof(PG_CHKSUM );
          } else {
            tmp___7 = 0U;
          }
        }
        tmp___5 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___7) +
                                    (((int )hcp->indx + 1) - 1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___9 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___9 = sizeof(PG_CHKSUM );
        } else {
          tmp___9 = 0U;
        }
      }
      if ((unsigned int )hcp->dup_len + 2U * sizeof(db_indx_t ) == (unsigned int )((unsigned short )((tmp___5 -
                                                                                                      (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                                                       26) +
                                                                                                                                      tmp___9) +
                                                                                                                        ((int )hcp->indx +
                                                                                                                         1)))) -
                                                                                                     (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))))) {
        ret = __ham_del_pair(dbc, 1);
      } else {
        goto _L;
      }
    } else {
      _L: 
      repldbt.flags = 0U;
      repldbt.flags = repldbt.flags | 8U;
      repldbt.doff = (unsigned int )hcp->dup_off;
      repldbt.dlen = (unsigned int )hcp->dup_len + 2U * sizeof(db_indx_t );
      repldbt.size = 0U;
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      repldbt.data = (void *)(((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                               26) +
                                                                              tmp___2) +
                                                                ((int )hcp->indx +
                                                                 1)))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
      ret = __ham_replpair(dbc, & repldbt, 0U);
      if (ret == 0) {
        hcp->dup_tlen = (unsigned short )((unsigned int )hcp->dup_tlen - ((unsigned int )hcp->dup_len +
                                                                          2U * sizeof(db_indx_t )));
        hcp->flags |= 2U;
        ret = __ham_c_update(dbc, (unsigned int )hcp->dup_len + 2U * sizeof(db_indx_t ),
                             0, 1);
      }
    }
  } else {
    ret = __ham_del_pair(dbc, 1);
  }
  out: 
  if ((unsigned int )hcp->page != (unsigned int )((void *)0)) {
    if (ret == 0) {
      tmp___10 = 2;
    } else {
      tmp___10 = 0;
    }
    t_ret = __memp_fput(mpf, hcp->page, (unsigned int )tmp___10);
    if (t_ret) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    hcp->page = (void *)0;
  }
  t_ret = __ham_release_meta(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __ham_c_dup(DBC *orig_dbc , DBC *new_dbc ) 
{ HASH_CURSOR *orig ;
  HASH_CURSOR *new ;
  int tmp ;

  {
  orig = (HASH_CURSOR *)orig_dbc->internal;
  new = (HASH_CURSOR *)new_dbc->internal;
  new->bucket = orig->bucket;
  new->lbucket = orig->lbucket;
  new->dup_off = orig->dup_off;
  new->dup_len = orig->dup_len;
  new->dup_tlen = orig->dup_tlen;
  if (orig->flags & 2U) {
    new->flags |= 2U;
  }
  if (orig->flags & 32U) {
    new->flags |= 32U;
  }
  if (! (orig->lock.off != 0U)) {
    return (0);
  } else {
    if ((unsigned int )orig_dbc->txn != (unsigned int )((void *)0)) {
      return (0);
    }
  }
  tmp = __ham_lock_bucket(new_dbc, (enum __anonenum_db_lockmode_t_50 )1);
  return (tmp);
}
}
static int __ham_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  db_lockmode_t lock_type ;
  int get_key ;
  int ret ;
  int t_ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if (dbc->flags & 32U) {
    lock_type = (enum __anonenum_db_lockmode_t_50 )2;
  } else {
    lock_type = (enum __anonenum_db_lockmode_t_50 )1;
  }
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    return (ret);
  }
  hcp->seek_size = 0U;
  ret = 0;
  get_key = 1;
  switch ((int )flags) {
  case 26: 
  hcp->flags |= 64U;
  case 25: ;
  if ((dbc->internal)->pgno != 0U) {
    ret = __ham_item_prev(dbc, lock_type, pgnop);
    break;
  }
  case 17: 
  ret = __ham_item_last(dbc, lock_type, pgnop);
  break;
  case 20: 
  hcp->flags |= 64U;
  case 18: ;
  if ((dbc->internal)->pgno != 0U) {
    ret = __ham_item_next(dbc, lock_type, pgnop);
    break;
  }
  case 9: 
  ret = __ham_item_first(dbc, lock_type, pgnop);
  break;
  case 19: 
  hcp->flags |= 8U;
  ret = __ham_item_next(dbc, lock_type, pgnop);
  break;
  case 28: ;
  case 30: ;
  case 10: ;
  case 12: 
  ret = __ham_lookup(dbc, (DBT const   *)key, 0U, lock_type, pgnop);
  get_key = 0;
  break;
  case 11: 
  hcp->flags |= 8U;
  ret = __ham_item_next(dbc, lock_type, pgnop);
  get_key = 0;
  break;
  case 7: ;
  if (hcp->flags & 2U) {
    ret = -30997;
    goto err;
  }
  ret = __ham_item(dbc, lock_type, pgnop);
  break;
  }
  while (1) {
    if (ret != 0) {
      if (ret != -30990) {
        goto err;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (hcp->flags & 256U) {
        if ((*pgnop) == 0U) {
          ret = __ham_dup_return(dbc, data, flags);
        }
        break;
      } else {
        if (! (hcp->flags & 128U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "H_NOMORE returned to __ham_c_get");
          ret = 22;
          break;
        }
      }
    }
    switch ((int )flags) {
    case 17: ;
    case 25: ;
    case 26: 
    ret = __memp_fput(mpf, hcp->page, 0U);
    hcp->page = (void *)0;
    if (hcp->bucket == 0U) {
      ret = -30990;
      hcp->pgno = 0U;
      goto err;
    }
    hcp->flags &= 4294967263U;
    hcp->bucket --;
    hcp->indx = (unsigned short)65535;
    tmp = __db_log2(hcp->bucket + 1U);
    hcp->pgno = hcp->bucket + (hcp->hdr)->spares[tmp];
    if (ret == 0) {
      ret = __ham_item_prev(dbc, lock_type, pgnop);
    }
    break;
    case 9: ;
    case 18: ;
    case 20: 
    ret = __memp_fput(mpf, hcp->page, 0U);
    hcp->page = (void *)0;
    hcp->indx = (unsigned short)65535;
    hcp->bucket ++;
    hcp->flags &= 4294967263U;
    tmp___0 = __db_log2(hcp->bucket + 1U);
    hcp->pgno = hcp->bucket + (hcp->hdr)->spares[tmp___0];
    if (hcp->bucket > (hcp->hdr)->max_bucket) {
      ret = -30990;
      hcp->pgno = 0U;
      goto err;
    }
    if (ret == 0) {
      ret = __ham_item_next(dbc, lock_type, pgnop);
    }
    break;
    case 10: ;
    case 11: ;
    case 12: ;
    case 19: ;
    case 28: ;
    case 30: 
    ret = -30990;
    goto err;
    case 7: 
    ret = -30997;
    goto err;
    default: ;
    }
  }
  if (get_key == 0) {
    key->flags = key->flags | 2U;
  }
  err: 
  t_ret = __ham_release_meta(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  hcp->flags &= 4294967287U;
  hcp->flags &= 4294967231U;
  return (ret);
}
}
static int __ham_bulk(DBC *dbc , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *cp ;
  PAGE *pg ;
  db_indx_t dup_len ;
  db_indx_t dup_off ;
  db_indx_t dup_tlen ;
  db_indx_t indx ;
  db_indx_t *inp ;
  db_lockmode_t lock_mode ;
  db_pgno_t pgno ;
  int32_t *endp ;
  int32_t key_off ;
  int32_t *offp ;
  int32_t *saveoff ;
  u_int32_t key_size ;
  u_int32_t size ;
  u_int32_t space ;
  u_int8_t *dbuf ;
  u_int8_t *dp ;
  u_int8_t *hk ;
  u_int8_t *np ;
  u_int8_t *tmp ;
  int is_dup ;
  int is_key ;
  int need_pg ;
  int next_key ;
  int no_dup ;
  int pagesize ;
  int ret ;
  int t_ret ;
  int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;
  int tmp___18 ;
  unsigned int tmp___20 ;
  unsigned int tmp___22 ;
  u_int32_t tmp___23 ;
  int tmp___26 ;
  unsigned int tmp___28 ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int32_t *tmp___33 ;
  int32_t *tmp___34 ;
  int32_t *tmp___35 ;
  int32_t *tmp___36 ;
  int32_t *tmp___37 ;
  int32_t *tmp___38 ;
  int tmp___41 ;
  unsigned int tmp___43 ;
  unsigned int tmp___45 ;
  int32_t *tmp___46 ;
  int32_t *tmp___47 ;
  int32_t *tmp___48 ;
  int tmp___49 ;
  int32_t *tmp___50 ;
  int32_t *tmp___51 ;
  int32_t *tmp___52 ;
  int32_t *tmp___53 ;
  u_int32_t tmp___54 ;

  {
  ret = 0;
  key_off = 0;
  dup_tlen = (unsigned short)0;
  dup_off = dup_tlen;
  dup_len = dup_off;
  size = 0U;
  dbp___1 = dbc->dbp;
  pagesize = (int )dbp___1->pgsize;
  mpf = dbp___1->mpf;
  cp = (HASH_CURSOR *)dbc->internal;
  if (flags & 134217728U) {
    is_key = 1;
  } else {
    is_key = 0;
  }
  if (is_key) {
    if ((flags & 255U) != 19U) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  next_key = tmp___0;
  no_dup = (flags & 255U) == 20U;
  dbuf = (u_int8_t *)data->data;
  dp = dbuf;
  np = dp;
  space = data->ulen;
  space -= sizeof((*offp));
  endp = (int32_t *)(dbuf + data->ulen);
  endp --;
  offp = endp;
  key_size = 0U;
  if (dbc->flags & 32U) {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  } else {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
  }
  next_pg: 
  need_pg = 1;
  indx = cp->indx;
  pg = (PAGE *)cp->page;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pg + 26) + tmp___2);
  while (1) {
    if (is_key) {
      if (dbp___1->flags & 2048U) {
        tmp___4 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___4 = sizeof(PG_CHKSUM );
        } else {
          tmp___4 = 0U;
        }
      }
      hk = (u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___4) +
                                     (int )indx));
      if ((int )(*hk) == 3) {
        memcpy((void * __restrict  )(& key_size), (void const   * __restrict  )(hk +
                                                                                (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->tlen)))),
               sizeof(u_int32_t ));
        memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
               sizeof(db_pgno_t ));
        size = key_size;
        if (key_size > space) {
          goto get_key_space;
        }
        ret = __bam_bulk_overflow(dbc, key_size, pgno, np);
        if (ret != 0) {
          return (ret);
        }
        space -= key_size;
        key_off = np - dbuf;
        np += key_size;
      } else {
        if (need_pg) {
          dp = np;
          size = (unsigned int )(pagesize - (int )pg->hf_offset);
          if (space < size) {
            get_key_space: 
            if ((unsigned int )offp == (unsigned int )endp) {
              data->size = (unsigned int )((unsigned long long )(((size + (unsigned int )pagesize) +
                                                                  1024U) - 1U) & 0xfffffffffffffc00ULL);
              return (12);
            }
            goto back_up;
          }
          memcpy((void * __restrict  )dp, (void const   * __restrict  )((u_int8_t *)pg +
                                                                        (int )pg->hf_offset),
                 size);
          need_pg = 0;
          space -= size;
          np += size;
        }
        if ((int )indx == 0) {
          tmp___7 = pagesize;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___9 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___9 = sizeof(PG_CHKSUM );
            } else {
              tmp___9 = 0U;
            }
          }
          tmp___7 = (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___9) + ((int )indx -
                                                                               1)));
        }
        if (dbp___1->flags & 2048U) {
          tmp___11 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___11 = sizeof(PG_CHKSUM );
          } else {
            tmp___11 = 0U;
          }
        }
        key_size = (unsigned int )((unsigned short )((tmp___7 - (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                                        26) +
                                                                                       tmp___11) +
                                                                         (int )indx))) -
                                                     (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
        key_off = ((dp + ((int )(*(inp + (int )indx)) - (int )pg->hf_offset)) - dbuf) +
                  (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___13 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___13 = sizeof(PG_CHKSUM );
      } else {
        tmp___13 = 0U;
      }
    }
    hk = (u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___13) +
                                   ((int )indx + 1)));
    switch ((int )(*hk)) {
    case 2: ;
    case 1: ;
    if (need_pg) {
      dp = np;
      size = (unsigned int )(pagesize - (int )pg->hf_offset);
      if (space < size) {
        back_up: 
        if ((int )indx != 0) {
          indx = (unsigned short )((int )indx - 2);
          if (dbp___1->flags & 2048U) {
            tmp___15 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___15 = sizeof(PG_CHKSUM );
            } else {
              tmp___15 = 0U;
            }
          }
          tmp = (u_int8_t *)pg + (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___15) +
                                          ((int )indx + 1)));
          if ((int )(*tmp) == 2) {
            if (((int )indx + 1) + 1 == 0) {
              tmp___18 = pagesize;
            } else {
              if (dbp___1->flags & 2048U) {
                tmp___20 = sizeof(PG_CRYPTO );
              } else {
                if (dbp___1->flags & 1U) {
                  tmp___20 = sizeof(PG_CHKSUM );
                } else {
                  tmp___20 = 0U;
                }
              }
              tmp___18 = (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___20) +
                                  ((((int )indx + 1) + 1) - 1)));
            }
            if (dbp___1->flags & 2048U) {
              tmp___22 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___22 = sizeof(PG_CHKSUM );
              } else {
                tmp___22 = 0U;
              }
            }
            dup_tlen = (unsigned short )((tmp___18 - (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                             26) +
                                                                            tmp___22) +
                                                              (((int )indx + 1) +
                                                               1)))) - (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
            dup_off = dup_tlen;
            memcpy((void * __restrict  )(& dup_len), (void const   * __restrict  )(tmp +
                                                                                   (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))),
                   sizeof(db_indx_t ));
          } else {
            is_dup = 0;
            dup_len = (unsigned short)0;
            dup_off = (unsigned short)0;
            dup_tlen = (unsigned short)0;
            cp->flags &= 4294967263U;
          }
          goto get_space;
        }
        cp->dup_len = dup_len;
        cp->dup_off = dup_off;
        cp->dup_tlen = dup_tlen;
        ret = __ham_item_prev(dbc, lock_mode, & pgno);
        if (ret != 0) {
          if (ret != -30990) {
            return (ret);
          }
          ret = __memp_fput(mpf, cp->page, 0U);
          if (ret != 0) {
            return (ret);
          }
          cp->page = (void *)0;
          if (cp->bucket == 0U) {
            indx = (unsigned short)65535;
            cp->indx = indx;
            goto get_space;
          }
          ret = __ham_get_meta(dbc);
          if (ret != 0) {
            return (ret);
          }
          cp->bucket --;
          tmp___23 = __db_log2(cp->bucket + 1U);
          cp->pgno = cp->bucket + (cp->hdr)->spares[tmp___23];
          cp->indx = (unsigned short)65535;
          ret = __ham_release_meta(dbc);
          if (ret != 0) {
            return (ret);
          }
          ret = __ham_item_prev(dbc, lock_mode, & pgno);
          if (ret != 0) {
            return (ret);
          }
        }
        indx = cp->indx;
        get_space: 
        if ((unsigned int )offp >= (unsigned int )endp) {
          data->size = (unsigned int )((unsigned long long )((((size + data->ulen) -
                                                               space) + 1024U) - 1U) &
                                       0xfffffffffffffc00ULL);
          return (12);
        } else {
          if (dbc->flags & 64U) {
            data->size = (unsigned int )((unsigned long long )((((size + data->ulen) -
                                                                 space) + 1024U) -
                                                               1U) & 0xfffffffffffffc00ULL);
            return (12);
          }
        }
        next_key = 0;
        break;
      }
      memcpy((void * __restrict  )dp, (void const   * __restrict  )((u_int8_t *)pg +
                                                                    (int )pg->hf_offset),
             size);
      need_pg = 0;
      space -= size;
      np += size;
    }
    if (cp->flags & 32U) {
      is_dup = 1;
      dup_len = cp->dup_len;
      dup_off = cp->dup_off;
      dup_tlen = cp->dup_tlen;
    } else {
      if ((int )(*hk) == 2) {
        is_dup = 1;
        cp->flags |= 32U;
        dup_off = (unsigned short)0;
        memcpy((void * __restrict  )(& dup_len), (void const   * __restrict  )(hk +
                                                                               (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))),
               sizeof(db_indx_t ));
        if ((int )indx + 1 == 0) {
          tmp___26 = pagesize;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___28 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___28 = sizeof(PG_CHKSUM );
            } else {
              tmp___28 = 0U;
            }
          }
          tmp___26 = (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___28) + (((int )indx +
                                                                                  1) -
                                                                                 1)));
        }
        if (dbp___1->flags & 2048U) {
          tmp___30 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___30 = sizeof(PG_CHKSUM );
          } else {
            tmp___30 = 0U;
          }
        }
        dup_tlen = (unsigned short )((tmp___26 - (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                         26) + tmp___30) +
                                                          ((int )indx + 1)))) - (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
      } else {
        is_dup = 0;
        dup_len = (unsigned short)0;
        dup_off = (unsigned short)0;
        dup_tlen = (unsigned short)0;
      }
    }
    while (1) {
      if (is_key) {
        tmp___31 = 4;
      } else {
        tmp___31 = 2;
      }
      space -= (unsigned int )tmp___31 * sizeof((*offp));
      if (is_key) {
        tmp___32 = 4;
      } else {
        tmp___32 = 2;
      }
      size += (unsigned int )tmp___32 * sizeof((*offp));
      if (space > data->ulen) {
        if (! is_dup) {
          goto back_up;
        } else {
          if ((int )dup_off == 0) {
            goto back_up;
          }
        }
        dup_off = (unsigned short )((int )dup_off - (int )((unsigned short )((unsigned int )(*(offp +
                                                                                               1)) +
                                                                             2U *
                                                                             sizeof(db_indx_t ))));
        goto get_space;
      }
      if (is_key) {
        tmp___33 = offp;
        offp --;
        (*tmp___33) = key_off;
        tmp___34 = offp;
        offp --;
        (*tmp___34) = (int )key_size;
      }
      if (is_dup) {
        tmp___35 = offp;
        offp --;
        (*tmp___35) = (int )((unsigned int )((((dp + ((int )(*(inp + ((int )indx +
                                                                      1))) - (int )pg->hf_offset)) -
                                               dbuf) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                             (int )dup_off) + sizeof(db_indx_t ));
        memcpy((void * __restrict  )(& dup_len), (void const   * __restrict  )((hk +
                                                                                (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                                                               (int )dup_off),
               sizeof(db_indx_t ));
        dup_off = (unsigned short )((unsigned int )dup_off + ((unsigned int )dup_len +
                                                              2U * sizeof(db_indx_t )));
        tmp___36 = offp;
        offp --;
        (*tmp___36) = (int )dup_len;
      } else {
        tmp___37 = offp;
        offp --;
        (*tmp___37) = ((dp + ((int )(*(inp + ((int )indx + 1))) - (int )pg->hf_offset)) -
                       dbuf) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
        tmp___38 = offp;
        offp --;
        if ((int )indx + 1 == 0) {
          tmp___41 = pagesize;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___43 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___43 = sizeof(PG_CHKSUM );
            } else {
              tmp___43 = 0U;
            }
          }
          tmp___41 = (int )(*((db_indx_t *)(((u_int8_t *)pg + 26) + tmp___43) + (((int )indx +
                                                                                  1) -
                                                                                 1)));
        }
        if (dbp___1->flags & 2048U) {
          tmp___45 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___45 = sizeof(PG_CHKSUM );
          } else {
            tmp___45 = 0U;
          }
        }
        (*tmp___38) = (int )((unsigned short )((tmp___41 - (int )(*((db_indx_t *)(((u_int8_t *)pg +
                                                                                   26) +
                                                                                  tmp___45) +
                                                                    ((int )indx +
                                                                     1)))) - (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
      }
      if (is_dup) {
        if ((int )dup_off < (int )dup_tlen) {
          if (! (no_dup == 0)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    }
    cp->flags &= 4294967263U;
    break;
    case 4: 
    memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
           sizeof(db_pgno_t ));
    space -= 2U * sizeof((*offp));
    if (space > data->ulen) {
      goto back_up;
    }
    if (is_key) {
      space -= 2U * sizeof((*offp));
      if (space > data->ulen) {
        goto back_up;
      }
      tmp___46 = offp;
      offp --;
      (*tmp___46) = key_off;
      tmp___47 = offp;
      offp --;
      (*tmp___47) = (int )key_size;
    }
    saveoff = offp;
    if (is_key) {
      tmp___48 = offp + 2;
    } else {
      tmp___48 = (int32_t *)((void *)0);
    }
    ret = __bam_bulk_duplicates(dbc, pgno, dbuf, tmp___48, & offp, & np, & space,
                                no_dup);
    if (ret != 0) {
      if (ret == 12) {
        size = space;
        space = 0U;
        if (is_key) {
          if ((unsigned int )saveoff == (unsigned int )offp) {
            offp += 2;
            goto back_up;
          }
        }
        goto get_space;
      }
      return (ret);
    }
    break;
    case 3: ;
    if (is_key) {
      tmp___49 = 4;
    } else {
      tmp___49 = 2;
    }
    space -= (unsigned int )tmp___49 * sizeof((*offp));
    if (space > data->ulen) {
      goto back_up;
    }
    memcpy((void * __restrict  )(& size), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->tlen)))),
           sizeof(u_int32_t ));
    memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
           sizeof(db_pgno_t ));
    if (size > space) {
      goto back_up;
    }
    ret = __bam_bulk_overflow(dbc, size, pgno, np);
    if (ret != 0) {
      return (ret);
    }
    if (is_key) {
      tmp___50 = offp;
      offp --;
      (*tmp___50) = key_off;
      tmp___51 = offp;
      offp --;
      (*tmp___51) = (int )key_size;
    }
    tmp___52 = offp;
    offp --;
    (*tmp___52) = np - dbuf;
    tmp___53 = offp;
    offp --;
    (*tmp___53) = (int )size;
    np += size;
    space -= size;
    break;
    }
    if (next_key) {
      indx = (unsigned short )((int )indx + 2);
      if (! ((int )indx < (int )pg->entries)) {
        break;
      }
    } else {
      break;
    }
  }
  cp->indx = indx;
  cp->dup_len = dup_len;
  cp->dup_off = dup_off;
  cp->dup_tlen = dup_tlen;
  if (ret == 0) {
    if (next_key) {
      if ((int )indx >= (int )pg->entries) {
        ret = __ham_item_next(dbc, lock_mode, & pgno);
        if (ret == 0) {
          goto next_pg;
        }
        if (ret != -30990) {
          return (ret);
        }
        ret = __memp_fput((dbc->dbp)->mpf, cp->page, 0U);
        if (ret != 0) {
          return (ret);
        }
        cp->page = (void *)0;
        ret = __ham_get_meta(dbc);
        if (ret != 0) {
          return (ret);
        }
        cp->bucket ++;
        if (cp->bucket > (cp->hdr)->max_bucket) {
          cp->bucket --;
          ret = -30990;
        } else {
          tmp___54 = __db_log2(cp->bucket + 1U);
          cp->pgno = cp->bucket + (cp->hdr)->spares[tmp___54];
          cp->indx = (unsigned short)65535;
          cp->flags &= 4294967263U;
          ret = __ham_item_next(dbc, lock_mode, & pgno);
        }
        t_ret = __ham_release_meta(dbc);
        if (t_ret != 0) {
          return (t_ret);
        }
        if (ret == 0) {
          goto next_pg;
        }
        if (ret != -30990) {
          return (ret);
        }
      }
    }
  }
  (*offp) = -1;
  return (0);
}
}
static int __ham_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  DBT tmp_val ;
  DBT *myval ;
  HASH_CURSOR *hcp ;
  u_int32_t nbytes ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  myval = (DBT *)((void *)0);
  myval = myval;
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (hcp->flags & 2U) {
    if (flags != 15U) {
      if (flags != 16U) {
        return (-30990);
      }
    }
  }
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    goto err1;
  }
  switch ((int )flags) {
  case 16: ;
  case 15: ;
  case 21: ;
  if (key->size > (hcp->hdr)->dbmeta.pagesize / 4U) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  if (tmp___1) {
    tmp___0 = sizeof(HOFFPAGE ) + sizeof(db_indx_t );
  } else {
    tmp___0 = (key->size + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
              sizeof(db_indx_t );
  }
  if (data->size > (hcp->hdr)->dbmeta.pagesize / 4U) {
    tmp___4 = 1;
  } else {
    tmp___4 = 0;
  }
  if (tmp___4) {
    tmp___3 = sizeof(HOFFPAGE ) + sizeof(db_indx_t );
  } else {
    tmp___3 = (data->size + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
              sizeof(db_indx_t );
  }
  nbytes = tmp___0 + tmp___3;
  ret = __ham_lookup(dbc, (DBT const   *)key, nbytes, (enum __anonenum_db_lockmode_t_50 )2,
                     pgnop);
  if (ret == -30990) {
    ret = 0;
    if (hcp->seek_found_page != 0U) {
      if (hcp->seek_found_page != hcp->pgno) {
        ret = __memp_fput(mpf, hcp->page, 0U);
        if (ret != 0) {
          goto err2;
        }
        hcp->page = (void *)0;
        hcp->pgno = hcp->seek_found_page;
        hcp->indx = (unsigned short)65535;
      }
    }
    if (data->flags & 8U) {
      if (data->doff != 0U) {
        ret = __ham_init_dbt(dbp___1->dbenv, & tmp_val, data->size + data->doff, & dbc->my_rdata.data,
                             & dbc->my_rdata.ulen);
        if (ret == 0) {
          memset(tmp_val.data, 0, data->doff);
          memcpy((void * __restrict  )((u_int8_t *)tmp_val.data + data->doff), (void const   * __restrict  )data->data,
                 data->size);
          myval = & tmp_val;
        }
      } else {
        myval = data;
      }
    } else {
      myval = data;
    }
    if (ret == 0) {
      ret = __ham_add_el(dbc, (DBT const   *)key, (DBT const   *)myval, 1);
    }
    goto done;
  }
  break;
  case 3: ;
  case 1: ;
  case 7: 
  ret = __ham_item(dbc, (enum __anonenum_db_lockmode_t_50 )2, pgnop);
  break;
  }
  if ((*pgnop) == 0U) {
    if (ret == 0) {
      if (flags == 7U) {
        ret = __ham_overwrite(dbc, data, flags);
      } else {
        if (flags == 15U) {
          goto _L;
        } else {
          if (flags == 16U) {
            goto _L;
          } else {
            if (flags == 21U) {
              _L: 
              if (dbp___1->flags & 512U) {
                ret = __ham_add_dup(dbc, data, flags, pgnop);
              } else {
                if (key->flags & 64U) {
                  ret = __ham_add_dup(dbc, data, flags, pgnop);
                } else {
                  ret = __ham_overwrite(dbc, data, flags);
                }
              }
            } else {
              ret = __ham_add_dup(dbc, data, flags, pgnop);
            }
          }
        }
      }
    }
  }
  done: 
  if (ret == 0) {
    if (hcp->flags & 16U) {
      ret = __ham_expand_table(dbc);
      hcp->flags &= 4294967279U;
    }
  }
  if ((unsigned int )hcp->page != (unsigned int )((void *)0)) {
    t_ret = __memp_fset(mpf, hcp->page, 2U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  err2: 
  t_ret = __ham_release_meta(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  err1: 
  return (ret);
}
}
static int __ham_expand_table(DBC *dbc ) 
{ DB *dbp___1 ;
  DB_LOCK metalock ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  DBMETA *mmeta ;
  HASH_CURSOR *hcp ;
  PAGE *h ;
  db_pgno_t pgno ;
  db_pgno_t mpgno ;
  u_int32_t newalloc ;
  u_int32_t new_bucket ;
  u_int32_t old_bucket ;
  int dirty_meta ;
  int got_meta ;
  int logn ;
  int new_double ;
  int ret ;
  u_int32_t tmp ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_dirty_meta(dbc);
  if (ret != 0) {
    return (ret);
  }
  metalock.off = 0U;
  mmeta = (DBMETA *)hcp->hdr;
  mpgno = mmeta->pgno;
  h = (PAGE *)((void *)0);
  dirty_meta = 0;
  got_meta = 0;
  newalloc = 0U;
  new_bucket = (hcp->hdr)->max_bucket + 1U;
  old_bucket = new_bucket & (hcp->hdr)->low_mask;
  new_double = (hcp->hdr)->max_bucket == (hcp->hdr)->high_mask;
  logn = (int )__db_log2(new_bucket);
  if (! new_double) {
    goto _L;
  } else {
    if ((hcp->hdr)->spares[logn + 1] != 0U) {
      _L: 
      tmp = __db_log2(new_bucket + 1U);
      pgno = new_bucket + (hcp->hdr)->spares[tmp];
      ret = __memp_fget(mpf, & pgno, 1U, (void *)(& h));
      if (ret != 0) {
        goto err;
      }
      lsn = h->lsn;
    } else {
      if (dbp___1->flags & 134217728U) {
        mpgno = 0U;
        ret = __db_lget(dbc, 0, mpgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & metalock);
        if (ret != 0) {
          goto err;
        }
        ret = __memp_fget(mpf, & mpgno, 0U, (void *)(& mmeta));
        if (ret != 0) {
          goto err;
        }
        got_meta = 1;
      }
      pgno = mmeta->last_pgno + 1U;
      while (1) {
        lsn.file = 0U;
        lsn.offset = 0U;
        break;
      }
      newalloc = 1U;
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___4;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          ret = __ham_metagroup_log(dbp___1, dbc->txn, & lsn, 0U, (hcp->hdr)->max_bucket,
                                    mpgno, & mmeta->lsn, (hcp->hdr)->dbmeta.pgno,
                                    & (hcp->hdr)->dbmeta.lsn, pgno, & lsn, newalloc);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    while (1) {
      lsn.file = 0U;
      lsn.offset = 1U;
      break;
    }
  }
  (hcp->hdr)->dbmeta.lsn = lsn;
  if (new_double) {
    if ((hcp->hdr)->spares[logn + 1] == 0U) {
      (hcp->hdr)->spares[logn + 1] = pgno - new_bucket;
      pgno += (hcp->hdr)->max_bucket;
      ret = __memp_fget(mpf, & pgno, 1U, (void *)(& h));
      if (ret != 0) {
        goto err;
      }
      mmeta->last_pgno = pgno;
      mmeta->lsn = lsn;
      dirty_meta = 2;
      while (1) {
        h->pgno = pgno;
        h->prev_pgno = 0U;
        h->next_pgno = 0U;
        h->entries = (unsigned short)0;
        h->hf_offset = (unsigned short )dbp___1->pgsize;
        h->level = (unsigned char)0;
        h->type = (unsigned char)2;
        break;
      }
    }
  }
  h->lsn = lsn;
  ret = __memp_fput(mpf, (void *)h, 2U);
  if (ret != 0) {
    goto err;
  }
  h = (PAGE *)((void *)0);
  (hcp->hdr)->max_bucket = new_bucket;
  if (new_double) {
    (hcp->hdr)->low_mask = (hcp->hdr)->high_mask;
    (hcp->hdr)->high_mask = new_bucket | (hcp->hdr)->low_mask;
  }
  ret = __ham_split_page(dbc, old_bucket, new_bucket);
  err: 
  if (got_meta) {
    __memp_fput(mpf, (void *)mmeta, (unsigned int )dirty_meta);
  }
  if (metalock.off != 0U) {
    if (metalock.off != 0U) {
      __db_lput(dbc, & metalock);
    }
  }
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)h, 0U);
  }
  return (ret);
}
}
u_int32_t __ham_call_hash(DBC *dbc , u_int8_t *k , int32_t len ) 
{ DB *dbp___1 ;
  u_int32_t n ;
  u_int32_t bucket ;
  HASH_CURSOR *hcp ;
  HASH *hashp ;
  u_int32_t tmp ;

  {
  dbp___1 = dbc->dbp;
  hcp = (HASH_CURSOR *)dbc->internal;
  hashp = (HASH *)dbp___1->h_internal;
  tmp = ((*(hashp->h_hash)))(dbp___1, (void const   *)k, (unsigned int )len);
  n = tmp;
  bucket = n & (hcp->hdr)->high_mask;
  if (bucket > (hcp->hdr)->max_bucket) {
    bucket = bucket & (hcp->hdr)->low_mask;
  }
  return (bucket);
}
}
static int __ham_dup_return(DBC *dbc , DBT *val , u_int32_t flags ) 
{ DB *dbp___1 ;
  HASH_CURSOR *hcp ;
  PAGE *pp ;
  DBT *myval ;
  DBT tmp_val ;
  db_indx_t ndx ;
  db_pgno_t pgno ;
  u_int32_t off ;
  u_int32_t tlen ;
  u_int8_t *hk ;
  u_int8_t type ;
  int cmp ;
  int ret ;
  db_indx_t len ;
  unsigned int tmp___0 ;
  u_int32_t tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;
  u_int32_t tmp___14 ;
  unsigned int tmp___16 ;
  unsigned int tmp___18 ;

  {
  dbp___1 = dbc->dbp;
  hcp = (HASH_CURSOR *)dbc->internal;
  ndx = (unsigned short )((int )hcp->indx + 1);
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  type = (*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                            26) + tmp___0) + (int )ndx))));
  pp = (PAGE *)hcp->page;
  myval = val;
  if ((int )type != 2) {
    if (flags != 10U) {
      if (flags != 11U) {
        if (flags != 12U) {
          return (0);
        }
      }
    }
  }
  if (! (hcp->flags & 32U)) {
    if ((int )type == 2) {
      hcp->flags |= 32U;
      if ((int )hcp->indx + 1 == 0) {
        tmp___3 = (hcp->hdr)->dbmeta.pagesize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___5 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___5 = sizeof(PG_CHKSUM );
          } else {
            tmp___5 = 0U;
          }
        }
        tmp___3 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___5) +
                                    (((int )hcp->indx + 1) - 1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___7 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___7 = sizeof(PG_CHKSUM );
        } else {
          tmp___7 = 0U;
        }
      }
      hcp->dup_tlen = (unsigned short )((tmp___3 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                    26) +
                                                                                   tmp___7) +
                                                                     ((int )hcp->indx +
                                                                      1)))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
      if (dbp___1->flags & 2048U) {
        tmp___9 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___9 = sizeof(PG_CHKSUM );
        } else {
          tmp___9 = 0U;
        }
      }
      hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                           26) + tmp___9) + ((int )hcp->indx +
                                                                             1)));
      if (flags == 17U) {
        goto _L;
      } else {
        if (flags == 25U) {
          goto _L;
        } else {
          if (flags == 26U) {
            _L: 
            hcp->dup_off = (unsigned short)0;
            while (1) {
              memcpy((void * __restrict  )(& len), (void const   * __restrict  )((hk +
                                                                                  (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                                                                 (int )hcp->dup_off),
                     sizeof(db_indx_t ));
              hcp->dup_off = (unsigned short )((unsigned int )hcp->dup_off + ((unsigned int )len +
                                                                              2U *
                                                                              sizeof(db_indx_t )));
              if (! ((int )hcp->dup_off < (int )hcp->dup_tlen)) {
                break;
              }
            }
            hcp->dup_off = (unsigned short )((unsigned int )hcp->dup_off - ((unsigned int )len +
                                                                            2U * sizeof(db_indx_t )));
          } else {
            memcpy((void * __restrict  )(& len), (void const   * __restrict  )(hk +
                                                                               (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))),
                   sizeof(db_indx_t ));
            hcp->dup_off = (unsigned short)0;
          }
        }
      }
      hcp->dup_len = len;
    }
  }
  if (flags == 10U) {
    goto _L___0;
  } else {
    if (flags == 11U) {
      goto _L___0;
    } else {
      if (flags == 12U) {
        _L___0: 
        if (hcp->flags & 32U) {
          if (flags == 11U) {
            hcp->flags |= 1U;
          }
          __ham_dsearch(dbc, val, & off, & cmp, flags);
          hcp->flags &= 4294967294U;
          hcp->dup_off = (unsigned short )off;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___11 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___11 = sizeof(PG_CHKSUM );
            } else {
              tmp___11 = 0U;
            }
          }
          hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                               26) + tmp___11) + ((int )hcp->indx +
                                                                                  1)));
          if ((int )((HKEYDATA *)hk)->type == 3) {
            memcpy((void * __restrict  )(& tlen), (void const   * __restrict  )(hk +
                                                                                (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->tlen)))),
                   sizeof(u_int32_t ));
            memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(hk +
                                                                                (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
                   sizeof(db_pgno_t ));
            ret = __db_moff(dbp___1, (DBT const   *)val, pgno, tlen, dbp___1->dup_compare,
                            & cmp);
            if (ret != 0) {
              return (ret);
            }
          } else {
            tmp_val.data = (void *)(hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
            if ((int )hcp->indx + 1 == 0) {
              tmp___14 = dbp___1->pgsize;
            } else {
              if (dbp___1->flags & 2048U) {
                tmp___16 = sizeof(PG_CRYPTO );
              } else {
                if (dbp___1->flags & 1U) {
                  tmp___16 = sizeof(PG_CHKSUM );
                } else {
                  tmp___16 = 0U;
                }
              }
              tmp___14 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                          26) + tmp___16) + (((int )hcp->indx +
                                                                              1) -
                                                                             1)));
            }
            if (dbp___1->flags & 2048U) {
              tmp___18 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___18 = sizeof(PG_CHKSUM );
              } else {
                tmp___18 = 0U;
              }
            }
            tmp_val.size = (unsigned int )((unsigned short )((tmp___14 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                          26) +
                                                                                                         tmp___18) +
                                                                                           ((int )hcp->indx +
                                                                                            1)))) -
                                                             (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
            if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
              cmp = __bam_defcmp(dbp___1, (DBT const   *)(& tmp_val), (DBT const   *)val);
            } else {
              cmp = ((*(dbp___1->dup_compare)))(dbp___1, (DBT const   *)(& tmp_val),
                                                (DBT const   *)val);
            }
          }
        }
        if (cmp != 0) {
          return (-30990);
        }
      }
    }
  }
  if (dbc->flags & 1536U) {
    return (0);
  }
  if (hcp->flags & 32U) {
    memcpy((void * __restrict  )(& tmp_val), (void const   * __restrict  )val, sizeof((*val)));
    if (tmp_val.flags & 8U) {
      if (tmp_val.doff + (unsigned int )hcp->dup_off > (unsigned int )hcp->dup_len) {
        tmp_val.dlen = 0U;
      } else {
        if (tmp_val.dlen + tmp_val.doff > (unsigned int )hcp->dup_len) {
          tmp_val.dlen = (unsigned int )hcp->dup_len - tmp_val.doff;
        }
      }
      tmp_val.doff = tmp_val.doff + (unsigned int )hcp->dup_off;
    } else {
      tmp_val.flags = tmp_val.flags | 8U;
      tmp_val.dlen = (unsigned int )hcp->dup_len;
      tmp_val.doff = (unsigned int )hcp->dup_off + sizeof(db_indx_t );
    }
    myval = & tmp_val;
  }
  ret = __db_ret(dbp___1, pp, (unsigned int )ndx, myval, & (dbc->rdata)->data, & (dbc->rdata)->ulen);
  if (ret != 0) {
    return (ret);
  }
  val->data = myval->data;
  val->size = myval->size;
  val->flags = val->flags | 2U;
  return (0);
}
}
static int __ham_overwrite(DBC *dbc , DBT *nval , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  HASH_CURSOR *hcp ;
  DBT *myval ;
  DBT tmp_val ;
  DBT tmp_val2 ;
  void *newrec ;
  u_int8_t *hk ;
  u_int8_t *p ;
  u_int32_t len ;
  u_int32_t nondup_size ;
  db_indx_t newsize ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___9 ;
  u_int32_t tmp___12 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  int tmp___17 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (hcp->flags & 32U) {
    if (nval->flags & 8U) {
      memset((void *)(& tmp_val), 0, sizeof(tmp_val));
      ret = __ham_dup_return(dbc, & tmp_val, 7U);
      if (ret != 0) {
        return (ret);
      }
      nondup_size = tmp_val.size;
      newsize = (unsigned short )nondup_size;
      if (nval->doff > nondup_size) {
        newsize = (unsigned short )((unsigned int )newsize + ((nval->doff - nondup_size) +
                                                              nval->size));
      } else {
        if (nval->doff + nval->dlen > nondup_size) {
          newsize = (unsigned short )((unsigned int )newsize + (nval->size - (nondup_size -
                                                                              nval->doff)));
        } else {
          newsize = (unsigned short )((unsigned int )newsize + (nval->size - nval->dlen));
        }
      }
      if (((unsigned int )hcp->dup_tlen - nondup_size) + (unsigned int )newsize >
          (hcp->hdr)->dbmeta.pagesize / 4U) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
      if (tmp___0) {
        ret = __ham_dup_convert(dbc);
        if (ret != 0) {
          return (ret);
        }
        tmp = ((*((hcp->opd)->c_am_put)))(hcp->opd, (DBT *)((void *)0), nval, flags,
                                          (db_pgno_t *)((void *)0));
        return (tmp);
      }
      ret = __os_malloc(dbp___1->dbenv, (unsigned int )newsize + 2U * sizeof(db_indx_t ),
                        (void *)(& newrec));
      if (ret != 0) {
        return (ret);
      }
      memset((void *)(& tmp_val2), 0, sizeof(tmp_val2));
      tmp_val2.flags = tmp_val2.flags | 8U;
      p = (u_int8_t *)newrec;
      memcpy((void * __restrict  )p, (void const   * __restrict  )(& newsize), sizeof(db_indx_t ));
      p += sizeof(db_indx_t );
      if (nval->doff > tmp_val.size) {
        len = tmp_val.size;
      } else {
        len = nval->doff;
      }
      memcpy((void * __restrict  )p, (void const   * __restrict  )tmp_val.data, len);
      p += len;
      if (nval->doff > tmp_val.size) {
        memset((void *)p, 0, nval->doff - tmp_val.size);
        p += nval->doff - tmp_val.size;
      }
      memcpy((void * __restrict  )p, (void const   * __restrict  )nval->data, nval->size);
      p += nval->size;
      if (nval->doff + nval->dlen < tmp_val.size) {
        len = (tmp_val.size - nval->doff) - nval->dlen;
        memcpy((void * __restrict  )p, (void const   * __restrict  )(((u_int8_t *)tmp_val.data +
                                                                      nval->doff) +
                                                                     nval->dlen),
               len);
        p += len;
      }
      memcpy((void * __restrict  )p, (void const   * __restrict  )(& newsize), sizeof(db_indx_t ));
      if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
        tmp_val2.data = (void *)((u_int8_t *)newrec + sizeof(db_indx_t ));
        tmp_val2.size = (unsigned int )newsize;
        tmp___2 = ((*(dbp___1->dup_compare)))(dbp___1, (DBT const   *)(& tmp_val),
                                              (DBT const   *)(& tmp_val2));
        if (tmp___2 != 0) {
          __os_free(dbenv___0, newrec);
          tmp___1 = __db_duperr(dbp___1, flags);
          return (tmp___1);
        }
      }
      tmp_val2.data = newrec;
      tmp_val2.size = (unsigned int )newsize + 2U * sizeof(db_indx_t );
      tmp_val2.doff = (unsigned int )hcp->dup_off;
      tmp_val2.dlen = (unsigned int )hcp->dup_len + 2U * sizeof(db_indx_t );
      ret = __ham_replpair(dbc, & tmp_val2, 0U);
      __os_free(dbenv___0, newrec);
      if (ret != 0) {
        return (ret);
      }
      if ((unsigned int )newsize > nondup_size) {
        hcp->dup_tlen = (unsigned short )((unsigned int )hcp->dup_tlen + ((unsigned int )newsize -
                                                                          nondup_size));
      } else {
        hcp->dup_tlen = (unsigned short )((unsigned int )hcp->dup_tlen - (nondup_size -
                                                                          (unsigned int )newsize));
      }
      hcp->dup_len = newsize;
      return (0);
    } else {
      if ((unsigned int )((int )hcp->dup_tlen - (int )hcp->dup_len) + nval->size >
          (hcp->hdr)->dbmeta.pagesize / 4U) {
        tmp___4 = 1;
      } else {
        tmp___4 = 0;
      }
      if (tmp___4) {
        ret = __ham_dup_convert(dbc);
        if (ret != 0) {
          return (ret);
        }
        tmp___3 = ((*((hcp->opd)->c_am_put)))(hcp->opd, (DBT *)((void *)0), nval,
                                              flags, (db_pgno_t *)((void *)0));
        return (tmp___3);
      }
      if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
        if (dbp___1->flags & 2048U) {
          tmp___6 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___6 = sizeof(PG_CHKSUM );
          } else {
            tmp___6 = 0U;
          }
        }
        tmp_val2.data = (void *)(((((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                    26) +
                                                                                   tmp___6) +
                                                                     ((int )hcp->indx +
                                                                      1)))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                  (int )hcp->dup_off) + sizeof(db_indx_t ));
        tmp_val2.size = (unsigned int )hcp->dup_len;
        tmp___7 = ((*(dbp___1->dup_compare)))(dbp___1, (DBT const   *)nval, (DBT const   *)(& tmp_val2));
        if (tmp___7 != 0) {
          __db_err((DB_ENV const   *)dbenv___0, "Existing data sorts differently from put data");
          return (22);
        }
      }
      ret = __ham_make_dup(dbp___1->dbenv, (DBT const   *)nval, & tmp_val, & dbc->my_rdata.data,
                           & dbc->my_rdata.ulen);
      if (ret != 0) {
        return (ret);
      }
      tmp_val.doff = (unsigned int )hcp->dup_off;
      tmp_val.dlen = (unsigned int )hcp->dup_len + 2U * sizeof(db_indx_t );
      if (nval->size > (unsigned int )hcp->dup_len) {
        hcp->dup_tlen = (unsigned short )((unsigned int )hcp->dup_tlen + (nval->size -
                                                                          (unsigned int )hcp->dup_len));
      } else {
        hcp->dup_tlen = (unsigned short )((unsigned int )hcp->dup_tlen - ((unsigned int )hcp->dup_len -
                                                                          nval->size));
      }
      hcp->dup_len = (unsigned short )nval->size;
    }
    myval = & tmp_val;
  } else {
    if (! (nval->flags & 8U)) {
      memcpy((void * __restrict  )(& tmp_val), (void const   * __restrict  )nval,
             sizeof((*nval)));
      tmp_val.flags = tmp_val.flags | 8U;
      tmp_val.doff = 0U;
      if (dbp___1->flags & 2048U) {
        tmp___9 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___9 = sizeof(PG_CHKSUM );
        } else {
          tmp___9 = 0U;
        }
      }
      hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                           26) + tmp___9) + ((int )hcp->indx +
                                                                             1)));
      if ((int )(*hk) == 3) {
        memcpy((void * __restrict  )(& tmp_val.dlen), (void const   * __restrict  )(hk +
                                                                                    (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->tlen)))),
               sizeof(u_int32_t ));
      } else {
        if ((int )hcp->indx + 1 == 0) {
          tmp___12 = (hcp->hdr)->dbmeta.pagesize;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___14 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___14 = sizeof(PG_CHKSUM );
            } else {
              tmp___14 = 0U;
            }
          }
          tmp___12 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                     tmp___14) + (((int )hcp->indx +
                                                                   1) - 1)));
        }
        if (dbp___1->flags & 2048U) {
          tmp___16 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___16 = sizeof(PG_CHKSUM );
          } else {
            tmp___16 = 0U;
          }
        }
        tmp_val.dlen = (unsigned int )((unsigned short )((tmp___12 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                      26) +
                                                                                                     tmp___16) +
                                                                                       ((int )hcp->indx +
                                                                                        1)))) -
                                                         (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
      }
      myval = & tmp_val;
    } else {
      myval = nval;
    }
  }
  tmp___17 = __ham_replpair(dbc, myval, 0U);
  return (tmp___17);
}
}
static int __ham_lookup(DBC *dbc , DBT const   *key , u_int32_t sought , db_lockmode_t mode ,
                        db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  HASH_CURSOR *hcp ;
  db_pgno_t pgno ;
  u_int32_t tlen ;
  int match ;
  int ret ;
  u_int8_t *hk ;
  u_int8_t *dk ;
  u_int32_t tmp ;
  unsigned int tmp___1 ;
  unsigned int tmp___3 ;
  u_int32_t tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  dbp___1 = dbc->dbp;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_item_reset(dbc);
  if (ret != 0) {
    return (ret);
  }
  hcp->seek_size = sought;
  hcp->bucket = __ham_call_hash(dbc, (u_int8_t *)key->data, (int )key->size);
  tmp = __db_log2(hcp->bucket + 1U);
  hcp->pgno = hcp->bucket + (hcp->hdr)->spares[tmp];
  while (1) {
    (*pgnop) = 0U;
    ret = __ham_item_next(dbc, mode, pgnop);
    if (ret != 0) {
      return (ret);
    }
    if (hcp->flags & 128U) {
      break;
    }
    if (dbp___1->flags & 2048U) {
      tmp___1 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___1 = sizeof(PG_CHKSUM );
      } else {
        tmp___1 = 0U;
      }
    }
    hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                        tmp___1) + (int )hcp->indx));
    switch ((int )(*hk)) {
    case 3: 
    memcpy((void * __restrict  )(& tlen), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->tlen)))),
           sizeof(u_int32_t ));
    if (tlen == key->size) {
      memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
             sizeof(db_pgno_t ));
      ret = __db_moff(dbp___1, key, pgno, tlen, (int (*)(DB * , DBT const   * , DBT const   * ))((void *)0),
                      & match);
      if (ret != 0) {
        return (ret);
      }
      if (match == 0) {
        goto found_key;
      }
    }
    break;
    case 1: ;
    if ((int )hcp->indx == 0) {
      tmp___6 = dbp___1->pgsize;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___8 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___8 = sizeof(PG_CHKSUM );
        } else {
          tmp___8 = 0U;
        }
      }
      tmp___6 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___8) +
                                  ((int )hcp->indx - 1)));
    }
    if (dbp___1->flags & 2048U) {
      tmp___10 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___10 = sizeof(PG_CHKSUM );
      } else {
        tmp___10 = 0U;
      }
    }
    if (key->size == (unsigned int )((unsigned short )((tmp___6 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                   26) +
                                                                                                  tmp___10) +
                                                                                    (int )hcp->indx))) -
                                                       (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))))) {
      tmp___11 = memcmp((void const   *)key->data, (void const   *)(hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))),
                        key->size);
      if (tmp___11 == 0) {
        found_key: 
        hcp->flags |= 256U;
        if (dbp___1->flags & 2048U) {
          tmp___3 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___3 = sizeof(PG_CHKSUM );
          } else {
            tmp___3 = 0U;
          }
        }
        dk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                             26) + tmp___3) + ((int )hcp->indx +
                                                                               1)));
        if ((int )(*dk) == 4) {
          memcpy((void * __restrict  )pgnop, (void const   * __restrict  )(dk + (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
                 sizeof(db_pgno_t ));
        }
        return (0);
      }
    }
    break;
    case 2: ;
    case 4: 
    tmp___12 = __db_pgfmt(dbp___1->dbenv, ((PAGE *)hcp->page)->pgno);
    return (tmp___12);
    }
  }
  if (sought != 0U) {
    return (ret);
  }
  return (ret);
}
}
int __ham_init_dbt(DB_ENV *dbenv___0 , DBT *dbt , u_int32_t size , void **bufp , u_int32_t *sizep ) 
{ int ret ;

  {
  memset((void *)dbt, 0, sizeof((*dbt)));
  if ((*sizep) < size) {
    ret = __os_realloc(dbenv___0, size, (void *)bufp);
    if (ret != 0) {
      (*sizep) = 0U;
      return (ret);
    }
    (*sizep) = size;
  }
  dbt->data = (*bufp);
  dbt->size = size;
  return (0);
}
}
int __ham_c_update(DBC *dbc , u_int32_t len , int add , int is_dup ) 
{ DB *dbp___1 ;
  DB *ldbp ;
  DBC *cp ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  HASH_CURSOR *hcp ;
  HASH_CURSOR *lcp ;
  int found ;
  int ret ;
  u_int32_t order ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  order = 0U;
  if (! add) {
    order = 1U;
    ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
    while (1) {
      if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
        if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
          break;
        }
      } else {
        break;
      }
      if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbp___1->mutexp)->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
        }
      }
      cp = ldbp->active_queue.tqh_first;
      while ((unsigned int )cp != (unsigned int )((void *)0)) {
        if ((unsigned int )cp == (unsigned int )dbc) {
          goto __Cont;
        } else {
          if ((int )cp->dbtype != 2) {
            goto __Cont;
          }
        }
        lcp = (HASH_CURSOR *)cp->internal;
        if (lcp->flags & 2U) {
          if (hcp->pgno == lcp->pgno) {
            if ((int )hcp->indx == (int )lcp->indx) {
              if (order <= lcp->order) {
                if (! is_dup) {
                  order = lcp->order + 1U;
                } else {
                  if ((int )hcp->dup_off == (int )lcp->dup_off) {
                    order = lcp->order + 1U;
                  }
                }
              }
            }
          }
        }
        __Cont: 
        cp = cp->links.tqe_next;
      }
      if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbp___1->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
        }
      }
      ldbp = ldbp->dblistlinks.le_next;
    }
    hcp->order = order;
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    cp = ldbp->active_queue.tqh_first;
    while ((unsigned int )cp != (unsigned int )((void *)0)) {
      if ((unsigned int )cp == (unsigned int )dbc) {
        goto __Cont___0;
      } else {
        if ((int )cp->dbtype != 2) {
          goto __Cont___0;
        }
      }
      lcp = (HASH_CURSOR *)cp->internal;
      if (lcp->pgno != hcp->pgno) {
        goto __Cont___0;
      } else {
        if ((int )lcp->indx == 65535) {
          goto __Cont___0;
        }
      }
      if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
        if ((unsigned int )cp->txn != (unsigned int )my_txn) {
          found = 1;
        }
      }
      if (! is_dup) {
        if (add) {
          if ((int )lcp->indx == (int )hcp->indx) {
            if (lcp->flags & 2U) {
              if (lcp->order == hcp->order) {
                lcp->flags &= 4294967293U;
              } else {
                if (lcp->order > hcp->order) {
                  lcp->order -= hcp->order - 1U;
                  lcp->indx = (unsigned short )((int )lcp->indx + 2);
                }
              }
            } else {
              goto _L;
            }
          } else {
            _L: 
            if ((int )lcp->indx >= (int )hcp->indx) {
              lcp->indx = (unsigned short )((int )lcp->indx + 2);
            }
          }
        } else {
          if ((int )lcp->indx > (int )hcp->indx) {
            lcp->indx = (unsigned short )((int )lcp->indx - 2);
            if ((int )lcp->indx == (int )hcp->indx) {
              if (lcp->flags & 2U) {
                lcp->order += order;
              }
            }
          } else {
            if ((int )lcp->indx == (int )hcp->indx) {
              if (! (lcp->flags & 2U)) {
                lcp->flags |= 2U;
                lcp->flags &= 4294967263U;
                lcp->order = order;
              }
            }
          }
        }
      } else {
        if ((int )lcp->indx == (int )hcp->indx) {
          if (add) {
            lcp->dup_tlen = (unsigned short )((unsigned int )lcp->dup_tlen + len);
            if ((int )lcp->dup_off == (int )hcp->dup_off) {
              if (hcp->flags & 2U) {
                if (lcp->flags & 2U) {
                  if (lcp->order == hcp->order) {
                    lcp->flags &= 4294967293U;
                  } else {
                    if (lcp->order > hcp->order) {
                      lcp->order -= hcp->order - 1U;
                      lcp->dup_off = (unsigned short )((unsigned int )lcp->dup_off +
                                                       len);
                    }
                  }
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            } else {
              _L___1: 
              if ((int )lcp->dup_off >= (int )hcp->dup_off) {
                lcp->dup_off = (unsigned short )((unsigned int )lcp->dup_off + len);
              }
            }
          } else {
            lcp->dup_tlen = (unsigned short )((unsigned int )lcp->dup_tlen - len);
            if ((int )lcp->dup_off > (int )hcp->dup_off) {
              lcp->dup_off = (unsigned short )((unsigned int )lcp->dup_off - len);
              if ((int )lcp->dup_off == (int )hcp->dup_off) {
                if (lcp->flags & 2U) {
                  lcp->order += order;
                }
              }
            } else {
              if ((int )lcp->dup_off == (int )hcp->dup_off) {
                if (! (lcp->flags & 2U)) {
                  lcp->flags |= 2U;
                  lcp->order = order;
                }
              }
            }
          }
        }
      }
      __Cont___0: 
      cp = cp->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          } else {
            _L___3: 
            ret = __ham_curadj_log(dbp___1, my_txn, & lsn, 0U, hcp->pgno, (unsigned int )hcp->indx,
                                   len, (unsigned int )hcp->dup_off, add, is_dup,
                                   order);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
int __ham_get_clist(DB *dbp___1 , db_pgno_t pgno , u_int32_t indx , DBC ***listp ) 
{ DB *ldbp ;
  DBC *cp ;
  DB_ENV *dbenv___0 ;
  int nalloc ;
  int nused ;
  int ret ;
  int tmp ;

  {
  nused = 0;
  nalloc = nused;
  (*listp) = (DBC **)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    cp = ldbp->active_queue.tqh_first;
    while ((unsigned int )cp != (unsigned int )((void *)0)) {
      if ((cp->internal)->pgno == pgno) {
        if (indx == 65535U) {
          goto _L;
        } else {
          if ((unsigned int )(cp->internal)->indx == indx) {
            _L: 
            if (nused >= nalloc) {
              nalloc += 10;
              ret = __os_realloc(dbp___1->dbenv, (unsigned int )nalloc * sizeof(HASH_CURSOR *),
                                 (void *)listp);
              if (ret != 0) {
                goto err;
              }
            }
            tmp = nused;
            nused ++;
            (*((*listp) + tmp)) = cp;
          }
        }
      }
      cp = cp->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbp___1->dbenv, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if ((unsigned int )listp != (unsigned int )((void *)0)) {
    if (nused >= nalloc) {
      nalloc ++;
      ret = __os_realloc(dbp___1->dbenv, (unsigned int )nalloc * sizeof(HASH_CURSOR *),
                         (void *)listp);
      if (ret != 0) {
        return (ret);
      }
    }
    (*((*listp) + nused)) = (DBC *)((void *)0);
  }
  return (0);
  err: 
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbp___1->dbenv, dbp___1->mutexp);
    }
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (ret);
}
}
static int __ham_c_writelock(DBC *dbc ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCK tmp_lock ;
  HASH_CURSOR *hcp ;
  int ret ;

  {
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if (! ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0))) {
        return (0);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  hcp = (HASH_CURSOR *)dbc->internal;
  if (! (hcp->lock.off != 0U)) {
    goto _L;
  } else {
    if ((int )hcp->lock_mode == 1) {
      _L: 
      tmp_lock = hcp->lock;
      ret = __ham_lock_bucket(dbc, (enum __anonenum_db_lockmode_t_50 )2);
      if (ret != 0) {
        return (ret);
      }
      dbenv___0 = (dbc->dbp)->dbenv;
      if (tmp_lock.off != 0U) {
        ret = __lock_put(dbenv___0, & tmp_lock);
        if (ret != 0) {
          return (ret);
        }
      }
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-2Xz2tBqC.i","-O2")
int __ham_insdel_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     u_int32_t opcode , db_pgno_t pgno , u_int32_t ndx , DB_LSN *pagelsn ,
                     DBT const   *key , DBT const   *data ) ;
int __ham_insdel_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __ham_insdel_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __ham_insdel_read(DB_ENV *dbenv___0 , void *recbuf , __ham_insdel_args **argpp ) ;
int __ham_newpage_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      u_int32_t opcode , db_pgno_t prev_pgno , DB_LSN *prevlsn , db_pgno_t new_pgno ,
                      DB_LSN *pagelsn , db_pgno_t next_pgno , DB_LSN *nextlsn ) ;
int __ham_newpage_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) ;
int __ham_newpage_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) ;
int __ham_newpage_read(DB_ENV *dbenv___0 , void *recbuf , __ham_newpage_args **argpp ) ;
int __ham_splitdata_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        u_int32_t opcode , db_pgno_t pgno , DBT const   *pageimage ,
                        DB_LSN *pagelsn ) ;
int __ham_splitdata_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) ;
int __ham_splitdata_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) ;
int __ham_splitdata_read(DB_ENV *dbenv___0 , void *recbuf , __ham_splitdata_args **argpp ) ;
int __ham_replace_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      db_pgno_t pgno , u_int32_t ndx , DB_LSN *pagelsn , int32_t off ,
                      DBT const   *olditem , DBT const   *newitem , u_int32_t makedup ) ;
int __ham_replace_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) ;
int __ham_replace_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) ;
int __ham_replace_read(DB_ENV *dbenv___0 , void *recbuf , __ham_replace_args **argpp ) ;
int __ham_copypage_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                       db_pgno_t pgno , DB_LSN *pagelsn , db_pgno_t next_pgno , DB_LSN *nextlsn ,
                       db_pgno_t nnext_pgno , DB_LSN *nnextlsn , DBT const   *page ) ;
int __ham_copypage_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                            void *summary ) ;
int __ham_copypage_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                         void *notused3 ) ;
int __ham_copypage_read(DB_ENV *dbenv___0 , void *recbuf , __ham_copypage_args **argpp ) ;
int __ham_metagroup_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) ;
int __ham_metagroup_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) ;
int __ham_metagroup_read(DB_ENV *dbenv___0 , void *recbuf , __ham_metagroup_args **argpp ) ;
int __ham_groupalloc_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                         DB_LSN *meta_lsn , db_pgno_t start_pgno , u_int32_t num ,
                         db_pgno_t free___0 ) ;
int __ham_groupalloc_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                              void *summary ) ;
int __ham_groupalloc_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                           void *notused3 ) ;
int __ham_groupalloc_read(DB_ENV *dbenv___0 , void *recbuf , __ham_groupalloc_args **argpp ) ;
int __ham_curadj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __ham_curadj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __ham_curadj_read(DB_ENV *dbenv___0 , void *recbuf , __ham_curadj_args **argpp ) ;
int __ham_chgpg_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    db_ham_mode mode , db_pgno_t old_pgno , db_pgno_t new_pgno , u_int32_t old_indx ,
                    u_int32_t new_indx ) ;
int __ham_chgpg_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __ham_chgpg_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __ham_chgpg_read(DB_ENV *dbenv___0 , void *recbuf , __ham_chgpg_args **argpp ) ;
int __ham_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) ;
int __ham_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) ;
int __ham_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __ham_insdel_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __ham_newpage_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) ;
int __ham_replace_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) ;
int __ham_splitdata_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) ;
int __ham_copypage_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                           void *info ) ;
int __ham_metagroup_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) ;
int __ham_groupalloc_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                             void *info ) ;
int __ham_curadj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __ham_chgpg_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __ham_insdel_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     u_int32_t opcode , db_pgno_t pgno , u_int32_t ndx , DB_LSN *pagelsn ,
                     DBT const   *key , DBT const   *data ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 21U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = key->size;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = data->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                     sizeof(u_int32_t )) + sizeof((*pagelsn))) + sizeof(u_int32_t )) +
                  tmp) + sizeof(u_int32_t )) + tmp___0;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = ndx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& key->size), sizeof(key->size));
    bp += sizeof(key->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )key->data, key->size);
    bp += key->size;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& data->size), sizeof(data->size));
    bp += sizeof(data->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )data->data, data->size);
    bp += data->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_insdel_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_insdel_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __ham_insdel_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_insdel_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_insdel%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tndx: %lu\n", (unsigned long )argp->ndx);
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\tkey: ");
  i = 0U;
  while (i < argp->key.size) {
    ch = (int )(*((u_int8_t *)argp->key.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tdata: ");
  i = 0U;
  while (i < argp->data.size) {
    ch = (int )(*((u_int8_t *)argp->data.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_insdel_read(DB_ENV *dbenv___0 , void *recbuf , __ham_insdel_args **argpp ) 
{ __ham_insdel_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_insdel_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->ndx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  memset((void *)(& argp->key), 0, sizeof(argp->key));
  memcpy((void * __restrict  )(& argp->key.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->key.data = (void *)bp;
  bp += argp->key.size;
  memset((void *)(& argp->data), 0, sizeof(argp->data));
  memcpy((void * __restrict  )(& argp->data.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->data.data = (void *)bp;
  bp += argp->data.size;
  (*argpp) = argp;
  return (0);
}
}
int __ham_newpage_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      u_int32_t opcode , db_pgno_t prev_pgno , DB_LSN *prevlsn , db_pgno_t new_pgno ,
                      DB_LSN *pagelsn , db_pgno_t next_pgno , DB_LSN *nextlsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 22U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*prevlsn))) +
                   sizeof(u_int32_t )) + sizeof((*pagelsn))) + sizeof(u_int32_t )) +
                sizeof((*nextlsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = prev_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )prevlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )prevlsn, sizeof((*prevlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*prevlsn)));
  }
  bp += sizeof((*prevlsn));
  uinttmp = new_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  uinttmp = next_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )nextlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )nextlsn, sizeof((*nextlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*nextlsn)));
  }
  bp += sizeof((*nextlsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_newpage_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_newpage_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) 
{ __ham_newpage_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_newpage_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_newpage%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tprev_pgno: %lu\n", (unsigned long )argp->prev_pgno);
  printf((char const   * __restrict  )"\tprevlsn: [%lu][%lu]\n", (unsigned long )argp->prevlsn.file,
         (unsigned long )argp->prevlsn.offset);
  printf((char const   * __restrict  )"\tnew_pgno: %lu\n", (unsigned long )argp->new_pgno);
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\tnext_pgno: %lu\n", (unsigned long )argp->next_pgno);
  printf((char const   * __restrict  )"\tnextlsn: [%lu][%lu]\n", (unsigned long )argp->nextlsn.file,
         (unsigned long )argp->nextlsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_newpage_read(DB_ENV *dbenv___0 , void *recbuf , __ham_newpage_args **argpp ) 
{ __ham_newpage_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_newpage_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->prev_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->prevlsn), (void const   * __restrict  )bp,
         sizeof(argp->prevlsn));
  bp += sizeof(argp->prevlsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->new_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->nextlsn), (void const   * __restrict  )bp,
         sizeof(argp->nextlsn));
  bp += sizeof(argp->nextlsn);
  (*argpp) = argp;
  return (0);
}
}
int __ham_splitdata_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        u_int32_t opcode , db_pgno_t pgno , DBT const   *pageimage ,
                        DB_LSN *pagelsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 24U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )pageimage == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = pageimage->size;
  }
  logrec.size = (((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                    sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                 tmp) + sizeof((*pagelsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pageimage == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& pageimage->size),
           sizeof(pageimage->size));
    bp += sizeof(pageimage->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pageimage->data,
           pageimage->size);
    bp += pageimage->size;
  }
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_splitdata_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_splitdata_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) 
{ __ham_splitdata_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_splitdata_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_splitdata%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tpageimage: ");
  i = 0U;
  while (i < argp->pageimage.size) {
    ch = (int )(*((u_int8_t *)argp->pageimage.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_splitdata_read(DB_ENV *dbenv___0 , void *recbuf , __ham_splitdata_args **argpp ) 
{ __ham_splitdata_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_splitdata_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->pageimage), 0, sizeof(argp->pageimage));
  memcpy((void * __restrict  )(& argp->pageimage.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->pageimage.data = (void *)bp;
  bp += argp->pageimage.size;
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  (*argpp) = argp;
  return (0);
}
}
int __ham_replace_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      db_pgno_t pgno , u_int32_t ndx , DB_LSN *pagelsn , int32_t off ,
                      DBT const   *olditem , DBT const   *newitem , u_int32_t makedup ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 25U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )olditem == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = olditem->size;
  }
  if ((unsigned int )newitem == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = newitem->size;
  }
  logrec.size = (((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                         sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                      sizeof((*pagelsn))) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   tmp) + sizeof(u_int32_t )) + tmp___0) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = ndx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  uinttmp = (unsigned int )off;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )olditem == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& olditem->size),
           sizeof(olditem->size));
    bp += sizeof(olditem->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )olditem->data, olditem->size);
    bp += olditem->size;
  }
  if ((unsigned int )newitem == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& newitem->size),
           sizeof(newitem->size));
    bp += sizeof(newitem->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )newitem->data, newitem->size);
    bp += newitem->size;
  }
  uinttmp = makedup;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_replace_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_replace_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) 
{ __ham_replace_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_replace_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_replace%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tndx: %lu\n", (unsigned long )argp->ndx);
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\toff: %ld\n", (long )argp->off);
  printf((char const   * __restrict  )"\tolditem: ");
  i = 0U;
  while (i < argp->olditem.size) {
    ch = (int )(*((u_int8_t *)argp->olditem.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tnewitem: ");
  i = 0U;
  while (i < argp->newitem.size) {
    ch = (int )(*((u_int8_t *)argp->newitem.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tmakedup: %lu\n", (unsigned long )argp->makedup);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_replace_read(DB_ENV *dbenv___0 , void *recbuf , __ham_replace_args **argpp ) 
{ __ham_replace_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_replace_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->ndx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->off = (int )uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->olditem), 0, sizeof(argp->olditem));
  memcpy((void * __restrict  )(& argp->olditem.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->olditem.data = (void *)bp;
  bp += argp->olditem.size;
  memset((void *)(& argp->newitem), 0, sizeof(argp->newitem));
  memcpy((void * __restrict  )(& argp->newitem.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->newitem.data = (void *)bp;
  bp += argp->newitem.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->makedup = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __ham_copypage_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                       db_pgno_t pgno , DB_LSN *pagelsn , db_pgno_t next_pgno , DB_LSN *nextlsn ,
                       db_pgno_t nnext_pgno , DB_LSN *nnextlsn , DBT const   *page ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 28U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )page == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = page->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*pagelsn))) +
                     sizeof(u_int32_t )) + sizeof((*nextlsn))) + sizeof(u_int32_t )) +
                  sizeof((*nnextlsn))) + sizeof(u_int32_t )) + tmp;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  uinttmp = next_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )nextlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )nextlsn, sizeof((*nextlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*nextlsn)));
  }
  bp += sizeof((*nextlsn));
  uinttmp = nnext_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )nnextlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )nnextlsn, sizeof((*nnextlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*nnextlsn)));
  }
  bp += sizeof((*nnextlsn));
  if ((unsigned int )page == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& page->size), sizeof(page->size));
    bp += sizeof(page->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )page->data, page->size);
    bp += page->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_copypage_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                            void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_copypage_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                         void *notused3 ) 
{ __ham_copypage_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_copypage_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_copypage%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\tnext_pgno: %lu\n", (unsigned long )argp->next_pgno);
  printf((char const   * __restrict  )"\tnextlsn: [%lu][%lu]\n", (unsigned long )argp->nextlsn.file,
         (unsigned long )argp->nextlsn.offset);
  printf((char const   * __restrict  )"\tnnext_pgno: %lu\n", (unsigned long )argp->nnext_pgno);
  printf((char const   * __restrict  )"\tnnextlsn: [%lu][%lu]\n", (unsigned long )argp->nnextlsn.file,
         (unsigned long )argp->nnextlsn.offset);
  printf((char const   * __restrict  )"\tpage: ");
  i = 0U;
  while (i < argp->page.size) {
    ch = (int )(*((u_int8_t *)argp->page.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_copypage_read(DB_ENV *dbenv___0 , void *recbuf , __ham_copypage_args **argpp ) 
{ __ham_copypage_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_copypage_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->nextlsn), (void const   * __restrict  )bp,
         sizeof(argp->nextlsn));
  bp += sizeof(argp->nextlsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->nnext_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->nnextlsn), (void const   * __restrict  )bp,
         sizeof(argp->nnextlsn));
  bp += sizeof(argp->nnextlsn);
  memset((void *)(& argp->page), 0, sizeof(argp->page));
  memcpy((void * __restrict  )(& argp->page.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->page.data = (void *)bp;
  bp += argp->page.size;
  (*argpp) = argp;
  return (0);
}
}
int __ham_metagroup_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        u_int32_t bucket , db_pgno_t mmpgno , DB_LSN *mmetalsn , db_pgno_t mpgno ,
                        DB_LSN *metalsn , db_pgno_t pgno , DB_LSN *pagelsn , u_int32_t newalloc ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 29U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                     sizeof((*mmetalsn))) + sizeof(u_int32_t )) + sizeof((*metalsn))) +
                  sizeof(u_int32_t )) + sizeof((*pagelsn))) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = bucket;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = mmpgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )mmetalsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )mmetalsn, sizeof((*mmetalsn)));
  } else {
    memset((void *)bp, 0, sizeof((*mmetalsn)));
  }
  bp += sizeof((*mmetalsn));
  uinttmp = mpgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )metalsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )metalsn, sizeof((*metalsn)));
  } else {
    memset((void *)bp, 0, sizeof((*metalsn)));
  }
  bp += sizeof((*metalsn));
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  uinttmp = newalloc;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_metagroup_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_metagroup_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) 
{ __ham_metagroup_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_metagroup_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_metagroup%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tbucket: %lu\n", (unsigned long )argp->bucket);
  printf((char const   * __restrict  )"\tmmpgno: %lu\n", (unsigned long )argp->mmpgno);
  printf((char const   * __restrict  )"\tmmetalsn: [%lu][%lu]\n", (unsigned long )argp->mmetalsn.file,
         (unsigned long )argp->mmetalsn.offset);
  printf((char const   * __restrict  )"\tmpgno: %lu\n", (unsigned long )argp->mpgno);
  printf((char const   * __restrict  )"\tmetalsn: [%lu][%lu]\n", (unsigned long )argp->metalsn.file,
         (unsigned long )argp->metalsn.offset);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\tnewalloc: %lu\n", (unsigned long )argp->newalloc);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_metagroup_read(DB_ENV *dbenv___0 , void *recbuf , __ham_metagroup_args **argpp ) 
{ __ham_metagroup_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_metagroup_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->bucket = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->mmpgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->mmetalsn), (void const   * __restrict  )bp,
         sizeof(argp->mmetalsn));
  bp += sizeof(argp->mmetalsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->mpgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->metalsn), (void const   * __restrict  )bp,
         sizeof(argp->metalsn));
  bp += sizeof(argp->metalsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->newalloc = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __ham_groupalloc_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                         DB_LSN *meta_lsn , db_pgno_t start_pgno , u_int32_t num ,
                         db_pgno_t free___0 ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 32U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                   sizeof((*meta_lsn))) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )meta_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )meta_lsn, sizeof((*meta_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*meta_lsn)));
  }
  bp += sizeof((*meta_lsn));
  uinttmp = start_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = num;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = free___0;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_groupalloc_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                              void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_groupalloc_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                           void *notused3 ) 
{ __ham_groupalloc_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_groupalloc_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_groupalloc%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tmeta_lsn: [%lu][%lu]\n", (unsigned long )argp->meta_lsn.file,
         (unsigned long )argp->meta_lsn.offset);
  printf((char const   * __restrict  )"\tstart_pgno: %lu\n", (unsigned long )argp->start_pgno);
  printf((char const   * __restrict  )"\tnum: %lu\n", (unsigned long )argp->num);
  printf((char const   * __restrict  )"\tfree: %lu\n", (unsigned long )argp->free);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_groupalloc_read(DB_ENV *dbenv___0 , void *recbuf , __ham_groupalloc_args **argpp ) 
{ __ham_groupalloc_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_groupalloc_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->start_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->num = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->free = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __ham_curadj_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_pgno_t pgno , u_int32_t indx , u_int32_t len , u_int32_t dup_off ,
                     int add , int is_dup , u_int32_t order ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 33U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = len;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = dup_off;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )add;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )is_dup;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = order;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_curadj_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_curadj_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __ham_curadj_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_curadj_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_curadj%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\tlen: %lu\n", (unsigned long )argp->len);
  printf((char const   * __restrict  )"\tdup_off: %lu\n", (unsigned long )argp->dup_off);
  printf((char const   * __restrict  )"\tadd: %ld\n", (long )argp->add);
  printf((char const   * __restrict  )"\tis_dup: %ld\n", (long )argp->is_dup);
  printf((char const   * __restrict  )"\torder: %lu\n", (unsigned long )argp->order);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_curadj_read(DB_ENV *dbenv___0 , void *recbuf , __ham_curadj_args **argpp ) 
{ __ham_curadj_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_curadj_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->len = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->dup_off = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->add = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->is_dup = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->order = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __ham_chgpg_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    db_ham_mode mode , db_pgno_t old_pgno , db_pgno_t new_pgno , u_int32_t old_indx ,
                    u_int32_t new_indx ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 34U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                    sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                 sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )mode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = old_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = new_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = old_indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = new_indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __ham_chgpg_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __ham_chgpg_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __ham_chgpg_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __ham_chgpg_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__ham_chgpg%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tmode: %ld\n", (long )argp->mode);
  printf((char const   * __restrict  )"\told_pgno: %lu\n", (unsigned long )argp->old_pgno);
  printf((char const   * __restrict  )"\tnew_pgno: %lu\n", (unsigned long )argp->new_pgno);
  printf((char const   * __restrict  )"\told_indx: %lu\n", (unsigned long )argp->old_indx);
  printf((char const   * __restrict  )"\tnew_indx: %lu\n", (unsigned long )argp->new_indx);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __ham_chgpg_read(DB_ENV *dbenv___0 , void *recbuf , __ham_chgpg_args **argpp ) 
{ __ham_chgpg_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__ham_chgpg_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->mode = (enum __anonenum_db_ham_mode_65 )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->old_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->new_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->old_indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->new_indx = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __ham_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_insdel_print, 21U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_newpage_print, 22U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_splitdata_print, 24U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_replace_print, 25U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_copypage_print, 28U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_metagroup_print, 29U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_groupalloc_print, 32U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_curadj_print, 33U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_chgpg_print, 34U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __ham_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_insdel_getpgnos, 21U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_newpage_getpgnos, 22U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_splitdata_getpgnos,
                          24U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_replace_getpgnos, 25U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_copypage_getpgnos,
                          28U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_metagroup_getpgnos,
                          29U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_groupalloc_getpgnos,
                          32U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_curadj_getpgnos, 33U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_chgpg_getpgnos, 34U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __ham_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_insdel_recover, 21U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_newpage_recover, 22U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_splitdata_recover,
                          24U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_replace_recover, 25U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_copypage_recover, 28U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_metagroup_recover,
                          29U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_groupalloc_recover,
                          32U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_curadj_recover, 33U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __ham_chgpg_recover, 34U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-tVrVXXrv.i","-O2")
int __ham_pgin(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __ham_pgout(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __ham_mswap(void *pg ) ;
int __ham_pgin(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB_PGINFO *pginfo ;
  PAGE *h ;
  int tmp___1 ;

  {
  h = (PAGE *)pp;
  pginfo = (DB_PGINFO *)cookie->data;
  if ((int )h->type != 8) {
    if (h->pgno == 0U) {
      while (1) {
        ((PAGE *)pp)->pgno = pg;
        ((PAGE *)pp)->prev_pgno = 0U;
        ((PAGE *)pp)->next_pgno = 0U;
        ((PAGE *)pp)->entries = (unsigned short)0;
        ((PAGE *)pp)->hf_offset = (unsigned short )pginfo->db_pagesize;
        ((PAGE *)pp)->level = (unsigned char)0;
        ((PAGE *)pp)->type = (unsigned char)2;
        break;
      }
      return (0);
    }
  }
  if (! (pginfo->flags & 268435456U)) {
    return (0);
  }
  if ((int )h->type == 8) {
    tmp___1 = __ham_mswap(pp);
  } else {
    tmp___1 = __db_byteswap(dbenv___0, dummydbp, pg, (PAGE *)pp, pginfo->db_pagesize,
                            1);
  }
  return (tmp___1);
}
}
int __ham_pgout(DB_ENV *dbenv___0 , DB *dummydbp , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB_PGINFO *pginfo ;
  PAGE *h ;
  int tmp___1 ;

  {
  pginfo = (DB_PGINFO *)cookie->data;
  if (! (pginfo->flags & 268435456U)) {
    return (0);
  }
  h = (PAGE *)pp;
  if ((int )h->type == 8) {
    tmp___1 = __ham_mswap(pp);
  } else {
    tmp___1 = __db_byteswap(dbenv___0, dummydbp, pg, (PAGE *)pp, pginfo->db_pagesize,
                            0);
  }
  return (tmp___1);
}
}
int __ham_mswap(void *pg ) 
{ u_int8_t *p ;
  int i ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  u_int32_t _tmp___5 ;
  u_int32_t _tmp___6 ;

  {
  __db_metaswap((PAGE *)pg);
  p = (u_int8_t *)pg + sizeof(DBMETA );
  (*((u_int8_t *)(& _tmp) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___0) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___0) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___0) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___0) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___1) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___1) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___1) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___1) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___2) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___2) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___2) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___2) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___2) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___2) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___2) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___2) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___3) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___3) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___3) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___3) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___3) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___3) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___3) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___3) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___4) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___4) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___4) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___4) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___4) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___4) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___4) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___4) + 0));
  p += sizeof(u_int32_t );
  i = 0;
  while (i < 32) {
    (*((u_int8_t *)(& _tmp___5) + 0)) = (*(p + 0));
    (*((u_int8_t *)(& _tmp___5) + 1)) = (*(p + 1));
    (*((u_int8_t *)(& _tmp___5) + 2)) = (*(p + 2));
    (*((u_int8_t *)(& _tmp___5) + 3)) = (*(p + 3));
    (*(p + 0)) = (*((u_int8_t *)(& _tmp___5) + 3));
    (*(p + 1)) = (*((u_int8_t *)(& _tmp___5) + 2));
    (*(p + 2)) = (*((u_int8_t *)(& _tmp___5) + 1));
    (*(p + 3)) = (*((u_int8_t *)(& _tmp___5) + 0));
    p += sizeof(u_int32_t );
    i ++;
  }
  p += 59U * sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___6) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___6) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___6) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___6) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___6) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___6) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___6) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___6) + 0));
  p += sizeof(u_int32_t );
  return (0);
}
}
#pragma merger(0,"/tmp/cil-xT2pUhu6.i","-O2")
void __ham_copy_item(DB *dbp___1 , PAGE *src_page , u_int32_t src_ndx , PAGE *dest_page ) ;
int __ham_add_ovflpage(DBC *dbc , PAGE *pagep , int release , PAGE **pp ) ;
static int __ham_c_chgpg(DBC *dbc , db_pgno_t old_pgno , u_int32_t old_index , db_pgno_t new_pgno ,
                         u_int32_t new_index ) ;
static int __ham_check_move(DBC *dbc , u_int32_t add_len ) ;
static int __ham_dcursor(DBC *dbc , db_pgno_t pgno , u_int32_t indx ) ;
static int __ham_move_offpage(DBC *dbc , PAGE *pagep , u_int32_t ndx , db_pgno_t pgno ) ;
int __ham_add_dup(DBC *dbc , DBT *nval , u_int32_t flags , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  DBT pval ;
  DBT tmp_val ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  u_int32_t add_bytes ;
  u_int32_t new_size ;
  int cmp ;
  int ret ;
  u_int8_t *hk ;
  u_int32_t tmp ;
  unsigned int tmp___1 ;
  u_int32_t tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___12 ;
  u_int32_t tmp___15 ;
  unsigned int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___21 ;
  int tmp___22 ;
  u_int32_t tmp___25 ;
  unsigned int tmp___27 ;
  unsigned int tmp___29 ;
  unsigned int tmp___31 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (nval->flags & 8U) {
    tmp = nval->doff;
  } else {
    tmp = 0U;
  }
  add_bytes = nval->size + tmp;
  add_bytes = add_bytes + 2U * sizeof(db_indx_t );
  ret = __ham_check_move(dbc, add_bytes);
  if (ret != 0) {
    return (ret);
  }
  if (dbp___1->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                      tmp___1) + ((int )hcp->indx +
                                                                  1)));
  if ((int )(*hk) != 2) {
    add_bytes += 2U * sizeof(db_indx_t );
  }
  if ((int )hcp->indx + 1 == 0) {
    tmp___4 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    tmp___4 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___6) +
                                (((int )hcp->indx + 1) - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___8 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___8 = sizeof(PG_CHKSUM );
    } else {
      tmp___8 = 0U;
    }
  }
  new_size = (unsigned int )((unsigned short )((tmp___4 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                           26) +
                                                                                          tmp___8) +
                                                                            ((int )hcp->indx +
                                                                             1)))) -
                                               (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))))) +
             add_bytes;
  if ((int )(*hk) != 4) {
    if ((int )(*hk) == 3) {
      goto _L;
    } else {
      if (new_size > (hcp->hdr)->dbmeta.pagesize / 4U) {
        tmp___10 = 1;
      } else {
        tmp___10 = 0;
      }
      if (tmp___10) {
        goto _L;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___12 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___12 = sizeof(PG_CHKSUM );
          } else {
            tmp___12 = 0U;
          }
        }
        if (add_bytes > (unsigned int )((PAGE *)hcp->page)->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                          26) +
                                                                                                                                         tmp___12)))) +
                                                                         (unsigned int )((PAGE *)hcp->page)->entries *
                                                                         sizeof(db_indx_t ))) {
          _L: 
          ret = __ham_dup_convert(dbc);
          if (ret != 0) {
            return (ret);
          }
          tmp___9 = ((*((hcp->opd)->c_am_put)))(hcp->opd, (DBT *)((void *)0), nval,
                                                flags, (db_pgno_t *)((void *)0));
          return (tmp___9);
        }
      }
    }
  }
  if ((int )(*hk) != 4) {
    if ((int )(*hk) != 2) {
      pval.flags = 0U;
      pval.data = (void *)(hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
      if ((int )hcp->indx + 1 == 0) {
        tmp___15 = dbp___1->pgsize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___17 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___17 = sizeof(PG_CHKSUM );
          } else {
            tmp___17 = 0U;
          }
        }
        tmp___15 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                   tmp___17) + (((int )hcp->indx +
                                                                 1) - 1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___19 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___19 = sizeof(PG_CHKSUM );
        } else {
          tmp___19 = 0U;
        }
      }
      pval.size = (unsigned int )((unsigned short )((tmp___15 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                 26) +
                                                                                                tmp___19) +
                                                                                  ((int )hcp->indx +
                                                                                   1)))) -
                                                    (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
      ret = __ham_make_dup(dbp___1->dbenv, (DBT const   *)(& pval), & tmp_val, & dbc->my_rdata.data,
                           & dbc->my_rdata.ulen);
      if (ret != 0) {
        return (ret);
      } else {
        ret = __ham_replpair(dbc, & tmp_val, 1U);
        if (ret != 0) {
          return (ret);
        }
      }
      if (dbp___1->flags & 2048U) {
        tmp___21 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___21 = sizeof(PG_CHKSUM );
        } else {
          tmp___21 = 0U;
        }
      }
      hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                           26) + tmp___21) + ((int )hcp->indx +
                                                                              1)));
      (*hk) = (unsigned char)2;
      hcp->flags = hcp->flags | 32U;
      hcp->dup_off = (unsigned short)0;
      hcp->dup_len = (unsigned short )pval.size;
      hcp->dup_tlen = (unsigned short )((unsigned int )hcp->dup_len + 2U * sizeof(db_indx_t ));
    }
    ret = __ham_make_dup(dbp___1->dbenv, (DBT const   *)nval, & tmp_val, & dbc->my_rdata.data,
                         & dbc->my_rdata.ulen);
    if (ret != 0) {
      return (ret);
    }
    tmp_val.dlen = 0U;
    switch ((int )flags) {
    case 15: ;
    case 16: ;
    case 21: ;
    if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
      __ham_dsearch(dbc, nval, & tmp_val.doff, & cmp, flags);
      if (cmp == 0) {
        tmp___22 = __db_duperr(dbp___1, flags);
        return (tmp___22);
      }
    } else {
      if ((int )hcp->indx + 1 == 0) {
        tmp___25 = dbp___1->pgsize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___27 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___27 = sizeof(PG_CHKSUM );
          } else {
            tmp___27 = 0U;
          }
        }
        tmp___25 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                   tmp___27) + (((int )hcp->indx +
                                                                 1) - 1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___29 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___29 = sizeof(PG_CHKSUM );
        } else {
          tmp___29 = 0U;
        }
      }
      hcp->dup_tlen = (unsigned short )((tmp___25 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                     26) +
                                                                                    tmp___29) +
                                                                      ((int )hcp->indx +
                                                                       1)))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
      hcp->dup_len = (unsigned short )nval->size;
      hcp->flags = hcp->flags | 32U;
      if (flags == 15U) {
        tmp_val.doff = 0U;
        hcp->dup_off = (unsigned short )tmp_val.doff;
      } else {
        tmp_val.doff = (unsigned int )hcp->dup_tlen;
        hcp->dup_off = (unsigned short )tmp_val.doff;
      }
    }
    break;
    case 3: 
    tmp_val.doff = (unsigned int )hcp->dup_off;
    break;
    case 1: 
    tmp_val.doff = (unsigned int )hcp->dup_off + ((unsigned int )hcp->dup_len + 2U *
                                                                                sizeof(db_indx_t ));
    break;
    }
    ret = __ham_replpair(dbc, & tmp_val, 0U);
    if (ret == 0) {
      ret = __memp_fset(mpf, hcp->page, 2U);
    }
    if (ret != 0) {
      return (ret);
    }
    switch ((int )flags) {
    case 1: 
    hcp->dup_off = (unsigned short )((unsigned int )hcp->dup_off + ((unsigned int )hcp->dup_len +
                                                                    2U * sizeof(db_indx_t )));
    hcp->dup_len = (unsigned short )nval->size;
    hcp->dup_tlen = (unsigned short )((int )hcp->dup_tlen + (int )((unsigned short )(nval->size +
                                                                                     2U *
                                                                                     sizeof(db_indx_t ))));
    break;
    case 3: ;
    case 15: ;
    case 16: ;
    case 21: 
    hcp->dup_tlen = (unsigned short )((int )hcp->dup_tlen + (int )((unsigned short )(nval->size +
                                                                                     2U *
                                                                                     sizeof(db_indx_t ))));
    hcp->dup_len = (unsigned short )nval->size;
    break;
    }
    ret = __ham_c_update(dbc, tmp_val.size, 1, 1);
    return (ret);
  }
  if (dbp___1->flags & 2048U) {
    tmp___31 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___31 = sizeof(PG_CHKSUM );
    } else {
      tmp___31 = 0U;
    }
  }
  memcpy((void * __restrict  )pgnop, (void const   * __restrict  )(((u_int8_t *)hcp->page +
                                                                    (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                            26) +
                                                                                           tmp___31) +
                                                                             ((int )hcp->indx +
                                                                              1)))) +
                                                                   (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
         sizeof(db_pgno_t ));
  return (ret);
}
}
int __ham_dup_convert(DBC *dbc ) 
{ BOVERFLOW bo ;
  DB *dbp___1 ;
  DBC **hcs ;
  DBT dbt ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  HOFFPAGE ho ;
  PAGE *dp ;
  db_indx_t i ;
  db_indx_t len ;
  db_indx_t off ;
  int c ;
  int ret ;
  int t_ret ;
  u_int8_t *p ;
  u_int8_t *pend ;
  int tmp ;
  unsigned int tmp___1 ;
  u_int32_t tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;
  u_int32_t tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___21 ;
  int tmp___22 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    tmp = 6;
  } else {
    tmp = 12;
  }
  ret = __db_new(dbc, (unsigned int )tmp, & dp);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    dp->pgno = dp->pgno;
    dp->prev_pgno = 0U;
    dp->next_pgno = 0U;
    dp->entries = (unsigned short)0;
    dp->hf_offset = (unsigned short )dbp___1->pgsize;
    dp->level = (unsigned char)1;
    dp->type = dp->type;
    break;
  }
  ret = __ham_get_clist(dbp___1, ((PAGE *)hcp->page)->pgno, (unsigned int )hcp->indx,
                        & hcs);
  if (ret != 0) {
    goto err;
  }
  dbt.flags = 0U;
  if (dbp___1->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  switch ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                   26) + tmp___1) +
                                                    ((int )hcp->indx + 1)))))) {
  case 1: ;
  if ((int )hcp->indx + 1 == 0) {
    tmp___4 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    tmp___4 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___6) +
                                (((int )hcp->indx + 1) - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___8 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___8 = sizeof(PG_CHKSUM );
    } else {
      tmp___8 = 0U;
    }
  }
  dbt.size = (unsigned int )((unsigned short )((tmp___4 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                           26) +
                                                                                          tmp___8) +
                                                                            ((int )hcp->indx +
                                                                             1)))) -
                                               (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
  if (dbp___1->flags & 2048U) {
    tmp___10 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___10 = sizeof(PG_CHKSUM );
    } else {
      tmp___10 = 0U;
    }
  }
  dbt.data = (void *)(((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                       26) + tmp___10) +
                                                        ((int )hcp->indx + 1)))) +
                      (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
  ret = __db_pitem(dbc, dp, 0U, (unsigned int )((unsigned long long )(((dbt.size +
                                                                        (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                       sizeof(u_int32_t )) -
                                                                      1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                               1ULL)),
                   (DBT *)((void *)0), & dbt);
  goto finish;
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___12 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___12 = sizeof(PG_CHKSUM );
    } else {
      tmp___12 = 0U;
    }
  }
  memcpy((void * __restrict  )(& ho), (void const   * __restrict  )((u_int8_t *)hcp->page +
                                                                    (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                            26) +
                                                                                           tmp___12) +
                                                                             ((int )hcp->indx +
                                                                              1)))),
         sizeof(HOFFPAGE ));
  bo.type = ho.type;
  bo.pgno = ho.pgno;
  bo.tlen = ho.tlen;
  dbt.size = (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                      sizeof(u_int32_t )) -
                                                                     1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                              1ULL)));
  dbt.data = (void *)(& bo);
  ret = __db_pitem(dbc, dp, 0U, dbt.size, & dbt, (DBT *)((void *)0));
  finish: 
  if (ret == 0) {
    ret = __memp_fset(mpf, (void *)dp, 2U);
    if (ret != 0) {
      break;
    }
    if ((unsigned int )hcs != (unsigned int )((void *)0)) {
      if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 16U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                       516U)) {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
                if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                  ret = __ham_chgpg_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_db_ham_mode_65 )5,
                                        ((PAGE *)hcp->page)->pgno, dp->pgno, (unsigned int )hcp->indx,
                                        0U);
                  if (ret != 0) {
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    c = 0;
    while (1) {
      if ((unsigned int )hcs != (unsigned int )((void *)0)) {
        if (! ((unsigned int )(*(hcs + c)) != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      ret = __ham_dcursor((*(hcs + c)), dp->pgno, 0U);
      if (ret != 0) {
        break;
      }
      c ++;
    }
  }
  break;
  case 2: ;
  if (dbp___1->flags & 2048U) {
    tmp___14 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___14 = sizeof(PG_CHKSUM );
    } else {
      tmp___14 = 0U;
    }
  }
  p = ((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                      tmp___14) + ((int )hcp->indx +
                                                                   1)))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
  if ((int )hcp->indx + 1 == 0) {
    tmp___17 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___19 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___19 = sizeof(PG_CHKSUM );
      } else {
        tmp___19 = 0U;
      }
    }
    tmp___17 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___19) +
                                 (((int )hcp->indx + 1) - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___21 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___21 = sizeof(PG_CHKSUM );
    } else {
      tmp___21 = 0U;
    }
  }
  pend = p + (int )((unsigned short )((tmp___17 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                   26) +
                                                                                  tmp___21) +
                                                                    ((int )hcp->indx +
                                                                     1)))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
  off = (unsigned short)0;
  i = (unsigned short)0;
  while ((unsigned int )p < (unsigned int )pend) {
    memcpy((void * __restrict  )(& len), (void const   * __restrict  )p, sizeof(db_indx_t ));
    dbt.size = (unsigned int )len;
    p += sizeof(db_indx_t );
    dbt.data = (void *)p;
    p += (unsigned int )len + sizeof(db_indx_t );
    ret = __db_pitem(dbc, dp, (unsigned int )i, (unsigned int )((unsigned long long )(((dbt.size +
                                                                                        (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                       sizeof(u_int32_t )) -
                                                                                      1U) &
                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)), (DBT *)((void *)0),
                     & dbt);
    if (ret != 0) {
      break;
    }
    if ((unsigned int )hcs != (unsigned int )((void *)0)) {
      if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 16U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                       516U)) {
                  goto _L___2;
                }
              } else {
                goto _L___2;
              }
            } else {
              _L___2: 
              if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
                if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                  ret = __ham_chgpg_log(dbp___1, dbc->txn, & lsn, 0U, (enum __anonenum_db_ham_mode_65 )5,
                                        ((PAGE *)hcp->page)->pgno, dp->pgno, (unsigned int )hcp->indx,
                                        (unsigned int )i);
                  if (ret != 0) {
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    c = 0;
    while (1) {
      if ((unsigned int )hcs != (unsigned int )((void *)0)) {
        if (! ((unsigned int )(*(hcs + c)) != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      if ((int )((HASH_CURSOR *)((*(hcs + c)))->internal)->dup_off == (int )off) {
        ret = __ham_dcursor((*(hcs + c)), dp->pgno, (unsigned int )i);
        if (ret != 0) {
          goto err;
        }
      }
      c ++;
    }
    off = (unsigned short )((unsigned int )off + ((unsigned int )len + 2U * sizeof(db_indx_t )));
    i = (unsigned short )((int )i + 1);
  }
  break;
  default: 
  ret = __db_pgfmt(dbp___1->dbenv, hcp->pgno);
  break;
  }
  if (ret == 0) {
    ret = __ham_move_offpage(dbc, (PAGE *)hcp->page, (unsigned int )((int )hcp->indx +
                                                                     1), dp->pgno);
  }
  err: 
  if (ret == 0) {
    ret = __memp_fset(mpf, hcp->page, 2U);
  }
  if (ret == 0) {
    tmp___22 = 2;
  } else {
    tmp___22 = 0;
  }
  t_ret = __memp_fput(mpf, (void *)dp, (unsigned int )tmp___22);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    hcp->dup_len = (unsigned short)0;
    hcp->dup_off = hcp->dup_len;
    hcp->dup_tlen = hcp->dup_off;
  }
  if ((unsigned int )hcs != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)hcs);
  }
  return (ret);
}
}
int __ham_make_dup(DB_ENV *dbenv___0 , DBT const   *notdup , DBT *duplicate , void **bufp ,
                   u_int32_t *sizep ) 
{ db_indx_t tsize ;
  db_indx_t item_size ;
  int ret ;
  u_int8_t *p ;

  {
  item_size = (unsigned short )notdup->size;
  if (notdup->flags & 8U) {
    item_size = (unsigned short )((unsigned int )item_size + notdup->doff);
  }
  tsize = (unsigned short )((unsigned int )item_size + 2U * sizeof(db_indx_t ));
  ret = __ham_init_dbt(dbenv___0, duplicate, (unsigned int )tsize, bufp, sizep);
  if (ret != 0) {
    return (ret);
  }
  duplicate->dlen = 0U;
  duplicate->flags = notdup->flags;
  duplicate->flags = duplicate->flags | 8U;
  p = (u_int8_t *)duplicate->data;
  memcpy((void * __restrict  )p, (void const   * __restrict  )(& item_size), sizeof(db_indx_t ));
  p += sizeof(db_indx_t );
  if (notdup->flags & 8U) {
    memset((void *)p, 0, notdup->doff);
    p += notdup->doff;
  }
  memcpy((void * __restrict  )p, (void const   * __restrict  )notdup->data, notdup->size);
  p += notdup->size;
  memcpy((void * __restrict  )p, (void const   * __restrict  )(& item_size), sizeof(db_indx_t ));
  duplicate->doff = 0U;
  duplicate->dlen = notdup->size;
  return (0);
}
}
static int __ham_check_move(DBC *dbc , u_int32_t add_len ) 
{ DB *dbp___1 ;
  DBT k ;
  DBT d ;
  DB_LSN new_lsn ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  PAGE *next_pagep ;
  db_pgno_t next_pgno ;
  u_int32_t new_datalen ;
  u_int32_t old_len ;
  u_int32_t rectype ;
  u_int8_t *hk ;
  int ret ;
  unsigned int tmp___0 ;
  u_int32_t tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___13 ;
  int tmp___15 ;
  u_int32_t tmp___18 ;
  unsigned int tmp___20 ;
  unsigned int tmp___22 ;
  unsigned int tmp___24 ;
  unsigned int tmp___26 ;
  unsigned int tmp___28 ;
  unsigned int tmp___30 ;
  u_int32_t tmp___33 ;
  unsigned int tmp___35 ;
  unsigned int tmp___37 ;
  unsigned int tmp___39 ;
  unsigned int tmp___41 ;
  unsigned int tmp___43 ;
  unsigned int tmp___45 ;
  u_int32_t tmp___48 ;
  unsigned int tmp___50 ;
  unsigned int tmp___52 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                      tmp___0) + ((int )hcp->indx +
                                                                  1)));
  if ((int )(*hk) == 4) {
    return (0);
  } else {
    if ((int )(*hk) == 3) {
      return (0);
    }
  }
  if ((int )hcp->indx + 1 == 0) {
    tmp___3 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___5 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___5 = sizeof(PG_CHKSUM );
      } else {
        tmp___5 = 0U;
      }
    }
    tmp___3 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___5) +
                                (((int )hcp->indx + 1) - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___7 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___7 = sizeof(PG_CHKSUM );
    } else {
      tmp___7 = 0U;
    }
  }
  old_len = tmp___3 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                      tmp___7) + ((int )hcp->indx +
                                                                  1)));
  new_datalen = (old_len - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))) +
                add_len;
  if ((int )(*hk) != 2) {
    new_datalen += 2U * sizeof(db_indx_t );
  }
  if (new_datalen > (hcp->hdr)->dbmeta.pagesize / 4U) {
    tmp___8 = 1;
  } else {
    tmp___8 = 0;
  }
  if (tmp___8) {
    if (old_len > sizeof(HOFFDUP )) {
      return (0);
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___10 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___10 = sizeof(PG_CHKSUM );
        } else {
          tmp___10 = 0U;
        }
      }
      if (sizeof(HOFFDUP ) - old_len <= (unsigned int )((PAGE *)hcp->page)->hf_offset -
                                        ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                          26) +
                                                                                                         tmp___10)))) +
                                         (unsigned int )((PAGE *)hcp->page)->entries *
                                         sizeof(db_indx_t ))) {
        return (0);
      }
    }
  }
  if (new_datalen > (hcp->hdr)->dbmeta.pagesize / 4U) {
    tmp___11 = 1;
  } else {
    tmp___11 = 0;
  }
  if (! tmp___11) {
    if (dbp___1->flags & 2048U) {
      tmp___13 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___13 = sizeof(PG_CHKSUM );
      } else {
        tmp___13 = 0U;
      }
    }
    if (add_len <= (unsigned int )((PAGE *)hcp->page)->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                     26) +
                                                                                                                                    tmp___13)))) +
                                                                    (unsigned int )((PAGE *)hcp->page)->entries *
                                                                    sizeof(db_indx_t ))) {
      return (0);
    }
  }
  if (new_datalen > (hcp->hdr)->dbmeta.pagesize / 4U) {
    tmp___15 = 1;
  } else {
    tmp___15 = 0;
  }
  if (tmp___15) {
    new_datalen = sizeof(HOFFDUP );
  } else {
    new_datalen = new_datalen + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
  }
  if ((int )hcp->indx == 0) {
    tmp___18 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___20 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___20 = sizeof(PG_CHKSUM );
      } else {
        tmp___20 = 0U;
      }
    }
    tmp___18 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___20) +
                                 ((int )hcp->indx - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___22 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___22 = sizeof(PG_CHKSUM );
    } else {
      tmp___22 = 0U;
    }
  }
  new_datalen += tmp___18 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                             26) + tmp___22) + (int )hcp->indx));
  next_pagep = (PAGE *)((void *)0);
  next_pgno = ((PAGE *)hcp->page)->next_pgno;
  while (next_pgno != 0U) {
    if ((unsigned int )next_pagep != (unsigned int )((void *)0)) {
      ret = __memp_fput(mpf, (void *)next_pagep, 0U);
      if (ret != 0) {
        return (ret);
      }
    }
    ret = __memp_fget(mpf, & next_pgno, 1U, (void *)(& next_pagep));
    if (ret != 0) {
      return (ret);
    }
    if (dbp___1->flags & 2048U) {
      tmp___24 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___24 = sizeof(PG_CHKSUM );
      } else {
        tmp___24 = 0U;
      }
    }
    if ((unsigned int )next_pagep->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                 26) +
                                                                                                                tmp___24)))) +
                                                (unsigned int )next_pagep->entries *
                                                sizeof(db_indx_t )) >= new_datalen) {
      break;
    }
    next_pgno = next_pagep->next_pgno;
  }
  if ((unsigned int )next_pagep == (unsigned int )((void *)0)) {
    ret = __ham_add_ovflpage(dbc, (PAGE *)hcp->page, 0, & next_pagep);
    if (ret != 0) {
      return (ret);
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___26 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___26 = sizeof(PG_CHKSUM );
    } else {
      tmp___26 = 0U;
    }
  }
  if ((unsigned int )next_pagep->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                               26) +
                                                                                                              tmp___26)))) +
                                              (unsigned int )next_pagep->entries *
                                              sizeof(db_indx_t )) < new_datalen) {
    ret = __ham_add_ovflpage(dbc, next_pagep, 1, & next_pagep);
    if (ret != 0) {
      __memp_fput(mpf, (void *)next_pagep, 0U);
      return (ret);
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          rectype = 32U;
          k.flags = 0U;
          d.flags = 0U;
          if (dbp___1->flags & 2048U) {
            tmp___39 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___39 = sizeof(PG_CHKSUM );
            } else {
              tmp___39 = 0U;
            }
          }
          if ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                       26) + tmp___39) +
                                                        (int )hcp->indx)))) == 3) {
            rectype |= 1U;
            if (dbp___1->flags & 2048U) {
              tmp___28 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___28 = sizeof(PG_CHKSUM );
              } else {
                tmp___28 = 0U;
              }
            }
            k.data = (void *)((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                              26) +
                                                                             tmp___28) +
                                                               (int )hcp->indx)));
            k.size = sizeof(HOFFPAGE );
          } else {
            if (dbp___1->flags & 2048U) {
              tmp___30 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___30 = sizeof(PG_CHKSUM );
              } else {
                tmp___30 = 0U;
              }
            }
            k.data = (void *)(((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                               26) +
                                                                              tmp___30) +
                                                                (int )hcp->indx))) +
                              (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
            if ((int )hcp->indx == 0) {
              tmp___33 = dbp___1->pgsize;
            } else {
              if (dbp___1->flags & 2048U) {
                tmp___35 = sizeof(PG_CRYPTO );
              } else {
                if (dbp___1->flags & 1U) {
                  tmp___35 = sizeof(PG_CHKSUM );
                } else {
                  tmp___35 = 0U;
                }
              }
              tmp___33 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                          26) + tmp___35) + ((int )hcp->indx -
                                                                             1)));
            }
            if (dbp___1->flags & 2048U) {
              tmp___37 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___37 = sizeof(PG_CHKSUM );
              } else {
                tmp___37 = 0U;
              }
            }
            k.size = (unsigned int )((unsigned short )((tmp___33 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                    26) +
                                                                                                   tmp___37) +
                                                                                     (int )hcp->indx))) -
                                                       (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
          }
          if ((int )(*hk) == 3) {
            rectype |= 2U;
            if (dbp___1->flags & 2048U) {
              tmp___41 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___41 = sizeof(PG_CHKSUM );
              } else {
                tmp___41 = 0U;
              }
            }
            d.data = (void *)((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                              26) +
                                                                             tmp___41) +
                                                               ((int )hcp->indx +
                                                                1))));
            d.size = sizeof(HOFFPAGE );
          } else {
            if (dbp___1->flags & 2048U) {
              tmp___43 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___43 = sizeof(PG_CHKSUM );
              } else {
                tmp___43 = 0U;
              }
            }
            if ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                         26) + tmp___43) +
                                                          ((int )hcp->indx + 1))))) ==
                2) {
              rectype |= 4U;
            }
            if (dbp___1->flags & 2048U) {
              tmp___45 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___45 = sizeof(PG_CHKSUM );
              } else {
                tmp___45 = 0U;
              }
            }
            d.data = (void *)(((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                               26) +
                                                                              tmp___45) +
                                                                ((int )hcp->indx +
                                                                 1)))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
            if ((int )hcp->indx + 1 == 0) {
              tmp___48 = dbp___1->pgsize;
            } else {
              if (dbp___1->flags & 2048U) {
                tmp___50 = sizeof(PG_CRYPTO );
              } else {
                if (dbp___1->flags & 1U) {
                  tmp___50 = sizeof(PG_CHKSUM );
                } else {
                  tmp___50 = 0U;
                }
              }
              tmp___48 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                          26) + tmp___50) + (((int )hcp->indx +
                                                                              1) -
                                                                             1)));
            }
            if (dbp___1->flags & 2048U) {
              tmp___52 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___52 = sizeof(PG_CHKSUM );
              } else {
                tmp___52 = 0U;
              }
            }
            d.size = (unsigned int )((unsigned short )((tmp___48 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                    26) +
                                                                                                   tmp___52) +
                                                                                     ((int )hcp->indx +
                                                                                      1)))) -
                                                       (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
          }
          ret = __ham_insdel_log(dbp___1, dbc->txn, & new_lsn, 0U, rectype, next_pagep->pgno,
                                 (unsigned int )next_pagep->entries, & next_pagep->lsn,
                                 (DBT const   *)(& k), (DBT const   *)(& d));
          if (ret != 0) {
            __memp_fput(mpf, (void *)next_pagep, 0U);
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      new_lsn.file = 0U;
      new_lsn.offset = 1U;
      break;
    }
  }
  next_pagep->lsn = new_lsn;
  __ham_copy_item(dbp___1, (PAGE *)hcp->page, (unsigned int )hcp->indx, next_pagep);
  __ham_copy_item(dbp___1, (PAGE *)hcp->page, (unsigned int )((int )hcp->indx + 1),
                  next_pagep);
  ret = __memp_fset(mpf, (void *)next_pagep, 2U);
  if (ret != 0) {
    goto out;
  }
  ret = __ham_c_chgpg(dbc, ((PAGE *)hcp->page)->pgno, (unsigned int )hcp->indx, next_pagep->pgno,
                      (unsigned int )((int )next_pagep->entries - 2));
  if (ret != 0) {
    goto out;
  }
  ret = __ham_del_pair(dbc, 0);
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if (! ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0))) {
        (hcp->hdr)->nelem = (hcp->hdr)->nelem + 1U;
      }
    } else {
      (hcp->hdr)->nelem = (hcp->hdr)->nelem + 1U;
    }
  } else {
    (hcp->hdr)->nelem = (hcp->hdr)->nelem + 1U;
  }
  out: 
  __memp_fput(mpf, hcp->page, 2U);
  hcp->page = (void *)next_pagep;
  hcp->pgno = ((PAGE *)hcp->page)->pgno;
  hcp->indx = (unsigned short )((int )((PAGE *)hcp->page)->entries - 2);
  hcp->flags = hcp->flags | 16U;
  hcp->flags = hcp->flags & 4294967293U;
  return (ret);
}
}
static int __ham_move_offpage(DBC *dbc , PAGE *pagep , u_int32_t ndx , db_pgno_t pgno ) 
{ DB *dbp___1 ;
  DBT new_dbt ;
  DBT old_dbt ;
  HOFFDUP od ;
  db_indx_t i ;
  db_indx_t *inp ;
  int32_t shrink ;
  u_int8_t *src ;
  int ret ;
  unsigned int tmp___0 ;
  u_int32_t tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  u_int32_t tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  unsigned int tmp___18 ;

  {
  dbp___1 = dbc->dbp;
  od.type = (unsigned char)4;
  od.pgno = pgno;
  ret = 0;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          new_dbt.data = (void *)(& od);
          new_dbt.size = sizeof(HOFFDUP );
          if (dbp___1->flags & 2048U) {
            tmp___0 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___0 = sizeof(PG_CHKSUM );
            } else {
              tmp___0 = 0U;
            }
          }
          old_dbt.data = (void *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                              26) +
                                                                             tmp___0) +
                                                               ndx)));
          if (ndx == 0U) {
            tmp___3 = dbp___1->pgsize;
          } else {
            if (dbp___1->flags & 2048U) {
              tmp___5 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___5 = sizeof(PG_CHKSUM );
              } else {
                tmp___5 = 0U;
              }
            }
            tmp___3 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___5) +
                                        (ndx - 1U)));
          }
          if (dbp___1->flags & 2048U) {
            tmp___7 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___7 = sizeof(PG_CHKSUM );
            } else {
              tmp___7 = 0U;
            }
          }
          old_dbt.size = tmp___3 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                    26) + tmp___7) +
                                                     ndx));
          ret = __ham_replace_log(dbp___1, dbc->txn, & pagep->lsn, 0U, pagep->pgno,
                                  ndx, & pagep->lsn, -1, (DBT const   *)(& old_dbt),
                                  (DBT const   *)(& new_dbt), 0U);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      pagep->lsn.file = 0U;
      pagep->lsn.offset = 1U;
      break;
    }
  }
  if (ndx == 0U) {
    tmp___10 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___12 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___12 = sizeof(PG_CHKSUM );
      } else {
        tmp___12 = 0U;
      }
    }
    tmp___10 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___12) +
                                 (ndx - 1U)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___14 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___14 = sizeof(PG_CHKSUM );
    } else {
      tmp___14 = 0U;
    }
  }
  shrink = (int )((tmp___10 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                               26) + tmp___14) + ndx))) -
                  sizeof(HOFFDUP ));
  if (dbp___1->flags & 2048U) {
    tmp___16 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___16 = sizeof(PG_CHKSUM );
    } else {
      tmp___16 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___16);
  if (shrink != 0) {
    src = (u_int8_t *)pagep + (int )pagep->hf_offset;
    memmove((void *)(src + shrink), (void const   *)src, (unsigned int )((int )(*(inp +
                                                                                  ndx)) -
                                                                         (int )pagep->hf_offset));
    pagep->hf_offset = (unsigned short )((int )pagep->hf_offset + shrink);
    i = (unsigned short )ndx;
    while ((int )i < (int )pagep->entries) {
      (*(inp + (int )i)) = (unsigned short )((int )(*(inp + (int )i)) + shrink);
      i = (unsigned short )((int )i + 1);
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___18 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___18 = sizeof(PG_CHKSUM );
    } else {
      tmp___18 = 0U;
    }
  }
  memcpy((void * __restrict  )((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                           26) + tmp___18) +
                                                            ndx))), (void const   * __restrict  )(& od),
         sizeof(HOFFDUP ));
  return (ret);
}
}
void __ham_dsearch(DBC *dbc , DBT *dbt , u_int32_t *offp , int *cmpp , u_int32_t flags ) 
{ DB *dbp___1 ;
  HASH_CURSOR *hcp ;
  DBT cur ;
  db_indx_t i ;
  db_indx_t len ;
  int (*func)(DB * , DBT const   * , DBT const   * ) ;
  u_int8_t *data ;
  unsigned int tmp___0 ;
  u_int32_t tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;

  {
  dbp___1 = dbc->dbp;
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    func = & __bam_defcmp;
  } else {
    func = dbp___1->dup_compare;
  }
  if (hcp->flags & 1U) {
    i = hcp->dup_off;
  } else {
    i = (unsigned short)0;
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  data = (((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                           26) + tmp___0) + ((int )hcp->indx +
                                                                             1)))) +
          (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
         (int )i;
  if ((int )hcp->indx + 1 == 0) {
    tmp___3 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___5 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___5 = sizeof(PG_CHKSUM );
      } else {
        tmp___5 = 0U;
      }
    }
    tmp___3 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___5) +
                                (((int )hcp->indx + 1) - 1)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___7 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___7 = sizeof(PG_CHKSUM );
    } else {
      tmp___7 = 0U;
    }
  }
  hcp->dup_tlen = (unsigned short )((tmp___3 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                26) +
                                                                               tmp___7) +
                                                                 ((int )hcp->indx +
                                                                  1)))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
  while ((int )i < (int )hcp->dup_tlen) {
    memcpy((void * __restrict  )(& len), (void const   * __restrict  )data, sizeof(db_indx_t ));
    data += sizeof(db_indx_t );
    cur.data = (void *)data;
    cur.size = (unsigned int )len;
    (*cmpp) = ((*func))(dbp___1, (DBT const   *)dbt, (DBT const   *)(& cur));
    if ((*cmpp) == 0) {
      break;
    }
    if ((*cmpp) < 0) {
      if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
        if (flags == 12U) {
          (*cmpp) = 0;
        }
        break;
      }
    }
    i = (unsigned short )((unsigned int )i + ((unsigned int )len + 2U * sizeof(db_indx_t )));
    data += (unsigned int )len + sizeof(db_indx_t );
  }
  (*offp) = (unsigned int )i;
  hcp->dup_off = i;
  hcp->dup_len = len;
  hcp->flags = hcp->flags | 32U;
  return;
}
}
static int __ham_dcursor(DBC *dbc , db_pgno_t pgno , u_int32_t indx ) 
{ DB *dbp___1 ;
  HASH_CURSOR *hcp ;
  BTREE_CURSOR *dcp ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __db_c_newopd(dbc, pgno, hcp->opd, & hcp->opd);
  if (ret != 0) {
    return (ret);
  }
  dcp = (BTREE_CURSOR *)(hcp->opd)->internal;
  dcp->pgno = pgno;
  dcp->indx = (unsigned short )indx;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    dcp->recno = indx + 1U;
  }
  if (hcp->flags & 2U) {
    dcp->flags = dcp->flags | 1U;
    hcp->flags = hcp->flags & 4294967293U;
  }
  return (0);
}
}
static int __ham_c_chgpg(DBC *dbc , db_pgno_t old_pgno , u_int32_t old_index , db_pgno_t new_pgno ,
                         u_int32_t new_index ) 
{ DB *dbp___1 ;
  DB *ldbp ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  DBC *cp ;
  HASH_CURSOR *hcp ;
  int found ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    cp = ldbp->active_queue.tqh_first;
    while ((unsigned int )cp != (unsigned int )((void *)0)) {
      if ((unsigned int )cp == (unsigned int )dbc) {
        goto __Cont;
      } else {
        if ((int )cp->dbtype != 2) {
          goto __Cont;
        }
      }
      hcp = (HASH_CURSOR *)cp->internal;
      if (hcp->flags & 2U) {
        goto __Cont;
      }
      if (hcp->pgno == old_pgno) {
        if ((unsigned int )hcp->indx == old_index) {
          hcp->pgno = new_pgno;
          hcp->indx = (unsigned short )new_index;
        } else {
          goto __Cont;
        }
        if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
          if ((unsigned int )cp->txn != (unsigned int )my_txn) {
            found = 1;
          }
        }
      }
      __Cont: 
      cp = cp->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            ret = __ham_chgpg_log(dbp___1, my_txn, & lsn, 0U, (enum __anonenum_db_ham_mode_65 )1,
                                  old_pgno, new_pgno, old_index, new_index);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-EpW9OPV7.i","-O2")
int __ham_get_meta(DBC *dbc ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  HASH *hashp ;
  HASH_CURSOR *hcp ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  hashp = (HASH *)dbp___1->h_internal;
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 18U)) {
            dbc->lock.pgno = hashp->meta_pgno;
            if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
              if ((dbc->txn)->flags & 64U) {
                tmp___0 = 1;
              } else {
                tmp___0 = 0;
              }
            } else {
              tmp___0 = 0;
            }
            ret = __lock_get(dbenv___0, dbc->locker, (unsigned int )tmp___0, (DBT const   *)(& dbc->lock_dbt),
                             (enum __anonenum_db_lockmode_t_50 )1, & hcp->hlock);
            if (ret != 0) {
              if (ret == -30994) {
                if (! (dbenv___0->flags & 2097152U)) {
                  tmp = -30995;
                } else {
                  tmp = ret;
                }
              } else {
                tmp = ret;
              }
              return (tmp);
            }
          }
        }
      }
    }
  }
  ret = __memp_fget(mpf, & hashp->meta_pgno, 1U, (void *)(& hcp->hdr));
  if (ret != 0) {
    if (hcp->hlock.off != 0U) {
      __lock_put(dbenv___0, & hcp->hlock);
    }
  }
  return (ret);
}
}
int __ham_release_meta(DBC *dbc ) 
{ DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  int tmp ;

  {
  mpf = (dbc->dbp)->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (hcp->hdr) {
    if (hcp->flags & 4U) {
      tmp = 2;
    } else {
      tmp = 0;
    }
    __memp_fput(mpf, (void *)hcp->hdr, (unsigned int )tmp);
  }
  hcp->hdr = (HMETA *)((void *)0);
  if (! (dbc->flags & 18U)) {
    if ((unsigned int )dbc->txn == (unsigned int )((void *)0)) {
      if (hcp->hlock.off != 0U) {
        __lock_put((dbc->dbp)->dbenv, & hcp->hlock);
      }
    }
  }
  hcp->flags = hcp->flags & 4294967291U;
  return (0);
}
}
int __ham_dirty_meta(DBC *dbc ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  DB_LOCK _tmp ;
  HASH *hashp ;
  HASH_CURSOR *hcp ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  hashp = (HASH *)dbp___1->h_internal;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = 0;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 18U)) {
          dbc->lock.pgno = hashp->meta_pgno;
          if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
            if ((dbc->txn)->flags & 64U) {
              tmp = 1;
            } else {
              tmp = 0;
            }
          } else {
            tmp = 0;
          }
          ret = __lock_get(dbenv___0, dbc->locker, (unsigned int )tmp, (DBT const   *)(& dbc->lock_dbt),
                           (enum __anonenum_db_lockmode_t_50 )2, & _tmp);
          if (ret == 0) {
            ret = __lock_put(dbenv___0, & hcp->hlock);
            hcp->hlock = _tmp;
          }
        }
      }
    }
  }
  if (ret == 0) {
    hcp->flags = hcp->flags | 4U;
  }
  if (ret == -30994) {
    if (! (dbenv___0->flags & 2097152U)) {
      tmp___0 = -30995;
    } else {
      tmp___0 = ret;
    }
  } else {
    tmp___0 = ret;
  }
  return (tmp___0);
}
}
#pragma merger(0,"/tmp/cil-3rCErVfX.i","-O2")
int __ham_db_create(DB *dbp___1 ) ;
int __ham_db_close(DB *dbp___1 ) ;
static int __ham_get_h_ffactor(DB *dbp___1 , u_int32_t *h_ffactorp ) ;
static int __ham_set_h_ffactor(DB *dbp___1 , u_int32_t h_ffactor ) ;
static int __ham_set_h_hash(DB *dbp___1 , u_int32_t (*func)(DB * , void const   * ,
                                                            u_int32_t  ) ) ;
static int __ham_get_h_nelem(DB *dbp___1 , u_int32_t *h_nelemp ) ;
static int __ham_set_h_nelem(DB *dbp___1 , u_int32_t h_nelem ) ;
int __ham_db_create(DB *dbp___1 ) 
{ HASH *hashp ;
  int ret ;

  {
  ret = __os_malloc(dbp___1->dbenv, sizeof(HASH ), (void *)(& dbp___1->h_internal));
  if (ret != 0) {
    return (ret);
  }
  hashp = (HASH *)dbp___1->h_internal;
  hashp->h_nelem = 0U;
  hashp->h_ffactor = 0U;
  hashp->h_hash = (u_int32_t (*)(DB * , void const   * , u_int32_t  ))((void *)0);
  dbp___1->get_h_ffactor = & __ham_get_h_ffactor;
  dbp___1->set_h_ffactor = & __ham_set_h_ffactor;
  dbp___1->set_h_hash = & __ham_set_h_hash;
  dbp___1->get_h_nelem = & __ham_get_h_nelem;
  dbp___1->set_h_nelem = & __ham_set_h_nelem;
  return (0);
}
}
int __ham_db_close(DB *dbp___1 ) 
{ 

  {
  if ((unsigned int )dbp___1->h_internal == (unsigned int )((void *)0)) {
    return (0);
  }
  __os_free(dbp___1->dbenv, dbp___1->h_internal);
  dbp___1->h_internal = (void *)0;
  return (0);
}
}
static int __ham_get_h_ffactor(DB *dbp___1 , u_int32_t *h_ffactorp ) 
{ HASH *hashp ;

  {
  hashp = (HASH *)dbp___1->h_internal;
  (*h_ffactorp) = hashp->h_ffactor;
  return (0);
}
}
static int __ham_set_h_ffactor(DB *dbp___1 , u_int32_t h_ffactor ) 
{ HASH *hashp ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_h_ffactor", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 2U);
  if (__ret != 0) {
    return (__ret);
  }
  hashp = (HASH *)dbp___1->h_internal;
  hashp->h_ffactor = h_ffactor;
  return (0);
}
}
static int __ham_set_h_hash(DB *dbp___1 , u_int32_t (*func)(DB * , void const   * ,
                                                            u_int32_t  ) ) 
{ HASH *hashp ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_h_hash", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 2U);
  if (__ret != 0) {
    return (__ret);
  }
  hashp = (HASH *)dbp___1->h_internal;
  hashp->h_hash = func;
  return (0);
}
}
static int __ham_get_h_nelem(DB *dbp___1 , u_int32_t *h_nelemp ) 
{ HASH *hashp ;
  int __ret ;

  {
  __ret = __dbh_am_chk(dbp___1, 2U);
  if (__ret != 0) {
    return (__ret);
  }
  hashp = (HASH *)dbp___1->h_internal;
  (*h_nelemp) = hashp->h_nelem;
  return (0);
}
}
static int __ham_set_h_nelem(DB *dbp___1 , u_int32_t h_nelem ) 
{ HASH *hashp ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_h_nelem", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 2U);
  if (__ret != 0) {
    return (__ret);
  }
  hashp = (HASH *)dbp___1->h_internal;
  hashp->h_nelem = h_nelem;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-9E2mFqan.i","-O2")
u_int32_t __ham_func4(DB *dbp___1 , void const   *key , u_int32_t len ) ;
u_int32_t __ham_func5(DB *dbp___1 , void const   *key , u_int32_t len ) ;
int __ham_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               u_int32_t flags ) ;
int __ham_metachk(DB *dbp___1 , char const   *name , HMETA *hashm ) ;
int __ham_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) ;
int __ham_new_subdb(DB *mdbp , DB *dbp___1 , DB_TXN *txn ) ;
static db_pgno_t __ham_init_meta(DB *dbp___1 , HMETA *meta , db_pgno_t pgno , DB_LSN *lsnp ) ;
int __ham_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  HASH *hashp ;
  int ret ;
  int t_ret ;
  int tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  dbc = (DBC *)((void *)0);
  mpf = dbp___1->mpf;
  if (flags & 1U) {
    if (dbenv___0->flags & 2U) {
      tmp = 35;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ret = __db_cursor(dbp___1, txn, & dbc, (unsigned int )tmp);
  if (ret != 0) {
    return (ret);
  }
  hcp = (HASH_CURSOR *)dbc->internal;
  hashp = (HASH *)dbp___1->h_internal;
  hashp->meta_pgno = base_pgno;
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    goto err1;
  }
  if ((hcp->hdr)->dbmeta.magic == 398689U) {
    if ((unsigned int )hashp->h_hash == (unsigned int )((void *)0)) {
      if ((hcp->hdr)->dbmeta.version < 5U) {
        hashp->h_hash = & __ham_func4;
      } else {
        hashp->h_hash = & __ham_func5;
      }
    }
    if (! (dbp___1->flags & 524288U)) {
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        tmp___0 = ((*(hashp->h_hash)))(dbp___1, (void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
        if (tmp___0 != (hcp->hdr)->h_charkey) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "hash: incompatible hash function");
          ret = 22;
          goto err2;
        }
      }
    }
    if ((hcp->hdr)->dbmeta.flags & 1U) {
      dbp___1->flags = dbp___1->flags | 512U;
    }
    if ((hcp->hdr)->dbmeta.flags & 4U) {
      dbp___1->flags = dbp___1->flags | 1024U;
    }
    if ((hcp->hdr)->dbmeta.flags & 2U) {
      dbp___1->flags = dbp___1->flags | 134217728U;
    }
    if (! (dbp___1->flags & 524288U)) {
      if (dbp___1->meta_pgno == 0U) {
        __memp_last_pgno(mpf, & (hcp->hdr)->dbmeta.last_pgno);
        hcp->flags = hcp->flags | 4U;
      }
    }
  } else {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (! (dbp___1->flags & 2097152U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "%s: Invalid hash meta page %d",
                 name, base_pgno);
        ret = 22;
      }
    }
  }
  err2: 
  t_ret = __ham_release_meta(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  err1: 
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __ham_metachk(DB *dbp___1 , char const   *name , HMETA *hashm ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t vers ;
  int ret ;
  u_int32_t _tmp ;
  int __ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  vers = hashm->dbmeta.version;
  if (dbp___1->flags & 268435456U) {
    _tmp = vers;
    (*((u_int8_t *)(& vers) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
    (*((u_int8_t *)(& vers) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
    (*((u_int8_t *)(& vers) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
    (*((u_int8_t *)(& vers) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  }
  switch ((int )vers) {
  case 4: ;
  case 5: ;
  case 6: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: hash version %lu requires a version upgrade",
           name, (unsigned long )vers);
  return (-30989);
  case 7: ;
  case 8: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unsupported hash version: %lu", name,
           (unsigned long )vers);
  return (22);
  }
  if (dbp___1->flags & 268435456U) {
    ret = __ham_mswap((void *)((PAGE *)hashm));
    if (ret != 0) {
      return (ret);
    }
  }
  if ((int )dbp___1->type != 2) {
    if ((int )dbp___1->type != 5) {
      return (22);
    }
  }
  dbp___1->type = (enum __anonenum_DBTYPE_61 )2;
  __ret = __dbh_am_chk(dbp___1, 2U);
  if (__ret != 0) {
    return (__ret);
  }
  ret = __db_fchk(dbenv___0, "DB->open", hashm->dbmeta.flags, 7U);
  if (ret != 0) {
    return (ret);
  }
  if (hashm->dbmeta.flags & 1U) {
    dbp___1->flags = dbp___1->flags | 512U;
  } else {
    if (dbp___1->flags & 512U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: DB_DUP specified to open method but not set in database",
               name);
      return (22);
    }
  }
  if (hashm->dbmeta.flags & 2U) {
    dbp___1->flags = dbp___1->flags | 134217728U;
  } else {
    if (dbp___1->flags & 134217728U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: multiple databases specified but not supported in file",
               name);
      return (22);
    }
  }
  if (hashm->dbmeta.flags & 4U) {
    if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
      dbp___1->dup_compare = & __bam_defcmp;
    }
  } else {
    if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: duplicate sort function specified but not set in database",
               name);
      return (22);
    }
  }
  dbp___1->pgsize = hashm->dbmeta.pagesize;
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(hashm->dbmeta.uid),
         20U);
  return (0);
}
}
static db_pgno_t __ham_init_meta(DB *dbp___1 , HMETA *meta , db_pgno_t pgno , DB_LSN *lsnp ) 
{ HASH *hashp ;
  db_pgno_t nbuckets ;
  int i ;
  int32_t l2 ;
  u_int32_t tmp ;

  {
  hashp = (HASH *)dbp___1->h_internal;
  if ((unsigned int )hashp->h_hash == (unsigned int )((void *)0)) {
    hashp->h_hash = & __ham_func5;
  }
  if (hashp->h_nelem != 0U) {
    if (hashp->h_ffactor != 0U) {
      hashp->h_nelem = (hashp->h_nelem - 1U) / hashp->h_ffactor + 1U;
      if (hashp->h_nelem > 2U) {
        tmp = hashp->h_nelem;
      } else {
        tmp = 2U;
      }
      l2 = (int32_t )__db_log2(tmp);
    } else {
      l2 = 1;
    }
  } else {
    l2 = 1;
  }
  nbuckets = (unsigned int )(1 << l2);
  memset((void *)meta, 0, sizeof(HMETA ));
  meta->dbmeta.lsn = (*lsnp);
  meta->dbmeta.pgno = pgno;
  meta->dbmeta.magic = 398689U;
  meta->dbmeta.version = 8U;
  meta->dbmeta.pagesize = dbp___1->pgsize;
  if (dbp___1->flags & 1U) {
    meta->dbmeta.metaflags = (unsigned char )((int )meta->dbmeta.metaflags | 1);
  }
  if (dbp___1->flags & 2048U) {
    meta->dbmeta.encrypt_alg = ((DB_CIPHER *)(dbp___1->dbenv)->crypto_handle)->alg;
    meta->crypto_magic = meta->dbmeta.magic;
  }
  meta->dbmeta.type = (unsigned char)8;
  meta->dbmeta.free = 0U;
  meta->dbmeta.last_pgno = pgno;
  meta->max_bucket = nbuckets - 1U;
  meta->high_mask = nbuckets - 1U;
  meta->low_mask = (nbuckets >> 1) - 1U;
  meta->ffactor = hashp->h_ffactor;
  meta->h_charkey = ((*(hashp->h_hash)))(dbp___1, (void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
  memcpy((void * __restrict  )(meta->dbmeta.uid), (void const   * __restrict  )(dbp___1->fileid),
         20U);
  if (dbp___1->flags & 512U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 1U;
  }
  if (dbp___1->flags & 134217728U) {
    meta->dbmeta.flags = meta->dbmeta.flags | 2U;
  }
  if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
    meta->dbmeta.flags = meta->dbmeta.flags | 4U;
  }
  meta->spares[0] = pgno + 1U;
  i = 1;
  while (i <= l2) {
    meta->spares[i] = meta->spares[0];
    i ++;
  }
  while (i < 32) {
    meta->spares[i] = 0U;
    i ++;
  }
  return (nbuckets);
}
}
int __ham_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) 
{ DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  DB_PGINFO pginfo ;
  DBT pdbt ;
  HMETA *meta ;
  PAGE *page ;
  int ret ;
  db_pgno_t lpgno ;
  void *buf ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  meta = (HMETA *)((void *)0);
  page = (PAGE *)((void *)0);
  memset((void *)(& pdbt), 0, sizeof(pdbt));
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    lpgno = 0U;
    ret = __memp_fget(mpf, & lpgno, 1U, (void *)(& meta));
  } else {
    pginfo.db_pagesize = dbp___1->pgsize;
    pginfo.type = dbp___1->type;
    pginfo.flags = dbp___1->flags & 268437505U;
    pdbt.data = (void *)(& pginfo);
    pdbt.size = sizeof(pginfo);
    ret = __os_calloc(dbp___1->dbenv, 1U, dbp___1->pgsize, (void *)(& buf));
    meta = (HMETA *)buf;
  }
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    lsn.file = 0U;
    lsn.offset = 1U;
    break;
  }
  lpgno = __ham_init_meta(dbp___1, meta, 0U, & lsn);
  meta->dbmeta.last_pgno = lpgno;
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ret = __memp_fput(mpf, (void *)meta, 2U);
  } else {
    ret = __db_pgout(dbenv___0, 0U, (void *)meta, & pdbt);
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 32768U) {
      tmp = 16;
    } else {
      tmp = 0;
    }
    ret = __fop_write(dbenv___0, txn, name, (enum __anonenum_APPNAME_39 )1, fhp, dbp___1->pgsize,
                      0U, 0U, (u_int8_t *)buf, dbp___1->pgsize, 1U, (unsigned int )tmp);
  }
  if (ret != 0) {
    goto err;
  }
  meta = (HMETA *)((void *)0);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ret = __memp_fget(mpf, & lpgno, 1U, (void *)(& page));
    if (ret != 0) {
      goto err;
    }
  } else {
    page = (PAGE *)buf;
  }
  while (1) {
    page->pgno = lpgno;
    page->prev_pgno = 0U;
    page->next_pgno = 0U;
    page->entries = (unsigned short)0;
    page->hf_offset = (unsigned short )dbp___1->pgsize;
    page->level = (unsigned char)0;
    page->type = (unsigned char)2;
    break;
  }
  while (1) {
    page->lsn.file = 0U;
    page->lsn.offset = 1U;
    break;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ret = __memp_fput(mpf, (void *)page, 2U);
  } else {
    ret = __db_pgout(dbenv___0, lpgno, buf, & pdbt);
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 32768U) {
      tmp___0 = 16;
    } else {
      tmp___0 = 0;
    }
    ret = __fop_write(dbenv___0, txn, name, (enum __anonenum_APPNAME_39 )1, fhp, dbp___1->pgsize,
                      lpgno, 0U, (u_int8_t *)buf, dbp___1->pgsize, 1U, (unsigned int )tmp___0);
  }
  if (ret != 0) {
    goto err;
  }
  page = (PAGE *)((void *)0);
  err: 
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, buf);
  } else {
    if ((unsigned int )meta != (unsigned int )((void *)0)) {
      __memp_fput(mpf, (void *)meta, 0U);
    }
    if ((unsigned int )page != (unsigned int )((void *)0)) {
      __memp_fput(mpf, (void *)page, 0U);
    }
  }
  return (ret);
}
}
int __ham_new_subdb(DB *mdbp , DB *dbp___1 , DB_TXN *txn ) 
{ DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DB_LOCK metalock ;
  DB_LOCK mmlock ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  DBMETA *mmeta ;
  HMETA *meta ;
  PAGE *h ;
  int i ;
  int ret ;
  int t_ret ;
  db_pgno_t lpgno ;
  db_pgno_t mpgno ;
  int tmp ;

  {
  dbenv___0 = mdbp->dbenv;
  mpf = mdbp->mpf;
  dbc = (DBC *)((void *)0);
  meta = (HMETA *)((void *)0);
  mmeta = (DBMETA *)((void *)0);
  metalock.off = 0U;
  mmlock.off = 0U;
  if (dbenv___0->flags & 2U) {
    tmp = 35;
  } else {
    tmp = 0;
  }
  ret = __db_cursor(mdbp, txn, & dbc, (unsigned int )tmp);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, dbp___1->meta_pgno, (enum __anonenum_db_lockmode_t_50 )2,
                  0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & dbp___1->meta_pgno, 1U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  lsn = meta->dbmeta.lsn;
  lpgno = __ham_init_meta(dbp___1, meta, dbp___1->meta_pgno, & lsn);
  mpgno = 0U;
  ret = __db_lget(dbc, 0, mpgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & mmlock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & mpgno, 0U, (void *)(& mmeta));
  if (ret != 0) {
    goto err;
  }
  meta->spares[0] = mmeta->last_pgno + 1U;
  i = 0;
  while (1) {
    if (i < 32) {
      if (! (meta->spares[i] != 0U)) {
        break;
      }
    } else {
      break;
    }
    meta->spares[i] = meta->spares[0];
    i ++;
  }
  ret = __db_log_page(mdbp, txn, & meta->dbmeta.lsn, dbp___1->meta_pgno, (PAGE *)meta);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        ret = __ham_groupalloc_log(mdbp, txn, & ((PAGE *)mmeta)->lsn, 0U, & ((PAGE *)mmeta)->lsn,
                                   meta->spares[0], meta->max_bucket + 1U, mmeta->free);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)meta, 2U);
  if (ret != 0) {
    goto err;
  }
  meta = (HMETA *)((void *)0);
  lpgno += mmeta->last_pgno;
  ret = __memp_fget(mpf, & lpgno, 1U, (void *)(& h));
  if (ret != 0) {
    goto err;
  }
  mmeta->last_pgno = lpgno;
  while (1) {
    h->pgno = lpgno;
    h->prev_pgno = 0U;
    h->next_pgno = 0U;
    h->entries = (unsigned short)0;
    h->hf_offset = (unsigned short )dbp___1->pgsize;
    h->level = (unsigned char)0;
    h->type = (unsigned char)2;
    break;
  }
  h->lsn = ((PAGE *)mmeta)->lsn;
  ret = __memp_fput(mpf, (void *)h, 2U);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fput(mpf, (void *)mmeta, 2U);
  if (ret != 0) {
    goto err;
  }
  mmeta = (DBMETA *)((void *)0);
  err: 
  if ((unsigned int )mmeta != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)mmeta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (mmlock.off != 0U) {
    if (mmlock.off != 0U) {
      t_ret = __lock_put((dbc->dbp)->dbenv, & mmlock);
    } else {
      t_ret = 0;
    }
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)meta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (metalock.off != 0U) {
    if (metalock.off != 0U) {
      t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
    } else {
      t_ret = 0;
    }
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-WNLlqcOM.i","-O2")
int __db_panic(DB_ENV *dbenv___0 , int errval ) ;
void __ham_putitem(DB *dbp___1 , PAGE *p , DBT const   *dbt , int type ) ;
void __ham_reputpair(DB *dbp___1 , PAGE *p , u_int32_t ndx , DBT const   *key , DBT const   *data ) ;
void __ham_onpage_replace(DB *dbp___1 , PAGE *pagep , u_int32_t ndx , int32_t off ,
                          int32_t change , DBT *dbt ) ;
int __ham_next_cpage(DBC *dbc , db_pgno_t pgno , int dirty ) ;
void __ham_dpair(DB *dbp___1 , PAGE *p , u_int32_t indx ) ;
static int __ham_c_delpg(DBC *dbc , db_pgno_t old_pgno , db_pgno_t new_pgno , u_int32_t num_ent ,
                         db_ham_mode op , u_int32_t *orderp ) ;
int __ham_item(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  HASH_CURSOR *hcp ;
  db_pgno_t next_pgno ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;

  {
  dbp___1 = dbc->dbp;
  hcp = (HASH_CURSOR *)dbc->internal;
  if (hcp->flags & 2U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "Attempt to return a deleted item");
    return (22);
  }
  hcp->flags = hcp->flags & 4294966911U;
  ret = __ham_get_cpage(dbc, mode);
  if (ret != 0) {
    return (ret);
  }
  recheck: 
  if (hcp->seek_size) {
    if (hcp->seek_found_page == 0U) {
      if (dbp___1->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      if (hcp->seek_size < (unsigned int )((PAGE *)hcp->page)->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                             26) +
                                                                                                                                            tmp___0)))) +
                                                                            (unsigned int )((PAGE *)hcp->page)->entries *
                                                                            sizeof(db_indx_t ))) {
        hcp->seek_found_page = hcp->pgno;
      }
    }
  }
  if ((int )hcp->indx < (int )((PAGE *)hcp->page)->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                 26) + tmp___4) +
                                                  ((int )hcp->indx + 1))))) == 4) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      memcpy((void * __restrict  )pgnop, (void const   * __restrict  )(((u_int8_t *)hcp->page +
                                                                        (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                26) +
                                                                                               tmp___2) +
                                                                                 ((int )hcp->indx +
                                                                                  1)))) +
                                                                       (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
             sizeof(db_pgno_t ));
      hcp->flags = hcp->flags | 256U;
      return (0);
    }
  }
  if (hcp->flags & 32U) {
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    memcpy((void * __restrict  )(& hcp->dup_len), (void const   * __restrict  )((((u_int8_t *)hcp->page +
                                                                                  (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                          26) +
                                                                                                         tmp___6) +
                                                                                           ((int )hcp->indx +
                                                                                            1)))) +
                                                                                 (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                                                                (int )hcp->dup_off),
           sizeof(db_indx_t ));
  }
  if ((int )hcp->indx >= (int )((PAGE *)hcp->page)->entries) {
    if (((PAGE *)hcp->page)->next_pgno == 0U) {
      hcp->flags = hcp->flags | 128U;
      return (-30990);
    }
    next_pgno = ((PAGE *)hcp->page)->next_pgno;
    hcp->indx = (unsigned short)0;
    ret = __ham_next_cpage(dbc, next_pgno, 0);
    if (ret != 0) {
      return (ret);
    }
    goto recheck;
  }
  hcp->flags = hcp->flags | 256U;
  return (0);
}
}
int __ham_item_reset(DBC *dbc ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = 0;
  if ((unsigned int )hcp->page != (unsigned int )((void *)0)) {
    ret = __memp_fput(mpf, hcp->page, 0U);
  }
  __ham_item_init(dbc);
  return (ret);
}
}
void __ham_item_init(DBC *dbc ) 
{ HASH_CURSOR *hcp ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  if (hcp->lock.off != 0U) {
    __db_lput(dbc, & hcp->lock);
  }
  hcp->bucket = 4294967295U;
  hcp->lbucket = 4294967295U;
  hcp->lock.off = 0U;
  hcp->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
  hcp->dup_off = (unsigned short)0;
  hcp->dup_len = (unsigned short)0;
  hcp->dup_tlen = (unsigned short)0;
  hcp->seek_size = 0U;
  hcp->seek_found_page = 0U;
  hcp->flags = 0U;
  hcp->pgno = 0U;
  hcp->indx = (unsigned short)65535;
  hcp->page = (void *)0;
  return;
}
}
int __ham_item_last(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) 
{ HASH_CURSOR *hcp ;
  int ret ;
  u_int32_t tmp ;
  int tmp___0 ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_item_reset(dbc);
  if (ret != 0) {
    return (ret);
  }
  hcp->bucket = (hcp->hdr)->max_bucket;
  tmp = __db_log2(hcp->bucket + 1U);
  hcp->pgno = hcp->bucket + (hcp->hdr)->spares[tmp];
  hcp->flags = hcp->flags | 256U;
  tmp___0 = __ham_item_prev(dbc, mode, pgnop);
  return (tmp___0);
}
}
int __ham_item_first(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) 
{ HASH_CURSOR *hcp ;
  int ret ;
  u_int32_t tmp ;
  int tmp___0 ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_item_reset(dbc);
  if (ret != 0) {
    return (ret);
  }
  hcp->flags = hcp->flags | 256U;
  hcp->bucket = 0U;
  tmp = __db_log2(hcp->bucket + 1U);
  hcp->pgno = hcp->bucket + (hcp->hdr)->spares[tmp];
  tmp___0 = __ham_item_next(dbc, mode, pgnop);
  return (tmp___0);
}
}
int __ham_item_prev(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  HASH_CURSOR *hcp ;
  db_pgno_t next_pgno ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  dbp___1 = dbc->dbp;
  hcp->flags = hcp->flags & 4294966909U;
  ret = __ham_get_cpage(dbc, mode);
  if (ret != 0) {
    return (ret);
  }
  if (! (hcp->flags & 64U)) {
    if (hcp->flags & 32U) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      if ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                   26) + tmp___2) +
                                                    ((int )hcp->indx + 1))))) == 4) {
        if (dbp___1->flags & 2048U) {
          tmp___0 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___0 = sizeof(PG_CHKSUM );
          } else {
            tmp___0 = 0U;
          }
        }
        memcpy((void * __restrict  )pgnop, (void const   * __restrict  )(((u_int8_t *)hcp->page +
                                                                          (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                  26) +
                                                                                                 tmp___0) +
                                                                                   ((int )hcp->indx +
                                                                                    1)))) +
                                                                         (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
               sizeof(db_pgno_t ));
        hcp->flags = hcp->flags | 256U;
        return (0);
      }
      if ((int )hcp->dup_off != 0) {
        if (dbp___1->flags & 2048U) {
          tmp___4 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___4 = sizeof(PG_CHKSUM );
          } else {
            tmp___4 = 0U;
          }
        }
        memcpy((void * __restrict  )(& hcp->dup_len), (void const   * __restrict  )(((((u_int8_t *)hcp->page +
                                                                                       (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                                               26) +
                                                                                                              tmp___4) +
                                                                                                ((int )hcp->indx +
                                                                                                 1)))) +
                                                                                      (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                                                                     (int )hcp->dup_off) -
                                                                                    sizeof(db_indx_t )),
               sizeof(db_indx_t ));
        hcp->dup_off = (unsigned short )((unsigned int )hcp->dup_off - ((unsigned int )hcp->dup_len +
                                                                        2U * sizeof(db_indx_t )));
        tmp___5 = __ham_item(dbc, mode, pgnop);
        return (tmp___5);
      }
    }
  }
  if (hcp->flags & 8U) {
    hcp->flags = hcp->flags & 4294967039U;
    hcp->flags = hcp->flags | 128U;
    return (0);
  } else {
    hcp->flags = hcp->flags & 4294967263U;
  }
  if ((int )hcp->indx == 0) {
    hcp->pgno = ((PAGE *)hcp->page)->prev_pgno;
    if (hcp->pgno == 0U) {
      hcp->flags = hcp->flags | 128U;
      return (-30990);
    } else {
      ret = __ham_next_cpage(dbc, hcp->pgno, 0);
      if (ret != 0) {
        return (ret);
      } else {
        hcp->indx = ((PAGE *)hcp->page)->entries;
      }
    }
  }
  if ((int )hcp->indx == 65535) {
    hcp->indx = ((PAGE *)hcp->page)->entries;
    next_pgno = ((PAGE *)hcp->page)->next_pgno;
    while (next_pgno != 0U) {
      ret = __ham_next_cpage(dbc, next_pgno, 0);
      if (ret != 0) {
        return (ret);
      }
      hcp->indx = ((PAGE *)hcp->page)->entries;
      next_pgno = ((PAGE *)hcp->page)->next_pgno;
    }
    if ((int )hcp->indx == 0) {
      hcp->flags = hcp->flags | 128U;
      return (-30990);
    }
  }
  hcp->indx = (unsigned short )((int )hcp->indx - 2);
  tmp___6 = __ham_item(dbc, mode, pgnop);
  return (tmp___6);
}
}
int __ham_item_next(DBC *dbc , db_lockmode_t mode , db_pgno_t *pgnop ) 
{ HASH_CURSOR *hcp ;
  int ret ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_get_cpage(dbc, mode);
  if (ret != 0) {
    return (ret);
  }
  if (hcp->flags & 2U) {
    if ((int )hcp->indx != 65535) {
      if (hcp->flags & 32U) {
        if ((dbc->dbp)->flags & 2048U) {
          tmp___0 = sizeof(PG_CRYPTO );
        } else {
          if ((dbc->dbp)->flags & 1U) {
            tmp___0 = sizeof(PG_CHKSUM );
          } else {
            tmp___0 = 0U;
          }
        }
        if ((int )(*((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                     26) + tmp___0) +
                                                      ((int )hcp->indx + 1))))) ==
            2) {
          if ((int )hcp->dup_tlen == (int )hcp->dup_off) {
            if (hcp->flags & 8U) {
              hcp->flags = hcp->flags & 4294967039U;
              hcp->flags = hcp->flags | 128U;
              return (0);
            } else {
              hcp->flags = hcp->flags & 4294967263U;
              hcp->indx = (unsigned short )((int )hcp->indx + 2);
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if (! (hcp->flags & 32U)) {
        if (hcp->flags & 8U) {
          hcp->flags = hcp->flags & 4294967039U;
          hcp->flags = hcp->flags | 128U;
          return (0);
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (hcp->flags & 32U) {
          if (hcp->flags & 64U) {
            hcp->flags = hcp->flags & 4294967263U;
            hcp->indx = (unsigned short )((int )hcp->indx + 2);
          }
        }
      }
    }
    hcp->flags = hcp->flags & 4294967293U;
  } else {
    if ((int )hcp->indx == 65535) {
      hcp->indx = (unsigned short)0;
      hcp->flags = hcp->flags & 4294967263U;
    } else {
      if (hcp->flags & 64U) {
        hcp->indx = (unsigned short )((int )hcp->indx + 2);
        hcp->flags = hcp->flags & 4294967263U;
      } else {
        if (hcp->flags & 32U) {
          if ((int )hcp->dup_tlen != 0) {
            if ((unsigned int )hcp->dup_off + ((unsigned int )hcp->dup_len + 2U *
                                                                             sizeof(db_indx_t )) >=
                (unsigned int )hcp->dup_tlen) {
              if (hcp->flags & 8U) {
                hcp->flags = hcp->flags & 4294967039U;
                hcp->flags = hcp->flags | 128U;
                return (0);
              }
            }
            hcp->dup_off = (unsigned short )((unsigned int )hcp->dup_off + ((unsigned int )hcp->dup_len +
                                                                            2U * sizeof(db_indx_t )));
            if ((int )hcp->dup_off >= (int )hcp->dup_tlen) {
              hcp->flags = hcp->flags & 4294967263U;
              hcp->indx = (unsigned short )((int )hcp->indx + 2);
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          if (hcp->flags & 8U) {
            hcp->flags = hcp->flags & 4294967039U;
            hcp->flags = hcp->flags | 128U;
            return (0);
          } else {
            hcp->indx = (unsigned short )((int )hcp->indx + 2);
            hcp->flags = hcp->flags & 4294967263U;
          }
        }
      }
    }
  }
  tmp___1 = __ham_item(dbc, mode, pgnop);
  return (tmp___1);
}
}
void __ham_putitem(DB *dbp___1 , PAGE *p , DBT const   *dbt , int type ) 
{ u_int16_t n ;
  u_int16_t off ;
  db_indx_t *inp ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;

  {
  n = p->entries;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)p + 26) + tmp___0);
  if (type == 3) {
    off = (unsigned short )((unsigned int )p->hf_offset - dbt->size);
    (*(inp + (int )n)) = off;
    p->hf_offset = (*(inp + (int )n));
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    memcpy((void * __restrict  )((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                         26) + tmp___2) +
                                                          (int )n))), (void const   * __restrict  )dbt->data,
           dbt->size);
  } else {
    off = (unsigned short )((unsigned int )p->hf_offset - (dbt->size + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
    (*(inp + (int )n)) = off;
    p->hf_offset = (*(inp + (int )n));
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    ((HKEYDATA *)((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___4) +
                                           (int )n))))->type = (unsigned char )type;
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    memcpy((void * __restrict  )(((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                          26) + tmp___6) +
                                                           (int )n))) + sizeof(u_int8_t )),
           (void const   * __restrict  )dbt->data, dbt->size);
  }
  p->entries = (unsigned short )((int )p->entries + 1);
  return;
}
}
void __ham_reputpair(DB *dbp___1 , PAGE *p , u_int32_t ndx , DBT const   *key , DBT const   *data ) 
{ db_indx_t i ;
  db_indx_t *inp ;
  db_indx_t movebytes ;
  db_indx_t newbytes ;
  size_t psize ;
  u_int8_t *from ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;

  {
  psize = dbp___1->pgsize;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)p + 26) + tmp___0);
  if (ndx == 0U) {
    tmp___1 = psize;
  } else {
    tmp___1 = (unsigned int )(*(inp + ((ndx - 2U) + 1U)));
  }
  movebytes = (unsigned short )(tmp___1 - (unsigned int )p->hf_offset);
  newbytes = (unsigned short )(key->size + data->size);
  from = (u_int8_t *)p + (int )p->hf_offset;
  memmove((void *)(from - (int )newbytes), (void const   *)from, (unsigned int )movebytes);
  i = (unsigned short )((int )p->entries - 1);
  while (1) {
    (*(inp + ((int )i + 2))) = (unsigned short )((int )(*(inp + (int )i)) - (int )newbytes);
    if ((unsigned int )i == ndx) {
      break;
    }
    i = (unsigned short )((int )i - 1);
  }
  if (ndx == 0U) {
    tmp___2 = psize;
  } else {
    tmp___2 = (unsigned int )(*(inp + ((ndx - 2U) + 1U)));
  }
  (*(inp + ndx)) = (unsigned short )(tmp___2 - key->size);
  (*(inp + (ndx + 1U))) = (unsigned short )((unsigned int )(*(inp + ndx)) - data->size);
  if (dbp___1->flags & 2048U) {
    tmp___4 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___4 = sizeof(PG_CHKSUM );
    } else {
      tmp___4 = 0U;
    }
  }
  memcpy((void * __restrict  )((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                       26) + tmp___4) +
                                                        ndx))), (void const   * __restrict  )key->data,
         key->size);
  if (dbp___1->flags & 2048U) {
    tmp___6 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___6 = sizeof(PG_CHKSUM );
    } else {
      tmp___6 = 0U;
    }
  }
  memcpy((void * __restrict  )((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                       26) + tmp___6) +
                                                        (ndx + 1U)))), (void const   * __restrict  )data->data,
         data->size);
  p->hf_offset = (unsigned short )((int )p->hf_offset - (int )newbytes);
  p->entries = (unsigned short )((int )p->entries + 2);
  return;
}
}
int __ham_del_pair(DBC *dbc , int reclaim_page ) 
{ DB *dbp___1 ;
  DBT data_dbt ;
  DBT key_dbt ;
  DB_LSN new_lsn ;
  DB_LSN *n_lsn ;
  DB_LSN tmp_lsn ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  PAGE *n_pagep ;
  PAGE *nn_pagep ;
  PAGE *p ;
  PAGE *p_pagep ;
  db_ham_mode op ;
  db_indx_t ndx ;
  db_pgno_t chg_pgno ;
  db_pgno_t pgno ;
  db_pgno_t tmp_pgno ;
  int ret ;
  int t_ret ;
  u_int32_t order ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  u_int32_t tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;
  unsigned int tmp___17 ;
  u_int32_t tmp___20 ;
  unsigned int tmp___22 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  DB_LSN *tmp___26 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  nn_pagep = (PAGE *)((void *)0);
  p_pagep = nn_pagep;
  n_pagep = p_pagep;
  ndx = hcp->indx;
  if ((unsigned int )hcp->page == (unsigned int )((void *)0)) {
    ret = __memp_fget(mpf, & hcp->pgno, 1U, (void *)(& hcp->page));
    if (ret != 0) {
      return (ret);
    }
  }
  p = (PAGE *)hcp->page;
  ret = 0;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  if ((int )(*((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___2) +
                                        (int )ndx)))) == 3) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(((u_int8_t *)p +
                                                                         (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                                                 26) +
                                                                                                tmp___0) +
                                                                                  (int )ndx))) +
                                                                        (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
           sizeof(db_pgno_t ));
    ret = __db_doff(dbc, pgno);
  }
  if (ret == 0) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    switch ((int )(*((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) +
                                                            tmp___4) + ((int )ndx +
                                                                        1)))))) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(((u_int8_t *)p +
                                                                         (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                                                 26) +
                                                                                                tmp___6) +
                                                                                  ((int )ndx +
                                                                                   1)))) +
                                                                        (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
           sizeof(db_pgno_t ));
    ret = __db_doff(dbc, pgno);
    break;
    case 4: ;
    case 2: 
    hcp->flags = hcp->flags & 4294967263U;
    break;
    }
  }
  if (ret) {
    return (ret);
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (dbp___1->flags & 2048U) {
            tmp___8 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___8 = sizeof(PG_CHKSUM );
            } else {
              tmp___8 = 0U;
            }
          }
          key_dbt.data = (void *)((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                          26) + tmp___8) +
                                                           (int )ndx)));
          if ((int )ndx == 0) {
            tmp___11 = dbp___1->pgsize;
          } else {
            if (dbp___1->flags & 2048U) {
              tmp___13 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___13 = sizeof(PG_CHKSUM );
              } else {
                tmp___13 = 0U;
              }
            }
            tmp___11 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___13) +
                                         ((int )ndx - 1)));
          }
          if (dbp___1->flags & 2048U) {
            tmp___15 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___15 = sizeof(PG_CHKSUM );
            } else {
              tmp___15 = 0U;
            }
          }
          key_dbt.size = tmp___11 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                     26) + tmp___15) +
                                                      (int )ndx));
          if (dbp___1->flags & 2048U) {
            tmp___17 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___17 = sizeof(PG_CHKSUM );
            } else {
              tmp___17 = 0U;
            }
          }
          data_dbt.data = (void *)((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                           26) + tmp___17) +
                                                            ((int )ndx + 1))));
          if ((int )ndx + 1 == 0) {
            tmp___20 = dbp___1->pgsize;
          } else {
            if (dbp___1->flags & 2048U) {
              tmp___22 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___22 = sizeof(PG_CHKSUM );
              } else {
                tmp___22 = 0U;
              }
            }
            tmp___20 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___22) +
                                         (((int )ndx + 1) - 1)));
          }
          if (dbp___1->flags & 2048U) {
            tmp___24 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___24 = sizeof(PG_CHKSUM );
            } else {
              tmp___24 = 0U;
            }
          }
          data_dbt.size = tmp___20 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                      26) + tmp___24) +
                                                       ((int )ndx + 1)));
          ret = __ham_insdel_log(dbp___1, dbc->txn, & new_lsn, 0U, 48U, p->pgno, (unsigned int )ndx,
                                 & p->lsn, (DBT const   *)(& key_dbt), (DBT const   *)(& data_dbt));
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      new_lsn.file = 0U;
      new_lsn.offset = 1U;
      break;
    }
  }
  p->lsn = new_lsn;
  __ham_dpair(dbp___1, p, (unsigned int )ndx);
  hcp->flags = hcp->flags | 2U;
  hcp->flags = hcp->flags & 4294967039U;
  ret = __ham_c_update(dbc, 0U, 0, 0);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if (! ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0))) {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: 
    (hcp->hdr)->nelem = (hcp->hdr)->nelem - 1U;
    ret = __ham_dirty_meta(dbc);
    if (ret != 0) {
      return (ret);
    }
  }
  if (! reclaim_page) {
    tmp___25 = __memp_fset(mpf, (void *)p, 2U);
    return (tmp___25);
  } else {
    if ((int )p->entries != 0) {
      tmp___25 = __memp_fset(mpf, (void *)p, 2U);
      return (tmp___25);
    } else {
      if (p->prev_pgno == 0U) {
        if (p->next_pgno == 0U) {
          tmp___25 = __memp_fset(mpf, (void *)p, 2U);
          return (tmp___25);
        }
      }
    }
  }
  if (p->prev_pgno == 0U) {
    ret = __memp_fget(mpf, & p->next_pgno, 0U, (void *)(& n_pagep));
    if (ret != 0) {
      return (ret);
    }
    if (n_pagep->next_pgno != 0U) {
      ret = __memp_fget(mpf, & n_pagep->next_pgno, 0U, (void *)(& nn_pagep));
      if (ret != 0) {
        goto err;
      }
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___10;
              } else {
                goto _L___8;
              }
            } else {
              goto _L___8;
            }
          } else {
            _L___8: 
            key_dbt.data = (void *)n_pagep;
            key_dbt.size = dbp___1->pgsize;
            if ((unsigned int )nn_pagep == (unsigned int )((void *)0)) {
              tmp___26 = (DB_LSN *)((void *)0);
            } else {
              tmp___26 = & nn_pagep->lsn;
            }
            ret = __ham_copypage_log(dbp___1, dbc->txn, & new_lsn, 0U, p->pgno, & p->lsn,
                                     n_pagep->pgno, & n_pagep->lsn, n_pagep->next_pgno,
                                     tmp___26, (DBT const   *)(& key_dbt));
            if (ret != 0) {
              goto err;
            }
          }
        } else {
          goto _L___10;
        }
      } else {
        goto _L___10;
      }
    } else {
      _L___10: 
      while (1) {
        new_lsn.file = 0U;
        new_lsn.offset = 1U;
        break;
      }
    }
    p->lsn = new_lsn;
    n_pagep->lsn = new_lsn;
    if (n_pagep->next_pgno != 0U) {
      nn_pagep->lsn = new_lsn;
    }
    if ((unsigned int )nn_pagep != (unsigned int )((void *)0)) {
      nn_pagep->prev_pgno = p->pgno;
      ret = __memp_fput(mpf, (void *)nn_pagep, 2U);
      if (ret != 0) {
        nn_pagep = (PAGE *)((void *)0);
        goto err;
      }
    }
    tmp_pgno = p->pgno;
    tmp_lsn = p->lsn;
    memcpy((void * __restrict  )p, (void const   * __restrict  )n_pagep, dbp___1->pgsize);
    p->pgno = tmp_pgno;
    p->lsn = tmp_lsn;
    p->prev_pgno = 0U;
    ret = __ham_c_delpg(dbc, n_pagep->pgno, p->pgno, 0U, (enum __anonenum_db_ham_mode_65 )2,
                        & order);
    if (ret != 0) {
      goto err;
    }
    hcp->indx = (unsigned short)0;
    hcp->pgno = p->pgno;
    hcp->order = hcp->order + order;
    ret = __memp_fset(mpf, (void *)p, 2U);
    if (ret != 0) {
      goto err;
    }
    ret = __db_free(dbc, n_pagep);
    if (ret != 0) {
      n_pagep = (PAGE *)((void *)0);
      goto err;
    }
  } else {
    ret = __memp_fget(mpf, & p->prev_pgno, 0U, (void *)(& p_pagep));
    if (ret != 0) {
      goto err;
    }
    if (p->next_pgno != 0U) {
      ret = __memp_fget(mpf, & p->next_pgno, 0U, (void *)(& n_pagep));
      if (ret != 0) {
        goto err;
      }
      n_lsn = & n_pagep->lsn;
    } else {
      n_pagep = (PAGE *)((void *)0);
      n_lsn = (DB_LSN *)((void *)0);
    }
    p_pagep->next_pgno = p->next_pgno;
    if ((unsigned int )n_pagep != (unsigned int )((void *)0)) {
      n_pagep->prev_pgno = p_pagep->pgno;
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___15;
              } else {
                goto _L___13;
              }
            } else {
              goto _L___13;
            }
          } else {
            _L___13: 
            ret = __ham_newpage_log(dbp___1, dbc->txn, & new_lsn, 0U, 80U, p->prev_pgno,
                                    & p_pagep->lsn, p->pgno, & p->lsn, p->next_pgno,
                                    n_lsn);
            if (ret != 0) {
              goto err;
            }
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: 
      while (1) {
        new_lsn.file = 0U;
        new_lsn.offset = 1U;
        break;
      }
    }
    p_pagep->lsn = new_lsn;
    if (n_pagep) {
      n_pagep->lsn = new_lsn;
    }
    p->lsn = new_lsn;
    if (p->next_pgno == 0U) {
      hcp->pgno = p_pagep->pgno;
      hcp->indx = p_pagep->entries;
      op = (enum __anonenum_db_ham_mode_65 )4;
    } else {
      hcp->pgno = p->next_pgno;
      hcp->indx = (unsigned short)0;
      op = (enum __anonenum_db_ham_mode_65 )3;
    }
    hcp->page = (void *)0;
    chg_pgno = p->pgno;
    ret = __db_free(dbc, p);
    t_ret = __memp_fput(mpf, (void *)p_pagep, 2U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if ((unsigned int )n_pagep != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(mpf, (void *)n_pagep, 2U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    if (ret != 0) {
      return (ret);
    }
    ret = __ham_c_delpg(dbc, chg_pgno, hcp->pgno, (unsigned int )hcp->indx, op, & order);
    if (ret != 0) {
      return (ret);
    }
    hcp->order = hcp->order + order;
  }
  return (ret);
  err: 
  if ((unsigned int )n_pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)n_pagep, 0U);
  }
  if ((unsigned int )nn_pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)nn_pagep, 0U);
  }
  if ((unsigned int )p_pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)p_pagep, 0U);
  }
  return (ret);
}
}
int __ham_replpair(DBC *dbc , DBT *dbt , u_int32_t make_dup ) 
{ DB *dbp___1 ;
  DBT old_dbt ;
  DBT tdata ;
  DBT tmp ;
  DB_ENV *dbenv___0 ;
  DB_LSN new_lsn ;
  HASH_CURSOR *hcp ;
  int32_t change ;
  u_int32_t dup_flag ;
  u_int32_t len ;
  u_int32_t memsize ;
  int beyond_eor ;
  int is_big ;
  int ret ;
  int type ;
  u_int8_t *beg ;
  u_int8_t *dest ;
  u_int8_t *end ;
  u_int8_t *hk ;
  u_int8_t *src ;
  void *memp ;
  unsigned int tmp___1 ;
  u_int32_t tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___13 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  hcp = (HASH_CURSOR *)dbc->internal;
  change = (int )(dbt->size - dbt->dlen);
  if (dbp___1->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  hk = (u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                      tmp___1) + ((int )hcp->indx +
                                                                  1)));
  is_big = (int )(*hk) == 3;
  if (is_big) {
    memcpy((void * __restrict  )(& len), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->tlen)))),
           sizeof(u_int32_t ));
  } else {
    if ((int )hcp->indx + 1 == 0) {
      tmp___4 = dbp___1->pgsize;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___6 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___6 = sizeof(PG_CHKSUM );
        } else {
          tmp___6 = 0U;
        }
      }
      tmp___4 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) + tmp___6) +
                                  (((int )hcp->indx + 1) - 1)));
    }
    if (dbp___1->flags & 2048U) {
      tmp___8 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___8 = sizeof(PG_CHKSUM );
      } else {
        tmp___8 = 0U;
      }
    }
    len = (unsigned int )((unsigned short )((tmp___4 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                                        26) +
                                                                                       tmp___8) +
                                                                         ((int )hcp->indx +
                                                                          1)))) -
                                            (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
  }
  beyond_eor = dbt->doff + dbt->dlen > len;
  if (beyond_eor) {
    change = (int )((unsigned int )change + ((dbt->doff + dbt->dlen) - len));
  }
  if (dbp___1->flags & 2048U) {
    tmp___11 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___11 = sizeof(PG_CHKSUM );
    } else {
      tmp___11 = 0U;
    }
  }
  if (change > (int )((unsigned int )((PAGE *)hcp->page)->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                        26) +
                                                                                                                                       tmp___11)))) +
                                                                       (unsigned int )((PAGE *)hcp->page)->entries *
                                                                       sizeof(db_indx_t )))) {
    goto _L___0;
  } else {
    if (beyond_eor) {
      goto _L___0;
    } else {
      if (is_big) {
        _L___0: 
        memset((void *)(& tmp), 0, sizeof(tmp));
        ret = __db_ret(dbp___1, (PAGE *)hcp->page, (unsigned int )hcp->indx, & tmp,
                       & dbc->my_rkey.data, & dbc->my_rkey.ulen);
        if (ret != 0) {
          return (ret);
        }
        dup_flag = hcp->flags & 32U;
        if (dbt->doff == 0U) {
          if (dbt->dlen == len) {
            ret = __ham_del_pair(dbc, 0);
            if (ret == 0) {
              if (dup_flag) {
                tmp___9 = 2;
              } else {
                tmp___9 = 1;
              }
              ret = __ham_add_el(dbc, (DBT const   *)(& tmp), (DBT const   *)dbt,
                                 tmp___9);
            }
          } else {
            goto _L;
          }
        } else {
          _L: 
          if ((int )(*hk) != 3) {
            type = (int )(*hk);
          } else {
            type = 1;
          }
          memset((void *)(& tdata), 0, sizeof(tdata));
          memp = (void *)0;
          memsize = 0U;
          ret = __db_ret(dbp___1, (PAGE *)hcp->page, (unsigned int )((int )hcp->indx +
                                                                     1), & tdata,
                         & memp, & memsize);
          if (ret != 0) {
            goto err;
          }
          ret = __ham_del_pair(dbc, 0);
          if (ret != 0) {
            __os_free(dbenv___0, memp);
            goto err;
          }
          if (change > 0) {
            ret = __os_realloc(dbenv___0, tdata.size + (unsigned int )change, (void *)(& tdata.data));
            if (ret != 0) {
              return (ret);
            }
            memp = tdata.data;
            memsize = tdata.size + (unsigned int )change;
            memset((void *)((u_int8_t *)tdata.data + tdata.size), 0, (unsigned int )change);
          }
          end = (u_int8_t *)tdata.data + tdata.size;
          src = ((u_int8_t *)tdata.data + dbt->doff) + dbt->dlen;
          if ((unsigned int )src < (unsigned int )end) {
            if (tdata.size > dbt->doff + dbt->dlen) {
              len = (tdata.size - dbt->doff) - dbt->dlen;
              dest = src + change;
              memmove((void *)dest, (void const   *)src, len);
            }
          }
          memcpy((void * __restrict  )((u_int8_t *)tdata.data + dbt->doff), (void const   * __restrict  )dbt->data,
                 dbt->size);
          tdata.size = tdata.size + (unsigned int )change;
          ret = __ham_add_el(dbc, (DBT const   *)(& tmp), (DBT const   *)(& tdata),
                             type);
          __os_free(dbenv___0, memp);
        }
        hcp->flags = hcp->flags | dup_flag;
        err: 
        return (ret);
      }
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___13 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___13 = sizeof(PG_CHKSUM );
    } else {
      tmp___13 = 0U;
    }
  }
  beg = ((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page + 26) +
                                                        tmp___13) + ((int )hcp->indx +
                                                                     1)))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
  beg += dbt->doff;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___5;
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          old_dbt.data = (void *)beg;
          old_dbt.size = dbt->dlen;
          ret = __ham_replace_log(dbp___1, dbc->txn, & new_lsn, 0U, ((PAGE *)hcp->page)->pgno,
                                  (unsigned int )((int )hcp->indx + 1), & ((PAGE *)hcp->page)->lsn,
                                  (int )dbt->doff, (DBT const   *)(& old_dbt), (DBT const   *)dbt,
                                  make_dup);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: 
    while (1) {
      new_lsn.file = 0U;
      new_lsn.offset = 1U;
      break;
    }
  }
  ((PAGE *)hcp->page)->lsn = new_lsn;
  __ham_onpage_replace(dbp___1, (PAGE *)hcp->page, (unsigned int )((int )hcp->indx +
                                                                   1), (int )dbt->doff,
                       change, dbt);
  return (0);
}
}
void __ham_onpage_replace(DB *dbp___1 , PAGE *pagep , u_int32_t ndx , int32_t off ,
                          int32_t change , DBT *dbt ) 
{ db_indx_t i ;
  db_indx_t *inp ;
  int32_t len ;
  size_t pgsize ;
  u_int8_t *src ;
  u_int8_t *dest ;
  int zero_me ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  size_t tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;
  size_t tmp___14 ;
  unsigned int tmp___16 ;
  unsigned int tmp___18 ;
  unsigned int tmp___20 ;
  unsigned int tmp___22 ;

  {
  pgsize = dbp___1->pgsize;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___0);
  if (change != 0) {
    zero_me = 0;
    src = (u_int8_t *)pagep + (int )pagep->hf_offset;
    if (off < 0) {
      len = (int )(*(inp + ndx)) - (int )pagep->hf_offset;
    } else {
      if (ndx == 0U) {
        tmp___14 = pgsize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___16 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___16 = sizeof(PG_CHKSUM );
          } else {
            tmp___16 = 0U;
          }
        }
        tmp___14 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___16) +
                                     (ndx - 1U)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___18 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___18 = sizeof(PG_CHKSUM );
        } else {
          tmp___18 = 0U;
        }
      }
      if ((unsigned int )off >= (unsigned int )((unsigned short )((tmp___14 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                                               26) +
                                                                                                              tmp___18) +
                                                                                                ndx))) -
                                                                  (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))))) {
        if (dbp___1->flags & 2048U) {
          tmp___2 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___2 = sizeof(PG_CHKSUM );
          } else {
            tmp___2 = 0U;
          }
        }
        if (ndx == 0U) {
          tmp___5 = pgsize;
        } else {
          if (dbp___1->flags & 2048U) {
            tmp___7 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___7 = sizeof(PG_CHKSUM );
            } else {
              tmp___7 = 0U;
            }
          }
          tmp___5 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___7) +
                                      (ndx - 1U)));
        }
        if (dbp___1->flags & 2048U) {
          tmp___9 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___9 = sizeof(PG_CHKSUM );
          } else {
            tmp___9 = 0U;
          }
        }
        len = ((((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) +
                                                            tmp___2) + ndx))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
               (int )((unsigned short )((tmp___5 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                                    26) +
                                                                                   tmp___9) +
                                                                     ndx))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))))) -
              src;
        zero_me = 1;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___11 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___11 = sizeof(PG_CHKSUM );
          } else {
            tmp___11 = 0U;
          }
        }
        len = ((((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) +
                                                            tmp___11) + ndx))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
               off) - src;
      }
    }
    dest = src - change;
    memmove((void *)dest, (void const   *)src, (unsigned int )len);
    if (zero_me) {
      memset((void *)(dest + len), 0, (unsigned int )change);
    }
    i = (unsigned short )ndx;
    while ((int )i < (int )pagep->entries) {
      (*(inp + (int )i)) = (unsigned short )((int )(*(inp + (int )i)) - change);
      i = (unsigned short )((int )i + 1);
    }
    pagep->hf_offset = (unsigned short )((int )pagep->hf_offset - change);
  }
  if (off >= 0) {
    if (dbp___1->flags & 2048U) {
      tmp___20 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___20 = sizeof(PG_CHKSUM );
      } else {
        tmp___20 = 0U;
      }
    }
    memcpy((void * __restrict  )((((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                               26) +
                                                                              tmp___20) +
                                                                ndx))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                 off), (void const   * __restrict  )dbt->data, dbt->size);
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___22 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___22 = sizeof(PG_CHKSUM );
      } else {
        tmp___22 = 0U;
      }
    }
    memcpy((void * __restrict  )((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                             26) +
                                                                            tmp___22) +
                                                              ndx))), (void const   * __restrict  )dbt->data,
           dbt->size);
  }
  return;
}
}
int __ham_split_page(DBC *dbc , u_int32_t obucket , u_int32_t nbucket ) 
{ DB *dbp___1 ;
  DBC **carray ;
  DBT key ;
  DBT page_dbt ;
  DB_ENV *dbenv___0 ;
  DB_LOCK block ;
  DB_LSN new_lsn ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  HASH_CURSOR *cp ;
  PAGE **pp ;
  PAGE *old_pagep ;
  PAGE *temp_pagep ;
  PAGE *new_pagep ;
  db_indx_t n ;
  db_pgno_t bucket_pgno ;
  db_pgno_t npgno ;
  db_pgno_t next_pgno ;
  u_int32_t big_len ;
  u_int32_t len ;
  int found ;
  int i ;
  int ret ;
  int t_ret ;
  void *big_buf ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  u_int32_t tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;
  unsigned int tmp___17 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  new_pagep = (PAGE *)((void *)0);
  old_pagep = new_pagep;
  temp_pagep = old_pagep;
  carray = (DBC **)((void *)0);
  block.off = 0U;
  tmp = __db_log2(obucket + 1U);
  bucket_pgno = obucket + (hcp->hdr)->spares[tmp];
  ret = __db_lget(dbc, 0, bucket_pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & block);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & bucket_pgno, 1U, (void *)(& old_pagep));
  if (ret != 0) {
    goto err;
  }
  tmp___0 = __db_log2(nbucket + 1U);
  npgno = nbucket + (hcp->hdr)->spares[tmp___0];
  ret = __memp_fget(mpf, & npgno, 1U, (void *)(& new_pagep));
  if (ret != 0) {
    goto err;
  }
  while (1) {
    new_pagep->pgno = npgno;
    new_pagep->prev_pgno = 0U;
    new_pagep->next_pgno = 0U;
    new_pagep->entries = (unsigned short)0;
    new_pagep->hf_offset = (unsigned short )dbp___1->pgsize;
    new_pagep->level = (unsigned char)0;
    new_pagep->type = (unsigned char)2;
    break;
  }
  temp_pagep = hcp->split_buf;
  memcpy((void * __restrict  )temp_pagep, (void const   * __restrict  )old_pagep,
         dbp___1->pgsize);
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          page_dbt.size = dbp___1->pgsize;
          page_dbt.data = (void *)old_pagep;
          ret = __ham_splitdata_log(dbp___1, dbc->txn, & new_lsn, 0U, 128U, old_pagep->pgno,
                                    (DBT const   *)(& page_dbt), & old_pagep->lsn);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      new_lsn.file = 0U;
      new_lsn.offset = 1U;
      break;
    }
  }
  old_pagep->lsn = new_lsn;
  while (1) {
    old_pagep->pgno = old_pagep->pgno;
    old_pagep->prev_pgno = 0U;
    old_pagep->next_pgno = 0U;
    old_pagep->entries = (unsigned short)0;
    old_pagep->hf_offset = (unsigned short )dbp___1->pgsize;
    old_pagep->level = (unsigned char)0;
    old_pagep->type = (unsigned char)2;
    break;
  }
  big_len = 0U;
  big_buf = (void *)0;
  key.flags = 0U;
  while ((unsigned int )temp_pagep != (unsigned int )((void *)0)) {
    ret = __ham_get_clist(dbp___1, temp_pagep->pgno, 65535U, & carray);
    if (ret != 0) {
      goto err;
    }
    n = (unsigned short)0;
    while ((int )n < (int )temp_pagep->entries) {
      ret = __db_ret(dbp___1, temp_pagep, (unsigned int )n, & key, & big_buf, & big_len);
      if (ret != 0) {
        goto err;
      }
      tmp___1 = __ham_call_hash(dbc, (u_int8_t *)key.data, (int )key.size);
      if (tmp___1 == obucket) {
        pp = & old_pagep;
      } else {
        pp = & new_pagep;
      }
      if ((int )n + 1 == 0) {
        tmp___4 = dbp___1->pgsize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___6 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___6 = sizeof(PG_CHKSUM );
          } else {
            tmp___6 = 0U;
          }
        }
        tmp___4 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)temp_pagep + 26) +
                                                  tmp___6) + (((int )n + 1) - 1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___8 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___8 = sizeof(PG_CHKSUM );
        } else {
          tmp___8 = 0U;
        }
      }
      if ((int )n == 0) {
        tmp___11 = dbp___1->pgsize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___13 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___13 = sizeof(PG_CHKSUM );
          } else {
            tmp___13 = 0U;
          }
        }
        tmp___11 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)temp_pagep + 26) +
                                                   tmp___13) + ((int )n - 1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___15 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___15 = sizeof(PG_CHKSUM );
        } else {
          tmp___15 = 0U;
        }
      }
      len = ((tmp___4 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)temp_pagep +
                                                         26) + tmp___8) + ((int )n +
                                                                           1)))) +
             (tmp___11 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)temp_pagep +
                                                          26) + tmp___15) + (int )n)))) +
            2U * sizeof(db_indx_t );
      if (dbp___1->flags & 2048U) {
        tmp___17 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___17 = sizeof(PG_CHKSUM );
        } else {
          tmp___17 = 0U;
        }
      }
      if ((unsigned int )((*pp))->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                26) +
                                                                                                               tmp___17)))) +
                                               (unsigned int )((*pp))->entries * sizeof(db_indx_t )) <
          len) {
        if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
            if (! (dbc->flags & 16U)) {
              if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
                if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                  if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                      516U) {
                    goto _L___8;
                  } else {
                    goto _L___6;
                  }
                } else {
                  goto _L___6;
                }
              } else {
                _L___6: 
                page_dbt.size = dbp___1->pgsize;
                page_dbt.data = (void *)(*pp);
                ret = __ham_splitdata_log(dbp___1, dbc->txn, & new_lsn, 0U, 144U,
                                          ((*pp))->pgno, (DBT const   *)(& page_dbt),
                                          & ((*pp))->lsn);
                if (ret != 0) {
                  goto err;
                }
              }
            } else {
              goto _L___8;
            }
          } else {
            goto _L___8;
          }
        } else {
          _L___8: 
          while (1) {
            new_lsn.file = 0U;
            new_lsn.offset = 1U;
            break;
          }
        }
        ((*pp))->lsn = new_lsn;
        ret = __ham_add_ovflpage(dbc, (*pp), 1, pp);
        if (ret != 0) {
          goto err;
        }
      }
      if ((unsigned int )carray != (unsigned int )((void *)0)) {
        found = 0;
        i = 0;
        while ((unsigned int )(*(carray + i)) != (unsigned int )((void *)0)) {
          cp = (HASH_CURSOR *)((*(carray + i)))->internal;
          if (cp->pgno == temp_pagep->pgno) {
            if ((int )cp->indx == (int )n) {
              cp->pgno = ((*pp))->pgno;
              cp->indx = ((*pp))->entries;
              found = 1;
            }
          }
          i ++;
        }
        if (found) {
          if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
              if (! (dbc->flags & 16U)) {
                if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
                  if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                    if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                           516U)) {
                      goto _L___10;
                    }
                  } else {
                    goto _L___10;
                  }
                } else {
                  _L___10: 
                  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
                    if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
                      ret = __ham_chgpg_log(dbp___1, dbc->txn, & new_lsn, 0U, (enum __anonenum_db_ham_mode_65 )6,
                                            temp_pagep->pgno, ((*pp))->pgno, (unsigned int )n,
                                            (unsigned int )((*pp))->entries);
                      if (ret != 0) {
                        goto err;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      __ham_copy_item(dbp___1, temp_pagep, (unsigned int )n, (*pp));
      __ham_copy_item(dbp___1, temp_pagep, (unsigned int )((int )n + 1), (*pp));
      n = (unsigned short )((int )n + 2);
    }
    next_pgno = temp_pagep->next_pgno;
    if (temp_pagep->pgno != bucket_pgno) {
      ret = __db_free(dbc, temp_pagep);
      if (ret != 0) {
        temp_pagep = (PAGE *)((void *)0);
        goto err;
      }
    }
    if (next_pgno == 0U) {
      temp_pagep = (PAGE *)((void *)0);
    } else {
      ret = __memp_fget(mpf, & next_pgno, 1U, (void *)(& temp_pagep));
      if (ret != 0) {
        goto err;
      }
    }
    if ((unsigned int )temp_pagep != (unsigned int )((void *)0)) {
      if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 16U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                    516U) {
                  goto _L___15;
                } else {
                  goto _L___13;
                }
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
              page_dbt.size = dbp___1->pgsize;
              page_dbt.data = (void *)temp_pagep;
              ret = __ham_splitdata_log(dbp___1, dbc->txn, & new_lsn, 0U, 128U, temp_pagep->pgno,
                                        (DBT const   *)(& page_dbt), & temp_pagep->lsn);
              if (ret != 0) {
                goto err;
              }
            }
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        _L___15: 
        while (1) {
          new_lsn.file = 0U;
          new_lsn.offset = 1U;
          break;
        }
      }
      temp_pagep->lsn = new_lsn;
    }
    if ((unsigned int )carray != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)carray);
    }
    carray = (DBC **)((void *)0);
  }
  if ((unsigned int )big_buf != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, big_buf);
  }
  if ((unsigned int )temp_pagep != (unsigned int )((void *)0)) {
    if (temp_pagep->pgno != bucket_pgno) {
      ret = __db_free(dbc, temp_pagep);
      if (ret != 0) {
        temp_pagep = (PAGE *)((void *)0);
        goto err;
      }
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___20;
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          page_dbt.size = dbp___1->pgsize;
          page_dbt.data = (void *)old_pagep;
          ret = __ham_splitdata_log(dbp___1, dbc->txn, & new_lsn, 0U, 144U, old_pagep->pgno,
                                    (DBT const   *)(& page_dbt), & old_pagep->lsn);
          if (ret != 0) {
            goto err;
          }
          old_pagep->lsn = new_lsn;
          page_dbt.data = (void *)new_pagep;
          ret = __ham_splitdata_log(dbp___1, dbc->txn, & new_lsn, 0U, 144U, new_pagep->pgno,
                                    (DBT const   *)(& page_dbt), & new_pagep->lsn);
          if (ret != 0) {
            goto err;
          }
          new_pagep->lsn = new_lsn;
        }
      } else {
        goto _L___20;
      }
    } else {
      goto _L___20;
    }
  } else {
    _L___20: 
    while (1) {
      old_pagep->lsn.file = 0U;
      old_pagep->lsn.offset = 1U;
      break;
    }
    while (1) {
      new_pagep->lsn.file = 0U;
      new_pagep->lsn.offset = 1U;
      break;
    }
  }
  ret = __memp_fput(mpf, (void *)old_pagep, 2U);
  t_ret = __memp_fput(mpf, (void *)new_pagep, 2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (0) {
    err: 
    if ((unsigned int )old_pagep != (unsigned int )((void *)0)) {
      __memp_fput(mpf, (void *)old_pagep, 2U);
    }
    if ((unsigned int )new_pagep != (unsigned int )((void *)0)) {
      while (1) {
        new_pagep->pgno = npgno;
        new_pagep->prev_pgno = 0U;
        new_pagep->next_pgno = 0U;
        new_pagep->entries = (unsigned short)0;
        new_pagep->hf_offset = (unsigned short )dbp___1->pgsize;
        new_pagep->level = (unsigned char)0;
        new_pagep->type = (unsigned char)2;
        break;
      }
      __memp_fput(mpf, (void *)new_pagep, 2U);
    }
    if ((unsigned int )temp_pagep != (unsigned int )((void *)0)) {
      if (temp_pagep->pgno != bucket_pgno) {
        __memp_fput(mpf, (void *)temp_pagep, 2U);
      }
    }
  }
  if (block.off != 0U) {
    if (block.off != 0U) {
      __db_lput(dbc, & block);
    }
  }
  if ((unsigned int )carray != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)carray);
  }
  return (ret);
}
}
int __ham_add_el(DBC *dbc , DBT const   *key , DBT const   *val , int type ) 
{ DBT const   *pkey ;
  DBT const   *pdata ;
  DB *dbp___1 ;
  DBT key_dbt ;
  DBT data_dbt ;
  DB_LSN new_lsn ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  HOFFPAGE doff ;
  HOFFPAGE koff ;
  db_pgno_t next_pgno ;
  db_pgno_t pgno ;
  u_int32_t data_size ;
  u_int32_t key_size ;
  u_int32_t pairsize ;
  u_int32_t rectype ;
  int do_expand ;
  int is_keybig ;
  int is_databig ;
  int ret ;
  int key_type ;
  int data_type ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  do_expand = 0;
  if (hcp->seek_found_page != 0U) {
    pgno = hcp->seek_found_page;
  } else {
    pgno = hcp->pgno;
  }
  if ((unsigned int )hcp->page == (unsigned int )((void *)0)) {
    ret = __memp_fget(mpf, & pgno, 1U, (void *)(& hcp->page));
    if (ret != 0) {
      return (ret);
    }
  }
  key_size = (key->size + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
             sizeof(db_indx_t );
  data_size = (val->size + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
              sizeof(db_indx_t );
  if (key->size > (hcp->hdr)->dbmeta.pagesize / 4U) {
    is_keybig = 1;
  } else {
    is_keybig = 0;
  }
  if (val->size > (hcp->hdr)->dbmeta.pagesize / 4U) {
    is_databig = 1;
  } else {
    is_databig = 0;
  }
  if (is_keybig) {
    key_size = sizeof(HOFFPAGE ) + sizeof(db_indx_t );
  }
  if (is_databig) {
    data_size = sizeof(HOFFPAGE ) + sizeof(db_indx_t );
  }
  pairsize = key_size + data_size;
  while (1) {
    if ((int )((PAGE *)hcp->page)->entries / 2) {
      if (! (((PAGE *)hcp->page)->next_pgno != 0U)) {
        break;
      }
    } else {
      break;
    }
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    if ((unsigned int )((PAGE *)hcp->page)->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                          26) +
                                                                                                                         tmp___0)))) +
                                                         (unsigned int )((PAGE *)hcp->page)->entries *
                                                         sizeof(db_indx_t )) >= pairsize) {
      break;
    }
    next_pgno = ((PAGE *)hcp->page)->next_pgno;
    ret = __ham_next_cpage(dbc, next_pgno, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  if ((unsigned int )((PAGE *)hcp->page)->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                        26) +
                                                                                                                       tmp___2)))) +
                                                       (unsigned int )((PAGE *)hcp->page)->entries *
                                                       sizeof(db_indx_t )) < pairsize) {
    do_expand = 1;
    ret = __ham_add_ovflpage(dbc, (PAGE *)hcp->page, 1, (PAGE **)(& hcp->page));
    if (ret != 0) {
      return (ret);
    }
    hcp->pgno = ((PAGE *)hcp->page)->pgno;
  }
  hcp->indx = ((PAGE *)hcp->page)->entries;
  hcp->flags = hcp->flags & 4294967293U;
  if (is_keybig) {
    koff.type = (unsigned char)3;
    ret = __db_poff(dbc, key, & koff.pgno);
    if (ret != 0) {
      return (ret);
    }
    koff.tlen = key->size;
    key_dbt.data = (void *)(& koff);
    key_dbt.size = sizeof(koff);
    pkey = (DBT const   *)(& key_dbt);
    key_type = 3;
  } else {
    pkey = key;
    key_type = 1;
  }
  if (is_databig) {
    doff.type = (unsigned char)3;
    ret = __db_poff(dbc, val, & doff.pgno);
    if (ret != 0) {
      return (ret);
    }
    doff.tlen = val->size;
    data_dbt.data = (void *)(& doff);
    data_dbt.size = sizeof(doff);
    pdata = (DBT const   *)(& data_dbt);
    data_type = 3;
  } else {
    pdata = val;
    data_type = type;
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          rectype = 32U;
          if (is_databig) {
            rectype |= 2U;
          }
          if (is_keybig) {
            rectype |= 1U;
          }
          if (type == 2) {
            rectype |= 4U;
          }
          ret = __ham_insdel_log(dbp___1, dbc->txn, & new_lsn, 0U, rectype, ((PAGE *)hcp->page)->pgno,
                                 (unsigned int )((PAGE *)hcp->page)->entries, & ((PAGE *)hcp->page)->lsn,
                                 pkey, pdata);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      new_lsn.file = 0U;
      new_lsn.offset = 1U;
      break;
    }
  }
  ((PAGE *)hcp->page)->lsn = new_lsn;
  __ham_putitem(dbp___1, (PAGE *)hcp->page, pkey, key_type);
  __ham_putitem(dbp___1, (PAGE *)hcp->page, pdata, data_type);
  hcp->pgno = ((PAGE *)hcp->page)->pgno;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if (! ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0))) {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: 
    (hcp->hdr)->nelem = (hcp->hdr)->nelem + 1U;
    ret = __ham_dirty_meta(dbc);
    if (ret != 0) {
      return (ret);
    }
  }
  if (do_expand) {
    hcp->flags = hcp->flags | 16U;
  } else {
    if ((hcp->hdr)->ffactor != 0U) {
      if ((unsigned int )((int )((PAGE *)hcp->page)->entries / 2) > (hcp->hdr)->ffactor) {
        hcp->flags = hcp->flags | 16U;
      }
    }
  }
  return (0);
}
}
void __ham_copy_item(DB *dbp___1 , PAGE *src_page , u_int32_t src_ndx , PAGE *dest_page ) 
{ u_int32_t len ;
  size_t pgsize ;
  void *src ;
  void *dest ;
  db_indx_t *inp ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  size_t tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;

  {
  pgsize = dbp___1->pgsize;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)dest_page + 26) + tmp___0);
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  src = (void *)((u_int8_t *)src_page + (int )(*((db_indx_t *)(((u_int8_t *)src_page +
                                                                26) + tmp___2) + src_ndx)));
  if (src_ndx == 0U) {
    tmp___5 = pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___7 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___7 = sizeof(PG_CHKSUM );
      } else {
        tmp___7 = 0U;
      }
    }
    tmp___5 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)src_page + 26) + tmp___7) +
                                (src_ndx - 1U)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___9 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___9 = sizeof(PG_CHKSUM );
    } else {
      tmp___9 = 0U;
    }
  }
  len = tmp___5 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)src_page + 26) + tmp___9) +
                                    src_ndx));
  dest_page->hf_offset = (unsigned short )((unsigned int )dest_page->hf_offset - len);
  (*(inp + (int )dest_page->entries)) = dest_page->hf_offset;
  if (dbp___1->flags & 2048U) {
    tmp___11 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___11 = sizeof(PG_CHKSUM );
    } else {
      tmp___11 = 0U;
    }
  }
  dest = (void *)((u_int8_t *)dest_page + (int )(*((db_indx_t *)(((u_int8_t *)dest_page +
                                                                  26) + tmp___11) +
                                                   (int )dest_page->entries)));
  dest_page->entries = (unsigned short )((int )dest_page->entries + 1);
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
  return;
}
}
int __ham_add_ovflpage(DBC *dbc , PAGE *pagep , int release , PAGE **pp ) 
{ DB *dbp___1 ;
  DB_LSN new_lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *new_pagep ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  ret = __db_new(dbc, 2U, & new_pagep);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __ham_newpage_log(dbp___1, dbc->txn, & new_lsn, 0U, 64U, pagep->pgno,
                                  & pagep->lsn, new_pagep->pgno, & new_pagep->lsn,
                                  0U, (DB_LSN *)((void *)0));
          if (ret != 0) {
            __memp_fput(mpf, (void *)pagep, 2U);
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      new_lsn.file = 0U;
      new_lsn.offset = 1U;
      break;
    }
  }
  new_pagep->lsn = new_lsn;
  pagep->lsn = new_pagep->lsn;
  pagep->next_pgno = new_pagep->pgno;
  new_pagep->prev_pgno = pagep->pgno;
  if (release) {
    ret = __memp_fput(mpf, (void *)pagep, 2U);
  }
  (*pp) = new_pagep;
  return (ret);
}
}
int __ham_get_cpage(DBC *dbc , db_lockmode_t mode ) 
{ DB *dbp___1 ;
  DB_LOCK tmp_lock ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  int ret ;
  u_int32_t tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = 0;
  tmp_lock.off = 0U;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        if (hcp->lbucket != hcp->bucket) {
          if (hcp->lock.off != 0U) {
            ret = __db_lput(dbc, & hcp->lock);
          } else {
            ret = 0;
          }
          if (ret != 0) {
            return (ret);
          }
        }
        if (hcp->lock.off != 0U) {
          if ((int )hcp->lock_mode == 1) {
            if ((int )mode == 2) {
              tmp_lock = hcp->lock;
              hcp->lock.off = 0U;
            }
          }
        }
        if (! (hcp->lock.off != 0U)) {
          ret = __ham_lock_bucket(dbc, mode);
          if (ret != 0) {
            return (ret);
          }
        }
        if (ret == 0) {
          hcp->lock_mode = mode;
          hcp->lbucket = hcp->bucket;
          if (tmp_lock.off != 0U) {
            ret = __lock_put(dbp___1->dbenv, & tmp_lock);
          }
        } else {
          if (tmp_lock.off != 0U) {
            hcp->lock = tmp_lock;
          }
        }
      }
    }
  }
  if (ret == 0) {
    if ((unsigned int )hcp->page == (unsigned int )((void *)0)) {
      if (hcp->pgno == 0U) {
        tmp___0 = __db_log2(hcp->bucket + 1U);
        hcp->pgno = hcp->bucket + (hcp->hdr)->spares[tmp___0];
      }
      ret = __memp_fget(mpf, & hcp->pgno, 1U, (void *)(& hcp->page));
      if (ret != 0) {
        return (ret);
      }
    }
  }
  return (0);
}
}
int __ham_next_cpage(DBC *dbc , db_pgno_t pgno , int dirty ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  PAGE *p ;
  int ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )hcp->page != (unsigned int )((void *)0)) {
    if (dirty) {
      tmp = 2;
    } else {
      tmp = 0;
    }
    ret = __memp_fput(mpf, hcp->page, (unsigned int )tmp);
    if (ret != 0) {
      return (ret);
    }
  }
  hcp->page = (void *)0;
  ret = __memp_fget(mpf, & pgno, 1U, (void *)(& p));
  if (ret != 0) {
    return (ret);
  }
  hcp->page = (void *)p;
  hcp->pgno = pgno;
  hcp->indx = (unsigned short)0;
  return (0);
}
}
int __ham_lock_bucket(DBC *dbc , db_lockmode_t mode ) 
{ HASH_CURSOR *hcp ;
  db_pgno_t pgno ;
  int gotmeta ;
  int ret ;
  u_int32_t tmp ;

  {
  hcp = (HASH_CURSOR *)dbc->internal;
  if ((unsigned int )hcp->hdr == (unsigned int )((void *)0)) {
    gotmeta = 1;
  } else {
    gotmeta = 0;
  }
  if (gotmeta) {
    ret = __ham_get_meta(dbc);
    if (ret != 0) {
      return (ret);
    }
  }
  tmp = __db_log2(hcp->bucket + 1U);
  pgno = hcp->bucket + (hcp->hdr)->spares[tmp];
  if (gotmeta) {
    ret = __ham_release_meta(dbc);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_lget(dbc, 0, pgno, mode, 0U, & hcp->lock);
  hcp->lock_mode = mode;
  return (ret);
}
}
void __ham_dpair(DB *dbp___1 , PAGE *p , u_int32_t indx ) 
{ db_indx_t delta ;
  db_indx_t n ;
  db_indx_t *inp ;
  u_int8_t *dest ;
  u_int8_t *src ;
  unsigned int tmp___0 ;
  u_int32_t tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  u_int32_t tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;

  {
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)p + 26) + tmp___0);
  if (indx == 0U) {
    tmp___3 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___5 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___5 = sizeof(PG_CHKSUM );
      } else {
        tmp___5 = 0U;
      }
    }
    tmp___3 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___5) + (indx -
                                                                                 1U)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___7 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___7 = sizeof(PG_CHKSUM );
    } else {
      tmp___7 = 0U;
    }
  }
  if (indx + 1U == 0U) {
    tmp___10 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___12 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___12 = sizeof(PG_CHKSUM );
      } else {
        tmp___12 = 0U;
      }
    }
    tmp___10 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___12) +
                                 ((indx + 1U) - 1U)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___14 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___14 = sizeof(PG_CHKSUM );
    } else {
      tmp___14 = 0U;
    }
  }
  delta = (unsigned short )((tmp___3 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                        26) + tmp___7) +
                                                         indx))) + (tmp___10 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                                                                26) +
                                                                                                               tmp___14) +
                                                                                                 (indx +
                                                                                                  1U)))));
  if ((int )((unsigned short )indx) != (int )p->entries - 2) {
    src = (u_int8_t *)p + (int )p->hf_offset;
    dest = src + (int )delta;
    memmove((void *)dest, (void const   *)src, (unsigned int )((int )(*(inp + (indx +
                                                                               1U))) -
                                                               (int )p->hf_offset));
  }
  p->hf_offset = (unsigned short )((int )p->hf_offset + (int )delta);
  p->entries = (unsigned short )((int )p->entries - 2);
  n = (unsigned short )indx;
  while ((int )n < (int )p->entries) {
    (*(inp + (int )n)) = (unsigned short )((int )(*(inp + ((int )n + 2))) + (int )delta);
    n = (unsigned short )((int )n + 1);
  }
  return;
}
}
static int __ham_c_delpg(DBC *dbc , db_pgno_t old_pgno , db_pgno_t new_pgno , u_int32_t num_ent ,
                         db_ham_mode op , u_int32_t *orderp ) 
{ DB *dbp___1 ;
  DB *ldbp ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DB_TXN *my_txn ;
  DBC *cp ;
  HASH_CURSOR *hcp ;
  int found ;
  int ret ;
  db_indx_t indx ;
  u_int32_t order ;
  int tmp ;

  {
  if ((int )op == 4) {
    indx = (unsigned short )num_ent;
  } else {
    indx = (unsigned short)0;
  }
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbc->txn)->parent != (unsigned int )((void *)0)) {
      my_txn = dbc->txn;
    } else {
      my_txn = (DB_TXN *)((void *)0);
    }
  } else {
    my_txn = (DB_TXN *)((void *)0);
  }
  found = 0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  order = 1U;
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    cp = ldbp->active_queue.tqh_first;
    while ((unsigned int )cp != (unsigned int )((void *)0)) {
      if ((unsigned int )cp == (unsigned int )dbc) {
        goto __Cont;
      } else {
        if ((int )cp->dbtype != 2) {
          goto __Cont;
        }
      }
      hcp = (HASH_CURSOR *)cp->internal;
      if (hcp->pgno == new_pgno) {
        if ((int )hcp->indx == (int )indx) {
          if (hcp->flags & 2U) {
            if (hcp->order >= order) {
              order = hcp->order + 1U;
            }
          }
        }
      }
      __Cont: 
      cp = cp->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    cp = ldbp->active_queue.tqh_first;
    while ((unsigned int )cp != (unsigned int )((void *)0)) {
      if ((unsigned int )cp == (unsigned int )dbc) {
        goto __Cont___0;
      } else {
        if ((int )cp->dbtype != 2) {
          goto __Cont___0;
        }
      }
      hcp = (HASH_CURSOR *)cp->internal;
      if (hcp->pgno == old_pgno) {
        switch ((int )op) {
        case 2: 
        hcp->pgno = new_pgno;
        if ((int )hcp->indx == (int )indx) {
          hcp->order = hcp->order + order;
        }
        break;
        case 3: 
        hcp->pgno = new_pgno;
        hcp->order = hcp->order + order;
        break;
        case 4: 
        hcp->pgno = new_pgno;
        hcp->indx = indx;
        hcp->order = hcp->order + order;
        break;
        default: 
        tmp = __db_panic(dbenv___0, 22);
        return (tmp);
        }
        if ((unsigned int )my_txn != (unsigned int )((void *)0)) {
          if ((unsigned int )cp->txn != (unsigned int )my_txn) {
            found = 1;
          }
        }
      }
      __Cont___0: 
      cp = cp->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (found != 0) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            ret = __ham_chgpg_log(dbp___1, my_txn, & lsn, 0U, op, old_pgno, new_pgno,
                                  (unsigned int )indx, order);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  (*orderp) = order;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-lJSWOH8Q.i","-O2")
int __db_add_limbo(DB_ENV *dbenv___0 , void *info , int32_t fileid , db_pgno_t pgno ,
                   int32_t count ) ;
static int __ham_alloc_pages(DB *dbp___1 , __ham_groupalloc_args *argp , DB_LSN *lsnp ) ;
int __ham_insdel_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __ham_insdel_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t flags ;
  u_int32_t opcode ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  int type ;
  int tmp ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_insdel_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_insdel_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        } else {
          ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  opcode = argp->opcode & 4294967280U;
  flags = 0U;
  if (opcode == 48U) {
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___7;
      } else {
        if ((int )op == 3) {
          goto _L___7;
        } else {
          if ((int )op == 2) {
            goto _L___7;
          } else {
            goto _L___10;
          }
        }
      }
    } else {
      goto _L___10;
    }
  } else {
    _L___10: 
    if (opcode == 32U) {
      if (cmp_p == 0) {
        if ((int )op == 4) {
          goto _L___7;
        } else {
          if ((int )op == 1) {
            _L___7: 
            if (opcode != 48U) {
              goto _L___0;
            } else {
              if (argp->ndx == (unsigned int )pagep->entries) {
                _L___0: 
                if ((int )op == 0) {
                  tmp = 3;
                } else {
                  if ((int )op == 3) {
                    tmp = 3;
                  } else {
                    if ((int )op == 2) {
                      tmp = 3;
                    } else {
                      if (argp->opcode & 1U) {
                        tmp = 3;
                      } else {
                        tmp = 1;
                      }
                    }
                  }
                }
                __ham_putitem(file_dbp, pagep, (DBT const   *)(& argp->key), tmp);
                if (argp->opcode & 4U) {
                  type = 2;
                } else {
                  if ((int )op == 0) {
                    type = 3;
                  } else {
                    if ((int )op == 3) {
                      type = 3;
                    } else {
                      if ((int )op == 2) {
                        type = 3;
                      } else {
                        if (argp->opcode & 2U) {
                          type = 3;
                        } else {
                          type = 1;
                        }
                      }
                    }
                  }
                }
                __ham_putitem(file_dbp, pagep, (DBT const   *)(& argp->data), type);
              } else {
                __ham_reputpair(file_dbp, pagep, argp->ndx, (DBT const   *)(& argp->key),
                                (DBT const   *)(& argp->data));
              }
            }
            if ((int )op == 4) {
              pagep->lsn = (*lsnp);
            } else {
              if ((int )op == 1) {
                pagep->lsn = (*lsnp);
              } else {
                pagep->lsn = argp->pagelsn;
              }
            }
            flags = 2U;
          } else {
            goto _L___8;
          }
        }
      } else {
        goto _L___8;
      }
    } else {
      _L___8: 
      if (opcode == 48U) {
        if (cmp_p == 0) {
          if ((int )op == 4) {
            goto _L___2;
          } else {
            if ((int )op == 1) {
              goto _L___2;
            } else {
              goto _L___4;
            }
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: 
        if (opcode == 32U) {
          if (cmp_n == 0) {
            if ((int )op == 0) {
              goto _L___2;
            } else {
              if ((int )op == 3) {
                goto _L___2;
              } else {
                if ((int )op == 2) {
                  _L___2: 
                  __ham_dpair(file_dbp, pagep, argp->ndx);
                  if ((int )op == 4) {
                    pagep->lsn = (*lsnp);
                  } else {
                    if ((int )op == 1) {
                      pagep->lsn = (*lsnp);
                    } else {
                      pagep->lsn = argp->pagelsn;
                    }
                  }
                  flags = 2U;
                }
              }
            }
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_newpage_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __ham_newpage_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t flags ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_newpage_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_newpage_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->new_pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      ret = 0;
      goto ppage;
    } else {
      if ((int )op == 3) {
        ret = 0;
        goto ppage;
      } else {
        if ((int )op == 2) {
          ret = 0;
          goto ppage;
        } else {
          ret = __memp_fget(mpf, & argp->new_pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  flags = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___10;
    } else {
      if ((int )op == 1) {
        _L___10: 
        if (argp->opcode == 64U) {
          goto _L___4;
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    }
  } else {
    _L___9: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___7;
      } else {
        if ((int )op == 3) {
          goto _L___7;
        } else {
          if ((int )op == 2) {
            _L___7: 
            if (argp->opcode == 80U) {
              _L___4: 
              while (1) {
                pagep->pgno = argp->new_pgno;
                pagep->prev_pgno = argp->prev_pgno;
                pagep->next_pgno = argp->next_pgno;
                pagep->entries = (unsigned short)0;
                pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                pagep->level = (unsigned char)0;
                pagep->type = (unsigned char)2;
                break;
              }
              flags = 2U;
            } else {
              goto _L___6;
            }
          } else {
            goto _L___6;
          }
        }
      }
    } else {
      _L___6: 
      if (cmp_p == 0) {
        if ((int )op == 4) {
          goto _L___3;
        } else {
          if ((int )op == 1) {
            _L___3: 
            if (argp->opcode == 80U) {
              flags = 2U;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        }
      } else {
        _L___2: 
        if (cmp_n == 0) {
          if ((int )op == 0) {
            goto _L___0;
          } else {
            if ((int )op == 3) {
              goto _L___0;
            } else {
              if ((int )op == 2) {
                _L___0: 
                if (argp->opcode == 64U) {
                  flags = 2U;
                }
              }
            }
          }
        }
      }
    }
  }
  if (flags) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
      } else {
        pagep->lsn = argp->pagelsn;
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  ppage: 
  if (argp->prev_pgno != 0U) {
    ret = __memp_fget(mpf, & argp->prev_pgno, 0U, (void *)(& pagep));
    if (ret != 0) {
      if ((int )op == 0) {
        ret = 0;
        goto npage;
      } else {
        if ((int )op == 3) {
          ret = 0;
          goto npage;
        } else {
          if ((int )op == 2) {
            ret = 0;
            goto npage;
          } else {
            ret = __memp_fget(mpf, & argp->prev_pgno, 1U, (void *)(& pagep));
            if (ret != 0) {
              goto out;
            }
          }
        }
      }
    }
    cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->prevlsn));
    if ((int )op == 4) {
      goto _L___11;
    } else {
      if ((int )op == 1) {
        _L___11: 
        if (cmp_p < 0) {
          if (pagep->lsn.file == 0U) {
            if (! (pagep->lsn.offset == 1U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                       (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                       (unsigned long )argp->prevlsn.file, (unsigned long )argp->prevlsn.offset);
              ret = 22;
              goto out;
            }
          } else {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->prevlsn.file, (unsigned long )argp->prevlsn.offset);
            ret = 22;
            goto out;
          }
        }
      }
    }
    flags = 0U;
    if (cmp_p == 0) {
      if ((int )op == 4) {
        goto _L___21;
      } else {
        if ((int )op == 1) {
          _L___21: 
          if (argp->opcode == 64U) {
            pagep->next_pgno = argp->new_pgno;
            flags = 2U;
          } else {
            goto _L___20;
          }
        } else {
          goto _L___20;
        }
      }
    } else {
      _L___20: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___18;
        } else {
          if ((int )op == 3) {
            goto _L___18;
          } else {
            if ((int )op == 2) {
              _L___18: 
              if (argp->opcode == 80U) {
                pagep->next_pgno = argp->new_pgno;
                flags = 2U;
              } else {
                goto _L___17;
              }
            } else {
              goto _L___17;
            }
          }
        }
      } else {
        _L___17: 
        if (cmp_p == 0) {
          if ((int )op == 4) {
            goto _L___15;
          } else {
            if ((int )op == 1) {
              _L___15: 
              if (argp->opcode == 80U) {
                pagep->next_pgno = argp->next_pgno;
                flags = 2U;
              } else {
                goto _L___14;
              }
            } else {
              goto _L___14;
            }
          }
        } else {
          _L___14: 
          if (cmp_n == 0) {
            if ((int )op == 0) {
              goto _L___12;
            } else {
              if ((int )op == 3) {
                goto _L___12;
              } else {
                if ((int )op == 2) {
                  _L___12: 
                  if (argp->opcode == 64U) {
                    pagep->next_pgno = argp->next_pgno;
                    flags = 2U;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (flags) {
      if ((int )op == 4) {
        pagep->lsn = (*lsnp);
      } else {
        if ((int )op == 1) {
          pagep->lsn = (*lsnp);
        } else {
          pagep->lsn = argp->prevlsn;
        }
      }
    }
    ret = __memp_fput(mpf, (void *)pagep, flags);
    if (ret != 0) {
      goto out;
    }
    pagep = (PAGE *)((void *)0);
  }
  npage: 
  if (argp->next_pgno != 0U) {
    ret = __memp_fget(mpf, & argp->next_pgno, 0U, (void *)(& pagep));
    if (ret != 0) {
      if ((int )op == 0) {
        goto done;
      } else {
        if ((int )op == 3) {
          goto done;
        } else {
          if ((int )op == 2) {
            goto done;
          } else {
            ret = __memp_fget(mpf, & argp->next_pgno, 1U, (void *)(& pagep));
            if (ret != 0) {
              goto out;
            }
          }
        }
      }
    }
    cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->nextlsn));
    if ((int )op == 4) {
      goto _L___22;
    } else {
      if ((int )op == 1) {
        _L___22: 
        if (cmp_p < 0) {
          if (pagep->lsn.file == 0U) {
            if (! (pagep->lsn.offset == 1U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                       (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                       (unsigned long )argp->nextlsn.file, (unsigned long )argp->nextlsn.offset);
              ret = 22;
              goto out;
            }
          } else {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->nextlsn.file, (unsigned long )argp->nextlsn.offset);
            ret = 22;
            goto out;
          }
        }
      }
    }
    flags = 0U;
    if (cmp_p == 0) {
      if ((int )op == 4) {
        goto _L___32;
      } else {
        if ((int )op == 1) {
          _L___32: 
          if (argp->opcode == 64U) {
            pagep->prev_pgno = argp->new_pgno;
            flags = 2U;
          } else {
            goto _L___31;
          }
        } else {
          goto _L___31;
        }
      }
    } else {
      _L___31: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___29;
        } else {
          if ((int )op == 3) {
            goto _L___29;
          } else {
            if ((int )op == 2) {
              _L___29: 
              if (argp->opcode == 80U) {
                pagep->prev_pgno = argp->new_pgno;
                flags = 2U;
              } else {
                goto _L___28;
              }
            } else {
              goto _L___28;
            }
          }
        }
      } else {
        _L___28: 
        if (cmp_p == 0) {
          if ((int )op == 4) {
            goto _L___26;
          } else {
            if ((int )op == 1) {
              _L___26: 
              if (argp->opcode == 80U) {
                pagep->prev_pgno = argp->prev_pgno;
                flags = 2U;
              } else {
                goto _L___25;
              }
            } else {
              goto _L___25;
            }
          }
        } else {
          _L___25: 
          if (cmp_n == 0) {
            if ((int )op == 0) {
              goto _L___23;
            } else {
              if ((int )op == 3) {
                goto _L___23;
              } else {
                if ((int )op == 2) {
                  _L___23: 
                  if (argp->opcode == 64U) {
                    pagep->prev_pgno = argp->prev_pgno;
                    flags = 2U;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (flags) {
      if ((int )op == 4) {
        pagep->lsn = (*lsnp);
      } else {
        if ((int )op == 1) {
          pagep->lsn = (*lsnp);
        } else {
          pagep->lsn = argp->nextlsn;
        }
      }
    }
    ret = __memp_fput(mpf, (void *)pagep, flags);
    if (ret != 0) {
      goto out;
    }
    pagep = (PAGE *)((void *)0);
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_replace_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __ham_replace_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  DBT dbt ;
  PAGE *pagep ;
  u_int32_t flags ;
  int32_t grow ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  u_int8_t *hk ;
  unsigned int tmp___0 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_replace_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_replace_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        } else {
          ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  memset((void *)(& dbt), 0, sizeof(dbt));
  flags = 0U;
  grow = 1;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      dbt.data = argp->newitem.data;
      dbt.size = argp->newitem.size;
      grow = (int )(argp->newitem.size - argp->olditem.size);
      pagep->lsn = (*lsnp);
      flags = 2U;
    } else {
      if ((int )op == 1) {
        dbt.data = argp->newitem.data;
        dbt.size = argp->newitem.size;
        grow = (int )(argp->newitem.size - argp->olditem.size);
        pagep->lsn = (*lsnp);
        flags = 2U;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        dbt.data = argp->olditem.data;
        dbt.size = argp->olditem.size;
        grow = (int )(argp->olditem.size - argp->newitem.size);
        pagep->lsn = argp->pagelsn;
        flags = 2U;
      } else {
        if ((int )op == 3) {
          dbt.data = argp->olditem.data;
          dbt.size = argp->olditem.size;
          grow = (int )(argp->olditem.size - argp->newitem.size);
          pagep->lsn = argp->pagelsn;
          flags = 2U;
        } else {
          if ((int )op == 2) {
            dbt.data = argp->olditem.data;
            dbt.size = argp->olditem.size;
            grow = (int )(argp->olditem.size - argp->newitem.size);
            pagep->lsn = argp->pagelsn;
            flags = 2U;
          }
        }
      }
    }
  }
  if (flags) {
    __ham_onpage_replace(file_dbp, pagep, argp->ndx, argp->off, grow, & dbt);
    if (argp->makedup) {
      if (file_dbp->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if (file_dbp->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      hk = (u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___0) +
                                        argp->ndx));
      if ((int )op == 4) {
        (*hk) = (unsigned char)2;
      } else {
        if ((int )op == 1) {
          (*hk) = (unsigned char)2;
        } else {
          (*hk) = (unsigned char)1;
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_splitdata_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) 
{ __ham_splitdata_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t flags ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_splitdata_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_splitdata_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        } else {
          ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  flags = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___2;
    } else {
      if ((int )op == 1) {
        _L___2: 
        if (argp->opcode == 144U) {
          memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pageimage.data,
                 argp->pageimage.size);
        }
        pagep->lsn = (*lsnp);
        flags = 2U;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            if (argp->opcode == 128U) {
              memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->pageimage.data,
                     argp->pageimage.size);
            } else {
              while (1) {
                pagep->pgno = argp->pgno;
                pagep->prev_pgno = 0U;
                pagep->next_pgno = 0U;
                pagep->entries = (unsigned short)0;
                pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                pagep->level = (unsigned char)0;
                pagep->type = (unsigned char)2;
                break;
              }
            }
            pagep->lsn = argp->pagelsn;
            flags = 2U;
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_copypage_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                           void *info ) 
{ __ham_copypage_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t flags ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_copypage_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_copypage_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  flags = 0U;
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      ret = 0;
      goto donext;
    } else {
      if ((int )op == 3) {
        ret = 0;
        goto donext;
      } else {
        if ((int )op == 2) {
          ret = 0;
          goto donext;
        } else {
          ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
             argp->page.size);
      pagep->pgno = argp->pgno;
      pagep->prev_pgno = 0U;
      pagep->lsn = (*lsnp);
      flags = 2U;
    } else {
      if ((int )op == 1) {
        memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
               argp->page.size);
        pagep->pgno = argp->pgno;
        pagep->prev_pgno = 0U;
        pagep->lsn = (*lsnp);
        flags = 2U;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            while (1) {
              pagep->pgno = argp->pgno;
              pagep->prev_pgno = 0U;
              pagep->next_pgno = argp->next_pgno;
              pagep->entries = (unsigned short)0;
              pagep->hf_offset = (unsigned short )file_dbp->pgsize;
              pagep->level = (unsigned char)0;
              pagep->type = (unsigned char)2;
              break;
            }
            pagep->lsn = argp->pagelsn;
            flags = 2U;
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  donext: 
  ret = __memp_fget(mpf, & argp->next_pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      ret = 0;
      goto do_nn;
    } else {
      if ((int )op == 3) {
        ret = 0;
        goto do_nn;
      } else {
        if ((int )op == 2) {
          ret = 0;
          goto do_nn;
        } else {
          ret = __memp_fget(mpf, & argp->next_pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->nextlsn));
  if ((int )op == 4) {
    goto _L___2;
  } else {
    if ((int )op == 1) {
      _L___2: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->nextlsn.file, (unsigned long )argp->nextlsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->nextlsn.file, (unsigned long )argp->nextlsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  flags = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
      flags = 2U;
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
        flags = 2U;
      } else {
        goto _L___3;
      }
    }
  } else {
    _L___3: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
               argp->page.size);
        flags = 2U;
      } else {
        if ((int )op == 3) {
          memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
                 argp->page.size);
          flags = 2U;
        } else {
          if ((int )op == 2) {
            memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
                   argp->page.size);
            flags = 2U;
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  do_nn: 
  if (argp->nnext_pgno == 0U) {
    goto done;
  }
  ret = __memp_fget(mpf, & argp->nnext_pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        } else {
          ret = __memp_fget(mpf, & argp->nnext_pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->nnextlsn));
  if ((int )op == 4) {
    goto _L___4;
  } else {
    if ((int )op == 1) {
      _L___4: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->nnextlsn.file, (unsigned long )argp->nnextlsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->nnextlsn.file, (unsigned long )argp->nnextlsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  flags = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      pagep->prev_pgno = argp->pgno;
      pagep->lsn = (*lsnp);
      flags = 2U;
    } else {
      if ((int )op == 1) {
        pagep->prev_pgno = argp->pgno;
        pagep->lsn = (*lsnp);
        flags = 2U;
      } else {
        goto _L___5;
      }
    }
  } else {
    _L___5: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        pagep->prev_pgno = argp->next_pgno;
        pagep->lsn = argp->nnextlsn;
        flags = 2U;
      } else {
        if ((int )op == 3) {
          pagep->prev_pgno = argp->next_pgno;
          pagep->lsn = argp->nnextlsn;
          flags = 2U;
        } else {
          if ((int )op == 2) {
            pagep->prev_pgno = argp->next_pgno;
            pagep->lsn = argp->nnextlsn;
            flags = 2U;
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_metagroup_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) 
{ __ham_metagroup_args *argp ;
  HASH_CURSOR *hcp ;
  DB *file_dbp ;
  DBMETA *mmeta ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  u_int32_t flags ;
  u_int32_t mmeta_flags ;
  int cmp_n ;
  int cmp_p ;
  int did_recover ;
  int groupgrow ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  mmeta_flags = 0U;
  mmeta = (DBMETA *)((void *)0);
  while (1) {
    argp = (__ham_metagroup_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_metagroup_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  tmp = __db_log2(argp->bucket + 1U);
  groupgrow = (unsigned int )(1 << tmp) == argp->bucket + 1U;
  pgno = argp->pgno;
  if (argp->newalloc) {
    pgno += argp->bucket;
  }
  ret = __memp_fget(mpf, & pgno, 1U, (void *)(& pagep));
  if (ret != 0) {
    if (ret != 28) {
      goto out;
    }
    pgno = 0U;
    groupgrow = 0;
    goto do_meta;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  flags = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___1;
    } else {
      if ((int )op == 1) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___1;
      } else {
        if ((int )op == 3) {
          goto _L___1;
        } else {
          if ((int )op == 2) {
            _L___1: 
            if ((int )op == 4) {
              pagep->lsn = (*lsnp);
            } else {
              if ((int )op == 1) {
                pagep->lsn = (*lsnp);
              } else {
                pagep->lsn = argp->pagelsn;
              }
            }
            flags = 2U;
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, flags);
  if (ret != 0) {
    goto out;
  }
  do_meta: 
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    goto out;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& (hcp->hdr)->dbmeta.lsn));
  cmp_p = log_compare((DB_LSN const   *)(& (hcp->hdr)->dbmeta.lsn), (DB_LSN const   *)(& argp->metalsn));
  if ((int )op == 4) {
    goto _L___3;
  } else {
    if ((int )op == 1) {
      _L___3: 
      if (cmp_p < 0) {
        if ((hcp->hdr)->dbmeta.lsn.file == 0U) {
          if (! ((hcp->hdr)->dbmeta.lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )(hcp->hdr)->dbmeta.lsn.file, (unsigned long )(hcp->hdr)->dbmeta.lsn.offset,
                     (unsigned long )argp->metalsn.file, (unsigned long )argp->metalsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )(hcp->hdr)->dbmeta.lsn.file, (unsigned long )(hcp->hdr)->dbmeta.lsn.offset,
                   (unsigned long )argp->metalsn.file, (unsigned long )argp->metalsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  did_recover = 0;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___6;
    } else {
      if ((int )op == 1) {
        _L___6: 
        (hcp->hdr)->max_bucket = (hcp->hdr)->max_bucket + 1U;
        if (groupgrow) {
          (hcp->hdr)->low_mask = (hcp->hdr)->high_mask;
          (hcp->hdr)->high_mask = (argp->bucket + 1U) | (hcp->hdr)->low_mask;
        }
        (hcp->hdr)->dbmeta.lsn = (*lsnp);
        did_recover = 1;
      } else {
        goto _L___5;
      }
    }
  } else {
    _L___5: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___4;
      } else {
        if ((int )op == 3) {
          goto _L___4;
        } else {
          if ((int )op == 2) {
            _L___4: 
            (hcp->hdr)->max_bucket = (hcp->hdr)->max_bucket - 1U;
            if (groupgrow) {
              (hcp->hdr)->high_mask = (hcp->hdr)->low_mask;
              (hcp->hdr)->low_mask = (hcp->hdr)->high_mask >> 1;
            }
            (hcp->hdr)->dbmeta.lsn = argp->metalsn;
            did_recover = 1;
          }
        }
      }
    }
  }
  if (groupgrow) {
    tmp___1 = __db_log2(argp->bucket + 1U);
    if ((hcp->hdr)->spares[tmp___1 + 1U] == 0U) {
      tmp___0 = __db_log2(argp->bucket + 1U);
      (hcp->hdr)->spares[tmp___0 + 1U] = (argp->pgno - argp->bucket) - 1U;
      did_recover = 1;
    }
  }
  if (argp->mmpgno != argp->mpgno) {
    ret = __memp_fget(mpf, & argp->mmpgno, 0U, (void *)(& mmeta));
    if (ret != 0) {
      goto out;
    }
    mmeta_flags = 0U;
    cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& mmeta->lsn));
    cmp_p = log_compare((DB_LSN const   *)(& mmeta->lsn), (DB_LSN const   *)(& argp->mmetalsn));
    if (cmp_p == 0) {
      if ((int )op == 4) {
        mmeta->lsn = (*lsnp);
        mmeta_flags = 2U;
      } else {
        if ((int )op == 1) {
          mmeta->lsn = (*lsnp);
          mmeta_flags = 2U;
        } else {
          goto _L___7;
        }
      }
    } else {
      _L___7: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          mmeta->lsn = argp->mmetalsn;
          mmeta_flags = 2U;
        } else {
          if ((int )op == 3) {
            mmeta->lsn = argp->mmetalsn;
            mmeta_flags = 2U;
          } else {
            if ((int )op == 2) {
              mmeta->lsn = argp->mmetalsn;
              mmeta_flags = 2U;
            }
          }
        }
      }
    }
  } else {
    mmeta = (DBMETA *)hcp->hdr;
  }
  if (mmeta->last_pgno < pgno) {
    mmeta->last_pgno = pgno;
  }
  mmeta_flags = 2U;
  if (argp->mmpgno != argp->mpgno) {
    ret = __memp_fput(mpf, (void *)mmeta, mmeta_flags);
    if (ret != 0) {
      goto out;
    }
  }
  mmeta = (DBMETA *)((void *)0);
  if (did_recover) {
    hcp->flags = hcp->flags | 4U;
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )mmeta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)mmeta, 0U);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __ham_release_meta(dbc);
  }
  if (ret == 2) {
    if ((int )op == 2) {
      ret = 0;
    }
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_groupalloc_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                             void *info ) 
{ __ham_groupalloc_args *argp ;
  DBMETA *mmeta ;
  DB_MPOOLFILE *mpf ;
  DB *file_dbp ;
  DBC *dbc ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __t_ret ;

  {
  mmeta = (DBMETA *)((void *)0);
  modified = 0;
  while (1) {
    argp = (__ham_groupalloc_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_groupalloc_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  pgno = 0U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& mmeta));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, pgno, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, pgno, ret);
        goto out;
      } else {
        ret = 0;
        goto done;
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)mmeta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)mmeta)->lsn), (DB_LSN const   *)(& argp->meta_lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (((PAGE *)mmeta)->lsn.file == 0U) {
          if (! (((PAGE *)mmeta)->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )((PAGE *)mmeta)->lsn.file, (unsigned long )((PAGE *)mmeta)->lsn.offset,
                     (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )((PAGE *)mmeta)->lsn.file, (unsigned long )((PAGE *)mmeta)->lsn.offset,
                   (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  pgno = (argp->start_pgno + argp->num) - 1U;
  if ((int )op == 4) {
    goto _L___1;
  } else {
    if ((int )op == 1) {
      _L___1: 
      ret = __ham_alloc_pages(file_dbp, argp, lsnp);
      if (ret != 0) {
        goto out;
      }
      if (cmp_p == 0) {
        ((PAGE *)mmeta)->lsn = (*lsnp);
        modified = 1;
      }
    } else {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pagep));
            if (ret == 0) {
              tmp = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)lsnp);
              if (tmp == 0) {
                while (1) {
                  pagep->lsn.file = 0U;
                  pagep->lsn.offset = 0U;
                  break;
                }
              }
              ret = __memp_fput(mpf, (void *)pagep, 2U);
              if (ret != 0) {
                goto out;
              }
            } else {
              if (ret != -30988) {
                goto out;
              }
            }
            ret = __db_add_limbo(dbenv___0, info, argp->fileid, argp->start_pgno,
                                 (int )argp->num);
            if (ret != 0) {
              goto out;
            }
            if (cmp_n == 0) {
              ((PAGE *)mmeta)->lsn = argp->meta_lsn;
              modified = 1;
            }
          }
        }
      }
    }
  }
  if (pgno > mmeta->last_pgno) {
    mmeta->last_pgno = pgno;
    modified = 1;
  }
  done: 
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  out: 
  if ((unsigned int )mmeta != (unsigned int )((void *)0)) {
    if (modified) {
      tmp___0 = 2;
    } else {
      tmp___0 = 0;
    }
    __memp_fput(mpf, (void *)mmeta, (unsigned int )tmp___0);
  }
  if (ret == 2) {
    if ((int )op == 2) {
      ret = 0;
    }
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
static int __ham_alloc_pages(DB *dbp___1 , __ham_groupalloc_args *argp , DB_LSN *lsnp ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  int ret ;
  int tmp ;

  {
  mpf = dbp___1->mpf;
  pgno = (argp->start_pgno + argp->num) - 1U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pagep));
  if (ret == 0) {
    if ((int )pagep->entries == 0) {
      if (pagep->lsn.file == 0U) {
        goto reinit_page;
      }
    }
    ret = __memp_fput(mpf, (void *)pagep, 0U);
    if (ret != 0) {
      return (ret);
    }
    return (0);
  }
  ret = __memp_fget(mpf, & pgno, 1U, (void *)(& pagep));
  if (ret != 0) {
    tmp = __db_pgerr(dbp___1, pgno, ret);
    return (tmp);
  }
  reinit_page: 
  while (1) {
    pagep->pgno = pgno;
    pagep->prev_pgno = 0U;
    pagep->next_pgno = 0U;
    pagep->entries = (unsigned short)0;
    pagep->hf_offset = (unsigned short )dbp___1->pgsize;
    pagep->level = (unsigned char)0;
    pagep->type = (unsigned char)2;
    break;
  }
  pagep->lsn = (*lsnp);
  ret = __memp_fput(mpf, (void *)pagep, 2U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __ham_curadj_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __ham_curadj_args *argp ;
  DB_MPOOLFILE *mpf ;
  DB *file_dbp ;
  DBC *dbc ;
  int ret ;
  HASH_CURSOR *hcp ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_curadj_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_curadj_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  if ((int )op != 0) {
    goto done;
  }
  hcp = (HASH_CURSOR *)dbc->internal;
  hcp->pgno = argp->pgno;
  hcp->indx = (unsigned short )argp->indx;
  hcp->dup_off = (unsigned short )argp->dup_off;
  hcp->order = argp->order;
  if (! argp->add) {
    hcp->flags = hcp->flags | 2U;
  }
  __ham_c_update(dbc, argp->len, (! argp->add != 0) != 0, argp->is_dup);
  done: 
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __ham_chgpg_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __ham_chgpg_args *argp ;
  BTREE_CURSOR *opdcp ;
  DB_MPOOLFILE *mpf ;
  DB *file_dbp ;
  DB *ldbp ;
  DBC *dbc ;
  int ret ;
  DBC *cp ;
  HASH_CURSOR *lcp ;
  u_int32_t order ;
  u_int32_t indx ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__ham_chgpg_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __ham_chgpg_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  if ((int )op != 0) {
    goto done;
  }
  indx = argp->old_indx;
  order = argp->new_indx;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  ldbp = __dblist_get(dbenv___0, file_dbp->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == file_dbp->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )file_dbp->mutexp != (unsigned int )((void *)0)) {
      if (! ((file_dbp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, file_dbp->mutexp);
      }
    }
    cp = ldbp->active_queue.tqh_first;
    while ((unsigned int )cp != (unsigned int )((void *)0)) {
      lcp = (HASH_CURSOR *)cp->internal;
      switch ((int )argp->mode) {
      case 2: ;
      if (lcp->pgno != argp->new_pgno) {
        break;
      }
      if ((unsigned int )lcp->indx != indx) {
        goto _L;
      } else {
        if (! (lcp->flags & 2U)) {
          goto _L;
        } else {
          if (lcp->order >= order) {
            _L: 
            lcp->pgno = argp->old_pgno;
            if ((unsigned int )lcp->indx == indx) {
              lcp->order = lcp->order - order;
            }
          }
        }
      }
      break;
      case 3: ;
      case 4: ;
      if (lcp->pgno == argp->new_pgno) {
        if ((unsigned int )lcp->indx == indx) {
          if (lcp->flags & 2U) {
            if (lcp->order >= order) {
              lcp->pgno = argp->old_pgno;
              lcp->order = lcp->order - order;
              lcp->indx = (unsigned short)0;
            }
          }
        }
      }
      break;
      case 1: ;
      if (lcp->flags & 2U) {
        break;
      }
      case 6: ;
      if (lcp->pgno == argp->new_pgno) {
        if ((unsigned int )lcp->indx == argp->new_indx) {
          lcp->indx = (unsigned short )argp->old_indx;
          lcp->pgno = argp->old_pgno;
        }
      }
      break;
      case 5: ;
      if ((unsigned int )lcp->opd == (unsigned int )((void *)0)) {
        break;
      }
      opdcp = (BTREE_CURSOR *)(lcp->opd)->internal;
      if (opdcp->pgno != argp->new_pgno) {
        break;
      } else {
        if ((unsigned int )opdcp->indx != argp->new_indx) {
          break;
        }
      }
      if (opdcp->flags & 1U) {
        lcp->flags = lcp->flags | 2U;
      }
      if ((unsigned int )file_dbp->mutexp != (unsigned int )((void *)0)) {
        if (! ((file_dbp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, file_dbp->mutexp);
        }
      }
      ret = __db_c_close(lcp->opd);
      if (ret != 0) {
        goto out;
      }
      if ((unsigned int )file_dbp->mutexp != (unsigned int )((void *)0)) {
        if (! ((file_dbp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, file_dbp->mutexp);
        }
      }
      lcp->opd = (DBC *)((void *)0);
      break;
      }
      cp = cp->links.tqe_next;
    }
    if ((unsigned int )file_dbp->mutexp != (unsigned int )((void *)0)) {
      if (! ((file_dbp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, file_dbp->mutexp);
      }
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-LCq4TLTG.i","-O2")
int __ham_reclaim(DB *dbp___1 , DB_TXN *txn ) ;
int __ham_truncate(DBC *dbc , u_int32_t *countp ) ;
int __ham_traverse(DBC *dbc , db_lockmode_t mode , int (*callback)(DB * , PAGE * ,
                                                                   void * , int * ) ,
                   void *cookie , int look_past_max ) ;
int __ham_reclaim(DB *dbp___1 , DB_TXN *txn ) 
{ DBC *dbc ;
  HASH_CURSOR *hcp ;
  int ret ;

  {
  ret = __db_cursor(dbp___1, txn, & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    goto err;
  }
  ret = __ham_traverse(dbc, (enum __anonenum_db_lockmode_t_50 )2, & __db_reclaim_callback,
                       (void *)dbc, 1);
  if (ret != 0) {
    goto err;
  }
  ret = __db_c_close(dbc);
  if (ret != 0) {
    goto err;
  }
  ret = __ham_release_meta(dbc);
  if (ret != 0) {
    goto err;
  }
  return (0);
  err: 
  if ((unsigned int )hcp->hdr != (unsigned int )((void *)0)) {
    __ham_release_meta(dbc);
  }
  __db_c_close(dbc);
  return (ret);
}
}
int __ham_truncate(DBC *dbc , u_int32_t *countp ) 
{ db_trunc_param trunc ;
  int ret ;
  int t_ret ;

  {
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    return (ret);
  }
  trunc.count = 0U;
  trunc.dbc = dbc;
  ret = __ham_traverse(dbc, (enum __anonenum_db_lockmode_t_50 )2, & __db_truncate_callback,
                       (void *)(& trunc), 1);
  t_ret = __ham_release_meta(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  (*countp) = trunc.count;
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-djWMe91X.i","-O2")
int __ham_stat(DBC *dbc , void *spp , u_int32_t flags ) ;
static int __ham_stat_callback(DB *dbp___1 , PAGE *pagep , void *cookie , int *putp ) ;
int __ham_stat(DBC *dbc , void *spp , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  DB_HASH_STAT *sp ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  PAGE *h ;
  db_pgno_t pgno ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  sp = (DB_HASH_STAT *)((void *)0);
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = __ham_get_meta(dbc);
  if (ret != 0) {
    goto err;
  }
  ret = __os_umalloc(dbenv___0, sizeof((*sp)), (void *)(& sp));
  if (ret != 0) {
    goto err;
  }
  memset((void *)sp, 0, sizeof((*sp)));
  sp->hash_nkeys = (hcp->hdr)->dbmeta.key_count;
  sp->hash_ndata = (hcp->hdr)->dbmeta.record_count;
  sp->hash_pagesize = dbp___1->pgsize;
  sp->hash_buckets = (hcp->hdr)->max_bucket + 1U;
  sp->hash_magic = (hcp->hdr)->dbmeta.magic;
  sp->hash_version = (hcp->hdr)->dbmeta.version;
  sp->hash_metaflags = (hcp->hdr)->dbmeta.flags;
  sp->hash_ffactor = (hcp->hdr)->ffactor;
  if (flags == 8U) {
    goto done;
  } else {
    if (flags == 4U) {
      goto done;
    }
  }
  sp->hash_free = 0U;
  pgno = (hcp->hdr)->dbmeta.free;
  while (pgno != 0U) {
    sp->hash_free ++;
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
    pgno = h->next_pgno;
    __memp_fput(mpf, (void *)h, 0U);
  }
  sp->hash_nkeys = 0U;
  sp->hash_ndata = 0U;
  ret = __ham_traverse(dbc, (enum __anonenum_db_lockmode_t_50 )1, & __ham_stat_callback,
                       (void *)sp, 0);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 524288U)) {
    ret = __ham_dirty_meta(dbc);
    if (ret != 0) {
      goto err;
    }
    (hcp->hdr)->dbmeta.key_count = sp->hash_nkeys;
    (hcp->hdr)->dbmeta.record_count = sp->hash_ndata;
  }
  done: 
  ret = __ham_release_meta(dbc);
  if (ret != 0) {
    goto err;
  }
  (*((DB_HASH_STAT **)spp)) = sp;
  return (0);
  err: 
  if ((unsigned int )sp != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, (void *)sp);
  }
  if ((unsigned int )hcp->hdr != (unsigned int )((void *)0)) {
    __ham_release_meta(dbc);
  }
  return (ret);
}
}
int __ham_traverse(DBC *dbc , db_lockmode_t mode , int (*callback)(DB * , PAGE * ,
                                                                   void * , int * ) ,
                   void *cookie , int look_past_max ) 
{ DB *dbp___1 ;
  DBC *opd ;
  DB_MPOOLFILE *mpf ;
  HASH_CURSOR *hcp ;
  HKEYDATA *hk ;
  db_pgno_t pgno ;
  db_pgno_t opgno ;
  int did_put ;
  int i ;
  int ret ;
  int t_ret ;
  u_int32_t bucket ;
  u_int32_t spares_entry ;
  u_int32_t tmp ;
  unsigned int tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  opd = (DBC *)((void *)0);
  mpf = dbp___1->mpf;
  hcp = (HASH_CURSOR *)dbc->internal;
  ret = 0;
  bucket = 0U;
  while (1) {
    if (look_past_max) {
      spares_entry = __db_log2(bucket + 1U);
      if (spares_entry >= 32U) {
        break;
      } else {
        if ((hcp->hdr)->spares[spares_entry] == 0U) {
          break;
        }
      }
    } else {
      if (bucket > (hcp->hdr)->max_bucket) {
        break;
      }
    }
    hcp->bucket = bucket;
    tmp = __db_log2(bucket + 1U);
    pgno = bucket + (hcp->hdr)->spares[tmp];
    hcp->pgno = pgno;
    ret = __ham_get_cpage(dbc, mode);
    while (ret == 0) {
      if ((int )((PAGE *)hcp->page)->type == 0) {
        break;
      }
      pgno = ((PAGE *)hcp->page)->next_pgno;
      i = 0;
      while (i < (int )((PAGE *)hcp->page)->entries) {
        if (dbp___1->flags & 2048U) {
          tmp___1 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___1 = sizeof(PG_CHKSUM );
          } else {
            tmp___1 = 0U;
          }
        }
        hk = (HKEYDATA *)((u_int8_t *)hcp->page + (int )(*((db_indx_t *)(((u_int8_t *)hcp->page +
                                                                          26) + tmp___1) +
                                                           i)));
        switch ((int )(*((u_int8_t *)hk))) {
        case 4: 
        memcpy((void * __restrict  )(& opgno), (void const   * __restrict  )((u_int8_t *)hk +
                                                                             (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
               sizeof(db_pgno_t ));
        ret = __db_c_newopd(dbc, opgno, (DBC *)((void *)0), & opd);
        if (ret != 0) {
          return (ret);
        }
        ret = __bam_traverse(opd, (enum __anonenum_db_lockmode_t_50 )1, opgno, callback,
                             cookie);
        if (ret != 0) {
          goto err;
        }
        ret = __db_c_close(opd);
        if (ret != 0) {
          return (ret);
        }
        opd = (DBC *)((void *)0);
        break;
        case 3: 
        memcpy((void * __restrict  )(& opgno), (void const   * __restrict  )((u_int8_t *)hk +
                                                                             (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
               sizeof(db_pgno_t ));
        ret = __db_traverse_big(dbp___1, opgno, callback, cookie);
        if (ret != 0) {
          goto err;
        }
        break;
        case 1: ;
        break;
        }
        i ++;
      }
      ret = ((*callback))(dbp___1, (PAGE *)hcp->page, cookie, & did_put);
      if (ret != 0) {
        goto err;
      }
      if (did_put) {
        hcp->page = (void *)0;
      }
      if (pgno == 0U) {
        break;
      }
      ret = __ham_next_cpage(dbc, pgno, 0);
    }
    if (ret != 0) {
      goto err;
    }
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          __lock_put(dbp___1->dbenv, & hcp->lock);
        }
      }
    }
    if ((unsigned int )hcp->page != (unsigned int )((void *)0)) {
      ret = __memp_fput(mpf, hcp->page, 0U);
      if (ret != 0) {
        return (ret);
      }
      hcp->page = (void *)0;
    }
    bucket ++;
  }
  err: 
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(opd);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
static int __ham_stat_callback(DB *dbp___1 , PAGE *pagep , void *cookie , int *putp ) 
{ DB_HASH_STAT *sp ;
  DB_BTREE_STAT bstat ;
  db_indx_t indx ;
  db_indx_t len ;
  db_indx_t off ;
  db_indx_t tlen ;
  db_indx_t top ;
  u_int8_t *hk ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___7 ;
  unsigned int tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;
  int tmp___16 ;

  {
  (*putp) = 0;
  sp = (DB_HASH_STAT *)cookie;
  switch ((int )pagep->type) {
  case 0: ;
  break;
  case 2: ;
  if (pagep->prev_pgno == 0U) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    sp->hash_bfree += (unsigned int )pagep->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                          26) +
                                                                                                                         tmp___0)))) +
                                                         (unsigned int )pagep->entries *
                                                         sizeof(db_indx_t ));
  } else {
    sp->hash_overflows ++;
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    sp->hash_ovfl_free += (unsigned int )pagep->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                              26) +
                                                                                                                             tmp___2)))) +
                                                             (unsigned int )pagep->entries *
                                                             sizeof(db_indx_t ));
  }
  top = pagep->entries;
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    switch ((int )(*((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                 26) + tmp___4) +
                                                  ((int )indx + 1)))))) {
    case 4: ;
    break;
    case 3: ;
    case 1: 
    sp->hash_ndata ++;
    break;
    case 2: ;
    if ((int )indx + 1 == 0) {
      tmp___7 = 0;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___9 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___9 = sizeof(PG_CHKSUM );
        } else {
          tmp___9 = 0U;
        }
      }
      tmp___7 = (int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___9) + (((int )indx +
                                                                               1) -
                                                                              1)));
    }
    if (dbp___1->flags & 2048U) {
      tmp___11 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___11 = sizeof(PG_CHKSUM );
      } else {
        tmp___11 = 0U;
      }
    }
    tlen = (unsigned short )((tmp___7 - (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                26) + tmp___11) +
                                                 ((int )indx + 1)))) - (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
    if (dbp___1->flags & 2048U) {
      tmp___13 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___13 = sizeof(PG_CHKSUM );
      } else {
        tmp___13 = 0U;
      }
    }
    hk = (u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___13) +
                                      ((int )indx + 1)));
    off = (unsigned short)0;
    while ((int )off < (int )tlen) {
      sp->hash_ndata ++;
      memcpy((void * __restrict  )(& len), (void const   * __restrict  )((hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                                                         (int )off),
             sizeof(db_indx_t ));
      off = (unsigned short )((unsigned int )off + ((unsigned int )len + 2U * sizeof(db_indx_t )));
    }
    }
    indx = (unsigned short )((int )indx + 2);
  }
  sp->hash_nkeys += (unsigned int )((int )pagep->entries / 2);
  break;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 12: 
  memset((void *)(& bstat), 0, sizeof(bstat));
  ret = __bam_stat_callback(dbp___1, pagep, (void *)(& bstat), putp);
  if (ret != 0) {
    return (ret);
  }
  sp->hash_dup ++;
  sp->hash_dup_free += (bstat.bt_leaf_pgfree + bstat.bt_dup_pgfree) + bstat.bt_int_pgfree;
  sp->hash_ndata += bstat.bt_ndata;
  break;
  case 7: 
  sp->hash_bigpages ++;
  if (dbp___1->flags & 2048U) {
    tmp___15 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___15 = sizeof(PG_CHKSUM );
    } else {
      tmp___15 = 0U;
    }
  }
  sp->hash_big_bfree += (dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                            26) +
                                                                                                           tmp___15))))) -
                        (unsigned int )pagep->hf_offset;
  break;
  default: 
  tmp___16 = __db_pgfmt(dbp___1->dbenv, pagep->pgno);
  return (tmp___16);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-koIusFKC.i","-O2")
int __os_write(DB_ENV *dbenv___0 , DB_FH *fhp , void *addr , size_t len , size_t *nwp ) ;
int __os_seek(DB_ENV *dbenv___0 , DB_FH *fhp , size_t pgsize , db_pgno_t pageno ,
              u_int32_t relative , int isrewind , DB_OS_SEEK db_whence ) ;
int __ham_30_hashmeta(DB *dbp___1 , char *real_name , u_int8_t *obuf ) ;
int __ham_30_sizefix(DB *dbp___1 , DB_FH *fhp , char *realname , u_int8_t *metabuf ) ;
int __ham_31_hashmeta(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp ,
                      PAGE *h , int *dirtyp ) ;
int __ham_31_hash(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp , PAGE *h ,
                  int *dirtyp ) ;
int __db_lastpgno(DB *dbp___1 , char *real_name , DB_FH *fhp , db_pgno_t *pgno_lastp ) ;
int __ham_30_hashmeta(DB *dbp___1 , char *real_name , u_int8_t *obuf ) 
{ DB_ENV *dbenv___0 ;
  HASHHDR *oldmeta ;
  HMETA30 newmeta ;
  u_int32_t *o_spares ;
  u_int32_t *n_spares ;
  u_int32_t fillf ;
  u_int32_t maxb ;
  u_int32_t nelem ;
  int i ;
  int max_entry ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  memset((void *)(& newmeta), 0, sizeof(newmeta));
  oldmeta = (HASHHDR *)obuf;
  newmeta.dbmeta.lsn = oldmeta->lsn;
  newmeta.dbmeta.pgno = oldmeta->pgno;
  newmeta.dbmeta.magic = oldmeta->magic;
  newmeta.dbmeta.version = 6U;
  newmeta.dbmeta.pagesize = oldmeta->pagesize;
  newmeta.dbmeta.type = (unsigned char)8;
  newmeta.dbmeta.flags = oldmeta->flags;
  newmeta.dbmeta.free = oldmeta->last_freed;
  newmeta.max_bucket = oldmeta->max_bucket;
  newmeta.high_mask = oldmeta->high_mask;
  newmeta.low_mask = oldmeta->low_mask;
  newmeta.ffactor = oldmeta->ffactor;
  newmeta.nelem = oldmeta->nelem;
  newmeta.h_charkey = oldmeta->h_charkey;
  nelem = newmeta.nelem;
  fillf = newmeta.ffactor;
  maxb = newmeta.max_bucket;
  if (fillf != 0U) {
    if (fillf * maxb < 2U * nelem) {
      newmeta.nelem = 0U;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (fillf == 0U) {
      if (nelem > 134217728U) {
        newmeta.nelem = 0U;
      }
    }
  }
  o_spares = oldmeta->spares;
  n_spares = newmeta.spares;
  max_entry = (int )__db_log2(maxb + 1U);
  (*(n_spares + 0)) = 1U;
  i = 1;
  while (1) {
    if (i < 32) {
      if (! (i <= max_entry)) {
        break;
      }
    } else {
      break;
    }
    (*(n_spares + i)) = 1U + (*(o_spares + (i - 1)));
    i ++;
  }
  ret = __os_fileid(dbenv___0, (char const   *)real_name, 1, newmeta.dbmeta.uid);
  if (ret != 0) {
    return (ret);
  }
  memcpy((void * __restrict  )oldmeta, (void const   * __restrict  )(& newmeta), sizeof(newmeta));
  return (0);
}
}
int __ham_30_sizefix(DB *dbp___1 , DB_FH *fhp , char *realname , u_int8_t *metabuf ) 
{ u_int8_t buf[65536] ;
  DB_ENV *dbenv___0 ;
  HMETA30 *meta ;
  db_pgno_t last_actual ;
  db_pgno_t last_desired ;
  int ret ;
  size_t nw ;
  u_int32_t pagesize ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  memset((void *)(buf), 0, 65536U);
  meta = (HMETA30 *)metabuf;
  pagesize = meta->dbmeta.pagesize;
  dbp___1->pgsize = pagesize;
  ret = __db_lastpgno(dbp___1, realname, fhp, & last_actual);
  if (ret != 0) {
    return (ret);
  }
  tmp = __db_log2(meta->high_mask + 1U);
  last_desired = meta->high_mask + meta->spares[tmp];
  if (last_desired > last_actual) {
    ret = __os_seek(dbenv___0, fhp, pagesize, last_desired, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
    if (ret != 0) {
      return (ret);
    }
    ret = __os_write(dbenv___0, fhp, (void *)(buf), pagesize, & nw);
    if (ret != 0) {
      return (ret);
    }
  }
  return (0);
}
}
int __ham_31_hashmeta(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp ,
                      PAGE *h , int *dirtyp ) 
{ HMETA31 *newmeta ;
  HMETA30 *oldmeta ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  real_name = (char *)((void *)0);
  real_name = real_name;
  fhp = (DB_FH *)((void *)0);
  fhp = fhp;
  newmeta = (HMETA31 *)h;
  oldmeta = (HMETA30 *)h;
  memmove((void *)(newmeta->spares), (void const   *)(oldmeta->spares), sizeof(oldmeta->spares));
  newmeta->h_charkey = oldmeta->h_charkey;
  newmeta->nelem = oldmeta->nelem;
  newmeta->ffactor = oldmeta->ffactor;
  newmeta->low_mask = oldmeta->low_mask;
  newmeta->high_mask = oldmeta->high_mask;
  newmeta->max_bucket = oldmeta->max_bucket;
  memmove((void *)(newmeta->dbmeta.uid), (void const   *)(oldmeta->dbmeta.uid), sizeof(oldmeta->dbmeta.uid));
  newmeta->dbmeta.flags = oldmeta->dbmeta.flags;
  newmeta->dbmeta.record_count = 0U;
  newmeta->dbmeta.key_count = 0U;
  while (1) {
    newmeta->dbmeta.unused3.file = 0U;
    newmeta->dbmeta.unused3.offset = 0U;
    break;
  }
  newmeta->dbmeta.version = 7U;
  if (flags & 4U) {
    newmeta->dbmeta.flags = newmeta->dbmeta.flags | 4U;
  }
  (*dirtyp) = 1;
  return (0);
}
}
int __ham_31_hash(DB *dbp___1 , char *real_name , u_int32_t flags , DB_FH *fhp , PAGE *h ,
                  int *dirtyp ) 
{ HKEYDATA *hk ;
  db_pgno_t pgno ;
  db_pgno_t tpgno ;
  db_indx_t indx ;
  int ret ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  flags = 0U;
  flags = flags;
  ret = 0;
  indx = (unsigned short)0;
  while ((int )indx < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    hk = (HKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___0) + ((int )indx +
                                                                         1))));
    if ((int )(*((u_int8_t *)hk)) == 4) {
      memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )((u_int8_t *)hk +
                                                                          (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
             sizeof(db_pgno_t ));
      tpgno = pgno;
      if (flags & 4U) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
      ret = __db_31_offdup(dbp___1, real_name, fhp, tmp___1, & tpgno);
      if (ret != 0) {
        break;
      }
      if (pgno != tpgno) {
        (*dirtyp) = 1;
        memcpy((void * __restrict  )((u_int8_t *)hk + (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
               (void const   * __restrict  )(& tpgno), sizeof(db_pgno_t ));
      }
    }
    indx = (unsigned short )((int )indx + 2);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-c4cqNnD0.i","-O2")
int __bam_vrfy_subtree(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , void *l ,
                       void *r , u_int32_t flags , u_int32_t *levelp , u_int32_t *nrecsp ,
                       u_int32_t *relenp ) ;
int __db_vrfy_ovfl_structure(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t tlen ,
                             u_int32_t flags ) ;
int __db_safe_goff(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , DBT *dbt , void *buf ,
                   u_int32_t flags ) ;
int __db_prdbt(DBT *dbtp , int checkprint , char const   *prefix , void *handle ,
               int (*callback)(void * , void const   * ) , int is_recno , VRFY_DBINFO *vdp ) ;
int __db_vrfy_datapage(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                       u_int32_t flags ) ;
int __db_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , DBMETA *meta , db_pgno_t pgno ,
                   u_int32_t flags ) ;
void __db_vrfy_struct_feedback(DB *dbp___1 , VRFY_DBINFO *vdp ) ;
int __db_vrfy_inpitem(DB *dbp___1 , PAGE *h , db_pgno_t pgno , u_int32_t i , int is_btree ,
                      u_int32_t flags , u_int32_t *himarkp , u_int32_t *offsetp ) ;
int __db_vrfy_duptype(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t flags ) ;
int __db_salvage_duptree(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , DBT *key ,
                         void *handle , int (*callback)(void * , void const   * ) ,
                         u_int32_t flags ) ;
int __db_vrfy_getpageinfo(VRFY_DBINFO *vdp , db_pgno_t pgno , VRFY_PAGEINFO **pipp ) ;
int __db_vrfy_putpageinfo(DB_ENV *dbenv___0 , VRFY_DBINFO *vdp , VRFY_PAGEINFO *pip ) ;
int __db_vrfy_pgset_get(DB *dbp___1 , db_pgno_t pgno , int *valp ) ;
int __db_vrfy_pgset_inc(DB *dbp___1 , db_pgno_t pgno ) ;
int __db_vrfy_childcursor(VRFY_DBINFO *vdp , DBC **dbcp ) ;
int __db_vrfy_childput(VRFY_DBINFO *vdp , db_pgno_t pgno , VRFY_CHILDINFO *cip ) ;
int __db_vrfy_ccset(DBC *dbc , db_pgno_t pgno , VRFY_CHILDINFO **cipp ) ;
int __db_vrfy_ccnext(DBC *dbc , VRFY_CHILDINFO **cipp ) ;
int __db_vrfy_ccclose(DBC *dbc ) ;
int __db_salvage_markdone(VRFY_DBINFO *vdp , db_pgno_t pgno ) ;
int __ham_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , HMETA *m , db_pgno_t pgno , u_int32_t flags ) ;
int __ham_vrfy(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) ;
int __ham_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t meta_pgno , u_int32_t flags ) ;
int __ham_vrfy_hashing(DB *dbp___1 , u_int32_t nentries , HMETA *m , u_int32_t thisbucket ,
                       db_pgno_t pgno , u_int32_t flags , u_int32_t (*hfunc)(DB * ,
                                                                             void const   * ,
                                                                             u_int32_t  ) ) ;
int __ham_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h , void *handle ,
                  int (*callback)(void * , void const   * ) , u_int32_t flags ) ;
int __ham_meta2pgset(DB *dbp___1 , VRFY_DBINFO *vdp , HMETA *hmeta , u_int32_t flags ,
                     DB *pgset ) ;
static int __ham_dups_unsorted(DB *dbp___1 , u_int8_t *buf , u_int32_t len ) ;
static int __ham_vrfy_bucket(DB *dbp___1 , VRFY_DBINFO *vdp , HMETA *m , u_int32_t bucket ,
                             u_int32_t flags ) ;
static int __ham_vrfy_item(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h ,
                           u_int32_t i , u_int32_t flags ) ;
int __ham_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , HMETA *m , db_pgno_t pgno , u_int32_t flags ) 
{ HASH *hashp ;
  VRFY_PAGEINFO *pip ;
  int i ;
  int ret ;
  int t_ret ;
  int isbad ;
  u_int32_t pwr ;
  u_int32_t mbucket ;
  u_int32_t (*hfunc)(DB * , void const   * , u_int32_t  ) ;
  u_int32_t tmp ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___2 ;
  int tmp___3 ;

  {
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  isbad = 0;
  hashp = (HASH *)dbp___1->h_internal;
  if ((unsigned int )hashp != (unsigned int )((void *)0)) {
    if ((unsigned int )hashp->h_hash != (unsigned int )((void *)0)) {
      hfunc = hashp->h_hash;
    } else {
      hfunc = & __ham_func5;
    }
  } else {
    hfunc = & __ham_func5;
  }
  if (! (pip->flags & 32U)) {
    ret = __db_vrfy_meta(dbp___1, vdp, & m->dbmeta, pgno, flags);
    if (ret != 0) {
      if (ret == -30976) {
        isbad = 1;
      } else {
        goto err;
      }
    }
  }
  if (! (flags & 2U)) {
    tmp = ((*hfunc))(dbp___1, (void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
    if (m->h_charkey != tmp) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: database has different custom hash function; reverify with DB_NOORDERCHK set",
                   (unsigned long )pgno);
        }
        break;
      }
      isbad = 1;
      goto err;
    }
  }
  if (m->max_bucket > vdp->last_pgno) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: Impossible max_bucket %lu on meta page",
                 (unsigned long )pgno, (unsigned long )m->max_bucket);
      }
      break;
    }
    isbad = 1;
    goto err;
  }
  if (m->max_bucket == 0U) {
    pwr = 1U;
  } else {
    tmp___1 = __db_log2(m->max_bucket + 1U);
    pwr = (unsigned int )(1 << tmp___1);
  }
  if (m->high_mask != pwr - 1U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: incorrect high_mask %lu, should be %lu",
                 (unsigned long )pgno, (unsigned long )m->high_mask, (unsigned long )pwr -
                                                                     1UL);
      }
      break;
    }
    isbad = 1;
  }
  pwr >>= 1;
  if (m->low_mask != pwr - 1U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: incorrect low_mask %lu, should be %lu",
                 (unsigned long )pgno, (unsigned long )m->low_mask, (unsigned long )pwr -
                                                                    1UL);
      }
      break;
    }
    isbad = 1;
  }
  pip->h_ffactor = m->ffactor;
  if (m->nelem > 2147483648U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: suspiciously high nelem of %lu",
                 (unsigned long )pgno, (unsigned long )m->nelem);
      }
      break;
    }
    isbad = 1;
    pip->h_nelem = 0U;
  } else {
    pip->h_nelem = m->nelem;
  }
  if (m->dbmeta.flags & 1U) {
    pip->flags |= 2U;
  }
  if (m->dbmeta.flags & 4U) {
    pip->flags |= 4U;
  }
  i = 0;
  while (1) {
    if (m->spares[i] != 0U) {
      if (! (i < 32)) {
        break;
      }
    } else {
      break;
    }
    mbucket = (unsigned int )((1 << i) - 1);
    tmp___2 = __db_log2(mbucket + 1U);
    if (mbucket + m->spares[tmp___2] > vdp->last_pgno) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: spares array entry %d is invalid",
                   (unsigned long )pgno, i);
        }
        break;
      }
      isbad = 1;
    }
    i ++;
  }
  err: 
  t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___3 = -30976;
    } else {
      tmp___3 = ret;
    }
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
int __ham_vrfy(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) 
{ VRFY_PAGEINFO *pip ;
  u_int32_t ent ;
  u_int32_t himark ;
  u_int32_t inpend ;
  db_indx_t *inp ;
  int isbad ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fchk(dbp___1->dbenv, "__ham_vrfy", flags, 67U);
  if (ret != 0) {
    goto err;
  }
  if ((int )h->type != 2) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: %s called on nonsensical page of type %lu",
                 (unsigned long )pgno, "__ham_vrfy", (unsigned long )h->type);
      }
      break;
    }
    ret = 22;
    goto err;
  }
  ret = __db_vrfy_datapage(dbp___1, vdp, h, pgno, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  ent = 0U;
  himark = dbp___1->pgsize;
  inpend = (unsigned int )((u_int8_t *)inp - (u_int8_t *)h);
  while (ent < (unsigned int )h->entries) {
    if ((unsigned int )(*(inp + ent)) >= himark) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: item %lu is out of order or nonsensical",
                   (unsigned long )pgno, (unsigned long )ent);
        }
        break;
      }
      isbad = 1;
      goto err;
    } else {
      if (inpend >= himark) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: entries array collided with data",
                     (unsigned long )pgno);
          }
          break;
        }
        isbad = 1;
        goto err;
      } else {
        himark = (unsigned int )(*(inp + ent));
        inpend += sizeof(db_indx_t );
        ret = __ham_vrfy_item(dbp___1, vdp, pgno, h, ent, flags);
        if (ret != 0) {
          goto err;
        }
      }
    }
    ent ++;
  }
  err: 
  t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___1 = -30976;
    } else {
      tmp___1 = ret;
    }
  } else {
    tmp___1 = ret;
  }
  return (tmp___1);
}
}
static int __ham_vrfy_item(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h ,
                           u_int32_t i , u_int32_t flags ) 
{ HOFFPAGE hop ;
  HOFFDUP hod ;
  VRFY_CHILDINFO child ;
  VRFY_PAGEINFO *pip ;
  db_indx_t offset ;
  db_indx_t len ;
  db_indx_t dlen ;
  db_indx_t elen ;
  int ret ;
  int t_ret ;
  u_int8_t *databuf ;
  unsigned int tmp___0 ;
  u_int32_t tmp___3 ;
  unsigned int tmp___5 ;
  unsigned int tmp___7 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;

  {
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  switch ((int )(*((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___0) +
                                            i))))) {
  case 1: ;
  break;
  case 2: ;
  if (i % 2U == 0U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: hash key stored as duplicate item %lu",
                 (unsigned long )pip->pgno, (unsigned long )i);
      }
      break;
    }
  }
  if (i == 0U) {
    tmp___3 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___5 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___5 = sizeof(PG_CHKSUM );
      } else {
        tmp___5 = 0U;
      }
    }
    tmp___3 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___5) + (i -
                                                                                 1U)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___7 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___7 = sizeof(PG_CHKSUM );
    } else {
      tmp___7 = 0U;
    }
  }
  len = (unsigned short )((tmp___3 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                      26) + tmp___7) +
                                                       i))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
  if (dbp___1->flags & 2048U) {
    tmp___9 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___9 = sizeof(PG_CHKSUM );
    } else {
      tmp___9 = 0U;
    }
  }
  databuf = ((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___9) +
                                      i))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
  offset = (unsigned short)0;
  while ((int )offset < (int )len) {
    memcpy((void * __restrict  )(& dlen), (void const   * __restrict  )(databuf +
                                                                        (int )offset),
           sizeof(db_indx_t ));
    if ((unsigned int )offset + ((unsigned int )dlen + 2U * sizeof(db_indx_t )) >
        (unsigned int )len) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: duplicate item %lu has bad length",
                   (unsigned long )pip->pgno, (unsigned long )i);
        }
        break;
      }
      ret = -30976;
      goto err;
    }
    memcpy((void * __restrict  )(& elen), (void const   * __restrict  )(((databuf +
                                                                          (int )offset) +
                                                                         (int )dlen) +
                                                                        sizeof(db_indx_t )),
           sizeof(db_indx_t ));
    if ((int )elen != (int )dlen) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: duplicate item %lu has two different lengths",
                   (unsigned long )pip->pgno, (unsigned long )i);
        }
        break;
      }
      ret = -30976;
      goto err;
    }
    offset = (unsigned short )((unsigned int )offset + ((unsigned int )dlen + 2U *
                                                                              sizeof(db_indx_t )));
  }
  pip->flags |= 2U;
  if (! (flags & 2U)) {
    tmp___10 = __ham_dups_unsorted(dbp___1, databuf, (unsigned int )len);
    if (tmp___10) {
      pip->flags |= 1U;
    }
  }
  break;
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___12 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___12 = sizeof(PG_CHKSUM );
    } else {
      tmp___12 = 0U;
    }
  }
  memcpy((void * __restrict  )(& hop), (void const   * __restrict  )((u_int8_t *)h +
                                                                     (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                             26) +
                                                                                            tmp___12) +
                                                                              i))),
         sizeof(HOFFPAGE ));
  if (! (hop.pgno <= vdp->last_pgno)) {
    goto _L;
  } else {
    if (hop.pgno == pip->pgno) {
      goto _L;
    } else {
      if (hop.pgno == 0U) {
        _L: 
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: offpage item %lu has bad pgno %lu",
                     (unsigned long )pip->pgno, (unsigned long )i, (unsigned long )hop.pgno);
          }
          break;
        }
        ret = -30976;
        goto err;
      }
    }
  }
  memset((void *)(& child), 0, sizeof(VRFY_CHILDINFO ));
  child.pgno = hop.pgno;
  child.type = 2U;
  child.tlen = hop.tlen;
  ret = __db_vrfy_childput(vdp, pip->pgno, & child);
  if (ret != 0) {
    goto err;
  }
  break;
  case 4: ;
  if (dbp___1->flags & 2048U) {
    tmp___14 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___14 = sizeof(PG_CHKSUM );
    } else {
      tmp___14 = 0U;
    }
  }
  memcpy((void * __restrict  )(& hod), (void const   * __restrict  )((u_int8_t *)h +
                                                                     (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                             26) +
                                                                                            tmp___14) +
                                                                              i))),
         sizeof(HOFFDUP ));
  if (! (hod.pgno <= vdp->last_pgno)) {
    goto _L___0;
  } else {
    if (hod.pgno == pip->pgno) {
      goto _L___0;
    } else {
      if (hod.pgno == 0U) {
        _L___0: 
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: offpage item %lu has bad page number",
                     (unsigned long )pip->pgno, (unsigned long )i);
          }
          break;
        }
        ret = -30976;
        goto err;
      }
    }
  }
  memset((void *)(& child), 0, sizeof(VRFY_CHILDINFO ));
  child.pgno = hod.pgno;
  child.type = 1U;
  ret = __db_vrfy_childput(vdp, pip->pgno, & child);
  if (ret != 0) {
    goto err;
  }
  pip->flags |= 2U;
  break;
  default: ;
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: item %lu has bad type",
               (unsigned long )pip->pgno, (unsigned long )i);
    }
    break;
  }
  ret = -30976;
  break;
  }
  err: 
  t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __ham_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t meta_pgno , u_int32_t flags ) 
{ DB *pgset ;
  DB_MPOOLFILE *mpf ;
  HMETA *m ;
  PAGE *h ;
  VRFY_PAGEINFO *pip ;
  int isbad ;
  int p ;
  int ret ;
  int t_ret ;
  db_pgno_t pgno ;
  u_int32_t bucket ;
  u_int32_t spares_entry ;
  u_int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  mpf = dbp___1->mpf;
  pgset = vdp->pgset;
  h = (PAGE *)((void *)0);
  isbad = 0;
  ret = isbad;
  ret = __db_vrfy_pgset_get(pgset, meta_pgno, & p);
  if (ret != 0) {
    return (ret);
  }
  if (p != 0) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: Hash meta page referenced twice",
                 (unsigned long )meta_pgno);
      }
      break;
    }
    return (-30976);
  }
  ret = __db_vrfy_pgset_inc(pgset, meta_pgno);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fget(mpf, & meta_pgno, 0U, (void *)(& m));
  if (ret != 0) {
    return (ret);
  }
  bucket = 0U;
  while (bucket <= m->max_bucket) {
    ret = __ham_vrfy_bucket(dbp___1, vdp, m, bucket, flags);
    if (ret != 0) {
      if (ret == -30976) {
        isbad = 1;
      } else {
        goto err;
      }
    }
    bucket ++;
  }
  bucket = m->max_bucket + 1U;
  while (1) {
    spares_entry = __db_log2(bucket + 1U);
    if (spares_entry < 32U) {
      if (m->spares[spares_entry] != 0U) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    if (! tmp___0) {
      break;
    }
    tmp = __db_log2(bucket + 1U);
    pgno = bucket + m->spares[tmp];
    ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
    if (ret != 0) {
      goto err;
    }
    pip->flags &= 4294967231U;
    if ((int )pip->type == 0) {
      ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
      if (ret != 0) {
        goto err;
      }
      goto __Cont;
    }
    if ((int )pip->type != 2) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: hash bucket %lu maps to non-hash page",
                   (unsigned long )pgno, (unsigned long )bucket);
        }
        break;
      }
      isbad = 1;
    } else {
      if ((int )pip->entries != 0) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: non-empty page in unused hash bucket %lu",
                     (unsigned long )pgno, (unsigned long )bucket);
          }
          break;
        }
        isbad = 1;
      } else {
        ret = __db_vrfy_pgset_get(pgset, pgno, & p);
        if (ret != 0) {
          goto err;
        }
        if (p != 0) {
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: above max_bucket referenced",
                       (unsigned long )pgno);
            }
            break;
          }
          isbad = 1;
        } else {
          ret = __db_vrfy_pgset_inc(pgset, pgno);
          if (ret != 0) {
            goto err;
          }
          ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
          if (ret != 0) {
            goto err;
          }
          goto __Cont;
        }
      }
    }
    __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
    goto err;
    __Cont: 
    bucket ++;
  }
  err: 
  t_ret = __memp_fput(mpf, (void *)m, 0U);
  if (t_ret != 0) {
    return (t_ret);
  }
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      return (t_ret);
    }
  }
  if (isbad == 1) {
    if (ret == 0) {
      tmp___1 = -30976;
    } else {
      tmp___1 = ret;
    }
  } else {
    tmp___1 = ret;
  }
  return (tmp___1);
}
}
static int __ham_vrfy_bucket(DB *dbp___1 , VRFY_DBINFO *vdp , HMETA *m , u_int32_t bucket ,
                             u_int32_t flags ) 
{ HASH *hashp ;
  VRFY_CHILDINFO *child ;
  VRFY_PAGEINFO *mip ;
  VRFY_PAGEINFO *pip ;
  int ret ;
  int t_ret ;
  int isbad ;
  int p ;
  db_pgno_t pgno ;
  db_pgno_t next_pgno ;
  DBC *cc ;
  u_int32_t (*hfunc)(DB * , void const   * , u_int32_t  ) ;
  u_int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  isbad = 0;
  pip = (VRFY_PAGEINFO *)((void *)0);
  cc = (DBC *)((void *)0);
  hashp = (HASH *)dbp___1->h_internal;
  if ((unsigned int )hashp != (unsigned int )((void *)0)) {
    if ((unsigned int )hashp->h_hash != (unsigned int )((void *)0)) {
      hfunc = hashp->h_hash;
    } else {
      hfunc = & __ham_func5;
    }
  } else {
    hfunc = & __ham_func5;
  }
  ret = __db_vrfy_getpageinfo(vdp, ((PAGE *)m)->pgno, & mip);
  if (ret != 0) {
    return (ret);
  }
  tmp = __db_log2(bucket + 1U);
  pgno = bucket + m->spares[tmp];
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    goto err;
  }
  if (pgno > vdp->last_pgno) {
    goto _L;
  } else {
    if ((int )pip->type != 2) {
      _L: 
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: impossible first page in bucket %lu",
                   (unsigned long )pgno, (unsigned long )bucket);
        }
        break;
      }
      isbad = 1;
      goto err;
    }
  }
  if (pip->prev_pgno != 0U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: first page in hash bucket %lu has a prev_pgno",
                 (unsigned long )pgno, (unsigned long )bucket);
      }
      break;
    }
    isbad = 1;
  }
  if (mip->flags & 2U) {
    tmp___0 = 65536;
  } else {
    tmp___0 = 0;
  }
  flags |= (unsigned int )tmp___0;
  if (mip->flags & 4U) {
    tmp___1 = 262144;
  } else {
    tmp___1 = 0;
  }
  flags |= (unsigned int )tmp___1;
  while (1) {
    if (! (flags & 64U)) {
      __db_vrfy_struct_feedback(dbp___1, vdp);
    }
    ret = __db_vrfy_pgset_get(vdp->pgset, pgno, & p);
    if (ret != 0) {
      goto err;
    }
    if (p != 0) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: hash page referenced twice",
                   (unsigned long )pgno);
        }
        break;
      }
      isbad = 1;
      goto err;
    } else {
      ret = __db_vrfy_pgset_inc(vdp->pgset, pgno);
      if (ret != 0) {
        goto err;
      }
    }
    pip->flags &= 4294967231U;
    if (pip->flags & 2U) {
      if (! (mip->flags & 2U)) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: duplicates present in non-duplicate database",
                     (unsigned long )pgno);
          }
          break;
        }
        isbad = 1;
      }
    }
    if (mip->flags & 4U) {
      if (pip->flags & 1U) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: unsorted dups in sorted-dup database",
                     (unsigned long )pgno);
          }
          break;
        }
        isbad = 1;
      }
    }
    ret = __db_vrfy_childcursor(vdp, & cc);
    if (ret != 0) {
      goto err;
    }
    ret = __db_vrfy_ccset(cc, pip->pgno, & child);
    while (ret == 0) {
      if (child->type == 2U) {
        ret = __db_vrfy_ovfl_structure(dbp___1, vdp, child->pgno, child->tlen, flags |
                                                                               1048576U);
        if (ret != 0) {
          if (ret == -30976) {
            isbad = 1;
          } else {
            goto err;
          }
        }
      } else {
        if (child->type == 1U) {
          ret = __db_vrfy_duptype(dbp___1, vdp, child->pgno, flags);
          if (ret != 0) {
            isbad = 1;
            goto __Cont;
          }
          ret = __bam_vrfy_subtree(dbp___1, vdp, child->pgno, (void *)0, (void *)0,
                                   ((flags | 2097152U) | 131072U) | 8388608U, (u_int32_t *)((void *)0),
                                   (u_int32_t *)((void *)0), (u_int32_t *)((void *)0));
          if (ret != 0) {
            if (ret == -30976) {
              isbad = 1;
            } else {
              goto err;
            }
          }
        }
      }
      __Cont: 
      ret = __db_vrfy_ccnext(cc, & child);
    }
    ret = __db_vrfy_ccclose(cc);
    if (ret != 0) {
      goto err;
    }
    cc = (DBC *)((void *)0);
    if (isbad == 0) {
      if (! (flags & 2U)) {
        ret = __ham_vrfy_hashing(dbp___1, (unsigned int )pip->entries, m, bucket,
                                 pgno, flags, hfunc);
        if (ret != 0) {
          if (ret == -30976) {
            isbad = 1;
          } else {
            goto err;
          }
        }
      }
    }
    next_pgno = pip->next_pgno;
    ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
    pip = (VRFY_PAGEINFO *)((void *)0);
    if (ret != 0) {
      goto err;
    }
    if (next_pgno == 0U) {
      break;
    }
    if (! (next_pgno <= vdp->last_pgno)) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: hash page has bad next_pgno",
                   (unsigned long )pgno);
        }
        break;
      }
      isbad = 1;
      goto err;
    }
    ret = __db_vrfy_getpageinfo(vdp, next_pgno, & pip);
    if (ret != 0) {
      goto err;
    }
    if (pip->prev_pgno != pgno) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: hash page has bad prev_pgno",
                   (unsigned long )next_pgno);
        }
        break;
      }
      isbad = 1;
    }
    pgno = next_pgno;
  }
  err: 
  if ((unsigned int )cc != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_ccclose(cc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )mip != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, mip);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )pip != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___2 = -30976;
    } else {
      tmp___2 = ret;
    }
  } else {
    tmp___2 = ret;
  }
  return (tmp___2);
}
}
int __ham_vrfy_hashing(DB *dbp___1 , u_int32_t nentries , HMETA *m , u_int32_t thisbucket ,
                       db_pgno_t pgno , u_int32_t flags , u_int32_t (*hfunc)(DB * ,
                                                                             void const   * ,
                                                                             u_int32_t  ) ) 
{ DBT dbt ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_indx_t i ;
  int ret ;
  int t_ret ;
  int isbad ;
  u_int32_t hval ;
  u_int32_t bucket ;
  int tmp ;

  {
  mpf = dbp___1->mpf;
  isbad = 0;
  ret = isbad;
  memset((void *)(& dbt), 0, sizeof(DBT ));
  dbt.flags = dbt.flags | 16U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  i = (unsigned short)0;
  while ((unsigned int )i < nentries) {
    ret = __db_ret(dbp___1, h, (unsigned int )i, & dbt, (void **)((void *)0), (u_int32_t *)((void *)0));
    if (ret != 0) {
      goto err;
    }
    hval = ((*hfunc))(dbp___1, (void const   *)dbt.data, dbt.size);
    bucket = hval & m->high_mask;
    if (bucket > m->max_bucket) {
      bucket = bucket & m->low_mask;
    }
    if (bucket != thisbucket) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: item %lu hashes incorrectly",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      isbad = 1;
    }
    i = (unsigned short )((int )i + 2);
  }
  err: 
  if ((unsigned int )dbt.data != (unsigned int )((void *)0)) {
    __os_ufree(dbp___1->dbenv, dbt.data);
  }
  t_ret = __memp_fput(mpf, (void *)h, 0U);
  if (t_ret != 0) {
    return (t_ret);
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp = -30976;
    } else {
      tmp = ret;
    }
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
int __ham_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h , void *handle ,
                  int (*callback)(void * , void const   * ) , u_int32_t flags ) 
{ DBT dbt ;
  DBT unkdbt ;
  db_pgno_t dpgno ;
  int ret ;
  int err_ret ;
  int t_ret ;
  u_int32_t himark ;
  u_int32_t tlen ;
  u_int8_t *hk ;
  void *buf ;
  u_int32_t dlen ;
  u_int32_t len ;
  u_int32_t i ;
  size_t tmp ;
  unsigned int tmp___1 ;
  u_int32_t tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
  memset((void *)(& dbt), 0, sizeof(DBT ));
  dbt.flags = 16U;
  memset((void *)(& unkdbt), 0, sizeof(DBT ));
  tmp = strlen("UNKNOWN");
  unkdbt.size = tmp + 1U;
  unkdbt.data = (void *)"UNKNOWN";
  err_ret = 0;
  ret = __os_malloc(dbp___1->dbenv, dbp___1->pgsize, (void *)(& buf));
  if (ret != 0) {
    return (ret);
  }
  himark = dbp___1->pgsize;
  i = 0U;
  while (1) {
    if (! (flags & 1U)) {
      if (i >= (unsigned int )h->entries) {
        break;
      }
    }
    ret = __db_vrfy_inpitem(dbp___1, h, pgno, i, 0, flags, & himark, (u_int32_t *)((void *)0));
    if (ret == -30891) {
      break;
    }
    if (ret == 0) {
      if (dbp___1->flags & 2048U) {
        tmp___1 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___1 = sizeof(PG_CHKSUM );
        } else {
          tmp___1 = 0U;
        }
      }
      hk = (u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___1) +
                                    i));
      if (i == 0U) {
        tmp___4 = dbp___1->pgsize;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___6 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___6 = sizeof(PG_CHKSUM );
          } else {
            tmp___6 = 0U;
          }
        }
        tmp___4 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___6) +
                                    (i - 1U)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___8 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___8 = sizeof(PG_CHKSUM );
        } else {
          tmp___8 = 0U;
        }
      }
      len = (unsigned int )((unsigned short )((tmp___4 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                          26) +
                                                                                         tmp___8) +
                                                                           i))) -
                                              (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
      if ((unsigned int )((hk + len) - (u_int8_t *)h) > dbp___1->pgsize) {
        if (! (flags & 1U)) {
          goto __Cont;
        }
        len = dbp___1->pgsize - (unsigned int )(hk - (u_int8_t *)h);
        err_ret = -30976;
      }
      switch ((int )(*hk)) {
      default: ;
      if (! (flags & 1U)) {
        break;
      }
      err_ret = -30976;
      case 1: ;
      keydata: 
      memcpy((void * __restrict  )buf, (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))),
             len);
      dbt.size = len;
      dbt.data = buf;
      ret = __db_prdbt(& dbt, 0, " ", handle, callback, 0, vdp);
      if (ret != 0) {
        err_ret = ret;
      }
      break;
      case 3: ;
      if (len < sizeof(HOFFPAGE )) {
        err_ret = -30976;
        goto __Cont;
      }
      memcpy((void * __restrict  )(& dpgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
             sizeof(dpgno));
      ret = __db_safe_goff(dbp___1, vdp, dpgno, & dbt, (void *)(& buf), flags);
      if (ret != 0) {
        err_ret = ret;
        __db_prdbt(& unkdbt, 0, " ", handle, callback, 0, vdp);
        break;
      }
      ret = __db_prdbt(& dbt, 0, " ", handle, callback, 0, vdp);
      if (ret != 0) {
        err_ret = ret;
      }
      break;
      case 4: ;
      if (len < sizeof(HOFFPAGE )) {
        err_ret = -30976;
        goto __Cont;
      }
      memcpy((void * __restrict  )(& dpgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)))),
             sizeof(dpgno));
      if (! (dpgno <= vdp->last_pgno)) {
        goto _L;
      } else {
        if (i % 2U == 0U) {
          _L: 
          ret = __db_prdbt(& unkdbt, 0, " ", handle, callback, 0, vdp);
          if (ret != 0) {
            err_ret = ret;
          }
        } else {
          ret = __db_salvage_duptree(dbp___1, vdp, dpgno, & dbt, handle, callback,
                                     flags | 524288U);
          if (ret != 0) {
            err_ret = ret;
          }
        }
      }
      break;
      case 2: ;
      if (i % 2U == 0U) {
        err_ret = ret;
        if (flags & 1U) {
          goto keydata;
        }
        break;
      }
      if (len < 2U * sizeof(db_indx_t ) + (unsigned int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) {
        err_ret = -30976;
        goto __Cont;
      }
      tlen = 0U;
      while (tlen + sizeof(db_indx_t ) < len) {
        tlen += sizeof(db_indx_t );
        memcpy((void * __restrict  )(& dlen), (void const   * __restrict  )hk, sizeof(db_indx_t ));
        if (dlen + tlen > len) {
          dlen = len - tlen;
        }
        memcpy((void * __restrict  )buf, (void const   * __restrict  )(hk + tlen),
               dlen);
        dbt.size = dlen;
        dbt.data = buf;
        ret = __db_prdbt(& dbt, 0, " ", handle, callback, 0, vdp);
        if (ret != 0) {
          err_ret = ret;
        }
        tlen += sizeof(db_indx_t );
        tlen += dlen;
      }
      break;
      }
    }
    __Cont: 
    i ++;
  }
  __os_free(dbp___1->dbenv, buf);
  t_ret = __db_salvage_markdone(vdp, pgno);
  if (t_ret != 0) {
    return (t_ret);
  }
  if (ret == 0) {
    if (err_ret != 0) {
      tmp___9 = err_ret;
    } else {
      tmp___9 = ret;
    }
  } else {
    tmp___9 = ret;
  }
  return (tmp___9);
}
}
int __ham_meta2pgset(DB *dbp___1 , VRFY_DBINFO *vdp , HMETA *hmeta , u_int32_t flags ,
                     DB *pgset ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t pgno ;
  u_int32_t bucket ;
  u_int32_t totpgs ;
  int ret ;
  int val ;
  u_int32_t tmp ;

  {
  flags = 0U;
  flags = flags;
  mpf = dbp___1->mpf;
  totpgs = 0U;
  bucket = 0U;
  while (bucket <= hmeta->max_bucket) {
    tmp = __db_log2(bucket + 1U);
    pgno = bucket + hmeta->spares[tmp];
    while (1) {
      ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
      if (ret != 0) {
        return (ret);
      }
      if ((int )h->type == 2) {
        totpgs ++;
        if (totpgs > vdp->last_pgno) {
          __memp_fput(mpf, (void *)h, 0U);
          return (-30976);
        }
        ret = __db_vrfy_pgset_inc(pgset, pgno);
        if (ret != 0) {
          __memp_fput(mpf, (void *)h, 0U);
          return (ret);
        }
        pgno = h->next_pgno;
      } else {
        pgno = 0U;
      }
      ret = __memp_fput(mpf, (void *)h, 0U);
      if (ret != 0) {
        return (ret);
      }
      if (! (pgno <= vdp->last_pgno)) {
        break;
      } else {
        if (pgno == 0U) {
          break;
        }
      }
      ret = __db_vrfy_pgset_get(pgset, pgno, & val);
      if (ret != 0) {
        return (ret);
      }
      if (val != 0) {
        break;
      }
    }
    bucket ++;
  }
  return (0);
}
}
static int __ham_dups_unsorted(DB *dbp___1 , u_int8_t *buf , u_int32_t len ) 
{ DBT a ;
  DBT b ;
  db_indx_t offset ;
  db_indx_t dlen ;
  int (*func)(DB * , DBT const   * , DBT const   * ) ;
  int tmp ;

  {
  memset((void *)(& a), 0, sizeof(DBT ));
  memset((void *)(& b), 0, sizeof(DBT ));
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    func = & __bam_defcmp;
  } else {
    func = dbp___1->dup_compare;
  }
  offset = (unsigned short)0;
  while ((unsigned int )offset < len) {
    memcpy((void * __restrict  )(& dlen), (void const   * __restrict  )(buf + (int )offset),
           sizeof(db_indx_t ));
    b.data = (void *)((buf + (int )offset) + sizeof(db_indx_t ));
    b.size = (unsigned int )dlen;
    if ((unsigned int )a.data != (unsigned int )((void *)0)) {
      tmp = ((*func))(dbp___1, (DBT const   *)(& a), (DBT const   *)(& b));
      if (tmp > 0) {
        return (1);
      }
    }
    a.data = b.data;
    a.size = b.size;
    offset = (unsigned short )((unsigned int )offset + ((unsigned int )dlen + 2U *
                                                                              sizeof(db_indx_t )));
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-kQJMrtRa.i","-O2")
int __db_panic_msg(DB_ENV *dbenv___0 ) ;
int __db_c_idup(DBC *dbc_orig , DBC **dbcp , u_int32_t flags ) ;
int __db_c_del_primary(DBC *dbc ) ;
int __qam_position(DBC *dbc , db_recno_t *recnop , qam_position_mode mode , int *exactp ) ;
int __qam_pitem(DBC *dbc , QPAGE *pagep , u_int32_t indx , db_recno_t recno , DBT *data ) ;
int __qam_append(DBC *dbc , DBT *key , DBT *data ) ;
int __qam_c_dup(DBC *orig_dbc , DBC *new_dbc ) ;
int __qam_c_init(DBC *dbc ) ;
int __qam_truncate(DBC *dbc , u_int32_t *countp ) ;
int __qam_incfirst_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                       db_recno_t recno , db_pgno_t meta_pgno ) ;
int __qam_mvptr_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , db_recno_t old_first , db_recno_t new_first ,
                    db_recno_t old_cur , db_recno_t new_cur , DB_LSN *metalsn , db_pgno_t meta_pgno ) ;
int __qam_del_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  DB_LSN *lsn , db_pgno_t pgno , u_int32_t indx , db_recno_t recno ) ;
int __qam_add_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  DB_LSN *lsn , db_pgno_t pgno , u_int32_t indx , db_recno_t recno ,
                  DBT const   *data , u_int32_t vflag , DBT const   *olddata ) ;
int __qam_delext_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DB_LSN *lsn , db_pgno_t pgno , u_int32_t indx , db_recno_t recno ,
                     DBT const   *data ) ;
int __qam_fprobe(DB *dbp___1 , db_pgno_t pgno , void *addrp , qam_probe_mode mode ,
                 u_int32_t flags ) ;
int __qam_fclose(DB *dbp___1 , db_pgno_t pgnoaddr ) ;
int __qam_fremove(DB *dbp___1 , db_pgno_t pgnoaddr ) ;
static int __qam_bulk(DBC *dbc , DBT *data , u_int32_t flags ) ;
static int __qam_c_close(DBC *dbc , db_pgno_t root_pgno , int *rmroot ) ;
static int __qam_c_del(DBC *dbc ) ;
static int __qam_c_destroy(DBC *dbc ) ;
static int __qam_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
static int __qam_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) ;
static int __qam_consume(DBC *dbc , QMETA *meta , db_recno_t first ) ;
static int __qam_getno(DB *dbp___1 , DBT const   *key , db_recno_t *rep ) ;
int __qam_position(DBC *dbc , db_recno_t *recnop , qam_position_mode mode , int *exactp ) 
{ QUEUE_CURSOR *cp ;
  DB *dbp___1 ;
  QAMDATA *qp ;
  db_pgno_t pg ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  cp = (QUEUE_CURSOR *)dbc->internal;
  pg = ((QUEUE *)dbp___1->q_internal)->q_root + ((*recnop) - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  if ((int )mode == 0) {
    tmp = 1;
  } else {
    tmp = 2;
  }
  ret = __db_lget(dbc, 0, pg, (enum __anonenum_db_lockmode_t_50 )tmp, 0U, & cp->lock);
  if (ret != 0) {
    return (ret);
  }
  cp->page = (void *)0;
  (*exactp) = 0;
  if ((int )mode == 1) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  ret = __qam_fprobe(dbp___1, pg, (void *)(& cp->page), (enum __anonenum_qam_probe_mode_80 )0,
                     (unsigned int )tmp___0);
  if (ret != 0) {
    if (cp->lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & cp->lock);
    }
    if ((int )mode != 1) {
      if (ret == -30988) {
        return (0);
      } else {
        if (ret == 2) {
          return (0);
        }
      }
    }
    return (ret);
  }
  cp->pgno = pg;
  cp->indx = (unsigned short )(((*recnop) - 1U) - ((QUEUE *)dbp___1->q_internal)->rec_page *
                                                  (pg - ((QUEUE *)dbp___1->q_internal)->q_root));
  if (((PAGE *)cp->page)->pgno == 0U) {
    if (dbp___1->flags & 524288U) {
      (*exactp) = 0;
      return (0);
    }
    ((PAGE *)cp->page)->pgno = pg;
    ((PAGE *)cp->page)->type = (unsigned char)11;
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = 48;
    } else {
      tmp___2 = 28;
    }
  }
  qp = (QAMDATA *)((u_int8_t *)cp->page + ((unsigned long long )tmp___2 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                              (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                             (unsigned long long )sizeof(u_int32_t )) -
                                                                            1ULL) &
                                                                           ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                              1ULL)) *
                                                                          (unsigned long long )cp->indx));
  if ((int )qp->flags & 1) {
    (*exactp) = 1;
  } else {
    (*exactp) = 0;
  }
  return (ret);
}
}
int __qam_pitem(DBC *dbc , QPAGE *pagep , u_int32_t indx , db_recno_t recno , DBT *data ) 
{ DB_ENV *dbenv___0 ;
  DB *dbp___1 ;
  DBT olddata ;
  DBT pdata ;
  DBT *datap ;
  QAMDATA *qp ;
  QUEUE *t ;
  u_int8_t *dest ;
  u_int8_t *p ;
  int alloced ;
  int ret ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  DBT *tmp___3 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  t = (QUEUE *)dbp___1->q_internal;
  ret = 0;
  alloced = ret;
  if (data->size > t->re_len) {
    tmp = __db_rec_toobig(dbenv___0, data->size, t->re_len);
    return (tmp);
  }
  if (dbp___1->flags & 2048U) {
    tmp___1 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = 48;
    } else {
      tmp___1 = 28;
    }
  }
  qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___1 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                           (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                          (unsigned long long )sizeof(u_int32_t )) -
                                                                         1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL)) *
                                                                       (unsigned long long )indx));
  p = qp->data;
  datap = data;
  if (data->flags & 8U) {
    if (data->doff + data->dlen > t->re_len) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: data offset plus length larger than record size of %lu",
               "Record length error", (unsigned long )t->re_len);
      return (22);
    }
    if (data->size != data->dlen) {
      tmp___2 = __db_rec_repl(dbenv___0, data->size, data->dlen);
      return (tmp___2);
    }
    if (data->size == t->re_len) {
      goto no_partial;
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___2;
              } else {
                goto _L;
              }
            } else {
              goto _L;
            }
          } else {
            goto _L;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if (! ((int )qp->flags & 1)) {
        _L: 
        datap = & pdata;
        memset((void *)datap, 0, sizeof((*datap)));
        ret = __os_malloc(dbenv___0, t->re_len, (void *)(& datap->data));
        if (ret != 0) {
          return (ret);
        }
        alloced = 1;
        datap->size = t->re_len;
        dest = (u_int8_t *)datap->data;
        if ((int )qp->flags & 1) {
          memcpy((void * __restrict  )dest, (void const   * __restrict  )p, t->re_len);
        } else {
          memset((void *)dest, t->re_pad, t->re_len);
        }
        dest += data->doff;
        memcpy((void * __restrict  )dest, (void const   * __restrict  )data->data,
               data->size);
      } else {
        datap = data;
        p += data->doff;
      }
    }
  }
  no_partial: 
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                   516U)) {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          olddata.size = 0U;
          if ((int )qp->flags & 2) {
            olddata.data = (void *)(qp->data);
            olddata.size = t->re_len;
          }
          if (olddata.size == 0U) {
            tmp___3 = (DBT *)((void *)0);
          } else {
            tmp___3 = & olddata;
          }
          ret = __qam_add_log(dbp___1, dbc->txn, & ((PAGE *)pagep)->lsn, 0U, & ((PAGE *)pagep)->lsn,
                              pagep->pgno, indx, recno, (DBT const   *)datap, (unsigned int )qp->flags,
                              (DBT const   *)tmp___3);
          if (ret != 0) {
            goto err;
          }
        }
      }
    }
  }
  qp->flags = (unsigned char )((int )qp->flags | 3);
  memcpy((void * __restrict  )p, (void const   * __restrict  )datap->data, datap->size);
  if (! (data->flags & 8U)) {
    memset((void *)(p + datap->size), t->re_pad, t->re_len - datap->size);
  }
  err: 
  if (alloced) {
    __os_free(dbenv___0, datap->data);
  }
  return (ret);
}
}
static int __qam_c_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  QMETA *meta ;
  QUEUE_CURSOR *cp ;
  db_pgno_t pg ;
  db_recno_t new_cur ;
  db_recno_t new_first ;
  u_int32_t opcode ;
  int exact ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if ((unsigned int )pgnop != (unsigned int )((void *)0)) {
    (*pgnop) = 0U;
  }
  cp = (QUEUE_CURSOR *)dbc->internal;
  switch ((int )flags) {
  case 15: ;
  case 16: 
  ret = __qam_getno(dbp___1, (DBT const   *)key, & cp->recno);
  if (ret != 0) {
    return (ret);
  }
  case 7: ;
  break;
  default: 
  tmp = __db_ferr((DB_ENV const   *)dbp___1->dbenv, "__qam_c_put", (int )flags);
  return (tmp);
  }
  ret = __db_lget(dbc, 0, cp->recno, (enum __anonenum_db_lockmode_t_50 )2, 2U, & lock);
  if (ret != 0) {
    return (ret);
  }
  ret = __qam_position(dbc, & cp->recno, (enum __anonenum_qam_position_mode_79 )1,
                       & exact);
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    return (ret);
  }
  ret = __qam_pitem(dbc, (QPAGE *)cp->page, (unsigned int )cp->indx, cp->recno, data);
  if (cp->lock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & cp->lock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                       2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  cp->page = (void *)0;
  cp->lock = lock;
  cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  if (ret != 0) {
    return (ret);
  }
  pg = ((QUEUE *)dbp___1->q_internal)->q_meta;
  ret = __memp_fget(mpf, & pg, 0U, (void *)(& meta));
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, pg, (enum __anonenum_db_lockmode_t_50 )2, 0U, & lock);
  if (ret != 0) {
    __memp_fput(mpf, (void *)meta, 0U);
    return (ret);
  }
  opcode = 0U;
  new_first = 0U;
  new_cur = new_first;
  if (meta->first_recno == meta->cur_recno) {
    new_first = cp->recno;
    new_cur = cp->recno + 1U;
    if (new_cur == 0U) {
      new_cur ++;
    }
    opcode |= 1U;
    opcode |= 2U;
  } else {
    if (cp->recno < meta->first_recno) {
      if (meta->first_recno <= meta->cur_recno) {
        goto _L;
      } else {
        if (cp->recno > meta->cur_recno) {
          if (cp->recno - meta->cur_recno > meta->first_recno - cp->recno) {
            _L: 
            if (meta->first_recno <= meta->cur_recno) {
              new_first = cp->recno;
              opcode |= 1U;
            } else {
              if (meta->first_recno - cp->recno < cp->recno - meta->cur_recno) {
                new_first = cp->recno;
                opcode |= 1U;
              }
            }
          }
        }
      }
    }
    if (meta->cur_recno == cp->recno) {
      goto _L___1;
    } else {
      if (cp->recno > meta->cur_recno) {
        if (meta->first_recno <= meta->cur_recno) {
          goto _L___2;
        } else {
          if (cp->recno < meta->first_recno) {
            if (cp->recno - meta->cur_recno < meta->first_recno - cp->recno) {
              _L___2: 
              if (meta->first_recno <= meta->cur_recno) {
                goto _L___1;
              } else {
                if (cp->recno - meta->cur_recno <= meta->first_recno - cp->recno) {
                  _L___1: 
                  new_cur = cp->recno + 1U;
                  if (new_cur == 0U) {
                    new_cur ++;
                  }
                  opcode |= 2U;
                }
              }
            }
          }
        }
      }
    }
  }
  if (opcode != 0U) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            _L___4: 
            ret = __qam_mvptr_log(dbp___1, dbc->txn, & meta->dbmeta.lsn, 0U, opcode,
                                  meta->first_recno, new_first, meta->cur_recno, new_cur,
                                  & meta->dbmeta.lsn, 0U);
            if (ret != 0) {
              opcode = 0U;
            }
          }
        }
      }
    }
  }
  if (opcode & 2U) {
    meta->cur_recno = new_cur;
  }
  if (opcode & 1U) {
    meta->first_recno = new_first;
  }
  if (opcode != 0U) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  t_ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___1);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (lock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & lock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __qam_append(DBC *dbc , DBT *key , DBT *data ) 
{ DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  QMETA *meta ;
  QPAGE *page ;
  QUEUE *qp ;
  QUEUE_CURSOR *cp ;
  db_pgno_t pg ;
  db_recno_t recno ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (QUEUE_CURSOR *)dbc->internal;
  pg = ((QUEUE *)dbp___1->q_internal)->q_meta;
  ret = __memp_fget(mpf, & pg, 0U, (void *)(& meta));
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, pg, (enum __anonenum_db_lockmode_t_50 )2, 0U, & lock);
  if (ret != 0) {
    __memp_fput(mpf, (void *)meta, 0U);
    return (ret);
  }
  recno = meta->cur_recno;
  meta->cur_recno ++;
  if (meta->cur_recno == 0U) {
    meta->cur_recno ++;
  }
  if (meta->cur_recno == meta->first_recno) {
    meta->cur_recno --;
    if (meta->cur_recno == 0U) {
      meta->cur_recno --;
    }
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    ret = 27;
    goto err;
  }
  if (recno < meta->first_recno) {
    if (meta->first_recno <= meta->cur_recno) {
      meta->first_recno = recno;
    } else {
      if (recno > meta->cur_recno) {
        if (recno - meta->cur_recno > meta->first_recno - recno) {
          meta->first_recno = recno;
        }
      }
    }
  }
  ret = __db_lget(dbc, 3, recno, (enum __anonenum_db_lockmode_t_50 )2, 2U, & lock);
  if ((unsigned int )(dbc->dbp)->db_append_recno != (unsigned int )((void *)0)) {
    t_ret = ((*((dbc->dbp)->db_append_recno)))(dbc->dbp, data, recno);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    goto err;
  }
  cp->lock = lock;
  cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  pg = ((QUEUE *)dbp___1->q_internal)->q_root + (recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  ret = __db_lget(dbc, 0, pg, (enum __anonenum_db_lockmode_t_50 )2, 0U, & lock);
  if (ret != 0) {
    goto err;
  }
  ret = __qam_fprobe(dbp___1, pg, (void *)(& page), (enum __anonenum_qam_probe_mode_80 )0,
                     1U);
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    goto err;
  }
  if (page->pgno == 0U) {
    page->pgno = pg;
    page->type = (unsigned char)11;
  }
  ret = __qam_pitem(dbc, page, (recno - 1U) - ((QUEUE *)dbp___1->q_internal)->rec_page *
                                              (pg - ((QUEUE *)dbp___1->q_internal)->q_root),
                    recno, data);
  if (lock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & lock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __qam_fprobe(dbp___1, pg, (void *)page, (enum __anonenum_qam_probe_mode_80 )1,
                       2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    ret = __db_retcopy(dbp___1->dbenv, key, (void *)(& recno), sizeof(recno), & (dbc->rkey)->data,
                       & (dbc->rkey)->ulen);
  }
  cp->recno = recno;
  qp = (QUEUE *)dbp___1->q_internal;
  if (qp->page_ext != 0U) {
    if (recno % (qp->page_ext * qp->rec_page) == 0U) {
      goto _L;
    } else {
      if (recno == 4294967295U) {
        _L: 
        ret = __db_lget(dbc, 0, ((QUEUE *)dbp___1->q_internal)->q_meta, (enum __anonenum_db_lockmode_t_50 )2,
                        0U, & lock);
        if (ret != 0) {
          goto err;
        }
        if (recno > meta->cur_recno) {
          if (! (meta->first_recno <= meta->cur_recno)) {
            if (recno < meta->first_recno) {
              if (! (recno - meta->cur_recno < meta->first_recno - recno)) {
                ret = __qam_fclose(dbp___1, pg);
              }
            } else {
              ret = __qam_fclose(dbp___1, pg);
            }
          }
        } else {
          ret = __qam_fclose(dbp___1, pg);
        }
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
      }
    }
  }
  err: 
  t_ret = __memp_fput(mpf, (void *)meta, 2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __qam_c_del(DBC *dbc ) 
{ DB *dbp___1 ;
  DBT data ;
  DB_LOCK lock ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  QAMDATA *qp ;
  QMETA *meta ;
  QUEUE_CURSOR *cp ;
  db_pgno_t pg ;
  db_recno_t first ;
  int exact ;
  int ret ;
  int t_ret ;
  int tmp___1 ;
  int tmp___3 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (QUEUE_CURSOR *)dbc->internal;
  pg = ((QUEUE *)dbp___1->q_internal)->q_meta;
  ret = __memp_fget(mpf, & pg, 0U, (void *)(& meta));
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, pg, (enum __anonenum_db_lockmode_t_50 )1, 0U, & metalock);
  if (ret != 0) {
    __memp_fput(mpf, (void *)meta, 0U);
    return (ret);
  }
  if (cp->recno == 0U) {
    ret = -30990;
  } else {
    if (cp->recno < meta->first_recno) {
      if (meta->first_recno <= meta->cur_recno) {
        ret = -30990;
      } else {
        if (cp->recno > meta->cur_recno) {
          if (cp->recno - meta->cur_recno > meta->first_recno - cp->recno) {
            ret = -30990;
          } else {
            goto _L;
          }
        } else {
          goto _L;
        }
      }
    } else {
      _L: 
      if (cp->recno > meta->cur_recno) {
        if (meta->first_recno <= meta->cur_recno) {
          ret = -30990;
        } else {
          if (cp->recno < meta->first_recno) {
            if (cp->recno - meta->cur_recno < meta->first_recno - cp->recno) {
              ret = -30990;
            }
          }
        }
      }
    }
  }
  first = meta->first_recno;
  if (metalock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret != 0) {
    goto err1;
  }
  ret = __db_lget(dbc, 0, cp->recno, (enum __anonenum_db_lockmode_t_50 )2, 2U, & lock);
  if (ret != 0) {
    goto err1;
  }
  cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
  ret = __qam_position(dbc, & cp->recno, (enum __anonenum_qam_position_mode_79 )1,
                       & exact);
  if (ret != 0) {
    cp->lock = lock;
    goto err1;
  }
  if (! exact) {
    ret = -30990;
    goto err1;
  }
  pagep = (PAGE *)cp->page;
  if (dbp___1->flags & 2048U) {
    tmp___1 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = 48;
    } else {
      tmp___1 = 28;
    }
  }
  qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___1 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                           (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                          (unsigned long long )sizeof(u_int32_t )) -
                                                                         1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL)) *
                                                                       (unsigned long long )cp->indx));
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                   516U)) {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          if (((QUEUE *)dbp___1->q_internal)->page_ext == 0U) {
            goto _L___0;
          } else {
            if (((QUEUE *)dbp___1->q_internal)->re_len == 0U) {
              _L___0: 
              ret = __qam_del_log(dbp___1, dbc->txn, & pagep->lsn, 0U, & pagep->lsn,
                                  pagep->pgno, (unsigned int )cp->indx, cp->recno);
              if (ret != 0) {
                goto err1;
              }
            } else {
              data.size = ((QUEUE *)dbp___1->q_internal)->re_len;
              data.data = (void *)(qp->data);
              ret = __qam_delext_log(dbp___1, dbc->txn, & pagep->lsn, 0U, & pagep->lsn,
                                     pagep->pgno, (unsigned int )cp->indx, cp->recno,
                                     (DBT const   *)(& data));
              if (ret != 0) {
                goto err1;
              }
            }
          }
        }
      }
    }
  }
  qp->flags = (unsigned char )((int )qp->flags & -2);
  if (cp->recno == first) {
    pg = ((QUEUE *)dbp___1->q_internal)->q_meta;
    ret = __db_lget(dbc, 0, pg, (enum __anonenum_db_lockmode_t_50 )2, 0U, & metalock);
    if (ret != 0) {
      goto err1;
    }
    ret = __qam_consume(dbc, meta, first);
    if (metalock.off != 0U) {
      t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
    } else {
      t_ret = 0;
    }
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  err1: 
  t_ret = __memp_fput(mpf, (void *)meta, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
    if (ret == 0) {
      tmp___3 = 2;
    } else {
      tmp___3 = 0;
    }
    t_ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                         (unsigned int )tmp___3);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  cp->page = (void *)0;
  if (cp->lock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & cp->lock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  cp->lock = lock;
  return (ret);
}
}
static int __qam_c_get(DBC *dbc , DBT *key , DBT *data , u_int32_t flags , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  DBC *dbcdup ;
  DBT tmp ;
  DB_ENV *dbenv___0 ;
  DB_LOCK lock ;
  DB_LOCK pglock ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  PAGE *pg ;
  QAMDATA *qp ;
  QMETA *meta ;
  QUEUE *t ;
  QUEUE_CURSOR *cp ;
  db_lockmode_t lock_mode ;
  db_pgno_t metapno ;
  db_recno_t first ;
  qam_position_mode mode ;
  int exact ;
  int is_first ;
  int locked ;
  int ret ;
  int t_ret ;
  int wait ;
  int with_delete ;
  int put_mode ;
  int retrying ;
  int tmp___0 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;
  int tmp___6 ;
  int tmp___11 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  cp = (QUEUE_CURSOR *)dbc->internal;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp___0 = __db_panic_msg(dbenv___0);
        return (tmp___0);
      }
    }
  }
  wait = 0;
  with_delete = 0;
  retrying = 0;
  lock_mode = (enum __anonenum_db_lockmode_t_50 )1;
  meta = (QMETA *)((void *)0);
  put_mode = 0;
  t_ret = 0;
  (*pgnop) = 0U;
  pg = (PAGE *)((void *)0);
  mode = (enum __anonenum_qam_position_mode_79 )0;
  if (dbc->flags & 32U) {
    lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
    mode = (enum __anonenum_qam_position_mode_79 )1;
  }
  if (flags == 6U) {
    wait = 1;
    flags = 5U;
  }
  if (flags == 5U) {
    with_delete = 1;
    flags = 9U;
    lock_mode = (enum __anonenum_db_lockmode_t_50 )2;
    mode = (enum __anonenum_qam_position_mode_79 )2;
  }
  locked = 0;
  is_first = 0;
  t = (QUEUE *)dbp___1->q_internal;
  metapno = t->q_meta;
  ret = __memp_fget(mpf, & metapno, 0U, (void *)(& meta));
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, metapno, lock_mode, 0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  locked = 1;
  first = 0U;
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  retry: 
  switch ((int )flags) {
  case 7: ;
  break;
  case 19: 
  ret = -30990;
  goto err;
  case 18: ;
  case 20: ;
  if (cp->recno != 0U) {
    cp->recno ++;
    if (cp->recno == 0U) {
      cp->recno ++;
    }
    if (cp->recno == meta->cur_recno) {
      goto _L___0;
    } else {
      if (cp->recno > meta->cur_recno) {
        if (meta->first_recno <= meta->cur_recno) {
          goto _L___0;
        } else {
          if (cp->recno < meta->first_recno) {
            if (cp->recno - meta->cur_recno < meta->first_recno - cp->recno) {
              _L___0: 
              pg = (PAGE *)((void *)0);
              if (! wait) {
                ret = -30990;
                goto err;
              }
              flags = 9U;
              if (first == 0U) {
                retrying = 1;
                goto retry;
              }
              if (dbenv___0->flags & 2U) {
                ret = __memp_fput(mpf, (void *)meta, 0U);
                if (ret != 0) {
                  goto err;
                }
                meta = (QMETA *)((void *)0);
                ret = __lock_get(dbenv___0, dbc->locker, 16U, (DBT const   *)(& dbc->lock_dbt),
                                 (enum __anonenum_db_lockmode_t_50 )3, & dbc->mylock);
                if (ret != 0) {
                  goto err;
                }
                ret = __memp_fget(mpf, & metapno, 0U, (void *)(& meta));
                if (ret != 0) {
                  goto err;
                }
                ret = __lock_get(dbenv___0, dbc->locker, 32U, (DBT const   *)(& dbc->lock_dbt),
                                 (enum __anonenum_db_lockmode_t_50 )2, & dbc->mylock);
                if (ret != 0) {
                  goto err;
                }
                goto retry;
              }
              if (locked == 0) {
                ret = __db_lget(dbc, 0, metapno, lock_mode, 0U, & metalock);
                if (ret != 0) {
                  goto err;
                }
                locked = 1;
                if (cp->recno != 0U) {
                  if (cp->recno > meta->cur_recno) {
                    if (! (meta->first_recno <= meta->cur_recno)) {
                      if (cp->recno < meta->first_recno) {
                        if (! (cp->recno - meta->cur_recno < meta->first_recno - cp->recno)) {
                          goto retry;
                        }
                      } else {
                        goto retry;
                      }
                    }
                  } else {
                    goto retry;
                  }
                }
              }
              ret = __memp_fput(mpf, (void *)meta, 0U);
              if (ret != 0) {
                goto err;
              }
              meta = (QMETA *)((void *)0);
              ret = __db_lget(dbc, 0, metapno, (enum __anonenum_db_lockmode_t_50 )3,
                              16U, & metalock);
              if (ret != 0) {
                if (ret == -30995) {
                  ret = -30994;
                }
                goto err;
              }
              ret = __memp_fget(mpf, & metapno, 0U, (void *)(& meta));
              if (ret != 0) {
                goto err;
              }
              ret = __lock_get(dbenv___0, dbc->locker, 32U, (DBT const   *)(& dbc->lock_dbt),
                               (enum __anonenum_db_lockmode_t_50 )2, & metalock);
              if (ret != 0) {
                goto err;
              }
              locked = 1;
              goto retry;
            }
          }
        }
      }
    }
    break;
  }
  case 9: 
  flags = 18U;
  is_first = 1;
  first = meta->first_recno;
  cp->recno = first;
  break;
  case 25: ;
  case 26: ;
  if (cp->recno != 0U) {
    if (cp->recno == meta->first_recno) {
      ret = -30990;
      goto err;
    } else {
      if (cp->recno < meta->first_recno) {
        if (meta->first_recno <= meta->cur_recno) {
          ret = -30990;
          goto err;
        } else {
          if (cp->recno > meta->cur_recno) {
            if (cp->recno - meta->cur_recno > meta->first_recno - cp->recno) {
              ret = -30990;
              goto err;
            }
          }
        }
      }
    }
    cp->recno --;
    if (cp->recno == 0U) {
      cp->recno --;
    }
    break;
  }
  case 17: ;
  if (meta->first_recno == meta->cur_recno) {
    ret = -30990;
    goto err;
  }
  cp->recno = meta->cur_recno - 1U;
  if (cp->recno == 0U) {
    cp->recno --;
  }
  break;
  case 28: ;
  case 30: ;
  case 10: ;
  case 12: 
  ret = __qam_getno(dbp___1, (DBT const   *)key, & cp->recno);
  if (ret != 0) {
    goto err;
  }
  if (cp->recno == 0U) {
    ret = -30990;
    goto err;
  } else {
    if (cp->recno < meta->first_recno) {
      if (meta->first_recno <= meta->cur_recno) {
        ret = -30990;
        goto err;
      } else {
        if (cp->recno > meta->cur_recno) {
          if (cp->recno - meta->cur_recno > meta->first_recno - cp->recno) {
            ret = -30990;
            goto err;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      }
    } else {
      _L___1: 
      if (cp->recno > meta->cur_recno) {
        if (meta->first_recno <= meta->cur_recno) {
          ret = -30990;
          goto err;
        } else {
          if (cp->recno < meta->first_recno) {
            if (cp->recno - meta->cur_recno < meta->first_recno - cp->recno) {
              ret = -30990;
              goto err;
            }
          }
        }
      }
    }
  }
  break;
  default: 
  ret = __db_unknown_flag(dbenv___0, (char *)"__qam_c_get", flags);
  goto err;
  }
  if (locked) {
    if (metalock.off != 0U) {
      ret = __lock_put((dbc->dbp)->dbenv, & metalock);
    } else {
      ret = 0;
    }
    if (ret != 0) {
      goto err;
    }
    locked = 0;
  }
  if (with_delete) {
    if (! retrying) {
      tmp___2 = 3;
    } else {
      tmp___2 = 2;
    }
  } else {
    tmp___2 = 2;
  }
  ret = __db_lget(dbc, 0, cp->recno, lock_mode, (unsigned int )tmp___2, & lock);
  if (ret == -30995) {
    if (with_delete) {
      first = 0U;
      ret = __db_lget(dbc, 0, metapno, lock_mode, 0U, & metalock);
      if (ret != 0) {
        goto err;
      }
      locked = 1;
      goto retry;
    }
  }
  if (ret != 0) {
    goto err;
  }
  if (! with_delete) {
    if (is_first) {
      goto _L___2;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    if (flags == 17U) {
      _L___2: 
      ret = __db_lget(dbc, 0, metapno, lock_mode, 0U, & metalock);
      if (ret != 0) {
        goto err;
      }
      if (is_first) {
        tmp___3 = meta->first_recno;
      } else {
        tmp___3 = meta->cur_recno - 1U;
      }
      if (cp->recno != tmp___3) {
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        if (is_first) {
          flags = 9U;
        }
        locked = 1;
        goto retry;
      }
      if (metalock.off != 0U) {
        ret = __lock_put((dbc->dbp)->dbenv, & metalock);
      } else {
        ret = 0;
      }
      if (ret != 0) {
        goto err;
      }
    }
  }
  ret = __qam_position(dbc, & cp->recno, mode, & exact);
  if (ret != 0) {
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    goto err;
  }
  pg = (PAGE *)cp->page;
  pglock = cp->lock;
  cp->lock = lock;
  cp->lock_mode = lock_mode;
  if (! exact) {
    if (flags == 18U) {
      goto _L___4;
    } else {
      if (flags == 20U) {
        goto _L___4;
      } else {
        if (flags == 25U) {
          goto _L___4;
        } else {
          if (flags == 26U) {
            goto _L___4;
          } else {
            if (flags == 17U) {
              _L___4: 
              if ((unsigned int )pg != (unsigned int )((void *)0)) {
                __qam_fprobe(dbp___1, cp->pgno, (void *)pg, (enum __anonenum_qam_probe_mode_80 )1,
                             0U);
              }
              pg = (PAGE *)((void *)0);
              cp->page = (void *)pg;
              if (pglock.off != 0U) {
                __lock_put((dbc->dbp)->dbenv, & pglock);
              }
              if (cp->lock.off != 0U) {
                __lock_put((dbc->dbp)->dbenv, & cp->lock);
              }
              if (flags == 17U) {
                flags = 25U;
              }
              if (! with_delete) {
                is_first = 0;
              }
              retrying = 0;
              goto retry;
            }
          }
        }
      }
    }
    ret = -30997;
    goto done;
  }
  if ((unsigned int )key != (unsigned int )((void *)0)) {
    if (flags != 10U) {
      if (flags != 12U) {
        if (flags != 28U) {
          if (flags != 30U) {
            ret = __db_retcopy(dbp___1->dbenv, key, (void *)(& cp->recno), sizeof(cp->recno),
                               & (dbc->rkey)->data, & (dbc->rkey)->ulen);
            if (ret != 0) {
              goto done;
            }
          }
        }
      }
    }
    key->flags = key->flags | 2U;
  }
  if (dbp___1->flags & 2048U) {
    tmp___6 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___6 = 48;
    } else {
      tmp___6 = 28;
    }
  }
  qp = (QAMDATA *)((u_int8_t *)pg + ((unsigned long long )tmp___6 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                        (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                       (unsigned long long )sizeof(u_int32_t )) -
                                                                      1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL)) *
                                                                    (unsigned long long )cp->indx));
  if (flags == 10U) {
    goto _L___5;
  } else {
    if (flags == 12U) {
      _L___5: 
      tmp.data = (void *)(qp->data);
      tmp.size = t->re_len;
      ret = __bam_defcmp(dbp___1, (DBT const   *)data, (DBT const   *)(& tmp));
      if (ret != 0) {
        ret = -30990;
        goto done;
      }
    }
  }
  if ((unsigned int )data != (unsigned int )((void *)0)) {
    if (! (dbc->flags & 1536U)) {
      ret = __db_retcopy(dbp___1->dbenv, data, (void *)(qp->data), t->re_len, & (dbc->rdata)->data,
                         & (dbc->rdata)->ulen);
      if (ret != 0) {
        goto done;
      }
    }
  }
  if ((unsigned int )data != (unsigned int )((void *)0)) {
    data->flags = data->flags | 2U;
  }
  if (with_delete) {
    if ((unsigned int )dbp___1->s_secondaries.lh_first != (unsigned int )((void *)0)) {
      ret = __db_c_idup(dbc, & dbcdup, 24U);
      if (ret != 0) {
        goto done;
      }
      ret = __db_c_del_primary(dbcdup);
      if (ret != 0) {
        __db_c_close(dbcdup);
        goto done;
      }
      ret = __db_c_close(dbcdup);
      if (ret != 0) {
        goto done;
      }
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                     516U)) {
                goto _L___8;
              }
            } else {
              goto _L___8;
            }
          } else {
            _L___8: 
            if (t->page_ext == 0U) {
              goto _L___6;
            } else {
              if (t->re_len == 0U) {
                _L___6: 
                ret = __qam_del_log(dbp___1, dbc->txn, & pg->lsn, 0U, & pg->lsn, pg->pgno,
                                    (unsigned int )cp->indx, cp->recno);
                if (ret != 0) {
                  goto done;
                }
              } else {
                tmp.data = (void *)(qp->data);
                tmp.size = t->re_len;
                ret = __qam_delext_log(dbp___1, dbc->txn, & pg->lsn, 0U, & pg->lsn,
                                       pg->pgno, (unsigned int )cp->indx, cp->recno,
                                       (DBT const   *)(& tmp));
                if (ret != 0) {
                  goto done;
                }
              }
            }
          }
        }
      }
    }
    qp->flags = (unsigned char )((int )qp->flags & -2);
    put_mode = 2;
    if (pglock.off != 0U) {
      ret = __lock_put((dbc->dbp)->dbenv, & pglock);
    } else {
      ret = 0;
    }
    if (ret != 0) {
      goto done;
    }
    if (locked == 0) {
      ret = __db_lget(dbc, 0, metapno, lock_mode, 0U, & metalock);
      if (ret != 0) {
        goto done;
      }
    }
    locked = 1;
    if (first == 0U) {
      first = cp->recno;
    }
    if (first != meta->first_recno) {
      goto done;
    }
    ret = __qam_consume(dbc, meta, first);
    if (ret != 0) {
      goto done;
    }
  }
  done: 
  if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
    t_ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                         (unsigned int )put_mode);
    if (! ret) {
      ret = t_ret;
    }
    if (pglock.off != 0U) {
      t_ret = __lock_put((dbc->dbp)->dbenv, & pglock);
    } else {
      t_ret = 0;
    }
    cp->page = (void *)0;
  }
  err: 
  if (! ret) {
    ret = t_ret;
  }
  if (meta) {
    t_ret = __memp_fput(mpf, (void *)meta, 0U);
    if (! ret) {
      ret = t_ret;
    }
    if (locked) {
      if (metalock.off != 0U) {
        t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
      } else {
        t_ret = 0;
      }
    }
  }
  if (t_ret == 0) {
    if (cp->lock.off != 0U) {
      t_ret = __db_lput(dbc, & cp->lock);
    } else {
      t_ret = 0;
    }
  }
  if (! ret) {
    ret = t_ret;
  }
  if (ret == -30994) {
    if (! (dbenv___0->flags & 2097152U)) {
      tmp___11 = -30995;
    } else {
      tmp___11 = ret;
    }
  } else {
    tmp___11 = ret;
  }
  return (tmp___11);
}
}
static int __qam_consume(DBC *dbc , QMETA *meta , db_recno_t first ) 
{ DB *dbp___1 ;
  DB_LOCK lock ;
  DB_LOCK save_lock ;
  DB_MPOOLFILE *mpf ;
  QUEUE_CURSOR *cp ;
  db_indx_t save_indx ;
  db_pgno_t save_page ;
  db_recno_t current ;
  db_recno_t save_recno ;
  u_int32_t rec_extent ;
  int exact ;
  int put_mode ;
  int ret ;
  int t_ret ;
  int wrapped ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (QUEUE_CURSOR *)dbc->internal;
  put_mode = 2;
  t_ret = 0;
  ret = t_ret;
  save_page = cp->pgno;
  save_indx = cp->indx;
  save_recno = cp->recno;
  save_lock = cp->lock;
  if (first != cp->recno) {
    ret = __db_lget(dbc, 0, first, (enum __anonenum_db_lockmode_t_50 )1, 3U, & lock);
    if (ret == -30995) {
      ret = 0;
      goto done;
    }
    if (ret != 0) {
      goto done;
    }
    ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                       (unsigned int )put_mode);
    if (ret != 0) {
      goto done;
    }
    cp->page = (void *)0;
    put_mode = 0;
    ret = __qam_position(dbc, & first, (enum __anonenum_qam_position_mode_79 )0, & exact);
    if (ret != 0) {
      goto _L;
    } else {
      if (exact != 0) {
        _L: 
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        goto done;
      }
    }
    if (lock.off != 0U) {
      ret = __lock_put((dbc->dbp)->dbenv, & lock);
    } else {
      ret = 0;
    }
    if (ret != 0) {
      goto done;
    }
    if (cp->lock.off != 0U) {
      ret = __lock_put((dbc->dbp)->dbenv, & cp->lock);
    } else {
      ret = 0;
    }
    if (ret != 0) {
      goto done;
    }
  }
  current = meta->cur_recno;
  wrapped = 0;
  if (first > current) {
    wrapped = 1;
  }
  rec_extent = meta->page_ext * meta->rec_page;
  while (1) {
    if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
      if (rec_extent != 0U) {
        exact = first % rec_extent == 0U;
        if (exact) {
          goto _L___1;
        } else {
          if (first % meta->rec_page == 0U) {
            goto _L___1;
          } else {
            if (first == 4294967295U) {
              _L___1: 
              if (exact == 1) {
                ret = __db_lget(dbc, 0, cp->pgno, (enum __anonenum_db_lockmode_t_50 )2,
                                0U, & cp->lock);
                if (ret != 0) {
                  break;
                }
              }
              put_mode |= 4;
              ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                                 (unsigned int )put_mode);
              if (ret != 0) {
                break;
              }
              cp->page = (void *)0;
              if (exact == 1) {
                ret = __qam_fremove(dbp___1, cp->pgno);
                if (cp->lock.off != 0U) {
                  t_ret = __lock_put((dbc->dbp)->dbenv, & cp->lock);
                } else {
                  t_ret = 0;
                }
              }
              if (ret != 0) {
                break;
              }
              if (t_ret != 0) {
                ret = t_ret;
                break;
              }
            } else {
              goto _L___2;
            }
          }
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
        ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                           (unsigned int )put_mode);
        if (ret != 0) {
          break;
        }
      }
    }
    cp->page = (void *)0;
    first ++;
    if (first == 0U) {
      wrapped = 0;
      first ++;
    }
    if (! wrapped) {
      if (first >= current) {
        break;
      }
    }
    ret = __db_lget(dbc, 0, first, (enum __anonenum_db_lockmode_t_50 )1, 3U, & lock);
    if (ret == -30995) {
      ret = 0;
      break;
    }
    if (ret != 0) {
      break;
    }
    ret = __qam_position(dbc, & first, (enum __anonenum_qam_position_mode_79 )0, & exact);
    if (ret != 0) {
      if (lock.off != 0U) {
        __lock_put((dbc->dbp)->dbenv, & lock);
      }
      break;
    }
    put_mode = 0;
    if (lock.off != 0U) {
      ret = __lock_put((dbc->dbp)->dbenv, & lock);
    } else {
      ret = 0;
    }
    if (ret != 0) {
      goto _L___3;
    } else {
      if (cp->lock.off != 0U) {
        ret = __lock_put((dbc->dbp)->dbenv, & cp->lock);
      } else {
        ret = 0;
      }
      if (ret != 0) {
        goto _L___3;
      } else {
        if (exact) {
          _L___3: 
          t_ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                               (unsigned int )put_mode);
          if (t_ret != 0) {
            if (ret == 0) {
              ret = t_ret;
            }
          }
          cp->page = (void *)0;
          break;
        }
      }
    }
  }
  cp->pgno = save_page;
  cp->indx = save_indx;
  cp->recno = save_recno;
  cp->lock = save_lock;
  if (ret == 0) {
    if (meta->first_recno != first) {
      if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
          if (! (dbc->flags & 16U)) {
            if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
                if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                       516U)) {
                  goto _L___5;
                }
              } else {
                goto _L___5;
              }
            } else {
              _L___5: 
              ret = __qam_incfirst_log(dbp___1, dbc->txn, & meta->dbmeta.lsn, 0U,
                                       cp->recno, 0U);
              if (ret != 0) {
                goto done;
              }
            }
          }
        }
      }
      meta->first_recno = first;
      __memp_fset(mpf, (void *)meta, 2U);
    }
  }
  done: 
  return (ret);
}
}
static int __qam_bulk(DBC *dbc , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  PAGE *pg ;
  QMETA *meta ;
  QAMDATA *qp ;
  QUEUE_CURSOR *cp ;
  db_indx_t indx ;
  db_pgno_t metapno ;
  qam_position_mode mode ;
  int32_t *endp ;
  int32_t *offp ;
  u_int8_t *dbuf ;
  u_int8_t *dp ;
  u_int8_t *np ;
  int exact ;
  int recs ;
  int re_len ;
  int ret ;
  int t_ret ;
  int valid ;
  int is_key ;
  int need_pg ;
  int pagesize ;
  int size ;
  int space ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int32_t *tmp___6 ;
  int32_t *tmp___7 ;
  int tmp___9 ;
  int32_t *tmp___10 ;
  int32_t *tmp___11 ;
  int32_t *tmp___12 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  cp = (QUEUE_CURSOR *)dbc->internal;
  mode = (enum __anonenum_qam_position_mode_79 )0;
  if (dbc->flags & 32U) {
    mode = (enum __anonenum_qam_position_mode_79 )1;
  }
  pagesize = (int )dbp___1->pgsize;
  re_len = (int )((QUEUE *)dbp___1->q_internal)->re_len;
  recs = (int )((QUEUE *)dbp___1->q_internal)->rec_page;
  metapno = ((QUEUE *)dbp___1->q_internal)->q_meta;
  if (flags & 134217728U) {
    is_key = 1;
  } else {
    is_key = 0;
  }
  size = 0;
  ret = __db_lget(dbc, 0, metapno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & metalock);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fget(mpf, & metapno, 0U, (void *)(& meta));
  if (ret != 0) {
    if (metalock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & metalock);
    }
    return (ret);
  }
  dbuf = (u_int8_t *)data->data;
  dp = dbuf;
  np = dp;
  space = (int )data->ulen;
  space = (int )((unsigned int )space - sizeof((*offp)));
  endp = (int32_t *)(dbuf + data->ulen);
  endp --;
  offp = endp;
  next_pg: 
  if (cp->recno == 0U) {
    cp->recno ++;
  }
  ret = __qam_position(dbc, & cp->recno, mode, & exact);
  if (ret != 0) {
    goto done;
  }
  pg = (PAGE *)cp->page;
  indx = cp->indx;
  need_pg = 1;
  while (1) {
    valid = 0;
    if ((unsigned int )pg != (unsigned int )((void *)0)) {
      if (dbp___1->flags & 2048U) {
        tmp___0 = 64;
      } else {
        if (dbp___1->flags & 1U) {
          tmp___0 = 48;
        } else {
          tmp___0 = 28;
        }
      }
      qp = (QAMDATA *)((u_int8_t *)pg + ((unsigned long long )tmp___0 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                            (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                           (unsigned long long )sizeof(u_int32_t )) -
                                                                          1ULL) &
                                                                         ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                            1ULL)) *
                                                                        (unsigned long long )indx));
      if ((int )qp->flags & 1) {
        valid = 1;
        if (is_key) {
          tmp___1 = 3;
        } else {
          tmp___1 = 2;
        }
        space = (int )((unsigned int )space - (unsigned int )tmp___1 * sizeof((*offp)));
        if (space < 0) {
          goto get_space;
        }
        if (need_pg) {
          dp = np;
          if (dbp___1->flags & 2048U) {
            tmp___3 = 64;
          } else {
            if (dbp___1->flags & 1U) {
              tmp___3 = 48;
            } else {
              tmp___3 = 28;
            }
          }
          size = pagesize - tmp___3;
          if (space < size) {
            get_space: 
            if ((unsigned int )offp == (unsigned int )endp) {
              data->size = (unsigned int )((unsigned long long )(((unsigned int )(size +
                                                                                  pagesize) +
                                                                  sizeof(u_int32_t )) -
                                                                 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                          1ULL));
              ret = 12;
              break;
            }
            if ((int )indx != 0) {
              indx = (unsigned short )((int )indx - 1);
            }
            cp->recno --;
            space = 0;
            break;
          }
          if (dbp___1->flags & 2048U) {
            tmp___5 = 64;
          } else {
            if (dbp___1->flags & 1U) {
              tmp___5 = 48;
            } else {
              tmp___5 = 28;
            }
          }
          memcpy((void * __restrict  )dp, (void const   * __restrict  )((char *)pg +
                                                                        tmp___5),
                 (unsigned int )size);
          need_pg = 0;
          space -= size;
          np += size;
        }
        if (is_key) {
          tmp___6 = offp;
          offp --;
          (*tmp___6) = (int )cp->recno;
        }
        tmp___7 = offp;
        offp --;
        if (dbp___1->flags & 2048U) {
          tmp___9 = 64;
        } else {
          if (dbp___1->flags & 1U) {
            tmp___9 = 48;
          } else {
            tmp___9 = 28;
          }
        }
        (*tmp___7) = ((dp + (((u_int8_t *)qp - (u_int8_t *)pg) - tmp___9)) - dbuf) +
                     (int )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0])));
        tmp___10 = offp;
        offp --;
        (*tmp___10) = re_len;
      }
    }
    if (! valid) {
      if (is_key == 0) {
        tmp___11 = offp;
        offp --;
        (*tmp___11) = 0;
        tmp___12 = offp;
        offp --;
        (*tmp___12) = 0;
      }
    }
    cp->recno ++;
    indx = (unsigned short )((int )indx + 1);
    if ((int )indx < recs) {
      if (cp->recno != 0U) {
        if (cp->recno != meta->cur_recno) {
          if (cp->recno > meta->cur_recno) {
            if (meta->first_recno <= meta->cur_recno) {
              break;
            } else {
              if (cp->recno < meta->first_recno) {
                if (cp->recno - meta->cur_recno < meta->first_recno - cp->recno) {
                  break;
                }
              }
            }
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  if (cp->lock.off != 0U) {
    t_ret = __db_lput(dbc, & cp->lock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
    t_ret = __qam_fprobe(dbp___1, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                         0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    cp->page = (void *)0;
  }
  if (ret == 0) {
    if (space > 0) {
      if ((int )indx >= recs) {
        goto _L;
      } else {
        if (cp->recno == 0U) {
          _L: 
          if (cp->recno != meta->cur_recno) {
            if (cp->recno > meta->cur_recno) {
              if (! (meta->first_recno <= meta->cur_recno)) {
                if (cp->recno < meta->first_recno) {
                  if (! (cp->recno - meta->cur_recno < meta->first_recno - cp->recno)) {
                    goto next_pg;
                  }
                } else {
                  goto next_pg;
                }
              }
            } else {
              goto next_pg;
            }
          }
        }
      }
    }
  }
  if (cp->recno == 0U) {
    cp->recno --;
  } else {
    if (space == 0) {
      if ((int )indx == recs) {
        cp->recno --;
      }
    }
  }
  if (is_key == 1) {
    (*offp) = 0;
  } else {
    (*offp) = -1;
  }
  done: 
  t_ret = __memp_fput(mpf, (void *)meta, 0U);
  if (! ret) {
    ret = t_ret;
  }
  if (metalock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
  } else {
    t_ret = 0;
  }
  return (ret);
}
}
static int __qam_c_close(DBC *dbc , db_pgno_t root_pgno , int *rmroot ) 
{ QUEUE_CURSOR *cp ;

  {
  root_pgno = 0U;
  root_pgno = root_pgno;
  rmroot = (int *)((void *)0);
  rmroot = rmroot;
  cp = (QUEUE_CURSOR *)dbc->internal;
  if (cp->lock.off != 0U) {
    __db_lput(dbc, & cp->lock);
  }
  cp->lock.off = 0U;
  cp->page = (void *)0;
  cp->pgno = 0U;
  cp->indx = (unsigned short)0;
  cp->lock_mode = (enum __anonenum_db_lockmode_t_50 )0;
  cp->recno = 0U;
  cp->flags = 0U;
  return (0);
}
}
int __qam_c_dup(DBC *orig_dbc , DBC *new_dbc ) 
{ QUEUE_CURSOR *orig ;
  QUEUE_CURSOR *new ;
  int tmp ;

  {
  orig = (QUEUE_CURSOR *)orig_dbc->internal;
  new = (QUEUE_CURSOR *)new_dbc->internal;
  new->recno = orig->recno;
  if ((unsigned int )orig_dbc->txn != (unsigned int )((void *)0)) {
    return (0);
  } else {
    if (! (orig_dbc->flags & 8U)) {
      if (! (((orig_dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((orig_dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          if (! (orig->lock.off != 0U)) {
            return (0);
          }
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    } else {
      return (0);
    }
  }
  tmp = __db_lget(new_dbc, 0, new->recno, new->lock_mode, 2U, & new->lock);
  return (tmp);
}
}
int __qam_c_init(DBC *dbc ) 
{ QUEUE_CURSOR *cp ;
  DB *dbp___1 ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  cp = (QUEUE_CURSOR *)dbc->internal;
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    ret = __os_calloc(dbp___1->dbenv, 1U, sizeof(QUEUE_CURSOR ), (void *)(& cp));
    if (ret != 0) {
      return (ret);
    }
    dbc->internal = (DBC_INTERNAL *)cp;
  }
  dbc->c_close = & __db_c_close;
  dbc->c_count = & __db_c_count_pp;
  dbc->c_del = & __db_c_del_pp;
  dbc->c_dup = & __db_c_dup_pp;
  dbc->c_get = & __db_c_get_pp;
  dbc->c_pget = & __db_c_pget_pp;
  dbc->c_put = & __db_c_put_pp;
  dbc->c_am_bulk = & __qam_bulk;
  dbc->c_am_close = & __qam_c_close;
  dbc->c_am_del = & __qam_c_del;
  dbc->c_am_destroy = & __qam_c_destroy;
  dbc->c_am_get = & __qam_c_get;
  dbc->c_am_put = & __qam_c_put;
  dbc->c_am_writelock = (int (*)(DBC * ))((void *)0);
  return (0);
}
}
static int __qam_c_destroy(DBC *dbc ) 
{ 

  {
  __os_free((dbc->dbp)->dbenv, (void *)dbc->internal);
  return (0);
}
}
static int __qam_getno(DB *dbp___1 , DBT const   *key , db_recno_t *rep ) 
{ 

  {
  (*rep) = (*((db_recno_t *)key->data));
  if ((*rep) == 0U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "illegal record number of 0");
    return (22);
  }
  return (0);
}
}
int __qam_truncate(DBC *dbc , u_int32_t *countp ) 
{ DB *dbp___1 ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  QMETA *meta ;
  QUEUE_CURSOR *cp ;
  db_pgno_t metapno ;
  int count ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  count = 0;
  while (1) {
    ret = __qam_c_get(dbc, (DBT *)((void *)0), (DBT *)((void *)0), 5U, & metapno);
    if (! (ret == 0)) {
      break;
    }
    count ++;
  }
  if (ret == -30990) {
    ret = 0;
  } else {
    return (ret);
  }
  cp = (QUEUE_CURSOR *)dbc->internal;
  if (cp->pgno != 0U) {
    if (((QUEUE *)dbp___1->q_internal)->page_ext != 0U) {
      ret = __qam_fremove(dbp___1, cp->pgno);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  metapno = ((QUEUE *)dbp___1->q_internal)->q_meta;
  ret = __db_lget(dbc, 0, metapno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & metalock);
  if (ret != 0) {
    return (ret);
  }
  mpf = dbp___1->mpf;
  ret = __memp_fget(mpf, & metapno, 0U, (void *)(& meta));
  if (ret != 0) {
    if (metalock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & metalock);
    }
    return (ret);
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if (! ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags &
                   516U)) {
              ret = __qam_mvptr_log(dbp___1, dbc->txn, & meta->dbmeta.lsn, 0U, 7U,
                                    meta->first_recno, 1U, meta->cur_recno, 1U, & meta->dbmeta.lsn,
                                    0U);
            }
          } else {
            ret = __qam_mvptr_log(dbp___1, dbc->txn, & meta->dbmeta.lsn, 0U, 7U, meta->first_recno,
                                  1U, meta->cur_recno, 1U, & meta->dbmeta.lsn, 0U);
          }
        } else {
          ret = __qam_mvptr_log(dbp___1, dbc->txn, & meta->dbmeta.lsn, 0U, 7U, meta->first_recno,
                                1U, meta->cur_recno, 1U, & meta->dbmeta.lsn, 0U);
        }
      }
    }
  }
  if (ret == 0) {
    meta->cur_recno = 1U;
    meta->first_recno = meta->cur_recno;
  }
  if (ret == 0) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  t_ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (metalock.off != 0U) {
    t_ret = __lock_put((dbc->dbp)->dbenv, & metalock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  (*countp) = (unsigned int )count;
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-s9SWJk8y.i","-O2")
int __qam_incfirst_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                            void *summary ) ;
int __qam_incfirst_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                         void *notused3 ) ;
int __qam_incfirst_read(DB_ENV *dbenv___0 , void *recbuf , __qam_incfirst_args **argpp ) ;
int __qam_mvptr_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __qam_mvptr_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __qam_mvptr_read(DB_ENV *dbenv___0 , void *recbuf , __qam_mvptr_args **argpp ) ;
int __qam_del_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) ;
int __qam_del_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) ;
int __qam_del_read(DB_ENV *dbenv___0 , void *recbuf , __qam_del_args **argpp ) ;
int __qam_add_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) ;
int __qam_add_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) ;
int __qam_add_read(DB_ENV *dbenv___0 , void *recbuf , __qam_add_args **argpp ) ;
int __qam_delext_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __qam_delext_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __qam_delext_read(DB_ENV *dbenv___0 , void *recbuf , __qam_delext_args **argpp ) ;
int __qam_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) ;
int __qam_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) ;
int __qam_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __qam_incfirst_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                           void *info ) ;
int __qam_mvptr_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __qam_del_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) ;
int __qam_delext_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __qam_add_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) ;
int __qam_incfirst_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                       db_recno_t recno , db_pgno_t meta_pgno ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 84U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                 sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = recno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __qam_incfirst_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                            void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __qam_incfirst_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                         void *notused3 ) 
{ __qam_incfirst_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __qam_incfirst_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__qam_incfirst%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\trecno: %lu\n", (unsigned long )argp->recno);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __qam_incfirst_read(DB_ENV *dbenv___0 , void *recbuf , __qam_incfirst_args **argpp ) 
{ __qam_incfirst_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__qam_incfirst_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->recno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __qam_mvptr_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , db_recno_t old_first , db_recno_t new_first ,
                    db_recno_t old_cur , db_recno_t new_cur , DB_LSN *metalsn , db_pgno_t meta_pgno ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 85U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*metalsn))) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = old_first;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = new_first;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = old_cur;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = new_cur;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )metalsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )metalsn, sizeof((*metalsn)));
  } else {
    memset((void *)bp, 0, sizeof((*metalsn)));
  }
  bp += sizeof((*metalsn));
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __qam_mvptr_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __qam_mvptr_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __qam_mvptr_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __qam_mvptr_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__qam_mvptr%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\told_first: %lu\n", (unsigned long )argp->old_first);
  printf((char const   * __restrict  )"\tnew_first: %lu\n", (unsigned long )argp->new_first);
  printf((char const   * __restrict  )"\told_cur: %lu\n", (unsigned long )argp->old_cur);
  printf((char const   * __restrict  )"\tnew_cur: %lu\n", (unsigned long )argp->new_cur);
  printf((char const   * __restrict  )"\tmetalsn: [%lu][%lu]\n", (unsigned long )argp->metalsn.file,
         (unsigned long )argp->metalsn.offset);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __qam_mvptr_read(DB_ENV *dbenv___0 , void *recbuf , __qam_mvptr_args **argpp ) 
{ __qam_mvptr_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__qam_mvptr_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->old_first = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->new_first = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->old_cur = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->new_cur = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->metalsn), (void const   * __restrict  )bp,
         sizeof(argp->metalsn));
  bp += sizeof(argp->metalsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __qam_del_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  DB_LSN *lsn , db_pgno_t pgno , u_int32_t indx , db_recno_t recno ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 79U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                   sizeof((*lsn))) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = recno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __qam_del_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __qam_del_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) 
{ __qam_del_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __qam_del_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__qam_del%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\trecno: %lu\n", (unsigned long )argp->recno);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __qam_del_read(DB_ENV *dbenv___0 , void *recbuf , __qam_del_args **argpp ) 
{ __qam_del_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__qam_del_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->recno = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __qam_add_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  DB_LSN *lsn , db_pgno_t pgno , u_int32_t indx , db_recno_t recno ,
                  DBT const   *data , u_int32_t vflag , DBT const   *olddata ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 80U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = data->size;
  }
  if ((unsigned int )olddata == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = olddata->size;
  }
  logrec.size = (((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                         sizeof(u_int32_t )) + sizeof((*lsn))) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   tmp) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp___0;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = recno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& data->size), sizeof(data->size));
    bp += sizeof(data->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )data->data, data->size);
    bp += data->size;
  }
  uinttmp = vflag;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )olddata == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& olddata->size),
           sizeof(olddata->size));
    bp += sizeof(olddata->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )olddata->data, olddata->size);
    bp += olddata->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __qam_add_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __qam_add_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) 
{ __qam_add_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __qam_add_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__qam_add%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\trecno: %lu\n", (unsigned long )argp->recno);
  printf((char const   * __restrict  )"\tdata: ");
  i = 0U;
  while (i < argp->data.size) {
    ch = (int )(*((u_int8_t *)argp->data.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tvflag: %lu\n", (unsigned long )argp->vflag);
  printf((char const   * __restrict  )"\tolddata: ");
  i = 0U;
  while (i < argp->olddata.size) {
    ch = (int )(*((u_int8_t *)argp->olddata.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __qam_add_read(DB_ENV *dbenv___0 , void *recbuf , __qam_add_args **argpp ) 
{ __qam_add_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__qam_add_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->recno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->data), 0, sizeof(argp->data));
  memcpy((void * __restrict  )(& argp->data.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->data.data = (void *)bp;
  bp += argp->data.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->vflag = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->olddata), 0, sizeof(argp->olddata));
  memcpy((void * __restrict  )(& argp->olddata.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->olddata.data = (void *)bp;
  bp += argp->olddata.size;
  (*argpp) = argp;
  return (0);
}
}
int __qam_delext_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DB_LSN *lsn , db_pgno_t pgno , u_int32_t indx , db_recno_t recno ,
                     DBT const   *data ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 83U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = data->size;
  }
  logrec.size = ((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                     sizeof((*lsn))) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = recno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& data->size), sizeof(data->size));
    bp += sizeof(data->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )data->data, data->size);
    bp += data->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __qam_delext_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __qam_delext_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __qam_delext_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __qam_delext_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__qam_delext%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\trecno: %lu\n", (unsigned long )argp->recno);
  printf((char const   * __restrict  )"\tdata: ");
  i = 0U;
  while (i < argp->data.size) {
    ch = (int )(*((u_int8_t *)argp->data.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __qam_delext_read(DB_ENV *dbenv___0 , void *recbuf , __qam_delext_args **argpp ) 
{ __qam_delext_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__qam_delext_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->recno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->data), 0, sizeof(argp->data));
  memcpy((void * __restrict  )(& argp->data.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->data.data = (void *)bp;
  bp += argp->data.size;
  (*argpp) = argp;
  return (0);
}
}
int __qam_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_incfirst_print, 84U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_mvptr_print, 85U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_del_print, 79U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_add_print, 80U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_delext_print, 83U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __qam_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_incfirst_getpgnos,
                          84U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_mvptr_getpgnos, 85U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_del_getpgnos, 79U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_add_getpgnos, 80U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_delext_getpgnos, 83U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __qam_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_incfirst_recover, 84U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_mvptr_recover, 85U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_del_recover, 79U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_add_recover, 80U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __qam_delext_recover, 83U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-f4s9Ukby.i","-O2")
int __qam_mswap(PAGE *pg ) ;
int __qam_pgin_out(DB_ENV *dbenv___0 , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __qam_mswap(PAGE *pg ) 
{ u_int8_t *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  u_int32_t _tmp___5 ;

  {
  __db_metaswap(pg);
  p = (u_int8_t *)pg + sizeof(DBMETA );
  (*((u_int8_t *)(& _tmp) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___0) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___0) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___0) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___0) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___1) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___1) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___1) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___1) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___2) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___2) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___2) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___2) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___2) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___2) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___2) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___2) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___3) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___3) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___3) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___3) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___3) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___3) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___3) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___3) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___4) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___4) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___4) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___4) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___4) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___4) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___4) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___4) + 0));
  p += sizeof(u_int32_t );
  p += 91U * sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___5) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___5) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___5) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___5) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___5) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___5) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___5) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___5) + 0));
  p += sizeof(u_int32_t );
  return (0);
}
}
int __qam_pgin_out(DB_ENV *dbenv___0 , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB_PGINFO *pginfo ;
  QPAGE *h ;
  int tmp ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;

  {
  pg = 0U;
  pg = pg;
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  pginfo = (DB_PGINFO *)cookie->data;
  if (! (pginfo->flags & 268435456U)) {
    return (0);
  }
  h = (QPAGE *)pp;
  if ((int )h->type == 10) {
    tmp = __qam_mswap((PAGE *)pp);
    return (tmp);
  }
  _tmp = h->lsn.file;
  (*((u_int8_t *)(& h->lsn.file) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*((u_int8_t *)(& h->lsn.file) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*((u_int8_t *)(& h->lsn.file) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*((u_int8_t *)(& h->lsn.file) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  _tmp___0 = h->lsn.offset;
  (*((u_int8_t *)(& h->lsn.offset) + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
  (*((u_int8_t *)(& h->lsn.offset) + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
  (*((u_int8_t *)(& h->lsn.offset) + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
  (*((u_int8_t *)(& h->lsn.offset) + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  _tmp___1 = h->pgno;
  (*((u_int8_t *)(& h->pgno) + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
  (*((u_int8_t *)(& h->pgno) + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
  (*((u_int8_t *)(& h->pgno) + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
  (*((u_int8_t *)(& h->pgno) + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
  return (0);
}
}
#pragma merger(0,"/tmp/cil-HRPNxidk.i","-O2")
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
__inline static  __attribute__((__nothrow__)) long strtol__extinline(char const   * __restrict  __nptr ,
                                                                     char ** __restrict  __endptr ,
                                                                     int __base ) ;
__inline static long strtol__extinline(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                       int __base ) 
{ long tmp ;

  {
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  return (tmp);
}
}
__inline static  __attribute__((__nothrow__)) long atol__extinline(char const   *__nptr ) ;
__inline static  __attribute__((__nothrow__)) long atol__extinline(char const   *__nptr ) ;
__inline static long atol__extinline(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                          10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int snprintf(char * __restrict  __s , size_t __maxlen ,
                                                  char const   * __restrict  __format 
                                                  , ...) ;
int __os_dirlist(DB_ENV *dbenv___0 , char const   *dir , char ***namesp , int *cntp ) ;
char *__db_rpath(char const   *path ) ;
int __db_close(DB *dbp___1 , DB_TXN *txn , u_int32_t flags ) ;
int __db_open(DB *dbp___1 , DB_TXN *txn , char const   *fname , char const   *dname ,
              DBTYPE type , u_int32_t flags , int mode , db_pgno_t meta_pgno ) ;
int __log_flush(DB_ENV *dbenv___0 , DB_LSN const   *lsn ) ;
int __fop_remove(DB_ENV *dbenv___0 , DB_TXN *txn , u_int8_t *fileid , char const   *name ,
                 APPNAME appname , u_int32_t flags ) ;
int __fop_rename(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *oldname , char const   *newname ,
                 u_int8_t *fid , APPNAME appname , u_int32_t flags ) ;
int __memp_fcreate(DB_ENV *dbenv___0 , DB_MPOOLFILE **retp ) ;
int __memp_set_fileid(DB_MPOOLFILE *dbmfp , u_int8_t *fileid ) ;
int __memp_set_flags(DB_MPOOLFILE *dbmfp , u_int32_t flags , int onoff ) ;
int __memp_get_ftype(DB_MPOOLFILE *dbmfp , int *ftypep ) ;
int __memp_set_ftype(DB_MPOOLFILE *dbmfp , int ftype ) ;
int __memp_set_lsn_offset(DB_MPOOLFILE *dbmfp , int32_t lsn_offset ) ;
int __memp_set_pgcookie(DB_MPOOLFILE *dbmfp , DBT *pgcookie ) ;
int __memp_fopen(DB_MPOOLFILE *dbmfp , MPOOLFILE *mfp , char const   *path , u_int32_t flags ,
                 int mode , size_t pagesize ) ;
int __memp_fclose(DB_MPOOLFILE *dbmfp , u_int32_t flags ) ;
int __memp_nameop(DB_ENV *dbenv___0 , u_int8_t *fileid , char const   *newname , char const   *fullold ,
                  char const   *fullnew ) ;
int __memp_sync(DB_ENV *dbenv___0 , DB_LSN *lsnp ) ;
int __memp_fsync(DB_MPOOLFILE *dbmfp ) ;
int __qam_sync(DB *dbp___1 ) ;
int __qam_gen_filelist(DB *dbp___1 , QUEUE_FILELIST **filelistp ) ;
int __qam_extent_names(DB_ENV *dbenv___0 , char *name , char ***namelistp ) ;
void __qam_exid(DB *dbp___1 , u_int8_t *fidp , u_int32_t exnum ) ;
int __qam_nameop(DB *dbp___1 , DB_TXN *txn , char const   *newname , qam_name_op op ) ;
int __qam_fprobe(DB *dbp___1 , db_pgno_t pgno , void *addrp , qam_probe_mode mode ,
                 u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  MPFARRAY *array ;
  QUEUE *qp ;
  u_int8_t fid[20] ;
  u_int32_t extid ;
  u_int32_t maxext ;
  u_int32_t openflags ;
  char buf[1024] ;
  int ftype ;
  int numext ;
  int offset ;
  int oldext ;
  int ret ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  dbenv___0 = dbp___1->dbenv;
  qp = (QUEUE *)dbp___1->q_internal;
  ret = 0;
  if (qp->page_ext == 0U) {
    mpf = dbp___1->mpf;
    if ((int )mode == 0) {
      tmp___1 = __memp_fget(mpf, & pgno, flags, addrp);
    } else {
      tmp___1 = __memp_fput(mpf, addrp, flags);
    }
    return (tmp___1);
  }
  mpf = (DB_MPOOLFILE *)((void *)0);
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  extid = (pgno - 1U) / ((QUEUE *)dbp___1->q_internal)->page_ext;
  array = & qp->array1;
  if (array->n_extent == 0U) {
    oldext = 0;
    array->n_extent = 4U;
    array->low_extent = extid;
    offset = 0;
    numext = 0;
    goto alloc;
  }
  offset = (int )(extid - qp->array1.low_extent);
  if (qp->array2.n_extent != 0U) {
    tmp___2 = abs(offset);
    tmp___3 = abs((int )(extid - qp->array2.low_extent));
    if (tmp___2 > tmp___3) {
      array = & qp->array2;
      offset = (int )(extid - array->low_extent);
    }
  }
  if (offset < 0) {
    goto _L___2;
  } else {
    if ((unsigned int )offset >= array->n_extent) {
      _L___2: 
      oldext = (int )array->n_extent;
      numext = (int )((array->hi_extent - array->low_extent) + 1U);
      if (offset < 0) {
        if ((unsigned int )(- offset) + (unsigned int )numext <= array->n_extent) {
          memmove((void *)(array->mpfarray + - offset), (void const   *)array->mpfarray,
                  (unsigned int )numext * sizeof((*(array->mpfarray + 0))));
          memset((void *)array->mpfarray, 0, (unsigned int )(- offset) * sizeof((*(array->mpfarray +
                                                                                   0))));
          offset = 0;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        if ((unsigned int )offset == array->n_extent) {
          if ((int )mode != 2) {
            if ((array->mpfarray + 0)->pinref == 0) {
              mpf = (array->mpfarray + 0)->mpf;
              if ((unsigned int )mpf != (unsigned int )((void *)0)) {
                ret = __memp_fclose(mpf, 0U);
                if (ret != 0) {
                  goto err;
                }
              }
              memmove((void *)(array->mpfarray + 0), (void const   *)(array->mpfarray +
                                                                      1), (array->n_extent -
                                                                           1U) * sizeof((*(array->mpfarray +
                                                                                           0))));
              array->low_extent = array->low_extent + 1U;
              array->hi_extent = array->hi_extent + 1U;
              offset --;
              (array->mpfarray + offset)->mpf = (DB_MPOOLFILE *)((void *)0);
              (array->mpfarray + offset)->pinref = 0;
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          maxext = 4294967295U / (qp->page_ext * qp->rec_page);
          tmp___5 = abs(offset);
          if ((unsigned int )tmp___5 >= maxext / 2U) {
            array = & qp->array2;
            oldext = 0;
            array->n_extent = 4U;
            array->low_extent = extid;
            offset = 0;
            numext = 0;
          } else {
            tmp___4 = abs(offset);
            array->n_extent = array->n_extent + (unsigned int )tmp___4;
            array->n_extent = array->n_extent << 2;
          }
          alloc: 
          ret = __os_realloc(dbenv___0, array->n_extent * sizeof(struct __qmpf ),
                             (void *)(& array->mpfarray));
          if (ret != 0) {
            goto err;
          }
          if (offset < 0) {
            offset = - offset;
            memmove((void *)(array->mpfarray + offset), (void const   *)array->mpfarray,
                    (unsigned int )numext * sizeof((*(array->mpfarray + 0))));
            memset((void *)array->mpfarray, 0, (unsigned int )offset * sizeof((*(array->mpfarray +
                                                                                 0))));
            memset((void *)(array->mpfarray + (numext + offset)), 0, (array->n_extent -
                                                                      (unsigned int )(numext +
                                                                                      offset)) *
                                                                     sizeof((*(array->mpfarray +
                                                                               0))));
            offset = 0;
          } else {
            memset((void *)(array->mpfarray + oldext), 0, (array->n_extent - (unsigned int )oldext) *
                                                          sizeof((*(array->mpfarray +
                                                                    0))));
          }
        }
      }
    }
  }
  if (extid < array->low_extent) {
    array->low_extent = extid;
  }
  if (extid > array->hi_extent) {
    array->hi_extent = extid;
  }
  if ((unsigned int )(array->mpfarray + offset)->mpf == (unsigned int )((void *)0)) {
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s%c__dbq.%s.%d",
             qp->dir, (*("/" + 0)), qp->name, extid);
    ret = __memp_fcreate(dbenv___0, & (array->mpfarray + offset)->mpf);
    if (ret != 0) {
      goto err;
    }
    mpf = (array->mpfarray + offset)->mpf;
    __memp_set_lsn_offset(mpf, 0);
    __memp_set_pgcookie(mpf, & qp->pgcookie);
    __memp_get_ftype(dbp___1->mpf, & ftype);
    __memp_set_ftype(mpf, ftype);
    __qam_exid(dbp___1, fid, extid);
    __memp_set_fileid(mpf, fid);
    openflags = 8192U;
    if (flags & 1U) {
      openflags |= 1U;
    }
    if (dbp___1->flags & 524288U) {
      openflags |= 16U;
    }
    if (dbenv___0->flags & 32U) {
      openflags |= 4096U;
    }
    ret = __memp_fopen(mpf, (MPOOLFILE *)((void *)0), (char const   *)(buf), openflags,
                       qp->mode, dbp___1->pgsize);
    if (ret != 0) {
      (array->mpfarray + offset)->mpf = (DB_MPOOLFILE *)((void *)0);
      __memp_fclose(mpf, 0U);
      goto err;
    }
  }
  mpf = (array->mpfarray + offset)->mpf;
  if ((int )mode == 0) {
    (array->mpfarray + offset)->pinref = (array->mpfarray + offset)->pinref + 1;
  }
  if (flags & 1U) {
    __memp_set_flags(mpf, 2U, 0);
  }
  err: 
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  if (ret == 0) {
    if ((int )mode == 2) {
      (*((DB_MPOOLFILE **)addrp)) = mpf;
      return (0);
    }
    pgno --;
    pgno %= qp->page_ext;
    if ((int )mode == 0) {
      tmp___6 = __memp_fget(mpf, & pgno, flags, addrp);
      return (tmp___6);
    }
    ret = __memp_fput(mpf, addrp, flags);
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    offset = (int )(extid - array->low_extent);
    (array->mpfarray + offset)->pinref = (array->mpfarray + offset)->pinref - 1;
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
  }
  return (ret);
}
}
int __qam_fclose(DB *dbp___1 , db_pgno_t pgnoaddr ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  MPFARRAY *array ;
  QUEUE *qp ;
  u_int32_t extid ;
  int offset ;
  int ret ;

  {
  ret = 0;
  dbenv___0 = dbp___1->dbenv;
  qp = (QUEUE *)dbp___1->q_internal;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  extid = (pgnoaddr - 1U) / ((QUEUE *)dbp___1->q_internal)->page_ext;
  array = & qp->array1;
  if (array->low_extent > extid) {
    array = & qp->array2;
  } else {
    if (array->hi_extent < extid) {
      array = & qp->array2;
    }
  }
  offset = (int )(extid - array->low_extent);
  if ((array->mpfarray + offset)->pinref != 0) {
    goto done;
  }
  mpf = (array->mpfarray + offset)->mpf;
  (array->mpfarray + offset)->mpf = (DB_MPOOLFILE *)((void *)0);
  ret = __memp_fclose(mpf, 0U);
  done: 
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  return (ret);
}
}
int __qam_fremove(DB *dbp___1 , db_pgno_t pgnoaddr ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  MPFARRAY *array ;
  QUEUE *qp ;
  u_int32_t extid ;
  int offset ;
  int ret ;

  {
  qp = (QUEUE *)dbp___1->q_internal;
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  extid = (pgnoaddr - 1U) / ((QUEUE *)dbp___1->q_internal)->page_ext;
  array = & qp->array1;
  if (array->low_extent > extid) {
    array = & qp->array2;
  } else {
    if (array->hi_extent < extid) {
      array = & qp->array2;
    }
  }
  offset = (int )(extid - array->low_extent);
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    ret = __log_flush(dbenv___0, (DB_LSN const   *)((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  mpf = (array->mpfarray + offset)->mpf;
  (array->mpfarray + offset)->mpf = (DB_MPOOLFILE *)((void *)0);
  __memp_set_flags(mpf, 2U, 1);
  ret = __memp_fclose(mpf, 0U);
  if (ret != 0) {
    goto err;
  }
  if (offset == 0) {
    memmove((void *)array->mpfarray, (void const   *)(array->mpfarray + 1), (array->hi_extent -
                                                                             array->low_extent) *
                                                                            sizeof((*(array->mpfarray +
                                                                                      0))));
    (array->mpfarray + (array->hi_extent - array->low_extent))->mpf = (DB_MPOOLFILE *)((void *)0);
    if (array->low_extent != array->hi_extent) {
      array->low_extent = array->low_extent + 1U;
    }
  } else {
    if (extid == array->hi_extent) {
      array->hi_extent = array->hi_extent - 1U;
    }
  }
  err: 
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  return (ret);
}
}
int __qam_sync(DB *dbp___1 ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  if (((QUEUE *)dbp___1->q_internal)->page_ext == 0U) {
    tmp = __memp_fsync(mpf);
    return (tmp);
  } else {
    tmp___0 = __memp_sync(dbenv___0, (DB_LSN *)((void *)0));
    return (tmp___0);
  }
}
}
int __qam_gen_filelist(DB *dbp___1 , QUEUE_FILELIST **filelistp ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  QUEUE *qp ;
  QMETA *meta ;
  size_t extent_cnt ;
  db_recno_t i ;
  db_recno_t current ;
  db_recno_t first ;
  db_recno_t stop ;
  db_recno_t rec_extent ;
  QUEUE_FILELIST *fp ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  qp = (QUEUE *)dbp___1->q_internal;
  (*filelistp) = (QUEUE_FILELIST *)((void *)0);
  if (qp->page_ext == 0U) {
    return (0);
  }
  if ((unsigned int )qp->name == (unsigned int )((void *)0)) {
    return (0);
  }
  i = 0U;
  ret = __memp_fget(mpf, & i, 0U, (void *)(& meta));
  if (ret != 0) {
    return (ret);
  }
  current = meta->cur_recno;
  first = meta->first_recno;
  ret = __memp_fput(mpf, (void *)meta, 0U);
  if (ret != 0) {
    return (ret);
  }
  rec_extent = qp->rec_page * qp->page_ext;
  if (current >= first) {
    extent_cnt = (current - first) / rec_extent + 3U;
  } else {
    extent_cnt = (current + (4294967295U - first)) / rec_extent + 4U;
  }
  ret = __os_calloc(dbenv___0, extent_cnt, sizeof(QUEUE_FILELIST ), (void *)filelistp);
  if (ret != 0) {
    return (ret);
  }
  fp = (*filelistp);
  again: 
  if (current >= first) {
    stop = current;
  } else {
    stop = 4294967295U;
  }
  first -= first % rec_extent;
  first += stop % rec_extent;
  i = first;
  while (1) {
    if (i >= first) {
      if (! (i <= stop)) {
        break;
      }
    } else {
      break;
    }
    ret = __qam_fprobe(dbp___1, ((QUEUE *)dbp___1->q_internal)->q_root + (i - 1U) /
                                                                         ((QUEUE *)dbp___1->q_internal)->rec_page,
                       (void *)(& fp->mpf), (enum __anonenum_qam_probe_mode_80 )2,
                       0U);
    if (ret != 0) {
      if (ret == 2) {
        goto __Cont;
      }
      return (ret);
    }
    fp->id = ((((QUEUE *)dbp___1->q_internal)->q_root + (i - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page) -
              1U) / ((QUEUE *)dbp___1->q_internal)->page_ext;
    fp ++;
    __Cont: 
    i += rec_extent;
  }
  if (current < first) {
    first = 1U;
    goto again;
  }
  return (0);
}
}
int __qam_extent_names(DB_ENV *dbenv___0 , char *name , char ***namelistp ) 
{ DB *dbp___1 ;
  QUEUE *qp ;
  QUEUE_FILELIST *filelist ;
  QUEUE_FILELIST *fp ;
  char buf[1024] ;
  char **cp ;
  char *freep ;
  int cnt ;
  int len ;
  int ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char **tmp___3 ;

  {
  (*namelistp) = (char **)((void *)0);
  filelist = (QUEUE_FILELIST *)((void *)0);
  ret = db_create(& dbp___1, dbenv___0, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_open(dbp___1, (DB_TXN *)((void *)0), (char const   *)name, (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )4, 16U, 0, 0U);
  if (ret != 0) {
    return (ret);
  }
  qp = (QUEUE *)dbp___1->q_internal;
  if (qp->page_ext == 0U) {
    goto done;
  }
  ret = __qam_gen_filelist(dbp___1, & filelist);
  if (ret != 0) {
    goto done;
  }
  if ((unsigned int )filelist == (unsigned int )((void *)0)) {
    goto done;
  }
  cnt = 0;
  fp = filelist;
  while ((unsigned int )fp->mpf != (unsigned int )((void *)0)) {
    cnt ++;
    fp ++;
  }
  tmp = strlen("%s%c__dbq.%s.%d");
  tmp___0 = strlen((char const   *)qp->dir);
  tmp___1 = strlen((char const   *)qp->name);
  len = (int )((unsigned int )cnt * ((((sizeof((*((*namelistp)))) + tmp) + tmp___0) +
                                      tmp___1) + 6U));
  ret = __os_malloc(dbp___1->dbenv, (unsigned int )len, (void *)namelistp);
  if (ret != 0) {
    goto done;
  }
  cp = (*namelistp);
  freep = (char *)((cp + cnt) + 1);
  fp = filelist;
  while ((unsigned int )fp->mpf != (unsigned int )((void *)0)) {
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s%c__dbq.%s.%d",
             qp->dir, (*("/" + 0)), qp->name, fp->id);
    len = (int )strlen((char const   *)(buf));
    tmp___3 = cp;
    cp ++;
    (*tmp___3) = freep;
    strcpy((char * __restrict  )freep, (char const   * __restrict  )(buf));
    freep += len + 1;
    fp ++;
  }
  (*cp) = (char *)((void *)0);
  done: 
  if ((unsigned int )filelist != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)filelist);
  }
  __db_close(dbp___1, (DB_TXN *)((void *)0), 23U);
  return (ret);
}
}
void __qam_exid(DB *dbp___1 , u_int8_t *fidp , u_int32_t exnum ) 
{ int i ;
  u_int8_t *p ;
  u_int8_t *tmp ;
  u_int8_t *tmp___0 ;
  u_int8_t *tmp___1 ;

  {
  memcpy((void * __restrict  )fidp, (void const   * __restrict  )(dbp___1->fileid),
         20U);
  i = (int )sizeof(u_int32_t );
  while (i > 0) {
    tmp = fidp;
    fidp ++;
    (*tmp) = (unsigned char)0;
    i --;
  }
  p = (u_int8_t *)(& exnum);
  i = (int )sizeof(u_int32_t );
  while (i > 0) {
    tmp___0 = fidp;
    fidp ++;
    tmp___1 = p;
    p ++;
    (*tmp___0) = (*tmp___1);
    i --;
  }
  return;
}
}
//extern int __builtin_strcmp() ;
int __qam_nameop(DB *dbp___1 , DB_TXN *txn , char const   *newname , qam_name_op op ) 
{ DB_ENV *dbenv___0 ;
  QUEUE *qp ;
  char buf[1024] ;
  char nbuf[1024] ;
  char sepsave ;
  char *endname ;
  char *endpath ;
  char *exname ;
  char *fullname ;
  char **names ;
  char *ndir ;
  char *namep ;
  char *new ;
  char *cp ;
  int cnt ;
  int exlen ;
  int fulllen ;
  int i ;
  int len ;
  int ret ;
  int t_ret ;
  u_int8_t fid[20] ;
  u_int32_t exid ;
  char *tmp ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;
  unsigned short const   **tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;

  {
  t_ret = 0;
  ret = t_ret;
  dbenv___0 = dbp___1->dbenv;
  qp = (QUEUE *)dbp___1->q_internal;
  fullname = (char *)((void *)0);
  exname = fullname;
  namep = exname;
  if (qp->page_ext == 0U) {
    return (0);
  }
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s%c__dbq.%s.%d",
           qp->dir, (*("/" + 0)), qp->name, 0);
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, (char const   *)(buf),
                     0U, (DB_FH **)((void *)0), & fullname);
  if (ret != 0) {
    return (ret);
  }
  endpath = __db_rpath((char const   *)fullname);
  if ((unsigned int )endpath == (unsigned int )((void *)0)) {
    ret = 22;
    goto err;
  }
  sepsave = (*endpath);
  (*endpath) = (char )'\000';
  ret = __os_dirlist(dbenv___0, (char const   *)fullname, & names, & cnt);
  if (ret != 0) {
    goto err;
  }
  (*endpath) = sepsave;
  if (cnt == 0) {
    goto err;
  }
  endpath ++;
  endname = strrchr((char const   *)endpath, '.');
  if ((unsigned int )endname == (unsigned int )((void *)0)) {
    ret = 22;
    goto err;
  }
  endname ++;
  (*endname) = (char )'\000';
  len = (int )strlen((char const   *)endpath);
  fulllen = (int )strlen((char const   *)fullname);
  exlen = fulllen + 20;
  ret = __os_malloc(dbenv___0, (unsigned int )exlen, (void *)(& exname));
  if (ret != 0) {
    goto err;
  }
  new = (char *)((void *)0);
  ndir = new;
  if ((unsigned int )newname != (unsigned int )((void *)0)) {
    ret = __os_strdup(dbenv___0, newname, (void *)(& namep));
    if (ret != 0) {
      goto err;
    }
    ndir = namep;
    new = __db_rpath((char const   *)namep);
    if ((unsigned int )new != (unsigned int )((void *)0)) {
      tmp = new;
      new ++;
      (*tmp) = (char )'\000';
    } else {
      new = namep;
      ndir = (char *)".";
    }
  }
  i = 0;
  while (i < cnt) {
    tmp___145 = __builtin_constant_p(len);
    if (tmp___145) {
      tmp___146 = __builtin_constant_p((int )(*(names + i)));
      if (tmp___146) {
        tmp___147 = strlen((char const   *)(*(names + i)));
        if (tmp___147 < (unsigned int )len) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
        tmp___148 = __builtin_constant_p((int )endpath);
        if (tmp___148) {
          tmp___149 = strlen((char const   *)endpath);
          if (tmp___149 < (unsigned int )len) {
            _L___39: 
            tmp___142 = __builtin_constant_p((int )(*(names + i)));
            if (tmp___142) {
              tmp___143 = __builtin_constant_p((int )endpath);
              if (tmp___143) {
                __s1_len___0 = strlen((char const   *)(*(names + i)));
                __s2_len___0 = strlen((char const   *)endpath);
                if (! ((unsigned int )((void const   *)((*(names + i)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                  i))) ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)(endpath + 1)) - (unsigned int )((void const   *)endpath) ==
                           1U)) {
                      tmp___144 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___144 = 1;
                      } else {
                        tmp___144 = 0;
                      }
                    }
                  } else {
                    tmp___144 = 0;
                  }
                }
                if (tmp___144) {
                  tmp___111 = __builtin_strcmp((*(names + i)), endpath);
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___141 = __builtin_constant_p((int )(*(names + i)));
              if (tmp___141) {
                if ((unsigned int )((void const   *)((*(names + i)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                               i))) ==
                    1U) {
                  __s1_len___0 = strlen((char const   *)(*(names + i)));
                  if (__s1_len___0 < 4U) {
                    tmp___130 = __builtin_constant_p((int )endpath);
                    if (tmp___130) {
                      if ((unsigned int )((void const   *)(endpath + 1)) - (unsigned int )((void const   *)endpath) ==
                          1U) {
                        tmp___111 = __builtin_strcmp((*(names + i)), endpath);
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)((char const   *)endpath);
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                           i))) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                               i))) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                   i))) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                       i))) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___111 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___140 = __builtin_constant_p((int )endpath);
                if (tmp___140) {
                  if ((unsigned int )((void const   *)(endpath + 1)) - (unsigned int )((void const   *)endpath) ==
                      1U) {
                    __s2_len___0 = strlen((char const   *)endpath);
                    if (__s2_len___0 < 4U) {
                      tmp___139 = __builtin_constant_p((int )(*(names + i)));
                      if (tmp___139) {
                        if ((unsigned int )((void const   *)((*(names + i)) + 1)) -
                            (unsigned int )((void const   *)(*(names + i))) == 1U) {
                          tmp___111 = __builtin_strcmp((*(names + i)), endpath);
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)((char const   *)(*(names +
                                                                                 i)));
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)endpath) +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)endpath) +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)((char const   *)endpath) +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)endpath) +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___111 = __result___46;
                      }
                    } else {
                      tmp___111 = __builtin_strcmp((*(names + i)), endpath);
                    }
                  } else {
                    tmp___111 = __builtin_strcmp((*(names + i)), endpath);
                  }
                } else {
                  tmp___111 = __builtin_strcmp((*(names + i)), endpath);
                }
              }
            }
            tmp___75 = tmp___111;
          } else {
            tmp___75 = strncmp((char const   *)(*(names + i)), (char const   *)endpath,
                               (unsigned int )len);
          }
        } else {
          tmp___75 = strncmp((char const   *)(*(names + i)), (char const   *)endpath,
                             (unsigned int )len);
        }
      }
    } else {
      tmp___75 = strncmp((char const   *)(*(names + i)), (char const   *)endpath,
                         (unsigned int )len);
    }
    if (tmp___75 != 0) {
      goto __Cont;
    }
    cp = (*(names + i)) + len;
    while ((int )(*cp) != 0) {
      tmp___150 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___150) + (int )(*cp))) & 2048)) {
        break;
      }
      cp ++;
    }
    if ((int )(*cp) != 0) {
      goto __Cont;
    }
    exid = (u_int32_t )atol__extinline((char const   *)((*(names + i)) + len));
    __qam_exid(dbp___1, fid, exid);
    switch ((int )op) {
    case 0: 
    snprintf((char * __restrict  )exname, (unsigned int )exlen, (char const   * __restrict  )"%s%s",
             fullname, (*(names + i)) + len);
    t_ret = __memp_nameop(dbenv___0, fid, (char const   *)((void *)0), (char const   *)exname,
                          (char const   *)((void *)0));
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    break;
    case 1: 
    snprintf((char * __restrict  )(nbuf), sizeof(nbuf), (char const   * __restrict  )"%s%c__dbq.%s.%d",
             ndir, (*("/" + 0)), new, exid);
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s%c__dbq.%s.%d",
             qp->dir, (*("/" + 0)), qp->name, exid);
    if (dbp___1->flags & 32768U) {
      tmp___151 = 16;
    } else {
      tmp___151 = 0;
    }
    ret = __fop_rename(dbenv___0, txn, (char const   *)(buf), (char const   *)(nbuf),
                       fid, (enum __anonenum_APPNAME_39 )1, (unsigned int )tmp___151);
    if (ret != 0) {
      goto err;
    }
    break;
    case 2: 
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s%c__dbq.%s.%d",
             qp->dir, (*("/" + 0)), qp->name, exid);
    if (dbp___1->flags & 32768U) {
      tmp___152 = 16;
    } else {
      tmp___152 = 0;
    }
    ret = __fop_remove(dbenv___0, txn, fid, (char const   *)(buf), (enum __anonenum_APPNAME_39 )1,
                       (unsigned int )tmp___152);
    if (ret != 0) {
      goto err;
    }
    break;
    }
    __Cont: 
    i ++;
  }
  err: 
  if ((unsigned int )fullname != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)fullname);
  }
  if ((unsigned int )exname != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)exname);
  }
  if ((unsigned int )namep != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)namep);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-du8gyzRX.i","-O2")
int __db_prpage(DB *dbp___1 , PAGE *h , FILE *fp , u_int32_t flags ) ;
int __qam_db_create(DB *dbp___1 ) ;
int __qam_db_close(DB *dbp___1 , u_int32_t flags ) ;
int __db_prqueue(DB *dbp___1 , FILE *fp , u_int32_t flags ) ;
int __qam_remove(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                 DB_LSN *lsnp ) ;
int __qam_rename(DB *dbp___1 , DB_TXN *txn , char const   *filename , char const   *subdb ,
                 char const   *newname ) ;
void __txn_remlock(DB_ENV *dbenv___0 , DB_TXN *txn , DB_LOCK *lock , u_int32_t locker ) ;
static int __qam_get_extentsize(DB *dbp___1 , u_int32_t *q_extentsizep ) ;
static int __qam_set_extentsize(DB *dbp___1 , u_int32_t extentsize ) ;
int __qam_db_create(DB *dbp___1 ) 
{ QUEUE *t ;
  int ret ;

  {
  ret = __os_calloc(dbp___1->dbenv, 1U, sizeof(QUEUE ), (void *)(& t));
  if (ret != 0) {
    return (ret);
  }
  dbp___1->q_internal = (void *)t;
  dbp___1->get_q_extentsize = & __qam_get_extentsize;
  dbp___1->set_q_extentsize = & __qam_set_extentsize;
  t->re_pad = ' ';
  return (0);
}
}
int __qam_db_close(DB *dbp___1 , u_int32_t flags ) 
{ DB_MPOOLFILE *mpf ;
  MPFARRAY *array ;
  QUEUE *t ;
  struct __qmpf *mpfp ;
  u_int32_t i ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  ret = 0;
  t = (QUEUE *)dbp___1->q_internal;
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    return (0);
  }
  array = & t->array1;
  again: 
  mpfp = array->mpfarray;
  if ((unsigned int )mpfp != (unsigned int )((void *)0)) {
    i = array->low_extent;
    while (i <= array->hi_extent) {
      mpf = mpfp->mpf;
      mpfp->mpf = (DB_MPOOLFILE *)((void *)0);
      if ((unsigned int )mpf != (unsigned int )((void *)0)) {
        if (flags & 256U) {
          tmp = 4;
        } else {
          tmp = 0;
        }
        t_ret = __memp_fclose(mpf, (unsigned int )tmp);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
      }
      i ++;
      mpfp ++;
    }
    __os_free(dbp___1->dbenv, (void *)array->mpfarray);
  }
  if (t->array2.n_extent != 0U) {
    array = & t->array2;
    array->n_extent = 0U;
    goto again;
  }
  if (flags & 256U) {
    t_ret = __qam_nameop(dbp___1, (DB_TXN *)((void *)0), (char const   *)((void *)0),
                         (enum __anonenum_qam_name_op_78 )0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )t->path != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)t->path);
  }
  __os_free(dbp___1->dbenv, (void *)t);
  dbp___1->q_internal = (void *)0;
  return (ret);
}
}
static int __qam_get_extentsize(DB *dbp___1 , u_int32_t *q_extentsizep ) 
{ 

  {
  (*q_extentsizep) = ((QUEUE *)dbp___1->q_internal)->page_ext;
  return (0);
}
}
static int __qam_set_extentsize(DB *dbp___1 , u_int32_t extentsize ) 
{ int tmp ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_extentsize", 1);
    return (tmp);
  }
  if (extentsize < 1U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "Extent size must be at least 1");
    return (22);
  }
  ((QUEUE *)dbp___1->q_internal)->page_ext = extentsize;
  return (0);
}
}
int __db_prqueue(DB *dbp___1 , FILE *fp , u_int32_t flags ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  QMETA *meta ;
  db_pgno_t first ;
  db_pgno_t i ;
  db_pgno_t last ;
  db_pgno_t pg_ext ;
  db_pgno_t stop ;
  int ret ;
  int t_ret ;

  {
  mpf = dbp___1->mpf;
  i = 0U;
  ret = __memp_fget(mpf, & i, 0U, (void *)(& meta));
  if (ret != 0) {
    return (ret);
  }
  first = ((QUEUE *)dbp___1->q_internal)->q_root + (meta->first_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  last = ((QUEUE *)dbp___1->q_internal)->q_root + (meta->cur_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  ret = __db_prpage(dbp___1, (PAGE *)meta, fp, flags);
  t_ret = __memp_fput(mpf, (void *)meta, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret != 0) {
    return (ret);
  }
  i = first;
  if (first > last) {
    stop = ((QUEUE *)dbp___1->q_internal)->q_root + 4294967294U / ((QUEUE *)dbp___1->q_internal)->rec_page;
  } else {
    stop = last;
  }
  begin: 
  while (i <= stop) {
    ret = __qam_fprobe(dbp___1, i, (void *)(& h), (enum __anonenum_qam_probe_mode_80 )0,
                       0U);
    if (ret != 0) {
      pg_ext = ((QUEUE *)dbp___1->q_internal)->page_ext;
      if (pg_ext == 0U) {
        if (ret == -30988) {
          if (first == last) {
            return (0);
          }
        }
        return (ret);
      }
      if (ret == 2) {
        i += (pg_ext - (i - 1U) % pg_ext) - 1U;
        goto __Cont;
      } else {
        if (ret == -30988) {
          i += (pg_ext - (i - 1U) % pg_ext) - 1U;
          goto __Cont;
        }
      }
      return (ret);
    }
    __db_prpage(dbp___1, h, fp, flags);
    ret = __qam_fprobe(dbp___1, i, (void *)h, (enum __anonenum_qam_probe_mode_80 )1,
                       0U);
    if (ret != 0) {
      return (ret);
    }
    __Cont: 
    i ++;
  }
  if (first > last) {
    i = 1U;
    stop = last;
    first = last;
    goto begin;
  }
  return (0);
}
}
int __qam_remove(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                 DB_LSN *lsnp ) 
{ DB_ENV *dbenv___0 ;
  DB *tmpdbp ;
  QUEUE *qp ;
  int ret ;
  int needclose ;
  int t_ret ;
  int tmp ;

  {
  lsnp = (DB_LSN *)((void *)0);
  lsnp = lsnp;
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  needclose = 0;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )subdb != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Queue does not support multiple databases per file");
    ret = 22;
    goto err;
  }
  if (dbp___1->flags & 65536U) {
    tmpdbp = dbp___1;
  } else {
    ret = db_create(& tmpdbp, dbenv___0, 0U);
    if (ret != 0) {
      return (ret);
    }
    tmpdbp->lid = dbp___1->lid;
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      needclose = 1;
    }
    ret = __db_open(tmpdbp, txn, name, (char const   *)((void *)0), (enum __anonenum_DBTYPE_61 )4,
                    0U, 0, 0U);
    if (ret != 0) {
      goto err;
    }
    needclose = 1;
  }
  qp = (QUEUE *)tmpdbp->q_internal;
  if (qp->page_ext != 0U) {
    ret = __qam_nameop(tmpdbp, txn, (char const   *)((void *)0), (enum __anonenum_qam_name_op_78 )2);
  }
  err: 
  if (needclose) {
    tmpdbp->lid = 0U;
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      __txn_remlock(dbenv___0, txn, & tmpdbp->handle_lock, 0U);
    }
    t_ret = __db_close(tmpdbp, txn, 23U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __qam_rename(DB *dbp___1 , DB_TXN *txn , char const   *filename , char const   *subdb ,
                 char const   *newname ) 
{ DB_ENV *dbenv___0 ;
  DB *tmpdbp ;
  QUEUE *qp ;
  int ret ;
  int needclose ;
  int t_ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  needclose = 0;
  if ((unsigned int )subdb != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Queue does not support multiple databases per file");
    ret = 22;
    goto err;
  }
  if (dbp___1->flags & 65536U) {
    tmpdbp = dbp___1;
  } else {
    ret = db_create(& tmpdbp, dbenv___0, 0U);
    if (ret != 0) {
      return (ret);
    }
    tmpdbp->lid = dbp___1->lid;
    needclose = 1;
    ret = __db_open(tmpdbp, txn, filename, (char const   *)((void *)0), (enum __anonenum_DBTYPE_61 )4,
                    0U, 0, 0U);
    if (ret != 0) {
      goto err;
    }
  }
  qp = (QUEUE *)tmpdbp->q_internal;
  if (qp->page_ext != 0U) {
    ret = __qam_nameop(tmpdbp, txn, newname, (enum __anonenum_qam_name_op_78 )1);
  }
  err: 
  if (needclose) {
    tmpdbp->lid = 0U;
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      __txn_remlock(dbenv___0, txn, & tmpdbp->handle_lock, 0U);
    }
    t_ret = __db_close(tmpdbp, txn, 23U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-8aYXNpEB.i","-O2")
int __db_omode(char const   *perm ) ;
int __qam_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               int mode , u_int32_t flags ) ;
int __qam_set_ext_data(DB *dbp___1 , char const   *name ) ;
int __qam_metachk(DB *dbp___1 , char const   *name , QMETA *qmeta ) ;
int __qam_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) ;
static int __qam_init_meta(DB *dbp___1 , QMETA *meta ) ;
int __qam_open(DB *dbp___1 , DB_TXN *txn , char const   *name , db_pgno_t base_pgno ,
               int mode , u_int32_t flags ) 
{ DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  QMETA *qmeta ;
  QUEUE *t ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  t = (QUEUE *)dbp___1->q_internal;
  ret = 0;
  qmeta = (QMETA *)((void *)0);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    if (t->page_ext != 0U) {
      __db_err((DB_ENV const   *)dbenv___0, "Extent size may not be specified for in-memory queue database");
      return (22);
    }
  }
  dbp___1->db_am_remove = & __qam_remove;
  dbp___1->db_am_rename = & __qam_rename;
  if (flags & 1U) {
    if (dbenv___0->flags & 2U) {
      tmp = 35;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ret = __db_cursor(dbp___1, txn, & dbc, (unsigned int )tmp);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_lget(dbc, 0, base_pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & base_pgno, 0U, (void *)(& qmeta));
  if (ret != 0) {
    goto err;
  }
  if (qmeta->dbmeta.magic != 270931U) {
    __db_err((DB_ENV const   *)dbenv___0, "%s: unexpected file type or format", name);
    ret = 22;
    goto err;
  }
  t->page_ext = qmeta->page_ext;
  if (t->page_ext != 0U) {
    ret = __qam_set_ext_data(dbp___1, name);
    if (ret != 0) {
      goto err;
    }
  }
  if (mode == 0) {
    mode = __db_omode("rwrw--");
  }
  t->mode = mode;
  t->re_pad = (int )qmeta->re_pad;
  t->re_len = qmeta->re_len;
  t->rec_page = qmeta->rec_page;
  t->q_meta = base_pgno;
  t->q_root = base_pgno + 1U;
  err: 
  if ((unsigned int )qmeta != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)qmeta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (metalock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & metalock);
  }
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __qam_set_ext_data(DB *dbp___1 , char const   *name ) 
{ QUEUE *t ;
  int ret ;
  char *tmp ;

  {
  t = (QUEUE *)dbp___1->q_internal;
  t->pginfo.db_pagesize = dbp___1->pgsize;
  t->pginfo.flags = dbp___1->flags & 268437505U;
  t->pginfo.type = dbp___1->type;
  t->pgcookie.data = (void *)(& t->pginfo);
  t->pgcookie.size = sizeof(DB_PGINFO );
  ret = __os_strdup(dbp___1->dbenv, name, (void *)(& t->path));
  if (ret != 0) {
    return (ret);
  }
  t->dir = t->path;
  t->name = __db_rpath((char const   *)t->path);
  if ((unsigned int )t->name == (unsigned int )((void *)0)) {
    t->name = t->path;
    t->dir = (char *)".";
  } else {
    tmp = t->name;
    t->name = t->name + 1;
    (*tmp) = (char )'\000';
  }
  return (0);
}
}
int __qam_metachk(DB *dbp___1 , char const   *name , QMETA *qmeta ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t vers ;
  int ret ;
  u_int32_t _tmp ;
  int __ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  vers = qmeta->dbmeta.version;
  if (dbp___1->flags & 268435456U) {
    _tmp = vers;
    (*((u_int8_t *)(& vers) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
    (*((u_int8_t *)(& vers) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
    (*((u_int8_t *)(& vers) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
    (*((u_int8_t *)(& vers) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  }
  switch ((int )vers) {
  case 1: ;
  case 2: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: queue version %lu requires a version upgrade",
           name, (unsigned long )vers);
  return (-30989);
  case 3: ;
  case 4: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unsupported qam version: %lu", name,
           (unsigned long )vers);
  return (22);
  }
  if (dbp___1->flags & 268435456U) {
    ret = __qam_mswap((PAGE *)qmeta);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((int )dbp___1->type != 4) {
    if ((int )dbp___1->type != 5) {
      return (22);
    }
  }
  dbp___1->type = (enum __anonenum_DBTYPE_61 )4;
  __ret = __dbh_am_chk(dbp___1, 4U);
  if (__ret != 0) {
    return (__ret);
  }
  dbp___1->pgsize = qmeta->dbmeta.pagesize;
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(qmeta->dbmeta.uid),
         20U);
  dbp___1->db_am_rename = & __qam_rename;
  dbp___1->db_am_remove = & __qam_remove;
  return (ret);
}
}
static int __qam_init_meta(DB *dbp___1 , QMETA *meta ) 
{ QUEUE *t ;
  int tmp___0 ;

  {
  t = (QUEUE *)dbp___1->q_internal;
  memset((void *)meta, 0, sizeof(QMETA ));
  while (1) {
    meta->dbmeta.lsn.file = 0U;
    meta->dbmeta.lsn.offset = 1U;
    break;
  }
  meta->dbmeta.pgno = 0U;
  meta->dbmeta.last_pgno = 0U;
  meta->dbmeta.magic = 270931U;
  meta->dbmeta.version = 4U;
  meta->dbmeta.pagesize = dbp___1->pgsize;
  if (dbp___1->flags & 1U) {
    meta->dbmeta.metaflags = (unsigned char )((int )meta->dbmeta.metaflags | 1);
  }
  if (dbp___1->flags & 2048U) {
    meta->dbmeta.encrypt_alg = ((DB_CIPHER *)(dbp___1->dbenv)->crypto_handle)->alg;
    meta->crypto_magic = meta->dbmeta.magic;
  }
  meta->dbmeta.type = (unsigned char)10;
  meta->re_pad = (unsigned int )t->re_pad;
  meta->re_len = t->re_len;
  if (dbp___1->flags & 2048U) {
    tmp___0 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = 48;
    } else {
      tmp___0 = 28;
    }
  }
  meta->rec_page = (unsigned int )((unsigned long long )(dbp___1->pgsize - (unsigned int )tmp___0) /
                                   (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                       (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                      (unsigned long long )sizeof(u_int32_t )) - 1ULL) &
                                    ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL)));
  meta->cur_recno = 1U;
  meta->first_recno = 1U;
  meta->page_ext = t->page_ext;
  t->rec_page = meta->rec_page;
  memcpy((void * __restrict  )(meta->dbmeta.uid), (void const   * __restrict  )(dbp___1->fileid),
         20U);
  if (((QUEUE *)dbp___1->q_internal)->rec_page < 1U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "Record size of %lu too large for page size of %lu",
             (unsigned long )t->re_len, (unsigned long )dbp___1->pgsize);
    return (22);
  }
  return (0);
}
}
int __qam_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) 
{ QMETA *meta ;
  DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  DB_PGINFO pginfo ;
  DBT pdbt ;
  db_pgno_t pgno ;
  int ret ;
  void *buf ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  buf = (void *)0;
  meta = (QMETA *)((void *)0);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    pgno = 0U;
    ret = __memp_fget(mpf, & pgno, 1U, (void *)(& meta));
  } else {
    ret = __os_calloc(dbp___1->dbenv, 1U, dbp___1->pgsize, (void *)(& buf));
    meta = (QMETA *)buf;
  }
  if (ret != 0) {
    return (ret);
  }
  ret = __qam_init_meta(dbp___1, meta);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    ret = __memp_fput(mpf, (void *)meta, 2U);
  } else {
    pginfo.db_pagesize = dbp___1->pgsize;
    pginfo.flags = dbp___1->flags & 268437505U;
    pginfo.type = (enum __anonenum_DBTYPE_61 )4;
    pdbt.data = (void *)(& pginfo);
    pdbt.size = sizeof(pginfo);
    ret = __db_pgout(dbenv___0, 0U, (void *)meta, & pdbt);
    if (ret != 0) {
      goto err;
    }
    if (dbp___1->flags & 32768U) {
      tmp = 16;
    } else {
      tmp = 0;
    }
    ret = __fop_write(dbenv___0, txn, name, (enum __anonenum_APPNAME_39 )1, fhp, dbp___1->pgsize,
                      0U, 0U, (u_int8_t *)buf, dbp___1->pgsize, 1U, (unsigned int )tmp);
  }
  if (ret != 0) {
    goto err;
  }
  meta = (QMETA *)((void *)0);
  err: 
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, buf);
  } else {
    if ((unsigned int )meta != (unsigned int )((void *)0)) {
      __memp_fput(mpf, (void *)meta, 0U);
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-JCkJmCDI.i","-O2")
int __qam_incfirst_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                           void *info ) 
{ __qam_incfirst_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_LOCK lock ;
  DB_LSN trunc_lsn ;
  DB_MPOOLFILE *mpf ;
  QMETA *meta ;
  QUEUE_CURSOR *cp ;
  db_pgno_t metapg ;
  int exact ;
  int modified ;
  int ret ;
  int rec_ext ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __t_ret ;

  {
  while (1) {
    argp = (__qam_incfirst_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __qam_incfirst_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  metapg = ((QUEUE *)file_dbp->q_internal)->q_meta;
  ret = __db_lget(dbc, 5, metapg, (enum __anonenum_db_lockmode_t_50 )2, 0U, & lock);
  if (ret != 0) {
    goto done;
  }
  ret = __memp_fget(mpf, & metapg, 0U, (void *)(& meta));
  if (ret != 0) {
    if ((int )op == 4) {
      goto _L;
    } else {
      if ((int )op == 1) {
        _L: 
        ret = __memp_fget(mpf, & metapg, 1U, (void *)(& meta));
        if (ret != 0) {
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          goto out;
        }
        meta->dbmeta.pgno = metapg;
        meta->dbmeta.type = (unsigned char)10;
      } else {
        (*lsnp) = argp->prev_lsn;
        ret = 0;
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        goto out;
      }
    }
  }
  modified = 0;
  if ((int )op == 0) {
    goto _L___0;
  } else {
    if ((int )op == 3) {
      goto _L___0;
    } else {
      if ((int )op == 2) {
        _L___0: 
        if (argp->recno < meta->first_recno) {
          if (meta->first_recno <= meta->cur_recno) {
            meta->first_recno = argp->recno;
            modified = 1;
          } else {
            if (argp->recno > meta->cur_recno) {
              if (argp->recno - meta->cur_recno > meta->first_recno - argp->recno) {
                meta->first_recno = argp->recno;
                modified = 1;
              }
            }
          }
        }
        trunc_lsn = ((DB_TXNHEAD *)info)->trunc_lsn;
        if (! (trunc_lsn.file == 0U)) {
          tmp = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& trunc_lsn));
          if (tmp > 0) {
            ((PAGE *)meta)->lsn = trunc_lsn;
            modified = 1;
          }
        }
      } else {
        tmp___0 = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)lsnp);
        if (tmp___0 < 0) {
          ((PAGE *)meta)->lsn = (*lsnp);
          modified = 1;
        }
        rec_ext = 0;
        if (meta->page_ext != 0U) {
          rec_ext = (int )(meta->page_ext * meta->rec_page);
        }
        cp = (QUEUE_CURSOR *)dbc->internal;
        if (meta->first_recno == 0U) {
          meta->first_recno = meta->first_recno + 1U;
        }
        while (1) {
          if (meta->first_recno != meta->cur_recno) {
            if (argp->recno + 1U < meta->first_recno) {
              if (meta->first_recno <= meta->cur_recno) {
                break;
              } else {
                if (argp->recno + 1U > meta->cur_recno) {
                  if ((argp->recno + 1U) - meta->cur_recno > meta->first_recno - (argp->recno +
                                                                                  1U)) {
                    break;
                  }
                }
              }
            }
          } else {
            break;
          }
          ret = __qam_position(dbc, & meta->first_recno, (enum __anonenum_qam_position_mode_79 )0,
                               & exact);
          if (ret != 0) {
            goto err;
          }
          if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
            __qam_fprobe(file_dbp, cp->pgno, cp->page, (enum __anonenum_qam_probe_mode_80 )1,
                         0U);
          }
          if (exact == 1) {
            break;
          }
          if ((unsigned int )cp->page != (unsigned int )((void *)0)) {
            if (rec_ext != 0) {
              if (meta->first_recno % (unsigned int )rec_ext == 0U) {
                ret = __qam_fremove(file_dbp, cp->pgno);
                if (ret != 0) {
                  goto err;
                }
              }
            }
          }
          meta->first_recno = meta->first_recno + 1U;
          if (meta->first_recno == 0U) {
            meta->first_recno = meta->first_recno + 1U;
          }
          modified = 1;
        }
      }
    }
  }
  if (modified) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___1);
  if (ret != 0) {
    goto err1;
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  if (0) {
    err: 
    __memp_fput(mpf, (void *)meta, 0U);
    err1: 
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
  }
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __qam_mvptr_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __qam_mvptr_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_LSN trunc_lsn ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  QMETA *meta ;
  db_pgno_t metapg ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __t_ret ;

  {
  while (1) {
    argp = (__qam_mvptr_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __qam_mvptr_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  metapg = ((QUEUE *)file_dbp->q_internal)->q_meta;
  ret = __db_lget(dbc, 5, metapg, (enum __anonenum_db_lockmode_t_50 )2, 0U, & lock);
  if (ret != 0) {
    goto done;
  }
  ret = __memp_fget(mpf, & metapg, 0U, (void *)(& meta));
  if (ret != 0) {
    if ((int )op == 4) {
      goto _L;
    } else {
      if ((int )op == 1) {
        _L: 
        ret = __memp_fget(mpf, & metapg, 1U, (void *)(& meta));
        if (ret != 0) {
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          goto out;
        }
        meta->dbmeta.pgno = metapg;
        meta->dbmeta.type = (unsigned char)10;
      } else {
        (*lsnp) = argp->prev_lsn;
        ret = 0;
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        goto out;
      }
    }
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& argp->metalsn));
  if ((int )op == 0) {
    goto _L___1;
  } else {
    if ((int )op == 3) {
      goto _L___1;
    } else {
      if ((int )op == 2) {
        _L___1: 
        if (argp->opcode & 4U) {
          if (cmp_n <= 0) {
            meta->first_recno = argp->old_first;
            meta->cur_recno = argp->old_cur;
            ((PAGE *)meta)->lsn = argp->metalsn;
            modified = 1;
          }
        }
        trunc_lsn = ((DB_TXNHEAD *)info)->trunc_lsn;
        if (! (trunc_lsn.file == 0U)) {
          tmp = log_compare((DB_LSN const   *)(& trunc_lsn), (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
          if (tmp < 0) {
            ((PAGE *)meta)->lsn = argp->metalsn;
            modified = 1;
          }
        }
      } else {
        if ((int )op == 1) {
          goto _L___0;
        } else {
          if (cmp_p == 0) {
            _L___0: 
            if (argp->opcode & 1U) {
              meta->first_recno = argp->new_first;
            }
            if (argp->opcode & 2U) {
              meta->cur_recno = argp->new_cur;
            }
            modified = 1;
            meta->dbmeta.lsn = (*lsnp);
          }
        }
      }
    }
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __qam_del_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) 
{ __qam_del_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  QAMDATA *qp ;
  QMETA *meta ;
  QPAGE *pagep ;
  db_pgno_t metapg ;
  int cmp_n ;
  int modified ;
  int ret ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__qam_del_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __qam_del_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __qam_fprobe(file_dbp, argp->pgno, (void *)(& pagep), (enum __anonenum_qam_probe_mode_80 )0,
                     1U);
  if (ret != 0) {
    goto out;
  }
  modified = 0;
  if (pagep->pgno == 0U) {
    pagep->pgno = argp->pgno;
    pagep->type = (unsigned char)11;
    modified = 1;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)pagep)->lsn));
  if ((int )op == 0) {
    goto _L___2;
  } else {
    if ((int )op == 3) {
      goto _L___2;
    } else {
      if ((int )op == 2) {
        _L___2: 
        metapg = ((QUEUE *)file_dbp->q_internal)->q_meta;
        ret = __db_lget(dbc, 5, metapg, (enum __anonenum_db_lockmode_t_50 )2, 0U,
                        & lock);
        if (ret != 0) {
          goto err;
        }
        ret = __memp_fget(mpf, & metapg, 0U, (void *)(& meta));
        if (ret != 0) {
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          goto err;
        }
        if (meta->first_recno == 0U) {
          meta->first_recno = argp->recno;
          __memp_fput(mpf, (void *)meta, 2U);
        } else {
          if (argp->recno < meta->first_recno) {
            if (meta->first_recno <= meta->cur_recno) {
              goto _L;
            } else {
              if (argp->recno > meta->cur_recno) {
                if (argp->recno - meta->cur_recno > meta->first_recno - argp->recno) {
                  _L: 
                  if (meta->first_recno <= meta->cur_recno) {
                    meta->first_recno = argp->recno;
                    __memp_fput(mpf, (void *)meta, 2U);
                  } else {
                    if (meta->first_recno - argp->recno < argp->recno - meta->cur_recno) {
                      meta->first_recno = argp->recno;
                      __memp_fput(mpf, (void *)meta, 2U);
                    } else {
                      __memp_fput(mpf, (void *)meta, 0U);
                    }
                  }
                } else {
                  __memp_fput(mpf, (void *)meta, 0U);
                }
              } else {
                __memp_fput(mpf, (void *)meta, 0U);
              }
            }
          } else {
            __memp_fput(mpf, (void *)meta, 0U);
          }
        }
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        if (file_dbp->flags & 2048U) {
          tmp___0 = 64;
        } else {
          if (file_dbp->flags & 1U) {
            tmp___0 = 48;
          } else {
            tmp___0 = 28;
          }
        }
        qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___0 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                                 (unsigned long long )((QUEUE *)file_dbp->q_internal)->re_len) +
                                                                                (unsigned long long )sizeof(u_int32_t )) -
                                                                               1ULL) &
                                                                              ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL)) *
                                                                             (unsigned long long )argp->indx));
        qp->flags = (unsigned char )((int )qp->flags | 1);
        if ((int )op == 3) {
          if (cmp_n <= 0) {
            ((PAGE *)pagep)->lsn = argp->lsn;
          }
        }
        modified = 1;
      } else {
        if ((int )op == 1) {
          goto _L___1;
        } else {
          if (cmp_n > 0) {
            if ((int )op == 4) {
              goto _L___1;
            } else {
              if ((int )op == 1) {
                _L___1: 
                if (file_dbp->flags & 2048U) {
                  tmp___2 = 64;
                } else {
                  if (file_dbp->flags & 1U) {
                    tmp___2 = 48;
                  } else {
                    tmp___2 = 28;
                  }
                }
                qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___2 +
                                                      (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                          (unsigned long long )((QUEUE *)file_dbp->q_internal)->re_len) +
                                                         (unsigned long long )sizeof(u_int32_t )) -
                                                        1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)) * (unsigned long long )argp->indx));
                qp->flags = (unsigned char )((int )qp->flags & -2);
                ((PAGE *)pagep)->lsn = (*lsnp);
                modified = 1;
              }
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp___3 = 2;
  } else {
    tmp___3 = 0;
  }
  ret = __qam_fprobe(file_dbp, argp->pgno, (void *)pagep, (enum __anonenum_qam_probe_mode_80 )1,
                     (unsigned int )tmp___3);
  if (ret != 0) {
    goto out;
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  if (0) {
    err: 
    __qam_fprobe(file_dbp, argp->pgno, (void *)pagep, (enum __anonenum_qam_probe_mode_80 )1,
                 0U);
  }
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __qam_delext_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __qam_delext_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  QAMDATA *qp ;
  QMETA *meta ;
  QPAGE *pagep ;
  db_pgno_t metapg ;
  int cmp_n ;
  int modified ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__qam_delext_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __qam_delext_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __qam_fprobe(file_dbp, argp->pgno, (void *)(& pagep), (enum __anonenum_qam_probe_mode_80 )0,
                     0U);
  if (ret != 0) {
    if (ret != -30988) {
      if (ret != 2) {
        goto out;
      }
    }
    if ((int )op == 4) {
      goto done;
    } else {
      if ((int )op == 1) {
        goto done;
      }
    }
    ret = __qam_fprobe(file_dbp, argp->pgno, (void *)(& pagep), (enum __anonenum_qam_probe_mode_80 )0,
                       1U);
    if (ret != 0) {
      goto out;
    }
  }
  modified = 0;
  if (pagep->pgno == 0U) {
    pagep->pgno = argp->pgno;
    pagep->type = (unsigned char)11;
    modified = 1;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)pagep)->lsn));
  if ((int )op == 0) {
    goto _L___2;
  } else {
    if ((int )op == 3) {
      goto _L___2;
    } else {
      if ((int )op == 2) {
        _L___2: 
        metapg = ((QUEUE *)file_dbp->q_internal)->q_meta;
        ret = __db_lget(dbc, 5, metapg, (enum __anonenum_db_lockmode_t_50 )2, 0U,
                        & lock);
        if (ret != 0) {
          goto err;
        }
        ret = __memp_fget(mpf, & metapg, 0U, (void *)(& meta));
        if (ret != 0) {
          if (lock.off != 0U) {
            __lock_put((dbc->dbp)->dbenv, & lock);
          }
          goto err;
        }
        if (meta->first_recno == 0U) {
          meta->first_recno = argp->recno;
          __memp_fput(mpf, (void *)meta, 2U);
        } else {
          if (argp->recno < meta->first_recno) {
            if (meta->first_recno <= meta->cur_recno) {
              goto _L;
            } else {
              if (argp->recno > meta->cur_recno) {
                if (argp->recno - meta->cur_recno > meta->first_recno - argp->recno) {
                  _L: 
                  if (meta->first_recno <= meta->cur_recno) {
                    meta->first_recno = argp->recno;
                    __memp_fput(mpf, (void *)meta, 2U);
                  } else {
                    if (meta->first_recno - argp->recno < argp->recno - meta->cur_recno) {
                      meta->first_recno = argp->recno;
                      __memp_fput(mpf, (void *)meta, 2U);
                    } else {
                      __memp_fput(mpf, (void *)meta, 0U);
                    }
                  }
                } else {
                  __memp_fput(mpf, (void *)meta, 0U);
                }
              } else {
                __memp_fput(mpf, (void *)meta, 0U);
              }
            }
          } else {
            __memp_fput(mpf, (void *)meta, 0U);
          }
        }
        if (lock.off != 0U) {
          __lock_put((dbc->dbp)->dbenv, & lock);
        }
        ret = __qam_pitem(dbc, pagep, argp->indx, argp->recno, & argp->data);
        if (ret != 0) {
          goto err;
        }
        if ((int )op == 3) {
          if (cmp_n <= 0) {
            ((PAGE *)pagep)->lsn = argp->lsn;
          }
        }
        modified = 1;
      } else {
        if ((int )op == 1) {
          goto _L___1;
        } else {
          if (cmp_n > 0) {
            if ((int )op == 4) {
              goto _L___1;
            } else {
              if ((int )op == 1) {
                _L___1: 
                if (file_dbp->flags & 2048U) {
                  tmp___0 = 64;
                } else {
                  if (file_dbp->flags & 1U) {
                    tmp___0 = 48;
                  } else {
                    tmp___0 = 28;
                  }
                }
                qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___0 +
                                                      (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                          (unsigned long long )((QUEUE *)file_dbp->q_internal)->re_len) +
                                                         (unsigned long long )sizeof(u_int32_t )) -
                                                        1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)) * (unsigned long long )argp->indx));
                qp->flags = (unsigned char )((int )qp->flags & -2);
                ((PAGE *)pagep)->lsn = (*lsnp);
                modified = 1;
              }
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  ret = __qam_fprobe(file_dbp, argp->pgno, (void *)pagep, (enum __anonenum_qam_probe_mode_80 )1,
                     (unsigned int )tmp___1);
  if (ret != 0) {
    goto out;
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  if (0) {
    err: 
    __qam_fprobe(file_dbp, argp->pgno, (void *)pagep, (enum __anonenum_qam_probe_mode_80 )1,
                 0U);
  }
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __qam_add_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) 
{ __qam_add_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  QAMDATA *qp ;
  QMETA *meta ;
  QPAGE *pagep ;
  db_pgno_t metapg ;
  int cmp_n ;
  int meta_dirty ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__qam_add_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __qam_add_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  modified = 0;
  ret = __qam_fprobe(file_dbp, argp->pgno, (void *)(& pagep), (enum __anonenum_qam_probe_mode_80 )0,
                     0U);
  if (ret != 0) {
    if (ret != -30988) {
      if (ret != 2) {
        goto out;
      }
    }
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __qam_fprobe(file_dbp, argp->pgno, (void *)(& pagep), (enum __anonenum_qam_probe_mode_80 )0,
                       1U);
    if (ret != 0) {
      goto out;
    }
  }
  if (pagep->pgno == 0U) {
    pagep->pgno = argp->pgno;
    pagep->type = (unsigned char)11;
    modified = 1;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)pagep)->lsn));
  if ((int )op == 4) {
    goto _L___1;
  } else {
    if ((int )op == 1) {
      _L___1: 
      metapg = ((QUEUE *)file_dbp->q_internal)->q_meta;
      ret = __memp_fget(mpf, & metapg, 0U, (void *)(& meta));
      if (ret != 0) {
        goto err;
      }
      meta_dirty = 0;
      if (argp->recno < meta->first_recno) {
        if (meta->first_recno <= meta->cur_recno) {
          meta->first_recno = argp->recno;
          meta_dirty = 1;
        } else {
          if (argp->recno > meta->cur_recno) {
            if (argp->recno - meta->cur_recno > meta->first_recno - argp->recno) {
              meta->first_recno = argp->recno;
              meta_dirty = 1;
            }
          }
        }
      }
      if (argp->recno == meta->cur_recno) {
        meta->cur_recno = argp->recno + 1U;
        meta_dirty = 1;
      } else {
        if (argp->recno > meta->cur_recno) {
          if (meta->first_recno <= meta->cur_recno) {
            meta->cur_recno = argp->recno + 1U;
            meta_dirty = 1;
          } else {
            if (argp->recno < meta->first_recno) {
              if (argp->recno - meta->cur_recno < meta->first_recno - argp->recno) {
                meta->cur_recno = argp->recno + 1U;
                meta_dirty = 1;
              }
            }
          }
        }
      }
      if (meta_dirty) {
        tmp = 2;
      } else {
        tmp = 0;
      }
      ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp);
      if (ret != 0) {
        goto err;
      }
      if ((int )op == 1) {
        goto _L;
      } else {
        if (cmp_n > 0) {
          _L: 
          ret = __qam_pitem(dbc, pagep, argp->indx, argp->recno, & argp->data);
          if (ret != 0) {
            goto err;
          }
          ((PAGE *)pagep)->lsn = (*lsnp);
          modified = 1;
        }
      }
    } else {
      if ((int )op == 0) {
        goto _L___0;
      } else {
        if ((int )op == 3) {
          goto _L___0;
        } else {
          if ((int )op == 2) {
            _L___0: 
            if (argp->olddata.size != 0U) {
              ret = __qam_pitem(dbc, pagep, argp->indx, argp->recno, & argp->olddata);
              if (ret != 0) {
                goto err;
              }
              if (! (argp->vflag & 1U)) {
                if (file_dbp->flags & 2048U) {
                  tmp___1 = 64;
                } else {
                  if (file_dbp->flags & 1U) {
                    tmp___1 = 48;
                  } else {
                    tmp___1 = 28;
                  }
                }
                qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___1 +
                                                      (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                          (unsigned long long )((QUEUE *)file_dbp->q_internal)->re_len) +
                                                         (unsigned long long )sizeof(u_int32_t )) -
                                                        1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)) * (unsigned long long )argp->indx));
                qp->flags = (unsigned char )((int )qp->flags & -2);
              }
              modified = 1;
            } else {
              if (file_dbp->flags & 2048U) {
                tmp___3 = 64;
              } else {
                if (file_dbp->flags & 1U) {
                  tmp___3 = 48;
                } else {
                  tmp___3 = 28;
                }
              }
              qp = (QAMDATA *)((u_int8_t *)pagep + ((unsigned long long )tmp___3 +
                                                    (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                        (unsigned long long )((QUEUE *)file_dbp->q_internal)->re_len) +
                                                       (unsigned long long )sizeof(u_int32_t )) -
                                                      1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                 1ULL)) * (unsigned long long )argp->indx));
              qp->flags = (unsigned char)0;
              modified = 1;
            }
            if ((int )op == 3) {
              if (cmp_n <= 0) {
                ((PAGE *)pagep)->lsn = argp->lsn;
              }
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp___4 = 2;
  } else {
    tmp___4 = 0;
  }
  ret = __qam_fprobe(file_dbp, argp->pgno, (void *)pagep, (enum __anonenum_qam_probe_mode_80 )1,
                     (unsigned int )tmp___4);
  if (ret != 0) {
    goto out;
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  if (0) {
    err: 
    __qam_fprobe(file_dbp, argp->pgno, (void *)pagep, (enum __anonenum_qam_probe_mode_80 )1,
                 0U);
  }
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-jPrl9mGY.i","-O2")
int __qam_stat(DBC *dbc , void *spp , u_int32_t flags ) ;
int __qam_stat(DBC *dbc , void *spp , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_LOCK lock ;
  DB_MPOOLFILE *mpf ;
  DB_QUEUE_STAT *sp ;
  PAGE *h ;
  QAMDATA *qp ;
  QAMDATA *ep ;
  QMETA *meta ;
  QUEUE *t ;
  db_indx_t indx ;
  db_pgno_t first ;
  db_pgno_t last ;
  db_pgno_t pgno ;
  db_pgno_t pg_ext ;
  db_pgno_t stop ;
  u_int32_t re_len ;
  int ret ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  dbp___1 = dbc->dbp;
  lock.off = 0U;
  mpf = dbp___1->mpf;
  sp = (DB_QUEUE_STAT *)((void *)0);
  t = (QUEUE *)dbp___1->q_internal;
  if ((unsigned int )spp == (unsigned int )((void *)0)) {
    return (0);
  }
  ret = __os_umalloc(dbp___1->dbenv, sizeof((*sp)), (void *)(& sp));
  if (ret != 0) {
    goto err;
  }
  memset((void *)sp, 0, sizeof((*sp)));
  re_len = ((QUEUE *)dbp___1->q_internal)->re_len;
  ret = __db_lget(dbc, 0, t->q_meta, (enum __anonenum_db_lockmode_t_50 )1, 0U, & lock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & t->q_meta, 0U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  if (flags == 8U) {
    sp->qs_nkeys = meta->dbmeta.key_count;
    sp->qs_ndata = meta->dbmeta.record_count;
    goto meta_only;
  } else {
    if (flags == 4U) {
      sp->qs_nkeys = meta->dbmeta.key_count;
      sp->qs_ndata = meta->dbmeta.record_count;
      goto meta_only;
    }
  }
  first = ((QUEUE *)dbp___1->q_internal)->q_root + (meta->first_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  last = ((QUEUE *)dbp___1->q_internal)->q_root + (meta->cur_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  ret = __memp_fput(mpf, (void *)meta, 0U);
  if (ret != 0) {
    goto err;
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  pgno = first;
  if (first > last) {
    stop = ((QUEUE *)dbp___1->q_internal)->q_root + 4294967294U / ((QUEUE *)dbp___1->q_internal)->rec_page;
  } else {
    stop = last;
  }
  pg_ext = ((QUEUE *)dbp___1->q_internal)->page_ext;
  begin: 
  while (pgno <= stop) {
    ret = __db_lget(dbc, 0, pgno, (enum __anonenum_db_lockmode_t_50 )1, 0U, & lock);
    if (ret != 0) {
      goto err;
    }
    ret = __qam_fprobe(dbp___1, pgno, (void *)(& h), (enum __anonenum_qam_probe_mode_80 )0,
                       0U);
    if (ret == 2) {
      pgno += pg_ext - 1U;
      goto __Cont;
    }
    if (ret == -30988) {
      if (pg_ext == 0U) {
        if (pgno != stop) {
          if (first != last) {
            goto err;
          }
        }
        ret = 0;
        break;
      }
      pgno += (pg_ext - (pgno - 1U) % pg_ext) - 1U;
      goto __Cont;
    }
    if (ret != 0) {
      goto err;
    }
    sp->qs_pages ++;
    ep = (QAMDATA *)(((u_int8_t *)h + dbp___1->pgsize) - re_len);
    indx = (unsigned short)0;
    if (dbp___1->flags & 2048U) {
      tmp___0 = 64;
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = 48;
      } else {
        tmp___0 = 28;
      }
    }
    qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___0 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                         (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                        (unsigned long long )sizeof(u_int32_t )) -
                                                                       1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) *
                                                                     (unsigned long long )indx));
    while ((unsigned int )qp <= (unsigned int )ep) {
      if ((int )qp->flags & 1) {
        sp->qs_ndata ++;
      } else {
        sp->qs_pgfree += re_len;
      }
      indx = (unsigned short )((int )indx + 1);
      if (dbp___1->flags & 2048U) {
        tmp___2 = 64;
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = 48;
        } else {
          tmp___2 = 28;
        }
      }
      qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___2 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                           (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                          (unsigned long long )sizeof(u_int32_t )) -
                                                                         1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL)) *
                                                                       (unsigned long long )indx));
    }
    ret = __qam_fprobe(dbp___1, pgno, (void *)h, (enum __anonenum_qam_probe_mode_80 )1,
                       0U);
    if (ret != 0) {
      goto err;
    }
    if (lock.off != 0U) {
      __lock_put((dbc->dbp)->dbenv, & lock);
    }
    __Cont: 
    pgno ++;
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  if (first > last) {
    pgno = 1U;
    stop = last;
    first = last;
    goto begin;
  }
  if (dbp___1->flags & 524288U) {
    tmp___3 = 1;
  } else {
    tmp___3 = 2;
  }
  ret = __db_lget(dbc, 0, t->q_meta, (enum __anonenum_db_lockmode_t_50 )tmp___3, 0U,
                  & lock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & t->q_meta, 0U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 524288U)) {
    meta->dbmeta.record_count = sp->qs_ndata;
    meta->dbmeta.key_count = meta->dbmeta.record_count;
  }
  sp->qs_nkeys = sp->qs_ndata;
  meta_only: 
  sp->qs_magic = meta->dbmeta.magic;
  sp->qs_version = meta->dbmeta.version;
  sp->qs_metaflags = meta->dbmeta.flags;
  sp->qs_pagesize = meta->dbmeta.pagesize;
  sp->qs_extentsize = meta->page_ext;
  sp->qs_re_len = meta->re_len;
  sp->qs_re_pad = meta->re_pad;
  sp->qs_first_recno = meta->first_recno;
  sp->qs_cur_recno = meta->cur_recno;
  if (dbp___1->flags & 524288U) {
    tmp___4 = 0;
  } else {
    tmp___4 = 2;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___4);
  if (ret != 0) {
    goto err;
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  (*((DB_QUEUE_STAT **)spp)) = sp;
  ret = 0;
  if (0) {
    err: 
    if ((unsigned int )sp != (unsigned int )((void *)0)) {
      __os_ufree(dbp___1->dbenv, (void *)sp);
    }
  }
  if (lock.off != 0U) {
    __lock_put((dbc->dbp)->dbenv, & lock);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-1KD6tQ9M.i","-O2")
int __qam_31_qammeta(DB *dbp___1 , char *real_name , u_int8_t *buf ) ;
int __qam_32_qammeta(DB *dbp___1 , char *real_name , u_int8_t *buf ) ;
int __qam_31_qammeta(DB *dbp___1 , char *real_name , u_int8_t *buf ) 
{ QMETA31 *newmeta ;
  QMETA30 *oldmeta ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  real_name = (char *)((void *)0);
  real_name = real_name;
  newmeta = (QMETA31 *)buf;
  oldmeta = (QMETA30 *)buf;
  newmeta->rec_page = oldmeta->rec_page;
  newmeta->re_pad = oldmeta->re_pad;
  newmeta->re_len = oldmeta->re_len;
  newmeta->cur_recno = oldmeta->cur_recno;
  newmeta->first_recno = oldmeta->first_recno;
  newmeta->start = oldmeta->start;
  memmove((void *)(newmeta->dbmeta.uid), (void const   *)(oldmeta->dbmeta.uid), sizeof(oldmeta->dbmeta.uid));
  newmeta->dbmeta.flags = oldmeta->dbmeta.flags;
  newmeta->dbmeta.record_count = 0U;
  newmeta->dbmeta.key_count = 0U;
  while (1) {
    newmeta->dbmeta.unused3.file = 0U;
    newmeta->dbmeta.unused3.offset = 0U;
    break;
  }
  newmeta->dbmeta.version = 2U;
  return (0);
}
}
int __qam_32_qammeta(DB *dbp___1 , char *real_name , u_int8_t *buf ) 
{ QMETA32 *newmeta ;
  QMETA31 *oldmeta ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  real_name = (char *)((void *)0);
  real_name = real_name;
  newmeta = (QMETA32 *)buf;
  oldmeta = (QMETA31 *)buf;
  newmeta->first_recno = oldmeta->first_recno;
  newmeta->cur_recno = oldmeta->cur_recno;
  newmeta->re_len = oldmeta->re_len;
  newmeta->re_pad = oldmeta->re_pad;
  newmeta->rec_page = oldmeta->rec_page;
  newmeta->page_ext = 0U;
  newmeta->cur_recno ++;
  if (newmeta->first_recno == 0U) {
    newmeta->first_recno = 1U;
  }
  newmeta->dbmeta.version = 3U;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-i73OksRJ.i","-O2")
void __os_dirfree(DB_ENV *dbenv___0 , char **names , int cnt ) ;
int __db_vrfy_common(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) ;
int __db_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h , void *handle ,
                 int (*callback)(void * , void const   * ) , u_int32_t flags ) ;
int __db_salvage_isdone(VRFY_DBINFO *vdp , db_pgno_t pgno ) ;
int __qam_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , QMETA *meta , db_pgno_t pgno ,
                    u_int32_t flags ) ;
int __qam_vrfy_data(DB *dbp___1 , VRFY_DBINFO *vdp , QPAGE *h , db_pgno_t pgno , u_int32_t flags ) ;
int __qam_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , u_int32_t flags ) ;
int __qam_vrfy_walkqueue(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                         void const   * ) ,
                         u_int32_t flags ) ;
int __qam_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h , void *handle ,
                  int (*callback)(void * , void const   * ) , u_int32_t flags ) ;
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
__inline static  __attribute__((__nothrow__)) int atoi__extinline(char const   *__nptr ) ;
__inline static int atoi__extinline(char const   *__nptr ) 
{ int tmp ;

  {
  tmp = (int )strtol__extinline((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                                10);
  return (tmp);
}
}
int __qam_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , QMETA *meta , db_pgno_t pgno ,
                    u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  QUEUE *qp ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t *extents ;
  db_pgno_t extid ;
  db_pgno_t first ;
  db_pgno_t last ;
  size_t len ;
  int count ;
  int i ;
  int isbad ;
  int nextents ;
  int ret ;
  int t_ret ;
  char *buf ;
  char **names ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___83 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___119 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___138 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  size_t tmp___155 ;
  int tmp___156 ;
  size_t tmp___157 ;
  int tmp___158 ;

  {
  dbenv___0 = dbp___1->dbenv;
  last = 0U;
  first = last;
  buf = (char *)((void *)0);
  names = (char **)((void *)0);
  qp = (QUEUE *)dbp___1->q_internal;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  isbad = 0;
  if (! (pip->flags & 32U)) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: queue databases must be one-per-file",
                 (unsigned long )pgno);
      }
      break;
    }
  }
  if (dbp___1->flags & 2048U) {
    tmp___0 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = 48;
    } else {
      tmp___0 = 28;
    }
  }
  if (((unsigned long long )((((meta->re_len + sizeof(QAMDATA )) - 1U) + sizeof(u_int32_t )) -
                             1U) & ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL)) *
      (unsigned long long )meta->rec_page + (unsigned long long )tmp___0 > (unsigned long long )dbp___1->pgsize) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: queue record length %lu too high for page size and recs/page",
                 (unsigned long )pgno, (unsigned long )meta->re_len);
      }
      break;
    }
    ret = -30891;
    goto err;
  } else {
    vdp->re_len = meta->re_len;
    qp->re_len = vdp->re_len;
    vdp->rec_page = meta->rec_page;
    qp->rec_page = vdp->rec_page;
    vdp->page_ext = meta->page_ext;
    qp->page_ext = vdp->page_ext;
  }
  if (vdp->flags & 16U) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: database contains multiple Queue metadata pages",
                 (unsigned long )pgno);
      }
      break;
    }
    goto err;
  }
  vdp->flags = vdp->flags | 16U;
  qp->page_ext = meta->page_ext;
  dbp___1->pgsize = meta->dbmeta.pagesize;
  qp->q_meta = pgno;
  qp->q_root = pgno + 1U;
  vdp->first_recno = meta->first_recno;
  vdp->last_recno = meta->cur_recno;
  if (qp->page_ext != 0U) {
    first = ((((QUEUE *)dbp___1->q_internal)->q_root + (vdp->first_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page) -
             1U) / ((QUEUE *)dbp___1->q_internal)->page_ext;
    last = ((((QUEUE *)dbp___1->q_internal)->q_root + (vdp->last_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page) -
            1U) / ((QUEUE *)dbp___1->q_internal)->page_ext;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, (char const   *)qp->dir,
                     0U, (DB_FH **)((void *)0), & buf);
  if (ret != 0) {
    goto err;
  }
  ret = __os_dirlist(dbenv___0, (char const   *)buf, & names, & count);
  if (ret != 0) {
    goto err;
  }
  __os_free(dbenv___0, (void *)buf);
  buf = (char *)((void *)0);
  tmp___1 = strlen("__dbq.%s.");
  tmp___2 = strlen((char const   *)qp->name);
  len = (tmp___1 + tmp___2) + 1U;
  ret = __os_malloc(dbenv___0, len, (void *)(& buf));
  if (ret != 0) {
    goto err;
  }
  len = (size_t )snprintf((char * __restrict  )buf, len, (char const   * __restrict  )"__dbq.%s.",
                          qp->name);
  nextents = 0;
  extents = (db_pgno_t *)((void *)0);
  i = 0;
  while (i < count) {
    tmp___153 = __builtin_constant_p((int )len);
    if (tmp___153) {
      tmp___154 = __builtin_constant_p((int )(*(names + i)));
      if (tmp___154) {
        tmp___155 = strlen((char const   *)(*(names + i)));
        if (tmp___155 < len) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
        tmp___156 = __builtin_constant_p((int )buf);
        if (tmp___156) {
          tmp___157 = strlen((char const   *)buf);
          if (tmp___157 < len) {
            _L___39: 
            tmp___150 = __builtin_constant_p((int )(*(names + i)));
            if (tmp___150) {
              tmp___151 = __builtin_constant_p((int )buf);
              if (tmp___151) {
                __s1_len___0 = strlen((char const   *)(*(names + i)));
                __s2_len___0 = strlen((char const   *)buf);
                if (! ((unsigned int )((void const   *)((*(names + i)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                  i))) ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)buf) ==
                           1U)) {
                      tmp___152 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___152 = 1;
                      } else {
                        tmp___152 = 0;
                      }
                    }
                  } else {
                    tmp___152 = 0;
                  }
                }
                if (tmp___152) {
                  tmp___119 = __builtin_strcmp((*(names + i)), buf);
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___149 = __builtin_constant_p((int )(*(names + i)));
              if (tmp___149) {
                if ((unsigned int )((void const   *)((*(names + i)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                               i))) ==
                    1U) {
                  __s1_len___0 = strlen((char const   *)(*(names + i)));
                  if (__s1_len___0 < 4U) {
                    tmp___138 = __builtin_constant_p((int )buf);
                    if (tmp___138) {
                      if ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)buf) ==
                          1U) {
                        tmp___119 = __builtin_strcmp((*(names + i)), buf);
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)((char const   *)buf);
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                           i))) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                               i))) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                   i))) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                       i))) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___119 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___148 = __builtin_constant_p((int )buf);
                if (tmp___148) {
                  if ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)buf) ==
                      1U) {
                    __s2_len___0 = strlen((char const   *)buf);
                    if (__s2_len___0 < 4U) {
                      tmp___147 = __builtin_constant_p((int )(*(names + i)));
                      if (tmp___147) {
                        if ((unsigned int )((void const   *)((*(names + i)) + 1)) -
                            (unsigned int )((void const   *)(*(names + i))) == 1U) {
                          tmp___119 = __builtin_strcmp((*(names + i)), buf);
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)((char const   *)(*(names +
                                                                                 i)));
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)buf) +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)buf) +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)((char const   *)buf) +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)((char const   *)buf) +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___119 = __result___46;
                      }
                    } else {
                      tmp___119 = __builtin_strcmp((*(names + i)), buf);
                    }
                  } else {
                    tmp___119 = __builtin_strcmp((*(names + i)), buf);
                  }
                } else {
                  tmp___119 = __builtin_strcmp((*(names + i)), buf);
                }
              }
            }
            tmp___83 = tmp___119;
          } else {
            tmp___83 = strncmp((char const   *)(*(names + i)), (char const   *)buf,
                               len);
          }
        } else {
          tmp___83 = strncmp((char const   *)(*(names + i)), (char const   *)buf,
                             len);
        }
      }
    } else {
      tmp___83 = strncmp((char const   *)(*(names + i)), (char const   *)buf, len);
    }
    if (tmp___83 == 0) {
      extid = (db_pgno_t )atoi__extinline((char const   *)((*(names + i)) + len));
      if (qp->page_ext != 0U) {
        if (last > first) {
          if (extid >= first) {
            if (extid <= last) {
              tmp___6 = 1;
            } else {
              tmp___6 = 0;
            }
          } else {
            tmp___6 = 0;
          }
          tmp___5 = tmp___6;
        } else {
          if (extid >= first) {
            tmp___7 = 1;
          } else {
            if (extid <= last) {
              tmp___7 = 1;
            } else {
              tmp___7 = 0;
            }
          }
          tmp___5 = tmp___7;
        }
        if (tmp___5) {
          goto __Cont;
        }
      }
      if ((unsigned int )extents == (unsigned int )((void *)0)) {
        ret = __os_malloc(dbenv___0, (unsigned int )(count - i) * sizeof(extid), (void *)(& extents));
        if (ret != 0) {
          goto err;
        }
      }
      (*(extents + nextents)) = extid;
      nextents ++;
    }
    __Cont: 
    i ++;
  }
  if (nextents > 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Warning: %d extra extent files found",
             nextents);
  }
  vdp->nextents = nextents;
  vdp->extents = extents;
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )names != (unsigned int )((void *)0)) {
    __os_dirfree(dbenv___0, names, count);
  }
  if ((unsigned int )buf != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)buf);
  }
  if (ret != 0) {
    if ((unsigned int )extents != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)extents);
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___158 = -30976;
    } else {
      tmp___158 = ret;
    }
  } else {
    tmp___158 = ret;
  }
  return (tmp___158);
}
}
int __qam_vrfy_data(DB *dbp___1 , VRFY_DBINFO *vdp , QPAGE *h , db_pgno_t pgno , u_int32_t flags ) 
{ DB fakedb ;
  struct __queue fakeq ;
  QAMDATA *qp ;
  db_recno_t i ;
  int tmp___0 ;

  {
  fakedb.q_internal = (void *)(& fakeq);
  fakedb.flags = dbp___1->flags;
  fakeq.re_len = vdp->re_len;
  i = 0U;
  while (i < vdp->rec_page) {
    if (fakedb.flags & 2048U) {
      tmp___0 = 64;
    } else {
      if (fakedb.flags & 1U) {
        tmp___0 = 48;
      } else {
        tmp___0 = 28;
      }
    }
    qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___0 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                         (unsigned long long )((QUEUE *)fakedb.q_internal)->re_len) +
                                                                        (unsigned long long )sizeof(u_int32_t )) -
                                                                       1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) *
                                                                     (unsigned long long )i));
    if ((unsigned int )((u_int8_t *)qp) >= (unsigned int )((u_int8_t *)h + dbp___1->pgsize)) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: queue record %lu extends past end of page",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      return (-30976);
    }
    if ((int )qp->flags & -4) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: queue record %lu has bad flags (%#lx)",
                   (unsigned long )pgno, (unsigned long )i, (unsigned long )qp->flags);
        }
        break;
      }
      return (-30976);
    }
    i ++;
  }
  return (0);
}
}
int __qam_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , u_int32_t flags ) 
{ VRFY_PAGEINFO *pip ;
  db_pgno_t i ;
  int ret ;
  int isbad ;
  int tmp ;

  {
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, 0U, & pip);
  if (ret != 0) {
    return (ret);
  }
  if ((int )pip->type != 10) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: queue database has no meta page",
                 0UL);
      }
      break;
    }
    isbad = 1;
    goto err;
  }
  ret = __db_vrfy_pgset_inc(vdp->pgset, 0U);
  if (ret != 0) {
    goto err;
  }
  i = 1U;
  while (i <= vdp->last_pgno) {
    if (! (flags & 64U)) {
      __db_vrfy_struct_feedback(dbp___1, vdp);
    }
    ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
    if (ret != 0) {
      return (ret);
    } else {
      ret = __db_vrfy_getpageinfo(vdp, i, & pip);
      if (ret != 0) {
        return (ret);
      }
    }
    if (! (pip->flags & 64U)) {
      if ((int )pip->type != 11) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: queue database page of incorrect type %lu",
                     (unsigned long )i, (unsigned long )pip->type);
          }
          break;
        }
        isbad = 1;
        goto err;
      } else {
        goto _L;
      }
    } else {
      _L: 
      ret = __db_vrfy_pgset_inc(vdp->pgset, i);
      if (ret != 0) {
        goto err;
      }
    }
    i ++;
  }
  err: 
  ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
  if (ret != 0) {
    return (ret);
  }
  if (isbad == 1) {
    tmp = -30976;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int __qam_vrfy_walkqueue(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                         void const   * ) ,
                         u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  PAGE *h ;
  QUEUE *qp ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t first ;
  db_pgno_t i ;
  db_pgno_t last ;
  db_pgno_t pg_ext ;
  db_pgno_t stop ;
  int isbad ;
  int nextents ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  t_ret = 0;
  ret = t_ret;
  isbad = ret;
  pip = (VRFY_PAGEINFO *)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  qp = (QUEUE *)dbp___1->q_internal;
  pg_ext = qp->page_ext;
  if (pg_ext == 0U) {
    return (0);
  }
  first = ((QUEUE *)dbp___1->q_internal)->q_root + (vdp->first_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  last = ((QUEUE *)dbp___1->q_internal)->q_root + (vdp->last_recno - 1U) / ((QUEUE *)dbp___1->q_internal)->rec_page;
  i = first;
  if (first > last) {
    stop = ((QUEUE *)dbp___1->q_internal)->q_root + 4294967294U / ((QUEUE *)dbp___1->q_internal)->rec_page;
  } else {
    stop = last;
  }
  nextents = vdp->nextents;
  begin: 
  while (i <= stop) {
    if (flags & 64U) {
      tmp = __db_salvage_isdone(vdp, i);
      if (tmp != 0) {
        goto __Cont;
      }
    }
    t_ret = __qam_fprobe(dbp___1, i, (void *)(& h), (enum __anonenum_qam_probe_mode_80 )0,
                         0U);
    if (t_ret != 0) {
      if (t_ret == 2) {
        i += (pg_ext - (i - 1U) % pg_ext) - 1U;
        goto __Cont;
      } else {
        if (t_ret == -30988) {
          i += (pg_ext - (i - 1U) % pg_ext) - 1U;
          goto __Cont;
        }
      }
      if (flags & 64U) {
        if (ret == 0) {
          ret = t_ret;
        }
        goto __Cont;
      } else {
        return (t_ret);
      }
    }
    if (flags & 64U) {
      t_ret = __db_salvage(dbp___1, vdp, i, h, handle, callback, flags);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
        isbad = 1;
      }
    } else {
      ret = __db_vrfy_common(dbp___1, vdp, h, i, flags);
      if (ret == -30976) {
        isbad = 1;
      } else {
        if (ret != 0) {
          goto err;
        }
      }
      __db_vrfy_struct_feedback(dbp___1, vdp);
      ret = __db_vrfy_getpageinfo(vdp, i, & pip);
      if (ret != 0) {
        return (ret);
      }
      if (pip->flags & 64U) {
        goto put;
      }
      if ((int )pip->type != 11) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: queue database page of incorrect type %lu",
                     (unsigned long )i, (unsigned long )pip->type);
          }
          break;
        }
        isbad = 1;
        goto err;
      }
      ret = __db_vrfy_pgset_inc(vdp->pgset, i);
      if (ret != 0) {
        goto err;
      }
      ret = __qam_vrfy_data(dbp___1, vdp, (QPAGE *)h, i, flags);
      if (ret == -30976) {
        isbad = 1;
      } else {
        if (ret != 0) {
          goto err;
        }
      }
      put: 
      ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
      if (ret != 0) {
        goto err;
      }
      pip = (VRFY_PAGEINFO *)((void *)0);
    }
    t_ret = __qam_fprobe(dbp___1, i, (void *)h, (enum __anonenum_qam_probe_mode_80 )1,
                         0U);
    if (t_ret != 0) {
      if (flags & 64U) {
        if (ret == 0) {
          ret = t_ret;
        }
        goto __Cont;
      } else {
        return (t_ret);
      }
    }
    __Cont: 
    i ++;
  }
  if (first > last) {
    i = 1U;
    stop = last;
    first = last;
    goto begin;
  }
  if (flags & 64U) {
    if (nextents != 0) {
      nextents --;
      i = 1U + (*(vdp->extents + nextents)) * vdp->page_ext;
      stop = i + vdp->page_ext;
      goto begin;
    }
  }
  if (0) {
    err: 
    t_ret = __qam_fprobe(dbp___1, i, (void *)h, (enum __anonenum_qam_probe_mode_80 )1,
                         0U);
    if (t_ret != 0) {
      if (ret == 0) {
        tmp___0 = t_ret;
      } else {
        tmp___0 = ret;
      }
      return (tmp___0);
    }
    if ((unsigned int )pip != (unsigned int )((void *)0)) {
      t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
      if (t_ret != 0) {
        if (ret == 0) {
          tmp___1 = t_ret;
        } else {
          tmp___1 = ret;
        }
        return (tmp___1);
      }
    }
  }
  if (isbad == 1) {
    if (ret == 0) {
      tmp___2 = -30976;
    } else {
      tmp___2 = ret;
    }
  } else {
    tmp___2 = ret;
  }
  return (tmp___2);
}
}
int __qam_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h , void *handle ,
                  int (*callback)(void * , void const   * ) , u_int32_t flags ) 
{ DBT dbt ;
  DBT key ;
  QAMDATA *qp ;
  QAMDATA *qep ;
  db_recno_t recno ;
  int ret ;
  int err_ret ;
  int t_ret ;
  u_int32_t pagesize ;
  u_int32_t qlen ;
  u_int32_t i ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  memset((void *)(& dbt), 0, sizeof(DBT ));
  memset((void *)(& key), 0, sizeof(DBT ));
  ret = 0;
  err_ret = ret;
  pagesize = ((dbp___1->mpf)->mfp)->stat.st_pagesize;
  qlen = ((QUEUE *)dbp___1->q_internal)->re_len;
  dbt.size = qlen;
  key.data = (void *)(& recno);
  key.size = sizeof(recno);
  recno = (pgno - 1U) * ((QUEUE *)dbp___1->q_internal)->rec_page + 1U;
  i = 0U;
  qep = (QAMDATA *)(((u_int8_t *)h + pagesize) - qlen);
  if (dbp___1->flags & 2048U) {
    tmp___0 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = 48;
    } else {
      tmp___0 = 28;
    }
  }
  qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___0 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                       (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                      (unsigned long long )sizeof(u_int32_t )) -
                                                                     1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                1ULL)) *
                                                                   (unsigned long long )i));
  while ((unsigned int )qp < (unsigned int )qep) {
    if ((int )qp->flags & -4) {
      goto __Cont;
    }
    if (! ((int )qp->flags & 2)) {
      goto __Cont;
    }
    if (! (flags & 1U)) {
      if (! ((int )qp->flags & 1)) {
        goto __Cont;
      }
    }
    dbt.data = (void *)(qp->data);
    ret = __db_prdbt(& key, 0, " ", handle, callback, 1, vdp);
    if (ret != 0) {
      err_ret = ret;
    }
    ret = __db_prdbt(& dbt, 0, " ", handle, callback, 0, vdp);
    if (ret != 0) {
      err_ret = ret;
    }
    __Cont: 
    recno ++;
    i ++;
    if (dbp___1->flags & 2048U) {
      tmp___2 = 64;
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = 48;
      } else {
        tmp___2 = 28;
      }
    }
    qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___2 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                         (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                        (unsigned long long )sizeof(u_int32_t )) -
                                                                       1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) *
                                                                     (unsigned long long )i));
  }
  t_ret = __db_salvage_markdone(vdp, pgno);
  if (t_ret != 0) {
    return (t_ret);
  }
  if (ret == 0) {
    if (err_ret != 0) {
      tmp___3 = err_ret;
    } else {
      tmp___3 = ret;
    }
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
#pragma merger(0,"/tmp/cil-hYoKsERe.i","-O2")
int __db_env_config(DB_ENV *dbenv___0 , char *i , u_int32_t flags ) ;
int __os_clock(DB_ENV *dbenv___0 , u_int32_t *secsp , u_int32_t *usecsp ) ;
void __os_id(u_int32_t *idp ) ;
int __os_sleep(DB_ENV *dbenv___0 , u_long secs , u_long usecs ) ;
int __rep_dbenv_create(DB_ENV *dbenv___0 ) ;
int __rep_open(DB_ENV *dbenv___0 ) ;
void __rep_elect_master(DB_ENV *dbenv___0 , REP *rep , int *eidp ) ;
int __rep_process_message(DB_ENV *dbenv___0 , DBT *control , DBT *rec , int *eidp ,
                          DB_LSN *ret_lsnp ) ;
int __rep_process_txn(DB_ENV *dbenv___0 , DBT *rec ) ;
int __rep_tally(DB_ENV *dbenv___0 , REP *rep , int eid , int *countp , u_int32_t egen ,
                u_int32_t vtoff ) ;
void __rep_cmp_vote(DB_ENV *dbenv___0 , REP *rep , int *eidp , DB_LSN *lsnp , int priority ,
                    int gen , int tiebreaker ) ;
int __rep_region_init(DB_ENV *dbenv___0 ) ;
int __rep_preclose(DB_ENV *dbenv___0 , int do_closefiles ) ;
int __rep_send_message(DB_ENV *dbenv___0 , int eid , u_int32_t rtype , DB_LSN *lsnp ,
                       DBT const   *dbtp , u_int32_t flags ) ;
void __rep_send_vote(DB_ENV *dbenv___0 , DB_LSN *lsnp , int nsites , int pri , int tiebreaker ,
                     u_int32_t egen , int eid , u_int32_t vtype ) ;
void __rep_elect_done(DB_ENV *dbenv___0 , REP *rep ) ;
int __rep_grow_sites(DB_ENV *dbenv___0 , int nsites ) ;
int __db_txnlist_init(DB_ENV *dbenv___0 , u_int32_t low_txn , u_int32_t hi_txn , DB_LSN *trunc_lsn ,
                      void *retp ) ;
int __db_txnlist_add(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid , int32_t status ,
                     DB_LSN *lsn ) ;
void __db_txnlist_end(DB_ENV *dbenv___0 , void *listp ) ;
int __db_txnlist_find(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid ) ;
int __db_remove(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                u_int32_t flags ) ;
int __log_cursor(DB_ENV *dbenv___0 , DB_LOGC **logcp ) ;
int __log_c_close(DB_LOGC *logc ) ;
int __log_c_get(DB_LOGC *logc , DB_LSN *alsn , DBT *dbt , u_int32_t flags ) ;
int __txn_abort(DB_TXN *txnp ) ;
int __txn_checkpoint(DB_ENV *dbenv___0 , u_int32_t kbytes , u_int32_t minutes , u_int32_t flags ) ;
int __txn_getckp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) ;
int __txn_reset(DB_ENV *dbenv___0 ) ;
int __txn_regop_read(DB_ENV *dbenv___0 , void *recbuf , __txn_regop_args **argpp ) ;
int __txn_ckp_read(DB_ENV *dbenv___0 , void *recbuf , __txn_ckp_args **argpp ) ;
int __txn_xa_regop_read(DB_ENV *dbenv___0 , void *recbuf , __txn_xa_regop_args **argpp ) ;
int __txn_restore_txn(DB_ENV *dbenv___0 , DB_LSN *lsnp , __txn_xa_regop_args *argp ) ;
int __txn_recover(DB_ENV *dbenv___0 , DB_PREPLIST *preplist , long count , long *retp ,
                  u_int32_t flags ) ;
static int __rep_abort_prepared(DB_ENV *dbenv___0 ) ;
static int __rep_bt_cmp(DB *dbp___1 , DBT const   *dbt1 , DBT const   *dbt2 ) ;
static int __rep_client_dbinit(DB_ENV *dbenv___0 , int startup ) ;
static int __rep_elect(DB_ENV *dbenv___0 , int nsites , int priority , u_int32_t timeout ,
                       int *eidp ) ;
static int __rep_elect_init(DB_ENV *dbenv___0 , DB_LSN *lsnp , int nsites , int priority ,
                            int *beginp , u_int32_t *otally ) ;
static int __rep_flush(DB_ENV *dbenv___0 ) ;
static int __rep_restore_prepared(DB_ENV *dbenv___0 ) ;
static int __rep_get_limit(DB_ENV *dbenv___0 , u_int32_t *gbytesp , u_int32_t *bytesp ) ;
static int __rep_set_limit(DB_ENV *dbenv___0 , u_int32_t gbytes , u_int32_t bytes ) ;
static int __rep_set_request(DB_ENV *dbenv___0 , u_int32_t min , u_int32_t max ) ;
static int __rep_set_rep_transport(DB_ENV *dbenv___0 , int eid , int (*f_send)(DB_ENV * ,
                                                                               DBT const   * ,
                                                                               DBT const   * ,
                                                                               DB_LSN const   * ,
                                                                               int  ,
                                                                               u_int32_t  ) ) ;
static int __rep_start(DB_ENV *dbenv___0 , DBT *dbt , u_int32_t flags ) ;
static int __rep_stat(DB_ENV *dbenv___0 , DB_REP_STAT **statp , u_int32_t flags ) ;
static int __rep_wait(DB_ENV *dbenv___0 , u_int32_t timeout , int *eidp , u_int32_t flags ) ;
int __rep_dbenv_create(DB_ENV *dbenv___0 ) 
{ 

  {
  dbenv___0->rep_elect = & __rep_elect;
  dbenv___0->rep_flush = & __rep_flush;
  dbenv___0->rep_process_message = & __rep_process_message;
  dbenv___0->rep_start = & __rep_start;
  dbenv___0->rep_stat = & __rep_stat;
  dbenv___0->get_rep_limit = & __rep_get_limit;
  dbenv___0->set_rep_limit = & __rep_set_limit;
  dbenv___0->set_rep_request = & __rep_set_request;
  dbenv___0->set_rep_transport = & __rep_set_rep_transport;
  return (0);
}
}
int __rep_open(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  int ret ;

  {
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_REP ), (void *)(& db_rep));
  if (ret != 0) {
    return (ret);
  }
  dbenv___0->rep_handle = (void *)db_rep;
  ret = __rep_region_init(dbenv___0);
  return (ret);
}
}
static int __rep_start(DB_ENV *dbenv___0 , DBT *dbt , u_int32_t flags ) 
{ DB_LOG *dblp ;
  DB_LSN lsn ;
  DB_REP *db_rep ;
  REP *rep ;
  u_int32_t repflags ;
  int announce ;
  int init_db ;
  int redo_prepared ;
  int ret ;
  int sleep_cnt ;
  int t_ret ;
  int was_client ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbenv___0->flags & 8192U)) {
    tmp___0 = __db_mi_open(dbenv___0, "DB_ENV->rep_start", 0);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___1 = __db_env_config(dbenv___0, (char *)"rep_start", 65536U);
    return (tmp___1);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  ret = __db_fchk(dbenv___0, "DB_ENV->rep_start", flags, 7U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fcchk(dbenv___0, "DB_ENV->rep_start", flags, 1U, 4U);
  if (ret != 0) {
    return (ret);
  }
  if (! (flags & 7U)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_start: replication mode must be specified");
    return (22);
  }
  ret = __db_fcchk(dbenv___0, "DB_ENV->rep_start", flags, 2U, 4U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->rep_send == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_rep_transport must be called before DB_ENV->rep_start");
    return (22);
  }
  if (flags & 4U) {
    ret = __log_flush(dbenv___0, (DB_LSN const   *)((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (rep->start_th != 0) {
    goto err;
  } else {
    rep->start_th = 1;
  }
  sleep_cnt = 0;
  while (rep->msg_th != 0U) {
    sleep_cnt ++;
    if (sleep_cnt % 60 == 0) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_start waiting %d minutes for replication message thread",
               sleep_cnt / 60);
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    __os_sleep(dbenv___0, 1UL, 0UL);
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
  }
  if (rep->eid == -2) {
    rep->eid = dbenv___0->rep_eid;
  }
  if (flags & 4U) {
    was_client = (int )(rep->flags & 512U);
    if (was_client) {
      ret = __rep_preclose(dbenv___0, 0);
      if (ret != 0) {
        goto errunlock;
      }
    }
    redo_prepared = 0;
    if (! (rep->flags & 8U)) {
      if (was_client) {
        if (rep->w_gen > rep->recover_gen) {
          rep->w_gen = rep->w_gen + 1U;
          rep->gen = rep->w_gen;
        } else {
          if (rep->gen > rep->recover_gen) {
            rep->gen = rep->gen + 1U;
          } else {
            rep->gen = rep->recover_gen + 1U;
          }
        }
        if (rep->egen > rep->gen) {
          rep->gen = rep->egen;
        }
        redo_prepared = 1;
      } else {
        if (rep->gen == 0U) {
          rep->gen = rep->recover_gen + 1U;
        }
      }
      if (rep->flags & 16U) {
        __rep_elect_done(dbenv___0, rep);
        rep->flags = rep->flags & 4294967279U;
      }
      if (rep->egen <= rep->gen) {
        rep->egen = rep->gen + 1U;
      }
    }
    rep->master_id = rep->eid;
    rep->flags = 8U;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    dblp = (DB_LOG *)dbenv___0->lg_handle;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    lsn = ((LOG *)dblp->reginfo.primary)->lsn;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    __rep_send_message(dbenv___0, -1, 13U, & lsn, (DBT const   *)((void *)0), 0U);
    ret = 0;
    if (was_client) {
      ret = __txn_reset(dbenv___0);
    }
    t_ret = __txn_checkpoint(dbenv___0, 0U, 0U, 4U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (redo_prepared) {
      t_ret = __rep_restore_prepared(dbenv___0);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  } else {
    init_db = 0;
    was_client = (int )(rep->flags & 516U);
    if (! was_client) {
      tmp___2 = 1;
    } else {
      if (rep->master_id == -2) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    }
    announce = tmp___2;
    repflags = rep->flags & 480U;
    if (flags & 2U) {
      repflags |= 4U;
    } else {
      repflags |= 512U;
    }
    rep->flags = repflags;
    if (! was_client) {
      rep->master_id = -2;
      init_db = 1;
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    ret = __rep_abort_prepared(dbenv___0);
    if (ret != 0) {
      goto errlock;
    }
    ret = __rep_client_dbinit(dbenv___0, init_db);
    if (ret != 0) {
      goto errlock;
    }
    if (announce) {
      __rep_send_message(dbenv___0, -1, 11U, (DB_LSN *)((void *)0), (DBT const   *)dbt,
                         0U);
    }
  }
  errlock: 
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  errunlock: 
  rep->start_th = 0;
  err: 
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (ret);
}
}
static int __rep_client_dbinit(DB_ENV *dbenv___0 , int startup ) 
{ DB_REP *db_rep ;
  DB *dbp___1 ;
  int ret ;
  int t_ret ;
  u_int32_t flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  dbp___1 = (DB *)((void *)0);
  if ((unsigned int )db_rep->rep_db != (unsigned int )((void *)0)) {
    return (0);
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  if (startup) {
    ret = db_create(& dbp___1, dbenv___0, 1U);
    if (ret != 0) {
      goto err;
    }
    __db_remove(dbp___1, (DB_TXN *)((void *)0), "__db.rep.db", (char const   *)((void *)0),
                4U);
  }
  ret = db_create(& dbp___1, dbenv___0, 1U);
  if (ret != 0) {
    goto err;
  }
  ret = __bam_set_bt_compare(dbp___1, & __rep_bt_cmp);
  if (ret != 0) {
    goto err;
  }
  dbp___1->flags = dbp___1->flags | 2U;
  if (startup) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  if (dbenv___0->flags & 1048576U) {
    tmp___1 = 64;
  } else {
    tmp___1 = 0;
  }
  flags = (unsigned int )((67108864 | tmp___0) | tmp___1);
  ret = __db_open(dbp___1, (DB_TXN *)((void *)0), "__db.rep.db", (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )1, flags, 0, 0U);
  if (ret != 0) {
    goto err;
  }
  db_rep->rep_db = dbp___1;
  if (0) {
    err: 
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      t_ret = __db_close(dbp___1, (DB_TXN *)((void *)0), 23U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    db_rep->rep_db = (DB *)((void *)0);
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  return (ret);
}
}
static int __rep_bt_cmp(DB *dbp___1 , DBT const   *dbt1 , DBT const   *dbt2 ) 
{ DB_LSN lsn1 ;
  DB_LSN lsn2 ;
  REP_CONTROL *rp1 ;
  REP_CONTROL *rp2 ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  rp1 = (REP_CONTROL *)dbt1->data;
  rp2 = (REP_CONTROL *)dbt2->data;
  __ua_memcpy((void *)(& lsn1), (void const   *)(& rp1->lsn), sizeof(DB_LSN ));
  __ua_memcpy((void *)(& lsn2), (void const   *)(& rp2->lsn), sizeof(DB_LSN ));
  if (lsn1.file > lsn2.file) {
    return (1);
  }
  if (lsn1.file < lsn2.file) {
    return (-1);
  }
  if (lsn1.offset > lsn2.offset) {
    return (1);
  }
  if (lsn1.offset < lsn2.offset) {
    return (-1);
  }
  return (0);
}
}
static int __rep_abort_prepared(DB_ENV *dbenv___0 ) 
{ DB_PREPLIST prep[50] ;
  DB_PREPLIST *p ;
  DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  int do_aborts ;
  int ret ;
  long count ;
  long i ;
  u_int32_t op ;

  {
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  do_aborts = 0;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (region->stat.st_nrestores != 0U) {
    do_aborts = 1;
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (do_aborts) {
    op = 9U;
    while (1) {
      ret = __txn_recover(dbenv___0, prep, 50L, & count, op);
      if (ret != 0) {
        return (ret);
      }
      i = 0L;
      while (i < count) {
        p = & prep[i];
        ret = __txn_abort(p->txn);
        if (ret != 0) {
          return (ret);
        }
        i ++;
      }
      op = 18U;
      if (! (count == 50L)) {
        break;
      }
    }
  }
  return (0);
}
}
static int __rep_restore_prepared(DB_ENV *dbenv___0 ) 
{ DB_LOGC *logc ;
  DB_LSN ckp_lsn ;
  DB_LSN lsn ;
  DBT rec ;
  __txn_ckp_args *ckp_args ;
  __txn_regop_args *regop_args ;
  __txn_xa_regop_args *prep_args ;
  int ret ;
  int t_ret ;
  u_int32_t hi_txn ;
  u_int32_t low_txn ;
  u_int32_t rectype ;
  void *txninfo ;
  int tmp ;
  int tmp___0 ;

  {
  txninfo = (void *)0;
  ckp_args = (__txn_ckp_args *)((void *)0);
  prep_args = (__txn_xa_regop_args *)((void *)0);
  regop_args = (__txn_regop_args *)((void *)0);
  while (1) {
    ckp_lsn.file = 0U;
    ckp_lsn.offset = 0U;
    break;
  }
  while (1) {
    lsn.file = 0U;
    lsn.offset = 0U;
    break;
  }
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& rec), 0, sizeof(DBT ));
  ret = __txn_getckp(dbenv___0, & lsn);
  if (ret == 0) {
    ret = __log_c_get(logc, & lsn, & rec, 28U);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "Checkpoint record at LSN [%lu][%lu] not found",
               (unsigned long )lsn.file, (unsigned long )lsn.offset);
      goto done;
    }
    ret = __txn_ckp_read(dbenv___0, rec.data, & ckp_args);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "Invalid checkpoint record at [%lu][%lu]",
               (unsigned long )lsn.file, (unsigned long )lsn.offset);
      goto done;
    }
    ckp_lsn = ckp_args->ckp_lsn;
    __os_free(dbenv___0, (void *)ckp_args);
    ret = __log_c_get(logc, & ckp_lsn, & rec, 28U);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "Checkpoint LSN record [%lu][%lu] not found",
               (unsigned long )ckp_lsn.file, (unsigned long )ckp_lsn.offset);
      goto done;
    }
  } else {
    ret = __log_c_get(logc, & lsn, & rec, 9U);
    if (ret != 0) {
      if (ret == -30990) {
        ret = 0;
        goto done;
      }
      __db_err((DB_ENV const   *)dbenv___0, "Attempt to get first log record failed");
      goto done;
    }
  }
  while (1) {
    memcpy((void * __restrict  )(& low_txn), (void const   * __restrict  )((u_int8_t *)rec.data +
                                                                           sizeof(u_int32_t )),
           sizeof(low_txn));
    if (low_txn != 0U) {
      break;
    }
    ret = __log_c_get(logc, & lsn, & rec, 18U);
    if (! (ret == 0)) {
      break;
    }
  }
  if (ret == -30990) {
    ret = 0;
    goto done;
  } else {
    if (ret != 0) {
      goto done;
    }
  }
  ret = __log_c_get(logc, & lsn, & rec, 17U);
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Final log record not found");
    goto done;
  }
  while (1) {
    memcpy((void * __restrict  )(& hi_txn), (void const   * __restrict  )((u_int8_t *)rec.data +
                                                                          sizeof(u_int32_t )),
           sizeof(hi_txn));
    if (hi_txn != 0U) {
      break;
    }
    ret = __log_c_get(logc, & lsn, & rec, 25U);
    if (! (ret == 0)) {
      break;
    }
  }
  if (ret == -30990) {
    ret = 0;
    goto done;
  } else {
    if (ret != 0) {
      goto done;
    }
  }
  ret = __db_txnlist_init(dbenv___0, low_txn, hi_txn, (DB_LSN *)((void *)0), (void *)(& txninfo));
  if (ret != 0) {
    goto done;
  }
  ret = __log_c_get(logc, & lsn, & rec, 17U);
  while (1) {
    if (ret == 0) {
      tmp = log_compare((DB_LSN const   *)(& lsn), (DB_LSN const   *)(& ckp_lsn));
      if (! (tmp > 0)) {
        break;
      }
    } else {
      break;
    }
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )rec.data,
           sizeof(rectype));
    switch ((int )rectype) {
    case 10: 
    ret = __txn_regop_read(dbenv___0, rec.data, & regop_args);
    if (ret != 0) {
      goto done;
    }
    ret = __db_txnlist_find(dbenv___0, txninfo, (regop_args->txnid)->txnid);
    if (ret == 4) {
      ret = __db_txnlist_add(dbenv___0, txninfo, (regop_args->txnid)->txnid, (int )regop_args->opcode,
                             & lsn);
    }
    __os_free(dbenv___0, (void *)regop_args);
    break;
    case 13: 
    ret = __txn_xa_regop_read(dbenv___0, rec.data, & prep_args);
    if (ret != 0) {
      goto done;
    }
    ret = __db_txnlist_find(dbenv___0, txninfo, (prep_args->txnid)->txnid);
    if (ret == 4) {
      if (prep_args->opcode == 3U) {
        ret = __db_txnlist_add(dbenv___0, txninfo, (prep_args->txnid)->txnid, (int )prep_args->opcode,
                               & lsn);
      } else {
        ret = __rep_process_txn(dbenv___0, & rec);
        if (ret == 0) {
          ret = __txn_restore_txn(dbenv___0, & lsn, prep_args);
        }
      }
    }
    __os_free(dbenv___0, (void *)prep_args);
    break;
    default: ;
    goto __Cont;
    }
    __Cont: 
    ret = __log_c_get(logc, & lsn, & rec, 25U);
  }
  if (ret == -30990) {
    ret = 0;
  }
  done: 
  t_ret = __log_c_close(logc);
  if ((unsigned int )txninfo != (unsigned int )((void *)0)) {
    __db_txnlist_end(dbenv___0, txninfo);
  }
  if (ret == 0) {
    tmp___0 = t_ret;
  } else {
    tmp___0 = ret;
  }
  return (tmp___0);
}
}
static int __rep_get_limit(DB_ENV *dbenv___0 , u_int32_t *gbytesp , u_int32_t *bytesp ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"rep_get_limit", 65536U);
    return (tmp___0);
  }
  if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->get_rep_limit: database environment not properly initialized");
    tmp___1 = __db_panic(dbenv___0, 22);
    return (tmp___1);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if ((unsigned int )gbytesp != (unsigned int )((void *)0)) {
    (*gbytesp) = rep->gbytes;
  }
  if ((unsigned int )bytesp != (unsigned int )((void *)0)) {
    (*bytesp) = rep->bytes;
  }
  return (0);
}
}
static int __rep_set_limit(DB_ENV *dbenv___0 , u_int32_t gbytes , u_int32_t bytes ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbenv___0->flags & 8192U)) {
    tmp___0 = __db_mi_open(dbenv___0, "DB_ENV->rep_set_limit", 0);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___1 = __db_env_config(dbenv___0, (char *)"rep_set_limit", 65536U);
    return (tmp___1);
  }
  if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_rep_limit: database environment not properly initialized");
    tmp___2 = __db_panic(dbenv___0, 22);
    return (tmp___2);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (bytes > 1073741824U) {
    gbytes += bytes / 1073741824U;
    bytes = bytes % 1073741824U;
  }
  rep->gbytes = gbytes;
  rep->bytes = bytes;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (0);
}
}
static int __rep_set_request(DB_ENV *dbenv___0 , u_int32_t min , u_int32_t max ) 
{ LOG *lp ;
  DB_LOG *dblp ;
  DB_REP *db_rep ;
  REP *rep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbenv___0->flags & 8192U)) {
    tmp___0 = __db_mi_open(dbenv___0, "DB_ENV->rep_set_request", 0);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___1 = __db_env_config(dbenv___0, (char *)"rep_set_request", 65536U);
    return (tmp___1);
  }
  if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_rep_request: database environment not properly initialized");
    tmp___2 = __db_panic(dbenv___0, 22);
    return (tmp___2);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  rep->request_gap = min;
  rep->max_gap = max;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if ((unsigned int )dblp != (unsigned int )((void *)0)) {
    lp = (LOG *)dblp->reginfo.primary;
    if ((unsigned int )lp != (unsigned int )((void *)0)) {
      lp->wait_recs = 0U;
      lp->rcvd_recs = 0U;
    }
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  return (0);
}
}
static int __rep_set_rep_transport(DB_ENV *dbenv___0 , int eid , int (*f_send)(DB_ENV * ,
                                                                               DBT const   * ,
                                                                               DBT const   * ,
                                                                               DB_LSN const   * ,
                                                                               int  ,
                                                                               u_int32_t  ) ) 
{ int tmp ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )f_send == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_rep_transport: no send function specified");
    return (22);
  }
  if (eid < 0) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_rep_transport: eid must be greater than or equal to 0");
    return (22);
  }
  dbenv___0->rep_send = f_send;
  dbenv___0->rep_eid = eid;
  return (0);
}
}
static int __rep_elect(DB_ENV *dbenv___0 , int nsites , int priority , u_int32_t timeout ,
                       int *eidp ) 
{ DB_LOG *dblp ;
  DB_LSN lsn ;
  DB_REP *db_rep ;
  REP *rep ;
  int done ;
  int in_progress ;
  int ret ;
  int send_vote ;
  int tiebreaker ;
  u_int32_t egen ;
  u_int32_t orig_tally ;
  u_int32_t pid ;
  u_int32_t sec ;
  u_int32_t usec ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"rep_elect", 65536U);
    return (tmp___0);
  }
  if (nsites <= 0) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_elect: nsites must be greater than 0");
    return (22);
  }
  if (priority < 0) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_elect: priority may not be negative");
    return (22);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  lsn = ((LOG *)dblp->reginfo.primary)->lsn;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  orig_tally = 0U;
  ret = __rep_elect_init(dbenv___0, & lsn, nsites, priority, & in_progress, & orig_tally);
  if (ret != 0) {
    if (ret == -30983) {
      ret = 0;
      (*eidp) = dbenv___0->rep_eid;
    }
    goto err;
  }
  if (in_progress) {
    (*eidp) = dbenv___0->rep_eid;
    return (0);
  }
  __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                     0U);
  ret = __rep_wait(dbenv___0, timeout / 4U, eidp, 1U);
  switch (ret) {
  case 0: ;
  if ((*eidp) != -2) {
    return (0);
  }
  break;
  case -30893: ;
  break;
  default: ;
  goto err;
  }
  restart: 
  __os_id(& pid);
  ret = __os_clock(dbenv___0, & sec, & usec);
  if (ret != 0) {
    return (ret);
  }
  tmp___1 = rand();
  tiebreaker = (int )((((pid ^ sec) ^ usec) ^ (unsigned int )tmp___1) ^ (unsigned int )(& pid));
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  rep->flags = rep->flags | 33U;
  rep->flags = rep->flags & 4294967039U;
  tmp___2 = __rep_tally(dbenv___0, rep, rep->eid, & rep->sites, rep->egen, rep->tally_off);
  if (tmp___2 != 0) {
    goto lockdone;
  }
  __rep_cmp_vote(dbenv___0, rep, & rep->eid, & lsn, priority, (int )rep->gen, tiebreaker);
  send_vote = -2;
  egen = rep->egen;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  __rep_send_vote(dbenv___0, & lsn, nsites, priority, tiebreaker, egen, -1, 22U);
  ret = __rep_wait(dbenv___0, timeout, eidp, 1U);
  switch (ret) {
  case 0: ;
  if ((*eidp) != -2) {
    return (0);
  }
  goto phase2;
  case -30893: ;
  break;
  default: ;
  goto err;
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (egen != rep->egen) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    goto restart;
  }
  if (rep->sites > rep->nsites / 2) {
    send_vote = rep->winner;
    if (rep->winner == rep->eid) {
      __rep_tally(dbenv___0, rep, rep->eid, & rep->votes, egen, rep->v2tally_off);
    }
    rep->flags = rep->flags | 2U;
    rep->flags = rep->flags & 4294967294U;
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  if (send_vote == -2) {
    ret = -30979;
    goto err;
  } else {
    if (send_vote != rep->eid) {
      __rep_send_vote(dbenv___0, (DB_LSN *)((void *)0), 0, 0, 0, egen, send_vote,
                      23U);
    }
    phase2: 
    ret = __rep_wait(dbenv___0, timeout, eidp, 2U);
    switch (ret) {
    case 0: ;
    return (0);
    case -30893: 
    ret = -30979;
    break;
    default: ;
    goto err;
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    done = rep->votes > rep->nsites / 2;
    if (send_vote == rep->eid) {
      if (done) {
        __rep_elect_master(dbenv___0, rep, eidp);
        ret = 0;
        goto lockdone;
      }
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
  }
  err: 
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  lockdone: 
  if (ret == 0) {
    __rep_elect_done(dbenv___0, rep);
  } else {
    if (ret == -30979) {
      __rep_elect_done(dbenv___0, rep);
    } else {
      if (orig_tally) {
        rep->flags = rep->flags | orig_tally;
      }
    }
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (ret);
}
}
static int __rep_elect_init(DB_ENV *dbenv___0 , DB_LSN *lsnp , int nsites , int priority ,
                            int *beginp , u_int32_t *otally ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int ret ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  ret = 0;
  rep->stat.st_elections = rep->stat.st_elections + 1U;
  if (rep->flags & 8U) {
    __rep_send_message(dbenv___0, -1, 13U, lsnp, (DBT const   *)((void *)0), 0U);
    rep->stat.st_elections_won = rep->stat.st_elections_won + 1U;
    return (-30983);
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if ((unsigned int )otally != (unsigned int )((void *)0)) {
    (*otally) = rep->flags & 256U;
  }
  (*beginp) = (int )(rep->flags & 3U);
  if (! (*beginp)) {
    if (nsites > rep->asites) {
      ret = __rep_grow_sites(dbenv___0, nsites);
      if (ret != 0) {
        goto err;
      }
    }
    rep->nsites = nsites;
    rep->priority = priority;
    rep->master_id = -2;
  }
  err: 
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (ret);
}
}
void __rep_elect_master(DB_ENV *dbenv___0 , REP *rep , int *eidp ) 
{ 

  {
  rep->master_id = rep->eid;
  rep->flags = rep->flags | 16U;
  if ((unsigned int )eidp != (unsigned int )((void *)0)) {
    (*eidp) = rep->master_id;
  }
  rep->stat.st_elections_won = rep->stat.st_elections_won + 1U;
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  return;
}
}
static int __rep_wait(DB_ENV *dbenv___0 , u_int32_t timeout , int *eidp , u_int32_t flags ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int done ;
  u_int32_t sleeptime ;
  int tmp ;

  {
  done = 0;
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (timeout > 5000000U) {
    sleeptime = 500000U;
  } else {
    sleeptime = timeout / 10U;
  }
  if (sleeptime == 0U) {
    sleeptime ++;
  }
  while (timeout > 0U) {
    __os_sleep(dbenv___0, 0UL, (unsigned long )sleeptime);
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    if (! (rep->flags & flags)) {
      if (rep->master_id != -2) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    done = tmp;
    (*eidp) = rep->master_id;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    if (done) {
      return (0);
    }
    if (timeout > sleeptime) {
      timeout -= sleeptime;
    } else {
      timeout = 0U;
    }
  }
  return (-30893);
}
}
static int __rep_flush(DB_ENV *dbenv___0 ) 
{ DBT rec ;
  DB_LOGC *logc ;
  DB_LSN lsn ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"rep_flush", 65536U);
    return (tmp___0);
  }
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& rec), 0, sizeof(rec));
  memset((void *)(& lsn), 0, sizeof(lsn));
  ret = __log_c_get(logc, & lsn, & rec, 17U);
  if (ret != 0) {
    goto err;
  }
  __rep_send_message(dbenv___0, -1, 7U, & lsn, (DBT const   *)(& rec), 0U);
  err: 
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __rep_stat(DB_ENV *dbenv___0 , DB_REP_STAT **statp , u_int32_t flags ) 
{ DB_LOG *dblp ;
  DB_REP *db_rep ;
  DB_REP_STAT *stats___0 ;
  LOG *lp ;
  REP *rep ;
  u_int32_t queued ;
  u_int32_t repflags ;
  int dolock ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"rep_stat", 65536U);
    return (tmp___0);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  (*statp) = (DB_REP_STAT *)((void *)0);
  ret = __db_fchk(dbenv___0, "DB_ENV->rep_stat", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  ret = __os_umalloc(dbenv___0, sizeof(DB_REP_STAT ), (void *)(& stats___0));
  if (ret != 0) {
    return (ret);
  }
  repflags = rep->flags;
  if (repflags & 128U) {
    dolock = 0;
  } else {
    dolock = 1;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
  }
  memcpy((void * __restrict  )stats___0, (void const   * __restrict  )(& rep->stat),
         sizeof((*stats___0)));
  if (rep->flags & 259U) {
    if (rep->flags & 1U) {
      stats___0->st_election_status = 1;
    } else {
      if (rep->flags & 2U) {
        stats___0->st_election_status = 2;
      }
    }
    stats___0->st_election_nsites = rep->sites;
    stats___0->st_election_cur_winner = rep->winner;
    stats___0->st_election_priority = rep->w_priority;
    stats___0->st_election_gen = rep->w_gen;
    stats___0->st_election_lsn = rep->w_lsn;
    stats___0->st_election_votes = rep->votes;
    stats___0->st_election_tiebreaker = rep->w_tiebreaker;
  }
  stats___0->st_env_id = rep->eid;
  stats___0->st_env_priority = rep->priority;
  stats___0->st_nsites = rep->nsites;
  stats___0->st_master = rep->master_id;
  stats___0->st_gen = rep->gen;
  if (rep->flags & 8U) {
    stats___0->st_status = 4U;
  } else {
    if (rep->flags & 4U) {
      stats___0->st_status = 2U;
    } else {
      if (rep->flags & 512U) {
        stats___0->st_status = 1U;
      } else {
        stats___0->st_status = 0U;
      }
    }
  }
  if (flags & 1U) {
    queued = rep->stat.st_log_queued;
    memset((void *)(& rep->stat), 0, sizeof(rep->stat));
    rep->stat.st_log_queued_max = queued;
    rep->stat.st_log_queued_total = rep->stat.st_log_queued_max;
    rep->stat.st_log_queued = rep->stat.st_log_queued_total;
  }
  if (dolock) {
    stats___0->st_in_recovery = 0U;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
    }
  } else {
    stats___0->st_in_recovery = 1U;
  }
  if (rep->flags & 516U) {
    stats___0->st_next_lsn = lp->ready_lsn;
    stats___0->st_waiting_lsn = lp->waiting_lsn;
  } else {
    if (rep->flags & 8U) {
      stats___0->st_next_lsn = lp->lsn;
    } else {
      while (1) {
        stats___0->st_next_lsn.file = 0U;
        stats___0->st_next_lsn.offset = 0U;
        break;
      }
    }
    while (1) {
      stats___0->st_waiting_lsn.file = 0U;
      stats___0->st_waiting_lsn.offset = 0U;
      break;
    }
  }
  if (dolock) {
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
    }
  }
  (*statp) = stats___0;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-VwngSN3d.i","-O2")
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
int __db_apprec(DB_ENV *dbenv___0 , DB_LSN *max_lsn , DB_LSN *trunclsn , u_int32_t update ,
                u_int32_t flags ) ;
int __rep_cmp_vote2(DB_ENV *dbenv___0 , REP *rep , int eid , u_int32_t egen ) ;
int __rep_new_master(DB_ENV *dbenv___0 , REP_CONTROL *cntrl , int eid ) ;
int __db_put(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_c_del(DBC *dbc , u_int32_t flags ) ;
int __db_c_get(DBC *dbc_arg , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_dispatch(DB_ENV *dbenv___0 , int (**dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  ,
                                                   void * ) , size_t dtabsize , DBT *db ,
                  DB_LSN *lsnp , db_recops redo , void *info ) ;
int __db_truncate(DB *dbp___1 , DB_TXN *txn , u_int32_t *countp , u_int32_t flags ) ;
int __lock_id(DB_ENV *dbenv___0 , u_int32_t *idp ) ;
int __lock_id_free(DB_ENV *dbenv___0 , u_int32_t id ) ;
int __lock_vec(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DB_LOCKREQ *list___2 ,
               int nlist___0 , DB_LOCKREQ **elistp ) ;
int __lock_get_list(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , db_lockmode_t lock_mode ,
                    DBT *list___2 ) ;
int __log_vtruncate(DB_ENV *dbenv___0 , DB_LSN *lsn , DB_LSN *ckplsn , DB_LSN *trunclsn ) ;
int __log_is_outdated(DB_ENV *dbenv___0 , u_int32_t fnum , int *outdatedp ) ;
void __log_autoremove(DB_ENV *dbenv___0 ) ;
int __log_newfile(DB_LOG *dblp , DB_LSN *lsnp ) ;
int __log_rep_put(DB_ENV *dbenv___0 , DB_LSN *lsnp , DBT const   *rec ) ;
void __txn_updateckp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) ;
int __txn_child_read(DB_ENV *dbenv___0 , void *recbuf , __txn_child_args **argpp ) ;
static int __rep_apply(DB_ENV *dbenv___0 , REP_CONTROL *rp , DBT *rec , DB_LSN *ret_lsnp ) ;
static int __rep_collect_txn(DB_ENV *dbenv___0 , DB_LSN *lsnp , LSN_COLLECTION *lc ) ;
static int __rep_dorecovery(DB_ENV *dbenv___0 , DB_LSN *lsnp , DB_LSN *trunclsnp ) ;
static int __rep_lsn_cmp(void const   *lsn1 , void const   *lsn2 ) ;
static int __rep_newfile(DB_ENV *dbenv___0 , REP_CONTROL *rc , DB_LSN *lsnp ) ;
static int __rep_verify_match(DB_ENV *dbenv___0 , REP_CONTROL *rp , time_t savetime ) ;
int __rep_process_message(DB_ENV *dbenv___0 , DBT *control , DBT *rec , int *eidp ,
                          DB_LSN *ret_lsnp ) 
{ DB_LOG *dblp ;
  DB_LOGC *logc ;
  DB_LSN endlsn ;
  DB_LSN lsn ;
  DB_LSN oldfilelsn ;
  DB_REP *db_rep ;
  DBT *d ;
  DBT data_dbt ;
  DBT mylog ;
  LOG *lp ;
  REP *rep ;
  REP_CONTROL *rp ;
  REP_VOTE_INFO *vi ;
  u_int32_t bytes ;
  u_int32_t egen ;
  u_int32_t flags ;
  u_int32_t gen ;
  u_int32_t gbytes ;
  u_int32_t type ;
  int check_limit ;
  int cmp ;
  int done ;
  int do_req ;
  int master ;
  int old ;
  int recovering ;
  int ret ;
  int t_ret ;
  time_t savetime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->rep_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"rep_process_message", 65536U);
    return (tmp___0);
  }
  if ((unsigned int )control == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_process_message: control argument must be specified");
    return (22);
  } else {
    if (control->size == 0U) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_process_message: control argument must be specified");
      return (22);
    }
  }
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    if (((DB_REP *)dbenv___0->rep_handle)->region) {
      if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 8U)) {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Environment not configured as replication master or client");
          return (22);
        }
      } else {
        __db_err((DB_ENV const   *)dbenv___0, "Environment not configured as replication master or client");
        return (22);
      }
    } else {
      __db_err((DB_ENV const   *)dbenv___0, "Environment not configured as replication master or client");
      return (22);
    }
  }
  ret = 0;
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  rp = (REP_CONTROL *)control->data;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (rep->start_th != 0) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    if (rp->flags & 32U) {
      if ((unsigned int )ret_lsnp != (unsigned int )((void *)0)) {
        (*ret_lsnp) = rp->lsn;
      }
      return (-30981);
    } else {
      return (0);
    }
  }
  if (rep->in_recovery != 0) {
    rep->stat.st_msgs_recover = rep->stat.st_msgs_recover + 1U;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    return (0);
  }
  rep->msg_th = rep->msg_th + 1U;
  gen = rep->gen;
  if (rep->in_recovery) {
    tmp___1 = 1;
  } else {
    if (rep->flags & 192U) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  recovering = tmp___1;
  savetime = rep->timestamp;
  rep->stat.st_msgs_processed = rep->stat.st_msgs_processed + 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  if (rp->rep_version != 1U) {
    __db_err((DB_ENV const   *)dbenv___0, "unexpected replication message version %lu, expected %d",
             (unsigned long )rp->rep_version, 1);
    ret = 22;
    goto errlock;
  }
  if (rp->log_version != 8U) {
    __db_err((DB_ENV const   *)dbenv___0, "unexpected log record version %lu, expected %d",
             (unsigned long )rp->log_version, 8);
    ret = 22;
    goto errlock;
  }
  if (rp->gen < gen) {
    if (rp->rectype != 2U) {
      if (rp->rectype != 11U) {
        if (rp->rectype != 10U) {
          if (rp->rectype != 4U) {
            rep->stat.st_msgs_badgen = rep->stat.st_msgs_badgen + 1U;
            goto errlock;
          }
        }
      }
    }
  }
  if (rp->gen > gen) {
    if (rep->flags & 8U) {
      rep->stat.st_dupmasters = rep->stat.st_dupmasters + 1U;
      ret = -30987;
      if (rp->rectype != 4U) {
        __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                           0U);
      }
      goto errlock;
    }
    if (rp->rectype == 1U) {
      goto _L___1;
    } else {
      if (rp->rectype == 22U) {
        goto _L___1;
      } else {
        if (rp->rectype == 23U) {
          _L___1: 
          if (! ((db_rep->rep_mutexp)->flags & 2U)) {
            __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
          }
          rep->gen = rp->gen;
          gen = rep->gen;
          if (rep->egen <= gen) {
            rep->egen = rep->gen + 1U;
          }
          if (! ((db_rep->rep_mutexp)->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
          }
        } else {
          if (rp->rectype != 13U) {
            __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                               0U);
            goto errlock;
          }
        }
      }
    }
  }
  if (recovering) {
    switch ((int )rp->rectype) {
    case 19: ;
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
    }
    cmp = log_compare((DB_LSN const   *)(& lp->verify_lsn), (DB_LSN const   *)(& rp->lsn));
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
    }
    if (cmp != 0) {
      goto skip;
    }
    break;
    case 1: ;
    case 2: ;
    case 4: ;
    case 11: ;
    case 13: ;
    case 14: ;
    case 20: ;
    case 22: ;
    case 23: ;
    break;
    default: ;
    skip: 
    rep->stat.st_msgs_recover = rep->stat.st_msgs_recover + 1U;
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    lp->rcvd_recs = lp->rcvd_recs + 1U;
    do_req = lp->rcvd_recs >= lp->wait_recs;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    if (do_req) {
      lp->wait_recs = lp->wait_recs * 2U;
      if (lp->wait_recs > rep->max_gap) {
        lp->wait_recs = rep->max_gap;
      }
      lp->rcvd_recs = 0U;
      lsn = lp->verify_lsn;
    }
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
    }
    if (do_req) {
      if (rep->master_id == -2) {
        if (rp->rectype != 10U) {
          __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                             0U);
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if ((*eidp) == rep->master_id) {
          __rep_send_message(dbenv___0, (*eidp), 21U, & lsn, (DBT const   *)((void *)0),
                             0U);
        }
      }
    }
    goto errlock;
    }
  }
  switch ((int )rp->rectype) {
  case 1: 
  egen = (*((u_int32_t *)rec->data));
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (egen > rep->egen) {
    rep->egen = egen;
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  break;
  case 2: 
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  lsn = ((LOG *)dblp->reginfo.primary)->lsn;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  egen = rep->egen;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  data_dbt.data = (void *)(& egen);
  data_dbt.size = sizeof(egen);
  __rep_send_message(dbenv___0, (*eidp), 1U, & lsn, (DBT const   *)(& data_dbt), 0U);
  goto errlock;
  case 4: ;
  if (rep->flags & 8U) {
    ret = -30987;
  }
  goto errlock;
  case 3: ;
  while (1) {
    if (! (rep->flags & 8U)) {
      ret = 22;
      goto errlock;
    }
    break;
  }
  bytes = 0U;
  gbytes = bytes;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  gbytes = rep->gbytes;
  bytes = rep->bytes;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  if (gbytes != 0U) {
    tmp___2 = 1;
  } else {
    if (bytes != 0U) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  check_limit = tmp___2;
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto errlock;
  }
  memset((void *)(& data_dbt), 0, sizeof(data_dbt));
  lsn = rp->lsn;
  oldfilelsn = lsn;
  type = 7U;
  if (rp->lsn.file == 0U) {
    flags = 9U;
  } else {
    if (rp->lsn.file == 1U) {
      if (rp->lsn.offset == 0U) {
        flags = 9U;
      } else {
        flags = 28U;
      }
    } else {
      flags = 28U;
    }
  }
  ret = __log_c_get(logc, & lsn, & data_dbt, flags);
  while (1) {
    if (ret == 0) {
      if (! (type == 7U)) {
        break;
      }
    } else {
      break;
    }
    if (lsn.file != oldfilelsn.file) {
      __rep_send_message(dbenv___0, (*eidp), 12U, & oldfilelsn, (DBT const   *)((void *)0),
                         0U);
    }
    if (check_limit) {
      while (bytes < data_dbt.size + sizeof(REP_CONTROL )) {
        if (gbytes > 0U) {
          bytes += 1073741824U;
          gbytes --;
          continue;
        }
        rep->stat.st_nthrottles = rep->stat.st_nthrottles + 1U;
        type = 8U;
        goto send;
      }
      bytes -= data_dbt.size + sizeof(REP_CONTROL );
    }
    send: 
    tmp___3 = __rep_send_message(dbenv___0, (*eidp), type, & lsn, (DBT const   *)(& data_dbt),
                                 0U);
    if (tmp___3 != 0) {
      break;
    }
    oldfilelsn = lsn;
    oldfilelsn.offset = oldfilelsn.offset + logc->c_len;
    ret = __log_c_get(logc, & lsn, & data_dbt, 18U);
  }
  if (ret == -30990) {
    ret = 0;
  }
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  goto errlock;
  case 7: ;
  case 8: ;
  while (1) {
    if (! (rep->flags & 516U)) {
      __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      ret = -30987;
      goto errlock;
    }
    break;
  }
  while (1) {
    if (rep->master_id == -2) {
      ret = 0;
      __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      goto errlock;
    }
    if ((*eidp) != rep->master_id) {
      __db_err((DB_ENV const   *)dbenv___0, "Received master record from %d, master is %d",
               (*eidp), rep->master_id);
      ret = 22;
      goto errlock;
    }
    break;
  }
  ret = __rep_apply(dbenv___0, rp, rec, ret_lsnp);
  if (ret != 0) {
    goto errlock;
  }
  if (rp->rectype == 8U) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    master = rep->master_id;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    lsn = lp->lsn;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    if (master == -2) {
      ret = 0;
    } else {
      tmp___4 = __rep_send_message(dbenv___0, master, 3U, & lsn, (DBT const   *)((void *)0),
                                   0U);
      if (tmp___4 != 0) {
        break;
      }
    }
  }
  goto errlock;
  case 9: ;
  while (1) {
    if (! (rep->flags & 8U)) {
      ret = 22;
      goto errlock;
    }
    break;
  }
  lsn = rp->lsn;
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto errlock;
  }
  memset((void *)(& data_dbt), 0, sizeof(data_dbt));
  ret = __log_c_get(logc, & rp->lsn, & data_dbt, 28U);
  if (ret == 0) {
    __rep_send_message(dbenv___0, (*eidp), 7U, & rp->lsn, (DBT const   *)(& data_dbt),
                       0U);
  } else {
    if (ret == -30990) {
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      endlsn = lp->lsn;
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      if (endlsn.file > lsn.file) {
        endlsn.file = lsn.file + 1U;
        endlsn.offset = 0U;
        ret = __log_c_get(logc, & endlsn, & data_dbt, 28U);
        if (ret != 0) {
          goto _L___3;
        } else {
          ret = __log_c_get(logc, & endlsn, & data_dbt, 25U);
          if (ret != 0) {
            _L___3: 
            if (dbenv___0->verbose & 8U) {
              __db_err((DB_ENV const   *)dbenv___0, "Unable to get prev of [%lu][%lu]",
                       (unsigned long )lsn.file, (unsigned long )lsn.offset);
            }
            ret = -30980;
          } else {
            endlsn.offset = endlsn.offset + logc->c_len;
            __rep_send_message(dbenv___0, (*eidp), 12U, & endlsn, (DBT const   *)((void *)0),
                               0U);
          }
        }
      } else {
        __db_err((DB_ENV const   *)dbenv___0, "Request for LSN [%lu][%lu] fails",
                 (unsigned long )lsn.file, (unsigned long )lsn.offset);
        ret = 22;
      }
    }
  }
  while (1) {
    if (ret == 0) {
      if ((unsigned int )rec != (unsigned int )((void *)0)) {
        if (! (rec->size != 0U)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    ret = __log_c_get(logc, & lsn, & data_dbt, 18U);
    if (ret != 0) {
      if (ret == -30990) {
        ret = 0;
      }
      break;
    }
    tmp___5 = log_compare((DB_LSN const   *)(& lsn), (DB_LSN const   *)((DB_LSN *)rec->data));
    if (tmp___5 >= 0) {
      break;
    }
    tmp___6 = __rep_send_message(dbenv___0, (*eidp), 7U, & lsn, (DBT const   *)(& data_dbt),
                                 0U);
    if (tmp___6 != 0) {
      break;
    }
  }
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  goto errlock;
  case 14: 
  rep->stat.st_newsites = rep->stat.st_newsites + 1U;
  if (rep->flags & 8U) {
    dblp = (DB_LOG *)dbenv___0->lg_handle;
    lp = (LOG *)dblp->reginfo.primary;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    lsn = lp->lsn;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    __rep_send_message(dbenv___0, (*eidp), 13U, & lsn, (DBT const   *)((void *)0),
                       0U);
  }
  ret = -30982;
  goto errlock;
  case 11: 
  __rep_send_message(dbenv___0, -1, 14U, & rp->lsn, (DBT const   *)rec, 0U);
  ret = -30982;
  if (rep->flags & 512U) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    egen = rep->egen;
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    data_dbt.data = (void *)(& egen);
    data_dbt.size = sizeof(egen);
    __rep_send_message(dbenv___0, (*eidp), 1U, & rp->lsn, (DBT const   *)(& data_dbt),
                       0U);
    goto errlock;
  }
  case 10: ;
  if (rep->flags & 8U) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    lsn = lp->lsn;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    __rep_send_message(dbenv___0, -1, 13U, & lsn, (DBT const   *)((void *)0), 0U);
  }
  goto errlock;
  case 12: ;
  while (1) {
    if (! (rep->flags & 516U)) {
      __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      ret = -30987;
      goto errlock;
    }
    break;
  }
  while (1) {
    if (rep->master_id == -2) {
      ret = 0;
      __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      goto errlock;
    }
    if ((*eidp) != rep->master_id) {
      __db_err((DB_ENV const   *)dbenv___0, "Received master record from %d, master is %d",
               (*eidp), rep->master_id);
      ret = 22;
      goto errlock;
    }
    break;
  }
  ret = __rep_apply(dbenv___0, rp, rec, ret_lsnp);
  goto errlock;
  case 13: ;
  if (rep->flags & 8U) {
    if ((*eidp) != dbenv___0->rep_eid) {
      rep->stat.st_dupmasters = rep->stat.st_dupmasters + 1U;
      ret = -30987;
      __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      goto errlock;
    }
  }
  ret = __rep_new_master(dbenv___0, rp, (*eidp));
  goto errlock;
  case 15: ;
  while (1) {
    if (! (rep->flags & 516U)) {
      __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      ret = -30987;
      goto errlock;
    }
    break;
  }
  while (1) {
    if (rep->master_id == -2) {
      ret = 0;
      __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      goto errlock;
    }
    if ((*eidp) != rep->master_id) {
      __db_err((DB_ENV const   *)dbenv___0, "Received master record from %d, master is %d",
               (*eidp), rep->master_id);
      ret = 22;
      goto errlock;
    }
    break;
  }
  break;
  case 16: ;
  while (1) {
    if (! (rep->flags & 8U)) {
      ret = 22;
      goto errlock;
    }
    break;
  }
  break;
  case 17: ;
  while (1) {
    if (! (rep->flags & 516U)) {
      __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      ret = -30987;
      goto errlock;
    }
    break;
  }
  while (1) {
    if (rep->master_id == -2) {
      ret = 0;
      __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      goto errlock;
    }
    if ((*eidp) != rep->master_id) {
      __db_err((DB_ENV const   *)dbenv___0, "Received master record from %d, master is %d",
               (*eidp), rep->master_id);
      ret = 22;
      goto errlock;
    }
    break;
  }
  break;
  case 18: ;
  while (1) {
    if (! (rep->flags & 8U)) {
      ret = 22;
      goto errlock;
    }
    break;
  }
  break;
  case 19: ;
  while (1) {
    if (! (rep->flags & 516U)) {
      __rep_send_message(dbenv___0, -1, 4U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      ret = -30987;
      goto errlock;
    }
    break;
  }
  while (1) {
    if (rep->master_id == -2) {
      ret = 0;
      __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                         0U);
      goto errlock;
    }
    if ((*eidp) != rep->master_id) {
      __db_err((DB_ENV const   *)dbenv___0, "Received master record from %d, master is %d",
               (*eidp), rep->master_id);
      ret = 22;
      goto errlock;
    }
    break;
  }
  if (lp->verify_lsn.file == 0U) {
    goto errlock;
  }
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto errlock;
  }
  memset((void *)(& mylog), 0, sizeof(mylog));
  ret = __log_c_get(logc, & rp->lsn, & mylog, 28U);
  if (ret != 0) {
    goto rep_verify_err;
  }
  if (mylog.size == rec->size) {
    tmp___7 = memcmp((void const   *)mylog.data, (void const   *)rec->data, rec->size);
    if (tmp___7 == 0) {
      ret = __rep_verify_match(dbenv___0, rp, savetime);
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    ret = __log_c_get(logc, & lsn, & mylog, 25U);
    if (ret == 0) {
      if (! ((db_rep->db_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
      }
      lp->verify_lsn = lsn;
      lp->rcvd_recs = 0U;
      lp->wait_recs = rep->request_gap;
      if (! ((db_rep->db_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
      }
      __rep_send_message(dbenv___0, (*eidp), 21U, & lsn, (DBT const   *)((void *)0),
                         0U);
    } else {
      if (ret == -30990) {
        ret = -30980;
        if (rp->lsn.file != 1U) {
          __db_err((DB_ENV const   *)dbenv___0, "Too few log files to sync with master");
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Client was never part of master\'s environment");
        }
      }
    }
  }
  rep_verify_err: 
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  goto errlock;
  case 20: 
  rep->stat.st_outdated = rep->stat.st_outdated + 1U;
  ret = -30980;
  goto errlock;
  case 21: ;
  while (1) {
    if (! (rep->flags & 8U)) {
      ret = 22;
      goto errlock;
    }
    break;
  }
  type = 19U;
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto errlock;
  }
  d = & data_dbt;
  memset((void *)d, 0, sizeof(data_dbt));
  logc->flags = logc->flags | 4U;
  ret = __log_c_get(logc, & rp->lsn, d, 28U);
  if (ret == -30990) {
    tmp___8 = __log_is_outdated(dbenv___0, rp->lsn.file, & old);
    if (tmp___8 == 0) {
      if (old != 0) {
        type = 20U;
      }
    }
  }
  if (ret != 0) {
    d = (DBT *)((void *)0);
  }
  __rep_send_message(dbenv___0, (*eidp), type, & rp->lsn, (DBT const   *)d, 0U);
  ret = __log_c_close(logc);
  goto errlock;
  case 22: ;
  if (rep->flags & 8U) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    lsn = lp->lsn;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    __rep_send_message(dbenv___0, (*eidp), 13U, & lsn, (DBT const   *)((void *)0),
                       0U);
    goto errlock;
  }
  vi = (REP_VOTE_INFO *)rec->data;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (vi->egen < rep->egen) {
    goto errunlock;
  }
  if (vi->egen > rep->egen) {
    __rep_elect_done(dbenv___0, rep);
    rep->egen = vi->egen;
  }
  if (! (rep->flags & 3U)) {
    rep->flags = rep->flags | 256U;
  }
  if (vi->nsites > rep->nsites) {
    rep->nsites = vi->nsites;
  }
  if (rep->sites + 1 > rep->nsites) {
    rep->nsites = rep->sites + 1;
  }
  if (rep->nsites > rep->asites) {
    ret = __rep_grow_sites(dbenv___0, rep->nsites);
    if (ret != 0) {
      goto errunlock;
    }
  }
  if (rep->flags & 2U) {
    goto errunlock;
  }
  ret = __rep_tally(dbenv___0, rep, (*eidp), & rep->sites, vi->egen, rep->tally_off);
  if (ret != 0) {
    ret = 0;
    goto errunlock;
  }
  __rep_cmp_vote(dbenv___0, rep, eidp, & rp->lsn, vi->priority, (int )rp->gen, vi->tiebreaker);
  if (! (rep->flags & 3U)) {
    ret = -30985;
    goto errunlock;
  }
  master = rep->winner;
  lsn = rep->w_lsn;
  if (rep->sites >= rep->nsites) {
    if (rep->w_priority != 0) {
      tmp___9 = 1;
    } else {
      tmp___9 = 0;
    }
  } else {
    tmp___9 = 0;
  }
  done = tmp___9;
  if (done) {
    egen = rep->egen;
    rep->flags = rep->flags | 2U;
    rep->flags = rep->flags & 4294967294U;
    if (master == rep->eid) {
      __rep_tally(dbenv___0, rep, rep->eid, & rep->votes, egen, rep->v2tally_off);
      goto errunlock;
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    __rep_send_vote(dbenv___0, (DB_LSN *)((void *)0), 0, 0, 0, egen, master, 23U);
  } else {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
  }
  break;
  case 23: ;
  if (rep->flags & 8U) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    lsn = lp->lsn;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    rep->stat.st_elections_won = rep->stat.st_elections_won + 1U;
    __rep_send_message(dbenv___0, (*eidp), 13U, & lsn, (DBT const   *)((void *)0),
                       0U);
    goto errlock;
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  vi = (REP_VOTE_INFO *)rec->data;
  if (! (rep->flags & 259U)) {
    if (vi->egen >= rep->egen) {
      ret = -30985;
      goto errunlock;
    }
  }
  ret = __rep_cmp_vote2(dbenv___0, rep, (*eidp), vi->egen);
  if (ret != 0) {
    ret = 0;
    goto errunlock;
  }
  ret = __rep_tally(dbenv___0, rep, (*eidp), & rep->votes, vi->egen, rep->v2tally_off);
  if (ret != 0) {
    ret = 0;
    goto errunlock;
  }
  done = rep->votes > rep->nsites / 2;
  if (done) {
    __rep_elect_master(dbenv___0, rep, eidp);
    ret = -30983;
    goto errunlock;
  } else {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
  }
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->rep_process_message: unknown replication message: type %lu",
           (unsigned long )rp->rectype);
  ret = 22;
  goto errlock;
  }
  errlock: 
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  errunlock: 
  rep->msg_th = rep->msg_th - 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (ret);
}
}
static int __rep_apply(DB_ENV *dbenv___0 , REP_CONTROL *rp , DBT *rec , DB_LSN *ret_lsnp ) 
{ __dbreg_register_args dbreg_args ;
  __txn_ckp_args ckp_args ;
  DB_REP *db_rep ;
  DBT control_dbt ;
  DBT key_dbt ;
  DBT lsn_dbt ;
  DBT max_lsn_dbt ;
  DBT *max_lsn_dbtp ;
  DBT nextrec_dbt ;
  DBT rec_dbt ;
  DB *dbp___1 ;
  DBC *dbc ;
  DB_LOG *dblp ;
  DB_LSN ckp_lsn ;
  DB_LSN max_lsn ;
  DB_LSN next_lsn ;
  LOG *lp ;
  REP *rep ;
  REP_CONTROL *grp ;
  u_int32_t rectype ;
  u_int32_t txnid ;
  int cmp ;
  int do_req ;
  int eid ;
  int gap ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  dbp___1 = db_rep->rep_db;
  dbc = (DBC *)((void *)0);
  gap = 0;
  ret = gap;
  memset((void *)(& control_dbt), 0, sizeof(control_dbt));
  memset((void *)(& rec_dbt), 0, sizeof(rec_dbt));
  max_lsn_dbtp = (DBT *)((void *)0);
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  lp = (LOG *)dblp->reginfo.primary;
  cmp = log_compare((DB_LSN const   *)(& rp->lsn), (DB_LSN const   *)(& lp->ready_lsn));
  if (cmp == 0) {
    if (rp->rectype == 12U) {
      ret = __rep_newfile(dbenv___0, rp, & lp->ready_lsn);
      rectype = 0U;
    } else {
      if (rp->flags & 32U) {
        gap = 1;
        max_lsn = rp->lsn;
      }
      ret = __log_rep_put(dbenv___0, & rp->lsn, (DBT const   *)rec);
      memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )rec->data,
             sizeof(rectype));
      if (ret == 0) {
        rep->stat.st_log_records = rep->stat.st_log_records + 1U;
      }
    }
    lp->rcvd_recs = 0U;
    while (1) {
      if (ret == 0) {
        if (rectype != 10U) {
          if (rectype != 13U) {
            if (rectype != 11U) {
              if (rectype != 2U) {
                tmp = log_compare((DB_LSN const   *)(& lp->ready_lsn), (DB_LSN const   *)(& lp->waiting_lsn));
                if (! (tmp == 0)) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      gap_check: 
      max_lsn_dbtp = (DBT *)((void *)0);
      lp->wait_recs = 0U;
      lp->rcvd_recs = 0U;
      while (1) {
        lp->max_wait_lsn.file = 0U;
        lp->max_wait_lsn.offset = 0U;
        break;
      }
      if ((unsigned int )dbc == (unsigned int )((void *)0)) {
        ret = __db_cursor(dbp___1, (DB_TXN *)((void *)0), & dbc, 0U);
        if (ret != 0) {
          goto done;
        }
      }
      control_dbt.flags = control_dbt.flags | 16U;
      rec_dbt.flags = rec_dbt.flags | 16U;
      ret = __db_c_get(dbc, & control_dbt, & rec_dbt, 268435465U);
      if (ret != 0) {
        goto done;
      }
      rp = (REP_CONTROL *)control_dbt.data;
      rec = & rec_dbt;
      memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )rec->data,
             sizeof(rectype));
      if (rp->rectype != 12U) {
        ret = __log_rep_put(dbenv___0, & rp->lsn, (DBT const   *)rec);
        if (ret == 0) {
          rep->stat.st_log_records = rep->stat.st_log_records + 1U;
        }
      } else {
        ret = __rep_newfile(dbenv___0, rp, & lp->ready_lsn);
        rectype = 0U;
      }
      ret = __db_c_del(dbc, 0U);
      if (ret != 0) {
        goto done;
      }
      if (rp->flags & 32U) {
        gap = 1;
        max_lsn = rp->lsn;
      }
      rep->stat.st_log_queued = rep->stat.st_log_queued - 1U;
      memset((void *)(& nextrec_dbt), 0, sizeof(nextrec_dbt));
      nextrec_dbt.flags = nextrec_dbt.flags | 8U;
      nextrec_dbt.dlen = 0U;
      nextrec_dbt.ulen = nextrec_dbt.dlen;
      memset((void *)(& lsn_dbt), 0, sizeof(lsn_dbt));
      ret = __db_c_get(dbc, & lsn_dbt, & nextrec_dbt, 18U);
      if (ret != -30990) {
        if (ret != 0) {
          goto done;
        }
      }
      if (ret == -30990) {
        while (1) {
          lp->waiting_lsn.file = 0U;
          lp->waiting_lsn.offset = 0U;
          break;
        }
        break;
      }
      grp = (REP_CONTROL *)lsn_dbt.data;
      lp->waiting_lsn = grp->lsn;
      if (rectype != 10U) {
        if (rectype != 13U) {
          if (rectype != 11U) {
            if (! (rectype != 2U)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    }
    do_req = 0;
    if (! (lp->waiting_lsn.file == 0U)) {
      tmp___1 = log_compare((DB_LSN const   *)(& lp->ready_lsn), (DB_LSN const   *)(& lp->waiting_lsn));
      if (tmp___1 != 0) {
        next_lsn = lp->ready_lsn;
        lp->rcvd_recs = lp->rcvd_recs + 1U;
        do_req = lp->rcvd_recs >= lp->wait_recs;
        if (do_req) {
          lp->wait_recs = rep->request_gap;
          lp->rcvd_recs = 0U;
          tmp___0 = log_compare((DB_LSN const   *)(& rp->lsn), (DB_LSN const   *)(& lp->max_wait_lsn));
          if (tmp___0 == 0) {
            lp->max_wait_lsn = lp->waiting_lsn;
            memset((void *)(& max_lsn_dbt), 0, sizeof(max_lsn_dbt));
            max_lsn_dbt.data = (void *)(& lp->waiting_lsn);
            max_lsn_dbt.size = sizeof(lp->waiting_lsn);
            max_lsn_dbtp = & max_lsn_dbt;
          }
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      lp->wait_recs = 0U;
      while (1) {
        lp->max_wait_lsn.file = 0U;
        lp->max_wait_lsn.offset = 0U;
        break;
      }
    }
    if ((unsigned int )dbc != (unsigned int )((void *)0)) {
      ret = __db_c_close(dbc);
      if (ret != 0) {
        goto done;
      }
    }
    dbc = (DBC *)((void *)0);
    if (do_req) {
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
      }
      eid = (db_rep->region)->master_id;
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
      }
      if (eid != -2) {
        rep->stat.st_log_requested = rep->stat.st_log_requested + 1U;
        __rep_send_message(dbenv___0, eid, 9U, & next_lsn, (DBT const   *)max_lsn_dbtp,
                           0U);
      }
    }
  } else {
    if (cmp > 0) {
      memset((void *)(& key_dbt), 0, sizeof(key_dbt));
      key_dbt.data = (void *)rp;
      key_dbt.size = sizeof((*rp));
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      next_lsn = lp->lsn;
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      do_req = 0;
      if (lp->wait_recs == 0U) {
        lp->wait_recs = rep->request_gap;
        lp->rcvd_recs = 0U;
        while (1) {
          lp->max_wait_lsn.file = 0U;
          lp->max_wait_lsn.offset = 0U;
          break;
        }
      }
      lp->rcvd_recs = lp->rcvd_recs + 1U;
      if (lp->rcvd_recs >= lp->wait_recs) {
        do_req = 1;
        lp->rcvd_recs = 0U;
        lp->wait_recs = lp->wait_recs * 2U;
        if (lp->wait_recs > rep->max_gap) {
          lp->wait_recs = rep->max_gap;
        }
        if (lp->max_wait_lsn.file == 0U) {
          lp->max_wait_lsn = lp->waiting_lsn;
          memset((void *)(& max_lsn_dbt), 0, sizeof(max_lsn_dbt));
          max_lsn_dbt.data = (void *)(& lp->waiting_lsn);
          max_lsn_dbt.size = sizeof(lp->waiting_lsn);
          max_lsn_dbtp = & max_lsn_dbt;
        } else {
          max_lsn_dbtp = (DBT *)((void *)0);
          lp->max_wait_lsn = next_lsn;
        }
      }
      ret = __db_put(dbp___1, (DB_TXN *)((void *)0), & key_dbt, rec, 0U);
      rep->stat.st_log_queued = rep->stat.st_log_queued + 1U;
      rep->stat.st_log_queued_total = rep->stat.st_log_queued_total + 1U;
      if (rep->stat.st_log_queued_max < rep->stat.st_log_queued) {
        rep->stat.st_log_queued_max = rep->stat.st_log_queued;
      }
      if (ret != 0) {
        goto done;
      }
      if (lp->waiting_lsn.file == 0U) {
        lp->waiting_lsn = rp->lsn;
      } else {
        tmp___2 = log_compare((DB_LSN const   *)(& rp->lsn), (DB_LSN const   *)(& lp->waiting_lsn));
        if (tmp___2 < 0) {
          lp->waiting_lsn = rp->lsn;
        }
      }
      if (do_req) {
        if (! ((db_rep->rep_mutexp)->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
        }
        eid = (db_rep->region)->master_id;
        if (eid != -2) {
          rep->stat.st_log_requested = rep->stat.st_log_requested + 1U;
          if (! ((db_rep->rep_mutexp)->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
          }
          __rep_send_message(dbenv___0, eid, 9U, & next_lsn, (DBT const   *)max_lsn_dbtp,
                             0U);
        } else {
          if (! ((db_rep->rep_mutexp)->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
          }
          __rep_send_message(dbenv___0, -1, 10U, (DB_LSN *)((void *)0), (DBT const   *)((void *)0),
                             0U);
        }
      }
      if (ret == 0) {
        if (rp->flags & 32U) {
          if ((unsigned int )ret_lsnp != (unsigned int )((void *)0)) {
            (*ret_lsnp) = rp->lsn;
          }
          ret = -30981;
        }
      }
      goto done;
    } else {
      rep->stat.st_log_duplicated = rep->stat.st_log_duplicated + 1U;
      goto done;
    }
  }
  if (ret != 0) {
    goto done;
  } else {
    if (cmp < 0) {
      goto done;
    } else {
      if (cmp == 0) {
        if (rectype != 10U) {
          if (rectype != 13U) {
            if (rectype != 11U) {
              if (rectype != 2U) {
                goto done;
              }
            }
          }
        }
      }
    }
  }
  switch ((int )rectype) {
  case 2: 
  memcpy((void * __restrict  )(& txnid), (void const   * __restrict  )((u_int8_t *)rec->data +
                                                                       ((u_int8_t *)(& dbreg_args.txnid) -
                                                                        (u_int8_t *)(& dbreg_args))),
         sizeof(u_int32_t ));
  if (txnid == 0U) {
    if (! (rep->flags & 4U)) {
      ret = __db_dispatch(dbenv___0, dbenv___0->recover_dtab, dbenv___0->recover_dtab_size,
                          rec, & rp->lsn, (enum __anonenum_db_recops_55 )1, (void *)0);
    }
  }
  break;
  case 11: 
  memcpy((void * __restrict  )(& ckp_lsn), (void const   * __restrict  )((u_int8_t *)rec->data +
                                                                         ((u_int8_t *)(& ckp_args.ckp_lsn) -
                                                                          (u_int8_t *)(& ckp_args))),
         sizeof(DB_LSN ));
  if (! (rep->flags & 4U)) {
    ret = __memp_sync(dbenv___0, & ckp_lsn);
  } else {
    ret = __log_flush(dbenv___0, (DB_LSN const   *)(& ckp_lsn));
  }
  if (ret == 0) {
    __txn_updateckp(dbenv___0, & rp->lsn);
  } else {
    __db_err((DB_ENV const   *)dbenv___0, "Error syncing ckp [%lu][%lu]", (unsigned long )ckp_lsn.file,
             (unsigned long )ckp_lsn.offset);
    __db_panic(dbenv___0, ret);
  }
  break;
  case 10: ;
  if (! (rep->flags & 4U)) {
    while (1) {
      ret = __rep_process_txn(dbenv___0, rec);
      if (! (ret == -30995)) {
        break;
      }
    }
  }
  if (ret == 0) {
    if (! (dbenv___0->flags & 4194304U)) {
      ret = __log_flush(dbenv___0, (DB_LSN const   *)((void *)0));
    }
  }
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Error processing txn [%lu][%lu]", (unsigned long )rp->lsn.file,
             (unsigned long )rp->lsn.offset);
    __db_panic(dbenv___0, ret);
  }
  break;
  case 13: 
  ret = __log_flush(dbenv___0, (DB_LSN const   *)((void *)0));
  break;
  default: ;
  goto done;
  }
  if (ret == 0) {
    tmp___3 = log_compare((DB_LSN const   *)(& lp->ready_lsn), (DB_LSN const   *)(& lp->waiting_lsn));
    if (tmp___3 == 0) {
      goto gap_check;
    }
  }
  done: 
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  if (ret == 0) {
    if (dbenv___0->flags & 512U) {
      if (rp->rectype == 12U) {
        __log_autoremove(dbenv___0);
      }
    }
  }
  if ((unsigned int )control_dbt.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, control_dbt.data);
  }
  if ((unsigned int )rec_dbt.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, rec_dbt.data);
  }
  if (ret == 0) {
    if (gap) {
      if ((unsigned int )ret_lsnp != (unsigned int )((void *)0)) {
        (*ret_lsnp) = max_lsn;
      }
      ret = -30984;
    }
  }
  return (ret);
}
}
int __rep_process_txn(DB_ENV *dbenv___0 , DBT *rec ) 
{ DBT data_dbt ;
  DBT *lock_dbt ;
  DB_LOCKREQ req ;
  DB_LOCKREQ *lvp ;
  DB_LOGC *logc ;
  DB_LSN prev_lsn ;
  DB_LSN *lsnp ;
  DB_REP *db_rep ;
  LSN_COLLECTION lc ;
  REP *rep ;
  __txn_regop_args *txn_args ;
  __txn_xa_regop_args *prep_args ;
  u_int32_t lockid ;
  u_int32_t rectype ;
  int i ;
  int ret ;
  int t_ret ;
  void *txninfo ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  logc = (DB_LOGC *)((void *)0);
  txninfo = (void *)0;
  memset((void *)(& data_dbt), 0, sizeof(data_dbt));
  if (dbenv___0->flags & 1048576U) {
    data_dbt.flags = data_dbt.flags | 16U;
  }
  memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )rec->data,
         sizeof(rectype));
  memset((void *)(& lc), 0, sizeof(lc));
  if (rectype == 10U) {
    ret = __txn_regop_read(dbenv___0, rec->data, & txn_args);
    if (ret != 0) {
      return (ret);
    }
    if (txn_args->opcode != 1U) {
      __os_free(dbenv___0, (void *)txn_args);
      return (0);
    }
    prev_lsn = txn_args->prev_lsn;
    lock_dbt = & txn_args->locks;
  } else {
    ret = __txn_xa_regop_read(dbenv___0, rec->data, & prep_args);
    if (ret != 0) {
      return (ret);
    }
    prev_lsn = prep_args->prev_lsn;
    lock_dbt = & prep_args->locks;
  }
  ret = __lock_id(dbenv___0, & lockid);
  if (ret != 0) {
    goto err1;
  }
  ret = __lock_get_list(dbenv___0, lockid, 0U, (enum __anonenum_db_lockmode_t_50 )2,
                        lock_dbt);
  if (ret != 0) {
    goto err;
  }
  ret = __rep_collect_txn(dbenv___0, & prev_lsn, & lc);
  if (ret != 0) {
    goto err;
  }
  qsort((void *)lc.array, (unsigned int )lc.nlsns, sizeof(DB_LSN ), & __rep_lsn_cmp);
  ret = __db_txnlist_init(dbenv___0, 0U, 0U, (DB_LSN *)((void *)0), (void *)(& txninfo));
  if (ret != 0) {
    goto err;
  }
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto err;
  }
  lsnp = lc.array + 0;
  i = 0;
  while (i < lc.nlsns) {
    ret = __log_c_get(logc, lsnp, & data_dbt, 28U);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "failed to read the log at [%lu][%lu]",
               (unsigned long )lsnp->file, (unsigned long )lsnp->offset);
      goto err;
    }
    ret = __db_dispatch(dbenv___0, dbenv___0->recover_dtab, dbenv___0->recover_dtab_size,
                        & data_dbt, lsnp, (enum __anonenum_db_recops_55 )1, txninfo);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "transaction failed at [%lu][%lu]", (unsigned long )lsnp->file,
               (unsigned long )lsnp->offset);
      goto err;
    }
    i ++;
    lsnp ++;
  }
  err: 
  memset((void *)(& req), 0, sizeof(req));
  req.op = (enum __anonenum_db_lockop_t_51 )5;
  t_ret = __lock_vec(dbenv___0, lockid, 0U, & req, 1, & lvp);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __lock_id_free(dbenv___0, lockid);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  err1: 
  if (rectype == 10U) {
    __os_free(dbenv___0, (void *)txn_args);
  } else {
    __os_free(dbenv___0, (void *)prep_args);
  }
  if (lc.nalloc != 0) {
    __os_free(dbenv___0, (void *)lc.array);
  }
  if ((unsigned int )logc != (unsigned int )((void *)0)) {
    t_ret = __log_c_close(logc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )txninfo != (unsigned int )((void *)0)) {
    __db_txnlist_end(dbenv___0, txninfo);
  }
  if (data_dbt.flags & 16U) {
    if ((unsigned int )data_dbt.data != (unsigned int )((void *)0)) {
      __os_ufree(dbenv___0, data_dbt.data);
    }
  }
  if (ret == 0) {
    rep->stat.st_txns_applied = rep->stat.st_txns_applied + 1U;
  }
  return (ret);
}
}
static int __rep_collect_txn(DB_ENV *dbenv___0 , DB_LSN *lsnp , LSN_COLLECTION *lc ) 
{ __txn_child_args *argp ;
  DB_LOGC *logc ;
  DB_LSN c_lsn ;
  DBT data ;
  u_int32_t rectype ;
  int nalloc ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  memset((void *)(& data), 0, sizeof(data));
  data.flags = data.flags | 16U;
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    if (! (lsnp->file == 0U)) {
      ret = __log_c_get(logc, lsnp, & data, 28U);
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )data.data,
           sizeof(rectype));
    if (rectype == 12U) {
      ret = __txn_child_read(dbenv___0, data.data, & argp);
      if (ret != 0) {
        goto err;
      }
      c_lsn = argp->c_lsn;
      (*lsnp) = argp->prev_lsn;
      __os_free(dbenv___0, (void *)argp);
      ret = __rep_collect_txn(dbenv___0, & c_lsn, lc);
    } else {
      if (lc->nalloc < lc->nlsns + 1) {
        if (lc->nalloc == 0) {
          nalloc = 20;
        } else {
          nalloc = lc->nalloc * 2;
        }
        ret = __os_realloc(dbenv___0, (unsigned int )nalloc * sizeof(DB_LSN ), (void *)(& lc->array));
        if (ret != 0) {
          goto err;
        }
        lc->nalloc = nalloc;
      }
      tmp = lc->nlsns;
      lc->nlsns ++;
      (*(lc->array + tmp)) = (*lsnp);
      memcpy((void * __restrict  )lsnp, (void const   * __restrict  )(((u_int8_t *)data.data +
                                                                       sizeof(u_int32_t )) +
                                                                      sizeof(u_int32_t )),
             sizeof(DB_LSN ));
    }
    if (ret != 0) {
      goto err;
    }
  }
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "collect failed at: [%lu][%lu]", (unsigned long )lsnp->file,
             (unsigned long )lsnp->offset);
  }
  err: 
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )data.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, data.data);
  }
  return (ret);
}
}
static int __rep_lsn_cmp(void const   *lsn1 , void const   *lsn2 ) 
{ int tmp ;

  {
  tmp = log_compare((DB_LSN const   *)((DB_LSN *)lsn1), (DB_LSN const   *)((DB_LSN *)lsn2));
  return (tmp);
}
}
static int __rep_newfile(DB_ENV *dbenv___0 , REP_CONTROL *rc , DB_LSN *lsnp ) 
{ DB_LOG *dblp ;
  LOG *lp ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (rc->lsn.file + 1U > lp->lsn.file) {
    tmp = __log_newfile(dblp, lsnp);
    return (tmp);
  } else {
    (*lsnp) = lp->lsn;
    return (0);
  }
}
}
int __rep_tally(DB_ENV *dbenv___0 , REP *rep , int eid , int *countp , u_int32_t egen ,
                u_int32_t vtoff ) 
{ REP_VTALLY *tally ;
  REP_VTALLY *vtp ;
  int i ;

  {
  rep = (REP *)((void *)0);
  rep = rep;
  tally = (REP_VTALLY *)((void *)((u_int8_t *)((REGINFO *)dbenv___0->reginfo)->addr +
                                  vtoff));
  i = 0;
  vtp = tally + i;
  while (i < (*countp)) {
    if (vtp->eid == eid) {
      if (vtp->egen >= egen) {
        return (1);
      } else {
        vtp->egen = egen;
        return (0);
      }
    }
    i ++;
    vtp = tally + i;
  }
  vtp->eid = eid;
  vtp->egen = egen;
  (*countp) ++;
  return (0);
}
}
void __rep_cmp_vote(DB_ENV *dbenv___0 , REP *rep , int *eidp , DB_LSN *lsnp , int priority ,
                    int gen , int tiebreaker ) 
{ int cmp ;

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  cmp = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& rep->w_lsn));
  if (rep->sites > 1) {
    if (priority != 0) {
      if (cmp > 0) {
        rep->winner = (*eidp);
        rep->w_priority = priority;
        rep->w_lsn = (*lsnp);
        rep->w_gen = (unsigned int )gen;
        rep->w_tiebreaker = tiebreaker;
      } else {
        if (cmp == 0) {
          if (priority > rep->w_priority) {
            rep->winner = (*eidp);
            rep->w_priority = priority;
            rep->w_lsn = (*lsnp);
            rep->w_gen = (unsigned int )gen;
            rep->w_tiebreaker = tiebreaker;
          } else {
            if (priority == rep->w_priority) {
              if (tiebreaker > rep->w_tiebreaker) {
                rep->winner = (*eidp);
                rep->w_priority = priority;
                rep->w_lsn = (*lsnp);
                rep->w_gen = (unsigned int )gen;
                rep->w_tiebreaker = tiebreaker;
              }
            }
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (rep->sites == 1) {
      if (priority != 0) {
        rep->winner = (*eidp);
        rep->w_priority = priority;
        rep->w_gen = (unsigned int )gen;
        rep->w_lsn = (*lsnp);
        rep->w_tiebreaker = tiebreaker;
      } else {
        rep->winner = -2;
        rep->w_priority = 0;
        rep->w_gen = 0U;
        while (1) {
          rep->w_lsn.file = 0U;
          rep->w_lsn.offset = 0U;
          break;
        }
        rep->w_tiebreaker = 0;
      }
    }
  }
  return;
}
}
int __rep_cmp_vote2(DB_ENV *dbenv___0 , REP *rep , int eid , u_int32_t egen ) 
{ int i ;
  REP_VTALLY *tally ;
  REP_VTALLY *vtp ;

  {
  tally = (REP_VTALLY *)((void *)((u_int8_t *)((REGINFO *)dbenv___0->reginfo)->addr +
                                  rep->tally_off));
  i = 0;
  vtp = tally + i;
  i = 0;
  while (i < rep->sites) {
    vtp = tally + i;
    if (vtp->eid == eid) {
      if (vtp->egen == egen) {
        return (0);
      }
    }
    i ++;
  }
  return (1);
}
}
static int __rep_dorecovery(DB_ENV *dbenv___0 , DB_LSN *lsnp , DB_LSN *trunclsnp ) 
{ DB_LSN lsn ;
  DBT mylog ;
  DB_LOGC *logc ;
  int ret ;
  int t_ret ;
  int undo ;
  u_int32_t rectype ;
  __txn_regop_args *txnrec ;
  int tmp ;

  {
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& mylog), 0, sizeof(mylog));
  undo = 0;
  while (1) {
    if (undo == 0) {
      ret = __log_c_get(logc, & lsn, & mylog, 25U);
      if (ret == 0) {
        tmp = log_compare((DB_LSN const   *)(& lsn), (DB_LSN const   *)lsnp);
        if (! (tmp > 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )mylog.data,
           sizeof(rectype));
    if (rectype == 10U) {
      ret = __txn_regop_read(dbenv___0, mylog.data, & txnrec);
      if (ret != 0) {
        goto err;
      }
      if (txnrec->opcode != 3U) {
        undo = 1;
      }
      __os_free(dbenv___0, (void *)txnrec);
    }
  }
  ret = __db_apprec(dbenv___0, lsnp, trunclsnp, (unsigned int )undo, 0U);
  err: 
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __rep_verify_match(DB_ENV *dbenv___0 , REP_CONTROL *rp , time_t savetime ) 
{ DB_LOG *dblp ;
  DB_LSN ckplsn ;
  DB_LSN trunclsn ;
  DB_REP *db_rep ;
  LOG *lp ;
  REP *rep ;
  int done ;
  int master ;
  int ret ;
  int wait_cnt ;
  u_int32_t unused ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  lp = (LOG *)dblp->reginfo.primary;
  ret = 0;
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  done = savetime != rep->timestamp;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  if (done) {
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
    }
    return (0);
  }
  while (1) {
    lp->verify_lsn.file = 0U;
    lp->verify_lsn.offset = 0U;
    break;
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (rp->lsn.file == lp->lsn.file) {
    if (rp->lsn.offset + lp->len == lp->lsn.offset) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  done = tmp;
  if (done) {
    lp->ready_lsn = lp->lsn;
    while (1) {
      lp->waiting_lsn.file = 0U;
      lp->waiting_lsn.offset = 0U;
      break;
    }
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (done) {
    goto finish;
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  if (rep->flags & 4U) {
    while (1) {
      ckplsn.file = 1U;
      ckplsn.offset = 0U;
      break;
    }
    ret = __log_flush(dbenv___0, (DB_LSN const   *)(& rp->lsn));
    if (ret != 0) {
      return (ret);
    } else {
      ret = __log_vtruncate(dbenv___0, & rp->lsn, & ckplsn, & trunclsn);
      if (ret != 0) {
        return (ret);
      }
    }
  } else {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    if (rep->flags & 64U) {
      rep->stat.st_msgs_recover = rep->stat.st_msgs_recover + 1U;
      goto errunlock;
    } else {
      if (rep->in_recovery != 0) {
        rep->stat.st_msgs_recover = rep->stat.st_msgs_recover + 1U;
        goto errunlock;
      }
    }
    rep->flags = rep->flags | 64U;
    wait_cnt = 0;
    while (rep->op_cnt != 0U) {
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
      }
      __os_sleep(dbenv___0, 1UL, 0UL);
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
      }
    }
    rep->in_recovery = 1;
    wait_cnt = 0;
    while (1) {
      if (! (rep->handle_cnt != 0U)) {
        if (! (rep->msg_th > 1U)) {
          break;
        }
      }
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
      }
      __os_sleep(dbenv___0, 1UL, 0UL);
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
      }
    }
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    ret = __rep_dorecovery(dbenv___0, & rp->lsn, & trunclsn);
    if (ret != 0) {
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
      }
      rep->in_recovery = 0;
      rep->flags = rep->flags & 4294967231U;
      goto errunlock;
    }
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  lp->ready_lsn = trunclsn;
  finish: 
  while (1) {
    lp->waiting_lsn.file = 0U;
    lp->waiting_lsn.offset = 0U;
    break;
  }
  lp->wait_recs = 0U;
  lp->rcvd_recs = 0U;
  while (1) {
    lp->verify_lsn.file = 0U;
    lp->verify_lsn.offset = 0U;
    break;
  }
  (db_rep->rep_db)->flags = (db_rep->rep_db)->flags | 2097152U;
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  ret = __db_truncate(db_rep->rep_db, (DB_TXN *)((void *)0), & unused, 0U);
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  (db_rep->rep_db)->flags = (db_rep->rep_db)->flags & 4292870143U;
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  rep->stat.st_log_queued = 0U;
  rep->in_recovery = 0;
  rep->flags = rep->flags & 4294967071U;
  if (ret != 0) {
    goto errunlock;
  }
  master = rep->master_id;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  if (master == -2) {
    ret = 0;
  } else {
    __rep_send_message(dbenv___0, master, 3U, & rp->lsn, (DBT const   *)((void *)0),
                       0U);
  }
  if (0) {
    errunlock: 
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-KBrcUv7d.i","-O2")
int __db_mutex_setup(DB_ENV *dbenv___0 , REGINFO *infop , void *ptr , u_int32_t flags ) ;
int __db_shalloc(void *p , size_t len , size_t align , void *retp ) ;
int __rep_region_destroy(DB_ENV *dbenv___0 ) ;
void __rep_dbenv_refresh(DB_ENV *dbenv___0 ) ;
int __rep_dbenv_close(DB_ENV *dbenv___0 ) ;
int __dbreg_close_files(DB_ENV *dbenv___0 ) ;
int __rep_region_init(DB_ENV *dbenv___0 ) 
{ REGENV *renv ;
  REGINFO *infop ;
  DB_MUTEX *db_mutexp ;
  DB_REP *db_rep ;
  REP *rep ;
  int ret ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  infop = (REGINFO *)dbenv___0->reginfo;
  renv = (REGENV *)infop->primary;
  ret = 0;
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  if (renv->rep_off == 0U) {
    ret = __db_shalloc(infop->addr, sizeof(REP ), 1U, (void *)(& rep));
    if (ret != 0) {
      goto err;
    }
    memset((void *)rep, 0, sizeof((*rep)));
    rep->tally_off = 0U;
    rep->v2tally_off = 0U;
    renv->rep_off = (unsigned int )((u_int8_t *)rep - (u_int8_t *)infop->addr);
    ret = __db_mutex_setup(dbenv___0, infop, (void *)(& rep->mutex), 32U);
    if (ret != 0) {
      goto err;
    }
    ret = __db_shalloc(infop->addr, sizeof(DB_MUTEX ), 1U, (void *)(& db_mutexp));
    if (ret != 0) {
      goto err;
    }
    rep->db_mutex_off = (unsigned int )((u_int8_t *)db_mutexp - (u_int8_t *)infop->addr);
    ret = __db_mutex_setup(dbenv___0, infop, (void *)db_mutexp, 32U);
    if (ret != 0) {
      goto err;
    }
    rep->eid = -2;
    rep->master_id = -2;
    rep->gen = 0U;
    rep->egen = rep->gen + 1U;
    rep->request_gap = 4U;
    rep->max_gap = 128U;
    rep->flags = rep->flags | 32U;
    time(& rep->timestamp);
  } else {
    rep = (REP *)((void *)((u_int8_t *)infop->addr + renv->rep_off));
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  db_rep->rep_mutexp = & rep->mutex;
  db_rep->db_mutexp = (DB_MUTEX *)((void *)((u_int8_t *)infop->addr + rep->db_mutex_off));
  db_rep->region = rep;
  return (0);
  err: 
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  return (ret);
}
}
int __rep_region_destroy(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  t_ret = 0;
  ret = t_ret;
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  if ((unsigned int )db_rep != (unsigned int )((void *)0)) {
    if ((unsigned int )db_rep->rep_mutexp != (unsigned int )((void *)0)) {
      ret = __db_pthread_mutex_destroy(db_rep->rep_mutexp);
    }
    if ((unsigned int )db_rep->db_mutexp != (unsigned int )((void *)0)) {
      t_ret = __db_pthread_mutex_destroy(db_rep->db_mutexp);
    }
  }
  if (ret == 0) {
    tmp = t_ret;
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
void __rep_dbenv_refresh(DB_ENV *dbenv___0 ) 
{ 

  {
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    ((DB_REP *)dbenv___0->rep_handle)->region = (REP *)((void *)0);
  }
  return;
}
}
int __rep_dbenv_close(DB_ENV *dbenv___0 ) 
{ 

  {
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, dbenv___0->rep_handle);
    dbenv___0->rep_handle = (void *)0;
    dbenv___0->rep_send = (int (*)(DB_ENV * , DBT const   * , DBT const   * , DB_LSN const   * ,
                                   int  , u_int32_t  ))((void *)0);
  }
  return (0);
}
}
int __rep_preclose(DB_ENV *dbenv___0 , int do_closefiles ) 
{ DB *dbp___1 ;
  DB_REP *db_rep ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  t_ret = 0;
  ret = t_ret;
  if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  dbp___1 = db_rep->rep_db;
  if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
    }
    ret = __db_close(dbp___1, (DB_TXN *)((void *)0), 23U);
    db_rep->rep_db = (DB *)((void *)0);
    if (! ((db_rep->db_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
    }
  }
  if (do_closefiles) {
    t_ret = __dbreg_close_files(dbenv___0);
  }
  if (ret == 0) {
    tmp = t_ret;
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-VbIT8i4u.i","-O2")
void __db_shalloc_free(void *regionp , void *ptr ) ;
int __rep_is_client(DB_ENV *dbenv___0 ) ;
int __rep_noarchive(DB_ENV *dbenv___0 ) ;
void __env_rep_enter(DB_ENV *dbenv___0 ) ;
void __env_rep_exit(DB_ENV *dbenv___0 ) ;
int __db_rep_enter(DB *dbp___1 , int checkgen , int return_now ) ;
void __db_rep_exit(DB_ENV *dbenv___0 ) ;
void __op_rep_enter(DB_ENV *dbenv___0 ) ;
void __op_rep_exit(DB_ENV *dbenv___0 ) ;
void __rep_get_gen(DB_ENV *dbenv___0 , u_int32_t *genp ) ;
int __rep_check_alloc(DB_ENV *dbenv___0 , TXN_RECS *r , int n ) 
{ int nalloc ;
  int ret ;

  {
  while (r->nalloc < r->npages + n) {
    if (r->nalloc == 0) {
      nalloc = 20;
    } else {
      nalloc = r->nalloc * 2;
    }
    ret = __os_realloc(dbenv___0, (unsigned int )nalloc * sizeof(LSN_PAGE ), (void *)(& r->array));
    if (ret != 0) {
      return (ret);
    }
    r->nalloc = nalloc;
  }
  return (0);
}
}
int __rep_send_message(DB_ENV *dbenv___0 , int eid , u_int32_t rtype , DB_LSN *lsnp ,
                       DBT const   *dbtp , u_int32_t flags ) 
{ DB_REP *db_rep ;
  REP *rep ;
  DBT cdbt ;
  DBT scrap_dbt ;
  REP_CONTROL cntrl ;
  int ret ;
  u_int32_t myflags ;
  u_int32_t rectype ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  memset((void *)(& cntrl), 0, sizeof(cntrl));
  if ((unsigned int )lsnp == (unsigned int )((void *)0)) {
    while (1) {
      cntrl.lsn.file = 0U;
      cntrl.lsn.offset = 0U;
      break;
    }
  } else {
    cntrl.lsn = (*lsnp);
  }
  cntrl.rectype = rtype;
  cntrl.flags = flags;
  cntrl.rep_version = 1U;
  cntrl.log_version = 8U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  cntrl.gen = rep->gen;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  memset((void *)(& cdbt), 0, sizeof(cdbt));
  cdbt.data = (void *)(& cntrl);
  cdbt.size = sizeof(cntrl);
  if ((unsigned int )dbtp == (unsigned int )((void *)0)) {
    memset((void *)(& scrap_dbt), 0, sizeof(DBT ));
    dbtp = (DBT const   *)(& scrap_dbt);
  }
  myflags = 0U;
  if (flags & 32U) {
    myflags = 2U;
  } else {
    if (rtype != 7U) {
      myflags = 1U;
    } else {
      memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )dbtp->data,
             sizeof(rectype));
      if (rectype == 10U) {
        cntrl.flags = cntrl.flags | 32U;
      } else {
        if (rectype == 11U) {
          cntrl.flags = cntrl.flags | 32U;
        }
      }
    }
  }
  ret = ((*(dbenv___0->rep_send)))(dbenv___0, (DBT const   *)(& cdbt), dbtp, (DB_LSN const   *)(& cntrl.lsn),
                                   eid, myflags);
  if (ret == 0) {
    rep->stat.st_msgs_sent = rep->stat.st_msgs_sent + 1U;
  } else {
    rep->stat.st_msgs_send_failures = rep->stat.st_msgs_send_failures + 1U;
  }
  return (ret);
}
}
int __rep_new_master(DB_ENV *dbenv___0 , REP_CONTROL *cntrl , int eid ) 
{ DB_LOG *dblp ;
  DB_LOGC *logc ;
  DB_LSN last_lsn ;
  DB_LSN lsn ;
  DB_REP *db_rep ;
  DBT dbt ;
  LOG *lp ;
  REP *rep ;
  int change ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  ret = 0;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  __rep_elect_done(dbenv___0, rep);
  if (rep->gen != cntrl->gen) {
    tmp = 1;
  } else {
    if (rep->master_id != eid) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  }
  change = tmp;
  if (change) {
    rep->gen = cntrl->gen;
    if (rep->egen <= rep->gen) {
      rep->egen = rep->gen + 1U;
    }
    rep->master_id = eid;
    rep->stat.st_master_changes = rep->stat.st_master_changes + 1U;
    rep->flags = rep->flags | 160U;
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  lsn = lp->lsn;
  last_lsn = lsn;
  if (last_lsn.offset > sizeof(LOGP )) {
    last_lsn.offset = last_lsn.offset - lp->len;
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (! change) {
    ret = 0;
    if (rep->flags & 128U) {
      if (! ((db_rep->db_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
      }
      lsn = lp->verify_lsn;
      if (! ((db_rep->db_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
      }
      if (! (lsn.file == 0U)) {
        __rep_send_message(dbenv___0, eid, 21U, & last_lsn, (DBT const   *)((void *)0),
                           0U);
      }
    } else {
      tmp___0 = log_compare((DB_LSN const   *)(& lsn), (DB_LSN const   *)(& cntrl->lsn));
      if (tmp___0 < 0) {
        __rep_send_message(dbenv___0, eid, 3U, & lsn, (DBT const   *)((void *)0),
                           0U);
      }
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
      }
      rep->flags = rep->flags & 4294967263U;
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
      }
    }
    return (ret);
  }
  if (lsn.file == 1U) {
    if (lsn.offset == 0U) {
      goto empty;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (lsn.file == 0U) {
      empty: 
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
      }
      rep->flags = rep->flags & 4294967071U;
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
      }
      if (cntrl->lsn.file == 1U) {
        if (! (cntrl->lsn.offset == 0U)) {
          __rep_send_message(dbenv___0, rep->master_id, 3U, & lsn, (DBT const   *)((void *)0),
                             0U);
        }
      } else {
        __rep_send_message(dbenv___0, rep->master_id, 3U, & lsn, (DBT const   *)((void *)0),
                           0U);
      }
      return (-30983);
    } else {
      if (last_lsn.offset <= sizeof(LOGP )) {
        ret = __log_cursor(dbenv___0, & logc);
        if (ret != 0) {
          return (ret);
        }
        memset((void *)(& dbt), 0, sizeof(dbt));
        ret = __log_c_get(logc, & last_lsn, & dbt, 17U);
        t_ret = __log_c_close(logc);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
        if (ret == -30990) {
          goto empty;
        }
        if (ret != 0) {
          if (change) {
            if (! ((db_rep->rep_mutexp)->flags & 2U)) {
              __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
            }
            rep->flags = rep->flags & 4294967167U;
            if (! ((db_rep->rep_mutexp)->flags & 2U)) {
              __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
            }
          }
          return (ret);
        }
      }
    }
  }
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->db_mutexp);
  }
  lp->verify_lsn = last_lsn;
  if (! ((db_rep->db_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->db_mutexp);
  }
  __rep_send_message(dbenv___0, eid, 21U, & last_lsn, (DBT const   *)((void *)0),
                     0U);
  return (-30983);
}
}
int __rep_is_client(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int ret ;

  {
  if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  ret = (int )(rep->flags & 516U);
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (ret);
}
}
int __rep_noarchive(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;

  {
  if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  return ((int )(rep->flags & 32U));
}
}
void __rep_send_vote(DB_ENV *dbenv___0 , DB_LSN *lsnp , int nsites , int pri , int tiebreaker ,
                     u_int32_t egen , int eid , u_int32_t vtype ) 
{ DBT vote_dbt ;
  REP_VOTE_INFO vi ;

  {
  memset((void *)(& vi), 0, sizeof(vi));
  vi.egen = egen;
  vi.priority = pri;
  vi.nsites = nsites;
  vi.tiebreaker = tiebreaker;
  memset((void *)(& vote_dbt), 0, sizeof(vote_dbt));
  vote_dbt.data = (void *)(& vi);
  vote_dbt.size = sizeof(vi);
  __rep_send_message(dbenv___0, eid, vtype, lsnp, (DBT const   *)(& vote_dbt), 0U);
  return;
}
}
void __rep_elect_done(DB_ENV *dbenv___0 , REP *rep ) 
{ int inelect ;

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  inelect = (int )(rep->flags & 259U);
  rep->flags = rep->flags & 4294967036U;
  rep->sites = 0;
  rep->votes = 0;
  if (inelect) {
    rep->egen = rep->egen + 1U;
  }
  return;
}
}
int __rep_grow_sites(DB_ENV *dbenv___0 , int nsites ) 
{ REGENV *renv ;
  REGINFO *infop ;
  REP *rep ;
  int nalloc ;
  int ret ;
  int *tally ;

  {
  rep = ((DB_REP *)dbenv___0->rep_handle)->region;
  nalloc = 2 * rep->asites;
  if (nalloc < nsites) {
    nalloc = nsites;
  }
  infop = (REGINFO *)dbenv___0->reginfo;
  renv = (REGENV *)infop->primary;
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  ret = __db_shalloc(infop->addr, (unsigned int )nalloc * sizeof(REP_VTALLY ), sizeof(REP_VTALLY ),
                     (void *)(& tally));
  if (ret == 0) {
    if (rep->tally_off != 0U) {
      __db_shalloc_free(infop->addr, (void *)((u_int8_t *)infop->addr + rep->tally_off));
    }
    rep->tally_off = (unsigned int )((u_int8_t *)tally - (u_int8_t *)infop->addr);
    ret = __db_shalloc(infop->addr, (unsigned int )nalloc * sizeof(REP_VTALLY ), sizeof(REP_VTALLY ),
                       (void *)(& tally));
    if (ret == 0) {
      if (rep->v2tally_off != 0U) {
        __db_shalloc_free(infop->addr, (void *)((u_int8_t *)infop->addr + rep->v2tally_off));
      }
      rep->v2tally_off = (unsigned int )((u_int8_t *)tally - (u_int8_t *)infop->addr);
      rep->asites = nalloc;
      rep->nsites = nsites;
    } else {
      if (rep->v2tally_off != 0U) {
        __db_shalloc_free(infop->addr, (void *)((u_int8_t *)infop->addr + rep->v2tally_off));
      }
      __db_shalloc_free(infop->addr, (void *)((u_int8_t *)infop->addr + rep->tally_off));
      rep->tally_off = 0U;
      rep->v2tally_off = rep->tally_off;
      rep->asites = 0;
      rep->nsites = 0;
    }
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  return (ret);
}
}
void __env_rep_enter(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int cnt ;

  {
  if (dbenv___0->flags & 1024U) {
    return;
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  cnt = 0;
  while (rep->in_recovery) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    __os_sleep(dbenv___0, 1UL, 0UL);
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    cnt ++;
    if (cnt % 60 == 0) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_ENV handle waiting %d minutes for replication recovery to complete",
               cnt / 60);
    }
  }
  rep->handle_cnt = rep->handle_cnt + 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return;
}
}
void __env_rep_exit(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;

  {
  if (dbenv___0->flags & 1024U) {
    return;
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  rep->handle_cnt = rep->handle_cnt - 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return;
}
}
int __db_rep_enter(DB *dbp___1 , int checkgen , int return_now ) 
{ DB_ENV *dbenv___0 ;
  DB_REP *db_rep ;
  REP *rep ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (dbenv___0->flags & 1024U) {
    return (0);
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (rep->flags & 64U) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    if (! return_now) {
      __os_sleep(dbenv___0, 5UL, 0UL);
    }
    return (-30995);
  }
  if (checkgen) {
    if (dbp___1->timestamp != rep->timestamp) {
      if (! ((db_rep->rep_mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
      }
      __db_err((DB_ENV const   *)dbenv___0, "%s %s", "replication recovery unrolled committed transactions;",
               "open DB and DBcursor handles must be closed");
      return (-30986);
    }
  }
  rep->handle_cnt = rep->handle_cnt + 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return (0);
}
}
void __db_rep_exit(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;

  {
  if (dbenv___0->flags & 1024U) {
    return;
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  rep->handle_cnt = rep->handle_cnt - 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return;
}
}
void __op_rep_enter(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;
  int cnt ;

  {
  if (dbenv___0->flags & 1024U) {
    return;
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  cnt = 0;
  while (rep->flags & 64U) {
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
    }
    __os_sleep(dbenv___0, 5UL, 0UL);
    if (! ((db_rep->rep_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
    }
    cnt ++;
    if (cnt % 60 == 0) {
      __db_err((DB_ENV const   *)dbenv___0, "__op_rep_enter waiting %d minutes for op count to drain",
               cnt / 60);
    }
  }
  rep->op_cnt = rep->op_cnt + 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return;
}
}
void __op_rep_exit(DB_ENV *dbenv___0 ) 
{ DB_REP *db_rep ;
  REP *rep ;

  {
  if (dbenv___0->flags & 1024U) {
    return;
  }
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  rep->op_cnt = rep->op_cnt - 1U;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return;
}
}
void __rep_get_gen(DB_ENV *dbenv___0 , u_int32_t *genp ) 
{ DB_REP *db_rep ;
  REP *rep ;

  {
  db_rep = (DB_REP *)dbenv___0->rep_handle;
  rep = db_rep->region;
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, db_rep->rep_mutexp);
  }
  if (rep->recover_gen > rep->gen) {
    (*genp) = rep->recover_gen;
  } else {
    (*genp) = rep->gen;
  }
  if (! ((db_rep->rep_mutexp)->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, db_rep->rep_mutexp);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-3AKWnUzg.i","-O2")
int __db_vrfy_overflow(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                       u_int32_t flags ) ;
int __db_vrfy_overflow(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                       u_int32_t flags ) 
{ VRFY_PAGEINFO *pip ;
  int isbad ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_vrfy_datapage(dbp___1, vdp, h, pgno, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  pip->refcount = (unsigned int )h->entries;
  if (pip->refcount < 1U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: overflow page has zero reference count",
                 (unsigned long )pgno);
      }
      break;
    }
    isbad = 1;
  }
  pip->olen = (unsigned int )h->hf_offset;
  err: 
  t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
  if (t_ret != 0) {
    ret = t_ret;
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp = -30976;
    } else {
      tmp = ret;
    }
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
int __db_vrfy_ovfl_structure(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t tlen ,
                             u_int32_t flags ) 
{ DB *pgset ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t next ;
  db_pgno_t prev ;
  int isbad ;
  int ret ;
  int seen_cnt ;
  int t_ret ;
  u_int32_t refcount ;
  int tmp ;

  {
  pgset = vdp->pgset;
  isbad = 0;
  if (! (pgno <= vdp->last_pgno)) {
    return (-30976);
  }
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  refcount = pip->refcount;
  if ((int )pip->type != 7) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: overflow page of invalid type %lu",
                 (unsigned long )pgno, (unsigned long )pip->type);
      }
      break;
    }
    ret = -30976;
    goto done;
  }
  prev = pip->prev_pgno;
  if (prev != 0U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: first page in overflow chain has a prev_pgno %lu",
                 (unsigned long )pgno, (unsigned long )prev);
      }
      break;
    }
    isbad = 1;
  }
  while (1) {
    ret = __db_vrfy_pgset_get(pgset, pgno, & seen_cnt);
    if (ret != 0) {
      goto done;
    }
    if ((unsigned int )seen_cnt > refcount) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: encountered too many times in overflow traversal",
                   (unsigned long )pgno);
        }
        break;
      }
      ret = -30976;
      goto done;
    }
    ret = __db_vrfy_pgset_inc(pgset, pgno);
    if (ret != 0) {
      goto done;
    }
    if (flags & 1048576U) {
      if (pip->flags & 1024U) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: overflow page linked twice from leaf or data page",
                     (unsigned long )pgno);
          }
          break;
        }
        ret = -30976;
        goto done;
      }
      pip->flags = pip->flags | 1024U;
    }
    if (seen_cnt == 0) {
      tlen -= pip->olen;
      if (! (flags & 64U)) {
        __db_vrfy_struct_feedback(dbp___1, vdp);
      }
    } else {
      goto done;
    }
    next = pip->next_pgno;
    if (next == 0U) {
      break;
    }
    if (! (next <= vdp->last_pgno)) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: bad next_pgno %lu on overflow page",
                   (unsigned long )pgno, (unsigned long )next);
        }
        break;
      }
      ret = -30976;
      goto done;
    }
    ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
    if (ret != 0) {
      return (ret);
    } else {
      ret = __db_vrfy_getpageinfo(vdp, next, & pip);
      if (ret != 0) {
        return (ret);
      }
    }
    if (pip->prev_pgno != pgno) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: bad prev_pgno %lu on overflow page (should be %lu)",
                   (unsigned long )next, (unsigned long )pip->prev_pgno, (unsigned long )pgno);
        }
        break;
      }
      isbad = 1;
    }
    pgno = next;
  }
  if (tlen > 0U) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Page %lu: overflow item incomplete",
                 (unsigned long )pgno);
      }
      break;
    }
  }
  done: 
  t_ret = __db_vrfy_putpageinfo(dbp___1->dbenv, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp = -30976;
    } else {
      tmp = ret;
    }
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
int __db_safe_goff(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , DBT *dbt , void *buf ,
                   u_int32_t flags ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int ret ;
  int t_ret ;
  u_int32_t bytesgot ;
  u_int32_t bytes ;
  u_int8_t *src ;
  u_int8_t *dest ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;

  {
  mpf = dbp___1->mpf;
  h = (PAGE *)((void *)0);
  t_ret = 0;
  ret = t_ret;
  bytes = 0U;
  bytesgot = bytes;
  while (1) {
    if (pgno != 0U) {
      if (! (pgno <= vdp->last_pgno)) {
        break;
      }
    } else {
      break;
    }
    ret = __db_salvage_markdone(vdp, pgno);
    if (ret != 0) {
      break;
    }
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      break;
    }
    if (! (flags & 1U)) {
      if ((int )h->type != 7) {
        ret = -30976;
        break;
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    src = (u_int8_t *)h + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                  26) +
                                                                                 tmp___0))));
    bytes = (unsigned int )h->hf_offset;
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if (bytes + (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                 26) +
                                                                                tmp___4)))) >
        dbp___1->pgsize) {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      bytes = dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                 26) +
                                                                                                tmp___2))));
    }
    ret = __os_realloc(dbp___1->dbenv, bytesgot + bytes, buf);
    if (ret != 0) {
      break;
    }
    dest = (*((u_int8_t **)buf)) + bytesgot;
    bytesgot += bytes;
    memcpy((void * __restrict  )dest, (void const   * __restrict  )src, bytes);
    pgno = h->next_pgno;
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      break;
    }
    h = (PAGE *)((void *)0);
  }
  if (ret == 0) {
    dbt->size = bytesgot;
    dbt->data = (*((void **)buf));
  } else {
    if (flags & 1U) {
      dbt->size = bytesgot;
      dbt->data = (*((void **)buf));
    }
  }
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-TE4tuV1F.i","-O2")
int __os_closehandle(DB_ENV *dbenv___0 , DB_FH *fhp ) ;
int __os_open(DB_ENV *dbenv___0 , char const   *name , u_int32_t flags , int mode ,
              DB_FH **fhpp ) ;
int __os_read(DB_ENV *dbenv___0 , DB_FH *fhp , void *addr , size_t len , size_t *nrp ) ;
int __db_isbigendian(void) ;
int __bam_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , BTMETA *meta , db_pgno_t pgno ,
                    u_int32_t flags ) ;
int __ram_vrfy_leaf(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) ;
int __bam_vrfy(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) ;
int __bam_vrfy_itemorder(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                         u_int32_t nentries , int ovflok , int hasdups , u_int32_t flags ) ;
int __bam_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t meta_pgno , u_int32_t flags ) ;
int __bam_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t pgtype ,
                  PAGE *h , void *handle , int (*callback)(void * , void const   * ) ,
                  DBT *key , u_int32_t flags ) ;
int __bam_salvage_walkdupint(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , DBT *key ,
                             void *handle , int (*callback)(void * , void const   * ) ,
                             u_int32_t flags ) ;
int __bam_meta2pgset(DB *dbp___1 , VRFY_DBINFO *vdp , BTMETA *btmeta , u_int32_t flags ,
                     DB *pgset ) ;
int __db_master_open(DB *subdbp , DB_TXN *txn , char const   *name , u_int32_t flags ,
                     int mode , DB **dbpp ) ;
int __db_dbenv_setup(DB *dbp___1 , DB_TXN *txn , char const   *fname , u_int32_t id ,
                     u_int32_t flags ) ;
int __db_chk_meta(DB_ENV *dbenv___0 , DB *dbp___1 , DBMETA *meta , int do_metachk ) ;
int __db_prheader(DB *dbp___1 , char *subname , int pflag , int keyflag , void *handle ,
                  int (*callback)(void * , void const   * ) , VRFY_DBINFO *vdp , db_pgno_t meta_pgno ) ;
int __db_prfooter(void *handle , int (*callback)(void * , void const   * ) ) ;
int __db_pr_callback(void *handle , void const   *str_arg ) ;
int __db_verify_pp(DB *dbp___1 , char const   *file , char const   *database , FILE *outfile ,
                   u_int32_t flags ) ;
int __db_verify_internal(DB *dbp___1 , char const   *fname , char const   *dname ,
                         void *handle , int (*callback)(void * , void const   * ) ,
                         u_int32_t flags ) ;
int __db_verify(DB *dbp___1 , char const   *name , char const   *subdb , void *handle ,
                int (*callback)(void * , void const   * ) , u_int32_t flags ) ;
int __db_vrfy_dbinfo_create(DB_ENV *dbenv___0 , u_int32_t pgsize , VRFY_DBINFO **vdpp ) ;
int __db_vrfy_dbinfo_destroy(DB_ENV *dbenv___0 , VRFY_DBINFO *vdp ) ;
int __db_vrfy_pgset(DB_ENV *dbenv___0 , u_int32_t pgsize , DB **dbpp ) ;
int __db_vrfy_pgset_next(DBC *dbc , db_pgno_t *pgnop ) ;
int __db_salvage_init(VRFY_DBINFO *vdp ) ;
void __db_salvage_destroy(VRFY_DBINFO *vdp ) ;
int __db_salvage_getnext(VRFY_DBINFO *vdp , db_pgno_t *pgnop , u_int32_t *pgtypep ) ;
int __db_salvage_markneeded(VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t pgtype ) ;
static u_int __db_guesspgsize(DB_ENV *dbenv___0 , DB_FH *fhp ) ;
static int __db_is_valid_magicno(u_int32_t magic , DBTYPE *typep ) ;
static int __db_is_valid_pagetype(u_int32_t type ) ;
static int __db_meta2pgset(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t flags ,
                           DB *pgset ) ;
static int __db_salvage_subdbpg(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *master , void *handle ,
                                int (*callback)(void * , void const   * ) , u_int32_t flags ) ;
static int __db_salvage_subdbs(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                               void const   * ) ,
                               u_int32_t flags , int *hassubsp ) ;
static int __db_salvage_unknowns(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                                 void const   * ) ,
                                 u_int32_t flags ) ;
static int __db_verify_arg(DB *dbp___1 , char const   *dname , u_int32_t flags ) ;
static int __db_vrfy_freelist(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t meta , u_int32_t flags ) ;
static int __db_vrfy_invalid(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                             u_int32_t flags ) ;
static int __db_vrfy_orderchkonly(DB *dbp___1 , VRFY_DBINFO *vdp , char const   *name ,
                                  char const   *subdb , u_int32_t flags ) ;
static int __db_vrfy_pagezero(DB *dbp___1 , VRFY_DBINFO *vdp , DB_FH *fhp , u_int32_t flags ) ;
static int __db_vrfy_subdbs(DB *dbp___1 , VRFY_DBINFO *vdp , char const   *dbname ,
                            u_int32_t flags ) ;
static int __db_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , char const   *dbname ,
                               db_pgno_t meta_pgno , u_int32_t flags ) ;
static int __db_vrfy_walkpages(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                               void const   * ) ,
                               u_int32_t flags ) ;
int __db_verify_pp(DB *dbp___1 , char const   *file , char const   *database , FILE *outfile ,
                   u_int32_t flags ) 
{ int tmp ;

  {
  tmp = __db_verify_internal(dbp___1, file, database, (void *)outfile, & __db_pr_callback,
                             flags);
  return (tmp);
}
}
int __db_verify_internal(DB *dbp___1 , char const   *fname , char const   *dname ,
                         void *handle , int (*callback)(void * , void const   * ) ,
                         u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (dbp___1->flags & 65536U) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->verify", 1);
    return (tmp___0);
  }
  ret = __db_verify_arg(dbp___1, dname, flags);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB->verify may not be used with transactions, logging, or locking");
    return (22);
  } else {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB->verify may not be used with transactions, logging, or locking");
      return (22);
    } else {
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        __db_err((DB_ENV const   *)dbenv___0, "DB->verify may not be used with transactions, logging, or locking");
        return (22);
      }
    }
  }
  tmp___1 = __db_verify(dbp___1, fname, dname, handle, callback, flags);
  return (tmp___1);
}
}
static int __db_verify_arg(DB *dbp___1 , char const   *dname , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_fchk(dbenv___0, "DB->verify", flags, 103U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 64U) {
    if (((flags & 4294967294U) & 4294967263U) != 64U) {
      tmp = __db_ferr((DB_ENV const   *)dbenv___0, "__db_verify", 1);
      return (tmp);
    }
  }
  if (flags & 1U) {
    goto _L;
  } else {
    if (flags & 32U) {
      _L: 
      if (! (flags & 64U)) {
        tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "__db_verify", 1);
        return (tmp___0);
      }
    }
  }
  if (flags & 4U) {
    if (flags != 4U) {
      tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "__db_verify", 1);
      return (tmp___1);
    }
  }
  if (flags & 4U) {
    if ((unsigned int )dname == (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_ORDERCHKONLY requires a database name");
      return (22);
    }
  }
  return (0);
}
}
int __db_verify(DB *dbp___1 , char const   *name , char const   *subdb , void *handle ,
                int (*callback)(void * , void const   * ) , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  VRFY_DBINFO *vdp ;
  int has ;
  int isbad ;
  int ret ;
  int t_ret ;
  char *real_name ;
  int tmp ;
  char *tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  fhp = (DB_FH *)((void *)0);
  vdp = (VRFY_DBINFO *)((void *)0);
  real_name = (char *)((void *)0);
  isbad = 0;
  ret = isbad;
  has = ret;
  dbp___1->flags = dbp___1->flags | 1073741824U;
  if (! (flags & 64U)) {
    if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
      ((*(dbp___1->db_feedback)))(dbp___1, 2, 0);
    }
  }
  ret = __db_vrfy_dbinfo_create(dbenv___0, 1024U, & vdp);
  if (ret != 0) {
    goto err;
  }
  if (flags & 32U) {
    vdp->flags = vdp->flags | 1U;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, name, 0U, (DB_FH **)((void *)0),
                     & real_name);
  if (ret != 0) {
    goto err;
  }
  ret = __os_open(dbenv___0, (char const   *)real_name, 16U, 292, & fhp);
  if (ret != 0) {
    goto err;
  }
  ret = __db_vrfy_pagezero(dbp___1, vdp, fhp, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  ret = __db_dbenv_setup(dbp___1, (DB_TXN *)((void *)0), name, 0U, 16400U);
  if (ret != 0) {
    return (ret);
  }
  if ((int )dbp___1->type == 4) {
    ret = __qam_set_ext_data(dbp___1, name);
    if (ret != 0) {
      return (ret);
    }
  }
  dbp___1->flags = dbp___1->flags | 65536U;
  __memp_last_pgno(dbp___1->mpf, & vdp->last_pgno);
  if (flags & 4U) {
    ret = __db_vrfy_orderchkonly(dbp___1, vdp, name, subdb, flags);
    goto done;
  }
  if (flags & 64U) {
    ret = __db_salvage_init(vdp);
    if (ret != 0) {
      return (ret);
    }
    if (! (flags & 1U)) {
      tmp = __db_salvage_subdbs(dbp___1, vdp, handle, callback, flags, & has);
      if (tmp != 0) {
        isbad = 1;
      }
    }
    if (has == 1) {
      vdp->flags = vdp->flags | 2U;
    }
  }
  ret = __db_vrfy_walkpages(dbp___1, vdp, handle, callback, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (! (flags & 64U)) {
    if (isbad == 0) {
      ret = __db_vrfy_structure(dbp___1, vdp, name, 0U, flags);
      if (ret != 0) {
        if (ret == -30976) {
          isbad = 1;
        } else {
          if (ret != 0) {
            goto err;
          }
        }
      }
    }
  }
  if (flags & 64U) {
    ret = __db_salvage_unknowns(dbp___1, vdp, handle, callback, flags);
    if (ret != 0) {
      isbad = 1;
    }
    __db_salvage_destroy(vdp);
  }
  if (0) {
    err: 
    if (ret == -30891) {
      ret = -30976;
    }
    tmp___0 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", name, tmp___0);
  }
  if (flags & 64U) {
    if (has == 0) {
      __db_prfooter(handle, callback);
    } else {
      if (vdp->flags & 4U) {
        __db_prfooter(handle, callback);
      }
    }
  }
  done: 
  if (! (flags & 64U)) {
    if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
      ((*(dbp___1->db_feedback)))(dbp___1, 2, 100);
    }
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    t_ret = __os_closehandle(dbenv___0, fhp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
    t_ret = __db_close(dbp___1, (DB_TXN *)((void *)0), 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )vdp != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_dbinfo_destroy(dbenv___0, vdp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  if (ret == 0) {
    if (isbad == 1) {
      ret = -30976;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (ret == -30891) {
      ret = -30976;
    }
  }
  return (ret);
}
}
static int __db_vrfy_pagezero(DB *dbp___1 , VRFY_DBINFO *vdp , DB_FH *fhp , u_int32_t flags ) 
{ DBMETA *meta ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t freelist ;
  size_t nr ;
  int isbad ;
  int ret ;
  int swapped ;
  u_int8_t mbuf[512] ;
  char *tmp ;
  u_int32_t _tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  int tmp___2 ;

  {
  swapped = 0;
  ret = swapped;
  isbad = ret;
  freelist = 0U;
  dbenv___0 = dbp___1->dbenv;
  meta = (DBMETA *)(mbuf);
  dbp___1->type = (enum __anonenum_DBTYPE_61 )5;
  ret = __os_seek(dbenv___0, fhp, 0U, 0U, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "Metadata page %lu cannot be read: %s",
             0UL, tmp);
    return (ret);
  } else {
    ret = __os_read(dbenv___0, fhp, (void *)(mbuf), 512U, & nr);
    if (ret != 0) {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "Metadata page %lu cannot be read: %s",
               0UL, tmp);
      return (ret);
    }
  }
  if (nr != 512U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: Incomplete metadata page",
                 0UL);
      }
      break;
    }
    return (-30891);
  }
  ret = __db_chk_meta(dbenv___0, dbp___1, meta, 1);
  if (ret != 0) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: metadata page corrupted",
                 0UL);
      }
      break;
    }
    isbad = 1;
    if (ret != -1) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: could not check metadata page",
                   0UL);
        }
        break;
      }
      return (-30891);
    }
  }
  if (meta->pgno != 0U) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: pgno incorrectly set to %lu",
                 0UL, (unsigned long )meta->pgno);
      }
      break;
    }
  }
  tmp___1 = __db_is_valid_magicno(meta->magic, & dbp___1->type);
  if (tmp___1) {
    swapped = 0;
  } else {
    _tmp = meta->magic;
    (*((u_int8_t *)(& meta->magic) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
    (*((u_int8_t *)(& meta->magic) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
    (*((u_int8_t *)(& meta->magic) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
    (*((u_int8_t *)(& meta->magic) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
    tmp___0 = __db_is_valid_magicno(meta->magic, & dbp___1->type);
    if (tmp___0) {
      swapped = 1;
    } else {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad magic number %lu",
                   0UL, (unsigned long )meta->magic);
        }
        break;
      }
    }
  }
  if (swapped) {
    _tmp___0 = meta->version;
    (*((u_int8_t *)(& meta->version) + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
    (*((u_int8_t *)(& meta->version) + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
    (*((u_int8_t *)(& meta->version) + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
    (*((u_int8_t *)(& meta->version) + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  }
  if ((int )dbp___1->type == 1) {
    if (meta->version > 9U) {
      goto _L___0;
    } else {
      if (meta->version < 8U) {
        goto _L___0;
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: 
    if ((int )dbp___1->type == 2) {
      if (meta->version > 8U) {
        goto _L___0;
      } else {
        if (meta->version < 7U) {
          goto _L___0;
        } else {
          goto _L___1;
        }
      }
    } else {
      _L___1: 
      if ((int )dbp___1->type == 4) {
        if (meta->version > 4U) {
          goto _L___0;
        } else {
          if (meta->version < 3U) {
            _L___0: 
            isbad = 1;
            while (1) {
              if (! (flags & 64U)) {
                __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unsupported DB version %lu; extraneous errors may result",
                         0UL, (unsigned long )meta->version);
              }
              break;
            }
          }
        }
      }
    }
  }
  if (swapped) {
    _tmp___1 = meta->pagesize;
    (*((u_int8_t *)(& meta->pagesize) + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
    (*((u_int8_t *)(& meta->pagesize) + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
    (*((u_int8_t *)(& meta->pagesize) + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
    (*((u_int8_t *)(& meta->pagesize) + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
  }
  if ((meta->pagesize & (meta->pagesize - 1U)) == 0U) {
    if (meta->pagesize >= 512U) {
      if (meta->pagesize <= 65536U) {
        dbp___1->pgsize = meta->pagesize;
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad page size %lu", 0UL,
                 (unsigned long )meta->pagesize);
      }
      break;
    }
    if ((dbp___1->pgsize & (dbp___1->pgsize - 1U)) == 0U) {
      if (dbp___1->pgsize >= 512U) {
        if (! (dbp___1->pgsize <= 65536U)) {
          dbp___1->pgsize = __db_guesspgsize(dbenv___0, fhp);
        }
      } else {
        dbp___1->pgsize = __db_guesspgsize(dbenv___0, fhp);
      }
    } else {
      dbp___1->pgsize = __db_guesspgsize(dbenv___0, fhp);
    }
  }
  if ((int )dbp___1->type == 1) {
    if ((int )meta->type != 9) {
      goto _L___5;
    } else {
      goto _L___7;
    }
  } else {
    _L___7: 
    if ((int )dbp___1->type == 2) {
      if ((int )meta->type != 8) {
        goto _L___5;
      } else {
        goto _L___6;
      }
    } else {
      _L___6: 
      if ((int )dbp___1->type == 4) {
        if ((int )meta->type != 10) {
          _L___5: 
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad page type %lu",
                       0UL, (unsigned long )meta->type);
            }
            break;
          }
        }
      }
    }
  }
  if (swapped) {
    _tmp___2 = meta->free;
    (*((u_int8_t *)(& meta->free) + 0)) = (*((u_int8_t *)(& _tmp___2) + 3));
    (*((u_int8_t *)(& meta->free) + 1)) = (*((u_int8_t *)(& _tmp___2) + 2));
    (*((u_int8_t *)(& meta->free) + 2)) = (*((u_int8_t *)(& _tmp___2) + 1));
    (*((u_int8_t *)(& meta->free) + 3)) = (*((u_int8_t *)(& _tmp___2) + 0));
  }
  freelist = meta->free;
  ret = __db_vrfy_getpageinfo(vdp, 0U, & pip);
  if (ret != 0) {
    return (ret);
  }
  pip->pgno = 0U;
  pip->type = meta->type;
  pip->flags = pip->flags | 32U;
  pip->free = freelist;
  ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (ret != 0) {
    return (ret);
  }
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(meta->uid),
         20U);
  if (swapped == 1) {
    dbp___1->flags = dbp___1->flags | 268435456U;
  }
  if (isbad) {
    tmp___2 = -30976;
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
static int __db_vrfy_walkpages(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                               void const   * ) ,
                               u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t i ;
  int ret ;
  int t_ret ;
  int isbad ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  t_ret = 0;
  isbad = t_ret;
  ret = isbad;
  ret = __db_fchk(dbenv___0, "__db_vrfy_walkpages", flags, 103U);
  if (ret != 0) {
    return (ret);
  }
  i = 0U;
  while (i <= vdp->last_pgno) {
    if (flags & 64U) {
      tmp = __db_salvage_isdone(vdp, i);
      if (tmp != 0) {
        goto __Cont;
      }
    }
    t_ret = __memp_fget(mpf, & i, 0U, (void *)(& h));
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
      if (flags & 64U) {
        goto __Cont;
      } else {
        return (ret);
      }
    }
    if (flags & 64U) {
      t_ret = __db_salvage(dbp___1, vdp, i, h, handle, callback, flags);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
        isbad = 1;
      }
    } else {
      if (i != 0U) {
        ret = __db_vrfy_common(dbp___1, vdp, h, i, flags);
        if (ret == -30976) {
          isbad = 1;
        } else {
          if (ret != 0) {
            goto err;
          }
        }
      }
      switch ((int )h->type) {
      case 0: 
      ret = __db_vrfy_invalid(dbp___1, vdp, h, i, flags);
      break;
      case 1: 
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: old-style duplicate page",
                   (unsigned long )i);
        }
        break;
      }
      break;
      case 2: 
      ret = __ham_vrfy(dbp___1, vdp, h, i, flags);
      break;
      case 3: ;
      case 4: ;
      case 5: ;
      case 12: 
      ret = __bam_vrfy(dbp___1, vdp, h, i, flags);
      break;
      case 6: 
      ret = __ram_vrfy_leaf(dbp___1, vdp, h, i, flags);
      break;
      case 7: 
      ret = __db_vrfy_overflow(dbp___1, vdp, h, i, flags);
      break;
      case 8: 
      ret = __ham_vrfy_meta(dbp___1, vdp, (HMETA *)h, i, flags);
      break;
      case 9: 
      ret = __bam_vrfy_meta(dbp___1, vdp, (BTMETA *)h, i, flags);
      break;
      case 10: 
      ret = __qam_vrfy_meta(dbp___1, vdp, (QMETA *)h, i, flags);
      break;
      case 11: 
      ret = __qam_vrfy_data(dbp___1, vdp, (QPAGE *)h, i, flags);
      break;
      default: ;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unknown page type %lu",
                   (unsigned long )i, (unsigned long )h->type);
        }
        break;
      }
      isbad = 1;
      break;
      }
      if (ret == -30976) {
        isbad = 1;
      } else {
        if (ret != 0) {
          goto err;
        }
      }
      if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
        ((*(dbp___1->db_feedback)))(dbp___1, 2, (int )(((i + 1U) * 50U) / (vdp->last_pgno +
                                                                           1U)));
      }
    }
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
      if (! (flags & 64U)) {
        return (ret);
      }
    }
    __Cont: 
    i ++;
  }
  if (vdp->flags & 16U) {
    t_ret = __qam_vrfy_walkqueue(dbp___1, vdp, handle, callback, flags);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
      if (t_ret == -30976) {
        isbad = 1;
      } else {
        if (! (flags & 64U)) {
          return (ret);
        }
      }
    }
  }
  if (0) {
    err: 
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        tmp___0 = t_ret;
      } else {
        tmp___0 = ret;
      }
      return (tmp___0);
    }
  }
  if (isbad == 1) {
    if (ret == 0) {
      tmp___1 = -30976;
    } else {
      tmp___1 = ret;
    }
  } else {
    tmp___1 = ret;
  }
  return (tmp___1);
}
}
static int __db_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , char const   *dbname ,
                               db_pgno_t meta_pgno , u_int32_t flags ) 
{ DB *pgset ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t i ;
  int ret ;
  int isbad ;
  int hassubs ;
  int p ;
  int tmp ;

  {
  isbad = 0;
  pip = (VRFY_PAGEINFO *)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  pgset = vdp->pgset;
  ret = __db_fchk(dbenv___0, "DB->verify", flags, 103U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 64U) {
    __db_err((DB_ENV const   *)dbenv___0, "__db_vrfy_structure called with DB_SALVAGE");
    return (22);
  }
  if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
    vdp->pgs_remaining = vdp->last_pgno + 1U;
  }
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: 
  ret = __bam_vrfy_structure(dbp___1, vdp, 0U, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  ret = __db_vrfy_getpageinfo(vdp, 0U, & pip);
  if (ret != 0) {
    goto err;
  }
  if (pip->flags & 8U) {
    hassubs = 1;
  } else {
    hassubs = 0;
  }
  ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (ret != 0) {
    goto err;
  }
  pip = (VRFY_PAGEINFO *)((void *)0);
  if (isbad == 0) {
    if (hassubs) {
      ret = __db_vrfy_subdbs(dbp___1, vdp, dbname, flags);
      if (ret != 0) {
        if (ret == -30976) {
          isbad = 1;
        } else {
          goto err;
        }
      }
    }
  }
  break;
  case 2: 
  ret = __ham_vrfy_structure(dbp___1, vdp, 0U, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  break;
  case 4: 
  ret = __qam_vrfy_structure(dbp___1, vdp, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    }
  }
  goto err;
  case 5: ;
  default: 
  ret = 22;
  goto err;
  }
  ret = __db_vrfy_freelist(dbp___1, vdp, meta_pgno, flags);
  if (ret == -30976) {
    isbad = 1;
  }
  if (ret != 0) {
    goto err;
  } else {
    if (isbad == 1) {
      goto err;
    }
  }
  i = 0U;
  while (i < vdp->last_pgno + 1U) {
    ret = __db_vrfy_getpageinfo(vdp, i, & pip);
    if (ret != 0) {
      goto err;
    }
    ret = __db_vrfy_pgset_get(pgset, i, & p);
    if (ret != 0) {
      goto err;
    }
    if ((int )pip->type == 7) {
      if ((unsigned int )p != pip->refcount) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: overflow refcount %lu, referenced %lu times",
                     (unsigned long )i, (unsigned long )pip->refcount, (unsigned long )p);
          }
          break;
        }
        isbad = 1;
      }
    } else {
      if (p == 0) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unreferenced page", (unsigned long )i);
          }
          break;
        }
        isbad = 1;
      }
    }
    if (pip->flags & 64U) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: totally zeroed page", (unsigned long )i);
        }
        break;
      }
      isbad = 1;
    }
    ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
    if (ret != 0) {
      goto err;
    }
    pip = (VRFY_PAGEINFO *)((void *)0);
    i ++;
  }
  err: 
  if ((unsigned int )pip != (unsigned int )((void *)0)) {
    __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  }
  if (isbad == 1) {
    if (ret == 0) {
      tmp = -30976;
    } else {
      tmp = ret;
    }
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
static int __db_is_valid_pagetype(u_int32_t type ) 
{ 

  {
  switch ((int )type) {
  case 0: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  case 9: ;
  case 10: ;
  case 11: ;
  case 12: ;
  return (1);
  default: ;
  break;
  }
  return (0);
}
}
static int __db_is_valid_magicno(u_int32_t magic , DBTYPE *typep ) 
{ 

  {
  switch ((int )magic) {
  case 340322: 
  (*typep) = (enum __anonenum_DBTYPE_61 )1;
  return (1);
  case 398689: 
  (*typep) = (enum __anonenum_DBTYPE_61 )2;
  return (1);
  case 270931: 
  (*typep) = (enum __anonenum_DBTYPE_61 )4;
  return (1);
  default: ;
  break;
  }
  (*typep) = (enum __anonenum_DBTYPE_61 )5;
  return (0);
}
}
int __db_vrfy_common(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  int ret ;
  int t_ret ;
  u_int8_t *p ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  pip->pgno = pgno;
  pip->flags = pip->flags & 4294967231U;
  if (pgno != 0U) {
    if (h->pgno == 0U) {
      p = (u_int8_t *)h;
      while ((unsigned int )p < (unsigned int )((u_int8_t *)h + dbp___1->pgsize)) {
        if ((int )(*p) != 0) {
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: partially zeroed page",
                       (unsigned long )pgno);
            }
            break;
          }
          ret = -30976;
          goto err;
        }
        p ++;
      }
      pip->type = (unsigned char)2;
      pip->flags = pip->flags | 64U;
      ret = 0;
      goto err;
    }
  }
  if (h->pgno != pgno) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad page number %lu", (unsigned long )pgno,
                 (unsigned long )h->pgno);
      }
      break;
    }
    ret = -30976;
  }
  tmp = __db_is_valid_pagetype((unsigned int )h->type);
  if (! tmp) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad page type %lu", (unsigned long )pgno,
                 (unsigned long )h->type);
      }
      break;
    }
    ret = -30976;
  }
  pip->type = h->type;
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __db_vrfy_invalid(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                             u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  int ret ;
  int t_ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  pip->prev_pgno = 0U;
  pip->next_pgno = pip->prev_pgno;
  if (! (h->next_pgno <= vdp->last_pgno)) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: invalid next_pgno %lu", (unsigned long )pgno,
                 (unsigned long )h->next_pgno);
      }
      break;
    }
    ret = -30976;
  } else {
    pip->next_pgno = h->next_pgno;
  }
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_vrfy_datapage(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                       u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  int isbad ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  isbad = 0;
  if ((int )h->type != 3) {
    if ((int )h->type != 4) {
      if (! (h->prev_pgno <= vdp->last_pgno)) {
        goto _L;
      } else {
        if (h->prev_pgno == pip->pgno) {
          _L: 
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: invalid prev_pgno %lu",
                       (unsigned long )pip->pgno, (unsigned long )h->prev_pgno);
            }
            break;
          }
        }
      }
      if (! (h->next_pgno <= vdp->last_pgno)) {
        goto _L___0;
      } else {
        if (h->next_pgno == pip->pgno) {
          _L___0: 
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: invalid next_pgno %lu",
                       (unsigned long )pip->pgno, (unsigned long )h->next_pgno);
            }
            break;
          }
        }
      }
      pip->prev_pgno = h->prev_pgno;
      pip->next_pgno = h->next_pgno;
    }
  }
  if ((int )h->type != 7) {
    if ((((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                 sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                1ULL)) + (unsigned long long )sizeof(db_indx_t )) *
        (unsigned long long )h->entries > (unsigned long long )dbp___1->pgsize) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: too many entries: %lu",
                   (unsigned long )pgno, (unsigned long )h->entries);
        }
        break;
      }
    }
    pip->entries = h->entries;
  }
  switch ((int )h->type) {
  case 3: ;
  case 4: ;
  if ((int )h->level < 2) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad btree level %lu", (unsigned long )pgno,
                 (unsigned long )h->level);
      }
      break;
    }
  }
  pip->bt_level = h->level;
  break;
  case 5: ;
  case 12: ;
  case 6: ;
  if ((int )h->level != 1) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: btree leaf page has incorrect level %lu",
                 (unsigned long )pgno, (unsigned long )h->level);
      }
      break;
    }
  }
  break;
  default: ;
  if ((int )h->level != 0) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: nonzero level %lu in non-btree database",
                 (unsigned long )pgno, (unsigned long )h->level);
      }
      break;
    }
  }
  break;
  }
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp = -30976;
    } else {
      tmp = ret;
    }
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
int __db_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , DBMETA *meta , db_pgno_t pgno ,
                   u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBTYPE dbtype ;
  DBTYPE magtype ;
  VRFY_PAGEINFO *pip ;
  int isbad ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  isbad = 0;
  dbenv___0 = dbp___1->dbenv;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )meta->type) {
  case 9: 
  dbtype = (enum __anonenum_DBTYPE_61 )1;
  break;
  case 8: 
  dbtype = (enum __anonenum_DBTYPE_61 )2;
  break;
  case 10: 
  dbtype = (enum __anonenum_DBTYPE_61 )4;
  break;
  default: 
  ret = 22;
  goto err;
  }
  tmp = __db_is_valid_magicno(meta->magic, & magtype);
  if (! tmp) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: invalid magic number", (unsigned long )pgno);
      }
      break;
    }
  }
  if ((int )magtype != (int )dbtype) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: magic number does not match database type",
                 (unsigned long )pgno);
      }
      break;
    }
  }
  if ((int )dbtype == 1) {
    if (meta->version > 9U) {
      goto _L___0;
    } else {
      if (meta->version < 8U) {
        goto _L___0;
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: 
    if ((int )dbtype == 2) {
      if (meta->version > 8U) {
        goto _L___0;
      } else {
        if (meta->version < 7U) {
          goto _L___0;
        } else {
          goto _L___1;
        }
      }
    } else {
      _L___1: 
      if ((int )dbtype == 4) {
        if (meta->version > 4U) {
          goto _L___0;
        } else {
          if (meta->version < 3U) {
            _L___0: 
            isbad = 1;
            while (1) {
              if (! (flags & 64U)) {
                __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unsupported database version %lu; extraneous errors may result",
                         (unsigned long )pgno, (unsigned long )meta->version);
              }
              break;
            }
          }
        }
      }
    }
  }
  if (meta->pagesize != dbp___1->pgsize) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: invalid pagesize %lu", (unsigned long )pgno,
                 (unsigned long )meta->pagesize);
      }
      break;
    }
  }
  if (pgno != 0U) {
    if (meta->free != 0U) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: nonempty free list on subdatabase metadata page",
                   (unsigned long )pgno);
        }
        break;
      }
    }
  }
  if (meta->free != 0U) {
    if (meta->free <= vdp->last_pgno) {
      pip->free = meta->free;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    if (! (meta->free <= vdp->last_pgno)) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: nonsensical free list pgno %lu",
                   (unsigned long )pgno, (unsigned long )meta->free);
        }
        break;
      }
    }
  }
  pip->flags = pip->flags & 4294967263U;
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___0 = -30976;
    } else {
      tmp___0 = ret;
    }
  } else {
    tmp___0 = ret;
  }
  return (tmp___0);
}
}
static int __db_vrfy_freelist(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t meta , u_int32_t flags ) 
{ DB *pgset ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t cur_pgno ;
  db_pgno_t next_pgno ;
  int p ;
  int ret ;
  int t_ret ;

  {
  pgset = vdp->pgset;
  dbenv___0 = dbp___1->dbenv;
  ret = __db_vrfy_getpageinfo(vdp, meta, & pip);
  if (ret != 0) {
    return (ret);
  }
  next_pgno = pip->free;
  while (next_pgno != 0U) {
    cur_pgno = pip->pgno;
    ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
    if (ret != 0) {
      return (ret);
    }
    if (! (next_pgno <= vdp->last_pgno)) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: invalid next_pgno %lu on free list page",
                   (unsigned long )cur_pgno, (unsigned long )next_pgno);
        }
        break;
      }
      return (-30976);
    }
    ret = __db_vrfy_pgset_get(pgset, next_pgno, & p);
    if (ret != 0) {
      return (ret);
    }
    if (p != 0) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: page %lu encountered a second time on free list",
                   (unsigned long )cur_pgno, (unsigned long )next_pgno);
        }
        break;
      }
      return (-30976);
    }
    ret = __db_vrfy_pgset_inc(pgset, next_pgno);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_vrfy_getpageinfo(vdp, next_pgno, & pip);
    if (ret != 0) {
      return (ret);
    }
    if ((int )pip->type != 0) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: non-invalid page %lu on free list",
                   (unsigned long )cur_pgno, (unsigned long )next_pgno);
        }
        break;
      }
      ret = -30976;
      break;
    }
    next_pgno = pip->next_pgno;
  }
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    ret = t_ret;
  }
  return (ret);
}
}
static int __db_vrfy_subdbs(DB *dbp___1 , VRFY_DBINFO *vdp , char const   *dbname ,
                            u_int32_t flags ) 
{ DB *mdbp ;
  DBC *dbc ;
  DBT key ;
  DBT data ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  db_pgno_t meta_pgno ;
  int ret ;
  int t_ret ;
  int isbad ;
  u_int8_t type ;
  u_int32_t _tmp ;
  int tmp ;
  int tmp___0 ;

  {
  isbad = 0;
  dbc = (DBC *)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  ret = __db_master_open(dbp___1, (DB_TXN *)((void *)0), dbname, 16U, 0, & mdbp);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_cursor_int(mdbp, (DB_TXN *)((void *)0), (enum __anonenum_DBTYPE_61 )1,
                        0U, 0, 0U, & dbc);
  if (ret != 0) {
    goto err;
  }
  memset((void *)(& key), 0, sizeof(key));
  memset((void *)(& data), 0, sizeof(data));
  while (1) {
    ret = __db_c_get(dbc, & key, & data, 18U);
    if (! (ret == 0)) {
      break;
    }
    if (data.size != sizeof(db_pgno_t )) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Subdatabase entry not page-number size");
        }
        break;
      }
      isbad = 1;
      goto err;
    }
    memcpy((void * __restrict  )(& meta_pgno), (void const   * __restrict  )data.data,
           data.size);
    while (1) {
      tmp = __db_isbigendian();
      if (! tmp) {
        (*((u_int8_t *)(& _tmp) + 0)) = (*((u_int8_t *)(& meta_pgno) + 0));
        (*((u_int8_t *)(& _tmp) + 1)) = (*((u_int8_t *)(& meta_pgno) + 1));
        (*((u_int8_t *)(& _tmp) + 2)) = (*((u_int8_t *)(& meta_pgno) + 2));
        (*((u_int8_t *)(& _tmp) + 3)) = (*((u_int8_t *)(& meta_pgno) + 3));
        (*((u_int8_t *)(& meta_pgno) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
        (*((u_int8_t *)(& meta_pgno) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
        (*((u_int8_t *)(& meta_pgno) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
        (*((u_int8_t *)(& meta_pgno) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
      }
      break;
    }
    if (meta_pgno == 0U) {
      goto _L;
    } else {
      if (meta_pgno > vdp->last_pgno) {
        _L: 
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Subdatabase entry references invalid page %lu",
                     (unsigned long )meta_pgno);
          }
          break;
        }
        isbad = 1;
        goto err;
      }
    }
    ret = __db_vrfy_getpageinfo(vdp, meta_pgno, & pip);
    if (ret != 0) {
      goto err;
    }
    type = pip->type;
    ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
    if (ret != 0) {
      goto err;
    }
    switch ((int )type) {
    case 9: 
    ret = __bam_vrfy_structure(dbp___1, vdp, meta_pgno, flags);
    if (ret != 0) {
      if (ret == -30976) {
        isbad = 1;
      } else {
        goto err;
      }
    }
    break;
    case 8: 
    ret = __ham_vrfy_structure(dbp___1, vdp, meta_pgno, flags);
    if (ret != 0) {
      if (ret == -30976) {
        isbad = 1;
      } else {
        goto err;
      }
    }
    break;
    case 10: ;
    default: ;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Subdatabase entry references page %lu of invalid type %lu",
                 (unsigned long )meta_pgno, (unsigned long )type);
      }
      break;
    }
    ret = -30976;
    goto err;
    }
  }
  if (ret == -30990) {
    ret = 0;
  }
  err: 
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  t_ret = __db_close(mdbp, (DB_TXN *)((void *)0), 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___0 = -30976;
    } else {
      tmp___0 = ret;
    }
  } else {
    tmp___0 = ret;
  }
  return (tmp___0);
}
}
void __db_vrfy_struct_feedback(DB *dbp___1 , VRFY_DBINFO *vdp ) 
{ int progress ;
  int tmp ;

  {
  if ((unsigned int )dbp___1->db_feedback == (unsigned int )((void *)0)) {
    return;
  }
  if (vdp->pgs_remaining > 0U) {
    vdp->pgs_remaining = vdp->pgs_remaining - 1U;
  }
  progress = 100 - (int )((vdp->pgs_remaining * 50U) / (vdp->last_pgno + 1U));
  if (progress == 100) {
    tmp = 99;
  } else {
    tmp = progress;
  }
  ((*(dbp___1->db_feedback)))(dbp___1, 2, tmp);
  return;
}
}
static int __db_vrfy_orderchkonly(DB *dbp___1 , VRFY_DBINFO *vdp , char const   *name ,
                                  char const   *subdb , u_int32_t flags ) 
{ BTMETA *btmeta ;
  DB *mdbp ;
  DB *pgset ;
  DBC *pgsc ;
  DBT key ;
  DBT data ;
  DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  HASH *h_internal ;
  HMETA *hmeta ;
  PAGE *h ;
  PAGE *currpg ;
  db_pgno_t meta_pgno ;
  db_pgno_t p ;
  db_pgno_t pgno ;
  u_int32_t bucket ;
  int t_ret ;
  int ret ;
  size_t tmp ;
  u_int32_t _tmp ;
  int tmp___0 ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___2 ;

  {
  pgset = (DB *)((void *)0);
  pgsc = (DBC *)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  h = (PAGE *)((void *)0);
  currpg = h;
  flags &= 4294967293U;
  ret = __db_master_open(dbp___1, (DB_TXN *)((void *)0), name, 16U, 0, & mdbp);
  if (ret != 0) {
    goto err;
  }
  memset((void *)(& key), 0, sizeof(key));
  key.data = (void *)subdb;
  tmp = strlen(subdb);
  key.size = tmp;
  memset((void *)(& data), 0, sizeof(data));
  ret = __db_get(mdbp, (DB_TXN *)((void *)0), & key, & data, 0U);
  if (ret != 0) {
    goto err;
  }
  if (data.size != sizeof(db_pgno_t )) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Subdatabase entry of invalid size");
      }
      break;
    }
    ret = -30976;
    goto err;
  }
  memcpy((void * __restrict  )(& meta_pgno), (void const   * __restrict  )data.data,
         data.size);
  while (1) {
    tmp___0 = __db_isbigendian();
    if (! tmp___0) {
      (*((u_int8_t *)(& _tmp) + 0)) = (*((u_int8_t *)(& meta_pgno) + 0));
      (*((u_int8_t *)(& _tmp) + 1)) = (*((u_int8_t *)(& meta_pgno) + 1));
      (*((u_int8_t *)(& _tmp) + 2)) = (*((u_int8_t *)(& meta_pgno) + 2));
      (*((u_int8_t *)(& _tmp) + 3)) = (*((u_int8_t *)(& meta_pgno) + 3));
      (*((u_int8_t *)(& meta_pgno) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
      (*((u_int8_t *)(& meta_pgno) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
      (*((u_int8_t *)(& meta_pgno) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
      (*((u_int8_t *)(& meta_pgno) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
    }
    break;
  }
  ret = __memp_fget(mpf, & meta_pgno, 0U, (void *)(& h));
  if (ret != 0) {
    goto err;
  }
  ret = __db_vrfy_pgset(dbenv___0, dbp___1->pgsize, & pgset);
  if (ret != 0) {
    goto err;
  }
  switch ((int )h->type) {
  case 9: 
  btmeta = (BTMETA *)h;
  if (btmeta->dbmeta.flags & 2U) {
    ret = 0;
    goto err;
  }
  ret = __db_meta2pgset(dbp___1, vdp, meta_pgno, flags, pgset);
  if (ret != 0) {
    goto err;
  }
  ret = __db_cursor_int(pgset, (DB_TXN *)((void *)0), dbp___1->type, 0U, 0, 0U, & pgsc);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    ret = __db_vrfy_pgset_next(pgsc, & p);
    if (! (ret == 0)) {
      break;
    }
    ret = __memp_fget(mpf, & p, 0U, (void *)(& currpg));
    if (ret != 0) {
      goto err;
    }
    ret = __bam_vrfy_itemorder(dbp___1, (VRFY_DBINFO *)((void *)0), currpg, p, (unsigned int )currpg->entries,
                               1, (int )(btmeta->dbmeta.flags & 1U), flags);
    if (ret != 0) {
      goto err;
    }
    ret = __memp_fput(mpf, (void *)currpg, 0U);
    if (ret != 0) {
      goto err;
    }
    currpg = (PAGE *)((void *)0);
  }
  if (ret == -30990) {
    ret = 0;
  }
  break;
  case 8: 
  hmeta = (HMETA *)h;
  h_internal = (HASH *)dbp___1->h_internal;
  if ((unsigned int )h_internal == (unsigned int )((void *)0)) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: DB->h_internal field is NULL",
                 (unsigned long )meta_pgno);
      }
      break;
    }
    ret = -30976;
    goto err;
  }
  if ((unsigned int )h_internal->h_hash == (unsigned int )((void *)0)) {
    if (hmeta->dbmeta.version < 5U) {
      h_internal->h_hash = & __ham_func4;
    } else {
      h_internal->h_hash = & __ham_func5;
    }
  }
  tmp___1 = ((*(h_internal->h_hash)))(dbp___1, (void const   *)"%$sniglet^&", sizeof("%$sniglet^&"));
  if (hmeta->h_charkey != tmp___1) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: incorrect hash function for database",
                 (unsigned long )meta_pgno);
      }
      break;
    }
    ret = -30976;
    goto err;
  }
  bucket = 0U;
  while (bucket <= hmeta->max_bucket) {
    tmp___2 = __db_log2(bucket + 1U);
    pgno = bucket + hmeta->spares[tmp___2];
    while (pgno != 0U) {
      ret = __memp_fget(mpf, & pgno, 0U, (void *)(& currpg));
      if (ret != 0) {
        goto err;
      }
      ret = __ham_vrfy_hashing(dbp___1, (unsigned int )currpg->entries, hmeta, bucket,
                               pgno, flags, h_internal->h_hash);
      if (ret != 0) {
        goto err;
      }
      pgno = currpg->next_pgno;
      ret = __memp_fput(mpf, (void *)currpg, 0U);
      if (ret != 0) {
        goto err;
      }
      currpg = (PAGE *)((void *)0);
    }
    bucket ++;
  }
  break;
  default: ;
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Page %lu: database metapage of bad type %lu",
               (unsigned long )meta_pgno, (unsigned long )h->type);
    }
    break;
  }
  ret = -30976;
  break;
  }
  err: 
  if ((unsigned int )pgsc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(pgsc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )pgset != (unsigned int )((void *)0)) {
    t_ret = __db_close(pgset, (DB_TXN *)((void *)0), 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )currpg != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)currpg, 0U);
    if (t_ret != 0) {
      ret = t_ret;
    }
  }
  t_ret = __db_close(mdbp, (DB_TXN *)((void *)0), 0U);
  if (t_ret != 0) {
    ret = t_ret;
  }
  return (ret);
}
}
int __db_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , PAGE *h , void *handle ,
                 int (*callback)(void * , void const   * ) , u_int32_t flags ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;

  {
  tmp = __db_salvage_isdone(vdp, pgno);
  if (tmp) {
    return (0);
  }
  switch ((int )h->type) {
  case 8: 
  ret = __ham_vrfy_meta(dbp___1, vdp, (HMETA *)h, pgno, flags);
  break;
  case 9: 
  ret = __bam_vrfy_meta(dbp___1, vdp, (BTMETA *)h, pgno, flags);
  break;
  case 10: 
  ret = __qam_vrfy_meta(dbp___1, vdp, (QMETA *)h, pgno, flags);
  break;
  case 2: 
  tmp___0 = __ham_salvage(dbp___1, vdp, pgno, h, handle, callback, flags);
  return (tmp___0);
  case 5: 
  tmp___1 = __bam_salvage(dbp___1, vdp, pgno, 5U, h, handle, callback, (DBT *)((void *)0),
                          flags);
  return (tmp___1);
  case 12: 
  tmp___2 = __db_salvage_markneeded(vdp, pgno, 2U);
  return (tmp___2);
  case 7: 
  tmp___3 = __db_salvage_markneeded(vdp, pgno, 4U);
  return (tmp___3);
  case 6: 
  tmp___4 = __db_salvage_markneeded(vdp, pgno, 7U);
  return (tmp___4);
  case 11: 
  tmp___5 = __qam_salvage(dbp___1, vdp, pgno, h, handle, callback, flags);
  return (tmp___5);
  case 3: ;
  case 0: ;
  case 4: ;
  case 1: ;
  default: ;
  return (0);
  }
  if (ret != 0) {
    tmp___7 = ret;
  } else {
    tmp___7 = __db_prheader(dbp___1, (char *)((void *)0), 0, 1, handle, callback,
                            vdp, 0U);
  }
  return (tmp___7);
}
}
static int __db_salvage_unknowns(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                                 void const   * ) ,
                                 u_int32_t flags ) 
{ DBT unkdbt ;
  DBT key ;
  DBT *dbt ;
  DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t pgno ;
  u_int32_t pgtype ;
  int ret ;
  int err_ret ;
  void *ovflbuf ;
  size_t tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  memset((void *)(& unkdbt), 0, sizeof(DBT ));
  tmp = strlen("UNKNOWN");
  unkdbt.size = tmp + 1U;
  unkdbt.data = (void *)"UNKNOWN";
  ret = __os_malloc(dbenv___0, dbp___1->pgsize, (void *)(& ovflbuf));
  if (ret != 0) {
    return (ret);
  }
  err_ret = 0;
  while (1) {
    ret = __db_salvage_getnext(vdp, & pgno, & pgtype);
    if (! (ret == 0)) {
      break;
    }
    dbt = (DBT *)((void *)0);
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      err_ret = ret;
      continue;
    }
    switch ((int )pgtype) {
    case 2: ;
    case 3: 
    dbt = & unkdbt;
    case 5: ;
    case 7: 
    ret = __bam_salvage(dbp___1, vdp, pgno, pgtype, h, handle, callback, dbt, flags);
    if (ret != 0) {
      err_ret = ret;
    }
    break;
    case 4: 
    ret = __db_safe_goff(dbp___1, vdp, pgno, & key, (void *)(& ovflbuf), flags);
    if (ret != 0) {
      err_ret = ret;
    } else {
      ret = __db_prdbt(& key, 0, " ", handle, callback, 0, vdp);
      if (ret != 0) {
        err_ret = ret;
      } else {
        ret = __db_prdbt(& unkdbt, 0, " ", handle, callback, 0, vdp);
        if (ret != 0) {
          err_ret = ret;
        }
      }
    }
    break;
    case 6: 
    ret = __ham_salvage(dbp___1, vdp, pgno, h, handle, callback, flags);
    if (ret != 0) {
      err_ret = ret;
    }
    break;
    case 0: ;
    case 1: ;
    default: ;
    break;
    }
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      err_ret = ret;
    }
  }
  __os_free(dbenv___0, ovflbuf);
  if (err_ret != 0) {
    if (ret == 0) {
      ret = err_ret;
    }
  }
  if (ret == -30990) {
    tmp___0 = 0;
  } else {
    tmp___0 = ret;
  }
  return (tmp___0);
}
}
int __db_vrfy_inpitem(DB *dbp___1 , PAGE *h , db_pgno_t pgno , u_int32_t i , int is_btree ,
                      u_int32_t flags , u_int32_t *himarkp , u_int32_t *offsetp ) 
{ BKEYDATA *bk ;
  DB_ENV *dbenv___0 ;
  db_indx_t *inp ;
  db_indx_t offset ;
  db_indx_t len ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  if ((unsigned int )(inp + i) >= (unsigned int )((db_indx_t *)((u_int8_t *)h + (*himarkp)))) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: entries listing %lu overlaps data",
                 (unsigned long )pgno, (unsigned long )i);
      }
      break;
    }
    return (-30891);
  }
  offset = (*(inp + i));
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  if ((int )offset <= (int )((unsigned short )((u_int8_t *)((db_indx_t *)(((u_int8_t *)h +
                                                                           26) + tmp___2) +
                                                            i) - (u_int8_t *)h))) {
    goto _L;
  } else {
    if ((unsigned int )offset > dbp___1->pgsize) {
      _L: 
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad offset %lu at page index %lu",
                   (unsigned long )pgno, (unsigned long )offset, (unsigned long )i);
        }
        break;
      }
      return (-30976);
    }
  }
  if ((unsigned int )offset < (*himarkp)) {
    (*himarkp) = (unsigned int )offset;
  }
  if (is_btree) {
    if ((unsigned long long )offset != ((unsigned long long )(((unsigned int )offset +
                                                               sizeof(u_int32_t )) -
                                                              1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                       1ULL))) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unaligned offset %lu at page index %lu",
                   (unsigned long )pgno, (unsigned long )offset, (unsigned long )i);
        }
        break;
      }
      return (-30976);
    }
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___4) + i)));
    switch ((int )bk->type & -129) {
    case 1: 
    len = bk->len;
    break;
    case 2: ;
    case 3: 
    len = (unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) + sizeof(u_int32_t )) -
                                                  1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                           1ULL));
    break;
    default: ;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: item %lu of unrecognizable type",
                 (unsigned long )pgno, (unsigned long )i);
      }
      break;
    }
    return (-30976);
    }
    if ((unsigned int )((int )offset + (int )len) > dbp___1->pgsize) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: item %lu extends past page boundary",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      return (-30976);
    }
  }
  if ((unsigned int )offsetp != (unsigned int )((void *)0)) {
    (*offsetp) = (unsigned int )offset;
  }
  return (0);
}
}
int __db_vrfy_duptype(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  int ret ;
  int isbad ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )pip->type) {
  case 3: ;
  case 12: ;
  if (! (flags & 262144U)) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: sorted duplicate set in unsorted-dup database",
                 (unsigned long )pgno);
      }
      break;
    }
    isbad = 1;
  }
  break;
  case 4: ;
  case 6: ;
  if (flags & 262144U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unsorted duplicate set in sorted-dup database",
                 (unsigned long )pgno);
      }
      break;
    }
    isbad = 1;
  }
  break;
  default: ;
  if (pip->flags & 64U) {
    while (1) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s is of inappropriate type %lu",
                   (unsigned long )pgno, "duplicate page", 0UL);
        }
        break;
      }
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: totally zeroed page", (unsigned long )pgno);
        }
        break;
      }
      break;
    }
  } else {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicate page of inappropriate type %lu",
                 (unsigned long )pgno, (unsigned long )pip->type);
      }
      break;
    }
  }
  isbad = 1;
  break;
  }
  ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (ret != 0) {
    return (ret);
  }
  if (isbad == 1) {
    tmp = -30976;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int __db_salvage_duptree(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , DBT *key ,
                         void *handle , int (*callback)(void * , void const   * ) ,
                         u_int32_t flags ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int ret ;
  int t_ret ;

  {
  mpf = dbp___1->mpf;
  if (pgno == 0U) {
    return (-30976);
  } else {
    if (! (pgno <= vdp->last_pgno)) {
      return (-30976);
    }
  }
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  switch ((int )h->type) {
  case 3: ;
  case 4: 
  ret = __db_vrfy_common(dbp___1, vdp, h, pgno, flags);
  if (ret != 0) {
    goto err;
  }
  ret = __bam_vrfy(dbp___1, vdp, h, pgno, flags | 2U);
  if (ret != 0) {
    goto err;
  } else {
    ret = __db_salvage_markdone(vdp, pgno);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __bam_salvage_walkdupint(dbp___1, vdp, h, key, handle, callback, flags);
  if (ret != 0) {
    goto err;
  }
  break;
  case 6: ;
  case 12: 
  ret = __bam_salvage(dbp___1, vdp, pgno, (unsigned int )h->type, h, handle, callback,
                      key, flags);
  if (ret != 0) {
    goto err;
  }
  break;
  default: 
  ret = -30976;
  goto err;
  }
  err: 
  t_ret = __memp_fput(mpf, (void *)h, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __db_salvage_subdbs(DB *dbp___1 , VRFY_DBINFO *vdp , void *handle , int (*callback)(void * ,
                                                                                               void const   * ) ,
                               u_int32_t flags , int *hassubsp ) 
{ BTMETA *btmeta ;
  DB *pgset ;
  DBC *pgsc ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t p ;
  db_pgno_t meta_pgno ;
  int ret ;
  int err_ret ;
  int tmp ;

  {
  pgset = (DB *)((void *)0);
  pgsc = (DBC *)((void *)0);
  mpf = dbp___1->mpf;
  err_ret = 0;
  meta_pgno = 0U;
  ret = __memp_fget(mpf, & meta_pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  if ((int )h->type == 9) {
    btmeta = (BTMETA *)h;
  } else {
    ret = 0;
    goto err;
  }
  ret = __db_vrfy_common(dbp___1, vdp, h, 0U, flags);
  if (ret != 0) {
    goto err;
  } else {
    ret = __bam_vrfy_meta(dbp___1, vdp, btmeta, 0U, flags);
    if (ret != 0) {
      goto err;
    }
  }
  if (! (btmeta->dbmeta.flags & 32U)) {
    ret = 0;
    goto err;
  }
  (*hassubsp) = 1;
  ret = __memp_fput(mpf, (void *)h, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_vrfy_pgset(dbp___1->dbenv, dbp___1->pgsize, & pgset);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_meta2pgset(dbp___1, vdp, 0U, flags, pgset);
  if (ret != 0) {
    goto err;
  }
  ret = __db_cursor(pgset, (DB_TXN *)((void *)0), & pgsc, 0U);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    ret = __db_vrfy_pgset_next(pgsc, & p);
    if (! (ret == 0)) {
      break;
    }
    ret = __memp_fget(mpf, & p, 0U, (void *)(& h));
    if (ret != 0) {
      err_ret = ret;
      continue;
    }
    ret = __db_vrfy_common(dbp___1, vdp, h, p, flags);
    if (ret != 0) {
      goto nextpg;
    } else {
      ret = __bam_vrfy(dbp___1, vdp, h, p, flags | 2U);
      if (ret != 0) {
        goto nextpg;
      }
    }
    if (! ((int )h->type != 5)) {
      ret = __db_salvage_subdbpg(dbp___1, vdp, h, handle, callback, flags);
      if (ret != 0) {
        err_ret = ret;
      }
    }
    nextpg: 
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      err_ret = ret;
    }
  }
  if (ret != -30990) {
    goto err;
  }
  ret = __db_c_close(pgsc);
  if (ret != 0) {
    goto err;
  }
  ret = __db_close(pgset, (DB_TXN *)((void *)0), 0U);
  if (ret == 0) {
    if (err_ret != 0) {
      tmp = err_ret;
    } else {
      tmp = ret;
    }
  } else {
    tmp = ret;
  }
  return (tmp);
  err: 
  if ((unsigned int )pgsc != (unsigned int )((void *)0)) {
    __db_c_close(pgsc);
  }
  if ((unsigned int )pgset != (unsigned int )((void *)0)) {
    __db_close(pgset, (DB_TXN *)((void *)0), 0U);
  }
  __memp_fput(mpf, (void *)h, 0U);
  return (ret);
}
}
static int __db_salvage_subdbpg(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *master , void *handle ,
                                int (*callback)(void * , void const   * ) , u_int32_t flags ) 
{ BKEYDATA *bkkey ;
  BKEYDATA *bkdata ;
  BOVERFLOW *bo ;
  DB *pgset ;
  DBC *pgsc ;
  DBT key ;
  DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  PAGE *subpg ;
  db_indx_t i ;
  db_pgno_t meta_pgno ;
  db_pgno_t p ;
  int ret ;
  int err_ret ;
  int t_ret ;
  char *subdbname ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  u_int32_t _tmp ;
  int tmp___3 ;
  int tmp___4 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  err_ret = 0;
  ret = err_ret;
  subdbname = (char *)((void *)0);
  ret = __db_vrfy_pgset(dbenv___0, dbp___1->pgsize, & pgset);
  if (ret != 0) {
    return (ret);
  }
  i = (unsigned short)0;
  while ((int )i < (int )master->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bkkey = (BKEYDATA *)((u_int8_t *)master + (int )(*((db_indx_t *)(((u_int8_t *)master +
                                                                      26) + tmp___0) +
                                                       (int )i)));
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    bkdata = (BKEYDATA *)((u_int8_t *)master + (int )(*((db_indx_t *)(((u_int8_t *)master +
                                                                       26) + tmp___2) +
                                                        ((int )i + 1))));
    if (((int )bkkey->type & -129) == 3) {
      bo = (BOVERFLOW *)bkkey;
      ret = __db_safe_goff(dbp___1, vdp, bo->pgno, & key, (void *)(& subdbname), flags);
      if (ret != 0) {
        err_ret = -30976;
        goto __Cont;
      }
      ret = __os_realloc(dbenv___0, key.size + 1U, (void *)(& subdbname));
      if (ret != 0) {
        goto err;
      }
      (*(subdbname + key.size)) = (char )'\000';
    } else {
      if (((int )bkkey->type & -129) == 1) {
        ret = __os_realloc(dbenv___0, (unsigned int )((int )bkkey->len + 1), (void *)(& subdbname));
        if (ret != 0) {
          goto err;
        }
        memcpy((void * __restrict  )subdbname, (void const   * __restrict  )(bkkey->data),
               (unsigned int )bkkey->len);
        (*(subdbname + (int )bkkey->len)) = (char )'\000';
      }
    }
    if ((unsigned int )bkdata->len != sizeof(db_pgno_t )) {
      err_ret = -30976;
      goto __Cont;
    }
    memcpy((void * __restrict  )(& meta_pgno), (void const   * __restrict  )(bkdata->data),
           sizeof(db_pgno_t ));
    while (1) {
      tmp___3 = __db_isbigendian();
      if (! tmp___3) {
        (*((u_int8_t *)(& _tmp) + 0)) = (*((u_int8_t *)(& meta_pgno) + 0));
        (*((u_int8_t *)(& _tmp) + 1)) = (*((u_int8_t *)(& meta_pgno) + 1));
        (*((u_int8_t *)(& _tmp) + 2)) = (*((u_int8_t *)(& meta_pgno) + 2));
        (*((u_int8_t *)(& _tmp) + 3)) = (*((u_int8_t *)(& meta_pgno) + 3));
        (*((u_int8_t *)(& meta_pgno) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
        (*((u_int8_t *)(& meta_pgno) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
        (*((u_int8_t *)(& meta_pgno) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
        (*((u_int8_t *)(& meta_pgno) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
      }
      break;
    }
    if (! (meta_pgno <= vdp->last_pgno)) {
      err_ret = ret;
      goto __Cont;
    } else {
      ret = __memp_fget(mpf, & meta_pgno, 0U, (void *)(& subpg));
      if (ret != 0) {
        err_ret = ret;
        goto __Cont;
      }
    }
    ret = __db_vrfy_common(dbp___1, vdp, subpg, meta_pgno, flags);
    if (ret != 0) {
      err_ret = ret;
      __memp_fput(mpf, (void *)subpg, 0U);
      goto __Cont;
    }
    switch ((int )subpg->type) {
    case 9: 
    ret = __bam_vrfy_meta(dbp___1, vdp, (BTMETA *)subpg, meta_pgno, flags);
    if (ret != 0) {
      err_ret = ret;
      __memp_fput(mpf, (void *)subpg, 0U);
      goto __Cont;
    }
    break;
    case 8: 
    ret = __ham_vrfy_meta(dbp___1, vdp, (HMETA *)subpg, meta_pgno, flags);
    if (ret != 0) {
      err_ret = ret;
      __memp_fput(mpf, (void *)subpg, 0U);
      goto __Cont;
    }
    break;
    default: 
    err_ret = -30976;
    goto __Cont;
    }
    ret = __memp_fput(mpf, (void *)subpg, 0U);
    if (ret != 0) {
      err_ret = ret;
      goto __Cont;
    }
    ret = __db_prheader(dbp___1, subdbname, 0, 0, handle, callback, vdp, meta_pgno);
    if (ret != 0) {
      goto err;
    }
    ret = __db_meta2pgset(dbp___1, vdp, meta_pgno, flags, pgset);
    if (ret != 0) {
      err_ret = ret;
      goto __Cont;
    }
    ret = __db_cursor(pgset, (DB_TXN *)((void *)0), & pgsc, 0U);
    if (ret != 0) {
      goto err;
    }
    while (1) {
      ret = __db_vrfy_pgset_next(pgsc, & p);
      if (! (ret == 0)) {
        break;
      }
      ret = __memp_fget(mpf, & p, 0U, (void *)(& subpg));
      if (ret != 0) {
        err_ret = ret;
        continue;
      }
      ret = __db_salvage(dbp___1, vdp, p, subpg, handle, callback, flags);
      if (ret != 0) {
        err_ret = ret;
      }
      ret = __memp_fput(mpf, (void *)subpg, 0U);
      if (ret != 0) {
        err_ret = ret;
      }
    }
    if (ret != -30990) {
      goto err;
    }
    ret = __db_c_close(pgsc);
    if (ret != 0) {
      goto err;
    }
    ret = __db_prfooter(handle, callback);
    if (ret != 0) {
      goto err;
    }
    __Cont: 
    i = (unsigned short )((int )i + 2);
  }
  err: 
  if (subdbname) {
    __os_free(dbenv___0, (void *)subdbname);
  }
  t_ret = __db_close(pgset, (DB_TXN *)((void *)0), 0U);
  if (t_ret != 0) {
    ret = t_ret;
  }
  t_ret = __db_salvage_markdone(vdp, master->pgno);
  if (t_ret != 0) {
    return (t_ret);
  }
  if (err_ret != 0) {
    tmp___4 = err_ret;
  } else {
    tmp___4 = ret;
  }
  return (tmp___4);
}
}
static int __db_meta2pgset(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t flags ,
                           DB *pgset ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int ret ;
  int t_ret ;

  {
  mpf = dbp___1->mpf;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  switch ((int )h->type) {
  case 9: 
  ret = __bam_meta2pgset(dbp___1, vdp, (BTMETA *)h, flags, pgset);
  break;
  case 8: 
  ret = __ham_meta2pgset(dbp___1, vdp, (HMETA *)h, flags, pgset);
  break;
  default: 
  ret = -30976;
  break;
  }
  t_ret = __memp_fput(mpf, (void *)h, 0U);
  if (t_ret != 0) {
    return (t_ret);
  }
  return (ret);
}
}
static u_int __db_guesspgsize(DB_ENV *dbenv___0 , DB_FH *fhp ) 
{ db_pgno_t i ;
  size_t nr ;
  u_int32_t guess ;
  u_int8_t type ;
  int tmp ;
  int tmp___0 ;

  {
  guess = 65536U;
  while (guess >= 512U) {
    i = 1U;
    while (i <= 3U) {
      tmp = __os_seek(dbenv___0, fhp, guess, i, (unsigned int )((unsigned short )((unsigned int )(& ((DBMETA *)0)->type))),
                      0, (enum __anonenum_DB_OS_SEEK_52 )2);
      if (tmp != 0) {
        break;
      }
      tmp___0 = __os_read(dbenv___0, fhp, (void *)(& type), 1U, & nr);
      if (tmp___0 != 0) {
        break;
      } else {
        if (nr == 0U) {
          break;
        }
      }
      if ((int )type == 0) {
        return (guess << 1);
      } else {
        if ((int )type >= 13) {
          return (guess << 1);
        }
      }
      i ++;
    }
    guess >>= 1;
  }
  return (8192U);
}
}
#pragma merger(0,"/tmp/cil-4E2ByPOK.i","-O2")
int __db_c_put(DBC *dbc_arg , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_set_flags(DB *dbp___1 , u_int32_t flags ) ;
int __db_set_pagesize(DB *dbp___1 , u_int32_t db_pagesize ) ;
static int __db_vrfy_childinc(DBC *dbc , VRFY_CHILDINFO *cip ) ;
static int __db_vrfy_pageinfo_create(DB_ENV *dbenv___0 , VRFY_PAGEINFO **pgipp ) ;
int __db_vrfy_dbinfo_create(DB_ENV *dbenv___0 , u_int32_t pgsize , VRFY_DBINFO **vdpp ) 
{ DB *cdbp ;
  DB *pgdbp ;
  DB *pgset ;
  VRFY_DBINFO *vdp ;
  int ret ;

  {
  vdp = (VRFY_DBINFO *)((void *)0);
  pgset = (DB *)((void *)0);
  pgdbp = pgset;
  cdbp = pgdbp;
  ret = __os_calloc((DB_ENV *)((void *)0), 1U, sizeof(VRFY_DBINFO ), (void *)(& vdp));
  if (ret != 0) {
    goto err;
  }
  ret = db_create(& cdbp, dbenv___0, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_set_flags(cdbp, 2U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_set_pagesize(cdbp, pgsize);
  if (ret != 0) {
    goto err;
  }
  ret = __db_open(cdbp, (DB_TXN *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )1, 1U, 384, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = db_create(& pgdbp, dbenv___0, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_set_pagesize(pgdbp, pgsize);
  if (ret != 0) {
    goto err;
  }
  ret = __db_open(pgdbp, (DB_TXN *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )1, 1U, 384, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_vrfy_pgset(dbenv___0, pgsize, & pgset);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    vdp->subdbs.lh_first = (struct __vrfy_childinfo *)((void *)0);
    break;
  }
  while (1) {
    vdp->activepips.lh_first = (struct __vrfy_pageinfo *)((void *)0);
    break;
  }
  vdp->cdbp = cdbp;
  vdp->pgdbp = pgdbp;
  vdp->pgset = pgset;
  (*vdpp) = vdp;
  return (0);
  err: 
  if ((unsigned int )cdbp != (unsigned int )((void *)0)) {
    __db_close(cdbp, (DB_TXN *)((void *)0), 0U);
  }
  if ((unsigned int )pgdbp != (unsigned int )((void *)0)) {
    __db_close(pgdbp, (DB_TXN *)((void *)0), 0U);
  }
  if ((unsigned int )vdp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)vdp);
  }
  return (ret);
}
}
int __db_vrfy_dbinfo_destroy(DB_ENV *dbenv___0 , VRFY_DBINFO *vdp ) 
{ VRFY_CHILDINFO *c ;
  VRFY_CHILDINFO *d ;
  int t_ret ;
  int ret ;

  {
  ret = 0;
  c = vdp->subdbs.lh_first;
  while ((unsigned int )c != (unsigned int )((void *)0)) {
    d = c->links.le_next;
    __os_free((DB_ENV *)((void *)0), (void *)c);
    c = d;
  }
  t_ret = __db_close(vdp->pgdbp, (DB_TXN *)((void *)0), 0U);
  if (t_ret != 0) {
    ret = t_ret;
  }
  t_ret = __db_close(vdp->cdbp, (DB_TXN *)((void *)0), 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __db_close(vdp->pgset, (DB_TXN *)((void *)0), 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )vdp->extents != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)vdp->extents);
  }
  __os_free(dbenv___0, (void *)vdp);
  return (ret);
}
}
int __db_vrfy_getpageinfo(VRFY_DBINFO *vdp , db_pgno_t pgno , VRFY_PAGEINFO **pipp ) 
{ DBT key ;
  DBT data ;
  DB *pgdbp ;
  VRFY_PAGEINFO *pip ;
  int ret ;

  {
  pip = vdp->activepips.lh_first;
  while ((unsigned int )pip != (unsigned int )((void *)0)) {
    if (pip->pgno == pgno) {
      goto found;
    }
    pip = pip->links.le_next;
  }
  pgdbp = vdp->pgdbp;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  data.flags = data.flags | 4U;
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  ret = __db_get(pgdbp, (DB_TXN *)((void *)0), & key, & data, 0U);
  if (ret == 0) {
    pip = (VRFY_PAGEINFO *)data.data;
    while (1) {
      pip->links.le_next = vdp->activepips.lh_first;
      if ((unsigned int )pip->links.le_next != (unsigned int )((void *)0)) {
        (vdp->activepips.lh_first)->links.le_prev = & pip->links.le_next;
      }
      vdp->activepips.lh_first = pip;
      pip->links.le_prev = & vdp->activepips.lh_first;
      break;
    }
    goto found;
  } else {
    if (ret != -30990) {
      return (ret);
    }
  }
  ret = __db_vrfy_pageinfo_create(pgdbp->dbenv, & pip);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    pip->links.le_next = vdp->activepips.lh_first;
    if ((unsigned int )pip->links.le_next != (unsigned int )((void *)0)) {
      (vdp->activepips.lh_first)->links.le_prev = & pip->links.le_next;
    }
    vdp->activepips.lh_first = pip;
    pip->links.le_prev = & vdp->activepips.lh_first;
    break;
  }
  found: 
  pip->pi_refcount = pip->pi_refcount + 1U;
  (*pipp) = pip;
  return (0);
}
}
int __db_vrfy_putpageinfo(DB_ENV *dbenv___0 , VRFY_DBINFO *vdp , VRFY_PAGEINFO *pip ) 
{ DBT key ;
  DBT data ;
  DB *pgdbp ;
  VRFY_PAGEINFO *p ;
  int ret ;

  {
  pip->pi_refcount = pip->pi_refcount - 1U;
  if (pip->pi_refcount > 0U) {
    return (0);
  }
  pgdbp = vdp->pgdbp;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  key.data = (void *)(& pip->pgno);
  key.size = sizeof(db_pgno_t );
  data.data = (void *)pip;
  data.size = sizeof(VRFY_PAGEINFO );
  ret = __db_put(pgdbp, (DB_TXN *)((void *)0), & key, & data, 0U);
  if (ret != 0) {
    return (ret);
  }
  p = vdp->activepips.lh_first;
  while ((unsigned int )p != (unsigned int )((void *)0)) {
    if ((unsigned int )p == (unsigned int )pip) {
      while (1) {
        if ((unsigned int )p->links.le_next != (unsigned int )((void *)0)) {
          (p->links.le_next)->links.le_prev = p->links.le_prev;
        }
        (*(p->links.le_prev)) = p->links.le_next;
        break;
      }
      break;
    }
    p = p->links.le_next;
  }
  __os_ufree(dbenv___0, (void *)pip);
  return (0);
}
}
int __db_vrfy_pgset(DB_ENV *dbenv___0 , u_int32_t pgsize , DB **dbpp ) 
{ DB *dbp___1 ;
  int ret ;

  {
  ret = db_create(& dbp___1, dbenv___0, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_set_pagesize(dbp___1, pgsize);
  if (ret != 0) {
    goto err;
  }
  ret = __db_open(dbp___1, (DB_TXN *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )1, 1U, 384, 0U);
  if (ret == 0) {
    (*dbpp) = dbp___1;
  } else {
    err: 
    __db_close(dbp___1, (DB_TXN *)((void *)0), 0U);
  }
  return (ret);
}
}
int __db_vrfy_pgset_get(DB *dbp___1 , db_pgno_t pgno , int *valp ) 
{ DBT key ;
  DBT data ;
  int ret ;
  int val ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  data.data = (void *)(& val);
  data.ulen = sizeof(int );
  data.flags = data.flags | 32U;
  ret = __db_get(dbp___1, (DB_TXN *)((void *)0), & key, & data, 0U);
  if (ret == 0) {
    memcpy((void * __restrict  )(& val), (void const   * __restrict  )data.data, sizeof(int ));
  } else {
    if (ret == -30990) {
      val = 0;
    } else {
      return (ret);
    }
  }
  (*valp) = val;
  return (0);
}
}
int __db_vrfy_pgset_inc(DB *dbp___1 , db_pgno_t pgno ) 
{ DBT key ;
  DBT data ;
  int ret ;
  int val ;
  int tmp ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  val = 0;
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  data.data = (void *)(& val);
  data.ulen = sizeof(int );
  data.flags = data.flags | 32U;
  ret = __db_get(dbp___1, (DB_TXN *)((void *)0), & key, & data, 0U);
  if (ret == 0) {
    memcpy((void * __restrict  )(& val), (void const   * __restrict  )data.data, sizeof(int ));
  } else {
    if (ret != -30990) {
      return (ret);
    }
  }
  data.size = sizeof(int );
  val ++;
  tmp = __db_put(dbp___1, (DB_TXN *)((void *)0), & key, & data, 0U);
  return (tmp);
}
}
int __db_vrfy_pgset_next(DBC *dbc , db_pgno_t *pgnop ) 
{ DBT key ;
  DBT data ;
  db_pgno_t pgno ;
  int ret ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  data.flags = data.flags | 40U;
  key.flags = key.flags | 32U;
  key.data = (void *)(& pgno);
  key.ulen = sizeof(db_pgno_t );
  ret = __db_c_get(dbc, & key, & data, 18U);
  if (ret != 0) {
    return (ret);
  }
  (*pgnop) = pgno;
  return (0);
}
}
int __db_vrfy_childcursor(VRFY_DBINFO *vdp , DBC **dbcp ) 
{ DB *cdbp ;
  DBC *dbc ;
  int ret ;

  {
  cdbp = vdp->cdbp;
  ret = __db_cursor(cdbp, (DB_TXN *)((void *)0), & dbc, 0U);
  if (ret == 0) {
    (*dbcp) = dbc;
  }
  return (ret);
}
}
int __db_vrfy_childput(VRFY_DBINFO *vdp , db_pgno_t pgno , VRFY_CHILDINFO *cip ) 
{ DB *cdbp ;
  DBC *cc ;
  DBT key ;
  DBT data ;
  VRFY_CHILDINFO *oldcip ;
  int ret ;
  int tmp ;

  {
  cdbp = vdp->cdbp;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  ret = __db_vrfy_childcursor(vdp, & cc);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_vrfy_ccset(cc, pgno, & oldcip);
  while (ret == 0) {
    if (oldcip->pgno == cip->pgno) {
      ret = __db_vrfy_childinc(cc, oldcip);
      if (ret != 0) {
        return (ret);
      } else {
        ret = __db_vrfy_ccclose(cc);
        if (ret != 0) {
          return (ret);
        }
      }
      return (0);
    }
    ret = __db_vrfy_ccnext(cc, & oldcip);
  }
  if (ret != -30990) {
    __db_vrfy_ccclose(cc);
    return (ret);
  }
  ret = __db_vrfy_ccclose(cc);
  if (ret != 0) {
    return (ret);
  }
  cip->refcnt = 1U;
  data.data = (void *)cip;
  data.size = sizeof(VRFY_CHILDINFO );
  tmp = __db_put(cdbp, (DB_TXN *)((void *)0), & key, & data, 0U);
  return (tmp);
}
}
static int __db_vrfy_childinc(DBC *dbc , VRFY_CHILDINFO *cip ) 
{ DBT key ;
  DBT data ;
  int tmp ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  cip->refcnt = cip->refcnt + 1U;
  data.data = (void *)cip;
  data.size = sizeof(VRFY_CHILDINFO );
  tmp = __db_c_put(dbc, & key, & data, 7U);
  return (tmp);
}
}
int __db_vrfy_ccset(DBC *dbc , db_pgno_t pgno , VRFY_CHILDINFO **cipp ) 
{ DBT key ;
  DBT data ;
  int ret ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  ret = __db_c_get(dbc, & key, & data, 28U);
  if (ret != 0) {
    return (ret);
  }
  (*cipp) = (VRFY_CHILDINFO *)data.data;
  return (0);
}
}
int __db_vrfy_ccnext(DBC *dbc , VRFY_CHILDINFO **cipp ) 
{ DBT key ;
  DBT data ;
  int ret ;

  {
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  ret = __db_c_get(dbc, & key, & data, 19U);
  if (ret != 0) {
    return (ret);
  }
  (*cipp) = (VRFY_CHILDINFO *)data.data;
  return (0);
}
}
int __db_vrfy_ccclose(DBC *dbc ) 
{ int tmp ;

  {
  tmp = __db_c_close(dbc);
  return (tmp);
}
}
static int __db_vrfy_pageinfo_create(DB_ENV *dbenv___0 , VRFY_PAGEINFO **pgipp ) 
{ VRFY_PAGEINFO *pgip ;
  int ret ;

  {
  ret = __os_umalloc(dbenv___0, sizeof(VRFY_PAGEINFO ), (void *)(& pgip));
  if (ret != 0) {
    return (ret);
  }
  memset((void *)pgip, 0, sizeof(VRFY_PAGEINFO ));
  (*pgipp) = pgip;
  return (0);
}
}
int __db_salvage_init(VRFY_DBINFO *vdp ) 
{ DB *dbp___1 ;
  int ret ;

  {
  ret = db_create(& dbp___1, (DB_ENV *)((void *)0), 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_set_pagesize(dbp___1, 1024U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_open(dbp___1, (DB_TXN *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )1, 1U, 0, 0U);
  if (ret != 0) {
    goto err;
  }
  vdp->salvage_pages = dbp___1;
  return (0);
  err: 
  __db_close(dbp___1, (DB_TXN *)((void *)0), 0U);
  return (ret);
}
}
void __db_salvage_destroy(VRFY_DBINFO *vdp ) 
{ 

  {
  __db_close(vdp->salvage_pages, (DB_TXN *)((void *)0), 0U);
  return;
}
}
int __db_salvage_getnext(VRFY_DBINFO *vdp , db_pgno_t *pgnop , u_int32_t *pgtypep ) 
{ DB *dbp___1 ;
  DBC *dbc ;
  DBT key ;
  DBT data ;
  int ret ;
  u_int32_t pgtype ;

  {
  dbp___1 = vdp->salvage_pages;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  ret = __db_cursor(dbp___1, (DB_TXN *)((void *)0), & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    ret = __db_c_get(dbc, & key, & data, 18U);
    if (! (ret == 0)) {
      break;
    }
    memcpy((void * __restrict  )(& pgtype), (void const   * __restrict  )data.data,
           sizeof(pgtype));
    ret = __db_c_del(dbc, 0U);
    if (ret != 0) {
      goto err;
    }
    if (pgtype != 1U) {
      goto found;
    }
  }
  if (0) {
    found: 
    (*pgnop) = (*((db_pgno_t *)key.data));
    (*pgtypep) = (*((u_int32_t *)data.data));
  }
  err: 
  __db_c_close(dbc);
  return (ret);
}
}
int __db_salvage_isdone(VRFY_DBINFO *vdp , db_pgno_t pgno ) 
{ DBT key ;
  DBT data ;
  DB *dbp___1 ;
  int ret ;
  u_int32_t currtype ;

  {
  dbp___1 = vdp->salvage_pages;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  currtype = 0U;
  data.data = (void *)(& currtype);
  data.ulen = sizeof(u_int32_t );
  data.flags = 32U;
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  ret = __db_get(dbp___1, (DB_TXN *)((void *)0), & key, & data, 0U);
  if (ret == 0) {
    if (currtype == 1U) {
      return (-30996);
    } else {
      return (0);
    }
  } else {
    if (ret != -30990) {
      return (ret);
    }
  }
  return (0);
}
}
int __db_salvage_markdone(VRFY_DBINFO *vdp , db_pgno_t pgno ) 
{ DBT key ;
  DBT data ;
  DB *dbp___1 ;
  int pgtype ;
  int ret ;
  u_int32_t currtype ;
  int tmp ;
  int tmp___0 ;

  {
  pgtype = 1;
  dbp___1 = vdp->salvage_pages;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  currtype = 0U;
  data.data = (void *)(& currtype);
  data.ulen = sizeof(u_int32_t );
  data.flags = 32U;
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  ret = __db_salvage_isdone(vdp, pgno);
  if (ret != 0) {
    if (ret == -30996) {
      tmp = -30976;
    } else {
      tmp = ret;
    }
    return (tmp);
  }
  data.size = sizeof(u_int32_t );
  data.data = (void *)(& pgtype);
  tmp___0 = __db_put(dbp___1, (DB_TXN *)((void *)0), & key, & data, 0U);
  return (tmp___0);
}
}
int __db_salvage_markneeded(VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t pgtype ) 
{ DB *dbp___1 ;
  DBT key ;
  DBT data ;
  int ret ;
  int tmp ;

  {
  dbp___1 = vdp->salvage_pages;
  memset((void *)(& key), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  key.data = (void *)(& pgno);
  key.size = sizeof(db_pgno_t );
  data.data = (void *)(& pgtype);
  data.size = sizeof(u_int32_t );
  ret = __db_put(dbp___1, (DB_TXN *)((void *)0), & key, & data, 22U);
  if (ret == -30996) {
    tmp = 0;
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-D38JF2nx.i","-O2")
static int __bam_safe_getdata(DB *dbp___1 , PAGE *h , u_int32_t i , int ovflok , DBT *dbt ,
                              int *freedbtp ) ;
static int __bam_vrfy_inp(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                          db_indx_t *nentriesp , u_int32_t flags ) ;
static int __bam_vrfy_treeorder(DB *dbp___1 , db_pgno_t pgno , PAGE *h , BINTERNAL *lp ,
                                BINTERNAL *rp , int (*func)(DB * , DBT const   * ,
                                                            DBT const   * ) , u_int32_t flags ) ;
static int __ram_vrfy_inp(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                          db_indx_t *nentriesp , u_int32_t flags ) ;
int __bam_vrfy_meta(DB *dbp___1 , VRFY_DBINFO *vdp , BTMETA *meta , db_pgno_t pgno ,
                    u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  int isbad ;
  int t_ret ;
  int ret ;
  db_indx_t ovflsize ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  dbenv___0 = dbp___1->dbenv;
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  if (! (pip->flags & 32U)) {
    ret = __db_vrfy_meta(dbp___1, vdp, & meta->dbmeta, pgno, flags);
    if (ret != 0) {
      if (ret == -30976) {
        isbad = 1;
      } else {
        goto err;
      }
    }
  }
  if (meta->minkey > 0U) {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    ovflsize = (unsigned short )((unsigned long long )((dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                           26) +
                                                                                                                                          tmp___2))))) /
                                                       (meta->minkey * 2U)) - ((((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                                        sizeof(u_int32_t )) -
                                                                                                       1U) &
                                                                                 ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL)) +
                                                                                (unsigned long long )sizeof(db_indx_t )) +
                                                                               ((unsigned long long )((1U +
                                                                                                       sizeof(int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(int32_t ) -
                                                                                   1ULL))));
  } else {
    ovflsize = (unsigned short)0;
  }
  if (meta->minkey < 2U) {
    goto _L;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if ((int )ovflsize > (int )((unsigned short )((unsigned long long )((dbp___1->pgsize -
                                                                         (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                          26) +
                                                                                                                                         tmp___4))))) /
                                                                        4U) - ((((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                                        sizeof(u_int32_t )) -
                                                                                                       1U) &
                                                                                 ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL)) +
                                                                                (unsigned long long )sizeof(db_indx_t )) +
                                                                               ((unsigned long long )((1U +
                                                                                                       sizeof(int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(int32_t ) -
                                                                                   1ULL)))))) {
      _L: 
      pip->bt_minkey = 0U;
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: nonsensical bt_minkey value %lu on metadata page",
                   (unsigned long )pgno, (unsigned long )meta->minkey);
        }
        break;
      }
    } else {
      pip->bt_minkey = meta->minkey;
    }
  }
  pip->bt_maxkey = meta->maxkey;
  pip->re_len = meta->re_len;
  pip->root = 0U;
  if (meta->root == 0U) {
    goto _L___0;
  } else {
    if (meta->root == pgno) {
      goto _L___0;
    } else {
      if (! (meta->root <= vdp->last_pgno)) {
        goto _L___0;
      } else {
        if (pgno == 0U) {
          if (meta->root != 1U) {
            _L___0: 
            isbad = 1;
            while (1) {
              if (! (flags & 64U)) {
                __db_err((DB_ENV const   *)dbenv___0, "Page %lu: nonsensical root page %lu on metadata page",
                         (unsigned long )pgno, (unsigned long )meta->root);
              }
              break;
            }
          } else {
            pip->root = meta->root;
          }
        } else {
          pip->root = meta->root;
        }
      }
    }
  }
  if (meta->dbmeta.flags & 16U) {
    pip->flags = pip->flags | 512U;
  }
  if (meta->dbmeta.flags & 32U) {
    if (meta->dbmeta.flags & 1U) {
      if (pgno == 0U) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: Btree metadata page has both duplicates and multiple databases",
                     (unsigned long )pgno);
          }
          break;
        }
      }
    }
    pip->flags = pip->flags | 8U;
  }
  if (meta->dbmeta.flags & 1U) {
    pip->flags = pip->flags | 2U;
  }
  if (meta->dbmeta.flags & 64U) {
    pip->flags = pip->flags | 4U;
  }
  if (meta->dbmeta.flags & 4U) {
    pip->flags = pip->flags | 16U;
  }
  if (pip->flags & 16U) {
    if (pip->flags & 2U) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: Btree metadata page illegally has both recnums and dups",
                   (unsigned long )pgno);
        }
        break;
      }
      isbad = 1;
    }
  }
  if (meta->dbmeta.flags & 2U) {
    pip->flags = pip->flags | 256U;
    dbp___1->type = (enum __anonenum_DBTYPE_61 )3;
  } else {
    if (pip->flags & 512U) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: metadata page has renumber flag set but is not recno",
                   (unsigned long )pgno);
        }
        break;
      }
    }
  }
  if (pip->flags & 256U) {
    if (pip->flags & 2U) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: recno metadata page specifies duplicates",
                   (unsigned long )pgno);
        }
        break;
      }
      isbad = 1;
    }
  }
  if (meta->dbmeta.flags & 8U) {
    pip->flags = pip->flags | 128U;
  } else {
    if (pip->re_len > 0U) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: re_len of %lu in non-fixed-length database",
                   (unsigned long )pgno, (unsigned long )pip->re_len);
        }
        break;
      }
    }
  }
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___5 = -30976;
    } else {
      tmp___5 = ret;
    }
  } else {
    tmp___5 = ret;
  }
  return (tmp___5);
}
}
int __ram_vrfy_leaf(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) 
{ BKEYDATA *bk ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  db_indx_t i ;
  int ret ;
  int t_ret ;
  int isbad ;
  u_int32_t re_len_guess ;
  u_int32_t len ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fchk(dbenv___0, "__ram_vrfy_leaf", flags, 67U);
  if (ret != 0) {
    goto err;
  }
  if ((int )h->type != 6) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
                 (unsigned long )pgno, "__ram_vrfy_leaf", (unsigned long )h->type);
      }
      break;
    }
    ret = 22;
    goto err;
  }
  ret = __db_vrfy_datapage(dbp___1, vdp, h, pgno, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  ret = __bam_vrfy_inp(dbp___1, vdp, h, pgno, & pip->entries, flags);
  if (ret != 0) {
    goto err;
  }
  if (pip->flags & 2U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: Recno database has dups",
                 (unsigned long )pgno);
      }
      break;
    }
    ret = -30976;
    goto err;
  }
  re_len_guess = 0U;
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___0) + (int )i)));
    if ((int )bk->type & 128) {
      goto __Cont;
    }
    if ((int )bk->type == 3) {
      len = ((BOVERFLOW *)bk)->tlen;
    } else {
      if ((int )bk->type == 1) {
        len = (unsigned int )bk->len;
      } else {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: nonsensical type for item %lu",
                     (unsigned long )pgno, (unsigned long )i);
          }
          break;
        }
        goto __Cont;
      }
    }
    if (re_len_guess == 0U) {
      re_len_guess = len;
    }
    if (re_len_guess != len) {
      re_len_guess = 0U;
      break;
    }
    __Cont: 
    i = (unsigned short )((int )i + 1);
  }
  pip->re_len = re_len_guess;
  pip->rec_cnt = (unsigned int )h->entries;
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___1 = -30976;
    } else {
      tmp___1 = ret;
    }
  } else {
    tmp___1 = ret;
  }
  return (tmp___1);
}
}
int __bam_vrfy(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  int ret ;
  int t_ret ;
  int isbad ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  isbad = 0;
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )h->type) {
  case 3: ;
  case 4: ;
  case 5: ;
  case 12: ;
  break;
  default: ;
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
               (unsigned long )pgno, "__bam_vrfy", (unsigned long )h->type);
    }
    break;
  }
  ret = 22;
  goto err;
  }
  ret = __db_vrfy_datapage(dbp___1, vdp, h, pgno, flags);
  if (ret != 0) {
    if (ret == -30976) {
      isbad = 1;
    } else {
      goto err;
    }
  }
  if ((int )h->type == 3) {
    pip->rec_cnt = h->prev_pgno;
  } else {
    if ((int )h->type == 4) {
      pip->rec_cnt = h->prev_pgno;
    } else {
      if ((int )h->type == 5) {
        tmp___0 = (int )h->entries / 2;
      } else {
        tmp___0 = (int )h->entries;
      }
      pip->rec_cnt = (unsigned int )tmp___0;
    }
  }
  if ((int )h->type == 4) {
    ret = __ram_vrfy_inp(dbp___1, vdp, h, pgno, & pip->entries, flags);
    if (ret != 0) {
      goto err;
    }
  } else {
    ret = __bam_vrfy_inp(dbp___1, vdp, h, pgno, & pip->entries, flags);
    if (ret != 0) {
      if (ret == -30976) {
        isbad = 1;
      } else {
        goto err;
      }
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: item order check unsafe: skipping",
                   (unsigned long )pgno);
        }
        break;
      }
    } else {
      if (! (flags & 2U)) {
        ret = __bam_vrfy_itemorder(dbp___1, vdp, h, pgno, 0U, 0, 0, flags);
        if (ret != 0) {
          if (ret == -30976) {
            isbad = 1;
          } else {
            goto err;
          }
        }
      }
    }
  }
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___1 = -30976;
    } else {
      tmp___1 = ret;
    }
  } else {
    tmp___1 = ret;
  }
  return (tmp___1);
}
}
static int __ram_vrfy_inp(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                          db_indx_t *nentriesp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  RINTERNAL *ri ;
  VRFY_CHILDINFO child ;
  VRFY_PAGEINFO *pip ;
  int ret ;
  int t_ret ;
  int isbad ;
  u_int32_t himark ;
  u_int32_t i ;
  u_int32_t offset ;
  u_int32_t nentries ;
  db_indx_t *inp ;
  u_int8_t *pagelayout ;
  u_int8_t *p ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  isbad = 0;
  memset((void *)(& child), 0, sizeof(VRFY_CHILDINFO ));
  nentries = 0U;
  pagelayout = (u_int8_t *)((void *)0);
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  if ((int )h->type != 4) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
                 (unsigned long )pgno, "__ram_vrfy_inp", (unsigned long )h->type);
      }
      break;
    }
    ret = 22;
    goto err;
  }
  himark = dbp___1->pgsize;
  ret = __os_malloc(dbenv___0, dbp___1->pgsize, (void *)(& pagelayout));
  if (ret != 0) {
    goto err;
  }
  memset((void *)pagelayout, 0, dbp___1->pgsize);
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  i = 0U;
  while (i < (unsigned int )h->entries) {
    if ((unsigned int )((u_int8_t *)inp + i) >= (unsigned int )((u_int8_t *)h + himark)) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: entries listing %lu overlaps data",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      ret = -30976;
      goto err;
    }
    offset = (unsigned int )(*(inp + i));
    if (offset <= (unsigned int )(((u_int8_t *)inp + i) - (u_int8_t *)h)) {
      goto _L;
    } else {
      if (offset > (unsigned int )((unsigned long long )dbp___1->pgsize - ((unsigned long long )((sizeof(RINTERNAL ) +
                                                                                                  sizeof(u_int32_t )) -
                                                                                                 1U) &
                                                                           ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                              1ULL)))) {
        _L: 
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad offset %lu at index %lu",
                     (unsigned long )pgno, (unsigned long )offset, (unsigned long )i);
          }
          break;
        }
        goto __Cont;
      }
    }
    if (offset < himark) {
      himark = offset;
    }
    nentries ++;
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    ri = (RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___2) + i)));
    if ((int )(*(pagelayout + offset)) == 0) {
      (*(pagelayout + offset)) = (unsigned char)1;
      child.pgno = ri->pgno;
      child.type = 3U;
      child.nrecs = ri->nrecs;
      ret = __db_vrfy_childput(vdp, pgno, & child);
      if (ret != 0) {
        goto err;
      }
    } else {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: RINTERNAL structure at offset %lu referenced twice",
                   (unsigned long )pgno, (unsigned long )offset);
        }
        break;
      }
      isbad = 1;
    }
    __Cont: 
    i ++;
  }
  p = pagelayout + himark;
  while ((unsigned int )p < (unsigned int )(pagelayout + dbp___1->pgsize)) {
    if ((int )(*p) != 1) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: gap between items at offset %lu",
                   (unsigned long )pgno, (unsigned long )(p - pagelayout));
        }
        break;
      }
      isbad = 1;
    }
    p += (unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                    1ULL);
  }
  if ((int )((unsigned short )himark) != (int )h->hf_offset) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad HOFFSET %lu, appears to be %lu",
                 (unsigned long )pgno, (unsigned long )h->hf_offset, (unsigned long )himark);
      }
      break;
    }
    isbad = 1;
  }
  (*nentriesp) = (unsigned short )nentries;
  err: 
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )pagelayout != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)pagelayout);
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___3 = -30976;
    } else {
      tmp___3 = ret;
    }
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __bam_vrfy_inp(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                          db_indx_t *nentriesp , u_int32_t flags ) 
{ BKEYDATA *bk ;
  BOVERFLOW *bo ;
  DB_ENV *dbenv___0 ;
  VRFY_CHILDINFO child ;
  VRFY_PAGEINFO *pip ;
  int isbad ;
  int initem ;
  int isdupitem ;
  int ret ;
  int t_ret ;
  u_int32_t himark ;
  u_int32_t offset ;
  u_int32_t i ;
  u_int32_t endoff ;
  u_int32_t nentries ;
  u_int8_t *pagelayout ;
  unsigned int tmp___0 ;
  unsigned long long tmp___1 ;
  int tmp___2 ;

  {
  dbenv___0 = dbp___1->dbenv;
  isdupitem = 0;
  isbad = isdupitem;
  nentries = 0U;
  memset((void *)(& child), 0, sizeof(VRFY_CHILDINFO ));
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )h->type) {
  case 3: ;
  case 5: ;
  case 12: ;
  case 6: ;
  break;
  default: ;
  if (flags & 64U) {
    break;
  }
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
               (unsigned long )pgno, "__bam_vrfy_inp", (unsigned long )h->type);
    }
    break;
  }
  ret = 22;
  goto err;
  }
  himark = dbp___1->pgsize;
  ret = __os_malloc(dbenv___0, dbp___1->pgsize, (void *)(& pagelayout));
  if (ret != 0) {
    goto err;
  }
  memset((void *)pagelayout, 0, dbp___1->pgsize);
  i = 0U;
  while (i < (unsigned int )h->entries) {
    ret = __db_vrfy_inpitem(dbp___1, h, pgno, i, 1, flags, & himark, & offset);
    switch (ret) {
    case 0: ;
    break;
    case -30976: 
    isbad = 1;
    goto __Cont;
    case -30891: 
    isbad = 1;
    goto err;
    default: ;
    break;
    }
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___0) + i)));
    if ((int )(*(pagelayout + offset)) == 0) {
      (*(pagelayout + offset)) = (unsigned char)1;
    } else {
      if ((int )(*(pagelayout + offset)) == 1) {
        if (i % 2U == 0U) {
          if ((int )h->type == 5) {
            pip->flags = pip->flags | 2U;
            nentries ++;
            isdupitem = 1;
          } else {
            goto _L;
          }
        } else {
          _L: 
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicated item %lu",
                       (unsigned long )pgno, (unsigned long )i);
            }
            break;
          }
        }
      }
    }
    switch ((int )bk->type & -129) {
    case 1: ;
    if ((int )h->type == 3) {
      endoff = (unsigned int )(((unsigned long long )offset + ((unsigned long long )(((unsigned int )((int )bk->len +
                                                                                                      (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                      sizeof(u_int32_t )) -
                                                                                     1U) &
                                                               ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                  1ULL))) - 1ULL);
    } else {
      endoff = (unsigned int )(((unsigned long long )offset + ((unsigned long long )(((unsigned int )((int )bk->len +
                                                                                                      (int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                      sizeof(u_int32_t )) -
                                                                                     1U) &
                                                               ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                  1ULL))) - 1ULL);
    }
    break;
    case 2: 
    pip->flags = pip->flags | 2U;
    case 3: ;
    if ((int )h->type == 3) {
      tmp___1 = (unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                       sizeof(u_int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL))) +
                                                       (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                       sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                      1ULL);
    } else {
      tmp___1 = (unsigned long long )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                               sizeof(u_int32_t )) -
                                                                              1U) &
                                                        ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                           1ULL)));
    }
    endoff = (unsigned int )(((unsigned long long )offset + tmp___1) - 1ULL);
    break;
    default: 
    endoff = (unsigned int )(((unsigned long long )offset + ((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])))) +
                                                                                    sizeof(u_int32_t )) -
                                                                                   1U) &
                                                             ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                1ULL))) - 1ULL);
    break;
    }
    if (isdupitem) {
      if ((int )(*(pagelayout + endoff)) != 2) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicated item %lu",
                     (unsigned long )pgno, (unsigned long )i);
          }
          break;
        }
        isbad = 1;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((int )(*(pagelayout + endoff)) == 0) {
        (*(pagelayout + endoff)) = (unsigned char)2;
      }
    }
    isdupitem = 0;
    if ((int )bk->type & 128) {
      if ((int )h->type != 6) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: item %lu marked deleted",
                     (unsigned long )pgno, (unsigned long )i);
          }
          break;
        }
      }
    }
    switch ((int )bk->type & -129) {
    case 1: ;
    break;
    case 2: ;
    if ((int )h->type == 3) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicate page referenced by internal btree page at item %lu",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      break;
    } else {
      if ((int )h->type == 6) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicate page referenced by recno page at item %lu",
                     (unsigned long )pgno, (unsigned long )i);
          }
          break;
        }
        break;
      }
    }
    case 3: ;
    if ((int )h->type == 3) {
      bo = (BOVERFLOW *)(((BINTERNAL *)bk)->data);
    } else {
      bo = (BOVERFLOW *)bk;
    }
    if (((int )bk->type & -129) == 3) {
      if (bo->tlen > dbp___1->pgsize * vdp->last_pgno) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: impossible tlen %lu, item %lu",
                     (unsigned long )pgno, (unsigned long )bo->tlen, (unsigned long )i);
          }
          break;
        }
        break;
      }
    }
    if (! (bo->pgno <= vdp->last_pgno)) {
      goto _L___1;
    } else {
      if (bo->pgno == pgno) {
        goto _L___1;
      } else {
        if (bo->pgno == 0U) {
          _L___1: 
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: offpage item %lu has bad pgno %lu",
                       (unsigned long )pgno, (unsigned long )i, (unsigned long )bo->pgno);
            }
            break;
          }
          break;
        }
      }
    }
    child.pgno = bo->pgno;
    if (((int )bk->type & -129) == 3) {
      child.type = 2U;
    } else {
      child.type = 1U;
    }
    child.tlen = bo->tlen;
    ret = __db_vrfy_childput(vdp, pgno, & child);
    if (ret != 0) {
      goto err;
    }
    break;
    default: 
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: item %lu of invalid type %lu",
                 (unsigned long )pgno, (unsigned long )i, (unsigned long )((int )bk->type &
                                                                           -129));
      }
      break;
    }
    break;
    }
    __Cont: 
    i ++;
  }
  initem = 0;
  i = himark;
  while (i < dbp___1->pgsize) {
    if (initem == 0) {
      switch ((int )(*(pagelayout + i))) {
      case 0: ;
      if ((unsigned long long )i != ((unsigned long long )((i + sizeof(u_int32_t )) -
                                                           1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                    1ULL))) {
        goto __Cont___0;
      }
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: gap between items at offset %lu",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      while (1) {
        if ((int )(*(pagelayout + (i + 1U))) == 0) {
          if (! (i + 1U < dbp___1->pgsize)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
      break;
      case 1: ;
      if ((unsigned long long )i != ((unsigned long long )((i + sizeof(u_int32_t )) -
                                                           1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                    1ULL))) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: offset %lu unaligned",
                     (unsigned long )pgno, (unsigned long )i);
          }
          break;
        }
      }
      initem = 1;
      nentries ++;
      break;
      case 2: 
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: overlapping items at offset %lu",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      break;
      default: 
      ret = 22;
      goto err;
      }
    } else {
      switch ((int )(*(pagelayout + i))) {
      case 0: ;
      break;
      case 2: 
      initem = 0;
      break;
      case 1: 
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: overlapping items at offset %lu",
                   (unsigned long )pgno, (unsigned long )i);
        }
        break;
      }
      break;
      }
    }
    __Cont___0: 
    i ++;
  }
  __os_free(dbenv___0, (void *)pagelayout);
  if ((int )((unsigned short )himark) != (int )h->hf_offset) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad HOFFSET %lu, appears to be %lu",
                 (unsigned long )pgno, (unsigned long )h->hf_offset, (unsigned long )himark);
      }
      break;
    }
    isbad = 1;
  }
  err: 
  if ((unsigned int )nentriesp != (unsigned int )((void *)0)) {
    (*nentriesp) = (unsigned short )nentries;
  }
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (isbad == 1) {
    if (ret == 0) {
      tmp___2 = -30976;
    } else {
      tmp___2 = ret;
    }
  } else {
    tmp___2 = ret;
  }
  return (tmp___2);
}
}
int __bam_vrfy_itemorder(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , db_pgno_t pgno ,
                         u_int32_t nentries , int ovflok , int hasdups , u_int32_t flags ) 
{ BINTERNAL *bi ;
  BKEYDATA *bk ;
  BOVERFLOW *bo ;
  BTREE *bt ;
  DBT dbta ;
  DBT dbtb ;
  DBT dup_1 ;
  DBT dup_2 ;
  DBT *p1 ;
  DBT *p2 ;
  DBT *tmp ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *pip ;
  db_indx_t i ;
  int cmp ;
  int freedup_1 ;
  int freedup_2 ;
  int isbad ;
  int ret ;
  int t_ret ;
  int (*dupfunc)(DB * , DBT const   * , DBT const   * ) ;
  int (*func)(DB * , DBT const   * , DBT const   * ) ;
  void *buf1 ;
  void *buf2 ;
  void *tmpbuf ;
  int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )vdp != (unsigned int )((void *)0)) {
    ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
    if (ret != 0) {
      return (ret);
    }
    nentries = (unsigned int )pip->entries;
  } else {
    pip = (VRFY_PAGEINFO *)((void *)0);
  }
  dbenv___0 = dbp___1->dbenv;
  isbad = 0;
  ret = isbad;
  bo = (BOVERFLOW *)((void *)0);
  memset((void *)(& dbta), 0, sizeof(DBT ));
  dbta.flags = dbta.flags | 16U;
  memset((void *)(& dbtb), 0, sizeof(DBT ));
  dbtb.flags = dbtb.flags | 16U;
  buf2 = (void *)0;
  buf1 = buf2;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    dupfunc = & __bam_defcmp;
  } else {
    dupfunc = dbp___1->dup_compare;
  }
  if ((int )h->type == 12) {
    func = dupfunc;
  } else {
    func = & __bam_defcmp;
    if ((unsigned int )dbp___1->bt_internal != (unsigned int )((void *)0)) {
      bt = (BTREE *)dbp___1->bt_internal;
      if ((unsigned int )bt->bt_compare != (unsigned int )((void *)0)) {
        func = bt->bt_compare;
      }
    }
  }
  p1 = & dbta;
  p2 = & dbtb;
  if ((int )h->type == 3) {
    i = (unsigned short)1;
  } else {
    i = (unsigned short)0;
  }
  while ((unsigned int )i < nentries) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmpbuf = buf1;
    buf1 = buf2;
    buf2 = tmpbuf;
    switch ((int )h->type) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___2) + (int )i)));
    if (((int )bi->type & -129) == 3) {
      bo = (BOVERFLOW *)(bi->data);
      goto overflow;
    } else {
      p2->data = (void *)(bi->data);
      p2->size = (unsigned int )bi->len;
    }
    break;
    case 5: ;
    case 12: ;
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___4) + (int )i)));
    if (((int )bk->type & -129) == 3) {
      bo = (BOVERFLOW *)bk;
      goto overflow;
    } else {
      p2->data = (void *)(bk->data);
      p2->size = (unsigned int )bk->len;
    }
    break;
    default: ;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
                 (unsigned long )pgno, "__bam_vrfy_itemorder", (unsigned long )h->type);
      }
      break;
    }
    ret = 22;
    goto err;
    }
    if (0) {
      overflow: 
      if (! ovflok) {
        pip->flags = pip->flags | 32U;
        goto err;
      }
      p2->data = buf2;
      ret = __db_goff(dbp___1, p2, bo->tlen, bo->pgno, (void **)((void *)0), (u_int32_t *)((void *)0));
      if (ret != 0) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: error %lu in fetching overflow item %lu",
                     (unsigned long )pgno, (unsigned long )ret, (unsigned long )i);
          }
          break;
        }
      }
      buf2 = p2->data;
    }
    if ((unsigned int )p1->data != (unsigned int )((void *)0)) {
      if ((unsigned int )p2->data != (unsigned int )((void *)0)) {
        cmp = ((*func))(dbp___1, (DBT const   *)p1, (DBT const   *)p2);
        if (cmp > 0) {
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: out-of-order key at entry %lu",
                       (unsigned long )pgno, (unsigned long )i);
            }
            break;
          }
        } else {
          if (cmp == 0) {
            if ((unsigned int )pip != (unsigned int )((void *)0)) {
              pip->flags = pip->flags | 2U;
            } else {
              if (hasdups == 0) {
                isbad = 1;
                while (1) {
                  if (! (flags & 64U)) {
                    __db_err((DB_ENV const   *)dbenv___0, "Page %lu: database with no duplicates has duplicated keys",
                             (unsigned long )pgno);
                  }
                  break;
                }
              }
            }
            if ((int )h->type == 5) {
              if ((int )i + 1 >= (int )((unsigned short )nentries)) {
                goto __Cont;
              }
              ret = __bam_safe_getdata(dbp___1, h, (unsigned int )((int )i - 1), ovflok,
                                       & dup_1, & freedup_1);
              if (ret != 0) {
                goto err;
              } else {
                ret = __bam_safe_getdata(dbp___1, h, (unsigned int )((int )i + 1),
                                         ovflok, & dup_2, & freedup_2);
                if (ret != 0) {
                  goto err;
                }
              }
              if ((unsigned int )dup_1.data == (unsigned int )((void *)0)) {
                pip->flags = pip->flags | 32U;
                goto err;
              } else {
                if ((unsigned int )dup_2.data == (unsigned int )((void *)0)) {
                  pip->flags = pip->flags | 32U;
                  goto err;
                }
              }
              tmp___5 = ((*dupfunc))(dbp___1, (DBT const   *)(& dup_1), (DBT const   *)(& dup_2));
              if (tmp___5 > 0) {
                pip->flags = pip->flags | 1U;
              }
              if (freedup_1) {
                __os_ufree(dbenv___0, dup_1.data);
              }
              if (freedup_2) {
                __os_ufree(dbenv___0, dup_2.data);
              }
            }
          }
        }
      }
    }
    __Cont: 
    if ((int )h->type == 5) {
      tmp___0 = 2;
    } else {
      tmp___0 = 1;
    }
    i = (unsigned short )((int )i + tmp___0);
  }
  err: 
  if ((unsigned int )pip != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )buf1 != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, buf1);
  }
  if ((unsigned int )buf2 != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, buf2);
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___6 = -30976;
    } else {
      tmp___6 = ret;
    }
  } else {
    tmp___6 = ret;
  }
  return (tmp___6);
}
}
int __bam_vrfy_structure(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t meta_pgno , u_int32_t flags ) 
{ DB *pgset ;
  DB_ENV *dbenv___0 ;
  VRFY_PAGEINFO *mip ;
  VRFY_PAGEINFO *rip ;
  db_pgno_t root ;
  db_pgno_t p ;
  int t_ret ;
  int ret ;
  u_int32_t nrecs ;
  u_int32_t level ;
  u_int32_t relen ;
  u_int32_t stflags ;

  {
  dbenv___0 = dbp___1->dbenv;
  rip = (VRFY_PAGEINFO *)0;
  mip = rip;
  pgset = vdp->pgset;
  ret = __db_vrfy_getpageinfo(vdp, meta_pgno, & mip);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_vrfy_pgset_get(pgset, meta_pgno, (int *)(& p));
  if (ret != 0) {
    goto err;
  }
  if (p != 0U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: btree metadata page observed twice",
                 (unsigned long )meta_pgno);
      }
      break;
    }
    ret = -30976;
    goto err;
  }
  ret = __db_vrfy_pgset_inc(pgset, meta_pgno);
  if (ret != 0) {
    goto err;
  }
  root = mip->root;
  if (root == 0U) {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: btree metadata page has no root",
                 (unsigned long )meta_pgno);
      }
      break;
    }
    ret = -30976;
    goto err;
  }
  ret = __db_vrfy_getpageinfo(vdp, root, & rip);
  if (ret != 0) {
    goto err;
  }
  switch ((int )rip->type) {
  case 3: ;
  case 5: 
  stflags = flags | 8388608U;
  if (mip->flags & 2U) {
    stflags |= 65536U;
  }
  if (mip->flags & 4U) {
    stflags |= 262144U;
  }
  if (mip->flags & 16U) {
    stflags |= 2097152U;
  }
  ret = __bam_vrfy_subtree(dbp___1, vdp, root, (void *)0, (void *)0, stflags, (u_int32_t *)((void *)0),
                           (u_int32_t *)((void *)0), (u_int32_t *)((void *)0));
  break;
  case 4: ;
  case 6: 
  stflags = ((flags | 2097152U) | 524288U) | 8388608U;
  if (mip->re_len > 0U) {
    stflags |= 4194304U;
  }
  ret = __bam_vrfy_subtree(dbp___1, vdp, root, (void *)0, (void *)0, stflags, & level,
                           & nrecs, & relen);
  if (ret != 0) {
    goto err;
  }
  if (mip->re_len > 0U) {
    if (relen > 0U) {
      if (mip->re_len != relen) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: recno database has bad re_len %lu",
                     (unsigned long )meta_pgno, (unsigned long )relen);
          }
          break;
        }
        ret = -30976;
        goto err;
      }
    }
  }
  ret = 0;
  break;
  case 12: ;
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicate tree referenced from metadata page",
               (unsigned long )meta_pgno);
    }
    break;
  }
  ret = -30976;
  break;
  default: ;
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Page %lu: btree root of incorrect type %lu on metadata page",
               (unsigned long )meta_pgno, (unsigned long )rip->type);
    }
    break;
  }
  ret = -30976;
  break;
  }
  err: 
  if ((unsigned int )mip != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, mip);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )rip != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, rip);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __bam_vrfy_subtree(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , void *l ,
                       void *r , u_int32_t flags , u_int32_t *levelp , u_int32_t *nrecsp ,
                       u_int32_t *relenp ) 
{ BINTERNAL *li ;
  BINTERNAL *ri ;
  BINTERNAL *lp ;
  BINTERNAL *rp ;
  DB *pgset ;
  DBC *cc ;
  DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  VRFY_CHILDINFO *child ;
  VRFY_PAGEINFO *pip ;
  db_indx_t i ;
  db_pgno_t next_pgno ;
  db_pgno_t prev_pgno ;
  db_recno_t child_nrecs ;
  db_recno_t nrecs ;
  u_int32_t child_level ;
  u_int32_t child_relen ;
  u_int32_t j ;
  u_int32_t level ;
  u_int32_t relen ;
  u_int32_t stflags ;
  u_int8_t leaf_type ;
  int (*func)(DB * , DBT const   * , DBT const   * ) ;
  int isbad ;
  int p ;
  int ret ;
  int t_ret ;
  int toplevel ;
  unsigned int tmp___0 ;
  unsigned int tmp___4 ;
  BINTERNAL *tmp___5 ;
  int tmp___6 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  isbad = 0;
  ret = isbad;
  nrecs = 0U;
  h = (PAGE *)((void *)0);
  relen = 0U;
  leaf_type = (unsigned char)0;
  prev_pgno = 0U;
  next_pgno = prev_pgno;
  rp = (BINTERNAL *)r;
  lp = (BINTERNAL *)l;
  if (! (flags & 64U)) {
    __db_vrfy_struct_feedback(dbp___1, vdp);
  }
  ret = __db_vrfy_getpageinfo(vdp, pgno, & pip);
  if (ret != 0) {
    return (ret);
  }
  cc = (DBC *)((void *)0);
  level = (unsigned int )pip->bt_level;
  if (flags & 8388608U) {
    toplevel = 1;
  } else {
    toplevel = 0;
  }
  flags &= 4286578687U;
  if (toplevel) {
    prev_pgno = vdp->prev_pgno;
    next_pgno = vdp->next_pgno;
    leaf_type = vdp->leaf_type;
    vdp->prev_pgno = 0U;
    vdp->next_pgno = vdp->prev_pgno;
    vdp->leaf_type = (unsigned char)0;
  }
  switch ((int )pip->type) {
  case 6: ;
  case 12: ;
  case 5: ;
  if ((int )vdp->leaf_type == 0) {
    vdp->leaf_type = pip->type;
    if (pip->prev_pgno != 0U) {
      goto bad_prev;
    }
  } else {
    if ((int )pip->type != (int )vdp->leaf_type) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unexpected page type %lu found in leaf chain (expected %lu)",
                   (unsigned long )pip->pgno, (unsigned long )pip->type, (unsigned long )vdp->leaf_type);
        }
        break;
      }
      isbad = 1;
    }
    if (! (vdp->flags & 8U)) {
      if (pip->pgno != vdp->next_pgno) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: incorrect next_pgno %lu found in leaf chain (should be %lu)",
                     (unsigned long )vdp->prev_pgno, (unsigned long )vdp->next_pgno,
                     (unsigned long )pip->pgno);
          }
          break;
        }
        isbad = 1;
      }
      if (pip->prev_pgno != vdp->prev_pgno) {
        bad_prev: 
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: incorrect prev_pgno %lu found in leaf chain (should be %lu)",
                     (unsigned long )pip->pgno, (unsigned long )pip->prev_pgno, (unsigned long )vdp->prev_pgno);
          }
          break;
        }
        isbad = 1;
      }
    }
  }
  vdp->prev_pgno = pip->pgno;
  vdp->next_pgno = pip->next_pgno;
  vdp->flags = vdp->flags & 4294967287U;
  ret = __db_vrfy_childcursor(vdp, & cc);
  if (ret != 0) {
    goto err;
  }
  ret = __db_vrfy_ccset(cc, pgno, & child);
  while (ret == 0) {
    if (child->type == 2U) {
      ret = __db_vrfy_ovfl_structure(dbp___1, vdp, child->pgno, child->tlen, flags |
                                                                             1048576U);
      if (ret != 0) {
        if (ret == -30976) {
          isbad = 1;
        } else {
          goto done;
        }
      }
    }
    ret = __db_vrfy_ccnext(cc, & child);
  }
  ret = __db_vrfy_ccclose(cc);
  if (ret != 0) {
    goto err;
  }
  cc = (DBC *)((void *)0);
  if ((int )pip->type == 6) {
    if (! (flags & 524288U)) {
      if (flags & 65536U) {
        if (! (! (flags & 262144U))) {
          goto _L;
        }
      } else {
        _L: 
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: recno leaf page non-recno tree",
                     (unsigned long )pgno);
          }
          break;
        }
        goto done;
      }
    }
    goto leaf;
  } else {
    if (flags & 524288U) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: non-recno leaf page in recno tree",
                   (unsigned long )pgno);
        }
        break;
      }
      goto done;
    }
  }
  if ((int )pip->type == 12) {
    goto leaf;
  }
  if (pip->flags & 2U) {
    if (! (flags & 65536U)) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: duplicates in non-dup btree",
                   (unsigned long )pgno);
        }
        break;
      }
    } else {
      ret = __db_vrfy_childcursor(vdp, & cc);
      if (ret != 0) {
        goto err;
      }
      ret = __db_vrfy_ccset(cc, pgno, & child);
      while (ret == 0) {
        stflags = (flags | 2097152U) | 131072U;
        if (child->type == 1U) {
          ret = __db_vrfy_duptype(dbp___1, vdp, child->pgno, stflags);
          if (ret != 0) {
            isbad = 1;
            goto __Cont;
          }
          ret = __bam_vrfy_subtree(dbp___1, vdp, child->pgno, (void *)0, (void *)0,
                                   stflags | 8388608U, (u_int32_t *)((void *)0), (u_int32_t *)((void *)0),
                                   (u_int32_t *)((void *)0));
          if (ret != 0) {
            if (ret != -30976) {
              goto err;
            } else {
              isbad = 1;
            }
          }
        }
        __Cont: 
        ret = __db_vrfy_ccnext(cc, & child);
      }
      ret = __db_vrfy_ccclose(cc);
      if (ret != 0) {
        goto err;
      }
      cc = (DBC *)((void *)0);
      if (pip->flags & 1U) {
        if (flags & 262144U) {
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unsorted duplicate set in sorted-dup database",
                       (unsigned long )pgno);
            }
            break;
          }
          isbad = 1;
        }
      }
    }
  }
  goto leaf;
  case 3: ;
  case 4: ;
  break;
  default: ;
  if (pip->flags & 64U) {
    while (1) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s is of inappropriate type %lu",
                   (unsigned long )pgno, "btree or recno page", 0UL);
        }
        break;
      }
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: totally zeroed page", (unsigned long )pgno);
        }
        break;
      }
      break;
    }
  } else {
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: btree or recno page is of inappropriate type %lu",
                 (unsigned long )pgno, (unsigned long )pip->type);
      }
      break;
    }
  }
  vdp->flags = vdp->flags | 8U;
  ret = -30976;
  goto err;
  }
  ret = __db_vrfy_childcursor(vdp, & cc);
  if (ret != 0) {
    goto err;
  }
  ret = __db_vrfy_ccset(cc, pgno, & child);
  while (ret == 0) {
    if (child->type == 3U) {
      if ((int )pip->type != 4) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
                     (unsigned long )pgno, "__bam_vrfy_subtree", (unsigned long )pip->type);
          }
          break;
        }
        ret = 22;
        goto err;
      }
      ret = __bam_vrfy_subtree(dbp___1, vdp, child->pgno, (void *)0, (void *)0, flags,
                               & child_level, & child_nrecs, & child_relen);
      if (ret != 0) {
        if (ret != -30976) {
          goto done;
        } else {
          isbad = 1;
        }
      }
      if (flags & 4194304U) {
        if (relen == 0U) {
          relen = child_relen;
        } else {
          if (child_relen > 0U) {
            if (relen != child_relen) {
              isbad = 1;
              while (1) {
                if (! (flags & 64U)) {
                  __db_err((DB_ENV const   *)dbenv___0, "Page %lu: recno page returned bad re_len %lu",
                           (unsigned long )child->pgno, (unsigned long )child_relen);
                }
                break;
              }
            }
          }
        }
        if (relenp) {
          (*relenp) = relen;
        }
      }
      if (flags & 2097152U) {
        nrecs += child_nrecs;
      }
      if (isbad == 0) {
        if (level != child_level + 1U) {
          isbad = 1;
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: recno level incorrect: got %lu, expected %lu",
                       (unsigned long )child->pgno, (unsigned long )child_level, (unsigned long )(level -
                                                                                                  1U));
            }
            break;
          }
        }
      }
    } else {
      if (child->type == 2U) {
        if (child->refcnt > 2U) {
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: overflow page %lu referenced more than twice from internal page",
                       (unsigned long )pgno, (unsigned long )child->pgno);
            }
            break;
          }
          isbad = 1;
        } else {
          j = 0U;
          while (j < child->refcnt) {
            ret = __db_vrfy_ovfl_structure(dbp___1, vdp, child->pgno, child->tlen,
                                           flags);
            if (ret != 0) {
              if (ret == -30976) {
                isbad = 1;
              } else {
                goto done;
              }
            }
            j ++;
          }
        }
      }
    }
    ret = __db_vrfy_ccnext(cc, & child);
  }
  ret = __db_vrfy_ccclose(cc);
  if (ret != 0) {
    goto err;
  }
  cc = (DBC *)((void *)0);
  if ((int )pip->type == 4) {
    goto done;
  }
  if ((unsigned int )h == (unsigned int )((void *)0)) {
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
  }
  i = (unsigned short)0;
  while ((int )i < (int )pip->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    li = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___0) + (int )i)));
    if ((int )i + 1 < (int )pip->entries) {
      if (dbp___1->flags & 2048U) {
        tmp___4 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___4 = sizeof(PG_CHKSUM );
        } else {
          tmp___4 = 0U;
        }
      }
      ri = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___4) + ((int )i +
                                                                            1))));
    } else {
      ri = (BINTERNAL *)((void *)0);
    }
    if ((int )i == 0) {
      tmp___5 = (BINTERNAL *)((void *)0);
    } else {
      tmp___5 = li;
    }
    ret = __bam_vrfy_subtree(dbp___1, vdp, li->pgno, (void *)tmp___5, (void *)ri,
                             flags, & child_level, & child_nrecs, (u_int32_t *)((void *)0));
    if (ret != 0) {
      if (ret != -30976) {
        goto done;
      } else {
        isbad = 1;
      }
    }
    if (flags & 2097152U) {
      nrecs += child_nrecs;
      if (li->nrecs != child_nrecs) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: item %lu has incorrect record count of %lu, should be %lu",
                     (unsigned long )pgno, (unsigned long )i, (unsigned long )li->nrecs,
                     (unsigned long )child_nrecs);
          }
          break;
        }
      }
    }
    if (level != child_level + 1U) {
      isbad = 1;
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: Btree level incorrect: got %lu, expected %lu",
                   (unsigned long )li->pgno, (unsigned long )child_level, (unsigned long )(level -
                                                                                           1U));
        }
        break;
      }
    }
    i = (unsigned short )((int )i + 1);
  }
  if (0) {
    leaf: 
    level = 1U;
    if (flags & 2097152U) {
      nrecs = pip->rec_cnt;
    }
    if (flags & 4194304U) {
      if (relenp) {
        (*relenp) = pip->re_len;
      }
    }
  }
  done: 
  if (pip->flags & 32U) {
    if (isbad == 0) {
      if (ret == 0) {
        if ((unsigned int )h == (unsigned int )((void *)0)) {
          ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
          if (ret != 0) {
            goto err;
          }
        }
        ret = __bam_vrfy_itemorder(dbp___1, vdp, h, pgno, 0U, 1, 0, flags);
        if (ret != 0) {
          goto err;
        }
        pip->flags = pip->flags & 4294967263U;
      }
    }
  }
  if (isbad == 0) {
    if (ret == 0) {
      if ((unsigned int )h == (unsigned int )((void *)0)) {
        ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
        if (ret != 0) {
          goto err;
        }
      }
      if ((int )h->entries == 0) {
        if ((int )h->type == 3) {
          goto _L___0;
        } else {
          if ((int )h->type == 4) {
            _L___0: 
            while (1) {
              if (! (flags & 64U)) {
                __db_err((DB_ENV const   *)dbenv___0, "Page %lu: internal page is empty and should not be",
                         (unsigned long )pgno);
              }
              break;
            }
            isbad = 1;
            goto err;
          }
        }
      }
    }
  }
  if (isbad == 0) {
    if (ret == 0) {
      if (! (flags & 2U)) {
        if ((unsigned int )lp != (unsigned int )((void *)0)) {
          if ((unsigned int )h == (unsigned int )((void *)0)) {
            ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
            if (ret != 0) {
              goto err;
            }
          }
          if (flags & 131072U) {
            func = dbp___1->dup_compare;
          } else {
            func = ((BTREE *)dbp___1->bt_internal)->bt_compare;
          }
          if ((unsigned int )func == (unsigned int )((void *)0)) {
            func = & __bam_defcmp;
          }
          ret = __bam_vrfy_treeorder(dbp___1, pgno, h, lp, rp, func, flags);
          if (ret != 0) {
            if (ret == -30976) {
              isbad = 1;
            } else {
              goto err;
            }
          }
        }
      }
    }
  }
  if (flags & 2097152U) {
    if (nrecs != pip->rec_cnt) {
      if (toplevel) {
        isbad = 1;
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: bad record count: has %lu records, claims %lu",
                     (unsigned long )pgno, (unsigned long )nrecs, (unsigned long )pip->rec_cnt);
          }
          break;
        }
      }
    }
  }
  if (levelp) {
    (*levelp) = level;
  }
  if (nrecsp) {
    (*nrecsp) = nrecs;
  }
  pgset = vdp->pgset;
  ret = __db_vrfy_pgset_get(pgset, pgno, & p);
  if (ret != 0) {
    goto err;
  }
  if (p != 0) {
    isbad = 1;
    while (1) {
      if (! (flags & 64U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Page %lu: linked twice", (unsigned long )pgno);
      }
      break;
    }
  } else {
    ret = __db_vrfy_pgset_inc(pgset, pgno);
    if (ret != 0) {
      goto err;
    }
  }
  if (toplevel) {
    if (vdp->next_pgno != 0U) {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unterminated leaf chain",
                   (unsigned long )vdp->prev_pgno);
        }
        break;
      }
      isbad = 1;
    }
  }
  err: 
  if (toplevel) {
    vdp->next_pgno = next_pgno;
    vdp->prev_pgno = prev_pgno;
    vdp->leaf_type = leaf_type;
  }
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)h, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )cc != (unsigned int )((void *)0)) {
    t_ret = __db_vrfy_ccclose(cc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (ret == 0) {
    if (isbad == 1) {
      tmp___6 = -30976;
    } else {
      tmp___6 = ret;
    }
  } else {
    tmp___6 = ret;
  }
  return (tmp___6);
}
}
static int __bam_vrfy_treeorder(DB *dbp___1 , db_pgno_t pgno , PAGE *h , BINTERNAL *lp ,
                                BINTERNAL *rp , int (*func)(DB * , DBT const   * ,
                                                            DBT const   * ) , u_int32_t flags ) 
{ BOVERFLOW *bo ;
  DB_ENV *dbenv___0 ;
  DBT dbt ;
  db_indx_t last ;
  int ret ;
  int cmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  memset((void *)(& dbt), 0, sizeof(DBT ));
  dbt.flags = dbt.flags | 4U;
  ret = 0;
  if ((int )h->entries == 0) {
    return (0);
  }
  switch ((int )h->type) {
  case 3: ;
  case 12: 
  last = (unsigned short )((int )h->entries - 1);
  break;
  case 5: 
  last = (unsigned short )((int )h->entries - 2);
  break;
  default: ;
  while (1) {
    if (! (flags & 64U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Page %lu: %s called on nonsensical page of type %lu",
               (unsigned long )pgno, "__bam_vrfy_treeorder", (unsigned long )h->type);
    }
    break;
  }
  return (22);
  }
  if ((unsigned int )lp != (unsigned int )((void *)0)) {
    if ((int )h->type != 3) {
      if ((int )lp->type == 1) {
        dbt.data = (void *)(lp->data);
        dbt.size = (unsigned int )lp->len;
      } else {
        if ((int )lp->type == 3) {
          bo = (BOVERFLOW *)(lp->data);
          ret = __db_goff(dbp___1, & dbt, bo->tlen, bo->pgno, (void **)((void *)0),
                          (u_int32_t *)((void *)0));
          if (ret != 0) {
            return (ret);
          }
        } else {
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unknown type for internal record",
                       (unsigned long )h->pgno);
            }
            break;
          }
          return (22);
        }
      }
      ret = __bam_cmp(dbp___1, (DBT const   *)(& dbt), h, 0U, func, & cmp);
      if (ret == 0) {
        if (cmp > 0) {
          while (1) {
            if (! (flags & 64U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Page %lu: first item on page sorted greater than parent entry",
                       (unsigned long )h->pgno);
            }
            break;
          }
          ret = -30976;
        }
      } else {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: first item on page had comparison error",
                     (unsigned long )h->pgno);
          }
          break;
        }
      }
      if ((unsigned int )dbt.data != (unsigned int )(lp->data)) {
        __os_ufree(dbenv___0, dbt.data);
      }
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    if ((int )rp->type == 1) {
      dbt.data = (void *)(rp->data);
      dbt.size = (unsigned int )rp->len;
    } else {
      if ((int )rp->type == 3) {
        bo = (BOVERFLOW *)(rp->data);
        ret = __db_goff(dbp___1, & dbt, bo->tlen, bo->pgno, (void **)((void *)0),
                        (u_int32_t *)((void *)0));
        if (ret != 0) {
          return (ret);
        }
      } else {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: unknown type for internal record",
                     (unsigned long )h->pgno);
          }
          break;
        }
        return (22);
      }
    }
    ret = __bam_cmp(dbp___1, (DBT const   *)(& dbt), h, (unsigned int )last, func,
                    & cmp);
    if (ret == 0) {
      if (cmp < 0) {
        while (1) {
          if (! (flags & 64U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Page %lu: last item on page sorted greater than parent entry",
                     (unsigned long )h->pgno);
          }
          break;
        }
        ret = -30976;
      }
    } else {
      while (1) {
        if (! (flags & 64U)) {
          __db_err((DB_ENV const   *)dbenv___0, "Page %lu: last item on page had comparison error",
                   (unsigned long )h->pgno);
        }
        break;
      }
    }
    if ((unsigned int )dbt.data != (unsigned int )(rp->data)) {
      __os_ufree(dbenv___0, dbt.data);
    }
  }
  return (ret);
}
}
int __bam_salvage(DB *dbp___1 , VRFY_DBINFO *vdp , db_pgno_t pgno , u_int32_t pgtype ,
                  PAGE *h , void *handle , int (*callback)(void * , void const   * ) ,
                  DBT *key , u_int32_t flags ) 
{ DBT dbt ;
  DBT unkdbt ;
  DB_ENV *dbenv___0 ;
  BKEYDATA *bk ;
  BOVERFLOW *bo ;
  db_indx_t i ;
  db_indx_t beg ;
  db_indx_t end ;
  db_indx_t *inp ;
  u_int32_t himark ;
  u_int8_t *pgmap ;
  void *ovflbuf ;
  int t_ret ;
  int ret ;
  int err_ret ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  dbenv___0 = dbp___1->dbenv;
  end = (unsigned short)0;
  end = end;
  pgmap = (u_int8_t *)((void *)0);
  ovflbuf = (void *)pgmap;
  ret = 0;
  err_ret = ret;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___0);
  memset((void *)(& dbt), 0, sizeof(DBT ));
  dbt.flags = 16U;
  memset((void *)(& unkdbt), 0, sizeof(DBT ));
  tmp___1 = strlen("UNKNOWN");
  unkdbt.size = tmp___1 + 1U;
  unkdbt.data = (void *)"UNKNOWN";
  ret = __os_malloc(dbenv___0, dbp___1->pgsize, (void *)(& ovflbuf));
  if (ret != 0) {
    return (ret);
  }
  if (flags & 1U) {
    ret = __os_malloc(dbenv___0, dbp___1->pgsize, (void *)(& pgmap));
    if (ret != 0) {
      goto err;
    }
    memset((void *)pgmap, 0, dbp___1->pgsize);
  }
  himark = dbp___1->pgsize;
  i = (unsigned short)0;
  while (1) {
    if (! (flags & 1U)) {
      if ((int )i >= (int )h->entries) {
        break;
      }
    }
    ret = __db_vrfy_inpitem(dbp___1, h, pgno, (unsigned int )i, 1, flags, & himark,
                            (u_int32_t *)((void *)0));
    if (ret == -30891) {
      if ((int )i < (int )h->entries) {
        ret = -30976;
      } else {
        ret = 0;
      }
      break;
    }
    if (ret == 0) {
      if (dbp___1->flags & 2048U) {
        tmp___3 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___3 = sizeof(PG_CHKSUM );
        } else {
          tmp___3 = 0U;
        }
      }
      bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                               tmp___3) + (int )i)));
      if (! (flags & 1U)) {
        if ((int )bk->type & 128) {
          goto __Cont;
        }
      }
      if ((unsigned int )key != (unsigned int )((void *)0)) {
        if ((int )i != 0) {
          goto _L;
        } else {
          if (! (flags & 524288U)) {
            _L: 
            ret = __db_prdbt(key, 0, " ", handle, callback, 0, vdp);
            if (ret != 0) {
              err_ret = ret;
            }
          }
        }
      }
      beg = (*(inp + (int )i));
      switch ((int )bk->type & -129) {
      case 2: 
      end = (unsigned short )(((int )beg + (int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                           sizeof(u_int32_t )) -
                                                                                          1U) &
                                                                    ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                       1ULL)))) -
                              1);
      if (pgtype != 5U) {
        break;
      }
      bo = (BOVERFLOW *)bk;
      if (! (bo->pgno <= vdp->last_pgno)) {
        goto _L___0;
      } else {
        if ((int )i % 2 == 0) {
          _L___0: 
          ret = __db_prdbt(& unkdbt, 0, " ", handle, callback, 0, vdp);
          if (ret != 0) {
            err_ret = ret;
          }
          break;
        }
      }
      ret = __db_salvage_duptree(dbp___1, vdp, bo->pgno, & dbt, handle, callback,
                                 flags | 524288U);
      if (ret != 0) {
        err_ret = ret;
      }
      break;
      case 1: 
      end = (unsigned short )(((unsigned long long )(((unsigned int )((int )beg +
                                                                      (int )bk->len) +
                                                      sizeof(u_int32_t )) - 1U) &
                               ~ ((unsigned long long )sizeof(u_int32_t ) - 1ULL)) -
                              1ULL);
      dbt.data = (void *)(bk->data);
      dbt.size = (unsigned int )bk->len;
      ret = __db_prdbt(& dbt, 0, " ", handle, callback, 0, vdp);
      if (ret != 0) {
        err_ret = ret;
      }
      break;
      case 3: 
      end = (unsigned short )(((int )beg + (int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                           sizeof(u_int32_t )) -
                                                                                          1U) &
                                                                    ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                       1ULL)))) -
                              1);
      bo = (BOVERFLOW *)bk;
      ret = __db_safe_goff(dbp___1, vdp, bo->pgno, & dbt, (void *)(& ovflbuf), flags);
      if (ret != 0) {
        err_ret = ret;
        __db_prdbt(& unkdbt, 0, " ", handle, callback, 0, vdp);
        break;
      }
      ret = __db_prdbt(& dbt, 0, " ", handle, callback, 0, vdp);
      if (ret != 0) {
        err_ret = ret;
      }
      break;
      default: ;
      return (22);
      }
      if (flags & 1U) {
        (*(pgmap + (int )beg)) = (unsigned char)1;
        (*(pgmap + (int )end)) = (unsigned char)2;
      }
    }
    __Cont: 
    i = (unsigned short )((int )i + 1);
  }
  if (pgtype == 5U) {
    if ((int )i % 2 == 1) {
      ret = __db_prdbt(& unkdbt, 0, " ", handle, callback, 0, vdp);
      if (ret != 0) {
        err_ret = ret;
      }
    }
  }
  err: 
  if ((unsigned int )pgmap != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)pgmap);
  }
  __os_free(dbenv___0, ovflbuf);
  t_ret = __db_salvage_markdone(vdp, pgno);
  if (t_ret != 0) {
    return (t_ret);
  }
  if (err_ret != 0) {
    tmp___4 = err_ret;
  } else {
    tmp___4 = ret;
  }
  return (tmp___4);
}
}
int __bam_salvage_walkdupint(DB *dbp___1 , VRFY_DBINFO *vdp , PAGE *h , DBT *key ,
                             void *handle , int (*callback)(void * , void const   * ) ,
                             u_int32_t flags ) 
{ RINTERNAL *ri ;
  BINTERNAL *bi ;
  int ret ;
  int t_ret ;
  db_indx_t i ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;

  {
  ret = 0;
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    switch ((int )h->type) {
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___0) + (int )i)));
    t_ret = __db_salvage_duptree(dbp___1, vdp, bi->pgno, key, handle, callback, flags);
    if (t_ret != 0) {
      ret = t_ret;
    }
    break;
    case 4: ;
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    ri = (RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___2) + (int )i)));
    t_ret = __db_salvage_duptree(dbp___1, vdp, ri->pgno, key, handle, callback, flags);
    if (t_ret != 0) {
      ret = t_ret;
    }
    break;
    default: 
    __db_err((DB_ENV const   *)dbp___1->dbenv, "__bam_salvage_walkdupint called on non-int. page");
    return (22);
    }
    flags &= ~ (flags & 524288U);
    i = (unsigned short )((int )i + 1);
  }
  return (ret);
}
}
int __bam_meta2pgset(DB *dbp___1 , VRFY_DBINFO *vdp , BTMETA *btmeta , u_int32_t flags ,
                     DB *pgset ) 
{ BINTERNAL *bi ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  RINTERNAL *ri ;
  db_pgno_t current ;
  db_pgno_t p ;
  int err_ret ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  mpf = dbp___1->mpf;
  h = (PAGE *)((void *)0);
  err_ret = 0;
  ret = err_ret;
  current = btmeta->root;
  while (1) {
    if (! (current <= vdp->last_pgno)) {
      err_ret = -30976;
      goto err;
    } else {
      if (current == ((PAGE *)btmeta)->pgno) {
        err_ret = -30976;
        goto err;
      }
    }
    ret = __memp_fget(mpf, & current, 0U, (void *)(& h));
    if (ret != 0) {
      err_ret = ret;
      goto err;
    }
    switch ((int )h->type) {
    case 3: ;
    case 4: 
    ret = __bam_vrfy(dbp___1, vdp, h, current, flags | 2U);
    if (ret != 0) {
      err_ret = ret;
      goto err;
    }
    if ((int )h->type == 3) {
      if (dbp___1->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___0) + 0)));
      current = bi->pgno;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___2 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___2 = sizeof(PG_CHKSUM );
        } else {
          tmp___2 = 0U;
        }
      }
      ri = (RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___2) + 0)));
      current = ri->pgno;
    }
    break;
    case 5: ;
    case 6: ;
    goto traverse;
    default: 
    err_ret = -30976;
    goto err;
    }
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      err_ret = ret;
    }
    h = (PAGE *)((void *)0);
  }
  traverse: 
  while (1) {
    if (current <= vdp->last_pgno) {
      if (! (current != 0U)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )h == (unsigned int )((void *)0)) {
      ret = __memp_fget(mpf, & current, 0U, (void *)(& h));
      if (ret != 0) {
        err_ret = ret;
        break;
      }
    }
    ret = __db_vrfy_pgset_get(pgset, current, (int *)(& p));
    if (ret != 0) {
      goto err;
    }
    if (p != 0U) {
      break;
    }
    ret = __db_vrfy_pgset_inc(pgset, current);
    if (ret != 0) {
      goto err;
    }
    current = h->next_pgno;
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      err_ret = ret;
    }
    h = (PAGE *)((void *)0);
  }
  err: 
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)h, 0U);
  }
  if (ret == 0) {
    tmp___3 = err_ret;
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __bam_safe_getdata(DB *dbp___1 , PAGE *h , u_int32_t i , int ovflok , DBT *dbt ,
                              int *freedbtp ) 
{ BKEYDATA *bk ;
  BOVERFLOW *bo ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  memset((void *)dbt, 0, sizeof(DBT ));
  (*freedbtp) = 0;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___0) + i)));
  if (((int )bk->type & -129) == 3) {
    if (! ovflok) {
      return (0);
    }
    bo = (BOVERFLOW *)bk;
    dbt->flags = dbt->flags | 4U;
    (*freedbtp) = 1;
    tmp___1 = __db_goff(dbp___1, dbt, bo->tlen, bo->pgno, (void **)((void *)0), (u_int32_t *)((void *)0));
    return (tmp___1);
  } else {
    dbt->data = (void *)(bk->data);
    dbt->size = (unsigned int )bk->len;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-wEgAx2O2.i","-O2")
int __aes_setup(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher ) ;
u_int __aes_adj_size(size_t len ) ;
int __aes_close(DB_ENV *dbenv___0 , void *data ) ;
int __aes_decrypt(DB_ENV *dbenv___0 , void *aes_data , void *iv , u_int8_t *cipher ,
                  size_t cipher_len ) ;
int __aes_encrypt(DB_ENV *dbenv___0 , void *aes_data , void *iv , u_int8_t *data ,
                  size_t data_len ) ;
int __aes_init(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher ) ;
int __db_generate_iv(DB_ENV *dbenv___0 , u_int32_t *iv ) ;
int __db_makeKey(keyInstance *key , int direction , int keyLen , char *keyMaterial ) ;
int __db_cipherInit(cipherInstance *cipher , int mode , char *IV ) ;
int __db_blockEncrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                      size_t inputLen , u_int8_t *outBuffer ) ;
int __db_blockDecrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                      size_t inputLen , u_int8_t *outBuffer ) ;
void __db_SHA1Init(SHA1_CTX *context ) ;
void __db_SHA1Update(SHA1_CTX *context , unsigned char *data , size_t len ) ;
void __db_SHA1Final(unsigned char *digest , SHA1_CTX *context ) ;
static void __aes_err(DB_ENV *dbenv___0 , int err ) ;
static int __aes_derivekeys(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher , u_int8_t *passwd ,
                            size_t plen ) ;
int __aes_setup(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher ) 
{ AES_CIPHER *aes_cipher ;
  int ret ;

  {
  db_cipher->adj_size = & __aes_adj_size;
  db_cipher->close = & __aes_close;
  db_cipher->decrypt = & __aes_decrypt;
  db_cipher->encrypt = & __aes_encrypt;
  db_cipher->init = & __aes_init;
  ret = __os_calloc(dbenv___0, 1U, sizeof(AES_CIPHER ), (void *)(& aes_cipher));
  if (ret != 0) {
    return (ret);
  }
  db_cipher->data = (void *)aes_cipher;
  return (0);
}
}
u_int __aes_adj_size(size_t len ) 
{ 

  {
  if (len % 16U == 0U) {
    return (0U);
  }
  return (16U - len % 16U);
}
}
int __aes_close(DB_ENV *dbenv___0 , void *data ) 
{ 

  {
  __os_free(dbenv___0, data);
  return (0);
}
}
int __aes_decrypt(DB_ENV *dbenv___0 , void *aes_data , void *iv , u_int8_t *cipher ,
                  size_t cipher_len ) 
{ AES_CIPHER *aes ;
  cipherInstance c ;
  int ret ;

  {
  aes = (AES_CIPHER *)aes_data;
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
    return (22);
  } else {
    if ((unsigned int )cipher == (unsigned int )((void *)0)) {
      return (22);
    }
  }
  if (cipher_len % 16U != 0U) {
    return (22);
  }
  ret = __db_cipherInit(& c, 2, (char *)iv);
  if (ret < 0) {
    __aes_err(dbenv___0, ret);
    return (11);
  }
  ret = __db_blockDecrypt(& c, & aes->decrypt_ki, cipher, cipher_len * 8U, cipher);
  if (ret < 0) {
    __aes_err(dbenv___0, ret);
    return (11);
  }
  return (0);
}
}
int __aes_encrypt(DB_ENV *dbenv___0 , void *aes_data , void *iv , u_int8_t *data ,
                  size_t data_len ) 
{ AES_CIPHER *aes ;
  cipherInstance c ;
  u_int32_t tmp_iv[4] ;
  int ret ;

  {
  aes = (AES_CIPHER *)aes_data;
  if ((unsigned int )aes == (unsigned int )((void *)0)) {
    return (22);
  } else {
    if ((unsigned int )data == (unsigned int )((void *)0)) {
      return (22);
    }
  }
  if (data_len % 16U != 0U) {
    return (22);
  }
  ret = __db_generate_iv(dbenv___0, tmp_iv);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_cipherInit(& c, 2, (char *)(tmp_iv));
  if (ret < 0) {
    __aes_err(dbenv___0, ret);
    return (11);
  }
  ret = __db_blockEncrypt(& c, & aes->encrypt_ki, data, data_len * 8U, data);
  if (ret < 0) {
    __aes_err(dbenv___0, ret);
    return (11);
  }
  memcpy((void * __restrict  )iv, (void const   * __restrict  )(tmp_iv), 16U);
  return (0);
}
}
int __aes_init(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher ) 
{ int tmp ;

  {
  tmp = __aes_derivekeys(dbenv___0, db_cipher, (u_int8_t *)dbenv___0->passwd, dbenv___0->passwd_len);
  return (tmp);
}
}
static int __aes_derivekeys(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher , u_int8_t *passwd ,
                            size_t plen ) 
{ SHA1_CTX ctx ;
  AES_CIPHER *aes ;
  int ret ;
  u_int32_t temp[5] ;
  size_t tmp ;

  {
  if ((unsigned int )passwd == (unsigned int )((void *)0)) {
    return (22);
  }
  aes = (AES_CIPHER *)db_cipher->data;
  __db_SHA1Init(& ctx);
  __db_SHA1Update(& ctx, passwd, plen);
  tmp = strlen("encryption and decryption key value magic");
  __db_SHA1Update(& ctx, (u_int8_t *)"encryption and decryption key value magic",
                  tmp);
  __db_SHA1Update(& ctx, passwd, plen);
  __db_SHA1Final((u_int8_t *)(temp), & ctx);
  ret = __db_makeKey(& aes->encrypt_ki, 0, 128, (char *)(temp));
  if (ret != 1) {
    __aes_err(dbenv___0, ret);
    return (11);
  }
  ret = __db_makeKey(& aes->decrypt_ki, 1, 128, (char *)(temp));
  if (ret != 1) {
    __aes_err(dbenv___0, ret);
    return (11);
  }
  return (0);
}
}
static void __aes_err(DB_ENV *dbenv___0 , int err ) 
{ char *errstr ;

  {
  switch (err) {
  case -1: 
  errstr = (char *)"AES key direction is invalid";
  break;
  case -2: 
  errstr = (char *)"AES key material not of correct length";
  break;
  case -3: 
  errstr = (char *)"AES key passwd not valid";
  break;
  case -4: 
  errstr = (char *)"AES cipher in wrong state (not initialized)";
  break;
  case -6: 
  errstr = (char *)"AES bad block length";
  break;
  case -7: 
  errstr = (char *)"AES cipher instance is invalid";
  break;
  case -8: 
  errstr = (char *)"AES data contents are invalid";
  break;
  case -9: 
  errstr = (char *)"AES unknown error";
  break;
  default: 
  errstr = (char *)"AES error unrecognized";
  break;
  }
  __db_err((DB_ENV const   *)dbenv___0, (char const   *)errstr);
  return;
}
}
#pragma merger(0,"/tmp/cil-7YHij41r.i","-O2")
int __dbenv_set_encrypt(DB_ENV *dbenv___0 , char const   *passwd , u_int32_t flags ) ;
int __crypto_region_init(DB_ENV *dbenv___0 ) ;
int __crypto_dbenv_close(DB_ENV *dbenv___0 ) ;
int __crypto_algsetup(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher , u_int32_t alg , int do_init ) ;
int __crypto_decrypt_meta(DB_ENV *dbenv___0 , DB *dbp___1 , u_int8_t *mbuf , int do_metachk ) ;
int __crypto_set_passwd(DB_ENV *dbenv_src , DB_ENV *dbenv_dest ) ;
int __crypto_region_init(DB_ENV *dbenv___0 ) 
{ REGENV *renv ;
  REGINFO *infop ;
  CIPHER *cipher ;
  DB_CIPHER *db_cipher ;
  char *sh_passwd ;
  int ret ;
  int tmp ;

  {
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  ret = 0;
  infop = (REGINFO *)dbenv___0->reginfo;
  renv = (REGENV *)infop->primary;
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  if (renv->cipher_off == 0U) {
    if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
      goto out;
    }
    if (! (infop->flags & 1U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Joining non-encrypted environment with encryption key");
      ret = 22;
      goto out;
    }
    if (db_cipher->flags & 1U) {
      __db_err((DB_ENV const   *)dbenv___0, "Encryption algorithm not supplied");
      ret = 22;
      goto out;
    }
    ret = __db_shalloc(infop->addr, sizeof(CIPHER ), 1U, (void *)(& cipher));
    if (ret != 0) {
      goto out;
    }
    memset((void *)cipher, 0, sizeof((*cipher)));
    ret = __db_shalloc(infop->addr, dbenv___0->passwd_len, 0U, (void *)(& sh_passwd));
    if (ret != 0) {
      __db_shalloc_free(infop->addr, (void *)cipher);
      goto out;
    }
    memset((void *)sh_passwd, 0, dbenv___0->passwd_len);
    cipher->passwd = (unsigned int )((u_int8_t *)sh_passwd - (u_int8_t *)infop->addr);
    cipher->passwd_len = dbenv___0->passwd_len;
    cipher->flags = (unsigned int )db_cipher->alg;
    memcpy((void * __restrict  )sh_passwd, (void const   * __restrict  )dbenv___0->passwd,
           cipher->passwd_len);
    renv->cipher_off = (unsigned int )((u_int8_t *)cipher - (u_int8_t *)infop->addr);
  } else {
    if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
      __db_err((DB_ENV const   *)dbenv___0, "Encrypted environment: no encryption key supplied");
      ret = 22;
      goto out;
    }
    cipher = (CIPHER *)((void *)((u_int8_t *)infop->addr + renv->cipher_off));
    sh_passwd = (char *)((void *)((u_int8_t *)infop->addr + cipher->passwd));
    if (cipher->passwd_len != dbenv___0->passwd_len) {
      __db_err((DB_ENV const   *)dbenv___0, "Invalid password");
      ret = 1;
      goto out;
    } else {
      tmp = memcmp((void const   *)dbenv___0->passwd, (void const   *)sh_passwd, cipher->passwd_len);
      if (tmp != 0) {
        __db_err((DB_ENV const   *)dbenv___0, "Invalid password");
        ret = 1;
        goto out;
      }
    }
    if (! (db_cipher->flags & 1U)) {
      if ((unsigned int )db_cipher->alg != cipher->flags) {
        __db_err((DB_ENV const   *)dbenv___0, "Environment encrypted using a different algorithm");
        ret = 22;
        goto out;
      }
    }
    if (db_cipher->flags & 1U) {
      ret = __crypto_algsetup(dbenv___0, db_cipher, cipher->flags, 0);
      if (ret != 0) {
        goto out;
      }
    }
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  ret = ((*(db_cipher->init)))(dbenv___0, db_cipher);
  memset((void *)dbenv___0->passwd, 255, dbenv___0->passwd_len - 1U);
  __os_free(dbenv___0, (void *)dbenv___0->passwd);
  dbenv___0->passwd = (char *)((void *)0);
  dbenv___0->passwd_len = 0U;
  if (0) {
    out: 
    if (! (renv->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
    }
  }
  return (ret);
}
}
int __crypto_dbenv_close(DB_ENV *dbenv___0 ) 
{ DB_CIPHER *db_cipher ;
  int ret ;

  {
  ret = 0;
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if ((unsigned int )dbenv___0->passwd != (unsigned int )((void *)0)) {
    memset((void *)dbenv___0->passwd, 255, dbenv___0->passwd_len - 1U);
    __os_free(dbenv___0, (void *)dbenv___0->passwd);
    dbenv___0->passwd = (char *)((void *)0);
  }
  if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  if (! (db_cipher->flags & 1U)) {
    ret = ((*(db_cipher->close)))(dbenv___0, db_cipher->data);
  }
  __os_free(dbenv___0, (void *)db_cipher);
  return (ret);
}
}
int __crypto_algsetup(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher , u_int32_t alg , int do_init ) 
{ int ret ;

  {
  ret = 0;
  if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
    __db_err((DB_ENV const   *)dbenv___0, "No cipher structure given");
    return (22);
  }
  db_cipher->flags = db_cipher->flags & 4294967294U;
  switch ((int )alg) {
  case 1: 
  db_cipher->alg = (unsigned char)1;
  ret = __aes_setup(dbenv___0, db_cipher);
  break;
  default: 
  __db_panic(dbenv___0, 22);
  }
  if (do_init) {
    ret = ((*(db_cipher->init)))(dbenv___0, db_cipher);
  }
  return (ret);
}
}
int __crypto_decrypt_meta(DB_ENV *dbenv___0 , DB *dbp___1 , u_int8_t *mbuf , int do_metachk ) 
{ DB_CIPHER *db_cipher ;
  DB dummydb ;
  DBMETA *meta ;
  size_t pg_off ;
  int ret ;
  u_int8_t *iv ;
  unsigned int tmp___0 ;

  {
  if ((unsigned int )dbp___1 == (unsigned int )((void *)0)) {
    memset((void *)(& dummydb), 0, sizeof(DB ));
    dbp___1 = & dummydb;
  }
  ret = 0;
  meta = (DBMETA *)mbuf;
  if ((int )meta->encrypt_alg != 0) {
    db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
    if (! (dbp___1->flags & 2048U)) {
      if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
        __db_err((DB_ENV const   *)dbenv___0, "Encrypted database: no encryption flag specified");
        return (22);
      }
      dbp___1->flags = dbp___1->flags | 2049U;
    }
    if (! (db_cipher->flags & 1U)) {
      if ((int )meta->encrypt_alg != (int )db_cipher->alg) {
        __db_err((DB_ENV const   *)dbenv___0, "Database encrypted using a different algorithm");
        return (22);
      }
    }
    iv = ((BTMETA *)mbuf)->iv;
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    pg_off = (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                              26) +
                                                                             tmp___0))));
    alg_retry: 
    if (! (db_cipher->flags & 1U)) {
      if (do_metachk) {
        ret = ((*(db_cipher->decrypt)))(dbenv___0, db_cipher->data, (void *)iv, mbuf +
                                                                                pg_off,
                                        512U - pg_off);
        if (ret) {
          return (ret);
        }
      }
      if (((BTMETA *)meta)->crypto_magic != meta->magic) {
        __db_err((DB_ENV const   *)dbenv___0, "Invalid password");
        return (22);
      }
      return (0);
    }
    ret = __crypto_algsetup(dbenv___0, db_cipher, (unsigned int )meta->encrypt_alg,
                            1);
    goto alg_retry;
  } else {
    if (dbp___1->flags & 2048U) {
      __db_err((DB_ENV const   *)dbenv___0, "Unencrypted database with a supplied encryption key");
      return (22);
    }
  }
  return (ret);
}
}
int __crypto_set_passwd(DB_ENV *dbenv_src , DB_ENV *dbenv_dest ) 
{ CIPHER *cipher ;
  REGENV *renv ;
  REGINFO *infop ;
  char *sh_passwd ;
  int ret ;
  int tmp ;

  {
  ret = 0;
  infop = (REGINFO *)dbenv_src->reginfo;
  renv = (REGENV *)infop->primary;
  cipher = (CIPHER *)((void *)((u_int8_t *)infop->addr + renv->cipher_off));
  sh_passwd = (char *)((void *)((u_int8_t *)infop->addr + cipher->passwd));
  tmp = __dbenv_set_encrypt(dbenv_dest, (char const   *)sh_passwd, 1U);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-v1LQHgeM.i","-O2")
void __db_chksum(u_int8_t *data , size_t data_len , u_int8_t *mac_key , u_int8_t *store ) ;
static void __db_sgenrand(unsigned long seed , unsigned long *mt , int *mtip ) ;
static unsigned long __db_genrand(DB_ENV *dbenv___0 ) ;
int __db_generate_iv(DB_ENV *dbenv___0 , u_int32_t *iv ) 
{ int i ;
  int n ;
  int ret ;

  {
  ret = 0;
  n = (int )(16U / sizeof(u_int32_t ));
  if ((unsigned int )dbenv___0->mt_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->mt_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->mt_mutexp);
    }
  }
  if ((unsigned int )dbenv___0->mt == (unsigned int )((void *)0)) {
    ret = __os_calloc(dbenv___0, 1U, 624U * sizeof(unsigned long ), (void *)(& dbenv___0->mt));
    if (ret != 0) {
      return (ret);
    }
    dbenv___0->mti = 625;
  }
  i = 0;
  while (i < n) {
    while (1) {
      (*(iv + i)) = (u_int32_t )__db_genrand(dbenv___0);
      if (! ((*(iv + i)) == 0U)) {
        break;
      }
    }
    i ++;
  }
  if ((unsigned int )dbenv___0->mt_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->mt_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->mt_mutexp);
    }
  }
  return (0);
}
}
static void __db_sgenrand(unsigned long seed , unsigned long *mt , int *mtip ) 
{ int i ;

  {
  i = 0;
  while (i < 624) {
    (*(mt + i)) = seed & 4294901760UL;
    seed = 69069UL * seed + 1UL;
    (*(mt + i)) = (*(mt + i)) | ((seed & 4294901760UL) >> 16);
    seed = 69069UL * seed + 1UL;
    i ++;
  }
  (*mtip) = 624;
  return;
}
}
static unsigned long mag01[2]  = {      0UL,      2567483615UL};
static unsigned long __db_genrand(DB_ENV *dbenv___0 ) 
{ unsigned long y ;
  u_int32_t secs ;
  u_int32_t seed ;
  u_int32_t usecs ;
  int kk ;
  int tmp ;
  int tmp___0 ;

  {
  if (dbenv___0->mti >= 624) {
    if (dbenv___0->mti == 625) {
      while (1) {
        tmp = __os_clock(dbenv___0, & secs, & usecs);
        if (tmp != 0) {
          return (0UL);
        }
        __db_chksum((u_int8_t *)(& secs), sizeof(secs), (u_int8_t *)((void *)0), (u_int8_t *)(& seed));
        if (! (seed == 0U)) {
          break;
        }
      }
      __db_sgenrand((unsigned long )((long )seed), dbenv___0->mt, & dbenv___0->mti);
    }
    kk = 0;
    while (kk < 227) {
      y = ((*(dbenv___0->mt + kk)) & 2147483648UL) | ((*(dbenv___0->mt + (kk + 1))) &
                                                      2147483647UL);
      (*(dbenv___0->mt + kk)) = ((*(dbenv___0->mt + (kk + 397))) ^ (y >> 1)) ^ mag01[y &
                                                                                     1UL];
      kk ++;
    }
    while (kk < 623) {
      y = ((*(dbenv___0->mt + kk)) & 2147483648UL) | ((*(dbenv___0->mt + (kk + 1))) &
                                                      2147483647UL);
      (*(dbenv___0->mt + kk)) = ((*(dbenv___0->mt + (kk + -227))) ^ (y >> 1)) ^ mag01[y &
                                                                                      1UL];
      kk ++;
    }
    y = ((*(dbenv___0->mt + 623)) & 2147483648UL) | ((*(dbenv___0->mt + 0)) & 2147483647UL);
    (*(dbenv___0->mt + 623)) = ((*(dbenv___0->mt + 396)) ^ (y >> 1)) ^ mag01[y & 1UL];
    dbenv___0->mti = 0;
  }
  tmp___0 = dbenv___0->mti;
  dbenv___0->mti = dbenv___0->mti + 1;
  y = (*(dbenv___0->mt + tmp___0));
  y ^= y >> 11;
  y ^= (y << 7) & 2636928640UL;
  y ^= (y << 15) & 4022730752UL;
  y ^= y >> 18;
  return (y);
}
}
#pragma merger(0,"/tmp/cil-nJDEHOea.i","-O2")
int __db_rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) ;
int __db_rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits ) ;
void __db_rijndaelEncrypt(u32 *rk , int Nr , u8 const   *pt , u8 *ct ) ;
void __db_rijndaelDecrypt(u32 *rk , int Nr , u8 const   *ct , u8 *pt ) ;
static u32 const   Te0[256]  = 
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
static u32 const   Te1[256]  = 
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
static u32 const   Te2[256]  = 
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
static u32 const   Te3[256]  = 
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
static u32 const   Te4[256]  = 
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
static u32 const   Td0[256]  = 
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
static u32 const   Td1[256]  = 
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
static u32 const   Td2[256]  = 
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
static u32 const   Td3[256]  = 
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
static u32 const   Td4[256]  = 
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
static u32 const   rcon[10]  = 
  {      (u32 const   )16777216U,      (u32 const   )33554432U,      (u32 const   )67108864U,      (u32 const   )134217728U, 
        (u32 const   )268435456U,      (u32 const   )536870912U,      (u32 const   )1073741824U,      (u32 const   )2147483648U, 
        (u32 const   )452984832U,      (u32 const   )905969664U};
int __db_rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
  i = 0;
  (*(rk + 0)) = ((((unsigned int )(*(cipherKey + 0)) << 24) ^ ((unsigned int )(*(cipherKey +
                                                                                 1)) <<
                                                               16)) ^ ((unsigned int )(*(cipherKey +
                                                                                         2)) <<
                                                                       8)) ^ (unsigned int )(*(cipherKey +
                                                                                               3));
  (*(rk + 1)) = ((((unsigned int )(*((cipherKey + 4) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                        4) +
                                                                                       1)) <<
                                                                     16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                4) +
                                                                                               2)) <<
                                                                             8)) ^
                (unsigned int )(*((cipherKey + 4) + 3));
  (*(rk + 2)) = ((((unsigned int )(*((cipherKey + 8) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                        8) +
                                                                                       1)) <<
                                                                     16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                8) +
                                                                                               2)) <<
                                                                             8)) ^
                (unsigned int )(*((cipherKey + 8) + 3));
  (*(rk + 3)) = ((((unsigned int )(*((cipherKey + 12) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                         12) +
                                                                                        1)) <<
                                                                      16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                 12) +
                                                                                                2)) <<
                                                                              8)) ^
                (unsigned int )(*((cipherKey + 12) + 3));
  if (keyBits == 128) {
    while (1) {
      temp = (*(rk + 3));
      (*(rk + 4)) = (((((*(rk + 0)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^
                       (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp &
                                                                                                   255U] &
                                                                                               65280U)) ^
                     (unsigned int )(Te4[temp >> 24] & 255U)) ^ rcon[i];
      (*(rk + 5)) = (*(rk + 1)) ^ (*(rk + 4));
      (*(rk + 6)) = (*(rk + 2)) ^ (*(rk + 5));
      (*(rk + 7)) = (*(rk + 3)) ^ (*(rk + 6));
      i ++;
      if (i == 10) {
        return (10);
      }
      rk += 4;
    }
  }
  (*(rk + 4)) = ((((unsigned int )(*((cipherKey + 16) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                         16) +
                                                                                        1)) <<
                                                                      16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                 16) +
                                                                                                2)) <<
                                                                              8)) ^
                (unsigned int )(*((cipherKey + 16) + 3));
  (*(rk + 5)) = ((((unsigned int )(*((cipherKey + 20) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                         20) +
                                                                                        1)) <<
                                                                      16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                 20) +
                                                                                                2)) <<
                                                                              8)) ^
                (unsigned int )(*((cipherKey + 20) + 3));
  if (keyBits == 192) {
    while (1) {
      temp = (*(rk + 5));
      (*(rk + 6)) = (((((*(rk + 0)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^
                       (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp &
                                                                                                   255U] &
                                                                                               65280U)) ^
                     (unsigned int )(Te4[temp >> 24] & 255U)) ^ rcon[i];
      (*(rk + 7)) = (*(rk + 1)) ^ (*(rk + 6));
      (*(rk + 8)) = (*(rk + 2)) ^ (*(rk + 7));
      (*(rk + 9)) = (*(rk + 3)) ^ (*(rk + 8));
      i ++;
      if (i == 8) {
        return (12);
      }
      (*(rk + 10)) = (*(rk + 4)) ^ (*(rk + 9));
      (*(rk + 11)) = (*(rk + 5)) ^ (*(rk + 10));
      rk += 6;
    }
  }
  (*(rk + 6)) = ((((unsigned int )(*((cipherKey + 24) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                         24) +
                                                                                        1)) <<
                                                                      16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                 24) +
                                                                                                2)) <<
                                                                              8)) ^
                (unsigned int )(*((cipherKey + 24) + 3));
  (*(rk + 7)) = ((((unsigned int )(*((cipherKey + 28) + 0)) << 24) ^ ((unsigned int )(*((cipherKey +
                                                                                         28) +
                                                                                        1)) <<
                                                                      16)) ^ ((unsigned int )(*((cipherKey +
                                                                                                 28) +
                                                                                                2)) <<
                                                                              8)) ^
                (unsigned int )(*((cipherKey + 28) + 3));
  if (keyBits == 256) {
    while (1) {
      temp = (*(rk + 7));
      (*(rk + 8)) = (((((*(rk + 0)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^
                       (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp &
                                                                                                   255U] &
                                                                                               65280U)) ^
                     (unsigned int )(Te4[temp >> 24] & 255U)) ^ rcon[i];
      (*(rk + 9)) = (*(rk + 1)) ^ (*(rk + 8));
      (*(rk + 10)) = (*(rk + 2)) ^ (*(rk + 9));
      (*(rk + 11)) = (*(rk + 3)) ^ (*(rk + 10));
      i ++;
      if (i == 7) {
        return (14);
      }
      temp = (*(rk + 11));
      (*(rk + 12)) = ((((*(rk + 4)) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^
                       (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >>
                                                                                                     8) &
                                                                                                    255U] &
                                                                                                65280U)) ^
                     (unsigned int )(Te4[temp & 255U] & 255U);
      (*(rk + 13)) = (*(rk + 5)) ^ (*(rk + 12));
      (*(rk + 14)) = (*(rk + 6)) ^ (*(rk + 13));
      (*(rk + 15)) = (*(rk + 7)) ^ (*(rk + 14));
      rk += 8;
    }
  }
  return (0);
}
}
int __db_rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
  Nr = __db_rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  i = 0;
  j = 4 * Nr;
  while (i < j) {
    temp = (*(rk + i));
    (*(rk + i)) = (*(rk + j));
    (*(rk + j)) = temp;
    temp = (*(rk + (i + 1)));
    (*(rk + (i + 1))) = (*(rk + (j + 1)));
    (*(rk + (j + 1))) = temp;
    temp = (*(rk + (i + 2)));
    (*(rk + (i + 2))) = (*(rk + (j + 2)));
    (*(rk + (j + 2))) = temp;
    temp = (*(rk + (i + 3)));
    (*(rk + (i + 3))) = (*(rk + (j + 3)));
    (*(rk + (j + 3))) = temp;
    i += 4;
    j -= 4;
  }
  i = 1;
  while (i < Nr) {
    rk += 4;
    (*(rk + 0)) = (unsigned int )(((Td0[Te4[(*(rk + 0)) >> 24] & 255U] ^ Td1[Te4[((*(rk +
                                                                                     0)) >>
                                                                                  16) &
                                                                                 255U] &
                                                                             255U]) ^
                                   Td2[Te4[((*(rk + 0)) >> 8) & 255U] & 255U]) ^ Td3[Te4[(*(rk +
                                                                                            0)) &
                                                                                         255U] &
                                                                                     255U]);
    (*(rk + 1)) = (unsigned int )(((Td0[Te4[(*(rk + 1)) >> 24] & 255U] ^ Td1[Te4[((*(rk +
                                                                                     1)) >>
                                                                                  16) &
                                                                                 255U] &
                                                                             255U]) ^
                                   Td2[Te4[((*(rk + 1)) >> 8) & 255U] & 255U]) ^ Td3[Te4[(*(rk +
                                                                                            1)) &
                                                                                         255U] &
                                                                                     255U]);
    (*(rk + 2)) = (unsigned int )(((Td0[Te4[(*(rk + 2)) >> 24] & 255U] ^ Td1[Te4[((*(rk +
                                                                                     2)) >>
                                                                                  16) &
                                                                                 255U] &
                                                                             255U]) ^
                                   Td2[Te4[((*(rk + 2)) >> 8) & 255U] & 255U]) ^ Td3[Te4[(*(rk +
                                                                                            2)) &
                                                                                         255U] &
                                                                                     255U]);
    (*(rk + 3)) = (unsigned int )(((Td0[Te4[(*(rk + 3)) >> 24] & 255U] ^ Td1[Te4[((*(rk +
                                                                                     3)) >>
                                                                                  16) &
                                                                                 255U] &
                                                                             255U]) ^
                                   Td2[Te4[((*(rk + 3)) >> 8) & 255U] & 255U]) ^ Td3[Te4[(*(rk +
                                                                                            3)) &
                                                                                         255U] &
                                                                                     255U]);
    i ++;
  }
  return (Nr);
}
}
void __db_rijndaelEncrypt(u32 *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;
  int r ;

  {
  s0 = (((((unsigned int )(*(pt + 0)) << 24) ^ ((unsigned int )(*(pt + 1)) << 16)) ^
         ((unsigned int )(*(pt + 2)) << 8)) ^ (unsigned int )(*(pt + 3))) ^ (*(rk +
                                                                               0));
  s1 = (((((unsigned int )(*((pt + 4) + 0)) << 24) ^ ((unsigned int )(*((pt + 4) +
                                                                        1)) << 16)) ^
         ((unsigned int )(*((pt + 4) + 2)) << 8)) ^ (unsigned int )(*((pt + 4) + 3))) ^
       (*(rk + 1));
  s2 = (((((unsigned int )(*((pt + 8) + 0)) << 24) ^ ((unsigned int )(*((pt + 8) +
                                                                        1)) << 16)) ^
         ((unsigned int )(*((pt + 8) + 2)) << 8)) ^ (unsigned int )(*((pt + 8) + 3))) ^
       (*(rk + 2));
  s3 = (((((unsigned int )(*((pt + 12) + 0)) << 24) ^ ((unsigned int )(*((pt + 12) +
                                                                         1)) << 16)) ^
         ((unsigned int )(*((pt + 12) + 2)) << 8)) ^ (unsigned int )(*((pt + 12) +
                                                                       3))) ^ (*(rk +
                                                                                 3));
  r = Nr >> 1;
  while (1) {
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) &
                                                                          255U]) ^
                          Te3[s3 & 255U]) ^ (unsigned int const   )(*(rk + 4)));
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) &
                                                                          255U]) ^
                          Te3[s0 & 255U]) ^ (unsigned int const   )(*(rk + 5)));
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) &
                                                                          255U]) ^
                          Te3[s1 & 255U]) ^ (unsigned int const   )(*(rk + 6)));
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) &
                                                                          255U]) ^
                          Te3[s2 & 255U]) ^ (unsigned int const   )(*(rk + 7)));
    rk += 8;
    r --;
    if (r == 0) {
      break;
    }
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) &
                                                                          255U]) ^
                          Te3[t3 & 255U]) ^ (unsigned int const   )(*(rk + 0)));
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) &
                                                                          255U]) ^
                          Te3[t0 & 255U]) ^ (unsigned int const   )(*(rk + 1)));
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) &
                                                                          255U]) ^
                          Te3[t1 & 255U]) ^ (unsigned int const   )(*(rk + 2)));
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) &
                                                                          255U]) ^
                          Te3[t2 & 255U]) ^ (unsigned int const   )(*(rk + 3)));
  }
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] &
                                                           16711680U)) ^ (Te4[(t2 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Te4[t3 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             0)));
  (*(ct + 0)) = (unsigned char )(s0 >> 24);
  (*(ct + 1)) = (unsigned char )(s0 >> 16);
  (*(ct + 2)) = (unsigned char )(s0 >> 8);
  (*(ct + 3)) = (unsigned char )s0;
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] &
                                                           16711680U)) ^ (Te4[(t3 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Te4[t0 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             1)));
  (*((ct + 4) + 0)) = (unsigned char )(s1 >> 24);
  (*((ct + 4) + 1)) = (unsigned char )(s1 >> 16);
  (*((ct + 4) + 2)) = (unsigned char )(s1 >> 8);
  (*((ct + 4) + 3)) = (unsigned char )s1;
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] &
                                                           16711680U)) ^ (Te4[(t0 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Te4[t1 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             2)));
  (*((ct + 8) + 0)) = (unsigned char )(s2 >> 24);
  (*((ct + 8) + 1)) = (unsigned char )(s2 >> 16);
  (*((ct + 8) + 2)) = (unsigned char )(s2 >> 8);
  (*((ct + 8) + 3)) = (unsigned char )s2;
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] &
                                                           16711680U)) ^ (Te4[(t1 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Te4[t2 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             3)));
  (*((ct + 12) + 0)) = (unsigned char )(s3 >> 24);
  (*((ct + 12) + 1)) = (unsigned char )(s3 >> 16);
  (*((ct + 12) + 2)) = (unsigned char )(s3 >> 8);
  (*((ct + 12) + 3)) = (unsigned char )s3;
  return;
}
}
void __db_rijndaelDecrypt(u32 *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;
  int r ;

  {
  s0 = (((((unsigned int )(*(ct + 0)) << 24) ^ ((unsigned int )(*(ct + 1)) << 16)) ^
         ((unsigned int )(*(ct + 2)) << 8)) ^ (unsigned int )(*(ct + 3))) ^ (*(rk +
                                                                               0));
  s1 = (((((unsigned int )(*((ct + 4) + 0)) << 24) ^ ((unsigned int )(*((ct + 4) +
                                                                        1)) << 16)) ^
         ((unsigned int )(*((ct + 4) + 2)) << 8)) ^ (unsigned int )(*((ct + 4) + 3))) ^
       (*(rk + 1));
  s2 = (((((unsigned int )(*((ct + 8) + 0)) << 24) ^ ((unsigned int )(*((ct + 8) +
                                                                        1)) << 16)) ^
         ((unsigned int )(*((ct + 8) + 2)) << 8)) ^ (unsigned int )(*((ct + 8) + 3))) ^
       (*(rk + 2));
  s3 = (((((unsigned int )(*((ct + 12) + 0)) << 24) ^ ((unsigned int )(*((ct + 12) +
                                                                         1)) << 16)) ^
         ((unsigned int )(*((ct + 12) + 2)) << 8)) ^ (unsigned int )(*((ct + 12) +
                                                                       3))) ^ (*(rk +
                                                                                 3));
  r = Nr >> 1;
  while (1) {
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) &
                                                                          255U]) ^
                          Td3[s1 & 255U]) ^ (unsigned int const   )(*(rk + 4)));
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) &
                                                                          255U]) ^
                          Td3[s2 & 255U]) ^ (unsigned int const   )(*(rk + 5)));
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) &
                                                                          255U]) ^
                          Td3[s3 & 255U]) ^ (unsigned int const   )(*(rk + 6)));
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) &
                                                                          255U]) ^
                          Td3[s0 & 255U]) ^ (unsigned int const   )(*(rk + 7)));
    rk += 8;
    r --;
    if (r == 0) {
      break;
    }
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) &
                                                                          255U]) ^
                          Td3[t1 & 255U]) ^ (unsigned int const   )(*(rk + 0)));
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) &
                                                                          255U]) ^
                          Td3[t2 & 255U]) ^ (unsigned int const   )(*(rk + 1)));
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) &
                                                                          255U]) ^
                          Td3[t3 & 255U]) ^ (unsigned int const   )(*(rk + 2)));
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) &
                                                                          255U]) ^
                          Td3[t0 & 255U]) ^ (unsigned int const   )(*(rk + 3)));
  }
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] &
                                                           16711680U)) ^ (Td4[(t2 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Td4[t1 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             0)));
  (*(pt + 0)) = (unsigned char )(s0 >> 24);
  (*(pt + 1)) = (unsigned char )(s0 >> 16);
  (*(pt + 2)) = (unsigned char )(s0 >> 8);
  (*(pt + 3)) = (unsigned char )s0;
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] &
                                                           16711680U)) ^ (Td4[(t3 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Td4[t2 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             1)));
  (*((pt + 4) + 0)) = (unsigned char )(s1 >> 24);
  (*((pt + 4) + 1)) = (unsigned char )(s1 >> 16);
  (*((pt + 4) + 2)) = (unsigned char )(s1 >> 8);
  (*((pt + 4) + 3)) = (unsigned char )s1;
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] &
                                                           16711680U)) ^ (Td4[(t0 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Td4[t3 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             2)));
  (*((pt + 8) + 0)) = (unsigned char )(s2 >> 24);
  (*((pt + 8) + 1)) = (unsigned char )(s2 >> 16);
  (*((pt + 8) + 2)) = (unsigned char )(s2 >> 8);
  (*((pt + 8) + 3)) = (unsigned char )s2;
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] &
                                                           16711680U)) ^ (Td4[(t1 >>
                                                                               8) &
                                                                              255U] &
                                                                          65280U)) ^
                        (Td4[t0 & 255U] & 255U)) ^ (unsigned int const   )(*(rk +
                                                                             3)));
  (*((pt + 12) + 0)) = (unsigned char )(s3 >> 24);
  (*((pt + 12) + 1)) = (unsigned char )(s3 >> 16);
  (*((pt + 12) + 2)) = (unsigned char )(s3 >> 8);
  (*((pt + 12) + 3)) = (unsigned char )s3;
  return;
}
}
#pragma merger(0,"/tmp/cil-6bHgJHRX.i","-O2")
int __db_padEncrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                    int inputOctets , u_int8_t *outBuffer ) ;
int __db_padDecrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                    int inputOctets , u_int8_t *outBuffer ) ;
int __db_makeKey(keyInstance *key , int direction , int keyLen , char *keyMaterial ) 
{ u8 cipherKey[32] ;

  {
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    return (-3);
  }
  if (direction == 0) {
    key->direction = (unsigned char )direction;
  } else {
    if (direction == 1) {
      key->direction = (unsigned char )direction;
    } else {
      return (-1);
    }
  }
  if (keyLen == 128) {
    key->keyLen = keyLen;
  } else {
    if (keyLen == 192) {
      key->keyLen = keyLen;
    } else {
      if (keyLen == 256) {
        key->keyLen = keyLen;
      } else {
        return (-2);
      }
    }
  }
  if ((unsigned int )keyMaterial != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )(cipherKey), (void const   * __restrict  )keyMaterial,
           (unsigned int )(key->keyLen / 4));
  }
  if (direction == 0) {
    key->Nr = __db_rijndaelKeySetupEnc(key->rk, (u8 const   *)(cipherKey), keyLen);
  } else {
    key->Nr = __db_rijndaelKeySetupDec(key->rk, (u8 const   *)(cipherKey), keyLen);
  }
  __db_rijndaelKeySetupEnc(key->ek, (u8 const   *)(cipherKey), keyLen);
  return (1);
}
}
int __db_cipherInit(cipherInstance *cipher , int mode , char *IV ) 
{ 

  {
  if (mode == 1) {
    cipher->mode = (unsigned char )mode;
  } else {
    if (mode == 2) {
      cipher->mode = (unsigned char )mode;
    } else {
      if (mode == 3) {
        cipher->mode = (unsigned char )mode;
      } else {
        return (-4);
      }
    }
  }
  if ((unsigned int )IV != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )(cipher->IV), (void const   * __restrict  )IV, 16U);
  }
  return (1);
}
}
int __db_blockEncrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                      size_t inputLen , u_int8_t *outBuffer ) 
{ int i ;
  int k ;
  int t ;
  int numBlocks ;
  u8 block[16] ;
  u8 *iv ;
  u32 tmpiv[4] ;

  {
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
    return (-5);
  } else {
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      return (-5);
    } else {
      if ((int )key->direction == 1) {
        return (-5);
      }
    }
  }
  if ((unsigned int )input == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if (inputLen <= 0U) {
      return (0);
    }
  }
  numBlocks = (int )(inputLen / 128U);
  switch ((int )cipher->mode) {
  case 1: 
  i = numBlocks;
  while (i > 0) {
    __db_rijndaelEncrypt(key->rk, key->Nr, (u8 const   *)input, outBuffer);
    input += 16;
    outBuffer += 16;
    i --;
  }
  break;
  case 2: 
  iv = cipher->IV;
  i = numBlocks;
  while (i > 0) {
    memcpy((void * __restrict  )(tmpiv), (void const   * __restrict  )iv, 16U);
    (*((u32 *)(block) + 0)) = (*((u32 *)input + 0)) ^ tmpiv[0];
    (*((u32 *)(block) + 1)) = (*((u32 *)input + 1)) ^ tmpiv[1];
    (*((u32 *)(block) + 2)) = (*((u32 *)input + 2)) ^ tmpiv[2];
    (*((u32 *)(block) + 3)) = (*((u32 *)input + 3)) ^ tmpiv[3];
    __db_rijndaelEncrypt(key->rk, key->Nr, (u8 const   *)(block), outBuffer);
    iv = outBuffer;
    input += 16;
    outBuffer += 16;
    i --;
  }
  break;
  case 3: 
  iv = cipher->IV;
  i = numBlocks;
  while (i > 0) {
    memcpy((void * __restrict  )outBuffer, (void const   * __restrict  )input, 16U);
    k = 0;
    while (k < 128) {
      __db_rijndaelEncrypt(key->ek, key->Nr, (u8 const   *)iv, block);
      (*(outBuffer + (k >> 3))) = (unsigned char )((unsigned int )(*(outBuffer + (k >>
                                                                                  3))) ^
                                                   (((unsigned int )block[0] & 128U) >>
                                                    (k & 7)));
      t = 0;
      while (t < 15) {
        (*(iv + t)) = (unsigned char )(((int )(*(iv + t)) << 1) | ((int )(*(iv + (t +
                                                                                  1))) >>
                                                                   7));
        t ++;
      }
      (*(iv + 15)) = (unsigned char )(((int )(*(iv + 15)) << 1) | (((int )(*(outBuffer +
                                                                             (k >>
                                                                              3))) >>
                                                                    (7 - (k & 7))) &
                                                                   1));
      k ++;
    }
    outBuffer += 16;
    input += 16;
    i --;
  }
  break;
  default: ;
  return (-5);
  }
  return (128 * numBlocks);
}
}
int __db_padEncrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                    int inputOctets , u_int8_t *outBuffer ) 
{ int i ;
  int numBlocks ;
  int padLen ;
  u8 block[16] ;
  u8 *iv ;
  u32 tmpiv[4] ;

  {
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
    return (-5);
  } else {
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      return (-5);
    } else {
      if ((int )key->direction == 1) {
        return (-5);
      }
    }
  }
  if ((unsigned int )input == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if (inputOctets <= 0) {
      return (0);
    }
  }
  numBlocks = inputOctets / 16;
  switch ((int )cipher->mode) {
  case 1: 
  i = numBlocks;
  while (i > 0) {
    __db_rijndaelEncrypt(key->rk, key->Nr, (u8 const   *)input, outBuffer);
    input += 16;
    outBuffer += 16;
    i --;
  }
  padLen = 16 - (inputOctets - 16 * numBlocks);
  memcpy((void * __restrict  )(block), (void const   * __restrict  )input, (unsigned int )(16 -
                                                                                           padLen));
  memset((void *)((block + 16) - padLen), padLen, (unsigned int )padLen);
  __db_rijndaelEncrypt(key->rk, key->Nr, (u8 const   *)(block), outBuffer);
  break;
  case 2: 
  iv = cipher->IV;
  i = numBlocks;
  while (i > 0) {
    memcpy((void * __restrict  )(tmpiv), (void const   * __restrict  )iv, 16U);
    (*((u32 *)(block) + 0)) = (*((u32 *)input + 0)) ^ tmpiv[0];
    (*((u32 *)(block) + 1)) = (*((u32 *)input + 1)) ^ tmpiv[1];
    (*((u32 *)(block) + 2)) = (*((u32 *)input + 2)) ^ tmpiv[2];
    (*((u32 *)(block) + 3)) = (*((u32 *)input + 3)) ^ tmpiv[3];
    __db_rijndaelEncrypt(key->rk, key->Nr, (u8 const   *)(block), outBuffer);
    iv = outBuffer;
    input += 16;
    outBuffer += 16;
    i --;
  }
  padLen = 16 - (inputOctets - 16 * numBlocks);
  i = 0;
  while (i < 16 - padLen) {
    block[i] = (unsigned char )((int )(*(input + i)) ^ (int )(*(iv + i)));
    i ++;
  }
  i = 16 - padLen;
  while (i < 16) {
    block[i] = (unsigned char )((int )((unsigned char )padLen) ^ (int )(*(iv + i)));
    i ++;
  }
  __db_rijndaelEncrypt(key->rk, key->Nr, (u8 const   *)(block), outBuffer);
  break;
  default: ;
  return (-5);
  }
  return (16 * (numBlocks + 1));
}
}
int __db_blockDecrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                      size_t inputLen , u_int8_t *outBuffer ) 
{ int i ;
  int k ;
  int t ;
  int numBlocks ;
  u8 block[16] ;
  u8 *iv ;
  u32 tmpiv[4] ;

  {
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
    return (-5);
  } else {
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      return (-5);
    } else {
      if ((int )cipher->mode != 3) {
        if ((int )key->direction == 0) {
          return (-5);
        }
      }
    }
  }
  if ((unsigned int )input == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if (inputLen <= 0U) {
      return (0);
    }
  }
  numBlocks = (int )(inputLen / 128U);
  switch ((int )cipher->mode) {
  case 1: 
  i = numBlocks;
  while (i > 0) {
    __db_rijndaelDecrypt(key->rk, key->Nr, (u8 const   *)input, outBuffer);
    input += 16;
    outBuffer += 16;
    i --;
  }
  break;
  case 2: 
  memcpy((void * __restrict  )(tmpiv), (void const   * __restrict  )(cipher->IV),
         16U);
  i = numBlocks;
  while (i > 0) {
    __db_rijndaelDecrypt(key->rk, key->Nr, (u8 const   *)input, block);
    (*((u32 *)(block) + 0)) = (*((u32 *)(block) + 0)) ^ tmpiv[0];
    (*((u32 *)(block) + 1)) = (*((u32 *)(block) + 1)) ^ tmpiv[1];
    (*((u32 *)(block) + 2)) = (*((u32 *)(block) + 2)) ^ tmpiv[2];
    (*((u32 *)(block) + 3)) = (*((u32 *)(block) + 3)) ^ tmpiv[3];
    memcpy((void * __restrict  )(tmpiv), (void const   * __restrict  )input, 16U);
    memcpy((void * __restrict  )outBuffer, (void const   * __restrict  )(block), 16U);
    input += 16;
    outBuffer += 16;
    i --;
  }
  break;
  case 3: 
  iv = cipher->IV;
  i = numBlocks;
  while (i > 0) {
    memcpy((void * __restrict  )outBuffer, (void const   * __restrict  )input, 16U);
    k = 0;
    while (k < 128) {
      __db_rijndaelEncrypt(key->ek, key->Nr, (u8 const   *)iv, block);
      t = 0;
      while (t < 15) {
        (*(iv + t)) = (unsigned char )(((int )(*(iv + t)) << 1) | ((int )(*(iv + (t +
                                                                                  1))) >>
                                                                   7));
        t ++;
      }
      (*(iv + 15)) = (unsigned char )(((int )(*(iv + 15)) << 1) | (((int )(*(input +
                                                                             (k >>
                                                                              3))) >>
                                                                    (7 - (k & 7))) &
                                                                   1));
      (*(outBuffer + (k >> 3))) = (unsigned char )((unsigned int )(*(outBuffer + (k >>
                                                                                  3))) ^
                                                   (((unsigned int )block[0] & 128U) >>
                                                    (k & 7)));
      k ++;
    }
    outBuffer += 16;
    input += 16;
    i --;
  }
  break;
  default: ;
  return (-5);
  }
  return (128 * numBlocks);
}
}
int __db_padDecrypt(cipherInstance *cipher , keyInstance *key , u_int8_t *input ,
                    int inputOctets , u_int8_t *outBuffer ) 
{ int i ;
  int numBlocks ;
  int padLen ;
  u8 block[16] ;
  u32 tmpiv[4] ;

  {
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
    return (-5);
  } else {
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      return (-5);
    } else {
      if ((int )key->direction == 0) {
        return (-5);
      }
    }
  }
  if ((unsigned int )input == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if (inputOctets <= 0) {
      return (0);
    }
  }
  if (inputOctets % 16 != 0) {
    return (-8);
  }
  numBlocks = inputOctets / 16;
  switch ((int )cipher->mode) {
  case 1: 
  i = numBlocks - 1;
  while (i > 0) {
    __db_rijndaelDecrypt(key->rk, key->Nr, (u8 const   *)input, outBuffer);
    input += 16;
    outBuffer += 16;
    i --;
  }
  __db_rijndaelDecrypt(key->rk, key->Nr, (u8 const   *)input, block);
  padLen = (int )block[15];
  if (padLen >= 16) {
    return (-8);
  }
  i = 16 - padLen;
  while (i < 16) {
    if ((int )block[i] != padLen) {
      return (-8);
    }
    i ++;
  }
  memcpy((void * __restrict  )outBuffer, (void const   * __restrict  )(block), (unsigned int )(16 -
                                                                                               padLen));
  break;
  case 2: 
  memcpy((void * __restrict  )(tmpiv), (void const   * __restrict  )(cipher->IV),
         16U);
  i = numBlocks - 1;
  while (i > 0) {
    __db_rijndaelDecrypt(key->rk, key->Nr, (u8 const   *)input, block);
    (*((u32 *)(block) + 0)) = (*((u32 *)(block) + 0)) ^ tmpiv[0];
    (*((u32 *)(block) + 1)) = (*((u32 *)(block) + 1)) ^ tmpiv[1];
    (*((u32 *)(block) + 2)) = (*((u32 *)(block) + 2)) ^ tmpiv[2];
    (*((u32 *)(block) + 3)) = (*((u32 *)(block) + 3)) ^ tmpiv[3];
    memcpy((void * __restrict  )(tmpiv), (void const   * __restrict  )input, 16U);
    memcpy((void * __restrict  )outBuffer, (void const   * __restrict  )(block), 16U);
    input += 16;
    outBuffer += 16;
    i --;
  }
  __db_rijndaelDecrypt(key->rk, key->Nr, (u8 const   *)input, block);
  (*((u32 *)(block) + 0)) = (*((u32 *)(block) + 0)) ^ tmpiv[0];
  (*((u32 *)(block) + 1)) = (*((u32 *)(block) + 1)) ^ tmpiv[1];
  (*((u32 *)(block) + 2)) = (*((u32 *)(block) + 2)) ^ tmpiv[2];
  (*((u32 *)(block) + 3)) = (*((u32 *)(block) + 3)) ^ tmpiv[3];
  padLen = (int )block[15];
  if (padLen <= 0) {
    return (-8);
  } else {
    if (padLen > 16) {
      return (-8);
    }
  }
  i = 16 - padLen;
  while (i < 16) {
    if ((int )block[i] != padLen) {
      return (-8);
    }
    i ++;
  }
  memcpy((void * __restrict  )outBuffer, (void const   * __restrict  )(block), (unsigned int )(16 -
                                                                                               padLen));
  break;
  default: ;
  return (-5);
  }
  return (16 * numBlocks - padLen);
}
}
#pragma merger(0,"/tmp/cil-uqLJ4329.i","-O2")
int __crdel_metasub_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        db_pgno_t pgno , DBT const   *page , DB_LSN *lsn ) ;
int __crdel_metasub_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) ;
int __crdel_metasub_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) ;
int __crdel_metasub_read(DB_ENV *dbenv___0 , void *recbuf , __crdel_metasub_args **argpp ) ;
int __crdel_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __crdel_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                             db_recops  , void * ) ,
                          size_t *dtabsizep ) ;
int __crdel_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                            db_recops  , void * ) ,
                         size_t *dtabsizep ) ;
int __crdel_metasub_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) ;
int __crdel_metasub_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        db_pgno_t pgno , DBT const   *page , DB_LSN *lsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 142U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )page == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = page->size;
  }
  logrec.size = ((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                   sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp) + sizeof((*lsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )page == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& page->size), sizeof(page->size));
    bp += sizeof(page->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )page->data, page->size);
    bp += page->size;
  }
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __crdel_metasub_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __crdel_metasub_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) 
{ __crdel_metasub_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __crdel_metasub_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__crdel_metasub%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tpage: ");
  i = 0U;
  while (i < argp->page.size) {
    ch = (int )(*((u_int8_t *)argp->page.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __crdel_metasub_read(DB_ENV *dbenv___0 , void *recbuf , __crdel_metasub_args **argpp ) 
{ __crdel_metasub_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__crdel_metasub_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->page), 0, sizeof(argp->page));
  memcpy((void * __restrict  )(& argp->page.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->page.data = (void *)bp;
  bp += argp->page.size;
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  (*argpp) = argp;
  return (0);
}
}
int __crdel_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __crdel_metasub_print, 142U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __crdel_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                             db_recops  , void * ) ,
                          size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __crdel_metasub_getpgnos,
                          142U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __crdel_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                            db_recops  , void * ) ,
                         size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __crdel_metasub_recover,
                          142U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-qjwE3C9H.i","-O2")
int __crdel_metasub_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) 
{ __crdel_metasub_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__crdel_metasub_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __crdel_metasub_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 4) {
      goto _L;
    } else {
      if ((int )op == 1) {
        _L: 
        ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
        if (ret != 0) {
          goto out;
        }
      } else {
        (*lsnp) = argp->prev_lsn;
        ret = 0;
        goto out;
      }
    }
  }
  modified = 0;
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L___0;
  } else {
    if ((int )op == 1) {
      _L___0: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
             argp->page.size);
      pagep->lsn = (*lsnp);
      modified = 1;
    } else {
      if ((int )op == 1) {
        memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->page.data,
               argp->page.size);
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: 
    if ((int )op == 0) {
      pagep->lsn = argp->lsn;
      modified = 1;
    } else {
      if ((int )op == 3) {
        pagep->lsn = argp->lsn;
        modified = 1;
      } else {
        if ((int )op == 2) {
          pagep->lsn = argp->lsn;
          modified = 1;
        }
      }
    }
  }
  if (modified) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-fIiTNiE5.i","-O2")
void __db_mutex_free(DB_ENV *dbenv___0 , REGINFO *infop , DB_MUTEX *mutexp ) ;
int __dbenv_open(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags , int mode ) ;
int __dbenv_close(DB_ENV *dbenv___0 , int rep_check ) ;
int __db_check_txn(DB *dbp___1 , DB_TXN *txn , u_int32_t assoc_lid , int read_op ) ;
int __db_master_update(DB *mdbp , DB *sdbp , DB_TXN *txn , char const   *subdb , DBTYPE type ,
                       mu_action action , char const   *newname , u_int32_t flags ) ;
int __db_refresh(DB *dbp___1 , DB_TXN *txn , u_int32_t flags , int *deferred_closep ) ;
int __db_backup_name(DB_ENV *dbenv___0 , char const   *name , DB_TXN *txn , char **backup ) ;
int __db_sync(DB *dbp___1 ) ;
int __db_debug_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   DBT const   *op , int32_t fileid , DBT const   *key , DBT const   *data ,
                   u_int32_t arg_flags ) ;
int __db_c_destroy(DBC *dbc ) ;
int __db_pgin(DB_ENV *dbenv___0 , db_pgno_t pg , void *pp , DBT *cookie ) ;
int __db_join_close(DBC *dbc ) ;
int __dbreg_setup(DB *dbp___1 , char const   *name , u_int32_t create_txnid ) ;
int __dbreg_teardown(DB *dbp___1 ) ;
int __dbreg_new_id(DB *dbp___1 , DB_TXN *txn ) ;
int __dbreg_revoke_id(DB *dbp___1 , int have_lock , int32_t force_id ) ;
int __dbreg_close_id(DB *dbp___1 , DB_TXN *txn ) ;
int __memp_set_clear_len(DB_MPOOLFILE *dbmfp , u_int32_t clear_len ) ;
int __memp_set_cachesize(DB_ENV *dbenv___0 , u_int32_t gbytes , u_int32_t bytes ,
                         int ncache ) ;
int __memp_register(DB_ENV *dbenv___0 , int ftype , int (*pgin)(DB_ENV * , db_pgno_t  ,
                                                                void * , DBT * ) ,
                    int (*pgout)(DB_ENV * , db_pgno_t  , void * , DBT * ) ) ;
int __txn_closeevent(DB_ENV *dbenv___0 , DB_TXN *txn , DB *dbp___1 ) ;
static int __db_dbenv_mpool(DB *dbp___1 , char const   *fname , u_int32_t flags ) ;
static int __db_disassociate(DB *sdbp ) ;
int __db_master_open(DB *subdbp , DB_TXN *txn , char const   *name , u_int32_t flags ,
                     int mode , DB **dbpp ) 
{ DB *dbp___1 ;
  int ret ;

  {
  (*dbpp) = (DB *)((void *)0);
  ret = db_create(& dbp___1, subdbp->dbenv, 0U);
  if (ret != 0) {
    return (ret);
  }
  dbp___1->pgsize = subdbp->pgsize;
  dbp___1->flags = dbp___1->flags | 134217728U;
  dbp___1->flags = dbp___1->flags | (subdbp->flags & 270567425U);
  flags &= 4294963199U;
  flags |= 16384U;
  ret = __db_open(dbp___1, txn, name, (char const   *)((void *)0), (enum __anonenum_DBTYPE_61 )1,
                  flags, mode, 0U);
  if (ret != 0) {
    goto err;
  }
  if (dbp___1->flags & 1U) {
    subdbp->flags = subdbp->flags | 1U;
  }
  if (subdbp->pgsize != 0U) {
    if (dbp___1->pgsize != subdbp->pgsize) {
      ret = 22;
      __db_err((DB_ENV const   *)dbp___1->dbenv, "Different pagesize specified on existent file");
      goto err;
    }
  }
  err: 
  if (ret != 0) {
    if (! (dbp___1->flags & 256U)) {
      __db_close(dbp___1, txn, 0U);
    } else {
      (*dbpp) = dbp___1;
    }
  } else {
    (*dbpp) = dbp___1;
  }
  return (ret);
}
}
int __db_master_update(DB *mdbp , DB *sdbp , DB_TXN *txn , char const   *subdb , DBTYPE type ,
                       mu_action action , char const   *newname , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBC *dbc ;
  DBC *ndbc ;
  DBT key ;
  DBT data ;
  DBT ndata ;
  PAGE *p ;
  db_pgno_t t_pgno ;
  int modify ;
  int ret ;
  int t_ret ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  u_int32_t _tmp ;
  int tmp___2 ;
  size_t tmp___3 ;
  u_int32_t _tmp___0 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int32_t _tmp___1 ;
  int tmp___6 ;

  {
  dbenv___0 = mdbp->dbenv;
  ndbc = (DBC *)((void *)0);
  dbc = ndbc;
  p = (PAGE *)((void *)0);
  memset((void *)(& key), 0, sizeof(key));
  memset((void *)(& data), 0, sizeof(data));
  if ((int )action != 2) {
    modify = 1;
  } else {
    if (flags & 1U) {
      modify = 1;
    } else {
      modify = 0;
    }
  }
  if (dbenv___0->flags & 2U) {
    if (modify) {
      tmp = 35;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ret = __db_cursor(mdbp, txn, & dbc, (unsigned int )tmp);
  if (ret != 0) {
    goto err;
  }
  key.data = (void *)subdb;
  tmp___0 = strlen(subdb);
  key.size = tmp___0;
  data.flags = data.flags | 4U;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        if (modify) {
          tmp___1 = 268435456;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  ret = __db_c_get(dbc, & key, & data, (unsigned int )(28 | tmp___1));
  switch ((int )action) {
  case 0: ;
  if (ret != 0) {
    goto err;
  }
  ret = __db_c_del(dbc, 0U);
  if (ret != 0) {
    goto err;
  }
  memcpy((void * __restrict  )(& sdbp->meta_pgno), (void const   * __restrict  )data.data,
         sizeof(db_pgno_t ));
  while (1) {
    tmp___2 = __db_isbigendian();
    if (! tmp___2) {
      (*((u_int8_t *)(& _tmp) + 0)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 0));
      (*((u_int8_t *)(& _tmp) + 1)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 1));
      (*((u_int8_t *)(& _tmp) + 2)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 2));
      (*((u_int8_t *)(& _tmp) + 3)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 3));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
    }
    break;
  }
  ret = __memp_fget(mdbp->mpf, & sdbp->meta_pgno, 0U, (void *)(& p));
  if (ret != 0) {
    goto err;
  }
  ret = __db_free(dbc, p);
  if (ret != 0) {
    p = (PAGE *)((void *)0);
    goto err;
  }
  p = (PAGE *)((void *)0);
  break;
  case 1: ;
  if (ret != 0) {
    goto err;
  }
  ret = __db_cursor(mdbp, txn, & ndbc, 0U);
  if (ret != 0) {
    goto err;
  }
  key.data = (void *)newname;
  tmp___3 = strlen(newname);
  key.size = tmp___3;
  memset((void *)(& ndata), 0, sizeof(ndata));
  ndata.flags = ndata.flags | 40U;
  ret = __db_c_get(ndbc, & key, & ndata, 28U);
  if (ret == 0) {
    ret = 17;
    __db_err((DB_ENV const   *)dbenv___0, "rename: database %s exists", newname);
    goto err;
  } else {
    if (ret != -30990) {
      goto err;
    }
  }
  ret = __db_c_put(ndbc, & key, & data, 15U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_c_del(dbc, 0U);
  if (ret != 0) {
    __db_c_del(ndbc, 0U);
    goto err;
  }
  break;
  case 2: ;
  switch (ret) {
  case 0: ;
  if (flags & 1U) {
    if (flags & 4096U) {
      ret = 17;
      goto err;
    }
  }
  memcpy((void * __restrict  )(& sdbp->meta_pgno), (void const   * __restrict  )data.data,
         sizeof(db_pgno_t ));
  while (1) {
    tmp___4 = __db_isbigendian();
    if (! tmp___4) {
      (*((u_int8_t *)(& _tmp___0) + 0)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 0));
      (*((u_int8_t *)(& _tmp___0) + 1)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 1));
      (*((u_int8_t *)(& _tmp___0) + 2)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 2));
      (*((u_int8_t *)(& _tmp___0) + 3)) = (*((u_int8_t *)(& sdbp->meta_pgno) + 3));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
      (*((u_int8_t *)(& sdbp->meta_pgno) + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
    }
    break;
  }
  goto err;
  case -30990: ;
  if (flags & 1U) {
    break;
  }
  ret = 2;
  goto err;
  default: ;
  goto err;
  }
  if ((int )type == 2) {
    tmp___5 = 8;
  } else {
    tmp___5 = 9;
  }
  ret = __db_new(dbc, (unsigned int )tmp___5, & p);
  if (ret != 0) {
    goto err;
  }
  sdbp->meta_pgno = p->pgno;
  t_pgno = p->pgno;
  while (1) {
    tmp___6 = __db_isbigendian();
    if (! tmp___6) {
      (*((u_int8_t *)(& _tmp___1) + 0)) = (*((u_int8_t *)(& t_pgno) + 0));
      (*((u_int8_t *)(& _tmp___1) + 1)) = (*((u_int8_t *)(& t_pgno) + 1));
      (*((u_int8_t *)(& _tmp___1) + 2)) = (*((u_int8_t *)(& t_pgno) + 2));
      (*((u_int8_t *)(& _tmp___1) + 3)) = (*((u_int8_t *)(& t_pgno) + 3));
      (*((u_int8_t *)(& t_pgno) + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
      (*((u_int8_t *)(& t_pgno) + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
      (*((u_int8_t *)(& t_pgno) + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
      (*((u_int8_t *)(& t_pgno) + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
    }
    break;
  }
  memset((void *)(& ndata), 0, sizeof(ndata));
  ndata.data = (void *)(& t_pgno);
  ndata.size = sizeof(db_pgno_t );
  ret = __db_c_put(dbc, & key, & ndata, 16U);
  if (ret != 0) {
    goto err;
  }
  sdbp->flags = sdbp->flags | 8U;
  break;
  }
  err: 
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    if (ret == 0) {
      t_ret = __memp_fput(mdbp->mpf, (void *)p, 2U);
      if (t_ret != 0) {
        ret = t_ret;
      }
      t_ret = __db_sync(mdbp);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    } else {
      __memp_fput(mdbp->mpf, (void *)p, 0U);
    }
  }
  if ((unsigned int )data.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, data.data);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )ndbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(ndbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_dbenv_setup(DB *dbp___1 , DB_TXN *txn , char const   *fname , u_int32_t id ,
                     u_int32_t flags ) 
{ DB *ldbp ;
  DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  u_int32_t maxid ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 8192U)) {
    if (dbenv___0->mp_gbytes == 0U) {
      if (dbenv___0->mp_bytes < dbp___1->pgsize * 16U) {
        ret = __memp_set_cachesize(dbenv___0, 0U, dbp___1->pgsize * 16U, 0);
        if (ret != 0) {
          return (ret);
        }
      }
    }
    ret = __dbenv_open(dbenv___0, (char const   *)((void *)0), 1081345U | (flags &
                                                                           64U), 0);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_dbenv_mpool(dbp___1, fname, flags);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 64U) {
    dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
    ret = __db_mutex_setup(dbenv___0, dbmp->reginfo, (void *)(& dbp___1->mutexp),
                           257U);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    ret = __dbreg_setup(dbp___1, fname, id);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        if (! (dbp___1->flags & 2097152U)) {
          if (! (dbp___1->flags & 524288U)) {
            ret = __dbreg_new_id(dbp___1, txn);
            if (ret != 0) {
              return (ret);
            }
          }
        }
      }
    }
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  maxid = 0U;
  ldbp = dbenv___0->dblist.lh_first;
  while ((unsigned int )ldbp != (unsigned int )((void *)0)) {
    if ((unsigned int )fname != (unsigned int )((void *)0)) {
      tmp = memcmp((void const   *)(ldbp->fileid), (void const   *)(dbp___1->fileid),
                   20U);
      if (tmp == 0) {
        if (ldbp->meta_pgno == dbp___1->meta_pgno) {
          break;
        }
      }
    }
    if (ldbp->adj_fileid > maxid) {
      maxid = ldbp->adj_fileid;
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )ldbp == (unsigned int )((void *)0)) {
    dbp___1->adj_fileid = maxid + 1U;
    while (1) {
      dbp___1->dblistlinks.le_next = dbenv___0->dblist.lh_first;
      if ((unsigned int )dbp___1->dblistlinks.le_next != (unsigned int )((void *)0)) {
        (dbenv___0->dblist.lh_first)->dblistlinks.le_prev = & dbp___1->dblistlinks.le_next;
      }
      dbenv___0->dblist.lh_first = dbp___1;
      dbp___1->dblistlinks.le_prev = & dbenv___0->dblist.lh_first;
      break;
    }
  } else {
    dbp___1->adj_fileid = ldbp->adj_fileid;
    while (1) {
      dbp___1->dblistlinks.le_next = ldbp->dblistlinks.le_next;
      if ((unsigned int )dbp___1->dblistlinks.le_next != (unsigned int )((void *)0)) {
        (ldbp->dblistlinks.le_next)->dblistlinks.le_prev = & dbp___1->dblistlinks.le_next;
      }
      ldbp->dblistlinks.le_next = dbp___1;
      dbp___1->dblistlinks.le_prev = & ldbp->dblistlinks.le_next;
      break;
    }
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (0);
}
}
static int __db_dbenv_mpool(DB *dbp___1 , char const   *fname , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBT pgcookie ;
  DB_MPOOLFILE *mpf ;
  DB_PGINFO pginfo ;
  u_int32_t clear_len ;
  int ftype ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  mpf = (DB_MPOOLFILE *)((void *)0);
  mpf = mpf;
  dbenv___0 = dbp___1->dbenv;
  ret = __memp_register(dbenv___0, -1, & __db_pgin, & __db_pgout);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: ;
  if (dbp___1->flags & 268437505U) {
    ftype = -1;
  } else {
    ftype = 0;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    clear_len = dbp___1->pgsize;
  } else {
    clear_len = 32U;
  }
  break;
  case 2: 
  ftype = -1;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    clear_len = dbp___1->pgsize;
  } else {
    clear_len = 32U;
  }
  break;
  case 4: ;
  if (dbp___1->flags & 268437505U) {
    ftype = -1;
  } else {
    ftype = 0;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    clear_len = dbp___1->pgsize;
  } else {
    clear_len = 0U;
  }
  break;
  case 5: ;
  if (dbp___1->flags & 1073741824U) {
    ftype = 0;
    clear_len = 32U;
    break;
  }
  default: 
  tmp = __db_unknown_type(dbenv___0, (char *)"__db_dbenv_setup", dbp___1->type);
  return (tmp);
  }
  mpf = dbp___1->mpf;
  __memp_set_clear_len(mpf, clear_len);
  __memp_set_fileid(mpf, dbp___1->fileid);
  __memp_set_ftype(mpf, ftype);
  __memp_set_lsn_offset(mpf, 0);
  pginfo.db_pagesize = dbp___1->pgsize;
  pginfo.flags = dbp___1->flags & 268437505U;
  pginfo.type = dbp___1->type;
  pgcookie.data = (void *)(& pginfo);
  pgcookie.size = sizeof(DB_PGINFO );
  __memp_set_pgcookie(mpf, & pgcookie);
  if (dbenv___0->flags & 32U) {
    tmp___0 = 4096;
  } else {
    tmp___0 = 0;
  }
  if (dbp___1->flags & 32768U) {
    tmp___1 = 512;
  } else {
    tmp___1 = 0;
  }
  ret = __memp_fopen(mpf, (MPOOLFILE *)((void *)0), fname, ((flags & 16536U) | (unsigned int )tmp___0) |
                                                           (unsigned int )tmp___1,
                     0, dbp___1->pgsize);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __db_close(DB *dbp___1 , DB_TXN *txn , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t dbpflags ;
  int db_ref ;
  int deferred_close ;
  int ret ;
  int t_ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  deferred_close = ret;
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    __db_check_txn(dbp___1, txn, 0U, 0);
  }
  dbpflags = dbp___1->flags;
  ret = __db_refresh(dbp___1, txn, flags, & deferred_close);
  if (deferred_close) {
    return (ret);
  }
  t_ret = __bam_db_close(dbp___1);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __ham_db_close(dbp___1);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __qam_db_close(dbp___1, dbpflags);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  dbenv___0->db_ref = dbenv___0->db_ref - 1;
  db_ref = dbenv___0->db_ref;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (dbenv___0->flags & 16U) {
    if (db_ref == 0) {
      t_ret = __dbenv_close(dbenv___0, 0);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  memset((void *)dbp___1, 219, sizeof((*dbp___1)));
  __os_free(dbenv___0, (void *)dbp___1);
  return (ret);
}
}
int __db_refresh(DB *dbp___1 , DB_TXN *txn , u_int32_t flags , int *deferred_closep ) 
{ DB *sdbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  DB_LOCKREQ lreq ;
  DB_MPOOL *dbmp ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  ret = 0;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbp___1->flags & 65536U)) {
    goto never_opened;
  }
  sdbp = dbp___1->s_secondaries.lh_first;
  while ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    while (1) {
      if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
        (sdbp->s_links.le_next)->s_links.le_prev = sdbp->s_links.le_prev;
      }
      (*(sdbp->s_links.le_prev)) = sdbp->s_links.le_next;
      break;
    }
    t_ret = __db_disassociate(sdbp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    sdbp = sdbp->s_links.le_next;
  }
  if (! (flags & 23U)) {
    if (! (dbp___1->flags & 2097408U)) {
      t_ret = __db_sync(dbp___1);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  while (1) {
    dbc = dbp___1->active_queue.tqh_first;
    if (! ((unsigned int )dbc != (unsigned int )((void *)0))) {
      break;
    }
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
      break;
    }
  }
  while (1) {
    dbc = dbp___1->free_queue.tqh_first;
    if (! ((unsigned int )dbc != (unsigned int )((void *)0))) {
      break;
    }
    t_ret = __db_c_destroy(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
      break;
    }
  }
  while (1) {
    dbc = dbp___1->join_queue.tqh_first;
    if (! ((unsigned int )dbc != (unsigned int )((void *)0))) {
      break;
    }
    t_ret = __db_join_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
      break;
    }
  }
  if (! (flags & 23U)) {
    if (! (dbp___1->flags & 2097408U)) {
      t_ret = __memp_fsync(dbp___1->mpf);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  if ((unsigned int )(dbp___1->dbenv)->lg_handle != (unsigned int )((void *)0)) {
    if (dbp___1->flags & 2097152U) {
      t_ret = __dbreg_revoke_id(dbp___1, 0, -1);
    } else {
      t_ret = __dbreg_close_id(dbp___1, txn);
      if (t_ret != 0) {
        if ((unsigned int )txn != (unsigned int )((void *)0)) {
          ret = __txn_closeevent(dbenv___0, txn, dbp___1);
          if (ret != 0) {
            tmp = __db_panic(dbenv___0, ret);
            return (tmp);
          }
          if ((unsigned int )deferred_closep != (unsigned int )((void *)0)) {
            (*deferred_closep) = 1;
          }
          return (t_ret);
        }
      }
    }
    if (ret == 0) {
      ret = t_ret;
    }
    t_ret = __dbreg_teardown(dbp___1);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbp___1->saved_open_fhp != (unsigned int )((void *)0)) {
    t_ret = __os_closehandle(dbenv___0, dbp___1->saved_open_fhp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  never_opened: 
  if (dbp___1->lid != 0U) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      __txn_remlock(dbenv___0, txn, & dbp___1->handle_lock, dbp___1->lid);
    }
    lreq.op = (enum __anonenum_db_lockop_t_51 )5;
    lreq.obj = (DBT *)((void *)0);
    t_ret = __lock_vec(dbenv___0, dbp___1->lid, 0U, & lreq, 1, (DB_LOCKREQ **)((void *)0));
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    t_ret = __lock_id_free(dbenv___0, dbp___1->lid);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    dbp___1->lid = 0U;
    dbp___1->handle_lock.off = 0U;
  }
  if (dbp___1->flags & 8192U) {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      t_ret = __lock_id_free(dbenv___0, (*((u_int32_t *)(dbp___1->fileid))));
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  dbp___1->type = (enum __anonenum_DBTYPE_61 )5;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
    __db_mutex_free(dbenv___0, dbmp->reginfo, dbp___1->mutexp);
    dbp___1->mutexp = (DB_MUTEX *)((void *)0);
  }
  if ((unsigned int )dbp___1->fname != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)dbp___1->fname);
    dbp___1->fname = (char *)((void *)0);
  }
  if ((unsigned int )dbp___1->dname != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)dbp___1->dname);
    dbp___1->dname = (char *)((void *)0);
  }
  if ((unsigned int )dbp___1->my_rskey.data != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, dbp___1->my_rskey.data);
  }
  if ((unsigned int )dbp___1->my_rkey.data != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, dbp___1->my_rkey.data);
  }
  if ((unsigned int )dbp___1->my_rdata.data != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, dbp___1->my_rdata.data);
  }
  memset((void *)(& dbp___1->my_rskey), 0, sizeof(DBT ));
  memset((void *)(& dbp___1->my_rkey), 0, sizeof(DBT ));
  memset((void *)(& dbp___1->my_rdata), 0, sizeof(DBT ));
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if ((unsigned int )dbp___1->dblistlinks.le_prev != (unsigned int )((void *)0)) {
    while (1) {
      if ((unsigned int )dbp___1->dblistlinks.le_next != (unsigned int )((void *)0)) {
        (dbp___1->dblistlinks.le_next)->dblistlinks.le_prev = dbp___1->dblistlinks.le_prev;
      }
      (*(dbp___1->dblistlinks.le_prev)) = dbp___1->dblistlinks.le_next;
      break;
    }
    dbp___1->dblistlinks.le_prev = (struct __db **)((void *)0);
  }
  if ((unsigned int )dbp___1->mpf != (unsigned int )((void *)0)) {
    if (dbp___1->flags & 256U) {
      tmp___0 = 4;
    } else {
      tmp___0 = 0;
    }
    t_ret = __memp_fclose(dbp___1->mpf, (unsigned int )tmp___0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    dbp___1->mpf = (DB_MPOOLFILE *)((void *)0);
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  memset((void *)(dbp___1->fileid), 0, sizeof(dbp___1->fileid));
  dbp___1->adj_fileid = 0U;
  dbp___1->meta_pgno = 0U;
  dbp___1->cur_lid = 0U;
  dbp___1->associate_lid = 0U;
  dbp___1->cl_id = 0L;
  dbp___1->open_flags = 0U;
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    dbp___1->handle_lock.off = 0U;
  }
  dbp___1->flags = dbp___1->orig_flags;
  return (ret);
}
}
int __db_log_page(DB *dbp___1 , DB_TXN *txn , DB_LSN *lsn , db_pgno_t pgno , PAGE *page ) 
{ DBT page_dbt ;
  DB_LSN new_lsn ;
  int ret ;

  {
  if (! ((unsigned int )(dbp___1->dbenv)->lg_handle != (unsigned int )((void *)0))) {
    return (0);
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      return (0);
    }
  }
  memset((void *)(& page_dbt), 0, sizeof(page_dbt));
  page_dbt.size = dbp___1->pgsize;
  page_dbt.data = (void *)page;
  ret = __crdel_metasub_log(dbp___1, txn, & new_lsn, 0U, pgno, (DBT const   *)(& page_dbt),
                            lsn);
  if (ret == 0) {
    page->lsn = new_lsn;
  }
  return (ret);
}
}
int __db_backup_name(DB_ENV *dbenv___0 , char const   *name , DB_TXN *txn , char **backup ) 
{ DB_LSN lsn ;
  size_t len ;
  int plen ;
  int ret ;
  int use_lsn ;
  char *p ;
  char *retp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (! (dbenv___0->flags & 8388608U)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      if (txn->last_lsn.file == 0U) {
        ret = __db_debug_log(dbenv___0, txn, & lsn, 0U, (DBT const   *)((void *)0),
                             0, (DBT const   *)((void *)0), (DBT const   *)((void *)0),
                             0U);
        if (ret != 0) {
          return (ret);
        }
      } else {
        lsn = txn->last_lsn;
      }
      use_lsn = 1;
    } else {
      use_lsn = 0;
    }
  } else {
    use_lsn = 0;
  }
  tmp = strlen(name);
  tmp___0 = strlen("__db.");
  len = (tmp + tmp___0) + 17U;
  ret = __os_malloc(dbenv___0, len, (void *)(& retp));
  if (ret != 0) {
    return (ret);
  }
  p = __db_rpath(name);
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    if (use_lsn) {
      snprintf((char * __restrict  )retp, len, (char const   * __restrict  )"%s%x.%x",
               "__db.", lsn.file, lsn.offset);
    } else {
      snprintf((char * __restrict  )retp, len, (char const   * __restrict  )"%s%s",
               "__db.", name);
    }
  } else {
    plen = (p - (char *)name) + 1;
    p ++;
    if (use_lsn) {
      snprintf((char * __restrict  )retp, len, (char const   * __restrict  )"%.*s%x.%x",
               plen, name, lsn.file, lsn.offset);
    } else {
      snprintf((char * __restrict  )retp, len, (char const   * __restrict  )"%.*s%s%s",
               plen, name, "__db.", p);
    }
  }
  (*backup) = retp;
  return (0);
}
}
DB *__dblist_get(DB_ENV *dbenv___0 , u_int32_t adjid ) 
{ DB *dbp___1 ;

  {
  dbp___1 = dbenv___0->dblist.lh_first;
  while (1) {
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      if (! (dbp___1->adj_fileid != adjid)) {
        break;
      }
    } else {
      break;
    }
    dbp___1 = dbp___1->dblistlinks.le_next;
  }
  return (dbp___1);
}
}
static int __db_disassociate(DB *sdbp ) 
{ DBC *dbc ;
  int ret ;
  int t_ret ;

  {
  ret = 0;
  sdbp->s_callback = (int (*)(DB * , DBT const   * , DBT const   * , DBT * ))((void *)0);
  sdbp->s_primary = (DB *)((void *)0);
  sdbp->get = sdbp->stored_get;
  sdbp->close = sdbp->stored_close;
  if (sdbp->s_refcnt != 1U) {
    __db_err((DB_ENV const   *)sdbp->dbenv, "Closing a primary DB while a secondary DB has active cursors is unsafe");
    ret = 22;
  } else {
    if ((unsigned int )sdbp->active_queue.tqh_first != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)sdbp->dbenv, "Closing a primary DB while a secondary DB has active cursors is unsafe");
      ret = 22;
    } else {
      if ((unsigned int )sdbp->join_queue.tqh_first != (unsigned int )((void *)0)) {
        __db_err((DB_ENV const   *)sdbp->dbenv, "Closing a primary DB while a secondary DB has active cursors is unsafe");
        ret = 22;
      }
    }
  }
  sdbp->s_refcnt = 0U;
  while (1) {
    dbc = sdbp->free_queue.tqh_first;
    if (! ((unsigned int )dbc != (unsigned int )((void *)0))) {
      break;
    }
    t_ret = __db_c_destroy(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  sdbp->flags = sdbp->flags & 4261412863U;
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-di6XorPV.i","-O2")
int __db_del(DB *dbp___1 , DB_TXN *txn , DBT *key , u_int32_t flags ) ;
int __db_associate(DB *dbp___1 , DB_TXN *txn , DB *sdbp , int (*callback)(DB * , DBT const   * ,
                                                                          DBT const   * ,
                                                                          DBT * ) ,
                   u_int32_t flags ) ;
int __db_c_secondary_get_pp(DBC *dbc , DBT *skey , DBT *data , u_int32_t flags ) ;
DB *__db_s_first(DB *pdbp ) ;
int __db_s_next(DB **sdbpp ) ;
int __db_s_done(DB *sdbp ) ;
int __db_pget(DB *dbp___1 , DB_TXN *txn , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) ;
static int __db_append_primary(DBC *dbc , DBT *key , DBT *data ) ;
static int __db_secondary_get(DB *sdbp , DB_TXN *txn , DBT *skey , DBT *data , u_int32_t flags ) ;
static int __db_secondary_close(DB *sdbp , u_int32_t flags ) ;
int __db_cursor_int(DB *dbp___1 , DB_TXN *txn , DBTYPE dbtype , db_pgno_t root , int is_opd ,
                    u_int32_t lockerid , DBC **dbcp ) 
{ DBC *dbc ;
  DBC *adbc ;
  DBC_INTERNAL *cp ;
  DB_ENV *dbenv___0 ;
  int allocated ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  allocated = 0;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  dbc = dbp___1->free_queue.tqh_first;
  while ((unsigned int )dbc != (unsigned int )((void *)0)) {
    if ((int )dbtype == (int )dbc->dbtype) {
      while (1) {
        if ((unsigned int )dbc->links.tqe_next != (unsigned int )((void *)0)) {
          (dbc->links.tqe_next)->links.tqe_prev = dbc->links.tqe_prev;
        } else {
          dbp___1->free_queue.tqh_last = dbc->links.tqe_prev;
        }
        (*(dbc->links.tqe_prev)) = dbc->links.tqe_next;
        break;
      }
      dbc->flags = dbc->flags & 2048U;
      break;
    }
    dbc = dbc->links.tqe_next;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  if ((unsigned int )dbc == (unsigned int )((void *)0)) {
    ret = __os_calloc(dbenv___0, 1U, sizeof(DBC ), (void *)(& dbc));
    if (ret != 0) {
      return (ret);
    }
    allocated = 1;
    dbc->flags = 0U;
    dbc->dbp = dbp___1;
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      if (! ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0))) {
        adbc = dbp___1->active_queue.tqh_first;
        if ((unsigned int )adbc != (unsigned int )((void *)0)) {
          dbc->lid = adbc->lid;
        } else {
          goto _L;
        }
      } else {
        _L: 
        ret = __lock_id(dbenv___0, & dbc->lid);
        if (ret != 0) {
          goto err;
        }
        dbc->flags = dbc->flags | 2048U;
      }
      if (dbenv___0->flags & 2U) {
        if (dbp___1->flags & 33554432U) {
          memcpy((void * __restrict  )(dbc->lock.fileid), (void const   * __restrict  )((dbp___1->s_primary)->fileid),
                 20U);
        } else {
          memcpy((void * __restrict  )(dbc->lock.fileid), (void const   * __restrict  )(dbp___1->fileid),
                 20U);
        }
      } else {
        memcpy((void * __restrict  )(dbc->lock.fileid), (void const   * __restrict  )(dbp___1->fileid),
               20U);
      }
      if (dbenv___0->flags & 2U) {
        if (dbenv___0->flags & 4U) {
          dbc->lock_dbt.size = sizeof(u_int32_t );
          dbc->lock_dbt.data = (void *)(& dbc->lock.pgno);
          dbc->lock.pgno = 0U;
        } else {
          dbc->lock_dbt.size = 20U;
          dbc->lock_dbt.data = (void *)(dbc->lock.fileid);
        }
      } else {
        dbc->lock.type = 3U;
        dbc->lock_dbt.size = sizeof(dbc->lock);
        dbc->lock_dbt.data = (void *)(& dbc->lock);
      }
    }
    switch ((int )dbtype) {
    case 1: ;
    case 3: 
    ret = __bam_c_init(dbc, dbtype);
    if (ret != 0) {
      goto err;
    }
    break;
    case 2: 
    ret = __ham_c_init(dbc);
    if (ret != 0) {
      goto err;
    }
    break;
    case 4: 
    ret = __qam_c_init(dbc);
    if (ret != 0) {
      goto err;
    }
    break;
    case 5: ;
    default: 
    ret = __db_unknown_type(dbenv___0, (char *)"DB->cursor", dbtype);
    goto err;
    }
    cp = dbc->internal;
  }
  dbc->dbtype = dbtype;
  while (1) {
    dbc->rskey = & dbc->my_rskey;
    dbc->rkey = & dbc->my_rkey;
    dbc->rdata = & dbc->my_rdata;
    break;
  }
  dbc->txn = txn;
  if ((unsigned int )dbc->txn == (unsigned int )((void *)0)) {
    if (lockerid != 0U) {
      dbc->locker = lockerid;
    } else {
      dbc->locker = dbc->lid;
    }
  } else {
    dbc->locker = txn->txnid;
    txn->cursors = txn->cursors + 1U;
  }
  if (dbp___1->flags & 33554432U) {
    dbc->c_get = & __db_c_secondary_get_pp;
  }
  if (is_opd) {
    dbc->flags = dbc->flags | 8U;
  }
  if (dbp___1->flags & 2097152U) {
    dbc->flags = dbc->flags | 16U;
  }
  if (dbp___1->flags & 4U) {
    dbc->flags = dbc->flags | 2U;
  }
  cp = dbc->internal;
  cp->opd = (DBC *)((void *)0);
  cp->indx = (unsigned short)0;
  cp->page = (void *)0;
  cp->pgno = 0U;
  cp->root = root;
  switch ((int )dbtype) {
  case 1: ;
  case 3: 
  ret = __bam_c_refresh(dbc);
  if (ret != 0) {
    goto err;
  }
  break;
  case 2: ;
  case 4: ;
  break;
  case 5: ;
  default: 
  ret = __db_unknown_type(dbenv___0, (char *)"DB->cursor", dbp___1->type);
  goto err;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  while (1) {
    dbc->links.tqe_next = (DBC *)((void *)0);
    dbc->links.tqe_prev = dbp___1->active_queue.tqh_last;
    (*(dbp___1->active_queue.tqh_last)) = dbc;
    dbp___1->active_queue.tqh_last = & dbc->links.tqe_next;
    break;
  }
  dbc->flags = dbc->flags | 1U;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  (*dbcp) = dbc;
  return (0);
  err: 
  if (allocated) {
    __os_free(dbenv___0, (void *)dbc);
  }
  return (ret);
}
}
int __db_put(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) 
{ DBC *dbc ;
  DBT tdata ;
  DB_ENV *dbenv___0 ;
  int ret ;
  int t_ret ;
  int tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_cursor(dbp___1, txn, & dbc, 36U);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    dbc->rskey = & dbp___1->my_rskey;
    dbc->rkey = & dbp___1->my_rkey;
    dbc->rdata = & dbp___1->my_rdata;
    break;
  }
  dbc->flags = dbc->flags | 64U;
  switch ((int )flags) {
  case 2: 
  tdata = (*data);
  switch ((int )dbp___1->type) {
  case 4: 
  ret = __qam_append(dbc, key, & tdata);
  if (ret != 0) {
    goto err;
  }
  break;
  case 3: 
  ret = __ram_append(dbc, key, & tdata);
  if (ret != 0) {
    goto err;
  }
  break;
  case 1: ;
  case 2: ;
  case 5: ;
  default: 
  ret = __db_ferr((DB_ENV const   *)dbenv___0, "DB->put", 0);
  goto err;
  }
  if ((unsigned int )dbp___1->s_secondaries.lh_first != (unsigned int )((void *)0)) {
    ret = __db_append_primary(dbc, key, & tdata);
  }
  if (tdata.flags & 1U) {
    __os_ufree(dbp___1->dbenv, tdata.data);
    tdata.flags = tdata.flags & 4294967294U;
  }
  goto err;
  case 22: 
  flags = 0U;
  memset((void *)(& tdata), 0, sizeof(tdata));
  tdata.flags = tdata.flags | 40U;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        tmp = 268435456;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ret = __db_c_get(dbc, key, & tdata, (unsigned int )(28 | tmp));
  if (ret == 0) {
    ret = -30996;
  } else {
    if (ret == -30990) {
      ret = 0;
    } else {
      if (ret == -30997) {
        ret = 0;
      }
    }
  }
  break;
  default: ;
  break;
  }
  if (ret == 0) {
    if (flags == 0U) {
      tmp___0 = 16U;
    } else {
      tmp___0 = flags;
    }
    ret = __db_c_put(dbc, key, data, tmp___0);
  }
  err: 
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_del(DB *dbp___1 , DB_TXN *txn , DBT *key , u_int32_t flags ) 
{ DBC *dbc ;
  DBT data ;
  DBT lkey ;
  u_int32_t f_init ;
  u_int32_t f_next ;
  int ret ;
  int t_ret ;

  {
  ret = __db_cursor(dbp___1, txn, & dbc, 36U);
  if (ret != 0) {
    goto done;
  }
  flags = 0U;
  flags = flags;
  memset((void *)(& lkey), 0, sizeof(lkey));
  lkey.flags = lkey.flags | 40U;
  memset((void *)(& data), 0, sizeof(data));
  data.flags = data.flags | 40U;
  f_init = 28U;
  f_next = 19U;
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        f_init |= 268435456U;
        f_next |= 268435456U;
      }
    }
  }
  ret = __db_c_get(dbc, key, & data, f_init);
  if (ret != 0) {
    goto done;
  }
  if ((int )dbp___1->type == 2) {
    if ((unsigned int )dbp___1->s_secondaries.lh_first == (unsigned int )((void *)0)) {
      if (! (dbp___1->flags & 33554432U)) {
        if ((unsigned int )(dbc->internal)->opd == (unsigned int )((void *)0)) {
          ret = __ham_quick_delete(dbc);
          goto done;
        }
      }
    }
  }
  while (1) {
    ret = __db_c_del(dbc, 0U);
    if (ret != 0) {
      break;
    }
    ret = __db_c_get(dbc, & lkey, & data, f_next);
    if (ret != 0) {
      if (ret == -30990) {
        ret = 0;
      }
      break;
    }
  }
  done: 
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_sync(DB *dbp___1 ) 
{ int ret ;
  int t_ret ;

  {
  ret = 0;
  if (dbp___1->flags & 524288U) {
    return (0);
  }
  if ((int )dbp___1->type == 3) {
    ret = __ram_writeback(dbp___1);
  }
  if (dbp___1->flags & 8192U) {
    return (ret);
  }
  if ((int )dbp___1->type == 4) {
    ret = __qam_sync(dbp___1);
  } else {
    t_ret = __memp_fsync(dbp___1->mpf);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_associate(DB *dbp___1 , DB_TXN *txn , DB *sdbp , int (*callback)(DB * , DBT const   * ,
                                                                          DBT const   * ,
                                                                          DBT * ) ,
                   u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBC *pdbc ;
  DBC *sdbc ;
  DBT skey ;
  DBT key ;
  DBT data ;
  int build ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  sdbc = (DBC *)((void *)0);
  pdbc = sdbc;
  ret = 0;
  sdbp->s_callback = callback;
  sdbp->s_primary = dbp___1;
  sdbp->stored_get = sdbp->get;
  sdbp->get = & __db_secondary_get;
  sdbp->stored_close = sdbp->close;
  sdbp->close = & __db_secondary_close;
  sdbp->flags = sdbp->flags | 33554432U;
  build = 0;
  if (flags & 1U) {
    ret = __db_cursor(sdbp, txn, & sdbc, 0U);
    if (ret != 0) {
      goto err;
    }
    memset((void *)(& key), 0, sizeof(DBT ));
    memset((void *)(& data), 0, sizeof(DBT ));
    key.flags = key.flags | 40U;
    data.flags = data.flags | 40U;
    if (! (sdbc->flags & 8U)) {
      if (! (((sdbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((sdbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          tmp = 268435456;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    ret = __db_c_get(sdbc, & key, & data, (unsigned int )(tmp | 9));
    if (ret == -30990) {
      build = 1;
      ret = 0;
    }
    t_ret = __db_c_close(sdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    sdbc = (DBC *)((void *)0);
    if (ret != 0) {
      goto err;
    }
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  sdbp->s_refcnt = 1U;
  while (1) {
    sdbp->s_links.le_next = dbp___1->s_secondaries.lh_first;
    if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
      (dbp___1->s_secondaries.lh_first)->s_links.le_prev = & sdbp->s_links.le_next;
    }
    dbp___1->s_secondaries.lh_first = sdbp;
    sdbp->s_links.le_prev = & dbp___1->s_secondaries.lh_first;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  if (build) {
    if ((sdbp->dbenv)->flags & 2U) {
      tmp___0 = 35;
    } else {
      tmp___0 = 0;
    }
    ret = __db_cursor(sdbp, txn, & sdbc, (unsigned int )tmp___0);
    if (ret != 0) {
      goto err;
    }
    ret = __db_cursor_int(dbp___1, txn, dbp___1->type, 0U, 0, sdbc->locker, & pdbc);
    if (ret != 0) {
      goto err;
    }
    dbp___1->associate_lid = sdbc->locker;
    memset((void *)(& key), 0, sizeof(DBT ));
    memset((void *)(& data), 0, sizeof(DBT ));
    while (1) {
      ret = __db_c_get(pdbc, & key, & data, 18U);
      if (! (ret == 0)) {
        break;
      }
      memset((void *)(& skey), 0, sizeof(DBT ));
      ret = ((*callback))(sdbp, (DBT const   *)(& key), (DBT const   *)(& data), & skey);
      if (ret != 0) {
        if (ret == -30999) {
          continue;
        }
        goto err;
      }
      ret = __db_c_put(sdbc, & skey, & key, 34U);
      if (ret != 0) {
        if (skey.flags & 1U) {
          __os_ufree(sdbp->dbenv, skey.data);
          skey.flags = skey.flags & 4294967294U;
        }
        goto err;
      }
      if (skey.flags & 1U) {
        __os_ufree(sdbp->dbenv, skey.data);
        skey.flags = skey.flags & 4294967294U;
      }
    }
    if (ret == -30990) {
      ret = 0;
    }
  }
  err: 
  if ((unsigned int )sdbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(sdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )pdbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(pdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  dbp___1->associate_lid = 0U;
  return (ret);
}
}
static int __db_secondary_get(DB *sdbp , DB_TXN *txn , DBT *skey , DBT *data , u_int32_t flags ) 
{ int tmp ;

  {
  tmp = __db_pget(sdbp, txn, skey, (DBT *)((void *)0), data, flags);
  return (tmp);
}
}
static int __db_secondary_close(DB *sdbp , u_int32_t flags ) 
{ DB *primary ;
  int doclose ;
  int tmp___0 ;

  {
  doclose = 0;
  primary = sdbp->s_primary;
  if ((unsigned int )primary->mutexp != (unsigned int )((void *)0)) {
    if (! ((primary->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(primary->dbenv, primary->mutexp);
    }
  }
  sdbp->s_refcnt = sdbp->s_refcnt - 1U;
  if (sdbp->s_refcnt == 0U) {
    while (1) {
      if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
        (sdbp->s_links.le_next)->s_links.le_prev = sdbp->s_links.le_prev;
      }
      (*(sdbp->s_links.le_prev)) = sdbp->s_links.le_next;
      break;
    }
    doclose = 1;
  }
  if ((unsigned int )primary->mutexp != (unsigned int )((void *)0)) {
    if (! ((primary->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(primary->dbenv, primary->mutexp);
    }
  }
  if (doclose) {
    tmp___0 = __db_close(sdbp, (DB_TXN *)((void *)0), flags);
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int __db_append_primary(DBC *dbc , DBT *key , DBT *data ) 
{ DB *dbp___1 ;
  DB *sdbp ;
  DBC *sdbc ;
  DBC *pdbc ;
  DBT oldpkey ;
  DBT pkey ;
  DBT pdata ;
  DBT skey ;
  int cmp ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  sdbp = (DB *)((void *)0);
  ret = 0;
  pdbc = (DBC *)((void *)0);
  if (data->flags & 8U) {
    goto _L;
  } else {
    if (key->flags & 8U) {
      _L: 
      ret = __db_c_idup(dbc, & pdbc, 24U);
      if (ret != 0) {
        return (ret);
      }
      memset((void *)(& pkey), 0, sizeof(DBT ));
      memset((void *)(& pdata), 0, sizeof(DBT ));
      ret = __db_c_get(pdbc, & pkey, & pdata, 7U);
      if (ret != 0) {
        goto err;
      }
      key = & pkey;
      data = & pdata;
    }
  }
  sdbp = __db_s_first(dbp___1);
  while (1) {
    if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& skey), 0, sizeof(DBT ));
    ret = ((*(sdbp->s_callback)))(sdbp, (DBT const   *)key, (DBT const   *)data, & skey);
    if (ret != 0) {
      if (ret == -30999) {
        goto __Cont;
      } else {
        goto err;
      }
    }
    ret = __db_cursor_int(sdbp, dbc->txn, sdbp->type, 0U, 0, dbc->locker, & sdbc);
    if (ret != 0) {
      if (skey.flags & 1U) {
        __os_ufree(sdbp->dbenv, skey.data);
        skey.flags = skey.flags & 4294967294U;
      }
      goto err;
    }
    if ((sdbp->dbenv)->flags & 2U) {
      sdbc->flags = sdbc->flags | 256U;
    }
    if (! (sdbp->flags & 512U)) {
      memset((void *)(& oldpkey), 0, sizeof(DBT ));
      oldpkey.flags = oldpkey.flags | 4U;
      if (! (dbc->flags & 8U)) {
        if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
            tmp = 268435456;
          } else {
            tmp = 0;
          }
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      ret = __db_c_get(sdbc, & skey, & oldpkey, (unsigned int )(28 | tmp));
      if (ret == 0) {
        cmp = __bam_defcmp(sdbp, (DBT const   *)(& oldpkey), (DBT const   *)key);
        __os_ufree(sdbp->dbenv, oldpkey.data);
        if (cmp != 0) {
          __db_err((DB_ENV const   *)sdbp->dbenv, "%s%s", "Append results in a non-unique secondary key in",
                   " an index not configured to support duplicates");
          ret = 22;
          goto err1;
        }
      } else {
        if (ret != -30990) {
          if (ret != -30997) {
            goto err1;
          }
        }
      }
    }
    ret = __db_c_put(sdbc, & skey, key, 34U);
    err1: 
    if (skey.flags & 1U) {
      __os_ufree(sdbp->dbenv, skey.data);
      skey.flags = skey.flags & 4294967294U;
    }
    t_ret = __db_c_close(sdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret != 0) {
      goto err;
    }
    __Cont: 
    ret = __db_s_next(& sdbp);
  }
  err: 
  if ((unsigned int )pdbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(pdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    t_ret = __db_s_done(sdbp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-PYXYNm2R.i","-O2")
int __db_addrem_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , db_pgno_t pgno , u_int32_t indx , u_int32_t nbytes ,
                    DBT const   *hdr , DBT const   *dbt , DB_LSN *pagelsn ) ;
int __db_addrem_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __db_addrem_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __db_addrem_read(DB_ENV *dbenv___0 , void *recbuf , __db_addrem_args **argpp ) ;
int __db_big_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                 u_int32_t opcode , db_pgno_t pgno , db_pgno_t prev_pgno , db_pgno_t next_pgno ,
                 DBT const   *dbt , DB_LSN *pagelsn , DB_LSN *prevlsn , DB_LSN *nextlsn ) ;
int __db_big_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                      void *summary ) ;
int __db_big_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                   void *notused3 ) ;
int __db_big_read(DB_ENV *dbenv___0 , void *recbuf , __db_big_args **argpp ) ;
int __db_ovref_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t pgno , int32_t adjust , DB_LSN *lsn ) ;
int __db_ovref_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) ;
int __db_ovref_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) ;
int __db_ovref_read(DB_ENV *dbenv___0 , void *recbuf , __db_ovref_args **argpp ) ;
int __db_relink_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , db_pgno_t pgno , DB_LSN *lsn , db_pgno_t prev ,
                    DB_LSN *lsn_prev , db_pgno_t next , DB_LSN *lsn_next ) ;
int __db_relink_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __db_relink_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __db_relink_read(DB_ENV *dbenv___0 , void *recbuf , __db_relink_args **argpp ) ;
int __db_debug_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) ;
int __db_debug_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) ;
int __db_debug_read(DB_ENV *dbenv___0 , void *recbuf , __db_debug_args **argpp ) ;
int __db_noop_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  db_pgno_t pgno , DB_LSN *prevlsn ) ;
int __db_noop_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) ;
int __db_noop_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) ;
int __db_noop_read(DB_ENV *dbenv___0 , void *recbuf , __db_noop_args **argpp ) ;
int __db_pg_alloc_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      DB_LSN *meta_lsn , db_pgno_t meta_pgno , DB_LSN *page_lsn ,
                      db_pgno_t pgno , u_int32_t ptype , db_pgno_t next ) ;
int __db_pg_alloc_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) ;
int __db_pg_alloc_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) ;
int __db_pg_alloc_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_alloc_args **argpp ) ;
int __db_pg_free_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_pgno_t pgno , DB_LSN *meta_lsn , db_pgno_t meta_pgno , DBT const   *header ,
                     db_pgno_t next ) ;
int __db_pg_free_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __db_pg_free_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __db_pg_free_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_free_args **argpp ) ;
int __db_cksum_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ) ;
int __db_cksum_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) ;
int __db_cksum_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) ;
int __db_cksum_read(DB_ENV *dbenv___0 , void *recbuf , __db_cksum_args **argpp ) ;
int __db_pg_freedata_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                         db_pgno_t pgno , DB_LSN *meta_lsn , db_pgno_t meta_pgno ,
                         DBT const   *header , db_pgno_t next , DBT const   *data ) ;
int __db_pg_freedata_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                              void *summary ) ;
int __db_pg_freedata_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                           void *notused3 ) ;
int __db_pg_freedata_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_freedata_args **argpp ) ;
int __db_pg_prepare_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        db_pgno_t pgno ) ;
int __db_pg_prepare_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) ;
int __db_pg_prepare_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) ;
int __db_pg_prepare_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_prepare_args **argpp ) ;
int __db_pg_new_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    db_pgno_t pgno , DB_LSN *meta_lsn , db_pgno_t meta_pgno , DBT const   *header ,
                    db_pgno_t next ) ;
int __db_pg_new_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __db_pg_new_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __db_pg_new_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_new_args **argpp ) ;
int __db_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                       db_recops  , void * ) , size_t *dtabsizep ) ;
int __db_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __db_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                         db_recops  , void * ) , size_t *dtabsizep ) ;
int __db_addrem_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __db_big_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                     void *info ) ;
int __db_ovref_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) ;
int __db_relink_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __db_debug_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) ;
int __db_noop_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) ;
int __db_pg_alloc_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) ;
int __db_pg_free_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __db_pg_new_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __db_pg_freedata_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                             void *info ) ;
int __db_cksum_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) ;
int __db_pg_prepare_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) ;
int __db_addrem_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , db_pgno_t pgno , u_int32_t indx , u_int32_t nbytes ,
                    DBT const   *hdr , DBT const   *dbt , DB_LSN *pagelsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 41U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )hdr == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = hdr->size;
  }
  if ((unsigned int )dbt == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = dbt->size;
  }
  logrec.size = (((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                         sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   tmp) + sizeof(u_int32_t )) + tmp___0) + sizeof((*pagelsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = indx;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = nbytes;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )hdr == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& hdr->size), sizeof(hdr->size));
    bp += sizeof(hdr->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )hdr->data, hdr->size);
    bp += hdr->size;
  }
  if ((unsigned int )dbt == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& dbt->size), sizeof(dbt->size));
    bp += sizeof(dbt->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )dbt->data, dbt->size);
    bp += dbt->size;
  }
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_addrem_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_addrem_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __db_addrem_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_addrem_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_addrem%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tindx: %lu\n", (unsigned long )argp->indx);
  printf((char const   * __restrict  )"\tnbytes: %lu\n", (unsigned long )argp->nbytes);
  printf((char const   * __restrict  )"\thdr: ");
  i = 0U;
  while (i < argp->hdr.size) {
    ch = (int )(*((u_int8_t *)argp->hdr.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tdbt: ");
  i = 0U;
  while (i < argp->dbt.size) {
    ch = (int )(*((u_int8_t *)argp->dbt.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_addrem_read(DB_ENV *dbenv___0 , void *recbuf , __db_addrem_args **argpp ) 
{ __db_addrem_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_addrem_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->indx = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->nbytes = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->hdr), 0, sizeof(argp->hdr));
  memcpy((void * __restrict  )(& argp->hdr.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->hdr.data = (void *)bp;
  bp += argp->hdr.size;
  memset((void *)(& argp->dbt), 0, sizeof(argp->dbt));
  memcpy((void * __restrict  )(& argp->dbt.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->dbt.data = (void *)bp;
  bp += argp->dbt.size;
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  (*argpp) = argp;
  return (0);
}
}
int __db_big_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                 u_int32_t opcode , db_pgno_t pgno , db_pgno_t prev_pgno , db_pgno_t next_pgno ,
                 DBT const   *dbt , DB_LSN *pagelsn , DB_LSN *prevlsn , DB_LSN *nextlsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 43U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )dbt == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = dbt->size;
  }
  logrec.size = (((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                         sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                   tmp) + sizeof((*pagelsn))) + sizeof((*prevlsn))) + sizeof((*nextlsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = prev_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = next_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )dbt == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& dbt->size), sizeof(dbt->size));
    bp += sizeof(dbt->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )dbt->data, dbt->size);
    bp += dbt->size;
  }
  if ((unsigned int )pagelsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )pagelsn, sizeof((*pagelsn)));
  } else {
    memset((void *)bp, 0, sizeof((*pagelsn)));
  }
  bp += sizeof((*pagelsn));
  if ((unsigned int )prevlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )prevlsn, sizeof((*prevlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*prevlsn)));
  }
  bp += sizeof((*prevlsn));
  if ((unsigned int )nextlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )nextlsn, sizeof((*nextlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*nextlsn)));
  }
  bp += sizeof((*nextlsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_big_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                      void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_big_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                   void *notused3 ) 
{ __db_big_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_big_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_big%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tprev_pgno: %lu\n", (unsigned long )argp->prev_pgno);
  printf((char const   * __restrict  )"\tnext_pgno: %lu\n", (unsigned long )argp->next_pgno);
  printf((char const   * __restrict  )"\tdbt: ");
  i = 0U;
  while (i < argp->dbt.size) {
    ch = (int )(*((u_int8_t *)argp->dbt.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tpagelsn: [%lu][%lu]\n", (unsigned long )argp->pagelsn.file,
         (unsigned long )argp->pagelsn.offset);
  printf((char const   * __restrict  )"\tprevlsn: [%lu][%lu]\n", (unsigned long )argp->prevlsn.file,
         (unsigned long )argp->prevlsn.offset);
  printf((char const   * __restrict  )"\tnextlsn: [%lu][%lu]\n", (unsigned long )argp->nextlsn.file,
         (unsigned long )argp->nextlsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_big_read(DB_ENV *dbenv___0 , void *recbuf , __db_big_args **argpp ) 
{ __db_big_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_big_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->prev_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->dbt), 0, sizeof(argp->dbt));
  memcpy((void * __restrict  )(& argp->dbt.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->dbt.data = (void *)bp;
  bp += argp->dbt.size;
  memcpy((void * __restrict  )(& argp->pagelsn), (void const   * __restrict  )bp,
         sizeof(argp->pagelsn));
  bp += sizeof(argp->pagelsn);
  memcpy((void * __restrict  )(& argp->prevlsn), (void const   * __restrict  )bp,
         sizeof(argp->prevlsn));
  bp += sizeof(argp->prevlsn);
  memcpy((void * __restrict  )(& argp->nextlsn), (void const   * __restrict  )bp,
         sizeof(argp->nextlsn));
  bp += sizeof(argp->nextlsn);
  (*argpp) = argp;
  return (0);
}
}
int __db_ovref_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   db_pgno_t pgno , int32_t adjust , DB_LSN *lsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 44U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*lsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )adjust;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_ovref_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_ovref_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) 
{ __db_ovref_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_ovref_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_ovref%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tadjust: %ld\n", (long )argp->adjust);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_ovref_read(DB_ENV *dbenv___0 , void *recbuf , __db_ovref_args **argpp ) 
{ __db_ovref_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_ovref_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->adjust = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  (*argpp) = argp;
  return (0);
}
}
int __db_relink_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , db_pgno_t pgno , DB_LSN *lsn , db_pgno_t prev ,
                    DB_LSN *lsn_prev , db_pgno_t next , DB_LSN *lsn_next ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 45U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*lsn))) +
                   sizeof(u_int32_t )) + sizeof((*lsn_prev))) + sizeof(u_int32_t )) +
                sizeof((*lsn_next));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn, sizeof((*lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn)));
  }
  bp += sizeof((*lsn));
  uinttmp = prev;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn_prev != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn_prev, sizeof((*lsn_prev)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn_prev)));
  }
  bp += sizeof((*lsn_prev));
  uinttmp = next;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )lsn_next != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )lsn_next, sizeof((*lsn_next)));
  } else {
    memset((void *)bp, 0, sizeof((*lsn_next)));
  }
  bp += sizeof((*lsn_next));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_relink_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_relink_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __db_relink_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_relink_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_relink%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tlsn: [%lu][%lu]\n", (unsigned long )argp->lsn.file,
         (unsigned long )argp->lsn.offset);
  printf((char const   * __restrict  )"\tprev: %lu\n", (unsigned long )argp->prev);
  printf((char const   * __restrict  )"\tlsn_prev: [%lu][%lu]\n", (unsigned long )argp->lsn_prev.file,
         (unsigned long )argp->lsn_prev.offset);
  printf((char const   * __restrict  )"\tnext: %lu\n", (unsigned long )argp->next);
  printf((char const   * __restrict  )"\tlsn_next: [%lu][%lu]\n", (unsigned long )argp->lsn_next.file,
         (unsigned long )argp->lsn_next.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_relink_read(DB_ENV *dbenv___0 , void *recbuf , __db_relink_args **argpp ) 
{ __db_relink_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_relink_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn), (void const   * __restrict  )bp, sizeof(argp->lsn));
  bp += sizeof(argp->lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->prev = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn_prev), (void const   * __restrict  )bp,
         sizeof(argp->lsn_prev));
  bp += sizeof(argp->lsn_prev);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->lsn_next), (void const   * __restrict  )bp,
         sizeof(argp->lsn_next));
  bp += sizeof(argp->lsn_next);
  (*argpp) = argp;
  return (0);
}
}
int __db_debug_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                   DBT const   *op , int32_t fileid , DBT const   *key , DBT const   *data ,
                   u_int32_t arg_flags ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;

  {
  rectype = 47U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )op == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = op->size;
  }
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = key->size;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    tmp___1 = 0U;
  } else {
    tmp___1 = data->size;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      tmp) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp___0) +
                  sizeof(u_int32_t )) + tmp___1) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )op == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& op->size), sizeof(op->size));
    bp += sizeof(op->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )op->data, op->size);
    bp += op->size;
  }
  uinttmp = (unsigned int )fileid;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )key == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& key->size), sizeof(key->size));
    bp += sizeof(key->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )key->data, key->size);
    bp += key->size;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& data->size), sizeof(data->size));
    bp += sizeof(data->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )data->data, data->size);
    bp += data->size;
  }
  uinttmp = arg_flags;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_debug_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_debug_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) 
{ __db_debug_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_debug_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_debug%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\top: ");
  i = 0U;
  while (i < argp->op.size) {
    ch = (int )(*((u_int8_t *)argp->op.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tkey: ");
  i = 0U;
  while (i < argp->key.size) {
    ch = (int )(*((u_int8_t *)argp->key.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tdata: ");
  i = 0U;
  while (i < argp->data.size) {
    ch = (int )(*((u_int8_t *)argp->data.data + i));
    tmp___8 = __ctype_b_loc();
    if ((int const   )(*((*tmp___8) + ch)) & 16384) {
      tmp___7 = "%c";
    } else {
      if (ch == 10) {
        tmp___7 = "%c";
      } else {
        tmp___7 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___7, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\targ_flags: %lu\n", (unsigned long )argp->arg_flags);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_debug_read(DB_ENV *dbenv___0 , void *recbuf , __db_debug_args **argpp ) 
{ __db_debug_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_debug_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memset((void *)(& argp->op), 0, sizeof(argp->op));
  memcpy((void * __restrict  )(& argp->op.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->op.data = (void *)bp;
  bp += argp->op.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->key), 0, sizeof(argp->key));
  memcpy((void * __restrict  )(& argp->key.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->key.data = (void *)bp;
  bp += argp->key.size;
  memset((void *)(& argp->data), 0, sizeof(argp->data));
  memcpy((void * __restrict  )(& argp->data.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->data.data = (void *)bp;
  bp += argp->data.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->arg_flags = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __db_noop_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  db_pgno_t pgno , DB_LSN *prevlsn ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 48U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                 sizeof(u_int32_t )) + sizeof((*prevlsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )prevlsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )prevlsn, sizeof((*prevlsn)));
  } else {
    memset((void *)bp, 0, sizeof((*prevlsn)));
  }
  bp += sizeof((*prevlsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_noop_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_noop_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) 
{ __db_noop_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_noop_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_noop%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tprevlsn: [%lu][%lu]\n", (unsigned long )argp->prevlsn.file,
         (unsigned long )argp->prevlsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_noop_read(DB_ENV *dbenv___0 , void *recbuf , __db_noop_args **argpp ) 
{ __db_noop_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_noop_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->prevlsn), (void const   * __restrict  )bp,
         sizeof(argp->prevlsn));
  bp += sizeof(argp->prevlsn);
  (*argpp) = argp;
  return (0);
}
}
int __db_pg_alloc_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      DB_LSN *meta_lsn , db_pgno_t meta_pgno , DB_LSN *page_lsn ,
                      db_pgno_t pgno , u_int32_t ptype , db_pgno_t next ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 49U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = ((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                     sizeof((*meta_lsn))) + sizeof(u_int32_t )) + sizeof((*page_lsn))) +
                  sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )meta_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )meta_lsn, sizeof((*meta_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*meta_lsn)));
  }
  bp += sizeof((*meta_lsn));
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )page_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )page_lsn, sizeof((*page_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*page_lsn)));
  }
  bp += sizeof((*page_lsn));
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = ptype;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = next;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_pg_alloc_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_pg_alloc_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) 
{ __db_pg_alloc_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_pg_alloc_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_pg_alloc%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tmeta_lsn: [%lu][%lu]\n", (unsigned long )argp->meta_lsn.file,
         (unsigned long )argp->meta_lsn.offset);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\tpage_lsn: [%lu][%lu]\n", (unsigned long )argp->page_lsn.file,
         (unsigned long )argp->page_lsn.offset);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tptype: %lu\n", (unsigned long )argp->ptype);
  printf((char const   * __restrict  )"\tnext: %lu\n", (unsigned long )argp->next);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_pg_alloc_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_alloc_args **argpp ) 
{ __db_pg_alloc_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_pg_alloc_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->page_lsn), (void const   * __restrict  )bp,
         sizeof(argp->page_lsn));
  bp += sizeof(argp->page_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->ptype = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __db_pg_free_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     db_pgno_t pgno , DB_LSN *meta_lsn , db_pgno_t meta_pgno , DBT const   *header ,
                     db_pgno_t next ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 50U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )header == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = header->size;
  }
  logrec.size = ((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                     sizeof(u_int32_t )) + sizeof((*meta_lsn))) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )meta_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )meta_lsn, sizeof((*meta_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*meta_lsn)));
  }
  bp += sizeof((*meta_lsn));
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )header == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& header->size),
           sizeof(header->size));
    bp += sizeof(header->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )header->data, header->size);
    bp += header->size;
  }
  uinttmp = next;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_pg_free_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_pg_free_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __db_pg_free_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_pg_free_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_pg_free%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tmeta_lsn: [%lu][%lu]\n", (unsigned long )argp->meta_lsn.file,
         (unsigned long )argp->meta_lsn.offset);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\theader: ");
  i = 0U;
  while (i < argp->header.size) {
    ch = (int )(*((u_int8_t *)argp->header.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tnext: %lu\n", (unsigned long )argp->next);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_pg_free_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_free_args **argpp ) 
{ __db_pg_free_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_pg_free_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->header), 0, sizeof(argp->header));
  memcpy((void * __restrict  )(& argp->header.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->header.data = (void *)bp;
  bp += argp->header.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __db_cksum_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  rectype = 51U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_cksum_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                        void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_cksum_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                     void *notused3 ) 
{ __db_cksum_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_cksum_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_cksum%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_cksum_read(DB_ENV *dbenv___0 , void *recbuf , __db_cksum_args **argpp ) 
{ __db_cksum_args *argp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_cksum_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  (*argpp) = argp;
  return (0);
}
}
int __db_pg_freedata_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                         db_pgno_t pgno , DB_LSN *meta_lsn , db_pgno_t meta_pgno ,
                         DBT const   *header , db_pgno_t next , DBT const   *data ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 52U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )header == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = header->size;
  }
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = data->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*meta_lsn))) +
                     sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t )) +
                 sizeof(u_int32_t )) + tmp___0;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )meta_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )meta_lsn, sizeof((*meta_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*meta_lsn)));
  }
  bp += sizeof((*meta_lsn));
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )header == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& header->size),
           sizeof(header->size));
    bp += sizeof(header->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )header->data, header->size);
    bp += header->size;
  }
  uinttmp = next;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )data == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& data->size), sizeof(data->size));
    bp += sizeof(data->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )data->data, data->size);
    bp += data->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_pg_freedata_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                              void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_pg_freedata_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                           void *notused3 ) 
{ __db_pg_freedata_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_pg_freedata_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_pg_freedata%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tmeta_lsn: [%lu][%lu]\n", (unsigned long )argp->meta_lsn.file,
         (unsigned long )argp->meta_lsn.offset);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\theader: ");
  i = 0U;
  while (i < argp->header.size) {
    ch = (int )(*((u_int8_t *)argp->header.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tnext: %lu\n", (unsigned long )argp->next);
  printf((char const   * __restrict  )"\tdata: ");
  i = 0U;
  while (i < argp->data.size) {
    ch = (int )(*((u_int8_t *)argp->data.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_pg_freedata_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_freedata_args **argpp ) 
{ __db_pg_freedata_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_pg_freedata_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->header), 0, sizeof(argp->header));
  memcpy((void * __restrict  )(& argp->header.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->header.data = (void *)bp;
  bp += argp->header.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->data), 0, sizeof(argp->data));
  memcpy((void * __restrict  )(& argp->data.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->data.data = (void *)bp;
  bp += argp->data.size;
  (*argpp) = argp;
  return (0);
}
}
int __db_pg_prepare_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                        db_pgno_t pgno ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 53U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_pg_prepare_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                             void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_pg_prepare_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                          void *notused3 ) 
{ __db_pg_prepare_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_pg_prepare_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_pg_prepare%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_pg_prepare_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_prepare_args **argpp ) 
{ __db_pg_prepare_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_pg_prepare_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __db_pg_new_log(DB *dbp___1 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    db_pgno_t pgno , DB_LSN *meta_lsn , db_pgno_t meta_pgno , DBT const   *header ,
                    db_pgno_t next ) 
{ DBT logrec ;
  DB_ENV *dbenv___0 ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  rectype = 54U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      goto _L;
    } else {
      if (dbp___1->flags & 32768U) {
        _L: 
        if (dbenv___0->flags & 8388608U) {
          if ((unsigned int )txnid == (unsigned int )((void *)0)) {
            return (0);
          }
        }
        is_durable = 0;
      }
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )header == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = header->size;
  }
  logrec.size = ((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                     sizeof(u_int32_t )) + sizeof((*meta_lsn))) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((dbp___1->log_filename)->id == -1) {
    ret = __dbreg_lazy_id(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  uinttmp = (unsigned int )(dbp___1->log_filename)->id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )meta_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )meta_lsn, sizeof((*meta_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*meta_lsn)));
  }
  bp += sizeof((*meta_lsn));
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )header == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& header->size),
           sizeof(header->size));
    bp += sizeof(header->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )header->data, header->size);
    bp += header->size;
  }
  uinttmp = next;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __db_pg_new_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __db_pg_new_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __db_pg_new_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __db_pg_new_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__db_pg_new%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tpgno: %lu\n", (unsigned long )argp->pgno);
  printf((char const   * __restrict  )"\tmeta_lsn: [%lu][%lu]\n", (unsigned long )argp->meta_lsn.file,
         (unsigned long )argp->meta_lsn.offset);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\theader: ");
  i = 0U;
  while (i < argp->header.size) {
    ch = (int )(*((u_int8_t *)argp->header.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tnext: %lu\n", (unsigned long )argp->next);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __db_pg_new_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_new_args **argpp ) 
{ __db_pg_new_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__db_pg_new_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->header), 0, sizeof(argp->header));
  memcpy((void * __restrict  )(& argp->header.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->header.data = (void *)bp;
  bp += argp->header.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __db_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                       db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_addrem_print, 41U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_big_print, 43U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_ovref_print, 44U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_relink_print, 45U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_debug_print, 47U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_noop_print, 48U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_alloc_print, 49U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_free_print, 50U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_cksum_print, 51U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_freedata_print, 52U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_prepare_print, 53U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_new_print, 54U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __db_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_addrem_getpgnos, 41U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_big_getpgnos, 43U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_ovref_getpgnos, 44U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_relink_getpgnos, 45U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_debug_getpgnos, 47U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_noop_getpgnos, 48U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_alloc_getpgnos, 49U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_free_getpgnos, 50U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_cksum_getpgnos, 51U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_freedata_getpgnos,
                          52U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_prepare_getpgnos,
                          53U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_new_getpgnos, 54U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __db_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                         db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_addrem_recover, 41U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_big_recover, 43U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_ovref_recover, 44U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_relink_recover, 45U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_debug_recover, 47U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_noop_recover, 48U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_alloc_recover, 49U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_free_recover, 50U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_cksum_recover, 51U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_freedata_recover,
                          52U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_prepare_recover,
                          53U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __db_pg_new_recover, 54U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-rvudTtWy.i","-O2")
int __db_byteorder(DB_ENV *dbenv___0 , int lorder ) ;
int __db_isbigendian(void) 
{ union __anonunion_u_53 u ;

  {
  u.l = 1L;
  return ((int )u.c[sizeof(long ) - 1U] == 1);
}
}
int __db_byteorder(DB_ENV *dbenv___0 , int lorder ) 
{ int is_bigendian___0 ;

  {
  is_bigendian___0 = __db_isbigendian();
  switch (lorder) {
  case 0: ;
  break;
  case 1234: ;
  if (is_bigendian___0) {
    return (-30894);
  }
  break;
  case 4321: ;
  if (! is_bigendian___0) {
    return (-30894);
  }
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "unsupported byte order, only big and little-endian supported");
  return (22);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-lpmuHLHJ.i","-O2")
int __db_c_count(DBC *dbc , db_recno_t *recnop ) ;
int __db_c_dup(DBC *dbc_orig , DBC **dbcp , u_int32_t flags ) ;
int __db_c_pget(DBC *dbc , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) ;
int __db_secondary_corrupt(DB *dbp___1 ) ;
static int __db_buildpartial(DB *dbp___1 , DBT *oldrec , DBT *partial , DBT *newrec ) ;
static int __db_c_cleanup(DBC *dbc , DBC *dbc_n , int failed ) ;
static int __db_c_del_secondary(DBC *dbc ) ;
static int __db_c_pget_recno(DBC *sdbc , DBT *pkey , DBT *data , u_int32_t flags ) ;
static int __db_wrlock_err(DB_ENV *dbenv___0 ) ;
int __db_c_close(DBC *dbc ) 
{ DB *dbp___1 ;
  DBC *opd ;
  DBC_INTERNAL *cp ;
  DB_ENV *dbenv___0 ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  cp = dbc->internal;
  opd = cp->opd;
  ret = 0;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    opd->flags = opd->flags & 4294967294U;
    while (1) {
      if ((unsigned int )opd->links.tqe_next != (unsigned int )((void *)0)) {
        (opd->links.tqe_next)->links.tqe_prev = opd->links.tqe_prev;
      } else {
        dbp___1->active_queue.tqh_last = opd->links.tqe_prev;
      }
      (*(opd->links.tqe_prev)) = opd->links.tqe_next;
      break;
    }
  }
  dbc->flags = dbc->flags & 4294967294U;
  while (1) {
    if ((unsigned int )dbc->links.tqe_next != (unsigned int )((void *)0)) {
      (dbc->links.tqe_next)->links.tqe_prev = dbc->links.tqe_prev;
    } else {
      dbp___1->active_queue.tqh_last = dbc->links.tqe_prev;
    }
    (*(dbc->links.tqe_prev)) = dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  t_ret = ((*(dbc->c_am_close)))(dbc, 0U, (int *)((void *)0));
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (dbenv___0->flags & 2U) {
    if (dbc->mylock.off != 0U) {
      t_ret = __lock_put(dbenv___0, & dbc->mylock);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    memset((void *)(& dbc->mylock), 0, sizeof(dbc->mylock));
    if ((unsigned int )opd != (unsigned int )((void *)0)) {
      memset((void *)(& opd->mylock), 0, sizeof(opd->mylock));
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    (dbc->txn)->cursors = (dbc->txn)->cursors - 1U;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      (dbc->txn)->cursors = (dbc->txn)->cursors - 1U;
    }
    while (1) {
      opd->links.tqe_next = (DBC *)((void *)0);
      opd->links.tqe_prev = dbp___1->free_queue.tqh_last;
      (*(dbp___1->free_queue.tqh_last)) = opd;
      dbp___1->free_queue.tqh_last = & opd->links.tqe_next;
      break;
    }
    opd = (DBC *)((void *)0);
  }
  while (1) {
    dbc->links.tqe_next = (DBC *)((void *)0);
    dbc->links.tqe_prev = dbp___1->free_queue.tqh_last;
    (*(dbp___1->free_queue.tqh_last)) = dbc;
    dbp___1->free_queue.tqh_last = & dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  return (ret);
}
}
int __db_c_destroy(DBC *dbc ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  while (1) {
    if ((unsigned int )dbc->links.tqe_next != (unsigned int )((void *)0)) {
      (dbc->links.tqe_next)->links.tqe_prev = dbc->links.tqe_prev;
    } else {
      dbp___1->free_queue.tqh_last = dbc->links.tqe_prev;
    }
    (*(dbc->links.tqe_prev)) = dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  if ((unsigned int )dbc->my_rskey.data != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, dbc->my_rskey.data);
  }
  if ((unsigned int )dbc->my_rkey.data != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, dbc->my_rkey.data);
  }
  if ((unsigned int )dbc->my_rdata.data != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, dbc->my_rdata.data);
  }
  if ((unsigned int )dbc->c_am_destroy == (unsigned int )((void *)0)) {
    ret = 0;
  } else {
    ret = ((*(dbc->c_am_destroy)))(dbc);
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    if (dbc->flags & 2048U) {
      t_ret = __lock_id_free(dbenv___0, dbc->lid);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  __os_free(dbenv___0, (void *)dbc);
  return (ret);
}
}
int __db_c_count(DBC *dbc , db_recno_t *recnop ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = (dbc->dbp)->dbenv;
  switch ((int )dbc->dbtype) {
  case 4: ;
  case 3: 
  (*recnop) = 1U;
  break;
  case 2: ;
  if ((unsigned int )(dbc->internal)->opd == (unsigned int )((void *)0)) {
    ret = __ham_c_count(dbc, recnop);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  case 1: 
  ret = __bam_c_count(dbc, recnop);
  if (ret != 0) {
    return (ret);
  }
  break;
  case 5: ;
  default: 
  tmp = __db_unknown_type(dbenv___0, (char *)"__db_c_count", dbc->dbtype);
  return (tmp);
  }
  return (0);
}
}
int __db_c_del(DBC *dbc , u_int32_t flags ) 
{ DB *dbp___1 ;
  DBC *opd ;
  int ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  if ((dbp___1->dbenv)->flags & 2U) {
    if (! (dbc->flags & 384U)) {
      tmp = __db_wrlock_err(dbp___1->dbenv);
      return (tmp);
    }
    if (dbc->flags & 128U) {
      ret = __lock_get(dbp___1->dbenv, dbc->locker, 32U, (DBT const   *)(& dbc->lock_dbt),
                       (enum __anonenum_db_lockmode_t_50 )2, & dbc->mylock);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if (flags != 34U) {
    if (dbp___1->flags & 33554432U) {
      ret = __db_c_del_secondary(dbc);
      goto done;
    }
  }
  if ((unsigned int )dbp___1->s_secondaries.lh_first != (unsigned int )((void *)0)) {
    ret = __db_c_del_primary(dbc);
    if (ret != 0) {
      goto done;
    }
  }
  opd = (dbc->internal)->opd;
  if ((unsigned int )opd == (unsigned int )((void *)0)) {
    ret = ((*(dbc->c_am_del)))(dbc);
  } else {
    ret = ((*(dbc->c_am_writelock)))(dbc);
    if (ret == 0) {
      ret = ((*(opd->c_am_del)))(opd);
    }
  }
  done: 
  if (dbc->flags & 128U) {
    __lock_downgrade(dbp___1->dbenv, & dbc->mylock, (enum __anonenum_db_lockmode_t_50 )4,
                     0U);
  }
  return (ret);
}
}
int __db_c_dup(DBC *dbc_orig , DBC **dbcp , u_int32_t flags ) 
{ DBC *dbc_n ;
  DBC *dbc_nopd ;
  int ret ;

  {
  dbc_nopd = (DBC *)((void *)0);
  dbc_n = dbc_nopd;
  ret = __db_c_idup(dbc_orig, & dbc_n, flags);
  if (ret != 0) {
    goto err;
  }
  (*dbcp) = dbc_n;
  if ((unsigned int )(dbc_orig->internal)->opd != (unsigned int )((void *)0)) {
    ret = __db_c_idup((dbc_orig->internal)->opd, & dbc_nopd, flags);
    if (ret != 0) {
      goto err;
    }
    (dbc_n->internal)->opd = dbc_nopd;
  }
  return (0);
  err: 
  if ((unsigned int )dbc_n != (unsigned int )((void *)0)) {
    __db_c_close(dbc_n);
  }
  if ((unsigned int )dbc_nopd != (unsigned int )((void *)0)) {
    __db_c_close(dbc_nopd);
  }
  return (ret);
}
}
int __db_c_idup(DBC *dbc_orig , DBC **dbcp , u_int32_t flags ) 
{ DB *dbp___1 ;
  DBC *dbc_n ;
  DBC_INTERNAL *int_n ;
  DBC_INTERNAL *int_orig ;
  int ret ;
  int tmp ;

  {
  dbp___1 = dbc_orig->dbp;
  dbc_n = (*dbcp);
  ret = __db_cursor_int(dbp___1, dbc_orig->txn, dbc_orig->dbtype, (dbc_orig->internal)->root,
                        (int )(dbc_orig->flags & 8U), dbc_orig->locker, & dbc_n);
  if (ret != 0) {
    return (ret);
  }
  if (flags == 24U) {
    int_n = dbc_n->internal;
    int_orig = dbc_orig->internal;
    dbc_n->flags = dbc_n->flags | (dbc_orig->flags & 4294965247U);
    int_n->indx = int_orig->indx;
    int_n->pgno = int_orig->pgno;
    int_n->root = int_orig->root;
    int_n->lock_mode = int_orig->lock_mode;
    switch ((int )dbc_orig->dbtype) {
    case 4: 
    ret = __qam_c_dup(dbc_orig, dbc_n);
    if (ret != 0) {
      goto err;
    }
    break;
    case 1: ;
    case 3: 
    ret = __bam_c_dup(dbc_orig, dbc_n);
    if (ret != 0) {
      goto err;
    }
    break;
    case 2: 
    ret = __ham_c_dup(dbc_orig, dbc_n);
    if (ret != 0) {
      goto err;
    }
    break;
    case 5: ;
    default: 
    ret = __db_unknown_type(dbp___1->dbenv, (char *)"__db_c_idup", dbc_orig->dbtype);
    goto err;
    }
  }
  dbc_n->flags = dbc_n->flags | (dbc_orig->flags & 4U);
  dbc_n->flags = dbc_n->flags | (dbc_orig->flags & 128U);
  if ((dbp___1->dbenv)->flags & 2U) {
    if (! (dbc_n->flags & 8U)) {
      if (dbc_orig->flags & 128U) {
        tmp = 4;
      } else {
        tmp = 1;
      }
      ret = __lock_get(dbp___1->dbenv, dbc_n->locker, 0U, (DBT const   *)(& dbc_n->lock_dbt),
                       (enum __anonenum_db_lockmode_t_50 )tmp, & dbc_n->mylock);
      if (ret != 0) {
        goto err;
      }
    }
  }
  (*dbcp) = dbc_n;
  return (0);
  err: 
  __db_c_close(dbc_n);
  return (ret);
}
}
int __db_c_newopd(DBC *dbc_parent , db_pgno_t root , DBC *oldopd , DBC **dbcp ) 
{ DB *dbp___1 ;
  DBC *opd ;
  DBTYPE dbtype ;
  int ret ;

  {
  dbp___1 = dbc_parent->dbp;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    dbtype = (enum __anonenum_DBTYPE_61 )3;
  } else {
    dbtype = (enum __anonenum_DBTYPE_61 )1;
  }
  (*dbcp) = oldopd;
  ret = __db_cursor_int(dbp___1, dbc_parent->txn, dbtype, root, 1, dbc_parent->locker,
                        & opd);
  if (ret != 0) {
    return (ret);
  }
  (*dbcp) = opd;
  if ((unsigned int )oldopd != (unsigned int )((void *)0)) {
    ret = __db_c_close(oldopd);
    if (ret != 0) {
      return (ret);
    }
  }
  return (0);
}
}
int __db_c_get(DBC *dbc_arg , DBT *key , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DBC *dbc ;
  DBC *dbc_n ;
  DBC *opd ;
  DBC_INTERNAL *cp ;
  DBC_INTERNAL *cp_n ;
  DB_MPOOLFILE *mpf ;
  db_pgno_t pgno ;
  u_int32_t multi ;
  u_int32_t tmp_dirty ;
  u_int32_t tmp_flags ;
  u_int32_t tmp_rmw ;
  u_int8_t type ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___1 ;

  {
  dbp___1 = dbc_arg->dbp;
  mpf = dbp___1->mpf;
  dbc_n = (DBC *)((void *)0);
  opd = (DBC *)((void *)0);
  tmp_rmw = flags & 268435456U;
  flags &= 4026531839U;
  tmp_dirty = flags & 33554432U;
  flags &= 4261412863U;
  multi = flags & 201326592U;
  flags &= 4093640703U;
  if (flags == 13U) {
    if (tmp_rmw) {
      dbc_arg->flags = dbc_arg->flags | 32U;
    }
    if (tmp_dirty) {
      dbc_arg->flags = dbc_arg->flags | 4U;
    }
    ret = __bam_c_rget(dbc_arg, data);
    if (tmp_rmw) {
      dbc_arg->flags = dbc_arg->flags & 4294967263U;
    }
    if (tmp_dirty) {
      dbc_arg->flags = dbc_arg->flags & 4294967291U;
    }
    return (ret);
  }
  if (flags == 5U) {
    goto _L;
  } else {
    if (flags == 6U) {
      _L: 
      if ((dbp___1->dbenv)->flags & 2U) {
        if (! (dbc_arg->flags & 384U)) {
          tmp = __db_wrlock_err(dbp___1->dbenv);
          return (tmp);
        }
        if (dbc_arg->flags & 128U) {
          ret = __lock_get(dbp___1->dbenv, dbc_arg->locker, 32U, (DBT const   *)(& dbc_arg->lock_dbt),
                           (enum __anonenum_db_lockmode_t_50 )2, & dbc_arg->mylock);
          if (ret != 0) {
            return (ret);
          }
        }
      }
    }
  }
  cp = dbc_arg->internal;
  if ((unsigned int )cp->opd != (unsigned int )((void *)0)) {
    if (flags == 7U) {
      goto _L___1;
    } else {
      if (flags == 11U) {
        goto _L___1;
      } else {
        if (flags == 18U) {
          goto _L___1;
        } else {
          if (flags == 19U) {
            goto _L___1;
          } else {
            if (flags == 25U) {
              _L___1: 
              if (tmp_rmw) {
                ret = ((*(dbc_arg->c_am_writelock)))(dbc_arg);
                if (ret != 0) {
                  return (ret);
                }
              }
              ret = __db_c_idup(cp->opd, & opd, 24U);
              if (ret != 0) {
                return (ret);
              }
              ret = ((*(opd->c_am_get)))(opd, key, data, flags, (db_pgno_t *)((void *)0));
              switch (ret) {
              case 0: ;
              goto done;
              case -30990: ;
              if (flags == 18U) {
                goto _L___0;
              } else {
                if (flags == 25U) {
                  _L___0: 
                  ret = __db_c_close(opd);
                  if (ret != 0) {
                    goto err;
                  }
                  opd = (DBC *)((void *)0);
                  break;
                }
              }
              goto err;
              default: ;
              goto err;
              }
            }
          }
        }
      }
    }
  }
  switch ((int )flags) {
  case 7: ;
  case 11: ;
  case 18: ;
  case 19: ;
  case 20: ;
  case 25: ;
  case 26: 
  tmp_flags = 24U;
  break;
  default: 
  tmp_flags = 0U;
  break;
  }
  if (tmp_dirty) {
    dbc_arg->flags = dbc_arg->flags | 4U;
  }
  if (dbc_arg->flags & 64U) {
    dbc_n = dbc_arg;
  } else {
    ret = __db_c_idup(dbc_arg, & dbc_n, tmp_flags);
    if (tmp_dirty) {
      dbc_arg->flags = dbc_arg->flags & 4294967291U;
    }
    if (ret != 0) {
      goto err;
    }
    while (1) {
      dbc_n->rskey = dbc_arg->rskey;
      dbc_n->rkey = dbc_arg->rkey;
      dbc_n->rdata = dbc_arg->rdata;
      break;
    }
  }
  if (tmp_rmw) {
    dbc_n->flags = dbc_n->flags | 32U;
  }
  switch ((int )multi) {
  case 67108864: 
  dbc_n->flags = dbc_n->flags | 512U;
  break;
  case 134217728: 
  dbc_n->flags = dbc_n->flags | 1024U;
  break;
  case 201326592: 
  dbc_n->flags = dbc_n->flags | 1536U;
  break;
  case 0: ;
  default: ;
  break;
  }
  pgno = 0U;
  ret = ((*(dbc_n->c_am_get)))(dbc_n, key, data, flags, & pgno);
  if (tmp_rmw) {
    dbc_n->flags = dbc_n->flags & 4294967263U;
  }
  if (tmp_dirty) {
    dbc_arg->flags = dbc_arg->flags & 4294967291U;
  }
  dbc_n->flags = dbc_n->flags & 4294965759U;
  if (ret != 0) {
    goto err;
  }
  cp_n = dbc_n->internal;
  if (pgno != 0U) {
    ret = __db_c_newopd(dbc_arg, pgno, cp_n->opd, & cp_n->opd);
    if (ret != 0) {
      goto err;
    }
    switch ((int )flags) {
    case 9: ;
    case 18: ;
    case 20: ;
    case 28: ;
    case 31: ;
    case 30: 
    tmp_flags = 9U;
    break;
    case 17: ;
    case 25: ;
    case 26: 
    tmp_flags = 17U;
    break;
    case 10: ;
    case 11: ;
    case 12: 
    tmp_flags = flags;
    break;
    default: 
    ret = __db_unknown_flag(dbp___1->dbenv, (char *)"__db_c_get", flags);
    goto err;
    }
    ret = ((*((cp_n->opd)->c_am_get)))(cp_n->opd, key, data, tmp_flags, (db_pgno_t *)((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  done: 
  if ((unsigned int )dbc_n == (unsigned int )((void *)0)) {
    cp_n = dbc_arg->internal;
  } else {
    cp_n = dbc_n->internal;
  }
  if (! (key->flags & 2U)) {
    if ((unsigned int )cp_n->page == (unsigned int )((void *)0)) {
      ret = __memp_fget(mpf, & cp_n->pgno, 0U, (void *)(& cp_n->page));
      if (ret != 0) {
        goto err;
      }
    }
    ret = __db_ret(dbp___1, (PAGE *)cp_n->page, (unsigned int )cp_n->indx, key, & (dbc_arg->rkey)->data,
                   & (dbc_arg->rkey)->ulen);
    if (ret != 0) {
      goto err;
    }
  }
  if (multi != 0U) {
    if ((unsigned int )dbc_n == (unsigned int )((void *)0)) {
      if (! (multi & 134217728U)) {
        if ((unsigned int )(dbc_arg->internal)->opd == (unsigned int )((void *)0)) {
          dbc_n = dbc_arg;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if (dbc_arg->flags & 64U) {
          dbc_n = dbc_arg;
        } else {
          ret = __db_c_idup(dbc_arg, & dbc_n, 24U);
          if (ret != 0) {
            goto err;
          }
          ret = ((*(dbc_n->c_am_get)))(dbc_n, key, data, 7U, & pgno);
          if (ret != 0) {
            goto err;
          }
        }
      }
      cp_n = dbc_n->internal;
    }
    if ((unsigned int )opd != (unsigned int )((void *)0)) {
      cp_n->opd = opd;
      opd = (DBC *)((void *)0);
    }
    data->size = data->ulen;
    ret = ((*(dbc_n->c_am_bulk)))(dbc_n, data, flags | multi);
  } else {
    if (! (data->flags & 2U)) {
      if ((unsigned int )opd != (unsigned int )((void *)0)) {
        dbc = opd;
      } else {
        if ((unsigned int )cp_n->opd != (unsigned int )((void *)0)) {
          dbc = cp_n->opd;
        } else {
          dbc = dbc_n;
        }
      }
      type = ((PAGE *)(dbc->internal)->page)->type;
      if ((int )type == 5) {
        tmp___1 = 1;
      } else {
        if ((int )type == 2) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      }
      ret = __db_ret(dbp___1, (PAGE *)(dbc->internal)->page, (unsigned int )((int )(dbc->internal)->indx +
                                                                             tmp___1),
                     data, & (dbc_arg->rdata)->data, & (dbc_arg->rdata)->ulen);
    }
  }
  err: 
  key->flags = key->flags & 4294967293U;
  data->flags = data->flags & 4294967293U;
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    t_ret = __db_c_cleanup((dbc_arg->internal)->opd, opd, ret);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  t_ret = __db_c_cleanup(dbc_arg, dbc_n, ret);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (flags == 5U) {
    goto _L___3;
  } else {
    if (flags == 6U) {
      _L___3: 
      if (dbc_arg->flags & 128U) {
        __lock_downgrade(dbp___1->dbenv, & dbc_arg->mylock, (enum __anonenum_db_lockmode_t_50 )4,
                         0U);
      }
    }
  }
  return (ret);
}
}
int __db_c_put(DBC *dbc_arg , DBT *key , DBT *data , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB *dbp___1 ;
  DB *sdbp ;
  DBC *dbc_n ;
  DBC *oldopd ;
  DBC *opd ;
  DBC *sdbc ;
  DBC *pdbc ;
  DBT olddata ;
  DBT oldpkey ;
  DBT oldskey ;
  DBT newdata ;
  DBT pkey ;
  DBT skey ;
  DBT temppkey ;
  DBT tempskey ;
  db_pgno_t pgno ;
  int cmp ;
  int have_oldrec ;
  int ispartial ;
  int nodel ;
  int re_pad ;
  int ret ;
  int rmw ;
  int t_ret ;
  u_int32_t re_len ;
  u_int32_t size ;
  u_int32_t tmp_flags ;
  int tmp ;
  DBT *tmp___0 ;
  DBT *tmp___1 ;
  int tmp___2 ;

  {
  dbp___1 = dbc_arg->dbp;
  dbenv___0 = dbp___1->dbenv;
  sdbp = (DB *)((void *)0);
  dbc_n = (DBC *)((void *)0);
  pdbc = dbc_n;
  memset((void *)(& newdata), 0, sizeof(DBT ));
  ret = 0;
  memset((void *)(& olddata), 0, sizeof(DBT ));
  olddata.flags = olddata.flags | 4U;
  if (flags == 34U) {
    flags = 16U;
  }
  if ((dbp___1->dbenv)->flags & 2U) {
    if (! (dbc_arg->flags & 384U)) {
      tmp = __db_wrlock_err(dbp___1->dbenv);
      return (tmp);
    }
    if (dbc_arg->flags & 128U) {
      ret = __lock_get(dbp___1->dbenv, dbc_arg->locker, 32U, (DBT const   *)(& dbc_arg->lock_dbt),
                       (enum __anonenum_db_lockmode_t_50 )2, & dbc_arg->mylock);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if ((unsigned int )dbp___1->s_secondaries.lh_first == (unsigned int )((void *)0)) {
    goto skip_s_update;
  }
  memset((void *)(& pkey), 0, sizeof(DBT ));
  nodel = 0;
  have_oldrec = nodel;
  if (! (dbc_arg->flags & 8U)) {
    if (! (((dbc_arg->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc_arg->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        rmw = 268435456;
      } else {
        rmw = 0;
      }
    } else {
      rmw = 0;
    }
  } else {
    rmw = 0;
  }
  pkey.data = key->data;
  pkey.size = key->size;
  if (flags == 7U) {
    ret = __db_c_get(dbc_arg, & pkey, & olddata, (unsigned int )(rmw | 7));
    if (ret == -30997) {
      nodel = 1;
      have_oldrec = 1;
      ret = 0;
    } else {
      if (ret != 0) {
        goto done;
      } else {
        have_oldrec = 1;
      }
    }
  }
  if (data->flags & 8U) {
    if (! have_oldrec) {
      if (! nodel) {
        ret = __db_c_idup(dbc_arg, & pdbc, 0U);
        if (ret != 0) {
          goto done;
        }
        ret = __db_c_get(pdbc, & pkey, & olddata, (unsigned int )(rmw | 28));
        if (ret == -30997) {
          nodel = 1;
          ret = 0;
        } else {
          if (ret == -30990) {
            nodel = 1;
            ret = 0;
          }
        }
        t_ret = __db_c_close(pdbc);
        if (t_ret != 0) {
          ret = t_ret;
        }
        if (ret != 0) {
          goto done;
        }
        have_oldrec = 1;
      }
    }
    ret = __db_buildpartial(dbp___1, & olddata, data, & newdata);
    if (ret != 0) {
      goto done;
    }
    ispartial = 1;
  } else {
    ispartial = 0;
  }
  if ((int )dbp___1->type == 3) {
    if (dbp___1->flags & 4096U) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if ((int )dbp___1->type == 4) {
      _L: 
      if ((int )dbp___1->type == 4) {
        re_len = ((QUEUE *)dbp___1->q_internal)->re_len;
        re_pad = ((QUEUE *)dbp___1->q_internal)->re_pad;
      } else {
        re_len = ((BTREE *)dbp___1->bt_internal)->re_len;
        re_pad = ((BTREE *)dbp___1->bt_internal)->re_pad;
      }
      if (ispartial) {
        size = newdata.size;
      } else {
        size = data->size;
      }
      if (size > re_len) {
        ret = __db_rec_toobig(dbenv___0, size, re_len);
        goto done;
      } else {
        if (size < re_len) {
          ret = __os_realloc(dbenv___0, re_len, (void *)(& newdata.data));
          if (ret != 0) {
            goto done;
          }
          if (! ispartial) {
            memcpy((void * __restrict  )newdata.data, (void const   * __restrict  )data->data,
                   size);
          }
          memset((void *)((u_int8_t *)newdata.data + size), re_pad, re_len - size);
          newdata.size = re_len;
          ispartial = 1;
        }
      }
    }
  }
  sdbp = __db_s_first(dbp___1);
  while (1) {
    if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& skey), 0, sizeof(DBT ));
    if (ispartial) {
      tmp___0 = & newdata;
    } else {
      tmp___0 = data;
    }
    ret = ((*(sdbp->s_callback)))(sdbp, (DBT const   *)(& pkey), (DBT const   *)tmp___0,
                                  & skey);
    if (ret != 0) {
      if (ret == -30999) {
        goto __Cont;
      } else {
        goto done;
      }
    }
    ret = __db_cursor_int(sdbp, dbc_arg->txn, sdbp->type, 0U, 0, dbc_arg->locker,
                          & sdbc);
    if (ret != 0) {
      goto done;
    }
    if (dbenv___0->flags & 2U) {
      sdbc->flags = sdbc->flags | 256U;
    }
    if (! (sdbp->flags & 512U)) {
      memset((void *)(& oldpkey), 0, sizeof(DBT ));
      oldpkey.flags = oldpkey.flags | 4U;
      ret = __db_c_get(sdbc, & skey, & oldpkey, (unsigned int )(rmw | 28));
      if (ret == 0) {
        cmp = __bam_defcmp(sdbp, (DBT const   *)(& oldpkey), (DBT const   *)(& pkey));
        __os_ufree(dbenv___0, oldpkey.data);
        if (cmp != 0) {
          __db_err((DB_ENV const   *)dbenv___0, "%s%s", "Put results in a non-unique secondary key in an ",
                   "index not configured to support duplicates");
          ret = 22;
          goto skipput;
        }
      } else {
        if (ret != -30990) {
          if (ret != -30997) {
            goto skipput;
          }
        }
      }
    } else {
      if (! (sdbp->flags & 1024U)) {
        memset((void *)(& tempskey), 0, sizeof(DBT ));
        tempskey.data = skey.data;
        tempskey.size = skey.size;
        memset((void *)(& temppkey), 0, sizeof(DBT ));
        temppkey.data = pkey.data;
        temppkey.size = pkey.size;
        ret = __db_c_get(sdbc, & tempskey, & temppkey, (unsigned int )(rmw | 10));
        if (ret != -30990) {
          if (ret != -30997) {
            goto skipput;
          }
        }
      }
    }
    ret = __db_c_put(sdbc, & skey, & pkey, 34U);
    if (ret == -30996) {
      ret = 0;
    }
    skipput: 
    if (skey.flags & 1U) {
      __os_ufree(sdbp->dbenv, skey.data);
      skey.flags = skey.flags & 4294967294U;
    }
    t_ret = __db_c_close(sdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret != 0) {
      goto done;
    }
    __Cont: 
    ret = __db_s_next(& sdbp);
  }
  if (ret != 0) {
    goto done;
  }
  if (! have_oldrec) {
    ret = __db_c_idup(dbc_arg, & pdbc, 0U);
    if (ret != 0) {
      goto done;
    }
    pkey.data = key->data;
    pkey.size = key->size;
    ret = __db_c_get(pdbc, & pkey, & olddata, (unsigned int )(rmw | 28));
    if (ret == -30997) {
      nodel = 1;
      ret = 0;
    } else {
      if (ret == -30990) {
        nodel = 1;
        ret = 0;
      }
    }
    t_ret = __db_c_close(pdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret != 0) {
      goto done;
    }
    have_oldrec = 1;
  }
  if (nodel) {
    goto skip_s_update;
  }
  sdbp = __db_s_first(dbp___1);
  while (1) {
    if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& oldskey), 0, sizeof(DBT ));
    ret = ((*(sdbp->s_callback)))(sdbp, (DBT const   *)(& pkey), (DBT const   *)(& olddata),
                                  & oldskey);
    if (ret != 0) {
      if (ret == -30999) {
        goto __Cont___0;
      } else {
        goto done;
      }
    }
    memset((void *)(& skey), 0, sizeof(DBT ));
    if (ispartial) {
      tmp___1 = & newdata;
    } else {
      tmp___1 = data;
    }
    ret = ((*(sdbp->s_callback)))(sdbp, (DBT const   *)(& pkey), (DBT const   *)tmp___1,
                                  & skey);
    if (ret != 0) {
      if (ret != -30999) {
        goto done;
      }
    }
    sdbc = (DBC *)((void *)0);
    if (ret == -30999) {
      goto _L___1;
    } else {
      tmp___2 = ((*(((BTREE *)sdbp->bt_internal)->bt_compare)))(sdbp, (DBT const   *)(& oldskey),
                                                                (DBT const   *)(& skey));
      if (tmp___2 != 0) {
        _L___1: 
        ret = __db_cursor_int(sdbp, dbc_arg->txn, sdbp->type, 0U, 0, dbc_arg->locker,
                              & sdbc);
        if (ret != 0) {
          goto done;
        }
        if (dbenv___0->flags & 2U) {
          sdbc->flags = sdbc->flags | 256U;
        }
        memset((void *)(& tempskey), 0, sizeof(DBT ));
        tempskey.data = oldskey.data;
        tempskey.size = oldskey.size;
        memset((void *)(& temppkey), 0, sizeof(DBT ));
        temppkey.data = pkey.data;
        temppkey.size = pkey.size;
        ret = __db_c_get(sdbc, & tempskey, & temppkey, (unsigned int )(rmw | 10));
        if (ret == 0) {
          ret = __db_c_del(sdbc, 34U);
        } else {
          if (ret == -30990) {
            ret = __db_secondary_corrupt(dbp___1);
          }
        }
      }
    }
    if (skey.flags & 1U) {
      __os_ufree(sdbp->dbenv, skey.data);
      skey.flags = skey.flags & 4294967294U;
    }
    if (oldskey.flags & 1U) {
      __os_ufree(sdbp->dbenv, oldskey.data);
      oldskey.flags = oldskey.flags & 4294967294U;
    }
    if ((unsigned int )sdbc != (unsigned int )((void *)0)) {
      t_ret = __db_c_close(sdbc);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    if (ret != 0) {
      goto done;
    }
    __Cont___0: 
    ret = __db_s_next(& sdbp);
  }
  skip_s_update: 
  if ((unsigned int )(dbc_arg->internal)->opd != (unsigned int )((void *)0)) {
    if (flags == 1U) {
      goto _L___2;
    } else {
      if (flags == 3U) {
        goto _L___2;
      } else {
        if (flags == 7U) {
          _L___2: 
          if ((int )dbc_arg->dbtype == 2) {
            if (((BTREE_CURSOR *)((dbc_arg->internal)->opd)->internal)->flags & 1U) {
              ret = -30990;
              goto done;
            }
          }
          ret = ((*(dbc_arg->c_am_writelock)))(dbc_arg);
          if (ret != 0) {
            return (ret);
          }
          ret = __db_c_dup(dbc_arg, & dbc_n, 24U);
          if (ret != 0) {
            goto done;
          }
          opd = (dbc_n->internal)->opd;
          ret = ((*(opd->c_am_put)))(opd, key, data, flags, (db_pgno_t *)((void *)0));
          if (ret != 0) {
            goto done;
          }
          goto done;
        }
      }
    }
  }
  tmp_flags = 24U;
  if (dbc_arg->flags & 64U) {
    dbc_n = dbc_arg;
  } else {
    ret = __db_c_idup(dbc_arg, & dbc_n, tmp_flags);
    if (ret != 0) {
      goto done;
    }
  }
  pgno = 0U;
  ret = ((*(dbc_n->c_am_put)))(dbc_n, key, data, flags, & pgno);
  if (ret != 0) {
    goto done;
  }
  if (pgno != 0U) {
    oldopd = (dbc_n->internal)->opd;
    ret = __db_c_newopd(dbc_arg, pgno, oldopd, & opd);
    if (ret != 0) {
      (dbc_n->internal)->opd = opd;
      goto done;
    }
    (dbc_n->internal)->opd = opd;
    ret = ((*(opd->c_am_put)))(opd, key, data, flags, (db_pgno_t *)((void *)0));
    if (ret != 0) {
      goto done;
    }
  }
  done: 
  t_ret = __db_c_cleanup(dbc_arg, dbc_n, ret);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )newdata.data != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, newdata.data);
  }
  if ((unsigned int )olddata.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, olddata.data);
  }
  if (dbc_arg->flags & 128U) {
    __lock_downgrade(dbp___1->dbenv, & dbc_arg->mylock, (enum __anonenum_db_lockmode_t_50 )4,
                     0U);
  }
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    t_ret = __db_s_done(sdbp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_duperr(DB *dbp___1 , u_int32_t flags ) 
{ 

  {
  if (flags != 21U) {
    if (! (dbp___1->flags & 33554432U)) {
      __db_err((DB_ENV const   *)dbp___1->dbenv, "Duplicate data items are not supported with sorted data");
    }
  }
  return (-30996);
}
}
static int __db_c_cleanup(DBC *dbc , DBC *dbc_n , int failed ) 
{ DB *dbp___1 ;
  DBC *opd ;
  DBC_INTERNAL *internal ;
  DB_MPOOLFILE *mpf ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  internal = dbc->internal;
  ret = 0;
  if ((unsigned int )internal->page != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, internal->page, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    internal->page = (void *)0;
  }
  opd = internal->opd;
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    if ((unsigned int )(opd->internal)->page != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(mpf, (opd->internal)->page, 0U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
      (opd->internal)->page = (void *)0;
    }
  }
  if ((unsigned int )dbc_n == (unsigned int )((void *)0)) {
    return (ret);
  } else {
    if ((unsigned int )dbc == (unsigned int )dbc_n) {
      return (ret);
    }
  }
  if ((unsigned int )(dbc_n->internal)->page != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (dbc_n->internal)->page, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    (dbc_n->internal)->page = (void *)0;
  }
  opd = (dbc_n->internal)->opd;
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    if ((unsigned int )(opd->internal)->page != (unsigned int )((void *)0)) {
      t_ret = __memp_fput(mpf, (opd->internal)->page, 0U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
      (opd->internal)->page = (void *)0;
    }
  }
  if (! failed) {
    if (ret == 0) {
      dbc->internal = dbc_n->internal;
      dbc_n->internal = internal;
    }
  }
  t_ret = __db_c_close(dbc_n);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_c_secondary_get_pp(DBC *dbc , DBT *skey , DBT *data , u_int32_t flags ) 
{ int tmp ;

  {
  tmp = __db_c_pget_pp(dbc, skey, (DBT *)((void *)0), data, flags);
  return (tmp);
}
}
int __db_c_pget(DBC *dbc , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) 
{ DB *pdbp ;
  DB *sdbp ;
  DBC *pdbc ;
  DBT *save_rdata ;
  DBT nullpkey ;
  u_int32_t save_pkey_flags ;
  int pkeymalloc ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  sdbp = dbc->dbp;
  pdbp = sdbp->s_primary;
  t_ret = 0;
  pkeymalloc = t_ret;
  if ((unsigned int )pkey == (unsigned int )((void *)0)) {
    memset((void *)(& nullpkey), 0, sizeof(DBT ));
    pkey = & nullpkey;
  }
  if ((flags & 255U) == 13U) {
    tmp = __db_c_pget_recno(dbc, pkey, data, flags);
    return (tmp);
  }
  save_rdata = dbc->rdata;
  dbc->rdata = dbc->rkey;
  dbc->rkey = dbc->rskey;
  save_pkey_flags = pkey->flags;
  pkey->flags = pkey->flags & 4294967287U;
  ret = __db_c_get(dbc, skey, pkey, flags);
  if (ret != 0) {
    pkey->flags = save_pkey_flags;
    dbc->rskey = dbc->rkey;
    dbc->rkey = dbc->rdata;
    dbc->rdata = save_rdata;
    goto err;
  }
  pkey->flags = save_pkey_flags;
  dbc->rskey = dbc->rkey;
  dbc->rkey = dbc->rdata;
  dbc->rdata = save_rdata;
  ret = __db_cursor_int(pdbp, dbc->txn, pdbp->type, 0U, 0, dbc->locker, & pdbc);
  if (ret != 0) {
    goto err;
  }
  if (pkey->flags & 4U) {
    pkey->flags = pkey->flags & 4294967291U;
    pkey->flags = pkey->flags | 16U;
    pkeymalloc = 1;
  }
  pdbc->flags = pdbc->flags | 64U;
  while (1) {
    pdbc->rskey = & dbc->my_rskey;
    pdbc->rkey = & dbc->my_rkey;
    pdbc->rdata = & dbc->my_rdata;
    break;
  }
  ret = __db_c_get(pdbc, pkey, data, 28U);
  if (ret == -30990) {
    ret = __db_secondary_corrupt(pdbp);
  }
  t_ret = __db_c_close(pdbc);
  err: 
  if (pkeymalloc) {
    pkey->flags = pkey->flags & 4294967279U;
    pkey->flags = pkey->flags | 4U;
  }
  if (t_ret == 0) {
    tmp___0 = ret;
  } else {
    tmp___0 = t_ret;
  }
  return (tmp___0);
}
}
static int __db_c_pget_recno(DBC *sdbc , DBT *pkey , DBT *data , u_int32_t flags ) 
{ DB *pdbp ;
  DB *sdbp ;
  DB_ENV *dbenv___0 ;
  DBC *pdbc ;
  DBT discardme ;
  DBT primary_key ;
  db_recno_t oob ;
  u_int32_t rmw ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  sdbp = sdbc->dbp;
  pdbp = sdbp->s_primary;
  dbenv___0 = sdbp->dbenv;
  pdbc = (DBC *)((void *)0);
  t_ret = 0;
  ret = t_ret;
  rmw = flags & 268435456U;
  memset((void *)(& discardme), 0, sizeof(DBT ));
  discardme.flags = discardme.flags | 40U;
  oob = 0U;
  if (pdbp->flags & 1048576U) {
    memset((void *)(& primary_key), 0, sizeof(DBT ));
    primary_key.flags = primary_key.flags | 4U;
    ret = __db_c_get(sdbc, & discardme, & primary_key, rmw | 7U);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_cursor_int(pdbp, sdbc->txn, pdbp->type, 0U, 0, sdbc->locker, & pdbc);
    if (ret != 0) {
      goto perr;
    }
    while (1) {
      pdbc->rskey = & sdbc->my_rskey;
      pdbc->rkey = & sdbc->my_rkey;
      pdbc->rdata = & sdbc->my_rdata;
      break;
    }
    ret = __db_c_get(pdbc, & primary_key, & discardme, rmw | 28U);
    if (ret != 0) {
      goto perr;
    }
    ret = __db_c_get(pdbc, & discardme, data, rmw | 13U);
    perr: 
    __os_ufree(sdbp->dbenv, primary_key.data);
    if ((unsigned int )pdbc != (unsigned int )((void *)0)) {
      t_ret = __db_c_close(pdbc);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    if (ret != 0) {
      return (ret);
    }
  } else {
    ret = __db_retcopy(dbenv___0, data, (void *)(& oob), sizeof(oob), & (sdbc->rkey)->data,
                       & (sdbc->rkey)->ulen);
    if (ret != 0) {
      return (ret);
    }
  }
  if (sdbp->flags & 1048576U) {
    tmp = __db_c_get(sdbc, & discardme, pkey, flags);
    return (tmp);
  } else {
    tmp___0 = __db_retcopy(dbenv___0, pkey, (void *)(& oob), sizeof(oob), & (sdbc->rdata)->data,
                           & (sdbc->rdata)->ulen);
    return (tmp___0);
  }
}
}
static int __db_wrlock_err(DB_ENV *dbenv___0 ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "Write attempted on read-only cursor");
  return (1);
}
}
static int __db_c_del_secondary(DBC *dbc ) 
{ DB *pdbp ;
  DBC *pdbc ;
  DBT skey ;
  DBT pkey ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  memset((void *)(& skey), 0, sizeof(DBT ));
  memset((void *)(& pkey), 0, sizeof(DBT ));
  skey.flags = skey.flags | 40U;
  ret = __db_c_get(dbc, & skey, & pkey, 7U);
  if (ret != 0) {
    return (ret);
  }
  pdbp = (dbc->dbp)->s_primary;
  ret = __db_cursor_int(pdbp, dbc->txn, pdbp->type, 0U, 0, dbc->locker, & pdbc);
  if (ret != 0) {
    return (ret);
  }
  if ((pdbp->dbenv)->flags & 2U) {
    pdbc->flags = pdbc->flags | 256U;
  }
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        tmp = 268435456;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ret = __db_c_get(pdbc, & pkey, & skey, (unsigned int )(tmp | 28));
  if (ret == 0) {
    ret = __db_c_del(pdbc, 0U);
  } else {
    if (ret == -30990) {
      ret = __db_secondary_corrupt(pdbp);
    }
  }
  t_ret = __db_c_close(pdbc);
  if (t_ret != 0) {
    if (ret != 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_c_del_primary(DBC *dbc ) 
{ DB *dbp___1 ;
  DB *sdbp ;
  DBC *sdbc ;
  DBT data ;
  DBT pkey ;
  DBT skey ;
  DBT temppkey ;
  DBT tempskey ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  memset((void *)(& pkey), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  ret = __db_c_get(dbc, & pkey, & data, 7U);
  if (ret != 0) {
    return (ret);
  }
  sdbp = __db_s_first(dbp___1);
  while (1) {
    if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& skey), 0, sizeof(DBT ));
    ret = ((*(sdbp->s_callback)))(sdbp, (DBT const   *)(& pkey), (DBT const   *)(& data),
                                  & skey);
    if (ret != 0) {
      if (ret == -30999) {
        goto __Cont;
      }
      if (skey.flags & 1U) {
        __os_ufree(sdbp->dbenv, skey.data);
        skey.flags = skey.flags & 4294967294U;
      }
      goto done;
    }
    ret = __db_cursor_int(sdbp, dbc->txn, sdbp->type, 0U, 0, dbc->locker, & sdbc);
    if (ret != 0) {
      goto done;
    }
    if ((sdbp->dbenv)->flags & 2U) {
      sdbc->flags = sdbc->flags | 256U;
    }
    memset((void *)(& tempskey), 0, sizeof(DBT ));
    tempskey.data = skey.data;
    tempskey.size = skey.size;
    memset((void *)(& temppkey), 0, sizeof(DBT ));
    temppkey.data = pkey.data;
    temppkey.size = pkey.size;
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          tmp = 268435456;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    ret = __db_c_get(sdbc, & tempskey, & temppkey, (unsigned int )(tmp | 10));
    if (ret == 0) {
      ret = __db_c_del(sdbc, 34U);
    } else {
      if (ret == -30990) {
        ret = __db_secondary_corrupt(dbp___1);
      }
    }
    if (skey.flags & 1U) {
      __os_ufree(sdbp->dbenv, skey.data);
      skey.flags = skey.flags & 4294967294U;
    }
    t_ret = __db_c_close(sdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret != 0) {
      goto done;
    }
    __Cont: 
    ret = __db_s_next(& sdbp);
  }
  done: 
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    t_ret = __db_s_done(sdbp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
DB *__db_s_first(DB *pdbp ) 
{ DB *sdbp ;

  {
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  sdbp = pdbp->s_secondaries.lh_first;
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    sdbp->s_refcnt = sdbp->s_refcnt + 1U;
  }
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  return (sdbp);
}
}
int __db_s_next(DB **sdbpp ) 
{ DB *sdbp ;
  DB *pdbp ;
  DB *closeme ;
  int ret ;

  {
  sdbp = (*sdbpp);
  pdbp = sdbp->s_primary;
  closeme = (DB *)((void *)0);
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  sdbp->s_refcnt = sdbp->s_refcnt - 1U;
  if (sdbp->s_refcnt == 0U) {
    while (1) {
      if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
        (sdbp->s_links.le_next)->s_links.le_prev = sdbp->s_links.le_prev;
      }
      (*(sdbp->s_links.le_prev)) = sdbp->s_links.le_next;
      break;
    }
    closeme = sdbp;
  }
  sdbp = sdbp->s_links.le_next;
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    sdbp->s_refcnt = sdbp->s_refcnt + 1U;
  }
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  (*sdbpp) = sdbp;
  if ((unsigned int )closeme != (unsigned int )((void *)0)) {
    ret = __db_close(closeme, (DB_TXN *)((void *)0), 0U);
  } else {
    ret = 0;
  }
  return (ret);
}
}
int __db_s_done(DB *sdbp ) 
{ DB *pdbp ;
  int doclose ;
  int tmp___0 ;

  {
  pdbp = sdbp->s_primary;
  doclose = 0;
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  sdbp->s_refcnt = sdbp->s_refcnt - 1U;
  if (sdbp->s_refcnt == 0U) {
    while (1) {
      if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
        (sdbp->s_links.le_next)->s_links.le_prev = sdbp->s_links.le_prev;
      }
      (*(sdbp->s_links.le_prev)) = sdbp->s_links.le_next;
      break;
    }
    doclose = 1;
  }
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  if (doclose) {
    tmp___0 = __db_close(sdbp, (DB_TXN *)((void *)0), 0U);
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int __db_buildpartial(DB *dbp___1 , DBT *oldrec , DBT *partial , DBT *newrec ) 
{ int ret ;
  u_int8_t *buf ;
  u_int32_t len ;
  u_int32_t nbytes ;
  int tmp ;
  u_int32_t tmp___0 ;

  {
  memset((void *)newrec, 0, sizeof(DBT ));
  nbytes = __db_partsize(oldrec->size, partial);
  newrec->size = nbytes;
  ret = __os_malloc(dbp___1->dbenv, nbytes, (void *)(& buf));
  if (ret != 0) {
    return (ret);
  }
  newrec->data = (void *)buf;
  if (dbp___1->flags & 4096U) {
    tmp = ((BTREE *)dbp___1->bt_internal)->re_pad;
  } else {
    tmp = 0;
  }
  memset((void *)buf, tmp, nbytes);
  if (partial->doff > oldrec->size) {
    tmp___0 = oldrec->size;
  } else {
    tmp___0 = partial->doff;
  }
  memcpy((void * __restrict  )buf, (void const   * __restrict  )oldrec->data, tmp___0);
  memcpy((void * __restrict  )(buf + partial->doff), (void const   * __restrict  )partial->data,
         partial->size);
  len = partial->doff + partial->dlen;
  if (oldrec->size > len) {
    memcpy((void * __restrict  )((buf + partial->doff) + partial->size), (void const   * __restrict  )((u_int8_t *)oldrec->data +
                                                                                                       len),
           oldrec->size - len);
  }
  return (0);
}
}
u_int32_t __db_partsize(u_int32_t nbytes , DBT *data ) 
{ 

  {
  if (nbytes < data->doff + data->dlen) {
    return (data->doff + data->size);
  }
  return ((nbytes + data->size) - data->dlen);
}
}
#pragma merger(0,"/tmp/cil-XfnWGROm.i","-O2")
int __db_check_chksum(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher , u_int8_t *chksum ,
                      void *data , size_t data_len , int is_hmac ) ;
int __db_pgin(DB_ENV *dbenv___0 , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB dummydb ;
  DB *dbp___1 ;
  DB_PGINFO *pginfo ;
  DB_CIPHER *db_cipher ;
  DB_LSN not_used ;
  PAGE *pagep ;
  size_t pg_off ;
  size_t pg_len ;
  size_t sum_len ;
  int is_hmac ;
  int ret ;
  u_int8_t *chksum ;
  u_int8_t *iv ;
  u_int32_t _tmp ;
  int tmp___0 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  pginfo = (DB_PGINFO *)cookie->data;
  pagep = (PAGE *)pp;
  is_hmac = 0;
  ret = is_hmac;
  iv = (u_int8_t *)((void *)0);
  chksum = iv;
  memset((void *)(& dummydb), 0, sizeof(DB ));
  dbp___1 = & dummydb;
  dummydb.flags = pginfo->flags;
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  switch ((int )pagep->type) {
  case 8: ;
  case 9: ;
  case 10: ;
  if ((int )((DBMETA *)pp)->metaflags & 1) {
    dbp___1->flags = dbp___1->flags | 1U;
  } else {
    dbp___1->flags = dbp___1->flags & 4294967294U;
  }
  if ((int )((DBMETA *)pp)->encrypt_alg != 0) {
    is_hmac = 1;
  } else {
    if (dbp___1->flags & 2048U) {
      is_hmac = 1;
    }
  }
  chksum = ((BTMETA *)pp)->chksum;
  sum_len = 512U;
  break;
  case 0: ;
  if (pagep->lsn.file == 0U) {
    if (pagep->pgno == 0U) {
      sum_len = 0U;
      break;
    }
  }
  default: ;
  if (dbp___1->flags & 2048U) {
    chksum = ((u_int8_t *)pagep + 26) + (int )((unsigned short )((unsigned int )(& ((PG_CRYPTO *)0)->chksum[0])));
  } else {
    if (dbp___1->flags & 1U) {
      chksum = ((u_int8_t *)pagep + 26) + (int )((unsigned short )((unsigned int )(& ((PG_CHKSUM *)0)->chksum[0])));
    } else {
      chksum = (u_int8_t *)((void *)0);
    }
  }
  sum_len = pginfo->db_pagesize;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    is_hmac = 1;
  } else {
    is_hmac = 0;
  }
  break;
  }
  if (dbp___1->flags & 1U) {
    if (sum_len != 0U) {
      if (dbp___1->flags & 268435456U) {
        if (is_hmac == 0) {
          (*((u_int8_t *)(& _tmp) + 0)) = (*(chksum + 0));
          (*((u_int8_t *)(& _tmp) + 1)) = (*(chksum + 1));
          (*((u_int8_t *)(& _tmp) + 2)) = (*(chksum + 2));
          (*((u_int8_t *)(& _tmp) + 3)) = (*(chksum + 3));
          (*(chksum + 0)) = (*((u_int8_t *)(& _tmp) + 3));
          (*(chksum + 1)) = (*((u_int8_t *)(& _tmp) + 2));
          (*(chksum + 2)) = (*((u_int8_t *)(& _tmp) + 1));
          (*(chksum + 3)) = (*((u_int8_t *)(& _tmp) + 0));
        }
      }
      ret = __db_check_chksum(dbenv___0, db_cipher, chksum, pp, sum_len, is_hmac);
      switch (ret) {
      case 0: ;
      break;
      case -1: ;
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)dbenv___0->rep_handle)->region) {
            if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
            if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
              __db_cksum_log(dbenv___0, (DB_TXN *)((void *)0), & not_used, 1U);
            }
          } else {
            __db_cksum_log(dbenv___0, (DB_TXN *)((void *)0), & not_used, 1U);
          }
        }
      }
      __db_err((DB_ENV const   *)dbenv___0, "checksum error: page %lu: catastrophic recovery required",
               (unsigned long )pg);
      tmp___0 = __db_panic(dbenv___0, -30978);
      return (tmp___0);
      default: ;
      return (ret);
      }
    }
  }
  if (dbp___1->flags & 2048U) {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    pg_off = (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                              26) +
                                                                             tmp___2))));
    switch ((int )pagep->type) {
    case 8: ;
    case 9: ;
    case 10: 
    iv = ((BTMETA *)pp)->iv;
    pg_len = 512U;
    break;
    case 0: ;
    if (pagep->lsn.file == 0U) {
      if (pagep->pgno == 0U) {
        pg_len = 0U;
        break;
      }
    }
    default: ;
    if (dbp___1->flags & 2048U) {
      iv = ((u_int8_t *)pagep + 26) + (int )((unsigned short )((unsigned int )(& ((PG_CRYPTO *)0)->iv[0])));
    } else {
      iv = (u_int8_t *)((void *)0);
    }
    pg_len = pginfo->db_pagesize;
    break;
    }
    if (pg_len != 0U) {
      ret = ((*(db_cipher->decrypt)))(dbenv___0, db_cipher->data, (void *)iv, (u_int8_t *)pagep +
                                                                              pg_off,
                                      pg_len - pg_off);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  switch ((int )pagep->type) {
  case 0: ;
  if ((int )pginfo->type == 4) {
    tmp___3 = __qam_pgin_out(dbenv___0, pg, pp, cookie);
    return (tmp___3);
  } else {
    tmp___4 = __ham_pgin(dbenv___0, dbp___1, pg, pp, cookie);
    return (tmp___4);
  }
  case 2: ;
  case 8: 
  tmp___5 = __ham_pgin(dbenv___0, dbp___1, pg, pp, cookie);
  return (tmp___5);
  case 9: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 12: ;
  case 6: ;
  case 7: 
  tmp___6 = __bam_pgin(dbenv___0, dbp___1, pg, pp, cookie);
  return (tmp___6);
  case 10: ;
  case 11: 
  tmp___7 = __qam_pgin_out(dbenv___0, pg, pp, cookie);
  return (tmp___7);
  default: ;
  break;
  }
  tmp___8 = __db_pgfmt(dbenv___0, pg);
  return (tmp___8);
}
}
int __db_pgout(DB_ENV *dbenv___0 , db_pgno_t pg , void *pp , DBT *cookie ) 
{ DB dummydb ;
  DB *dbp___1 ;
  DB_CIPHER *db_cipher ;
  DB_PGINFO *pginfo ;
  PAGE *pagep ;
  size_t pg_off ;
  size_t pg_len ;
  size_t sum_len ;
  int ret ;
  u_int8_t *chksum ;
  u_int8_t *iv ;
  u_int8_t *key ;
  int tmp ;
  unsigned int tmp___1 ;
  u_int32_t _tmp ;

  {
  pginfo = (DB_PGINFO *)cookie->data;
  pagep = (PAGE *)pp;
  key = (u_int8_t *)((void *)0);
  iv = key;
  chksum = iv;
  memset((void *)(& dummydb), 0, sizeof(DB ));
  dbp___1 = & dummydb;
  dummydb.flags = pginfo->flags;
  ret = 0;
  switch ((int )pagep->type) {
  case 0: ;
  if ((int )pginfo->type == 4) {
    ret = __qam_pgin_out(dbenv___0, pg, pp, cookie);
  } else {
    ret = __ham_pgout(dbenv___0, dbp___1, pg, pp, cookie);
  }
  break;
  case 2: ;
  case 8: 
  ret = __ham_pgout(dbenv___0, dbp___1, pg, pp, cookie);
  break;
  case 9: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 12: ;
  case 6: ;
  case 7: 
  ret = __bam_pgout(dbenv___0, dbp___1, pg, pp, cookie);
  break;
  case 10: ;
  case 11: 
  ret = __qam_pgin_out(dbenv___0, pg, pp, cookie);
  break;
  default: 
  tmp = __db_pgfmt(dbenv___0, pg);
  return (tmp);
  }
  if (ret) {
    return (ret);
  }
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if (dbp___1->flags & 2048U) {
    if (dbp___1->flags & 2048U) {
      tmp___1 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___1 = sizeof(PG_CHKSUM );
      } else {
        tmp___1 = 0U;
      }
    }
    pg_off = (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                              26) +
                                                                             tmp___1))));
    key = db_cipher->mac_key;
    switch ((int )pagep->type) {
    case 8: ;
    case 9: ;
    case 10: 
    iv = ((BTMETA *)pp)->iv;
    pg_len = 512U;
    break;
    default: ;
    if (dbp___1->flags & 2048U) {
      iv = ((u_int8_t *)pagep + 26) + (int )((unsigned short )((unsigned int )(& ((PG_CRYPTO *)0)->iv[0])));
    } else {
      iv = (u_int8_t *)((void *)0);
    }
    pg_len = pginfo->db_pagesize;
    break;
    }
    ret = ((*(db_cipher->encrypt)))(dbenv___0, db_cipher->data, (void *)iv, (u_int8_t *)pagep +
                                                                            pg_off,
                                    pg_len - pg_off);
    if (ret != 0) {
      return (ret);
    }
  }
  if (dbp___1->flags & 1U) {
    switch ((int )pagep->type) {
    case 8: ;
    case 9: ;
    case 10: 
    chksum = ((BTMETA *)pp)->chksum;
    sum_len = 512U;
    break;
    default: ;
    if (dbp___1->flags & 2048U) {
      chksum = ((u_int8_t *)pagep + 26) + (int )((unsigned short )((unsigned int )(& ((PG_CRYPTO *)0)->chksum[0])));
    } else {
      if (dbp___1->flags & 1U) {
        chksum = ((u_int8_t *)pagep + 26) + (int )((unsigned short )((unsigned int )(& ((PG_CHKSUM *)0)->chksum[0])));
      } else {
        chksum = (u_int8_t *)((void *)0);
      }
    }
    sum_len = pginfo->db_pagesize;
    break;
    }
    __db_chksum((u_int8_t *)pp, sum_len, key, chksum);
    if (dbp___1->flags & 268435456U) {
      if (! (dbp___1->flags & 2048U)) {
        (*((u_int8_t *)(& _tmp) + 0)) = (*(chksum + 0));
        (*((u_int8_t *)(& _tmp) + 1)) = (*(chksum + 1));
        (*((u_int8_t *)(& _tmp) + 2)) = (*(chksum + 2));
        (*((u_int8_t *)(& _tmp) + 3)) = (*(chksum + 3));
        (*(chksum + 0)) = (*((u_int8_t *)(& _tmp) + 3));
        (*(chksum + 1)) = (*((u_int8_t *)(& _tmp) + 2));
        (*(chksum + 2)) = (*((u_int8_t *)(& _tmp) + 1));
        (*(chksum + 3)) = (*((u_int8_t *)(& _tmp) + 0));
      }
    }
  }
  return (0);
}
}
void __db_metaswap(PAGE *pg ) 
{ u_int8_t *p ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int32_t _tmp___4 ;
  u_int32_t _tmp___5 ;
  u_int32_t _tmp___6 ;
  u_int32_t _tmp___7 ;
  u_int32_t _tmp___8 ;
  u_int32_t _tmp___9 ;
  u_int32_t _tmp___10 ;

  {
  p = (u_int8_t *)pg;
  (*((u_int8_t *)(& _tmp) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___0) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___0) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___0) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___0) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___1) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___1) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___1) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___1) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___2) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___2) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___2) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___2) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___2) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___2) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___2) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___2) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___3) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___3) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___3) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___3) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___3) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___3) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___3) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___3) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___4) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___4) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___4) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___4) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___4) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___4) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___4) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___4) + 0));
  p += sizeof(u_int32_t );
  p += 4;
  (*((u_int8_t *)(& _tmp___5) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___5) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___5) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___5) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___5) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___5) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___5) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___5) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___6) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___6) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___6) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___6) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___6) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___6) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___6) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___6) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___7) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___7) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___7) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___7) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___7) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___7) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___7) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___7) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___8) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___8) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___8) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___8) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___8) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___8) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___8) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___8) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___9) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___9) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___9) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___9) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___9) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___9) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___9) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___9) + 0));
  p += sizeof(u_int32_t );
  (*((u_int8_t *)(& _tmp___10) + 0)) = (*(p + 0));
  (*((u_int8_t *)(& _tmp___10) + 1)) = (*(p + 1));
  (*((u_int8_t *)(& _tmp___10) + 2)) = (*(p + 2));
  (*((u_int8_t *)(& _tmp___10) + 3)) = (*(p + 3));
  (*(p + 0)) = (*((u_int8_t *)(& _tmp___10) + 3));
  (*(p + 1)) = (*((u_int8_t *)(& _tmp___10) + 2));
  (*(p + 2)) = (*((u_int8_t *)(& _tmp___10) + 1));
  (*(p + 3)) = (*((u_int8_t *)(& _tmp___10) + 0));
  p += sizeof(u_int32_t );
  return;
}
}
int __db_byteswap(DB_ENV *dbenv___0 , DB *dbp___1 , db_pgno_t pg , PAGE *h , size_t pagesize ,
                  int pgin ) 
{ BINTERNAL *bi ;
  BKEYDATA *bk ;
  BOVERFLOW *bo ;
  RINTERNAL *ri ;
  db_indx_t i ;
  db_indx_t *inp ;
  db_indx_t len ;
  db_indx_t tmp ;
  u_int8_t *p ;
  u_int8_t *end ;
  unsigned int tmp___1 ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  u_int32_t _tmp___1 ;
  u_int32_t _tmp___2 ;
  u_int32_t _tmp___3 ;
  u_int16_t _tmp___4 ;
  u_int16_t _tmp___5 ;
  u_int16_t _tmp___6 ;
  unsigned int tmp___3 ;
  size_t tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  u_int16_t _tmp___7 ;
  u_int16_t _tmp___8 ;
  u_int16_t _tmp___9 ;
  unsigned int tmp___14 ;
  u_int32_t _tmp___10 ;
  unsigned int tmp___16 ;
  u_int32_t _tmp___11 ;
  u_int32_t _tmp___12 ;
  int tmp___17 ;
  u_int16_t _tmp___13 ;
  u_int16_t _tmp___14 ;
  u_int16_t _tmp___15 ;
  u_int16_t _tmp___16 ;
  unsigned int tmp___19 ;
  u_int16_t _tmp___17 ;
  u_int32_t _tmp___18 ;
  u_int32_t _tmp___19 ;
  int tmp___20 ;
  u_int16_t _tmp___20 ;
  u_int16_t _tmp___21 ;
  unsigned int tmp___22 ;
  u_int16_t _tmp___22 ;
  u_int32_t _tmp___23 ;
  u_int32_t _tmp___24 ;
  u_int32_t _tmp___25 ;
  u_int32_t _tmp___26 ;
  int tmp___23 ;
  u_int16_t _tmp___27 ;
  u_int16_t _tmp___28 ;
  unsigned int tmp___25 ;
  u_int32_t _tmp___29 ;
  u_int32_t _tmp___30 ;
  u_int16_t _tmp___31 ;
  int tmp___26 ;
  u_int32_t _tmp___32 ;
  u_int32_t _tmp___33 ;
  u_int32_t _tmp___34 ;
  u_int32_t _tmp___35 ;
  u_int32_t _tmp___36 ;
  u_int16_t _tmp___37 ;
  u_int16_t _tmp___38 ;

  {
  pg = 0U;
  pg = pg;
  if (dbp___1->flags & 2048U) {
    tmp___1 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___1 = sizeof(PG_CHKSUM );
    } else {
      tmp___1 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___1);
  if (pgin) {
    _tmp = h->lsn.file;
    (*((u_int8_t *)(& h->lsn.file) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
    (*((u_int8_t *)(& h->lsn.file) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
    (*((u_int8_t *)(& h->lsn.file) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
    (*((u_int8_t *)(& h->lsn.file) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
    _tmp___0 = h->lsn.offset;
    (*((u_int8_t *)(& h->lsn.offset) + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
    (*((u_int8_t *)(& h->lsn.offset) + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
    (*((u_int8_t *)(& h->lsn.offset) + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
    (*((u_int8_t *)(& h->lsn.offset) + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
    _tmp___1 = h->pgno;
    (*((u_int8_t *)(& h->pgno) + 0)) = (*((u_int8_t *)(& _tmp___1) + 3));
    (*((u_int8_t *)(& h->pgno) + 1)) = (*((u_int8_t *)(& _tmp___1) + 2));
    (*((u_int8_t *)(& h->pgno) + 2)) = (*((u_int8_t *)(& _tmp___1) + 1));
    (*((u_int8_t *)(& h->pgno) + 3)) = (*((u_int8_t *)(& _tmp___1) + 0));
    _tmp___2 = h->prev_pgno;
    (*((u_int8_t *)(& h->prev_pgno) + 0)) = (*((u_int8_t *)(& _tmp___2) + 3));
    (*((u_int8_t *)(& h->prev_pgno) + 1)) = (*((u_int8_t *)(& _tmp___2) + 2));
    (*((u_int8_t *)(& h->prev_pgno) + 2)) = (*((u_int8_t *)(& _tmp___2) + 1));
    (*((u_int8_t *)(& h->prev_pgno) + 3)) = (*((u_int8_t *)(& _tmp___2) + 0));
    _tmp___3 = h->next_pgno;
    (*((u_int8_t *)(& h->next_pgno) + 0)) = (*((u_int8_t *)(& _tmp___3) + 3));
    (*((u_int8_t *)(& h->next_pgno) + 1)) = (*((u_int8_t *)(& _tmp___3) + 2));
    (*((u_int8_t *)(& h->next_pgno) + 2)) = (*((u_int8_t *)(& _tmp___3) + 1));
    (*((u_int8_t *)(& h->next_pgno) + 3)) = (*((u_int8_t *)(& _tmp___3) + 0));
    _tmp___4 = h->entries;
    (*((u_int8_t *)(& h->entries) + 0)) = (*((u_int8_t *)(& _tmp___4) + 1));
    (*((u_int8_t *)(& h->entries) + 1)) = (*((u_int8_t *)(& _tmp___4) + 0));
    _tmp___5 = h->hf_offset;
    (*((u_int8_t *)(& h->hf_offset) + 0)) = (*((u_int8_t *)(& _tmp___5) + 1));
    (*((u_int8_t *)(& h->hf_offset) + 1)) = (*((u_int8_t *)(& _tmp___5) + 0));
  }
  switch ((int )h->type) {
  case 2: 
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    if (pgin) {
      _tmp___6 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___6) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___6) + 0));
    }
    if (dbp___1->flags & 2048U) {
      tmp___3 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___3 = sizeof(PG_CHKSUM );
      } else {
        tmp___3 = 0U;
      }
    }
    switch ((int )(*((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                            tmp___3) + (int )i))))) {
    case 1: ;
    break;
    case 2: ;
    if ((int )i == 0) {
      tmp___6 = pagesize;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___8 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___8 = sizeof(PG_CHKSUM );
        } else {
          tmp___8 = 0U;
        }
      }
      tmp___6 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___8) +
                                  ((int )i - 1)));
    }
    if (dbp___1->flags & 2048U) {
      tmp___10 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___10 = sizeof(PG_CHKSUM );
      } else {
        tmp___10 = 0U;
      }
    }
    len = (unsigned short )((tmp___6 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                        26) + tmp___10) +
                                                         (int )i))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))));
    if (dbp___1->flags & 2048U) {
      tmp___12 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___12 = sizeof(PG_CHKSUM );
      } else {
        tmp___12 = 0U;
      }
    }
    p = ((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___12) +
                                  (int )i))) + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
    end = p + (int )len;
    while ((unsigned int )p < (unsigned int )end) {
      if (pgin) {
        (*((u_int8_t *)(& _tmp___7) + 0)) = (*(p + 0));
        (*((u_int8_t *)(& _tmp___7) + 1)) = (*(p + 1));
        (*(p + 0)) = (*((u_int8_t *)(& _tmp___7) + 1));
        (*(p + 1)) = (*((u_int8_t *)(& _tmp___7) + 0));
        memcpy((void * __restrict  )(& tmp), (void const   * __restrict  )p, sizeof(db_indx_t ));
        p += sizeof(db_indx_t );
      } else {
        memcpy((void * __restrict  )(& tmp), (void const   * __restrict  )p, sizeof(db_indx_t ));
        (*((u_int8_t *)(& _tmp___8) + 0)) = (*(p + 0));
        (*((u_int8_t *)(& _tmp___8) + 1)) = (*(p + 1));
        (*(p + 0)) = (*((u_int8_t *)(& _tmp___8) + 1));
        (*(p + 1)) = (*((u_int8_t *)(& _tmp___8) + 0));
        p += sizeof(u_int16_t );
      }
      p += (int )tmp;
      (*((u_int8_t *)(& _tmp___9) + 0)) = (*(p + 0));
      (*((u_int8_t *)(& _tmp___9) + 1)) = (*(p + 1));
      (*(p + 0)) = (*((u_int8_t *)(& _tmp___9) + 1));
      (*(p + 1)) = (*((u_int8_t *)(& _tmp___9) + 0));
      p += sizeof(u_int16_t );
    }
    break;
    case 4: ;
    if (dbp___1->flags & 2048U) {
      tmp___14 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___14 = sizeof(PG_CHKSUM );
      } else {
        tmp___14 = 0U;
      }
    }
    p = ((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___14) +
                                  (int )i))) + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)));
    (*((u_int8_t *)(& _tmp___10) + 0)) = (*(p + 0));
    (*((u_int8_t *)(& _tmp___10) + 1)) = (*(p + 1));
    (*((u_int8_t *)(& _tmp___10) + 2)) = (*(p + 2));
    (*((u_int8_t *)(& _tmp___10) + 3)) = (*(p + 3));
    (*(p + 0)) = (*((u_int8_t *)(& _tmp___10) + 3));
    (*(p + 1)) = (*((u_int8_t *)(& _tmp___10) + 2));
    (*(p + 2)) = (*((u_int8_t *)(& _tmp___10) + 1));
    (*(p + 3)) = (*((u_int8_t *)(& _tmp___10) + 0));
    p += sizeof(u_int32_t );
    break;
    case 3: ;
    if (dbp___1->flags & 2048U) {
      tmp___16 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___16 = sizeof(PG_CHKSUM );
      } else {
        tmp___16 = 0U;
      }
    }
    p = ((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___16) +
                                  (int )i))) + (int )((unsigned short )((unsigned int )(& ((HOFFPAGE *)0)->pgno)));
    (*((u_int8_t *)(& _tmp___11) + 0)) = (*(p + 0));
    (*((u_int8_t *)(& _tmp___11) + 1)) = (*(p + 1));
    (*((u_int8_t *)(& _tmp___11) + 2)) = (*(p + 2));
    (*((u_int8_t *)(& _tmp___11) + 3)) = (*(p + 3));
    (*(p + 0)) = (*((u_int8_t *)(& _tmp___11) + 3));
    (*(p + 1)) = (*((u_int8_t *)(& _tmp___11) + 2));
    (*(p + 2)) = (*((u_int8_t *)(& _tmp___11) + 1));
    (*(p + 3)) = (*((u_int8_t *)(& _tmp___11) + 0));
    p += sizeof(u_int32_t );
    (*((u_int8_t *)(& _tmp___12) + 0)) = (*(p + 0));
    (*((u_int8_t *)(& _tmp___12) + 1)) = (*(p + 1));
    (*((u_int8_t *)(& _tmp___12) + 2)) = (*(p + 2));
    (*((u_int8_t *)(& _tmp___12) + 3)) = (*(p + 3));
    (*(p + 0)) = (*((u_int8_t *)(& _tmp___12) + 3));
    (*(p + 1)) = (*((u_int8_t *)(& _tmp___12) + 2));
    (*(p + 2)) = (*((u_int8_t *)(& _tmp___12) + 1));
    (*(p + 3)) = (*((u_int8_t *)(& _tmp___12) + 0));
    p += sizeof(u_int32_t );
    break;
    default: 
    tmp___17 = __db_pgfmt(dbenv___0, pg);
    return (tmp___17);
    }
    i = (unsigned short )((int )i + 1);
  }
  if (! pgin) {
    i = (unsigned short)0;
    while ((int )i < (int )h->entries) {
      _tmp___13 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___13) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___13) + 0));
      i = (unsigned short )((int )i + 1);
    }
  }
  break;
  case 5: ;
  case 12: ;
  case 6: 
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    if (pgin) {
      _tmp___14 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___14) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___14) + 0));
    }
    if ((int )h->type == 5) {
      if ((int )i > 1) {
        if (pgin) {
          if ((int )(*(inp + (int )i)) == (int )(*(inp + ((int )i - 2)))) {
            goto __Cont;
          }
        } else {
          _tmp___15 = (*(inp + (int )i));
          (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___15) + 1));
          (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___15) + 0));
          if ((int )(*(inp + (int )i)) == (int )(*(inp + ((int )i - 2)))) {
            goto __Cont;
          }
          _tmp___16 = (*(inp + (int )i));
          (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___16) + 1));
          (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___16) + 0));
        }
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___19 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___19 = sizeof(PG_CHKSUM );
      } else {
        tmp___19 = 0U;
      }
    }
    bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                             tmp___19) + (int )i)));
    switch ((int )bk->type & -129) {
    case 1: 
    _tmp___17 = bk->len;
    (*((u_int8_t *)(& bk->len) + 0)) = (*((u_int8_t *)(& _tmp___17) + 1));
    (*((u_int8_t *)(& bk->len) + 1)) = (*((u_int8_t *)(& _tmp___17) + 0));
    break;
    case 2: ;
    case 3: 
    bo = (BOVERFLOW *)bk;
    _tmp___18 = bo->pgno;
    (*((u_int8_t *)(& bo->pgno) + 0)) = (*((u_int8_t *)(& _tmp___18) + 3));
    (*((u_int8_t *)(& bo->pgno) + 1)) = (*((u_int8_t *)(& _tmp___18) + 2));
    (*((u_int8_t *)(& bo->pgno) + 2)) = (*((u_int8_t *)(& _tmp___18) + 1));
    (*((u_int8_t *)(& bo->pgno) + 3)) = (*((u_int8_t *)(& _tmp___18) + 0));
    _tmp___19 = bo->tlen;
    (*((u_int8_t *)(& bo->tlen) + 0)) = (*((u_int8_t *)(& _tmp___19) + 3));
    (*((u_int8_t *)(& bo->tlen) + 1)) = (*((u_int8_t *)(& _tmp___19) + 2));
    (*((u_int8_t *)(& bo->tlen) + 2)) = (*((u_int8_t *)(& _tmp___19) + 1));
    (*((u_int8_t *)(& bo->tlen) + 3)) = (*((u_int8_t *)(& _tmp___19) + 0));
    break;
    default: 
    tmp___20 = __db_pgfmt(dbenv___0, pg);
    return (tmp___20);
    }
    if (! pgin) {
      _tmp___20 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___20) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___20) + 0));
    }
    __Cont: 
    i = (unsigned short )((int )i + 1);
  }
  break;
  case 3: 
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    if (pgin) {
      _tmp___21 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___21) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___21) + 0));
    }
    if (dbp___1->flags & 2048U) {
      tmp___22 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___22 = sizeof(PG_CHKSUM );
      } else {
        tmp___22 = 0U;
      }
    }
    bi = (BINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___22) + (int )i)));
    _tmp___22 = bi->len;
    (*((u_int8_t *)(& bi->len) + 0)) = (*((u_int8_t *)(& _tmp___22) + 1));
    (*((u_int8_t *)(& bi->len) + 1)) = (*((u_int8_t *)(& _tmp___22) + 0));
    _tmp___23 = bi->pgno;
    (*((u_int8_t *)(& bi->pgno) + 0)) = (*((u_int8_t *)(& _tmp___23) + 3));
    (*((u_int8_t *)(& bi->pgno) + 1)) = (*((u_int8_t *)(& _tmp___23) + 2));
    (*((u_int8_t *)(& bi->pgno) + 2)) = (*((u_int8_t *)(& _tmp___23) + 1));
    (*((u_int8_t *)(& bi->pgno) + 3)) = (*((u_int8_t *)(& _tmp___23) + 0));
    _tmp___24 = bi->nrecs;
    (*((u_int8_t *)(& bi->nrecs) + 0)) = (*((u_int8_t *)(& _tmp___24) + 3));
    (*((u_int8_t *)(& bi->nrecs) + 1)) = (*((u_int8_t *)(& _tmp___24) + 2));
    (*((u_int8_t *)(& bi->nrecs) + 2)) = (*((u_int8_t *)(& _tmp___24) + 1));
    (*((u_int8_t *)(& bi->nrecs) + 3)) = (*((u_int8_t *)(& _tmp___24) + 0));
    switch ((int )bi->type & -129) {
    case 1: ;
    break;
    case 2: ;
    case 3: 
    bo = (BOVERFLOW *)(bi->data);
    _tmp___25 = bo->pgno;
    (*((u_int8_t *)(& bo->pgno) + 0)) = (*((u_int8_t *)(& _tmp___25) + 3));
    (*((u_int8_t *)(& bo->pgno) + 1)) = (*((u_int8_t *)(& _tmp___25) + 2));
    (*((u_int8_t *)(& bo->pgno) + 2)) = (*((u_int8_t *)(& _tmp___25) + 1));
    (*((u_int8_t *)(& bo->pgno) + 3)) = (*((u_int8_t *)(& _tmp___25) + 0));
    _tmp___26 = bo->tlen;
    (*((u_int8_t *)(& bo->tlen) + 0)) = (*((u_int8_t *)(& _tmp___26) + 3));
    (*((u_int8_t *)(& bo->tlen) + 1)) = (*((u_int8_t *)(& _tmp___26) + 2));
    (*((u_int8_t *)(& bo->tlen) + 2)) = (*((u_int8_t *)(& _tmp___26) + 1));
    (*((u_int8_t *)(& bo->tlen) + 3)) = (*((u_int8_t *)(& _tmp___26) + 0));
    break;
    default: 
    tmp___23 = __db_pgfmt(dbenv___0, pg);
    return (tmp___23);
    }
    if (! pgin) {
      _tmp___27 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___27) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___27) + 0));
    }
    i = (unsigned short )((int )i + 1);
  }
  break;
  case 4: 
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    if (pgin) {
      _tmp___28 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___28) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___28) + 0));
    }
    if (dbp___1->flags & 2048U) {
      tmp___25 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___25 = sizeof(PG_CHKSUM );
      } else {
        tmp___25 = 0U;
      }
    }
    ri = (RINTERNAL *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                              tmp___25) + (int )i)));
    _tmp___29 = ri->pgno;
    (*((u_int8_t *)(& ri->pgno) + 0)) = (*((u_int8_t *)(& _tmp___29) + 3));
    (*((u_int8_t *)(& ri->pgno) + 1)) = (*((u_int8_t *)(& _tmp___29) + 2));
    (*((u_int8_t *)(& ri->pgno) + 2)) = (*((u_int8_t *)(& _tmp___29) + 1));
    (*((u_int8_t *)(& ri->pgno) + 3)) = (*((u_int8_t *)(& _tmp___29) + 0));
    _tmp___30 = ri->nrecs;
    (*((u_int8_t *)(& ri->nrecs) + 0)) = (*((u_int8_t *)(& _tmp___30) + 3));
    (*((u_int8_t *)(& ri->nrecs) + 1)) = (*((u_int8_t *)(& _tmp___30) + 2));
    (*((u_int8_t *)(& ri->nrecs) + 2)) = (*((u_int8_t *)(& _tmp___30) + 1));
    (*((u_int8_t *)(& ri->nrecs) + 3)) = (*((u_int8_t *)(& _tmp___30) + 0));
    if (! pgin) {
      _tmp___31 = (*(inp + (int )i));
      (*((u_int8_t *)(inp + (int )i) + 0)) = (*((u_int8_t *)(& _tmp___31) + 1));
      (*((u_int8_t *)(inp + (int )i) + 1)) = (*((u_int8_t *)(& _tmp___31) + 0));
    }
    i = (unsigned short )((int )i + 1);
  }
  break;
  case 7: ;
  case 0: ;
  break;
  default: 
  tmp___26 = __db_pgfmt(dbenv___0, pg);
  return (tmp___26);
  }
  if (! pgin) {
    _tmp___32 = h->lsn.file;
    (*((u_int8_t *)(& h->lsn.file) + 0)) = (*((u_int8_t *)(& _tmp___32) + 3));
    (*((u_int8_t *)(& h->lsn.file) + 1)) = (*((u_int8_t *)(& _tmp___32) + 2));
    (*((u_int8_t *)(& h->lsn.file) + 2)) = (*((u_int8_t *)(& _tmp___32) + 1));
    (*((u_int8_t *)(& h->lsn.file) + 3)) = (*((u_int8_t *)(& _tmp___32) + 0));
    _tmp___33 = h->lsn.offset;
    (*((u_int8_t *)(& h->lsn.offset) + 0)) = (*((u_int8_t *)(& _tmp___33) + 3));
    (*((u_int8_t *)(& h->lsn.offset) + 1)) = (*((u_int8_t *)(& _tmp___33) + 2));
    (*((u_int8_t *)(& h->lsn.offset) + 2)) = (*((u_int8_t *)(& _tmp___33) + 1));
    (*((u_int8_t *)(& h->lsn.offset) + 3)) = (*((u_int8_t *)(& _tmp___33) + 0));
    _tmp___34 = h->pgno;
    (*((u_int8_t *)(& h->pgno) + 0)) = (*((u_int8_t *)(& _tmp___34) + 3));
    (*((u_int8_t *)(& h->pgno) + 1)) = (*((u_int8_t *)(& _tmp___34) + 2));
    (*((u_int8_t *)(& h->pgno) + 2)) = (*((u_int8_t *)(& _tmp___34) + 1));
    (*((u_int8_t *)(& h->pgno) + 3)) = (*((u_int8_t *)(& _tmp___34) + 0));
    _tmp___35 = h->prev_pgno;
    (*((u_int8_t *)(& h->prev_pgno) + 0)) = (*((u_int8_t *)(& _tmp___35) + 3));
    (*((u_int8_t *)(& h->prev_pgno) + 1)) = (*((u_int8_t *)(& _tmp___35) + 2));
    (*((u_int8_t *)(& h->prev_pgno) + 2)) = (*((u_int8_t *)(& _tmp___35) + 1));
    (*((u_int8_t *)(& h->prev_pgno) + 3)) = (*((u_int8_t *)(& _tmp___35) + 0));
    _tmp___36 = h->next_pgno;
    (*((u_int8_t *)(& h->next_pgno) + 0)) = (*((u_int8_t *)(& _tmp___36) + 3));
    (*((u_int8_t *)(& h->next_pgno) + 1)) = (*((u_int8_t *)(& _tmp___36) + 2));
    (*((u_int8_t *)(& h->next_pgno) + 2)) = (*((u_int8_t *)(& _tmp___36) + 1));
    (*((u_int8_t *)(& h->next_pgno) + 3)) = (*((u_int8_t *)(& _tmp___36) + 0));
    _tmp___37 = h->entries;
    (*((u_int8_t *)(& h->entries) + 0)) = (*((u_int8_t *)(& _tmp___37) + 1));
    (*((u_int8_t *)(& h->entries) + 1)) = (*((u_int8_t *)(& _tmp___37) + 0));
    _tmp___38 = h->hf_offset;
    (*((u_int8_t *)(& h->hf_offset) + 0)) = (*((u_int8_t *)(& _tmp___38) + 1));
    (*((u_int8_t *)(& h->hf_offset) + 1)) = (*((u_int8_t *)(& _tmp___38) + 0));
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-MNQWLCac.i","-O2")
int __db_txnlist_remove(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid ) ;
void __db_txnlist_ckp(DB_ENV *dbenv___0 , void *listp , DB_LSN *ckp_lsn ) ;
int __db_txnlist_update(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid , int32_t status ,
                        DB_LSN *lsn ) ;
int __db_txnlist_gen(DB_ENV *dbenv___0 , void *listp , int incr , u_int32_t min ,
                     u_int32_t max ) ;
int __db_txnlist_lsnadd(DB_ENV *dbenv___0 , void *listp , DB_LSN *lsnp , u_int32_t flags ) ;
int __db_txnlist_lsninit(DB_ENV *dbenv___0 , DB_TXNHEAD *hp , DB_LSN *lsnp ) ;
int __db_do_the_limbo(DB_ENV *dbenv___0 , DB_TXN *ptxn , DB_TXN *txn , DB_TXNHEAD *hp ,
                      db_limbo_state state ) ;
int __db_default_getpgnos(DB_ENV *dbenv___0 , DB_LSN *lsnp , void *summary ) ;
int __dbreg_id_to_fname(DB_LOG *dblp , int32_t lid , int have_lock , FNAME **fnamep ) ;
int __txn_compensate_begin(DB_ENV *dbenv___0 , DB_TXN **txnpp ) ;
int __txn_commit(DB_TXN *txnp , u_int32_t flags ) ;
static int __db_limbo_fix(DB *dbp___1 , DB_TXN *ctxn , DB_TXNLIST *elp , db_pgno_t *lastp ,
                          DBMETA *meta , db_limbo_state state ) ;
static int __db_limbo_bucket(DB_ENV *dbenv___0 , DB_TXN *txn , DB_TXNLIST *elp , db_limbo_state state ) ;
static int __db_limbo_move(DB_ENV *dbenv___0 , DB_TXN *ptxn , DB_TXN *txn , DB_TXNLIST *elp ) ;
static int __db_limbo_prepare(DB *dbp___1 , DB_TXN *txn , DB_TXNLIST *elp ) ;
static int __db_lock_move(DB_ENV *dbenv___0 , u_int8_t *fileid , db_pgno_t pgno ,
                          db_lockmode_t mode , DB_TXN *ptxn , DB_TXN *txn ) ;
static int __db_txnlist_find_internal(DB_ENV *dbenv___0 , void *listp , db_txnlist_type type ,
                                      u_int32_t txnid , u_int8_t *uid , DB_TXNLIST **txnlistp ,
                                      int delete ) ;
static int __db_txnlist_pgnoadd(DB_ENV *dbenv___0 , DB_TXNHEAD *hp , int32_t fileid ,
                                u_int8_t *uid , char *fname , db_pgno_t pgno ) ;
int __db_dispatch(DB_ENV *dbenv___0 , int (**dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  ,
                                                   void * ) , size_t dtabsize , DBT *db ,
                  DB_LSN *lsnp , db_recops redo , void *info ) 
{ DB_LSN prev_lsn ;
  u_int32_t rectype ;
  u_int32_t txnid ;
  int make_call ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )db->data,
         sizeof(rectype));
  memcpy((void * __restrict  )(& txnid), (void const   * __restrict  )((u_int8_t *)db->data +
                                                                       sizeof(rectype)),
         sizeof(txnid));
  ret = 0;
  make_call = ret;
  switch ((int )redo) {
  case 0: ;
  case 1: ;
  case 8: 
  make_call = 1;
  break;
  case 6: 
  memcpy((void * __restrict  )(& prev_lsn), (void const   * __restrict  )(((u_int8_t *)db->data +
                                                                           sizeof(rectype)) +
                                                                          sizeof(txnid)),
         sizeof(prev_lsn));
  if (txnid != 0U) {
    if (prev_lsn.file == 0U) {
      ret = __db_txnlist_add(dbenv___0, info, txnid, 0, (DB_LSN *)((void *)0));
      if (ret != 0) {
        return (ret);
      }
    }
  }
  case 7: ;
  if (rectype == 2U) {
    tmp = ((*((*(dtab + rectype)))))(dbenv___0, db, lsnp, redo, info);
    return (tmp);
  } else {
    if (rectype == 12U) {
      tmp = ((*((*(dtab + rectype)))))(dbenv___0, db, lsnp, redo, info);
      return (tmp);
    } else {
      if (rectype == 11U) {
        tmp = ((*((*(dtab + rectype)))))(dbenv___0, db, lsnp, redo, info);
        return (tmp);
      } else {
        if (rectype == 14U) {
          tmp = ((*((*(dtab + rectype)))))(dbenv___0, db, lsnp, redo, info);
          return (tmp);
        }
      }
    }
  }
  break;
  case 3: ;
  switch ((int )rectype) {
  case 10: ;
  case 14: ;
  case 11: ;
  case 48: ;
  case 141: ;
  case 12: 
  make_call = 1;
  break;
  case 2: ;
  if (txnid == 0U) {
    make_call = 1;
    break;
  }
  default: ;
  if (txnid != 0U) {
    ret = __db_txnlist_find(dbenv___0, info, txnid);
    if (ret != 1) {
      if (ret != 5) {
        if (ret == 4) {
          tmp___0 = __db_txnlist_add(dbenv___0, info, txnid, 5, lsnp);
          return (tmp___0);
        }
        make_call = 1;
        if (ret == 0) {
          if (rectype == 13U) {
            tmp___1 = 2;
          } else {
            tmp___1 = 3;
          }
          ret = __db_txnlist_update(dbenv___0, info, txnid, tmp___1, (DB_LSN *)((void *)0));
          if (ret != 0) {
            return (ret);
          }
        }
      }
    }
  }
  }
  break;
  case 4: ;
  switch ((int )rectype) {
  case 14: ;
  case 11: ;
  case 48: 
  make_call = 1;
  break;
  default: ;
  if (txnid != 0U) {
    ret = __db_txnlist_find(dbenv___0, info, txnid);
    if (ret == 1) {
      make_call = 1;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (ret != 5) {
      if (rectype == 29U) {
        make_call = 1;
        redo = (enum __anonenum_db_recops_55 )2;
      } else {
        if (rectype == 32U) {
          make_call = 1;
          redo = (enum __anonenum_db_recops_55 )2;
        } else {
          if (rectype == 49U) {
            make_call = 1;
            redo = (enum __anonenum_db_recops_55 )2;
          } else {
            goto _L;
          }
        }
      }
    } else {
      _L: 
      if (rectype == 2U) {
        if (txnid == 0U) {
          make_call = 1;
        }
      }
    }
  }
  }
  break;
  case 5: ;
  if (rectype < 10000U) {
    make_call = 1;
    break;
  }
  tmp___2 = __db_default_getpgnos(dbenv___0, lsnp, info);
  return (tmp___2);
  case 2: ;
  default: 
  tmp___3 = __db_unknown_flag(dbenv___0, (char *)"__db_dispatch", (unsigned int )redo);
  return (tmp___3);
  }
  ret = 0;
  if (make_call) {
    if (rectype & 2147483648U) {
      if ((int )redo == 8) {
        rectype &= 2147483647U;
      } else {
        memcpy((void * __restrict  )lsnp, (void const   * __restrict  )(((u_int8_t *)db->data +
                                                                         sizeof(rectype)) +
                                                                        sizeof(txnid)),
               sizeof((*lsnp)));
        return (0);
      }
    }
    if (rectype >= 10000U) {
      if ((unsigned int )dbenv___0->app_dispatch != (unsigned int )((void *)0)) {
        tmp___4 = ((*(dbenv___0->app_dispatch)))(dbenv___0, db, lsnp, redo);
        return (tmp___4);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (rectype > dtabsize) {
        __db_err((DB_ENV const   *)dbenv___0, "Illegal record type %lu in log", (unsigned long )rectype);
        return (22);
      } else {
        if ((unsigned int )(*(dtab + rectype)) == (unsigned int )((void *)0)) {
          __db_err((DB_ENV const   *)dbenv___0, "Illegal record type %lu in log",
                   (unsigned long )rectype);
          return (22);
        }
      }
      tmp___5 = ((*((*(dtab + rectype)))))(dbenv___0, db, lsnp, redo, info);
      return (tmp___5);
    }
  }
  return (0);
}
}
int __db_add_recovery(DB_ENV *dbenv___0 , int (***dtab)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsize ,
                      int (*func)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ,
                      u_int32_t ndx ) 
{ size_t i ;
  size_t nsize ;
  int ret ;

  {
  if (ndx >= (*dtabsize)) {
    nsize = ndx + 40U;
    ret = __os_realloc(dbenv___0, nsize * sizeof((*((*dtab) + 0))), (void *)dtab);
    if (ret != 0) {
      return (ret);
    }
    i = (*dtabsize);
    while (i < nsize) {
      (*((*dtab) + i)) = (int (*)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ))((void *)0);
      i ++;
    }
    (*dtabsize) = nsize;
  }
  (*((*dtab) + ndx)) = func;
  return (0);
}
}
int __db_txnlist_init(DB_ENV *dbenv___0 , u_int32_t low_txn , u_int32_t hi_txn , DB_LSN *trunc_lsn ,
                      void *retp ) 
{ DB_TXNHEAD *headp ;
  u_int32_t size ;
  u_int32_t tmp ;
  int ret ;

  {
  if (low_txn == 0U) {
    size = 1U;
  } else {
    if (hi_txn < low_txn) {
      tmp = hi_txn;
      hi_txn = low_txn;
      low_txn = tmp;
    }
    tmp = hi_txn - low_txn;
    if (tmp > 1073741823U) {
      tmp = (low_txn - 2147483648U) + (4294967295U - hi_txn);
    }
    size = tmp / 5U;
    if (size < 100U) {
      size = 100U;
    }
  }
  ret = __os_malloc(dbenv___0, sizeof(DB_TXNHEAD ) + size * sizeof(headp->head), (void *)(& headp));
  if (ret != 0) {
    return (ret);
  }
  memset((void *)headp, 0, sizeof(DB_TXNHEAD ) + size * sizeof(headp->head));
  headp->maxid = hi_txn;
  headp->generation = 0U;
  headp->nslots = size;
  headp->gen_alloc = 8U;
  ret = __os_malloc(dbenv___0, headp->gen_alloc * sizeof((*(headp->gen_array + 0))),
                    (void *)(& headp->gen_array));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)headp);
    return (ret);
  }
  (headp->gen_array + 0)->generation = 0U;
  (headp->gen_array + 0)->txn_min = 2147483648U;
  (headp->gen_array + 0)->txn_max = 4294967295U;
  if ((unsigned int )trunc_lsn != (unsigned int )((void *)0)) {
    headp->trunc_lsn = (*trunc_lsn);
    headp->maxlsn = (*trunc_lsn);
  } else {
    while (1) {
      headp->trunc_lsn.file = 0U;
      headp->trunc_lsn.offset = 0U;
      break;
    }
    while (1) {
      headp->maxlsn.file = 0U;
      headp->maxlsn.offset = 0U;
      break;
    }
  }
  while (1) {
    headp->ckplsn.file = 0U;
    headp->ckplsn.offset = 0U;
    break;
  }
  (*((void **)retp)) = (void *)headp;
  return (0);
}
}
int __db_txnlist_add(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid , int32_t status ,
                     DB_LSN *lsn ) 
{ DB_TXNHEAD *hp ;
  DB_TXNLIST *elp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(DB_TXNLIST ), (void *)(& elp));
  if (ret != 0) {
    return (ret);
  }
  hp = (DB_TXNHEAD *)listp;
  while (1) {
    elp->links.le_next = hp->head[txnid % hp->nslots].lh_first;
    if ((unsigned int )elp->links.le_next != (unsigned int )((void *)0)) {
      (hp->head[txnid % hp->nslots].lh_first)->links.le_prev = & elp->links.le_next;
    }
    hp->head[txnid % hp->nslots].lh_first = elp;
    elp->links.le_prev = & hp->head[txnid % hp->nslots].lh_first;
    break;
  }
  elp->type = (enum __anonenum_db_txnlist_type_54 )3;
  elp->u.t.txnid = txnid;
  elp->u.t.status = status;
  elp->u.t.generation = hp->generation;
  if (txnid > hp->maxid) {
    hp->maxid = txnid;
  }
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    if (hp->maxlsn.file == 0U) {
      if (status == 1) {
        hp->maxlsn = (*lsn);
      }
    }
  }
  return (0);
}
}
int __db_txnlist_remove(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid ) 
{ DB_TXNLIST *entry ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = __db_txnlist_find_internal(dbenv___0, listp, (enum __anonenum_db_txnlist_type_54 )3,
                                       txnid, (u_int8_t *)((void *)0), & entry, 1);
  if (tmp___1 == 4) {
    tmp___0 = 4;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
void __db_txnlist_ckp(DB_ENV *dbenv___0 , void *listp , DB_LSN *ckp_lsn ) 
{ DB_TXNHEAD *hp ;
  int tmp ;

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  hp = (DB_TXNHEAD *)listp;
  if (hp->ckplsn.file == 0U) {
    if (! (hp->maxlsn.file == 0U)) {
      tmp = log_compare((DB_LSN const   *)(& hp->maxlsn), (DB_LSN const   *)ckp_lsn);
      if (tmp >= 0) {
        hp->ckplsn = (*ckp_lsn);
      }
    }
  }
  return;
}
}
void __db_txnlist_end(DB_ENV *dbenv___0 , void *listp ) 
{ DB_TXNHEAD *hp ;
  DB_TXNLIST *p ;
  u_int32_t i ;

  {
  hp = (DB_TXNHEAD *)listp;
  if ((unsigned int )hp == (unsigned int )((void *)0)) {
    return;
  }
  i = 0U;
  while (i < hp->nslots) {
    while (1) {
      if ((unsigned int )hp != (unsigned int )((void *)0)) {
        p = hp->head[i].lh_first;
        if (! ((unsigned int )p != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      while (1) {
        if ((unsigned int )p->links.le_next != (unsigned int )((void *)0)) {
          (p->links.le_next)->links.le_prev = p->links.le_prev;
        }
        (*(p->links.le_prev)) = p->links.le_next;
        break;
      }
      switch ((int )p->type) {
      case 1: 
      __os_free(dbenv___0, (void *)p->u.l.lsn_array);
      break;
      case 0: ;
      case 2: ;
      case 3: ;
      default: ;
      break;
      }
      __os_free(dbenv___0, (void *)p);
    }
    i ++;
  }
  if ((unsigned int )hp->gen_array != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)hp->gen_array);
  }
  __os_free(dbenv___0, listp);
  return;
}
}
int __db_txnlist_find(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid ) 
{ DB_TXNLIST *entry ;
  int tmp ;

  {
  if (txnid == 0U) {
    return (4);
  }
  tmp = __db_txnlist_find_internal(dbenv___0, listp, (enum __anonenum_db_txnlist_type_54 )3,
                                   txnid, (u_int8_t *)((void *)0), & entry, 0);
  return (tmp);
}
}
int __db_txnlist_update(DB_ENV *dbenv___0 , void *listp , u_int32_t txnid , int32_t status ,
                        DB_LSN *lsn ) 
{ DB_TXNHEAD *hp ;
  DB_TXNLIST *elp ;
  int ret ;

  {
  if (txnid == 0U) {
    return (4);
  }
  hp = (DB_TXNHEAD *)listp;
  ret = __db_txnlist_find_internal(dbenv___0, listp, (enum __anonenum_db_txnlist_type_54 )3,
                                   txnid, (u_int8_t *)((void *)0), & elp, 0);
  if (ret == 4) {
    return (ret);
  } else {
    if (ret == 5) {
      return (ret);
    }
  }
  elp->u.t.status = status;
  if ((unsigned int )lsn != (unsigned int )((void *)0)) {
    if (hp->maxlsn.file == 0U) {
      if (status == 1) {
        hp->maxlsn = (*lsn);
      }
    }
  }
  return (ret);
}
}
static int __db_txnlist_find_internal(DB_ENV *dbenv___0 , void *listp , db_txnlist_type type ,
                                      u_int32_t txnid , u_int8_t *uid , DB_TXNLIST **txnlistp ,
                                      int delete ) 
{ struct __db_headlink *head ;
  DB_TXNHEAD *hp ;
  DB_TXNLIST *p ;
  u_int32_t generation ;
  u_int32_t hash ;
  u_int32_t i ;
  int ret ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  hp = (DB_TXNHEAD *)listp;
  if ((unsigned int )hp == (unsigned int )((void *)0)) {
    return (4);
  }
  switch ((int )type) {
  case 3: 
  hash = txnid;
  i = 0U;
  while (i <= hp->generation) {
    if ((hp->gen_array + i)->txn_min < (hp->gen_array + i)->txn_max) {
      if (txnid >= (hp->gen_array + i)->txn_min) {
        if (txnid <= (hp->gen_array + i)->txn_max) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      tmp___1 = tmp___2;
    } else {
      if (txnid >= (hp->gen_array + i)->txn_min) {
        tmp___3 = 1;
      } else {
        if (txnid <= (hp->gen_array + i)->txn_max) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      }
      tmp___1 = tmp___3;
    }
    if (tmp___1) {
      break;
    }
    i ++;
  }
  generation = (hp->gen_array + i)->generation;
  break;
  case 2: 
  memcpy((void * __restrict  )(& hash), (void const   * __restrict  )uid, sizeof(hash));
  generation = 0U;
  break;
  case 0: ;
  case 1: ;
  default: ;
  return (22);
  }
  head = & hp->head[hash % hp->nslots];
  p = head->lh_first;
  while ((unsigned int )p != (unsigned int )((void *)0)) {
    if ((int )p->type != (int )type) {
      goto __Cont;
    }
    switch ((int )type) {
    case 3: ;
    if (p->u.t.txnid != txnid) {
      goto __Cont;
    } else {
      if (generation != p->u.t.generation) {
        goto __Cont;
      }
    }
    ret = p->u.t.status;
    break;
    case 2: 
    tmp___4 = memcmp((void const   *)uid, (void const   *)(p->u.p.uid), 20U);
    if (tmp___4 != 0) {
      goto __Cont;
    }
    ret = 0;
    break;
    case 0: ;
    case 1: ;
    default: 
    ret = 22;
    }
    if (delete == 1) {
      while (1) {
        if ((unsigned int )p->links.le_next != (unsigned int )((void *)0)) {
          (p->links.le_next)->links.le_prev = p->links.le_prev;
        }
        (*(p->links.le_prev)) = p->links.le_next;
        break;
      }
      __os_free(dbenv___0, (void *)p);
    } else {
      if ((unsigned int )p != (unsigned int )head->lh_first) {
        while (1) {
          if ((unsigned int )p->links.le_next != (unsigned int )((void *)0)) {
            (p->links.le_next)->links.le_prev = p->links.le_prev;
          }
          (*(p->links.le_prev)) = p->links.le_next;
          break;
        }
        while (1) {
          p->links.le_next = head->lh_first;
          if ((unsigned int )p->links.le_next != (unsigned int )((void *)0)) {
            (head->lh_first)->links.le_prev = & p->links.le_next;
          }
          head->lh_first = p;
          p->links.le_prev = & head->lh_first;
          break;
        }
      }
    }
    (*txnlistp) = p;
    return (ret);
    __Cont: 
    p = p->links.le_next;
  }
  return (4);
}
}
int __db_txnlist_gen(DB_ENV *dbenv___0 , void *listp , int incr , u_int32_t min ,
                     u_int32_t max ) 
{ DB_TXNHEAD *hp ;
  int ret ;

  {
  hp = (DB_TXNHEAD *)listp;
  if (incr < 0) {
    hp->generation = hp->generation - 1U;
    memmove((void *)hp->gen_array, (void const   *)(hp->gen_array + 1), (hp->generation +
                                                                         1U) * sizeof((*(hp->gen_array +
                                                                                         0))));
  } else {
    hp->generation = hp->generation + 1U;
    if (hp->generation >= hp->gen_alloc) {
      hp->gen_alloc = hp->gen_alloc * 2U;
      ret = __os_realloc(dbenv___0, hp->gen_alloc * sizeof((*(hp->gen_array + 0))),
                         (void *)(& hp->gen_array));
      if (ret != 0) {
        return (ret);
      }
    }
    memmove((void *)(hp->gen_array + 1), (void const   *)(hp->gen_array + 0), hp->generation *
                                                                              sizeof((*(hp->gen_array +
                                                                                        0))));
    (hp->gen_array + 0)->generation = hp->generation;
    (hp->gen_array + 0)->txn_min = min;
    (hp->gen_array + 0)->txn_max = max;
  }
  return (0);
}
}
int __db_txnlist_lsnadd(DB_ENV *dbenv___0 , void *listp , DB_LSN *lsnp , u_int32_t flags ) 
{ DB_TXNHEAD *hp ;
  DB_TXNLIST *elp ;
  u_int32_t i ;
  int ret ;
  u_int32_t tmp ;
  DB_LSN __tmp ;
  u_int32_t __j ;
  int tmp___0 ;
  u_int32_t tmp___1 ;

  {
  hp = (DB_TXNHEAD *)listp;
  elp = hp->head[0].lh_first;
  while ((unsigned int )elp != (unsigned int )((void *)0)) {
    if ((int )elp->type == 1) {
      break;
    }
    elp = elp->links.le_next;
  }
  if ((unsigned int )elp == (unsigned int )((void *)0)) {
    return (-30895);
  }
  if (flags & 1U) {
    if (elp->u.l.ntxns >= elp->u.l.maxn) {
      ret = __os_realloc(dbenv___0, (2U * elp->u.l.maxn) * sizeof(DB_LSN ), (void *)(& elp->u.l.lsn_array));
      if (ret != 0) {
        return (ret);
      }
      elp->u.l.maxn = elp->u.l.maxn * 2U;
    }
    tmp = elp->u.l.ntxns;
    elp->u.l.ntxns = elp->u.l.ntxns + 1U;
    (*(elp->u.l.lsn_array + tmp)) = (*lsnp);
  } else {
    (*(elp->u.l.lsn_array + 0)) = (*lsnp);
  }
  i = 0U;
  while (1) {
    if (! (flags & 1U)) {
      tmp___1 = 1U;
    } else {
      tmp___1 = elp->u.l.ntxns;
    }
    if (! (i < tmp___1)) {
      break;
    }
    __j = 0U;
    while (__j < elp->u.l.ntxns - 1U) {
      tmp___0 = log_compare((DB_LSN const   *)(elp->u.l.lsn_array + __j), (DB_LSN const   *)(elp->u.l.lsn_array +
                                                                                             (__j +
                                                                                              1U)));
      if (tmp___0 < 0) {
        __tmp = (*(elp->u.l.lsn_array + __j));
        (*(elp->u.l.lsn_array + __j)) = (*(elp->u.l.lsn_array + (__j + 1U)));
        (*(elp->u.l.lsn_array + (__j + 1U))) = __tmp;
      }
      __j ++;
    }
    i ++;
  }
  (*lsnp) = (*(elp->u.l.lsn_array + 0));
  return (0);
}
}
int __db_txnlist_lsninit(DB_ENV *dbenv___0 , DB_TXNHEAD *hp , DB_LSN *lsnp ) 
{ DB_TXNLIST *elp ;
  int ret ;

  {
  elp = (DB_TXNLIST *)((void *)0);
  ret = __os_malloc(dbenv___0, sizeof(DB_TXNLIST ), (void *)(& elp));
  if (ret != 0) {
    goto err;
  }
  while (1) {
    elp->links.le_next = hp->head[0].lh_first;
    if ((unsigned int )elp->links.le_next != (unsigned int )((void *)0)) {
      (hp->head[0].lh_first)->links.le_prev = & elp->links.le_next;
    }
    hp->head[0].lh_first = elp;
    elp->links.le_prev = & hp->head[0].lh_first;
    break;
  }
  ret = __os_malloc(dbenv___0, 12U * sizeof(DB_LSN ), (void *)(& elp->u.l.lsn_array));
  if (ret != 0) {
    goto err;
  }
  elp->type = (enum __anonenum_db_txnlist_type_54 )1;
  elp->u.l.maxn = 12U;
  elp->u.l.ntxns = 1U;
  (*(elp->u.l.lsn_array + 0)) = (*lsnp);
  return (0);
  err: 
  __db_txnlist_end(dbenv___0, (void *)hp);
  return (ret);
}
}
int __db_add_limbo(DB_ENV *dbenv___0 , void *info , int32_t fileid , db_pgno_t pgno ,
                   int32_t count ) 
{ DB_LOG *dblp ;
  FNAME *fnp ;
  int ret ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  ret = __dbreg_id_to_fname(dblp, fileid, 0, & fnp);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    ret = __db_txnlist_pgnoadd(dbenv___0, (DB_TXNHEAD *)info, fileid, fnp->ufid, (char *)((void *)((u_int8_t *)dblp->reginfo.addr +
                                                                                                   fnp->name_off)),
                               pgno);
    if (ret != 0) {
      return (ret);
    }
    pgno ++;
    count --;
    if (! (count != 0)) {
      break;
    }
  }
  return (0);
}
}
int __db_do_the_limbo(DB_ENV *dbenv___0 , DB_TXN *ptxn , DB_TXN *txn , DB_TXNHEAD *hp ,
                      db_limbo_state state ) 
{ DB_TXNLIST *elp ;
  u_int32_t h ;
  int ret ;

  {
  ret = 0;
  h = 0U;
  while (h < hp->nslots) {
    elp = hp->head[h].lh_first;
    if ((unsigned int )elp == (unsigned int )((void *)0)) {
      goto __Cont;
    }
    if ((unsigned int )ptxn != (unsigned int )((void *)0)) {
      ret = __db_limbo_move(dbenv___0, ptxn, txn, elp);
      if (ret != 0) {
        goto err;
      }
    } else {
      ret = __db_limbo_bucket(dbenv___0, txn, elp, state);
      if (ret != 0) {
        goto err;
      }
    }
    __Cont: 
    h ++;
  }
  err: 
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Fatal error in abort of an allocation");
    ret = __db_panic(dbenv___0, ret);
  }
  return (ret);
}
}
static int __db_lock_move(DB_ENV *dbenv___0 , u_int8_t *fileid , db_pgno_t pgno ,
                          db_lockmode_t mode , DB_TXN *ptxn , DB_TXN *txn ) 
{ DBT lock_dbt ;
  DB_LOCK lock ;
  DB_LOCK_ILOCK lock_obj ;
  DB_LOCKREQ req ;
  int ret ;

  {
  lock_obj.pgno = pgno;
  memcpy((void * __restrict  )(lock_obj.fileid), (void const   * __restrict  )fileid,
         20U);
  lock_obj.type = 3U;
  memset((void *)(& lock_dbt), 0, sizeof(lock_dbt));
  lock_dbt.data = (void *)(& lock_obj);
  lock_dbt.size = sizeof(lock_obj);
  ret = __lock_get(dbenv___0, txn->txnid, 0U, (DBT const   *)(& lock_dbt), mode, & lock);
  if (ret == 0) {
    memset((void *)(& req), 0, sizeof(req));
    req.lock = lock;
    req.op = (enum __anonenum_db_lockop_t_51 )9;
    ret = __lock_vec(dbenv___0, ptxn->txnid, 0U, & req, 1, (DB_LOCKREQ **)((void *)0));
  }
  return (ret);
}
}
static int __db_limbo_move(DB_ENV *dbenv___0 , DB_TXN *ptxn , DB_TXN *txn , DB_TXNLIST *elp ) 
{ int ret ;

  {
  while ((unsigned int )elp != (unsigned int )((void *)0)) {
    if ((int )elp->type != 2) {
      goto __Cont;
    } else {
      if (elp->u.p.locked == 1) {
        goto __Cont;
      }
    }
    ret = __db_lock_move(dbenv___0, elp->u.p.uid, 0U, (enum __anonenum_db_lockmode_t_50 )2,
                         ptxn, txn);
    if (ret != 0) {
      return (ret);
    }
    elp->u.p.locked = 1;
    __Cont: 
    elp = elp->links.le_next;
  }
  return (0);
}
}
static int __db_limbo_bucket(DB_ENV *dbenv___0 , DB_TXN *txn , DB_TXNLIST *elp , db_limbo_state state ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  DBMETA *meta ;
  DB_TXN *ctxn ;
  DB_TXN *t ;
  db_pgno_t last_pgno ;
  db_pgno_t pgno ;
  int dbp_created ;
  int in_retry ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  ctxn = (DB_TXN *)((void *)0);
  in_retry = 0;
  meta = (DBMETA *)((void *)0);
  mpf = (DB_MPOOLFILE *)((void *)0);
  ret = 0;
  while ((unsigned int )elp != (unsigned int )((void *)0)) {
    if ((int )elp->type != 2) {
      goto __Cont;
    }
    retry: 
    dbp_created = 0;
    if ((int )state == 1) {
      ctxn = txn;
    } else {
      if (! in_retry) {
        if ((int )state != 2) {
          if ((int )state != 3) {
            if ((unsigned int )txn != (unsigned int )((void *)0)) {
              if (! (txn->flags & 128U)) {
                goto _L;
              }
            } else {
              _L: 
              ret = __txn_compensate_begin(dbenv___0, & ctxn);
              if (ret != 0) {
                return (ret);
              }
            }
          }
        }
      }
    }
    if ((unsigned int )ctxn == (unsigned int )((void *)0)) {
      t = txn;
    } else {
      t = ctxn;
    }
    ret = __dbreg_id_to_db(dbenv___0, t, & dbp___1, elp->u.p.fileid, 0);
    if (ret == -30898) {
      goto next;
    } else {
      if (ret == 0) {
        if (dbp___1->flags & 256U) {
          goto next;
        }
      }
    }
    if (ret != 0) {
      ret = db_create(& dbp___1, dbenv___0, 0U);
      if (ret != 0) {
        goto err;
      }
      dbp___1->flags = dbp___1->flags | 4U;
      dbp_created = 1;
      tmp = __db_omode("rw----");
      ret = __db_open(dbp___1, t, (char const   *)elp->u.p.fname, (char const   *)((void *)0),
                      (enum __anonenum_DBTYPE_61 )5, 16384U, tmp, 0U);
      if (ret == 2) {
        goto next;
      }
    }
    tmp___0 = memcmp((void const   *)(elp->u.p.uid), (void const   *)(dbp___1->fileid),
                     20U);
    if (tmp___0 != 0) {
      goto next;
    }
    mpf = dbp___1->mpf;
    last_pgno = 0U;
    if ((unsigned int )ctxn == (unsigned int )((void *)0)) {
      goto _L___0;
    } else {
      if ((int )state == 4) {
        _L___0: 
        pgno = 0U;
        ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
        if (ret != 0) {
          goto err;
        }
        last_pgno = meta->free;
      }
    }
    if ((int )state == 1) {
      ret = __db_limbo_prepare(dbp___1, ctxn, elp);
      if (ret != 0) {
        goto err;
      }
    } else {
      ret = __db_limbo_fix(dbp___1, ctxn, elp, & last_pgno, meta, state);
    }
    if (ret != 0) {
      if (ret == -30978) {
        goto err;
      } else {
        if ((unsigned int )ctxn == (unsigned int )((void *)0)) {
          goto err;
        }
      }
      in_retry = 1;
      goto retry;
    }
    if ((int )state == 1) {
      ctxn = (DB_TXN *)((void *)0);
    } else {
      if ((unsigned int )ctxn != (unsigned int )((void *)0)) {
        if ((int )state == 4) {
          ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags &
                                                    4294967294U;
        }
        ret = __txn_commit(ctxn, 256U);
        ctxn = (DB_TXN *)((void *)0);
        if ((int )state == 4) {
          ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags |
                                                    1U;
        }
        if (ret != 0) {
          goto retry;
        }
      } else {
        if (last_pgno == meta->free) {
          ret = __memp_fput(mpf, (void *)meta, 0U);
          if (ret != 0) {
            goto err;
          }
          meta = (DBMETA *)((void *)0);
        } else {
          if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
            if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
              goto _L___1;
            }
          } else {
            _L___1: 
            if ((unsigned int )txn != (unsigned int )((void *)0)) {
              if (! (txn->flags & 128U)) {
                __db_err((DB_ENV const   *)dbenv___0, "Flushing free list to disk");
              }
            } else {
              __db_err((DB_ENV const   *)dbenv___0, "Flushing free list to disk");
            }
          }
          ret = __memp_fput(mpf, (void *)meta, 0U);
          if (ret != 0) {
            goto err;
          }
          meta = (DBMETA *)((void *)0);
          ret = __db_sync(dbp___1);
          if (ret != 0) {
            goto err;
          }
          pgno = 0U;
          ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
          if (ret != 0) {
            goto err;
          }
          meta->free = last_pgno;
          ret = __memp_fput(mpf, (void *)meta, 2U);
          if (ret != 0) {
            goto err;
          }
          meta = (DBMETA *)((void *)0);
        }
      }
    }
    next: 
    if ((unsigned int )ctxn != (unsigned int )((void *)0)) {
      t_ret = __txn_abort(ctxn);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    if (dbp_created) {
      t_ret = __db_close(dbp___1, txn, 23U);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    dbp___1 = (DB *)((void *)0);
    if ((int )state != 1) {
      if ((int )state != 3) {
        __os_free(dbenv___0, (void *)elp->u.p.fname);
        __os_free(dbenv___0, (void *)elp->u.p.pgno_array);
      }
    }
    if (ret == 2) {
      ret = 0;
    } else {
      if (ret != 0) {
        goto err;
      }
    }
    __Cont: 
    elp = elp->links.le_next;
  }
  err: 
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, 0U);
  }
  return (ret);
}
}
static int __db_limbo_fix(DB *dbp___1 , DB_TXN *ctxn , DB_TXNLIST *elp , db_pgno_t *lastp ,
                          DBMETA *meta , db_limbo_state state ) 
{ DBC *dbc ;
  DBT ldbt ;
  DB_MPOOLFILE *mpf ;
  PAGE *freep ;
  PAGE *pagep ;
  db_pgno_t next ;
  db_pgno_t pgno ;
  u_int32_t i ;
  int put_page ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;

  {
  dbc = (DBC *)((void *)0);
  mpf = dbp___1->mpf;
  pagep = (PAGE *)((void *)0);
  ret = 0;
  put_page = ret;
  i = 0U;
  while (i < elp->u.p.nentries) {
    pgno = (*(elp->u.p.pgno_array + i));
    if (pgno == 0U) {
      goto __Cont;
    }
    ret = __memp_fget(mpf, & pgno, 1U, (void *)(& pagep));
    if (ret != 0) {
      if (ret != 28) {
        goto err;
      }
      goto __Cont;
    }
    put_page = 1;
    if ((int )state == 4) {
      goto _L;
    } else {
      if (pagep->lsn.file == 0U) {
        _L: 
        if ((unsigned int )ctxn == (unsigned int )((void *)0)) {
          next = (*lastp);
          while (next != 0U) {
            if (next == pgno) {
              break;
            }
            ret = __memp_fget(mpf, & next, 0U, (void *)(& freep));
            if (ret != 0) {
              goto err;
            }
            next = freep->next_pgno;
            ret = __memp_fput(mpf, (void *)freep, 0U);
            if (ret != 0) {
              goto err;
            }
          }
          if (next != pgno) {
            while (1) {
              pagep->pgno = pgno;
              pagep->prev_pgno = 0U;
              pagep->next_pgno = (*lastp);
              pagep->entries = (unsigned short)0;
              pagep->hf_offset = (unsigned short )dbp___1->pgsize;
              pagep->level = (unsigned char)0;
              pagep->type = (unsigned char)0;
              break;
            }
            while (1) {
              pagep->lsn.file = 1U;
              pagep->lsn.offset = 0U;
              break;
            }
            (*lastp) = pgno;
          }
        } else {
          if ((int )state == 4) {
            while (1) {
              pagep->lsn.file = 0U;
              pagep->lsn.offset = 0U;
              break;
            }
            memset((void *)(& ldbt), 0, sizeof(ldbt));
            ldbt.data = (void *)pagep;
            if (dbp___1->flags & 2048U) {
              tmp___0 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___0 = sizeof(PG_CHKSUM );
              } else {
                tmp___0 = 0U;
              }
            }
            ldbt.size = (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                         26) +
                                                                                        tmp___0))));
            ret = __db_pg_new_log(dbp___1, ctxn, & ((PAGE *)meta)->lsn, 0U, pagep->pgno,
                                  & ((PAGE *)meta)->lsn, 0U, (DBT const   *)(& ldbt),
                                  pagep->next_pgno);
            if (ret != 0) {
              goto err;
            }
          } else {
            if ((unsigned int )dbc == (unsigned int )((void *)0)) {
              ret = __db_cursor(dbp___1, ctxn, & dbc, 0U);
              if (ret != 0) {
                goto err;
              }
            }
            dbc->flags = dbc->flags | 2U;
            ret = __db_free(dbc, pagep);
            put_page = 0;
            if (ret != 0) {
              __db_c_close(dbc);
              dbc = (DBC *)((void *)0);
              goto err;
            }
          }
        }
      } else {
        (*(elp->u.p.pgno_array + i)) = 0U;
      }
    }
    if (put_page == 1) {
      ret = __memp_fput(mpf, (void *)pagep, 2U);
      put_page = 0;
    }
    if (ret != 0) {
      goto err;
    }
    __Cont: 
    i ++;
  }
  err: 
  if (put_page) {
    t_ret = __memp_fput(mpf, (void *)pagep, 2U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
static int __db_limbo_prepare(DB *dbp___1 , DB_TXN *txn , DB_TXNLIST *elp ) 
{ DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  u_int32_t i ;
  int ret ;
  int t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  ret = 0;
  mpf = dbp___1->mpf;
  i = 0U;
  while (i < elp->u.p.nentries) {
    pgno = (*(elp->u.p.pgno_array + i));
    ret = __memp_fget(mpf, & pgno, 1U, (void *)(& pagep));
    if (ret != 0) {
      if (ret != 28) {
        return (ret);
      }
      goto __Cont;
    }
    if (pagep->lsn.file == 0U) {
      ret = __db_pg_prepare_log(dbp___1, txn, & lsn, 0U, pgno);
    }
    t_ret = __memp_fput(mpf, (void *)pagep, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret != 0) {
      return (ret);
    }
    __Cont: 
    i ++;
  }
  return (0);
}
}
static int __db_txnlist_pgnoadd(DB_ENV *dbenv___0 , DB_TXNHEAD *hp , int32_t fileid ,
                                u_int8_t *uid , char *fname , db_pgno_t pgno ) 
{ DB_TXNLIST *elp ;
  size_t len ;
  u_int32_t hash ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  u_int32_t tmp___1 ;

  {
  elp = (DB_TXNLIST *)((void *)0);
  tmp___0 = __db_txnlist_find_internal(dbenv___0, (void *)hp, (enum __anonenum_db_txnlist_type_54 )2,
                                       0U, uid, & elp, 0);
  if (tmp___0 != 0) {
    ret = __os_malloc(dbenv___0, sizeof(DB_TXNLIST ), (void *)(& elp));
    if (ret != 0) {
      goto err;
    }
    memcpy((void * __restrict  )(& hash), (void const   * __restrict  )uid, sizeof(hash));
    while (1) {
      elp->links.le_next = hp->head[hash % hp->nslots].lh_first;
      if ((unsigned int )elp->links.le_next != (unsigned int )((void *)0)) {
        (hp->head[hash % hp->nslots].lh_first)->links.le_prev = & elp->links.le_next;
      }
      hp->head[hash % hp->nslots].lh_first = elp;
      elp->links.le_prev = & hp->head[hash % hp->nslots].lh_first;
      break;
    }
    elp->u.p.fileid = fileid;
    memcpy((void * __restrict  )(elp->u.p.uid), (void const   * __restrict  )uid,
           20U);
    tmp = strlen((char const   *)fname);
    len = tmp + 1U;
    ret = __os_malloc(dbenv___0, len, (void *)(& elp->u.p.fname));
    if (ret != 0) {
      goto err;
    }
    memcpy((void * __restrict  )elp->u.p.fname, (void const   * __restrict  )fname,
           len);
    elp->u.p.maxentry = 0U;
    elp->u.p.locked = 0;
    elp->type = (enum __anonenum_db_txnlist_type_54 )2;
    ret = __os_malloc(dbenv___0, 8U * sizeof(db_pgno_t ), (void *)(& elp->u.p.pgno_array));
    if (ret != 0) {
      goto err;
    }
    elp->u.p.maxentry = 8U;
    elp->u.p.nentries = 0U;
  } else {
    if (elp->u.p.nentries == elp->u.p.maxentry) {
      elp->u.p.maxentry = elp->u.p.maxentry << 1;
      ret = __os_realloc(dbenv___0, elp->u.p.maxentry * sizeof(db_pgno_t ), (void *)(& elp->u.p.pgno_array));
      if (ret != 0) {
        goto err;
      }
    }
  }
  tmp___1 = elp->u.p.nentries;
  elp->u.p.nentries = elp->u.p.nentries + 1U;
  (*(elp->u.p.pgno_array + tmp___1)) = pgno;
  return (0);
  err: 
  __db_txnlist_end(dbenv___0, (void *)hp);
  return (ret);
}
}
int __db_default_getpgnos(DB_ENV *dbenv___0 , DB_LSN *lsnp , void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-9JDfEZ9j.i","-O2")
int __db_ditem(DBC *dbc , PAGE *pagep , u_int32_t indx , u_int32_t nbytes ) 
{ DB *dbp___1 ;
  DBT ldbt ;
  db_indx_t cnt ;
  db_indx_t *inp ;
  db_indx_t offset ;
  int ret ;
  u_int8_t *from ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if (dbp___1->flags & 2048U) {
            tmp___0 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___0 = sizeof(PG_CHKSUM );
            } else {
              tmp___0 = 0U;
            }
          }
          ldbt.data = (void *)((u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep +
                                                                           26) + tmp___0) +
                                                            indx)));
          ldbt.size = nbytes;
          ret = __db_addrem_log(dbp___1, dbc->txn, & pagep->lsn, 0U, 2U, pagep->pgno,
                                indx, nbytes, (DBT const   *)(& ldbt), (DBT const   *)((void *)0),
                                & pagep->lsn);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      pagep->lsn.file = 0U;
      pagep->lsn.offset = 1U;
      break;
    }
  }
  if ((int )pagep->entries == 1) {
    pagep->entries = (unsigned short)0;
    pagep->hf_offset = (unsigned short )dbp___1->pgsize;
    return (0);
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___2);
  from = (u_int8_t *)pagep + (int )pagep->hf_offset;
  memmove((void *)(from + nbytes), (void const   *)from, (unsigned int )((int )(*(inp +
                                                                                  indx)) -
                                                                         (int )pagep->hf_offset));
  pagep->hf_offset = (unsigned short )((unsigned int )pagep->hf_offset + nbytes);
  offset = (*(inp + indx));
  cnt = (unsigned short)0;
  while ((int )cnt < (int )pagep->entries) {
    if ((int )(*(inp + (int )cnt)) < (int )offset) {
      (*(inp + (int )cnt)) = (unsigned short )((unsigned int )(*(inp + (int )cnt)) +
                                               nbytes);
    }
    cnt = (unsigned short )((int )cnt + 1);
  }
  pagep->entries = (unsigned short )((int )pagep->entries - 1);
  if (indx != (unsigned int )pagep->entries) {
    memmove((void *)(inp + indx), (void const   *)(inp + (indx + 1U)), sizeof(db_indx_t ) *
                                                                       ((unsigned int )pagep->entries -
                                                                        indx));
  }
  return (0);
}
}
int __db_pitem(DBC *dbc , PAGE *pagep , u_int32_t indx , u_int32_t nbytes , DBT *hdr ,
               DBT *data ) 
{ DB *dbp___1 ;
  BKEYDATA bk ;
  DBT thdr ;
  db_indx_t *inp ;
  int ret ;
  u_int8_t *p ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;

  {
  dbp___1 = dbc->dbp;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  if (nbytes > (unsigned int )pagep->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                   26) +
                                                                                                                  tmp___0)))) +
                                                  (unsigned int )pagep->entries *
                                                  sizeof(db_indx_t ))) {
    return (22);
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __db_addrem_log(dbp___1, dbc->txn, & pagep->lsn, 0U, 1U, pagep->pgno,
                                indx, nbytes, (DBT const   *)hdr, (DBT const   *)data,
                                & pagep->lsn);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      pagep->lsn.file = 0U;
      pagep->lsn.offset = 1U;
      break;
    }
  }
  if ((unsigned int )hdr == (unsigned int )((void *)0)) {
    bk.type = (unsigned char)1;
    if ((unsigned int )data == (unsigned int )((void *)0)) {
      bk.len = (unsigned short)0;
    } else {
      bk.len = (unsigned short )data->size;
    }
    thdr.data = (void *)(& bk);
    thdr.size = (unsigned int )((unsigned short )((unsigned int )(& ((BKEYDATA *)0)->data[0])));
    hdr = & thdr;
  }
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___2);
  if (indx != (unsigned int )pagep->entries) {
    memmove((void *)(inp + (indx + 1U)), (void const   *)(inp + indx), sizeof(db_indx_t ) *
                                                                       ((unsigned int )pagep->entries -
                                                                        indx));
  }
  pagep->hf_offset = (unsigned short )((unsigned int )pagep->hf_offset - nbytes);
  (*(inp + indx)) = pagep->hf_offset;
  pagep->entries = (unsigned short )((int )pagep->entries + 1);
  if (dbp___1->flags & 2048U) {
    tmp___4 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___4 = sizeof(PG_CHKSUM );
    } else {
      tmp___4 = 0U;
    }
  }
  p = (u_int8_t *)pagep + (int )(*((db_indx_t *)(((u_int8_t *)pagep + 26) + tmp___4) +
                                   indx));
  memcpy((void * __restrict  )p, (void const   * __restrict  )hdr->data, hdr->size);
  if ((unsigned int )data != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )(p + hdr->size), (void const   * __restrict  )data->data,
           data->size);
  }
  return (0);
}
}
int __db_relink(DBC *dbc , u_int32_t add_rem , PAGE *pagep , PAGE **new_next , int needlock ) 
{ DB *dbp___1 ;
  PAGE *np ;
  PAGE *pp ;
  DB_LOCK npl ;
  DB_LOCK ppl ;
  DB_LSN *nlsnp ;
  DB_LSN *plsnp ;
  DB_LSN ret_lsn ;
  DB_MPOOLFILE *mpf ;
  int ret ;

  {
  dbp___1 = dbc->dbp;
  pp = (PAGE *)((void *)0);
  np = pp;
  npl.off = 0U;
  ppl.off = 0U;
  plsnp = (DB_LSN *)((void *)0);
  nlsnp = plsnp;
  mpf = dbp___1->mpf;
  ret = 0;
  if (pagep->next_pgno != 0U) {
    if (needlock) {
      ret = __db_lget(dbc, 0, pagep->next_pgno, (enum __anonenum_db_lockmode_t_50 )2,
                      0U, & npl);
      if (ret != 0) {
        goto err;
      }
    }
    ret = __memp_fget(mpf, & pagep->next_pgno, 0U, (void *)(& np));
    if (ret != 0) {
      ret = __db_pgerr(dbp___1, pagep->next_pgno, ret);
      goto err;
    }
    nlsnp = & np->lsn;
  }
  if (add_rem == 6U) {
    if (pagep->prev_pgno != 0U) {
      if (needlock) {
        ret = __db_lget(dbc, 0, pagep->prev_pgno, (enum __anonenum_db_lockmode_t_50 )2,
                        0U, & ppl);
        if (ret != 0) {
          goto err;
        }
      }
      ret = __memp_fget(mpf, & pagep->prev_pgno, 0U, (void *)(& pp));
      if (ret != 0) {
        ret = __db_pgerr(dbp___1, pagep->prev_pgno, ret);
        goto err;
      }
      plsnp = & pp->lsn;
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __db_relink_log(dbp___1, dbc->txn, & ret_lsn, 0U, add_rem, pagep->pgno,
                                & pagep->lsn, pagep->prev_pgno, plsnp, pagep->next_pgno,
                                nlsnp);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      ret_lsn.file = 0U;
      ret_lsn.offset = 1U;
      break;
    }
  }
  if ((unsigned int )np != (unsigned int )((void *)0)) {
    np->lsn = ret_lsn;
  }
  if ((unsigned int )pp != (unsigned int )((void *)0)) {
    pp->lsn = ret_lsn;
  }
  if (add_rem == 6U) {
    pagep->lsn = ret_lsn;
  }
  if ((unsigned int )np != (unsigned int )((void *)0)) {
    if (add_rem == 5U) {
      np->prev_pgno = pagep->pgno;
    } else {
      np->prev_pgno = pagep->prev_pgno;
    }
    if ((unsigned int )new_next == (unsigned int )((void *)0)) {
      ret = __memp_fput(mpf, (void *)np, 2U);
    } else {
      (*new_next) = np;
      ret = __memp_fset(mpf, (void *)np, 2U);
    }
    if (ret != 0) {
      goto err;
    }
    if (needlock) {
      if (npl.off != 0U) {
        __db_lput(dbc, & npl);
      }
    }
  } else {
    if ((unsigned int )new_next != (unsigned int )((void *)0)) {
      (*new_next) = (PAGE *)((void *)0);
    }
  }
  if ((unsigned int )pp != (unsigned int )((void *)0)) {
    pp->next_pgno = pagep->next_pgno;
    ret = __memp_fput(mpf, (void *)pp, 2U);
    if (ret != 0) {
      goto err;
    }
    if (needlock) {
      if (ppl.off != 0U) {
        __db_lput(dbc, & ppl);
      }
    }
  }
  return (0);
  err: 
  if ((unsigned int )np != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)np, 0U);
  }
  if (needlock) {
    if (npl.off != 0U) {
      __db_lput(dbc, & npl);
    }
  }
  if ((unsigned int )pp != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pp, 0U);
  }
  if (needlock) {
    if (ppl.off != 0U) {
      __db_lput(dbc, & ppl);
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-SV6MctRe.i","-O2")
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int vsnprintf(char * __restrict  __s , size_t __maxlen ,
                                                   char const   * __restrict  __format ,
                                                   __gnuc_va_list __arg ) ;
int __db_fnl(DB_ENV const   *dbenv___0 , char const   *name ) ;
void __db_errcall(DB_ENV const   *dbenv___0 , int error , int error_set , char const   *fmt ,
                  va_list ap ) ;
void __db_errfile(DB_ENV const   *dbenv___0 , int error , int error_set , char const   *fmt ,
                  va_list ap ) ;
void __db_logmsg(DB_ENV const   *dbenv___0 , DB_TXN *txnid , char const   *opname ,
                 u_int32_t flags , char const   *fmt  , ...) ;
int __db_not_txn_env(DB_ENV *dbenv___0 ) ;
int __db_fchk(DB_ENV *dbenv___0 , char const   *name , u_int32_t flags , u_int32_t ok_flags ) 
{ int tmp___0 ;

  {
  if (flags & ~ ok_flags) {
    tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, name, 0);
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int __db_fcchk(DB_ENV *dbenv___0 , char const   *name , u_int32_t flags , u_int32_t flag1 ,
               u_int32_t flag2 ) 
{ int tmp___0 ;

  {
  if (flags & flag1) {
    if (flags & flag2) {
      tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, name, 1);
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int __db_ferr(DB_ENV const   *dbenv___0 , char const   *name , int iscombo ) 
{ char const   *tmp ;

  {
  if (iscombo) {
    tmp = "combination ";
  } else {
    tmp = "";
  }
  __db_err(dbenv___0, "illegal flag %sspecified to %s", tmp, name);
  return (22);
}
}
int __db_fnl(DB_ENV const   *dbenv___0 , char const   *name ) 
{ 

  {
  __db_err(dbenv___0, "%s: the DB_DIRTY_READ and DB_RMW flags require locking", name);
  return (22);
}
}
int __db_pgerr(DB *dbp___1 , db_pgno_t pgno , int errval ) 
{ int tmp ;

  {
  __db_err((DB_ENV const   *)dbp___1->dbenv, "unable to create/retrieve page %lu",
           (unsigned long )pgno);
  tmp = __db_panic(dbp___1->dbenv, errval);
  return (tmp);
}
}
int __db_pgfmt(DB_ENV *dbenv___0 , db_pgno_t pgno ) 
{ int tmp ;

  {
  __db_err((DB_ENV const   *)dbenv___0, "page %lu: illegal page type or format", (unsigned long )pgno);
  tmp = __db_panic(dbenv___0, 22);
  return (tmp);
}
}
int __db_panic_msg(DB_ENV *dbenv___0 ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "PANIC: fatal region error detected; run recovery");
  if ((unsigned int )dbenv___0->db_paniccall != (unsigned int )((void *)0)) {
    ((*(dbenv___0->db_paniccall)))(dbenv___0, -30978);
  }
  return (-30978);
}
}
int __db_panic(DB_ENV *dbenv___0 , int errval ) 
{ char *tmp ;

  {
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      ((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic = 1;
    }
    tmp = db_strerror(errval);
    __db_err((DB_ENV const   *)dbenv___0, "PANIC: %s", tmp);
    if ((unsigned int )dbenv___0->db_paniccall != (unsigned int )((void *)0)) {
      ((*(dbenv___0->db_paniccall)))(dbenv___0, errval);
    }
  }
  return (-30978);
}
}
static char ebuf[40]  ;
char *db_strerror(int error ) 
{ char *p ;

  {
  if (error == 0) {
    return ((char *)"Successful return: 0");
  }
  if (error > 0) {
    p = strerror(error);
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      return (p);
    }
    goto unknown_err;
  }
  switch (error) {
  case -30999: ;
  return ((char *)"DB_DONOTINDEX: Secondary index callback returns null");
  case -30998: ;
  return ((char *)"DB_FILEOPEN: Rename or remove while file is open.");
  case -30997: ;
  return ((char *)"DB_KEYEMPTY: Non-existent key/data pair");
  case -30996: ;
  return ((char *)"DB_KEYEXIST: Key/data pair already exists");
  case -30995: ;
  return ((char *)"DB_LOCK_DEADLOCK: Locker killed to resolve a deadlock");
  case -30994: ;
  return ((char *)"DB_LOCK_NOTGRANTED: Lock not granted");
  case -30993: ;
  return ((char *)"DB_NOSERVER: Fatal error, no RPC server");
  case -30992: ;
  return ((char *)"DB_NOSERVER_HOME: Home unrecognized at server");
  case -30991: ;
  return ((char *)"DB_NOSERVER_ID: Identifier unrecognized at server");
  case -30990: ;
  return ((char *)"DB_NOTFOUND: No matching key/data pair found");
  case -30989: ;
  return ((char *)"DB_OLDVERSION: Database requires a version upgrade");
  case -30988: ;
  return ((char *)"DB_PAGE_NOTFOUND: Requested page not found");
  case -30987: ;
  return ((char *)"DB_REP_DUPMASTER: A second master site appeared");
  case -30986: ;
  return ((char *)"DB_REP_HANDLE_DEAD: Handle is no longer valid.");
  case -30985: ;
  return ((char *)"DB_REP_HOLDELECTION: Need to hold an election");
  case -30984: ;
  return ((char *)"DB_REP_ISPERM: Permanent record written");
  case -30983: ;
  return ((char *)"DB_REP_NEWMASTER: A new master has declared itself");
  case -30982: ;
  return ((char *)"DB_REP_NEWSITE: A new site has entered the system");
  case -30981: ;
  return ((char *)"DB_REP_NOTPERM: Permanent log record not written.");
  case -30980: ;
  return ((char *)"DB_REP_OUTDATED: Insufficient logs on master to recover");
  case -30979: ;
  return ((char *)"DB_REP_UNAVAIL: Unable to elect a master");
  case -30978: ;
  return ((char *)"DB_RUNRECOVERY: Fatal error, run database recovery");
  case -30977: ;
  return ((char *)"DB_SECONDARY_BAD: Secondary index inconsistent with primary");
  case -30976: ;
  return ((char *)"DB_VERIFY_BAD: Database verification failed");
  default: ;
  break;
  }
  unknown_err: 
  snprintf((char * __restrict  )(ebuf), sizeof(ebuf), (char const   * __restrict  )"Unknown error: %d",
           error);
  return (ebuf);
}
}
void __db_err(DB_ENV const   *dbenv___0 , char const   *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errcall != (unsigned int )((void *)0)) {
      __db_errcall(dbenv___0, 0, 0, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errfile != (unsigned int )((void *)0)) {
      __db_errfile(dbenv___0, 0, 0, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  __builtin_va_end(ap);
  return;
}
}
void __db_errcall(DB_ENV const   *dbenv___0 , int error , int error_set , char const   *fmt ,
                  va_list ap ) 
{ char *p ;
  char errbuf[2048] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  p = errbuf;
  if ((unsigned int )fmt != (unsigned int )((void *)0)) {
    tmp = vsnprintf((char * __restrict  )(errbuf), sizeof(errbuf), (char const   * __restrict  )fmt,
                    ap);
    p += tmp;
  }
  if (error_set) {
    tmp___0 = db_strerror(error);
    tmp___1 = snprintf((char * __restrict  )p, sizeof(errbuf) - (unsigned int )(p -
                                                                                errbuf),
                       (char const   * __restrict  )": %s", tmp___0);
    p += tmp___1;
  }
  ((*(dbenv___0->db_errcall)))(dbenv___0->db_errpfx, errbuf);
  return;
}
}
void __db_errfile(DB_ENV const   *dbenv___0 , int error , int error_set , char const   *fmt ,
                  va_list ap ) 
{ FILE *fp ;
  char *tmp ;

  {
  if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
    fp = stderr;
  } else {
    if ((unsigned int )dbenv___0->db_errfile == (unsigned int )((void *)0)) {
      fp = stderr;
    } else {
      fp = dbenv___0->db_errfile;
    }
  }
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errpfx != (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s: ", dbenv___0->db_errpfx);
    }
  }
  if ((unsigned int )fmt != (unsigned int )((void *)0)) {
    vfprintf((FILE * __restrict  )fp, (char const   * __restrict  )fmt, ap);
    if (error_set) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )": ");
    }
  }
  if (error_set) {
    tmp = db_strerror(error);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", tmp);
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  fflush(fp);
  return;
}
}
void __db_logmsg(DB_ENV const   *dbenv___0 , DB_TXN *txnid , char const   *opname ,
                 u_int32_t flags , char const   *fmt  , ...) 
{ DBT opdbt ;
  DBT msgdbt ;
  DB_LSN lsn ;
  va_list ap ;
  char __logbuf[2048] ;
  size_t tmp ;

  {
  if (! ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0))) {
    return;
  }
  __builtin_va_start(ap, fmt);
  memset((void *)(& opdbt), 0, sizeof(opdbt));
  opdbt.data = (void *)opname;
  tmp = strlen(opname);
  opdbt.size = tmp + 1U;
  memset((void *)(& msgdbt), 0, sizeof(msgdbt));
  msgdbt.data = (void *)(__logbuf);
  msgdbt.size = (u_int32_t )vsnprintf((char * __restrict  )(__logbuf), sizeof(__logbuf),
                                      (char const   * __restrict  )fmt, ap);
  __db_debug_log((DB_ENV *)dbenv___0, txnid, & lsn, flags, (DBT const   *)(& opdbt),
                 -1, (DBT const   *)(& msgdbt), (DBT const   *)((void *)0), 0U);
  __builtin_va_end(ap);
  return;
}
}
int __db_unknown_flag(DB_ENV *dbenv___0 , char *routine , u_int32_t flag ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "%s: Unknown flag: 0x%x", routine, flag);
  return (22);
}
}
int __db_unknown_type(DB_ENV *dbenv___0 , char *routine , DBTYPE type ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "%s: Unknown db type: 0x%x", routine, (unsigned int )type);
  return (22);
}
}
int __db_check_txn(DB *dbp___1 , DB_TXN *txn , u_int32_t assoc_lid , int read_op ) 
{ DB_ENV *dbenv___0 ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (dbp___1->flags & 2097152U) {
      return (0);
    }
  }
  if ((unsigned int )txn == (unsigned int )((void *)0)) {
    if (! read_op) {
      if (dbp___1->flags & 536870912U) {
        __db_err((DB_ENV const   *)dbenv___0, "DB handle previously used in transaction, missing transaction handle");
        return (22);
      }
    }
    if (dbp___1->cur_lid >= 2147483648U) {
      goto open_err;
    }
  } else {
    if (dbp___1->cur_lid >= 2147483648U) {
      if (dbp___1->cur_lid != txn->txnid) {
        goto open_err;
      }
    }
    if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
      tmp = __db_not_txn_env(dbenv___0);
      return (tmp);
    }
    if (! (dbp___1->flags & 536870912U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Transaction specified for a DB handle opened outside a transaction");
      return (22);
    }
  }
  if (! read_op) {
    if (dbp___1->associate_lid != 0U) {
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (dbp___1->associate_lid != assoc_lid) {
          __db_err((DB_ENV const   *)dbenv___0, "Operation forbidden while secondary index is being created");
          return (22);
        }
      }
    }
  }
  return (0);
  open_err: 
  __db_err((DB_ENV const   *)dbenv___0, "Transaction that opened the DB handle is still active");
  return (22);
}
}
int __db_not_txn_env(DB_ENV *dbenv___0 ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "DB environment not configured for transactions");
  return (22);
}
}
int __db_rec_toobig(DB_ENV *dbenv___0 , u_int32_t data_len , u_int32_t fixed_rec_len ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "%s: length of %lu larger than database\'s value of %lu",
           "Record length error", (unsigned long )data_len, (unsigned long )fixed_rec_len);
  return (22);
}
}
int __db_rec_repl(DB_ENV *dbenv___0 , u_int32_t data_size , u_int32_t data_dlen ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "%s: replacement length %lu differs from replaced length %lu",
           "Record length error", (unsigned long )data_size, (unsigned long )data_dlen);
  return (22);
}
}
#pragma merger(0,"/tmp/cil-BSoB5ut9.i","-O2")
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
__inline static  __attribute__((__nothrow__)) unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                                               char ** __restrict  __endptr ,
                                                                               int __base ) ;
__inline static  __attribute__((__nothrow__)) unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                                               char ** __restrict  __endptr ,
                                                                               int __base ) ;
__inline static unsigned long strtoul__extinline(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base ) 
{ unsigned long tmp ;

  {
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
  return (tmp);
}
}
int __os_get_errno(void) ;
void __os_set_errno(int evalue ) ;
int __db_getlong(DB_ENV *dbenv___0 , char const   *progname___0 , char *p , long min ,
                 long max , long *storep ) ;
int __db_getulong(DB_ENV *dbenv___0 , char const   *progname___0 , char *p , u_long min ,
                  u_long max , u_long *storep ) ;
int __db_getlong(DB_ENV *dbenv___0 , char const   *progname___0 , char *p , long min ,
                 long max , long *storep ) 
{ long val ;
  char *end ;
  char *tmp ;
  int tmp___0 ;

  {
  __os_set_errno(0);
  val = strtol__extinline((char const   * __restrict  )p, (char ** __restrict  )(& end),
                          10);
  if (val == (-0x7FFFFFFF-1)) {
    goto _L;
  } else {
    if (val == 2147483647L) {
      _L: 
      tmp___0 = __os_get_errno();
      if (tmp___0 == 34) {
        if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
          tmp = strerror(34);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: %s\n",
                  progname___0, p, tmp);
        } else {
          ((*(dbenv___0->err)))((DB_ENV const   *)dbenv___0, 34, "%s", p);
        }
        return (1);
      }
    }
  }
  if ((int )(*(p + 0)) == 0) {
    goto _L___0;
  } else {
    if ((int )(*(end + 0)) != 0) {
      if ((int )(*(end + 0)) != 10) {
        _L___0: 
        if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Invalid numeric argument\n",
                  progname___0, p);
        } else {
          ((*(dbenv___0->errx)))((DB_ENV const   *)dbenv___0, "%s: Invalid numeric argument",
                                 p);
        }
        return (1);
      }
    }
  }
  if (val < min) {
    if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Less than minimum value (%ld)\n",
              progname___0, p, min);
    } else {
      ((*(dbenv___0->errx)))((DB_ENV const   *)dbenv___0, "%s: Less than minimum value (%ld)",
                             p, min);
    }
    return (1);
  }
  if (val > max) {
    if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Greater than maximum value (%ld)\n",
              progname___0, p, max);
    } else {
      ((*(dbenv___0->errx)))((DB_ENV const   *)dbenv___0, "%s: Greater than maximum value (%ld)",
                             p, max);
    }
    return (1);
  }
  (*storep) = val;
  return (0);
}
}
int __db_getulong(DB_ENV *dbenv___0 , char const   *progname___0 , char *p , u_long min ,
                  u_long max , u_long *storep ) 
{ u_long val ;
  char *end ;
  char *tmp ;
  int tmp___0 ;

  {
  __os_set_errno(0);
  val = strtoul__extinline((char const   * __restrict  )p, (char ** __restrict  )(& end),
                           10);
  if (val == 4294967295UL) {
    tmp___0 = __os_get_errno();
    if (tmp___0 == 34) {
      if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
        tmp = strerror(34);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: %s\n",
                progname___0, p, tmp);
      } else {
        ((*(dbenv___0->err)))((DB_ENV const   *)dbenv___0, 34, "%s", p);
      }
      return (1);
    }
  }
  if ((int )(*(p + 0)) == 0) {
    goto _L;
  } else {
    if ((int )(*(end + 0)) != 0) {
      if ((int )(*(end + 0)) != 10) {
        _L: 
        if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Invalid numeric argument\n",
                  progname___0, p);
        } else {
          ((*(dbenv___0->errx)))((DB_ENV const   *)dbenv___0, "%s: Invalid numeric argument",
                                 p);
        }
        return (1);
      }
    }
  }
  if (val < min) {
    if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Less than minimum value (%lu)\n",
              progname___0, p, min);
    } else {
      ((*(dbenv___0->errx)))((DB_ENV const   *)dbenv___0, "%s: Less than minimum value (%lu)",
                             p, min);
    }
    return (1);
  }
  if (max != 0UL) {
    if (val > max) {
      if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: Greater than maximum value (%lu)\n",
                progname___0, p, max);
      } else {
        ((*(dbenv___0->errx)))((DB_ENV const   *)dbenv___0, "%s: Greater than maximum value (%lu)",
                               p, max);
      }
      return (1);
    }
  }
  (*storep) = val;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-wvJGr9f9.i","-O2")
void __db_idspace(u_int32_t *inuse , int n , u_int32_t *minp , u_int32_t *maxp ) ;
static int __db_idcmp(void const   *a , void const   *b ) ;
static int __db_idcmp(void const   *a , void const   *b ) 
{ u_int32_t i ;
  u_int32_t j ;

  {
  i = (*((u_int32_t *)a));
  j = (*((u_int32_t *)b));
  if (i < j) {
    return (-1);
  } else {
    if (i > j) {
      return (1);
    } else {
      return (0);
    }
  }
}
}
void __db_idspace(u_int32_t *inuse , int n , u_int32_t *minp , u_int32_t *maxp ) 
{ int i ;
  int low ;
  u_int32_t gap ;
  u_int32_t t ;

  {
  if (n == 1) {
    if ((*(inuse + 0)) != (*maxp)) {
      (*minp) = (*(inuse + 0));
    }
    (*maxp) = (*(inuse + 0)) - 1U;
    return;
  }
  gap = 0U;
  low = 0;
  qsort((void *)inuse, (unsigned int )n, sizeof(u_int32_t ), & __db_idcmp);
  i = 0;
  while (i < n - 1) {
    t = (*(inuse + (i + 1))) - (*(inuse + i));
    if (t > gap) {
      gap = t;
      low = i;
    }
    i ++;
  }
  if (((*maxp) - (*(inuse + (n - 1)))) + ((*(inuse + 0)) - (*minp)) > gap) {
    if ((*(inuse + (n - 1))) != (*maxp)) {
      (*minp) = (*(inuse + (n - 1)));
    }
    (*maxp) = (*(inuse + 0));
  } else {
    (*minp) = (*(inuse + low));
    (*maxp) = (*(inuse + (low + 1)));
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-yUKZkzKT.i","-O2")
int __db_associate_pp(DB *dbp___1 , DB_TXN *txn , DB *sdbp , int (*callback)(DB * ,
                                                                             DBT const   * ,
                                                                             DBT const   * ,
                                                                             DBT * ) ,
                      u_int32_t flags ) ;
int __db_close_pp(DB *dbp___1 , u_int32_t flags ) ;
int __db_cursor_pp(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t flags ) ;
int __db_del_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , u_int32_t flags ) ;
int __db_fd_pp(DB *dbp___1 , int *fdp ) ;
int __db_get_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_join_pp(DB *primary , DBC **curslist , DBC **dbcp , u_int32_t flags ) ;
int __db_key_range_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , DB_KEY_RANGE *kr , u_int32_t flags ) ;
int __db_open_pp(DB *dbp___1 , DB_TXN *txn , char const   *fname , char const   *dname ,
                 DBTYPE type , u_int32_t flags , int mode ) ;
int __db_pget_pp(DB *dbp___1 , DB_TXN *txn , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) ;
int __db_put_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_stat_pp(DB *dbp___1 , void *spp , u_int32_t flags ) ;
int __db_stat(DB *dbp___1 , void *spp , u_int32_t flags ) ;
int __db_sync_pp(DB *dbp___1 , u_int32_t flags ) ;
int __db_c_close_pp(DBC *dbc ) ;
int __db_c_del_arg(DBC *dbc , u_int32_t flags ) ;
int __db_txn_auto_init(DB_ENV *dbenv___0 , DB_TXN **txnidp ) ;
int __db_txn_auto_resolve(DB_ENV *dbenv___0 , DB_TXN *txn , int nosync , int ret ) ;
int __db_join(DB *primary , DBC **curslist , DBC **dbcp , u_int32_t flags ) ;
int __db_remove_int(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                    u_int32_t flags ) ;
int __mp_xxx_fh(DB_MPOOLFILE *dbmfp , DB_FH **fhp ) ;
static int __db_associate_arg(DB *dbp___1 , DB *sdbp , int (*callback)(DB * , DBT const   * ,
                                                                       DBT const   * ,
                                                                       DBT * ) , u_int32_t flags ) ;
static int __db_c_get_arg(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) ;
static int __db_c_pget_arg(DBC *dbc , DBT *pkey , u_int32_t flags ) ;
static int __db_c_put_arg(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) ;
static int __db_curinval(DB_ENV const   *dbenv___0 ) ;
static int __db_cursor_arg(DB *dbp___1 , u_int32_t flags ) ;
static int __db_del_arg(DB *dbp___1 , u_int32_t flags ) ;
static int __db_get_arg(DB const   *dbp___1 , DBT const   *key , DBT *data , u_int32_t flags ) ;
static int __db_join_arg(DB *primary , DBC **curslist , u_int32_t flags ) ;
static int __db_open_arg(DB *dbp___1 , DB_TXN *txn , char const   *fname , char const   *dname ,
                         DBTYPE type , u_int32_t flags ) ;
static int __db_pget_arg(DB *dbp___1 , DBT *pkey , u_int32_t flags ) ;
static int __db_put_arg(DB *dbp___1 , DBT *key , DBT *data , u_int32_t flags ) ;
static int __db_rdonly(DB_ENV const   *dbenv___0 , char const   *name ) ;
static int __db_stat_arg(DB *dbp___1 , u_int32_t flags ) ;
static int __dbt_ferr(DB const   *dbp___1 , char const   *name , DBT const   *dbt ,
                      int check_thread ) ;
int __db_associate_pp(DB *dbp___1 , DB_TXN *txn , DB *sdbp , int (*callback)(DB * ,
                                                                             DBT const   * ,
                                                                             DBT const   * ,
                                                                             DBT * ) ,
                      u_int32_t flags ) 
{ DBC *sdbc ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_associate_arg(dbp___1, sdbp, callback, flags);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )sdbp->active_queue.tqh_first != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Databases may not become secondary indices while cursors are open");
    return (22);
  } else {
    if ((unsigned int )sdbp->join_queue.tqh_first != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "Databases may not become secondary indices while cursors are open");
      return (22);
    }
  }
  txn_local = 0;
  if (flags & 16777216U) {
    goto _L;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            return (ret);
          }
          txn_local = 1;
          flags &= 4278190079U;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
          tmp___0 = __db_not_txn_env(dbenv___0);
          return (tmp___0);
        }
      }
    }
  }
  ret = __db_check_txn(dbp___1, txn, 0U, 0);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  while (1) {
    sdbc = sdbp->free_queue.tqh_first;
    if (! ((unsigned int )sdbc != (unsigned int )((void *)0))) {
      break;
    }
    ret = __db_c_destroy(sdbc);
    if (ret != 0) {
      break;
    }
  }
  if (ret == 0) {
    ret = __db_associate(dbp___1, txn, sdbp, callback, flags);
  }
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  err: 
  if (txn_local) {
    tmp___3 = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __db_associate_arg(DB *dbp___1 , DB *sdbp , int (*callback)(DB * , DBT const   * ,
                                                                       DBT const   * ,
                                                                       DBT * ) , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (sdbp->flags & 33554432U) {
    __db_err((DB_ENV const   *)dbenv___0, "Secondary index handles may not be re-associated");
    return (22);
  }
  if (dbp___1->flags & 33554432U) {
    __db_err((DB_ENV const   *)dbenv___0, "Secondary indices may not be used as primary databases");
    return (22);
  }
  if (dbp___1->flags & 512U) {
    __db_err((DB_ENV const   *)dbenv___0, "Primary databases may not be configured with duplicates");
    return (22);
  }
  if (dbp___1->flags & 4194304U) {
    __db_err((DB_ENV const   *)dbenv___0, "Renumbering recno databases may not be used as primary databases");
    return (22);
  }
  if ((unsigned int )dbp___1->dbenv != (unsigned int )sdbp->dbenv) {
    if (! ((dbp___1->dbenv)->flags & 16U)) {
      __db_err((DB_ENV const   *)dbenv___0, "The primary and secondary must be opened in the same environment");
      return (22);
    } else {
      if (! ((sdbp->dbenv)->flags & 16U)) {
        __db_err((DB_ENV const   *)dbenv___0, "The primary and secondary must be opened in the same environment");
        return (22);
      }
    }
  }
  if (((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) != ((unsigned int )sdbp->mutexp !=
                                                                         (unsigned int )((void *)0))) {
    __db_err((DB_ENV const   *)dbenv___0, "The DB_THREAD setting must be the same for primary and secondary");
    return (22);
  }
  if ((unsigned int )callback == (unsigned int )((void *)0)) {
    if (! (dbp___1->flags & 524288U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Callback function may be NULL only when database handles are read-only");
      return (22);
    } else {
      if (! (sdbp->flags & 524288U)) {
        __db_err((DB_ENV const   *)dbenv___0, "Callback function may be NULL only when database handles are read-only");
        return (22);
      }
    }
  }
  ret = __db_fchk(dbenv___0, "DB->associate", flags, 16777217U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __db_close_pp(DB *dbp___1 , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (flags != 0U) {
    if (flags != 23U) {
      t_ret = __db_ferr((DB_ENV const   *)dbenv___0, "DB->close", 0);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    t_ret = __db_rep_enter(dbp___1, 0, 0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  t_ret = __db_close(dbp___1, (DB_TXN *)((void *)0), flags);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_cursor_pp(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->cursor", 0);
    return (tmp___0);
  }
  ret = __db_cursor_arg(dbp___1, flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_check_txn(dbp___1, txn, 0U, 1);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_cursor(dbp___1, txn, dbcp, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_cursor(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBC *dbc ;
  db_lockmode_t mode ;
  u_int32_t op ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_cursor_int(dbp___1, txn, dbp___1->type, 0U, 0, 0U, & dbc);
  if (ret != 0) {
    return (ret);
  }
  if (dbenv___0->flags & 2U) {
    op = flags & 255U;
    if (op == 36U) {
      mode = (enum __anonenum_db_lockmode_t_50 )2;
    } else {
      if (op == 35U) {
        mode = (enum __anonenum_db_lockmode_t_50 )4;
      } else {
        mode = (enum __anonenum_db_lockmode_t_50 )1;
      }
    }
    ret = __lock_get(dbenv___0, dbc->locker, 0U, (DBT const   *)(& dbc->lock_dbt),
                     mode, & dbc->mylock);
    if (ret != 0) {
      goto err;
    }
    if (op == 35U) {
      dbc->flags = dbc->flags | 128U;
    }
    if (op == 36U) {
      dbc->flags = dbc->flags | 256U;
    }
  }
  if (flags & 33554432U) {
    dbc->flags = dbc->flags | 4U;
  } else {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      if (txn->flags & 4U) {
        dbc->flags = dbc->flags | 4U;
      }
    }
  }
  (*dbcp) = dbc;
  return (0);
  err: 
  __db_c_close(dbc);
  return (ret);
}
}
static int __db_cursor_arg(DB *dbp___1 , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (flags & 33554432U) {
    if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
      tmp = __db_fnl((DB_ENV const   *)dbenv___0, "DB->cursor");
      return (tmp);
    }
    flags &= 4261412863U;
  }
  switch ((int )flags) {
  case 0: ;
  break;
  case 35: ;
  if (dbp___1->flags & 524288U) {
    tmp___0 = __db_rdonly((DB_ENV const   *)dbenv___0, "DB->cursor");
    return (tmp___0);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 516U) {
          if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 4U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! (dbp___1->flags & 2U)) {
              tmp___0 = __db_rdonly((DB_ENV const   *)dbenv___0, "DB->cursor");
              return (tmp___0);
            }
          }
        }
      }
    }
  }
  if (! (dbenv___0->flags & 2U)) {
    tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->cursor", 0);
    return (tmp___1);
  }
  break;
  case 36: ;
  if (dbp___1->flags & 524288U) {
    tmp___2 = __db_rdonly((DB_ENV const   *)dbenv___0, "DB->cursor");
    return (tmp___2);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 516U) {
          if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 4U)) {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            _L___2: 
            if (! (dbp___1->flags & 2U)) {
              tmp___2 = __db_rdonly((DB_ENV const   *)dbenv___0, "DB->cursor");
              return (tmp___2);
            }
          }
        }
      }
    }
  }
  break;
  default: 
  tmp___3 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->cursor", 0);
  return (tmp___3);
  }
  return (0);
}
}
int __db_del_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->del", 0);
    return (tmp___0);
  }
  ret = __db_del_arg(dbp___1, flags);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 16777216U) {
    goto _L;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            return (ret);
          }
          txn_local = 1;
          flags &= 4278190079U;
        } else {
          txn_local = 0;
        }
      } else {
        txn_local = 0;
      }
    } else {
      txn_local = 0;
    }
  }
  ret = __db_check_txn(dbp___1, txn, 0U, 0);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_del(dbp___1, txn, key, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  err: 
  if (txn_local) {
    tmp___3 = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __db_del_arg(DB *dbp___1 , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (dbp___1->flags & 524288U) {
    tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "DB->del");
    return (tmp);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 516U) {
          if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 4U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! (dbp___1->flags & 2U)) {
              tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "DB->del");
              return (tmp);
            }
          }
        }
      }
    }
  }
  flags &= 4278190079U;
  switch ((int )flags) {
  case 0: ;
  break;
  default: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->del", 0);
  return (tmp___0);
  }
  return (0);
}
}
int __db_fd_pp(DB *dbp___1 , int *fdp ) 
{ DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->fd", 0);
    return (tmp___0);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __mp_xxx_fh(dbp___1->mpf, & fhp);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )fhp == (unsigned int )((void *)0)) {
    (*fdp) = -1;
    __db_err((DB_ENV const   *)dbenv___0, "Database does not have a valid file handle");
    ret = 2;
  } else {
    (*fdp) = fhp->fd;
  }
  err: 
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_get_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t mode ;
  int handle_check ;
  int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->get", 0);
    return (tmp___0);
  }
  ret = __db_get_arg((DB const   *)dbp___1, (DBT const   *)key, data, flags);
  if (ret != 0) {
    return (ret);
  }
  mode = 0U;
  txn_local = 0;
  if (flags & 33554432U) {
    mode = 33554432U;
  } else {
    if ((flags & 255U) == 5U) {
      goto _L___0;
    } else {
      if ((flags & 255U) == 6U) {
        _L___0: 
        mode = 36U;
        if (flags & 16777216U) {
          goto _L;
        } else {
          if ((unsigned int )txn == (unsigned int )((void *)0)) {
            if (dbenv___0->flags & 1U) {
              if (! (flags & 67108864U)) {
                _L: 
                ret = __db_txn_auto_init(dbenv___0, & txn);
                if (ret != 0) {
                  return (ret);
                }
                txn_local = 1;
                flags &= 4278190079U;
              }
            }
          }
        }
      }
    }
  }
  if (mode == 36U) {
    tmp___1 = 0;
  } else {
    if (flags & 268435456U) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  }
  ret = __db_check_txn(dbp___1, txn, 0U, tmp___1);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  handle_check = tmp___2;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_get(dbp___1, txn, key, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  err: 
  if (txn_local) {
    tmp___4 = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  } else {
    tmp___4 = ret;
  }
  return (tmp___4);
}
}
int __db_get(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) 
{ DBC *dbc ;
  u_int32_t mode ;
  int ret ;
  int t_ret ;

  {
  mode = 0U;
  if (flags & 33554432U) {
    mode = 33554432U;
    flags &= 4261412863U;
  } else {
    if ((flags & 255U) == 5U) {
      mode = 36U;
    } else {
      if ((flags & 255U) == 6U) {
        mode = 36U;
      }
    }
  }
  ret = __db_cursor(dbp___1, txn, & dbc, mode);
  if (ret != 0) {
    return (ret);
  }
  dbc->flags = dbc->flags | 64U;
  while (1) {
    dbc->rskey = & dbp___1->my_rskey;
    dbc->rkey = & dbp___1->my_rkey;
    dbc->rdata = & dbp___1->my_rdata;
    break;
  }
  if ((flags & 3959422975U) == 0U) {
    flags |= 28U;
  }
  ret = __db_c_get(dbc, key, data, flags);
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
static int __db_get_arg(DB const   *dbp___1 , DBT const   *key , DBT *data , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int check_thread ;
  int dirty ;
  int multi ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  dirty = 0;
  check_thread = dirty;
  if (flags & 301989888U) {
    if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
      tmp = __db_fnl((DB_ENV const   *)dbenv___0, "DB->get");
      return (tmp);
    }
    if (flags & 33554432U) {
      dirty = 1;
    }
    flags &= 3992977407U;
  }
  multi = 0;
  if (flags & 201326592U) {
    if (flags & 134217728U) {
      goto multi_err;
    }
    if (flags & 67108864U) {
      multi = 1;
    } else {
      multi = 0;
    }
    flags &= 4227858431U;
  }
  if (flags & 16777216U) {
    flags &= 4278190079U;
    if (flags != 5U) {
      if (flags != 6U) {
        goto err;
      }
    }
  }
  switch ((int )flags) {
  case 0: ;
  case 10: ;
  break;
  case 31: 
  check_thread = 1;
  if (! (dbp___1->flags & 1048576U)) {
    goto err;
  }
  break;
  case 5: ;
  case 6: 
  check_thread = 1;
  if (dirty) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_DIRTY_READ is not supported with DB_CONSUME or DB_CONSUME_WAIT");
    return (22);
  }
  if (multi) {
    multi_err: 
    tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->get", 1);
    return (tmp___0);
  }
  if ((int )dbp___1->type == 4) {
    break;
  }
  default: ;
  err: 
  tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->get", 0);
  return (tmp___1);
  }
  ret = __dbt_ferr(dbp___1, "key", key, check_thread);
  if (ret != 0) {
    return (ret);
  }
  ret = __dbt_ferr(dbp___1, "data", (DBT const   *)data, 1);
  if (ret != 0) {
    return (ret);
  }
  if (multi) {
    if (! (data->flags & 32U)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE requires DB_DBT_USERMEM be set");
      return (22);
    }
    if (key->flags & 8U) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE does not support DB_DBT_PARTIAL");
      return (22);
    } else {
      if (data->flags & 8U) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE does not support DB_DBT_PARTIAL");
        return (22);
      }
    }
    if (data->ulen < 1024U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s%s", "DB_MULTIPLE buffers must be ",
               "aligned, at least page size and multiples of 1KB");
      return (22);
    } else {
      if (data->ulen < dbp___1->pgsize) {
        __db_err((DB_ENV const   *)dbenv___0, "%s%s", "DB_MULTIPLE buffers must be ",
                 "aligned, at least page size and multiples of 1KB");
        return (22);
      } else {
        if (data->ulen % 1024U != 0U) {
          __db_err((DB_ENV const   *)dbenv___0, "%s%s", "DB_MULTIPLE buffers must be ",
                   "aligned, at least page size and multiples of 1KB");
          return (22);
        }
      }
    }
  }
  return (0);
}
}
int __db_join_pp(DB *primary , DBC **curslist , DBC **dbcp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = primary->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_join_arg(primary, curslist, flags);
  if (ret != 0) {
    return (ret);
  }
  if (! (primary->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(primary, 1, (unsigned int )((*(curslist + 0)))->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_join(primary, curslist, dbcp, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __db_join_arg(DB *primary , DBC **curslist , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_TXN *txn ;
  int i ;
  int tmp ;

  {
  dbenv___0 = primary->dbenv;
  switch ((int )flags) {
  case 0: ;
  case 1: ;
  break;
  default: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DB->join", 0);
  return (tmp);
  }
  if ((unsigned int )curslist == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "At least one secondary cursor must be specified to DB->join");
    return (22);
  } else {
    if ((unsigned int )(*(curslist + 0)) == (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "At least one secondary cursor must be specified to DB->join");
      return (22);
    }
  }
  txn = ((*(curslist + 0)))->txn;
  i = 1;
  while ((unsigned int )(*(curslist + i)) != (unsigned int )((void *)0)) {
    if ((unsigned int )((*(curslist + i)))->txn != (unsigned int )txn) {
      __db_err((DB_ENV const   *)dbenv___0, "All secondary cursors must share the same transaction");
      return (22);
    }
    i ++;
  }
  return (0);
}
}
int __db_key_range_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , DB_KEY_RANGE *kr , u_int32_t flags ) 
{ DBC *dbc ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! ((dbp___1->dbenv)->flags & 4096U)) {
    if ((unsigned int )(dbp___1->dbenv)->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)(dbp___1->dbenv)->reginfo)->primary)->envpanic !=
          0) {
        tmp = __db_panic_msg(dbp___1->dbenv);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->key_range", 0);
    return (tmp___0);
  }
  if (flags != 0U) {
    tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->key_range", 0);
    return (tmp___1);
  }
  ret = __db_check_txn(dbp___1, txn, 0U, 1);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  handle_check = tmp___2;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  switch ((int )dbp___1->type) {
  case 1: 
  ret = __db_cursor(dbp___1, txn, & dbc, 0U);
  if (ret != 0) {
    break;
  }
  ret = __bam_key_range(dbc, key, kr, flags);
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  break;
  case 2: ;
  case 4: ;
  case 3: 
  ret = __dbh_am_chk(dbp___1, 1U);
  break;
  case 5: ;
  default: 
  ret = __db_unknown_type(dbenv___0, (char *)"DB->key_range", dbp___1->type);
  break;
  }
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_open_pp(DB *dbp___1 , DB_TXN *txn , char const   *fname , char const   *dname ,
                 DBTYPE type , u_int32_t flags , int mode ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int nosync ;
  int remove_me ;
  int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  nosync = 1;
  remove_me = 0;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_open_arg(dbp___1, txn, fname, dname, type, flags);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )fname != (unsigned int )((void *)0)) {
    ret = __os_strdup(dbenv___0, fname, (void *)(& dbp___1->fname));
    if (ret != 0) {
      return (ret);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dname != (unsigned int )((void *)0)) {
      ret = __os_strdup(dbenv___0, dname, (void *)(& dbp___1->dname));
      if (ret != 0) {
        return (ret);
      }
    }
  }
  dbp___1->open_flags = flags;
  dbp___1->orig_flags = dbp___1->flags;
  txn_local = 0;
  if (flags & 16777216U) {
    goto _L___0;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L___0: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            return (ret);
          }
          txn_local = 1;
          flags &= 4278190079U;
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
          tmp___0 = __db_not_txn_env(dbenv___0);
          return (tmp___0);
        }
      }
    }
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_open(dbp___1, txn, fname, dname, type, flags, mode, 0U);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dname == (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
        goto _L___3;
      }
    } else {
      _L___3: 
      if (! (flags & 16U)) {
        if (! (flags & 16384U)) {
          if (dbp___1->flags & 134217728U) {
            __db_err((DB_ENV const   *)dbenv___0, "files containing multiple databases may only be opened read-only");
            ret = 22;
            goto err;
          }
        }
      }
    }
  }
  if (dbp___1->flags & 24U) {
    nosync = 0;
  }
  dbp___1->flags = dbp___1->flags & 4294967015U;
  err: 
  if (ret != 0) {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      remove_me = (int )(dbp___1->flags & 8U);
      if (dbp___1->flags & 16U) {
        __db_remove_int(dbp___1, txn, fname, (char const   *)((void *)0), 4U);
      } else {
        if ((unsigned int )dname == (unsigned int )((void *)0)) {
          if (remove_me) {
            __db_remove_int(dbp___1, txn, fname, (char const   *)((void *)0), 4U);
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          if (remove_me) {
            __db_remove_int(dbp___1, txn, fname, dname, 4U);
          }
        }
      }
    }
  }
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  if (txn_local) {
    tmp___3 = __db_txn_auto_resolve(dbenv___0, txn, nosync, ret);
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __db_open_arg(DB *dbp___1 , DB_TXN *txn , char const   *fname , char const   *dname ,
                         DBTYPE type , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t ok_flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __ret ;
  char const   *tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_fchk(dbenv___0, "DB->open", flags, 117502169U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 4096U) {
    if (! (flags & 1U)) {
      tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DB->open", 1);
      return (tmp);
    }
  }
  if (flags & 16U) {
    if (flags & 1U) {
      tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->open", 1);
      return (tmp___0);
    }
  }
  switch ((int )type) {
  case 5: ;
  if (flags & 129U) {
    __db_err((DB_ENV const   *)dbenv___0, "%s: DB_UNKNOWN type specified with DB_CREATE or DB_TRUNCATE",
             fname);
    return (22);
  }
  ok_flags = 0U;
  break;
  case 1: 
  ok_flags = 1U;
  break;
  case 2: 
  ok_flags = 2U;
  break;
  case 4: 
  ok_flags = 4U;
  break;
  case 3: 
  ok_flags = 8U;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "unknown type: %lu", (unsigned long )type);
  return (22);
  }
  if (ok_flags) {
    __ret = __dbh_am_chk(dbp___1, ok_flags);
    if (__ret != 0) {
      return (__ret);
    }
  }
  if (! (dbenv___0->flags & 8208U)) {
    __db_err((DB_ENV const   *)dbenv___0, "environment not yet opened");
    return (22);
  }
  if (! (dbenv___0->flags & 16U)) {
    if (! ((unsigned int )dbenv___0->mp_handle != (unsigned int )((void *)0))) {
      __db_err((DB_ENV const   *)dbenv___0, "environment did not include a memory pool");
      return (22);
    }
  }
  if (flags & 64U) {
    if (! (dbenv___0->flags & 1048592U)) {
      __db_err((DB_ENV const   *)dbenv___0, "environment not created using DB_THREAD");
      return (22);
    }
  }
  if (flags & 128U) {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        _L: 
        if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
          tmp___1 = "locking";
        } else {
          tmp___1 = "transactions";
        }
        __db_err((DB_ENV const   *)dbenv___0, "DB_TRUNCATE illegal with %s specified",
                 tmp___1);
        return (22);
      }
    }
  }
  if ((unsigned int )dname != (unsigned int )((void *)0)) {
    if ((unsigned int )fname == (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "multiple databases cannot be created in temporary files");
      return (22);
    }
    if ((int )type == 4) {
      __db_err((DB_ENV const   *)dbenv___0, "Queue databases must be one-per-file");
      return (22);
    }
  }
  return (0);
}
}
int __db_pget_pp(DB *dbp___1 , DB_TXN *txn , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->pget", 0);
    return (tmp___0);
  }
  ret = __db_pget_arg(dbp___1, pkey, flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_get_arg((DB const   *)dbp___1, (DBT const   *)skey, data, flags);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_pget(dbp___1, txn, skey, pkey, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_pget(DB *dbp___1 , DB_TXN *txn , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) 
{ DBC *dbc ;
  int ret ;
  int t_ret ;

  {
  ret = __db_cursor(dbp___1, txn, & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    dbc->rskey = & dbp___1->my_rskey;
    dbc->rkey = & dbp___1->my_rkey;
    dbc->rdata = & dbp___1->my_rdata;
    break;
  }
  if ((unsigned int )pkey == (unsigned int )((void *)0)) {
    dbc->rkey = & dbc->my_rkey;
  }
  if (flags == 0U) {
    flags |= 28U;
  } else {
    if (flags == 268435456U) {
      flags |= 28U;
    }
  }
  ret = __db_c_pget(dbc, skey, pkey, data, flags);
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __db_pget_arg(DB *dbp___1 , DBT *pkey , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbp___1->flags & 33554432U)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB->pget may only be used on secondary indices");
    return (22);
  }
  if (flags & 201326592U) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE and DB_MULTIPLE_KEY may not be used on secondary indices");
    return (22);
  }
  flags &= 4026531839U;
  switch ((int )flags) {
  case 5: ;
  case 6: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DB->pget", 0);
  return (tmp);
  default: ;
  break;
  }
  if ((unsigned int )pkey != (unsigned int )((void *)0)) {
    ret = __dbt_ferr((DB const   *)dbp___1, "primary key", (DBT const   *)pkey, 1);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )pkey == (unsigned int )((void *)0)) {
    if (flags == 10U) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_GET_BOTH on a secondary index requires a primary key");
      return (22);
    }
  }
  return (0);
}
}
int __db_put_pp(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->put", 0);
    return (tmp___0);
  }
  ret = __db_put_arg(dbp___1, key, data, flags);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 16777216U) {
    goto _L;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            return (ret);
          }
          txn_local = 1;
          flags &= 4278190079U;
        } else {
          txn_local = 0;
        }
      } else {
        txn_local = 0;
      }
    } else {
      txn_local = 0;
    }
  }
  ret = __db_check_txn(dbp___1, txn, 0U, 0);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_put(dbp___1, txn, key, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  err: 
  if (txn_local) {
    tmp___3 = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __db_put_arg(DB *dbp___1 , DBT *key , DBT *data , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int returnkey ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  returnkey = 0;
  if (dbp___1->flags & 524288U) {
    tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "put");
    return (tmp);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 516U) {
          if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 4U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! (dbp___1->flags & 2U)) {
              tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "put");
              return (tmp);
            }
          }
        }
      }
    }
  }
  if (dbp___1->flags & 33554432U) {
    __db_err((DB_ENV const   *)dbenv___0, "DB->put forbidden on secondary indices");
    return (22);
  }
  flags &= 4278190079U;
  switch ((int )flags) {
  case 0: ;
  case 22: ;
  break;
  case 2: ;
  if ((int )dbp___1->type != 3) {
    if ((int )dbp___1->type != 4) {
      goto err;
    }
  }
  returnkey = 1;
  break;
  case 21: ;
  if (dbp___1->flags & 1024U) {
    break;
  }
  default: ;
  err: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->put", 0);
  return (tmp___0);
  }
  ret = __dbt_ferr((DB const   *)dbp___1, "key", (DBT const   *)key, returnkey);
  if (ret != 0) {
    return (ret);
  }
  ret = __dbt_ferr((DB const   *)dbp___1, "data", (DBT const   *)data, 0);
  if (ret != 0) {
    return (ret);
  }
  if (data->flags & 8U) {
    if (dbp___1->flags & 512U) {
      __db_err((DB_ENV const   *)dbenv___0, "a partial put in the presence of duplicates requires a cursor operation");
      return (22);
    } else {
      if (key->flags & 64U) {
        __db_err((DB_ENV const   *)dbenv___0, "a partial put in the presence of duplicates requires a cursor operation");
        return (22);
      }
    }
  }
  return (0);
}
}
int __db_stat_pp(DB *dbp___1 , void *spp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! ((dbp___1->dbenv)->flags & 4096U)) {
    if ((unsigned int )(dbp___1->dbenv)->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)(dbp___1->dbenv)->reginfo)->primary)->envpanic !=
          0) {
        tmp = __db_panic_msg(dbp___1->dbenv);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->stat", 0);
    return (tmp___0);
  }
  ret = __db_stat_arg(dbp___1, flags);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_stat(dbp___1, spp, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_stat(DB *dbp___1 , void *spp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBC *dbc ;
  int ret ;
  int t_ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_cursor(dbp___1, (DB_TXN *)((void *)0), & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: 
  ret = __bam_stat(dbc, spp, flags);
  break;
  case 2: 
  ret = __ham_stat(dbc, spp, flags);
  break;
  case 4: 
  ret = __qam_stat(dbc, spp, flags);
  break;
  case 5: ;
  default: 
  ret = __db_unknown_type(dbenv___0, (char *)"DB->stat", dbp___1->type);
  break;
  }
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __db_stat_arg(DB *dbp___1 , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  switch ((int )flags) {
  case 0: ;
  case 8: ;
  case 4: ;
  break;
  case 27: ;
  if ((int )dbp___1->type == 3) {
    break;
  }
  if ((int )dbp___1->type == 1) {
    if (dbp___1->flags & 1048576U) {
      break;
    }
  }
  goto err;
  default: ;
  err: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DB->stat", 0);
  return (tmp);
  }
  return (0);
}
}
int __db_sync_pp(DB *dbp___1 , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! ((dbp___1->dbenv)->flags & 4096U)) {
    if ((unsigned int )(dbp___1->dbenv)->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)(dbp___1->dbenv)->reginfo)->primary)->envpanic !=
          0) {
        tmp = __db_panic_msg(dbp___1->dbenv);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 65536U)) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->sync", 0);
    return (tmp___0);
  }
  if (flags != 0U) {
    tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->sync", 0);
    return (tmp___1);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  handle_check = tmp___2;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_sync(dbp___1);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_c_close_pp(DBC *dbc ) 
{ DB_ENV *dbenv___0 ;
  DB *dbp___1 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbc->flags & 1U)) {
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "Closing already-closed cursor");
    }
    return (22);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 0, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_close(dbc);
  if (handle_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_c_count_pp(DBC *dbc , db_recno_t *recnop , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB *dbp___1 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (flags != 0U) {
    tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->count", 0);
    return (tmp___0);
  }
  if (! ((dbc->internal)->pgno != 0U)) {
    tmp___1 = __db_curinval((DB_ENV const   *)dbenv___0);
    return (tmp___1);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  handle_check = tmp___2;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_count(dbc, recnop);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_c_del_pp(DBC *dbc , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_c_del_arg(dbc, flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_check_txn(dbp___1, dbc->txn, dbc->locker, 0);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_del(dbc, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_c_del_arg(DBC *dbc , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (dbp___1->flags & 524288U) {
    tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "DBcursor->del");
    return (tmp);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 516U) {
          if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 4U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! (dbp___1->flags & 2U)) {
              tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "DBcursor->del");
              return (tmp);
            }
          }
        }
      }
    }
  }
  switch ((int )flags) {
  case 0: ;
  break;
  case 34: ;
  break;
  default: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->del", 0);
  return (tmp___0);
  }
  if (! ((dbc->internal)->pgno != 0U)) {
    tmp___1 = __db_curinval((DB_ENV const   *)dbenv___0);
    return (tmp___1);
  }
  return (0);
}
}
int __db_c_dup_pp(DBC *dbc , DBC **dbcp , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (flags != 0U) {
    if (flags != 24U) {
      tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->dup", 0);
      return (tmp___0);
    }
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_dup(dbc, dbcp, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_c_get_pp(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_c_get_arg(dbc, key, data, flags);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_get(dbc, key, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __db_c_get_arg(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int dirty ;
  int multi ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  dirty = 0;
  if (flags & 301989888U) {
    if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
      tmp = __db_fnl((DB_ENV const   *)dbenv___0, "DBcursor->get");
      return (tmp);
    }
    if (flags & 33554432U) {
      dirty = 1;
    }
    flags &= 3992977407U;
  }
  multi = 0;
  if (flags & 201326592U) {
    multi = 1;
    if (flags & 67108864U) {
      if (flags & 134217728U) {
        goto multi_err;
      }
    }
    flags &= 4093640703U;
  }
  switch ((int )flags) {
  case 5: ;
  case 6: ;
  if (dirty) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_DIRTY_READ is not supported with DB_CONSUME or DB_CONSUME_WAIT");
    return (22);
  }
  if ((int )dbp___1->type != 4) {
    goto err;
  }
  break;
  case 7: ;
  case 9: ;
  case 10: ;
  case 12: ;
  case 18: ;
  case 19: ;
  case 20: ;
  case 28: ;
  case 30: ;
  break;
  case 17: ;
  case 25: ;
  case 26: ;
  if (multi) {
    multi_err: 
    tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->get", 1);
    return (tmp___0);
  }
  break;
  case 11: ;
  if ((int )dbp___1->type == 4) {
    goto err;
  }
  break;
  case 13: ;
  if (! (dbp___1->flags & 1048576U)) {
    if (! (dbp___1->flags & 33554432U)) {
      goto err;
    } else {
      if (! ((dbp___1->s_primary)->flags & 1048576U)) {
        goto err;
      }
    }
  }
  break;
  case 31: ;
  if (! (dbp___1->flags & 1048576U)) {
    goto err;
  }
  break;
  default: ;
  err: 
  tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->get", 0);
  return (tmp___1);
  }
  ret = __dbt_ferr((DB const   *)dbp___1, "key", (DBT const   *)key, 0);
  if (ret != 0) {
    return (ret);
  }
  ret = __dbt_ferr((DB const   *)dbp___1, "data", (DBT const   *)data, 0);
  if (ret != 0) {
    return (ret);
  }
  if (multi) {
    if (! (data->flags & 32U)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE/DB_MULTIPLE_KEY require DB_DBT_USERMEM be set");
      return (22);
    }
    if (key->flags & 8U) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE/DB_MULTIPLE_KEY do not support DB_DBT_PARTIAL");
      return (22);
    } else {
      if (data->flags & 8U) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE/DB_MULTIPLE_KEY do not support DB_DBT_PARTIAL");
        return (22);
      }
    }
    if (data->ulen < 1024U) {
      __db_err((DB_ENV const   *)dbenv___0, "%s%s", "DB_MULTIPLE/DB_MULTIPLE_KEY buffers must be ",
               "aligned, at least page size and multiples of 1KB");
      return (22);
    } else {
      if (data->ulen < dbp___1->pgsize) {
        __db_err((DB_ENV const   *)dbenv___0, "%s%s", "DB_MULTIPLE/DB_MULTIPLE_KEY buffers must be ",
                 "aligned, at least page size and multiples of 1KB");
        return (22);
      } else {
        if (data->ulen % 1024U != 0U) {
          __db_err((DB_ENV const   *)dbenv___0, "%s%s", "DB_MULTIPLE/DB_MULTIPLE_KEY buffers must be ",
                   "aligned, at least page size and multiples of 1KB");
          return (22);
        }
      }
    }
  }
  if (! ((dbc->internal)->pgno != 0U)) {
    if (flags == 7U) {
      tmp___2 = __db_curinval((DB_ENV const   *)dbenv___0);
      return (tmp___2);
    } else {
      if (flags == 13U) {
        tmp___2 = __db_curinval((DB_ENV const   *)dbenv___0);
        return (tmp___2);
      } else {
        if (flags == 19U) {
          tmp___2 = __db_curinval((DB_ENV const   *)dbenv___0);
          return (tmp___2);
        }
      }
    }
  }
  if (flags & 268435456U) {
    ret = __db_check_txn(dbp___1, dbc->txn, dbc->locker, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  return (0);
}
}
int __db_c_pget_pp(DBC *dbc , DBT *skey , DBT *pkey , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_c_pget_arg(dbc, pkey, flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_c_get_arg(dbc, skey, data, flags);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_pget(dbc, skey, pkey, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __db_c_pget_arg(DBC *dbc , DBT *pkey , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbp___1->flags & 33554432U)) {
    __db_err((DB_ENV const   *)dbenv___0, "DBcursor->pget may only be used on secondary indices");
    return (22);
  }
  if (flags & 201326592U) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_MULTIPLE and DB_MULTIPLE_KEY may not be used on secondary indices");
    return (22);
  }
  switch ((int )(flags & 4026531839U)) {
  case 5: ;
  case 6: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->pget", 0);
  return (tmp);
  case 10: ;
  if ((unsigned int )pkey == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_GET_BOTH requires both a secondary and a primary key");
    return (22);
  }
  break;
  default: ;
  break;
  }
  if ((unsigned int )pkey != (unsigned int )((void *)0)) {
    ret = __dbt_ferr((DB const   *)dbp___1, "primary key", (DBT const   *)pkey, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )pkey == (unsigned int )((void *)0)) {
    if ((flags & 255U) == 10U) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_GET_BOTH on a secondary index requires a primary key");
      return (22);
    }
  }
  return (0);
}
}
int __db_c_put_pp(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_c_put_arg(dbc, key, data, flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_check_txn(dbp___1, dbc->txn, dbc->locker, 0);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_c_put(dbc, key, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __db_c_put_arg(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  int key_flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  key_flags = 0;
  if (dbp___1->flags & 524288U) {
    tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "c_put");
    return (tmp);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 516U) {
          if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(dbp___1->dbenv)->rep_handle)->region) {
              if (! ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags & 4U)) {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! (dbp___1->flags & 2U)) {
              tmp = __db_rdonly((DB_ENV const   *)dbenv___0, "c_put");
              return (tmp);
            }
          }
        }
      }
    }
  }
  if (dbp___1->flags & 33554432U) {
    if (flags == 34U) {
      flags = 16U;
    } else {
      __db_err((DB_ENV const   *)dbenv___0, "DBcursor->put forbidden on secondary indices");
      return (22);
    }
  }
  switch ((int )flags) {
  case 1: ;
  case 3: ;
  switch ((int )dbp___1->type) {
  case 1: ;
  case 2: ;
  if (! (dbp___1->flags & 512U)) {
    goto err;
  }
  if ((unsigned int )dbp___1->dup_compare != (unsigned int )((void *)0)) {
    goto err;
  }
  break;
  case 4: ;
  goto err;
  case 3: ;
  if (! (dbp___1->flags & 4194304U)) {
    goto err;
  }
  key_flags = 1;
  break;
  case 5: ;
  default: ;
  goto err;
  }
  break;
  case 7: ;
  break;
  case 21: ;
  if (! (dbp___1->flags & 1024U)) {
    goto err;
  }
  case 15: ;
  case 16: 
  key_flags = 1;
  break;
  default: ;
  err: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DBcursor->put", 0);
  return (tmp___0);
  }
  if (key_flags) {
    ret = __dbt_ferr((DB const   *)dbp___1, "key", (DBT const   *)key, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __dbt_ferr((DB const   *)dbp___1, "data", (DBT const   *)data, 0);
  if (ret != 0) {
    return (ret);
  }
  if (! ((dbc->internal)->pgno != 0U)) {
    if (flags != 15U) {
      if (flags != 16U) {
        if (flags != 21U) {
          tmp___1 = __db_curinval((DB_ENV const   *)dbenv___0);
          return (tmp___1);
        }
      }
    }
  }
  return (0);
}
}
static int __dbt_ferr(DB const   *dbp___1 , char const   *name , DBT const   *dbt ,
                      int check_thread ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_fchk(dbenv___0, name, dbt->flags, 125U);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )(dbt->flags & 52U)) {
  case 0: ;
  case 4: ;
  case 16: ;
  case 32: ;
  break;
  default: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, name, 1);
  return (tmp);
  }
  if (check_thread) {
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! (dbt->flags & 52U)) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_THREAD mandates memory allocation flag on DBT %s",
                 name);
        return (22);
      }
    }
  }
  return (0);
}
}
static int __db_rdonly(DB_ENV const   *dbenv___0 , char const   *name ) 
{ 

  {
  __db_err(dbenv___0, "%s: attempt to modify a read-only tree", name);
  return (13);
}
}
static int __db_curinval(DB_ENV const   *dbenv___0 ) 
{ 

  {
  __db_err(dbenv___0, "Cursor position must be set before performing this operation");
  return (22);
}
}
int __db_txn_auto_init(DB_ENV *dbenv___0 , DB_TXN **txnidp ) 
{ int tmp ;

  {
  if ((unsigned int )(*txnidp) != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_AUTO_COMMIT may not be specified along with a transaction handle");
    return (22);
  }
  if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_AUTO_COMMIT may not be specified in non-transactional environment");
    return (22);
  }
  tmp = ((*(dbenv___0->txn_begin)))(dbenv___0, (DB_TXN *)((void *)0), txnidp, 0U);
  return (tmp);
}
}
int __db_txn_auto_resolve(DB_ENV *dbenv___0 , DB_TXN *txn , int nosync , int ret ) 
{ int t_ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (ret == 0) {
    if (nosync) {
      tmp = 256;
    } else {
      tmp = 0;
    }
    tmp___0 = ((*(txn->commit)))(txn, (unsigned int )tmp);
    return (tmp___0);
  }
  t_ret = ((*(txn->abort)))(txn);
  if (t_ret != 0) {
    tmp___1 = __db_panic(dbenv___0, t_ret);
    return (tmp___1);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-T3VylAxn.i","-O2")
static int __db_join_close_pp(DBC *dbc ) ;
static int __db_join_cmp(void const   *a , void const   *b ) ;
static int __db_join_del(DBC *dbc , u_int32_t flags ) ;
static int __db_join_get(DBC *dbc , DBT *key_arg , DBT *data_arg , u_int32_t flags ) ;
static int __db_join_get_pp(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) ;
static int __db_join_getnext(DBC *dbc , DBT *key , DBT *data , u_int32_t exhausted ,
                             u_int32_t opmods ) ;
static int __db_join_primget(DB *dbp___1 , DB_TXN *txn , u_int32_t lockerid , DBT *key ,
                             DBT *data , u_int32_t flags ) ;
static int __db_join_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_join(DB *primary , DBC **curslist , DBC **dbcp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DBC *dbc ;
  JOIN_CURSOR *jc ;
  size_t ncurs ;
  size_t nslots ;
  u_int32_t i ;
  int ret ;

  {
  dbenv___0 = primary->dbenv;
  dbc = (DBC *)((void *)0);
  jc = (JOIN_CURSOR *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(DBC ), (void *)(& dbc));
  if (ret != 0) {
    goto err;
  }
  ret = __os_calloc(dbenv___0, 1U, sizeof(JOIN_CURSOR ), (void *)(& jc));
  if (ret != 0) {
    goto err;
  }
  ret = __os_malloc(dbenv___0, 256U, (void *)(& jc->j_key.data));
  if (ret != 0) {
    goto err;
  }
  jc->j_key.ulen = 256U;
  jc->j_key.flags = jc->j_key.flags | 32U;
  jc->j_rdata.flags = jc->j_rdata.flags | 16U;
  jc->j_curslist = curslist;
  while ((unsigned int )(*(jc->j_curslist)) != (unsigned int )((void *)0)) {
    jc->j_curslist ++;
  }
  ncurs = (unsigned int )(jc->j_curslist - curslist);
  nslots = ncurs + 1U;
  jc->j_curslist = (DBC **)((void *)0);
  jc->j_workcurs = (DBC **)((void *)0);
  jc->j_fdupcurs = (DBC **)((void *)0);
  jc->j_exhausted = (u_int8_t *)((void *)0);
  ret = __os_calloc(dbenv___0, nslots, sizeof(DBC *), (void *)(& jc->j_curslist));
  if (ret != 0) {
    goto err;
  }
  ret = __os_calloc(dbenv___0, nslots, sizeof(DBC *), (void *)(& jc->j_workcurs));
  if (ret != 0) {
    goto err;
  }
  ret = __os_calloc(dbenv___0, nslots, sizeof(DBC *), (void *)(& jc->j_fdupcurs));
  if (ret != 0) {
    goto err;
  }
  ret = __os_calloc(dbenv___0, nslots, sizeof(u_int8_t ), (void *)(& jc->j_exhausted));
  if (ret != 0) {
    goto err;
  }
  i = 0U;
  while ((unsigned int )(*(curslist + i)) != (unsigned int )((void *)0)) {
    (*(jc->j_curslist + i)) = (*(curslist + i));
    (*(jc->j_workcurs + i)) = (DBC *)((void *)0);
    (*(jc->j_fdupcurs + i)) = (DBC *)((void *)0);
    (*(jc->j_exhausted + i)) = (unsigned char)0;
    i ++;
  }
  jc->j_ncurs = ncurs;
  if (! (flags & 1U)) {
    qsort((void *)jc->j_curslist, ncurs, sizeof(DBC *), & __db_join_cmp);
  }
  ret = __db_c_dup((*(jc->j_curslist + 0)), jc->j_workcurs, 24U);
  if (ret != 0) {
    goto err;
  }
  dbc->c_close = & __db_join_close_pp;
  dbc->c_del = & __db_join_del;
  dbc->c_get = & __db_join_get_pp;
  dbc->c_put = & __db_join_put;
  dbc->internal = (DBC_INTERNAL *)jc;
  dbc->dbp = primary;
  jc->j_primary = primary;
  dbc->txn = ((*(curslist + 0)))->txn;
  (*dbcp) = dbc;
  if ((unsigned int )primary->mutexp != (unsigned int )((void *)0)) {
    if (! ((primary->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, primary->mutexp);
    }
  }
  while (1) {
    dbc->links.tqe_next = (DBC *)((void *)0);
    dbc->links.tqe_prev = primary->join_queue.tqh_last;
    (*(primary->join_queue.tqh_last)) = dbc;
    primary->join_queue.tqh_last = & dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )primary->mutexp != (unsigned int )((void *)0)) {
    if (! ((primary->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, primary->mutexp);
    }
  }
  return (0);
  err: 
  if ((unsigned int )jc != (unsigned int )((void *)0)) {
    if ((unsigned int )jc->j_curslist != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)jc->j_curslist);
    }
    if ((unsigned int )jc->j_workcurs != (unsigned int )((void *)0)) {
      if ((unsigned int )(*(jc->j_workcurs + 0)) != (unsigned int )((void *)0)) {
        __os_free(dbenv___0, (void *)(*(jc->j_workcurs + 0)));
      }
      __os_free(dbenv___0, (void *)jc->j_workcurs);
    }
    if ((unsigned int )jc->j_fdupcurs != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)jc->j_fdupcurs);
    }
    if ((unsigned int )jc->j_exhausted != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)jc->j_exhausted);
    }
    __os_free(dbenv___0, (void *)jc);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbc);
  }
  return (ret);
}
}
static int __db_join_close_pp(DBC *dbc ) 
{ DB_ENV *dbenv___0 ;
  DB *dbp___1 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 0, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_join_close(dbc);
  if (handle_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __db_join_put(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) 
{ int tmp ;

  {
  if (! (((dbc->dbp)->dbenv)->flags & 4096U)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)((dbc->dbp)->dbenv)->reginfo)->primary)->envpanic !=
          0) {
        tmp = __db_panic_msg((dbc->dbp)->dbenv);
        return (tmp);
      }
    }
  }
  key = (DBT *)((void *)0);
  key = key;
  data = (DBT *)((void *)0);
  data = data;
  flags = 0U;
  flags = flags;
  return (22);
}
}
static int __db_join_del(DBC *dbc , u_int32_t flags ) 
{ int tmp ;

  {
  if (! (((dbc->dbp)->dbenv)->flags & 4096U)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)((dbc->dbp)->dbenv)->reginfo)->primary)->envpanic !=
          0) {
        tmp = __db_panic_msg((dbc->dbp)->dbenv);
        return (tmp);
      }
    }
  }
  flags = 0U;
  flags = flags;
  return (22);
}
}
static int __db_join_get_pp(DBC *dbc , DBT *key , DBT *data , u_int32_t flags ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  u_int32_t handle_check ;
  u_int32_t ret ;
  u_int32_t save_flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  save_flags = flags;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (flags & 301989888U) {
    if (! ((unsigned int )(dbp___1->dbenv)->lk_handle != (unsigned int )((void *)0))) {
      tmp___0 = __db_fnl((DB_ENV const   *)dbp___1->dbenv, "DBcursor->c_get");
      return (tmp___0);
    }
    flags &= 3992977407U;
  }
  switch ((int )flags) {
  case 0: ;
  case 14: ;
  break;
  default: 
  tmp___1 = __db_ferr((DB_ENV const   *)dbp___1->dbenv, "DBcursor->c_get", 0);
  return (tmp___1);
  }
  if (key->flags & 8U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "DB_DBT_PARTIAL may not be set on key during join_get");
    return (22);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )(dbp___1->dbenv)->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)(dbp___1->dbenv)->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)(dbp___1->dbenv)->rep_handle)->region)->flags != 0U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  handle_check = (unsigned int )tmp___2;
  if (handle_check) {
    ret = (u_int32_t )__db_rep_enter(dbp___1, 1, (unsigned int )dbc->txn != (unsigned int )((void *)0));
    if (ret != 0U) {
      return ((int )ret);
    }
  }
  flags = save_flags;
  ret = (u_int32_t )__db_join_get(dbc, key, data, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return ((int )ret);
}
}
static int __db_join_get(DBC *dbc , DBT *key_arg , DBT *data_arg , u_int32_t flags ) 
{ DBT *key_n ;
  DBT key_n_mem ;
  DB *dbp___1 ;
  DBC *cp ;
  JOIN_CURSOR *jc ;
  int db_manage_data ;
  int ret ;
  u_int32_t i ;
  u_int32_t j ;
  u_int32_t operation ;
  u_int32_t opmods ;
  int tmp ;
  int tmp___0 ;
  DBT *tmp___1 ;

  {
  dbp___1 = dbc->dbp;
  jc = (JOIN_CURSOR *)dbc->internal;
  operation = flags & 255U;
  opmods = flags & 301989888U;
  if (key_arg->flags & 32U) {
    key_n = & key_n_mem;
    memset((void *)key_n, 0, sizeof(DBT ));
  } else {
    if (key_arg->flags & 4U) {
      key_n = & key_n_mem;
      memset((void *)key_n, 0, sizeof(DBT ));
    } else {
      key_n = key_arg;
    }
  }
  if (jc->flags & 1U) {
    goto samekey;
  }
  jc->flags &= 4294967294U;
  retry: 
  if ((*(jc->j_exhausted + 0))) {
    tmp = 19;
  } else {
    tmp = 7;
  }
  ret = __db_c_get((*(jc->j_workcurs + 0)), & jc->j_key, key_n, opmods | (unsigned int )tmp);
  if (ret == 12) {
    jc->j_key.ulen = jc->j_key.ulen << 1;
    ret = __os_realloc(dbp___1->dbenv, jc->j_key.ulen, (void *)(& jc->j_key.data));
    if (ret != 0) {
      goto mem_err;
    }
    goto retry;
  }
  if (ret != 0) {
    goto err;
  }
  i = 1U;
  while (i < jc->j_ncurs) {
    if ((unsigned int )(*(jc->j_fdupcurs + i)) != (unsigned int )((void *)0)) {
      ret = __db_c_close((*(jc->j_fdupcurs + i)));
      if (ret != 0) {
        goto err;
      }
    }
    (*(jc->j_fdupcurs + i)) = (DBC *)((void *)0);
    i ++;
  }
  if ((unsigned int )(*(jc->j_curslist + 1)) == (unsigned int )((void *)0)) {
    (*(jc->j_exhausted + 0)) = (unsigned char)1;
  } else {
    (*(jc->j_exhausted + 0)) = (unsigned char)0;
  }
  i = 1U;
  while (i < jc->j_ncurs) {
    if ((unsigned int )(*(jc->j_workcurs + i)) == (unsigned int )((void *)0)) {
      ret = __db_c_dup((*(jc->j_curslist + i)), jc->j_workcurs + i, 24U);
      if (ret != 0) {
        goto err;
      }
    }
    retry2: 
    cp = (*(jc->j_workcurs + i));
    ret = __db_join_getnext(cp, & jc->j_key, key_n, (unsigned int )(*(jc->j_exhausted +
                                                                      i)), opmods);
    if (ret == -30990) {
      i --;
      (*(jc->j_exhausted + i)) = (unsigned char)1;
      if (i == 0U) {
        j = 1U;
        while ((unsigned int )(*(jc->j_workcurs + j)) != (unsigned int )((void *)0)) {
          ret = __db_c_close((*(jc->j_workcurs + j)));
          if (ret != 0) {
            goto err;
          }
          if (! ((unsigned int )(((*(jc->j_curslist + 0)))->dbp)->dup_compare != (unsigned int )((void *)0))) {
            (*(jc->j_workcurs + j)) = (DBC *)((void *)0);
          } else {
            if (! ((unsigned int )(((*(jc->j_curslist + j)))->dbp)->dup_compare !=
                   (unsigned int )((void *)0))) {
              (*(jc->j_workcurs + j)) = (DBC *)((void *)0);
            } else {
              if ((unsigned int )(*(jc->j_fdupcurs + j)) == (unsigned int )((void *)0)) {
                (*(jc->j_workcurs + j)) = (DBC *)((void *)0);
              } else {
                tmp___0 = __db_c_dup((*(jc->j_fdupcurs + j)), jc->j_workcurs + j,
                                     24U);
                if (tmp___0 != 0) {
                  goto err;
                }
              }
            }
          }
          (*(jc->j_exhausted + j)) = (unsigned char)0;
          j ++;
        }
        goto retry;
      }
      j = i + 1U;
      while ((unsigned int )(*(jc->j_workcurs + j)) != (unsigned int )((void *)0)) {
        ret = __db_c_close((*(jc->j_workcurs + j)));
        if (ret != 0) {
          goto err;
        }
        (*(jc->j_exhausted + j)) = (unsigned char)0;
        if ((unsigned int )(*(jc->j_fdupcurs + j)) != (unsigned int )((void *)0)) {
          ret = __db_c_dup((*(jc->j_fdupcurs + j)), jc->j_workcurs + j, 24U);
          if (ret != 0) {
            goto err;
          } else {
            (*(jc->j_workcurs + j)) = (DBC *)((void *)0);
          }
        } else {
          (*(jc->j_workcurs + j)) = (DBC *)((void *)0);
        }
        j ++;
      }
      goto retry2;
    }
    if (ret == 12) {
      jc->j_key.ulen = jc->j_key.ulen << 1;
      ret = __os_realloc(dbp___1->dbenv, jc->j_key.ulen, (void *)(& jc->j_key.data));
      if (ret != 0) {
        mem_err: 
        __db_err((DB_ENV const   *)dbp___1->dbenv, "Allocation failed for join key, len = %lu",
                 (unsigned long )jc->j_key.ulen);
        goto err;
      }
      goto retry2;
    }
    if (ret != 0) {
      goto err;
    }
    if (i + 1U != jc->j_ncurs) {
      (*(jc->j_exhausted + i)) = (unsigned char)0;
    } else {
      (*(jc->j_exhausted + i)) = (unsigned char)1;
    }
    if ((unsigned int )(((*(jc->j_curslist + i)))->dbp)->dup_compare != (unsigned int )((void *)0)) {
      if ((unsigned int )(*(jc->j_fdupcurs + i)) == (unsigned int )((void *)0)) {
        ret = __db_c_dup(cp, jc->j_fdupcurs + i, 24U);
        if (ret != 0) {
          goto err;
        }
      }
    }
    i ++;
  }
  err: 
  if (ret != 0) {
    return (ret);
  }
  if (0) {
    samekey: 
    ret = __db_c_get((*(jc->j_workcurs + 0)), & jc->j_key, key_n, 7U | opmods);
    if (ret != 0) {
      return (ret);
    }
    jc->flags &= 4294967294U;
  }
  if (key_arg->flags & 36U) {
    ret = __db_retcopy(dbp___1->dbenv, key_arg, key_n->data, key_n->size, (void **)((void *)0),
                       (u_int32_t *)((void *)0));
    if (ret != 0) {
      jc->flags |= 1U;
      return (ret);
    }
  }
  if (operation == 14U) {
    return (0);
  }
  if (! (data_arg->flags & 52U)) {
    db_manage_data = 1;
  } else {
    db_manage_data = 0;
  }
  if (db_manage_data) {
    tmp___1 = & jc->j_rdata;
  } else {
    tmp___1 = data_arg;
  }
  ret = __db_join_primget(jc->j_primary, ((*(jc->j_curslist + 0)))->txn, ((*(jc->j_curslist +
                                                                             0)))->locker,
                          key_arg, tmp___1, opmods);
  if (ret != 0) {
    if (ret == -30990) {
      ret = __db_secondary_corrupt(jc->j_primary);
    } else {
      jc->flags |= 1U;
    }
  }
  if (db_manage_data) {
    if (ret == 0) {
      data_arg->data = jc->j_rdata.data;
      data_arg->size = jc->j_rdata.size;
    }
  }
  return (ret);
}
}
int __db_join_close(DBC *dbc ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  JOIN_CURSOR *jc ;
  int ret ;
  int t_ret ;
  u_int32_t i ;
  int tmp ;

  {
  jc = (JOIN_CURSOR *)dbc->internal;
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  t_ret = 0;
  ret = t_ret;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  while (1) {
    if ((unsigned int )dbc->links.tqe_next != (unsigned int )((void *)0)) {
      (dbc->links.tqe_next)->links.tqe_prev = dbc->links.tqe_prev;
    } else {
      dbp___1->join_queue.tqh_last = dbc->links.tqe_prev;
    }
    (*(dbc->links.tqe_prev)) = dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  i = 0U;
  while (i < jc->j_ncurs) {
    if ((unsigned int )(*(jc->j_workcurs + i)) != (unsigned int )((void *)0)) {
      t_ret = __db_c_close((*(jc->j_workcurs + i)));
      if (t_ret != 0) {
        ret = t_ret;
      }
    }
    if ((unsigned int )(*(jc->j_fdupcurs + i)) != (unsigned int )((void *)0)) {
      t_ret = __db_c_close((*(jc->j_fdupcurs + i)));
      if (t_ret != 0) {
        ret = t_ret;
      }
    }
    i ++;
  }
  __os_free(dbenv___0, (void *)jc->j_exhausted);
  __os_free(dbenv___0, (void *)jc->j_curslist);
  __os_free(dbenv___0, (void *)jc->j_workcurs);
  __os_free(dbenv___0, (void *)jc->j_fdupcurs);
  __os_free(dbenv___0, jc->j_key.data);
  if ((unsigned int )jc->j_rdata.data != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, jc->j_rdata.data);
  }
  __os_free(dbenv___0, (void *)jc);
  __os_free(dbenv___0, (void *)dbc);
  return (ret);
}
}
static int __db_join_getnext(DBC *dbc , DBT *key , DBT *data , u_int32_t exhausted ,
                             u_int32_t opmods ) 
{ int ret ;
  int cmp ;
  DB *dbp___1 ;
  DBT ldata ;
  int (*func)(DB * , DBT const   * , DBT const   * ) ;

  {
  dbp___1 = dbc->dbp;
  if ((unsigned int )dbp___1->dup_compare == (unsigned int )((void *)0)) {
    func = & __bam_defcmp;
  } else {
    func = dbp___1->dup_compare;
  }
  switch ((int )exhausted) {
  case 0: 
  memset((void *)(& ldata), 0, sizeof(DBT ));
  ldata.flags = ldata.flags | 4U;
  ret = __db_c_get(dbc, key, & ldata, opmods | 7U);
  if (ret != 0) {
    break;
  }
  cmp = ((*func))(dbp___1, (DBT const   *)data, (DBT const   *)(& ldata));
  if (cmp == 0) {
    ret = __db_retcopy(dbp___1->dbenv, data, ldata.data, ldata.size, & data->data,
                       & data->size);
    if (ret != 0) {
      return (ret);
    }
    __os_ufree(dbp___1->dbenv, ldata.data);
    return (0);
  }
  __os_ufree(dbp___1->dbenv, ldata.data);
  case 1: 
  ret = __db_c_get(dbc, key, data, opmods | 11U);
  break;
  default: 
  ret = 22;
  break;
  }
  return (ret);
}
}
static int __db_join_cmp(void const   *a , void const   *b ) 
{ DBC *dbca ;
  DBC *dbcb ;
  db_recno_t counta ;
  db_recno_t countb ;
  int tmp ;
  int tmp___0 ;

  {
  dbca = (DBC *)(*((DBC * const  *)a));
  dbcb = (DBC *)(*((DBC * const  *)b));
  tmp = __db_c_count(dbca, & counta);
  if (tmp != 0) {
    return (0);
  } else {
    tmp___0 = __db_c_count(dbcb, & countb);
    if (tmp___0 != 0) {
      return (0);
    }
  }
  return ((int )((long )counta - (long )countb));
}
}
static int __db_join_primget(DB *dbp___1 , DB_TXN *txn , u_int32_t lockerid , DBT *key ,
                             DBT *data , u_int32_t flags ) 
{ DBC *dbc ;
  int dirty ;
  int ret ;
  int rmw ;
  int t_ret ;

  {
  rmw = (int )(flags & 268435456U);
  dirty = (int )(flags & 33554432U);
  flags &= 3992977407U;
  ret = __db_cursor_int(dbp___1, txn, dbp___1->type, 0U, 0, lockerid, & dbc);
  if (ret != 0) {
    return (ret);
  }
  if (dirty) {
    dbc->flags = dbc->flags | 4U;
  } else {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      if (txn->flags & 4U) {
        dbc->flags = dbc->flags | 4U;
      }
    }
  }
  dbc->flags = dbc->flags | 64U;
  while (1) {
    dbc->rskey = & dbp___1->my_rskey;
    dbc->rkey = & dbp___1->my_rkey;
    dbc->rdata = & dbp___1->my_rdata;
    break;
  }
  ret = __db_c_get(dbc, key, data, (unsigned int )(28 | rmw));
  t_ret = __db_c_close(dbc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_secondary_corrupt(DB *dbp___1 ) 
{ 

  {
  __db_err((DB_ENV const   *)dbp___1->dbenv, "Secondary index corrupt: not consistent with primary");
  return (-30977);
}
}
#pragma merger(0,"/tmp/cil-hSkRHwjS.i","-O2")
u_int32_t __db_log2(u_int32_t num ) 
{ u_int32_t i ;
  u_int32_t limit ;

  {
  limit = 1U;
  i = 0U;
  while (limit < num) {
    i ++;
    limit = limit << 1;
  }
  return (i);
}
}
#pragma merger(0,"/tmp/cil-TGrwMCQs.i","-O2")
static void __db_init_meta(DB *dbp___1 , void *p , db_pgno_t pgno , u_int32_t pgtype ) ;
static void __db_init_meta(DB *dbp___1 , void *p , db_pgno_t pgno , u_int32_t pgtype ) 
{ DB_LSN save_lsn ;
  DBMETA *meta ;

  {
  meta = (DBMETA *)p;
  save_lsn = meta->lsn;
  memset((void *)meta, 0, sizeof(DBMETA ));
  meta->lsn = save_lsn;
  meta->pagesize = dbp___1->pgsize;
  if (dbp___1->flags & 1U) {
    meta->metaflags = (unsigned char )((int )meta->metaflags | 1);
  }
  meta->pgno = pgno;
  meta->type = (unsigned char )pgtype;
  return;
}
}
int __db_new(DBC *dbc , u_int32_t type , PAGE **pagepp ) 
{ DBMETA *meta ;
  DB *dbp___1 ;
  DB_LOCK metalock ;
  DB_LSN lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t last ;
  db_pgno_t pgno ;
  db_pgno_t newnext ;
  u_int32_t meta_flags ;
  int extend ;
  int ret ;
  int tmp ;

  {
  meta = (DBMETA *)((void *)0);
  meta_flags = 0U;
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  h = (PAGE *)((void *)0);
  newnext = 0U;
  pgno = 0U;
  ret = __db_lget(dbc, 1, pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  last = meta->last_pgno;
  if (meta->free == 0U) {
    pgno = meta->last_pgno + 1U;
    last = pgno;
    while (1) {
      lsn.file = 0U;
      lsn.offset = 0U;
      break;
    }
    extend = 1;
  } else {
    pgno = meta->free;
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
    newnext = h->next_pgno;
    lsn = h->lsn;
    extend = 0;
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __db_pg_alloc_log(dbp___1, dbc->txn, & ((PAGE *)meta)->lsn, 0U, & ((PAGE *)meta)->lsn,
                                  0U, & lsn, pgno, type, newnext);
          if (ret != 0) {
            goto err;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      ((PAGE *)meta)->lsn.file = 0U;
      ((PAGE *)meta)->lsn.offset = 1U;
      break;
    }
  }
  meta_flags = 2U;
  meta->free = newnext;
  if (extend == 1) {
    ret = __memp_fget(mpf, & pgno, 4U, (void *)(& h));
    if (ret != 0) {
      goto err;
    }
    meta->last_pgno = pgno;
    while (1) {
      h->lsn.file = 0U;
      h->lsn.offset = 0U;
      break;
    }
    h->pgno = pgno;
  }
  h->lsn = ((PAGE *)meta)->lsn;
  if ((int )h->type != 0) {
    tmp = __db_panic(dbp___1->dbenv, 22);
    return (tmp);
  }
  __memp_fput(mpf, (void *)((PAGE *)meta), 2U);
  if (metalock.off != 0U) {
    __db_lput(dbc, & metalock);
  }
  switch ((int )type) {
  case 9: ;
  case 8: ;
  case 10: 
  __db_init_meta(dbp___1, (void *)h, h->pgno, type);
  break;
  default: ;
  while (1) {
    h->pgno = h->pgno;
    h->prev_pgno = 0U;
    h->next_pgno = 0U;
    h->entries = (unsigned short)0;
    h->hf_offset = (unsigned short )dbp___1->pgsize;
    h->level = (unsigned char)0;
    h->type = (unsigned char )type;
    break;
  }
  break;
  }
  if ((dbc->dbp)->flags & 128U) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      ret = __db_lget(dbc, 0, h->pgno, (enum __anonenum_db_lockmode_t_50 )8, 0U, & metalock);
      if (ret != 0) {
        goto err;
      }
    }
  }
  (*pagepp) = h;
  return (0);
  err: 
  if ((unsigned int )h != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)h, 0U);
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, meta_flags);
  }
  if (metalock.off != 0U) {
    __db_lput(dbc, & metalock);
  }
  return (ret);
}
}
int __db_free(DBC *dbc , PAGE *h ) 
{ DBMETA *meta ;
  DB *dbp___1 ;
  DBT ddbt ;
  DBT ldbt ;
  DB_LOCK metalock ;
  DB_MPOOLFILE *mpf ;
  db_pgno_t pgno ;
  u_int32_t dirty_flag ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  dirty_flag = 0U;
  pgno = 0U;
  ret = __db_lget(dbc, 1, pgno, (enum __anonenum_db_lockmode_t_50 )2, 0U, & metalock);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    if (metalock.off != 0U) {
      __db_lput(dbc, & metalock);
    }
    goto err;
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          memset((void *)(& ldbt), 0, sizeof(ldbt));
          ldbt.data = (void *)h;
          if (dbp___1->flags & 2048U) {
            tmp___0 = sizeof(PG_CRYPTO );
          } else {
            if (dbp___1->flags & 1U) {
              tmp___0 = sizeof(PG_CHKSUM );
            } else {
              tmp___0 = 0U;
            }
          }
          ldbt.size = (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                       26) +
                                                                                      tmp___0))));
          switch ((int )h->type) {
          case 2: ;
          case 3: ;
          case 4: ;
          case 5: ;
          case 6: ;
          case 12: ;
          if ((int )h->entries > 0) {
            ldbt.size = ldbt.size + (unsigned int )h->entries * sizeof(db_indx_t );
            ddbt.data = (void *)((u_int8_t *)h + (int )h->hf_offset);
            ddbt.size = dbp___1->pgsize - (unsigned int )h->hf_offset;
            ret = __db_pg_freedata_log(dbp___1, dbc->txn, & ((PAGE *)meta)->lsn, 0U,
                                       h->pgno, & ((PAGE *)meta)->lsn, 0U, (DBT const   *)(& ldbt),
                                       meta->free, (DBT const   *)(& ddbt));
            break;
          }
          goto log;
          case 8: 
          ldbt.size = sizeof(HMETA );
          goto log;
          case 9: 
          ldbt.size = sizeof(BTMETA );
          goto log;
          case 7: 
          ldbt.size = ldbt.size + (unsigned int )h->hf_offset;
          goto log;
          default: ;
          log: 
          ret = __db_pg_free_log(dbp___1, dbc->txn, & ((PAGE *)meta)->lsn, 0U, h->pgno,
                                 & ((PAGE *)meta)->lsn, 0U, (DBT const   *)(& ldbt),
                                 meta->free);
          }
          if (ret != 0) {
            __memp_fput(mpf, (void *)((PAGE *)meta), 0U);
            if (metalock.off != 0U) {
              __db_lput(dbc, & metalock);
            }
            goto err;
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      ((PAGE *)meta)->lsn.file = 0U;
      ((PAGE *)meta)->lsn.offset = 1U;
      break;
    }
  }
  h->lsn = ((PAGE *)meta)->lsn;
  while (1) {
    h->pgno = h->pgno;
    h->prev_pgno = 0U;
    h->next_pgno = meta->free;
    h->entries = (unsigned short)0;
    h->hf_offset = (unsigned short )dbp___1->pgsize;
    h->level = (unsigned char)0;
    h->type = (unsigned char)0;
    break;
  }
  meta->free = h->pgno;
  t_ret = __memp_fput(mpf, (void *)((PAGE *)meta), 2U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (metalock.off != 0U) {
    t_ret = __db_lput(dbc, & metalock);
  } else {
    t_ret = 0;
  }
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  dirty_flag = 2U;
  err: 
  t_ret = __memp_fput(mpf, (void *)h, dirty_flag);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_lget(DBC *dbc , int action , db_pgno_t pgno , db_lockmode_t mode , u_int32_t lkflags ,
              DB_LOCK *lockp ) 
{ DB *dbp___1 ;
  DB_ENV *dbenv___0 ;
  DB_LOCKREQ couple[2] ;
  DB_LOCKREQ *reqp ;
  DB_TXN *txn ;
  int has_timeout ;
  int ret ;
  int tmp ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  txn = dbc->txn;
  if (dbenv___0->flags & 2U) {
    lockp->off = 0U;
    return (0);
  } else {
    if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
      lockp->off = 0U;
      return (0);
    } else {
      if (dbc->flags & 2U) {
        lockp->off = 0U;
        return (0);
      } else {
        if (dbc->flags & 16U) {
          if (action != 5) {
            lockp->off = 0U;
            return (0);
          } else {
            if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
              if (((DB_REP *)dbenv___0->rep_handle)->region) {
                if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
                  lockp->off = 0U;
                  return (0);
                } else {
                  goto _L;
                }
              } else {
                goto _L;
              }
            } else {
              goto _L;
            }
          }
        } else {
          _L: 
          if (action != 1) {
            if (dbc->flags & 8U) {
              lockp->off = 0U;
              return (0);
            }
          }
        }
      }
    }
  }
  dbc->lock.pgno = pgno;
  if (lkflags & 2U) {
    dbc->lock.type = 2U;
  } else {
    dbc->lock.type = 3U;
  }
  lkflags &= 4294967293U;
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((dbc->txn)->flags & 64U) {
      lkflags |= 1U;
    }
  }
  if (dbc->flags & 4U) {
    if ((int )mode == 1) {
      mode = (enum __anonenum_db_lockmode_t_50 )7;
    }
  }
  if (dbc->flags & 16U) {
    tmp = 1;
  } else {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      if (txn->flags & 8U) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  }
  has_timeout = tmp;
  if (action == 2) {
    goto _L___2;
  } else {
    if (action == 3) {
      _L___2: 
      if (lockp->off != 0U) {
        if ((unsigned int )dbc->txn == (unsigned int )((void *)0)) {
          tmp___2 = 2;
        } else {
          if (action == 3) {
            tmp___2 = 2;
          } else {
            if (dbc->flags & 4U) {
              if ((int )lockp->mode == 7) {
                tmp___2 = 2;
              } else {
                goto _L___1;
              }
            } else {
              _L___1: 
              if ((dbc->dbp)->flags & 128U) {
                if ((int )lockp->mode == 2) {
                  tmp___2 = 4;
                } else {
                  tmp___2 = 0;
                }
              } else {
                tmp___2 = 0;
              }
            }
          }
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  }
  switch (tmp___2) {
  case 2: ;
  lck_couple: 
  if (has_timeout) {
    couple[0].op = (enum __anonenum_db_lockop_t_51 )2;
  } else {
    couple[0].op = (enum __anonenum_db_lockop_t_51 )1;
  }
  couple[0].obj = & dbc->lock_dbt;
  couple[0].mode = mode;
  if (action == 3) {
    action = 2;
  }
  if (has_timeout) {
    if (dbc->flags & 16U) {
      couple[0].timeout = 0U;
    } else {
      couple[0].timeout = txn->lock_timeout;
    }
  }
  if (action == 2) {
    couple[1].op = (enum __anonenum_db_lockop_t_51 )4;
    couple[1].lock = (*lockp);
  }
  if (action == 2) {
    tmp___4 = 2;
  } else {
    tmp___4 = 1;
  }
  ret = __lock_vec(dbenv___0, dbc->locker, lkflags, couple, tmp___4, & reqp);
  if (ret == 0) {
    (*lockp) = couple[0].lock;
  } else {
    if ((unsigned int )reqp == (unsigned int )(& couple[1])) {
      (*lockp) = couple[0].lock;
    }
  }
  break;
  case 4: 
  ret = __lock_downgrade(dbenv___0, lockp, (enum __anonenum_db_lockmode_t_50 )8, 0U);
  if (ret != 0) {
    return (ret);
  }
  default: ;
  if (has_timeout) {
    goto lck_couple;
  }
  ret = __lock_get(dbenv___0, dbc->locker, lkflags, (DBT const   *)(& dbc->lock_dbt),
                   mode, lockp);
  break;
  }
  if (ret == -30994) {
    if (! (dbenv___0->flags & 2097152U)) {
      tmp___5 = -30995;
    } else {
      tmp___5 = ret;
    }
  } else {
    tmp___5 = ret;
  }
  return (tmp___5);
}
}
int __db_lput(DBC *dbc , DB_LOCK *lockp ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp___1 ;

  {
  dbenv___0 = (dbc->dbp)->dbenv;
  if (lockp->off != 0U) {
    if ((unsigned int )dbc->txn == (unsigned int )((void *)0)) {
      tmp___1 = 2;
    } else {
      if (dbc->flags & 4U) {
        if ((int )lockp->mode == 7) {
          tmp___1 = 2;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if ((dbc->dbp)->flags & 128U) {
          if ((int )lockp->mode == 2) {
            tmp___1 = 4;
          } else {
            tmp___1 = 0;
          }
        } else {
          tmp___1 = 0;
        }
      }
    }
  } else {
    tmp___1 = 0;
  }
  switch (tmp___1) {
  case 2: 
  ret = __lock_put(dbenv___0, lockp);
  break;
  case 4: 
  ret = __lock_downgrade(dbenv___0, lockp, (enum __anonenum_db_lockmode_t_50 )8, 0U);
  break;
  default: 
  ret = 0;
  break;
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-6pin20SM.i","-O2")
struct __db_globals __db_global_values ;
int __dbenv_set_alloc(DB_ENV *dbenv___0 , void *(*mal_func)(size_t  ) , void *(*real_func)(void * ,
                                                                                           size_t  ) ,
                      void (*free_func)(void * ) ) ;
int __dbenv_get_encrypt_flags(DB_ENV *dbenv___0 , u_int32_t *flagsp ) ;
void __dbenv_set_errcall(DB_ENV *dbenv___0 , void (*errcall)(char const   * , char * ) ) ;
void __dbenv_get_errfile(DB_ENV *dbenv___0 , FILE **errfilep ) ;
void __dbenv_set_errfile(DB_ENV *dbenv___0 , FILE *errfile ) ;
void __dbenv_get_errpfx(DB_ENV *dbenv___0 , char const   **errpfxp ) ;
void __dbenv_set_errpfx(DB_ENV *dbenv___0 , char const   *errpfx ) ;
int __dbenv_set_paniccall(DB_ENV *dbenv___0 , void (*paniccall)(DB_ENV * , int  ) ) ;
int __db_mi_env(DB_ENV *dbenv___0 , char const   *name ) ;
int __db_set_lorder(DB *dbp___1 , int db_lorder ) ;
int __db_get_open_flags(DB *dbp___1 , u_int32_t *flagsp ) ;
int __db_remove_pp(DB *dbp___1 , char const   *name , char const   *subdb , u_int32_t flags ) ;
int __db_rename_pp(DB *dbp___1 , char const   *name , char const   *subdb , char const   *newname ,
                   u_int32_t flags ) ;
int __db_truncate_pp(DB *dbp___1 , DB_TXN *txn , u_int32_t *countp , u_int32_t flags ) ;
int __db_upgrade_pp(DB *dbp___1 , char const   *fname , u_int32_t flags ) ;
int __memp_get_cachesize(DB_ENV *dbenv___0 , u_int32_t *gbytesp , u_int32_t *bytesp ,
                         int *ncachep ) ;
int __db_xa_create(DB *dbp___1 ) ;
static int __db_get_byteswapped(DB *dbp___1 , int *isswapped ) ;
static int __db_get_dbname(DB *dbp___1 , char const   **fnamep , char const   **dnamep ) ;
static int __db_get_env(DB *dbp___1 , DB_ENV **dbenvp ) ;
static int __db_get_lorder(DB *dbp___1 , int *db_lorderp ) ;
static int __db_get_transactional(DB *dbp___1 , int *istxnp ) ;
static int __db_get_type(DB *dbp___1 , DBTYPE *dbtype ) ;
static int __db_init(DB *dbp___1 , u_int32_t flags ) ;
static int __db_set_alloc(DB *dbp___1 , void *(*mal_func)(size_t  ) , void *(*real_func)(void * ,
                                                                                         size_t  ) ,
                          void (*free_func)(void * ) ) ;
static int __db_set_append_recno(DB *dbp___1 , int (*func)(DB * , DBT * , db_recno_t  ) ) ;
static int __db_get_cachesize(DB *dbp___1 , u_int32_t *cache_gbytesp , u_int32_t *cache_bytesp ,
                              int *ncachep ) ;
static int __db_set_cachesize(DB *dbp___1 , u_int32_t cache_gbytes , u_int32_t cache_bytes ,
                              int ncache ) ;
static int __db_set_dup_compare(DB *dbp___1 , int (*func)(DB * , DBT const   * , DBT const   * ) ) ;
static int __db_get_encrypt_flags(DB *dbp___1 , u_int32_t *flagsp ) ;
static int __db_set_encrypt(DB *dbp___1 , char const   *passwd , u_int32_t flags ) ;
static int __db_set_feedback(DB *dbp___1 , void (*feedback)(DB * , int  , int  ) ) ;
static void __db_map_flags(DB *dbp___1 , u_int32_t *inflagsp , u_int32_t *outflagsp ) ;
static int __db_get_flags(DB *dbp___1 , u_int32_t *flagsp ) ;
static int __db_get_pagesize(DB *dbp___1 , u_int32_t *db_pagesizep ) ;
static int __db_set_paniccall(DB *dbp___1 , void (*paniccall)(DB_ENV * , int  ) ) ;
static void __db_set_errcall(DB *dbp___1 , void (*errcall)(char const   * , char * ) ) ;
static void __db_get_errfile(DB *dbp___1 , FILE **errfilep ) ;
static void __db_set_errfile(DB *dbp___1 , FILE *errfile ) ;
static void __db_get_errpfx(DB *dbp___1 , char const   **errpfxp ) ;
static void __db_set_errpfx(DB *dbp___1 , char const   *errpfx ) ;
static void __dbh_err(DB *dbp___1 , int error , char const   *fmt  , ...) ;
static void __dbh_errx(DB *dbp___1 , char const   *fmt  , ...) ;
int db_create(DB **dbpp , DB_ENV *dbenv___0 , u_int32_t flags ) 
{ DB *dbp___1 ;
  int ret ;
  int tmp ;

  {
  switch ((int )flags) {
  case 0: ;
  break;
  case 1: ;
  break;
  case 2: ;
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "XA applications may not specify an environment to db_create");
    return (22);
  }
  dbenv___0 = __db_global_values.db_envq.tqh_first;
  break;
  default: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, "db_create", 0);
  return (tmp);
  }
  ret = __os_calloc(dbenv___0, 1U, sizeof((*dbp___1)), (void *)(& dbp___1));
  if (ret != 0) {
    return (ret);
  }
  ret = __db_init(dbp___1, flags);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
    ret = db_env_create(& dbenv___0, 0U);
    if (ret != 0) {
      goto err;
    }
    dbenv___0->flags = dbenv___0->flags | 16U;
  }
  dbp___1->dbenv = dbenv___0;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  dbenv___0->db_ref = dbenv___0->db_ref + 1;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (dbenv___0->flags & 16U) {
    dbp___1->timestamp = 0L;
  } else {
    if (! ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0))) {
      dbp___1->timestamp = 0L;
    } else {
      dbp___1->timestamp = (((DB_REP *)dbenv___0->rep_handle)->region)->timestamp;
    }
  }
  ret = __memp_fcreate(dbenv___0, & dbp___1->mpf);
  if (ret != 0) {
    goto err;
  }
  dbp___1->type = (enum __anonenum_DBTYPE_61 )5;
  (*dbpp) = dbp___1;
  return (0);
  err: 
  if ((unsigned int )dbp___1->mpf != (unsigned int )((void *)0)) {
    __memp_fclose(dbp___1->mpf, 0U);
  }
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if (dbenv___0->flags & 16U) {
      __dbenv_close(dbenv___0, 0);
    }
  }
  __os_free(dbenv___0, (void *)dbp___1);
  (*dbpp) = (DB *)((void *)0);
  return (ret);
}
}
static int __db_init(DB *dbp___1 , u_int32_t flags ) 
{ int ret ;

  {
  dbp___1->lid = 0U;
  dbp___1->handle_lock.off = 0U;
  while (1) {
    dbp___1->free_queue.tqh_first = (struct __dbc *)((void *)0);
    dbp___1->free_queue.tqh_last = & dbp___1->free_queue.tqh_first;
    break;
  }
  while (1) {
    dbp___1->active_queue.tqh_first = (struct __dbc *)((void *)0);
    dbp___1->active_queue.tqh_last = & dbp___1->active_queue.tqh_first;
    break;
  }
  while (1) {
    dbp___1->join_queue.tqh_first = (struct __dbc *)((void *)0);
    dbp___1->join_queue.tqh_last = & dbp___1->join_queue.tqh_first;
    break;
  }
  while (1) {
    dbp___1->s_secondaries.lh_first = (struct __db *)((void *)0);
    break;
  }
  dbp___1->am_ok = dbp___1->am_ok | 15U;
  dbp___1->associate = & __db_associate_pp;
  dbp___1->close = & __db_close_pp;
  dbp___1->cursor = & __db_cursor_pp;
  dbp___1->del = & __db_del_pp;
  dbp___1->err = & __dbh_err;
  dbp___1->errx = & __dbh_errx;
  dbp___1->fd = & __db_fd_pp;
  dbp___1->get = & __db_get_pp;
  dbp___1->get_byteswapped = & __db_get_byteswapped;
  dbp___1->get_dbname = & __db_get_dbname;
  dbp___1->get_env = & __db_get_env;
  dbp___1->get_open_flags = & __db_get_open_flags;
  dbp___1->get_transactional = & __db_get_transactional;
  dbp___1->get_type = & __db_get_type;
  dbp___1->join = & __db_join_pp;
  dbp___1->key_range = & __db_key_range_pp;
  dbp___1->open = & __db_open_pp;
  dbp___1->pget = & __db_pget_pp;
  dbp___1->put = & __db_put_pp;
  dbp___1->remove = & __db_remove_pp;
  dbp___1->rename = & __db_rename_pp;
  dbp___1->truncate = & __db_truncate_pp;
  dbp___1->set_alloc = & __db_set_alloc;
  dbp___1->set_append_recno = & __db_set_append_recno;
  dbp___1->get_cachesize = & __db_get_cachesize;
  dbp___1->set_cachesize = & __db_set_cachesize;
  dbp___1->set_dup_compare = & __db_set_dup_compare;
  dbp___1->get_encrypt_flags = & __db_get_encrypt_flags;
  dbp___1->set_encrypt = & __db_set_encrypt;
  dbp___1->set_errcall = & __db_set_errcall;
  dbp___1->get_errfile = & __db_get_errfile;
  dbp___1->set_errfile = & __db_set_errfile;
  dbp___1->get_errpfx = & __db_get_errpfx;
  dbp___1->set_errpfx = & __db_set_errpfx;
  dbp___1->set_feedback = & __db_set_feedback;
  dbp___1->get_flags = & __db_get_flags;
  dbp___1->set_flags = & __db_set_flags;
  dbp___1->get_lorder = & __db_get_lorder;
  dbp___1->set_lorder = & __db_set_lorder;
  dbp___1->get_pagesize = & __db_get_pagesize;
  dbp___1->set_pagesize = & __db_set_pagesize;
  dbp___1->set_paniccall = & __db_set_paniccall;
  dbp___1->stat = & __db_stat_pp;
  dbp___1->sync = & __db_sync_pp;
  dbp___1->upgrade = & __db_upgrade_pp;
  dbp___1->verify = & __db_verify_pp;
  ret = __bam_db_create(dbp___1);
  if (ret != 0) {
    return (ret);
  }
  ret = __ham_db_create(dbp___1);
  if (ret != 0) {
    return (ret);
  }
  ret = __qam_db_create(dbp___1);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 2U) {
    ret = __db_xa_create(dbp___1);
    if (ret != 0) {
      return (ret);
    }
  }
  if (flags & 1U) {
    dbp___1->flags = dbp___1->flags | 8388608U;
  }
  return (0);
}
}
int __dbh_am_chk(DB *dbp___1 , u_int32_t flags ) 
{ 

  {
  if (flags & 1U) {
    if (dbp___1->am_ok & 1U) {
      dbp___1->am_ok = dbp___1->am_ok & ~ (~ flags);
      return (0);
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if (flags & 2U) {
      if (dbp___1->am_ok & 2U) {
        dbp___1->am_ok = dbp___1->am_ok & ~ (~ flags);
        return (0);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (flags & 4U) {
        if (dbp___1->am_ok & 4U) {
          dbp___1->am_ok = dbp___1->am_ok & ~ (~ flags);
          return (0);
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (flags & 8U) {
          if (dbp___1->am_ok & 8U) {
            dbp___1->am_ok = dbp___1->am_ok & ~ (~ flags);
            return (0);
          }
        }
      }
    }
  }
  __db_err((DB_ENV const   *)dbp___1->dbenv, "call implies an access method which is inconsistent with previous calls");
  return (22);
}
}
static void __dbh_err(DB *dbp___1 , int error , char const   *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbp___1->dbenv != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbp___1->dbenv)->db_errcall != (unsigned int )((void *)0)) {
      __db_errcall((DB_ENV const   *)dbp___1->dbenv, error, 1, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbp___1->dbenv != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbp___1->dbenv)->db_errfile != (unsigned int )((void *)0)) {
      __db_errfile((DB_ENV const   *)dbp___1->dbenv, error, 1, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbp___1->dbenv == (unsigned int )((void *)0)) {
    __db_errfile((DB_ENV const   *)dbp___1->dbenv, error, 1, fmt, ap);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->db_errcall == (unsigned int )((void *)0)) {
      if ((unsigned int )(dbp___1->dbenv)->db_errfile == (unsigned int )((void *)0)) {
        __db_errfile((DB_ENV const   *)dbp___1->dbenv, error, 1, fmt, ap);
      }
    }
  }
  __builtin_va_end(ap);
  return;
}
}
static void __dbh_errx(DB *dbp___1 , char const   *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbp___1->dbenv != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbp___1->dbenv)->db_errcall != (unsigned int )((void *)0)) {
      __db_errcall((DB_ENV const   *)dbp___1->dbenv, 0, 0, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbp___1->dbenv != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbp___1->dbenv)->db_errfile != (unsigned int )((void *)0)) {
      __db_errfile((DB_ENV const   *)dbp___1->dbenv, 0, 0, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbp___1->dbenv == (unsigned int )((void *)0)) {
    __db_errfile((DB_ENV const   *)dbp___1->dbenv, 0, 0, fmt, ap);
  } else {
    if ((unsigned int )(dbp___1->dbenv)->db_errcall == (unsigned int )((void *)0)) {
      if ((unsigned int )(dbp___1->dbenv)->db_errfile == (unsigned int )((void *)0)) {
        __db_errfile((DB_ENV const   *)dbp___1->dbenv, 0, 0, fmt, ap);
      }
    }
  }
  __builtin_va_end(ap);
  return;
}
}
static int __db_get_byteswapped(DB *dbp___1 , int *isswapped ) 
{ int tmp ;

  {
  if (! (dbp___1->flags & 65536U)) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->get_byteswapped", 0);
    return (tmp);
  }
  if (dbp___1->flags & 268435456U) {
    (*isswapped) = 1;
  } else {
    (*isswapped) = 0;
  }
  return (0);
}
}
static int __db_get_dbname(DB *dbp___1 , char const   **fnamep , char const   **dnamep ) 
{ int tmp ;

  {
  if (! (dbp___1->flags & 65536U)) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->get_dbname", 0);
    return (tmp);
  }
  if ((unsigned int )fnamep != (unsigned int )((void *)0)) {
    (*fnamep) = (char const   *)dbp___1->fname;
  }
  if ((unsigned int )dnamep != (unsigned int )((void *)0)) {
    (*dnamep) = (char const   *)dbp___1->dname;
  }
  return (0);
}
}
static int __db_get_env(DB *dbp___1 , DB_ENV **dbenvp ) 
{ 

  {
  (*dbenvp) = dbp___1->dbenv;
  return (0);
}
}
static int __db_get_transactional(DB *dbp___1 , int *istxnp ) 
{ int tmp ;

  {
  if (! (dbp___1->flags & 65536U)) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->get_transactional", 0);
    return (tmp);
  }
  if (dbp___1->flags & 536870912U) {
    (*istxnp) = 1;
  } else {
    (*istxnp) = 0;
  }
  return (0);
}
}
static int __db_get_type(DB *dbp___1 , DBTYPE *dbtype ) 
{ int tmp ;

  {
  if (! (dbp___1->flags & 65536U)) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->get_type", 0);
    return (tmp);
  }
  (*dbtype) = dbp___1->type;
  return (0);
}
}
static int __db_set_append_recno(DB *dbp___1 , int (*func)(DB * , DBT * , db_recno_t  ) ) 
{ int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_append_recno", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 12U);
  if (__ret != 0) {
    return (__ret);
  }
  dbp___1->db_append_recno = func;
  return (0);
}
}
static int __db_get_cachesize(DB *dbp___1 , u_int32_t *cache_gbytesp , u_int32_t *cache_bytesp ,
                              int *ncachep ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (! ((dbp___1->dbenv)->flags & 16U)) {
    tmp = __db_mi_env(dbp___1->dbenv, "DB->get_cachesize");
    return (tmp);
  }
  tmp___0 = __memp_get_cachesize(dbp___1->dbenv, cache_gbytesp, cache_bytesp, ncachep);
  return (tmp___0);
}
}
static int __db_set_cachesize(DB *dbp___1 , u_int32_t cache_gbytes , u_int32_t cache_bytes ,
                              int ncache ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! ((dbp___1->dbenv)->flags & 16U)) {
    tmp = __db_mi_env(dbp___1->dbenv, "DB->set_cachesize");
    return (tmp);
  }
  if (dbp___1->flags & 65536U) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->set_cachesize", 1);
    return (tmp___0);
  }
  tmp___1 = __memp_set_cachesize(dbp___1->dbenv, cache_gbytes, cache_bytes, ncache);
  return (tmp___1);
}
}
static int __db_set_dup_compare(DB *dbp___1 , int (*func)(DB * , DBT const   * , DBT const   * ) ) 
{ int ret ;
  int tmp ;
  int __ret ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->dup_compare", 1);
    return (tmp);
  }
  __ret = __dbh_am_chk(dbp___1, 3U);
  if (__ret != 0) {
    return (__ret);
  }
  ret = __db_set_flags(dbp___1, 4U);
  if (ret != 0) {
    return (ret);
  }
  dbp___1->dup_compare = func;
  return (0);
}
}
static int __db_get_encrypt_flags(DB *dbp___1 , u_int32_t *flagsp ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (! ((dbp___1->dbenv)->flags & 16U)) {
    tmp = __db_mi_env(dbp___1->dbenv, "DB->get_encrypt_flags");
    return (tmp);
  }
  tmp___0 = __dbenv_get_encrypt_flags(dbp___1->dbenv, flagsp);
  return (tmp___0);
}
}
static int __db_set_encrypt(DB *dbp___1 , char const   *passwd , u_int32_t flags ) 
{ DB_CIPHER *db_cipher ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! ((dbp___1->dbenv)->flags & 16U)) {
    tmp = __db_mi_env(dbp___1->dbenv, "DB->set_encrypt");
    return (tmp);
  }
  if (dbp___1->flags & 65536U) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->set_encrypt", 1);
    return (tmp___0);
  }
  ret = __dbenv_set_encrypt(dbp___1->dbenv, passwd, flags);
  if (ret != 0) {
    return (ret);
  }
  db_cipher = (DB_CIPHER *)(dbp___1->dbenv)->crypto_handle;
  if (! (db_cipher->flags & 1U)) {
    ret = ((*(db_cipher->init)))(dbp___1->dbenv, db_cipher);
    if (ret != 0) {
      return (ret);
    }
  }
  tmp___1 = __db_set_flags(dbp___1, 8U);
  return (tmp___1);
}
}
static void __db_set_errcall(DB *dbp___1 , void (*errcall)(char const   * , char * ) ) 
{ 

  {
  __dbenv_set_errcall(dbp___1->dbenv, errcall);
  return;
}
}
static void __db_get_errfile(DB *dbp___1 , FILE **errfilep ) 
{ 

  {
  __dbenv_get_errfile(dbp___1->dbenv, errfilep);
  return;
}
}
static void __db_set_errfile(DB *dbp___1 , FILE *errfile ) 
{ 

  {
  __dbenv_set_errfile(dbp___1->dbenv, errfile);
  return;
}
}
static void __db_get_errpfx(DB *dbp___1 , char const   **errpfxp ) 
{ 

  {
  __dbenv_get_errpfx(dbp___1->dbenv, errpfxp);
  return;
}
}
static void __db_set_errpfx(DB *dbp___1 , char const   *errpfx ) 
{ 

  {
  __dbenv_set_errpfx(dbp___1->dbenv, errpfx);
  return;
}
}
static int __db_set_feedback(DB *dbp___1 , void (*feedback)(DB * , int  , int  ) ) 
{ 

  {
  dbp___1->db_feedback = feedback;
  return (0);
}
}
static void __db_map_flags(DB *dbp___1 , u_int32_t *inflagsp , u_int32_t *outflagsp ) 
{ 

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  if ((*inflagsp) & 1U) {
    (*outflagsp) |= 1U;
    (*inflagsp) &= 4294967294U;
  }
  if ((*inflagsp) & 8U) {
    (*outflagsp) |= 2049U;
    (*inflagsp) &= 4294967287U;
  }
  if ((*inflagsp) & 512U) {
    (*outflagsp) |= 32768U;
    (*inflagsp) &= 4294966783U;
  }
  return;
}
}
static u_int32_t const   db_flags[10]  = 
  {      (u_int32_t const   )1U,      (u_int32_t const   )2U,      (u_int32_t const   )4U,      (u_int32_t const   )8U, 
        (u_int32_t const   )16U,      (u_int32_t const   )32U,      (u_int32_t const   )64U,      (u_int32_t const   )128U, 
        (u_int32_t const   )512U,      (u_int32_t const   )0U};
static int __db_get_flags(DB *dbp___1 , u_int32_t *flagsp ) 
{ u_int32_t f ;
  u_int32_t flags ;
  u_int32_t mapped_flag ;
  int i ;

  {
  flags = 0U;
  i = 0;
  while (1) {
    f = db_flags[i];
    if (! (f != 0U)) {
      break;
    }
    mapped_flag = 0U;
    __db_map_flags(dbp___1, & f, & mapped_flag);
    __bam_map_flags(dbp___1, & f, & mapped_flag);
    __ram_map_flags(dbp___1, & f, & mapped_flag);
    if ((dbp___1->flags & mapped_flag) == mapped_flag) {
      flags |= db_flags[i];
    }
    i ++;
  }
  (*flagsp) = flags;
  return (0);
}
}
int __db_set_flags(DB *dbp___1 , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;
  int tmp___1 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (flags & 8U) {
    if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
      __db_err((DB_ENV const   *)dbenv___0, "Database environment not configured for encryption");
      return (22);
    }
  }
  if (flags & 512U) {
    if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
      tmp = __db_env_config(dbenv___0, (char *)"DB_NOT_DURABLE", 131072U);
      return (tmp);
    }
  }
  __db_map_flags(dbp___1, & flags, & dbp___1->flags);
  ret = __bam_set_flags(dbp___1, & flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __ram_set_flags(dbp___1, & flags);
  if (ret != 0) {
    return (ret);
  }
  if (flags == 0U) {
    tmp___1 = 0;
  } else {
    tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DB->set_flags", 0);
  }
  return (tmp___1);
}
}
static int __db_get_lorder(DB *dbp___1 , int *db_lorderp ) 
{ int ret ;

  {
  ret = __db_byteorder(dbp___1->dbenv, 1234);
  switch (ret) {
  case 0: ;
  if (dbp___1->flags & 268435456U) {
    (*db_lorderp) = 4321;
  } else {
    (*db_lorderp) = 1234;
  }
  break;
  case -30894: ;
  if (dbp___1->flags & 268435456U) {
    (*db_lorderp) = 1234;
  } else {
    (*db_lorderp) = 4321;
  }
  break;
  default: ;
  return (ret);
  }
  return (0);
}
}
int __db_set_lorder(DB *dbp___1 , int db_lorder ) 
{ int ret ;
  int tmp ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_lorder", 1);
    return (tmp);
  }
  ret = __db_byteorder(dbp___1->dbenv, db_lorder);
  switch (ret) {
  case 0: 
  dbp___1->flags = dbp___1->flags & 4026531839U;
  break;
  case -30894: 
  dbp___1->flags = dbp___1->flags | 268435456U;
  break;
  default: ;
  return (ret);
  }
  return (0);
}
}
static int __db_set_alloc(DB *dbp___1 , void *(*mal_func)(size_t  ) , void *(*real_func)(void * ,
                                                                                         size_t  ) ,
                          void (*free_func)(void * ) ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! ((dbp___1->dbenv)->flags & 16U)) {
    tmp = __db_mi_env(dbp___1->dbenv, "DB->set_alloc");
    return (tmp);
  }
  if (dbp___1->flags & 65536U) {
    tmp___0 = __db_mi_open(dbp___1->dbenv, "DB->set_alloc", 1);
    return (tmp___0);
  }
  tmp___1 = __dbenv_set_alloc(dbp___1->dbenv, mal_func, real_func, free_func);
  return (tmp___1);
}
}
static int __db_get_pagesize(DB *dbp___1 , u_int32_t *db_pagesizep ) 
{ 

  {
  (*db_pagesizep) = dbp___1->pgsize;
  return (0);
}
}
int __db_set_pagesize(DB *dbp___1 , u_int32_t db_pagesize ) 
{ int tmp ;

  {
  if (dbp___1->flags & 65536U) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->set_pagesize", 1);
    return (tmp);
  }
  if (db_pagesize < 512U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "page sizes may not be smaller than %lu",
             512UL);
    return (22);
  }
  if (db_pagesize > 65536U) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "page sizes may not be larger than %lu",
             65536UL);
    return (22);
  }
  if (! ((db_pagesize & (db_pagesize - 1U)) == 0U)) {
    __db_err((DB_ENV const   *)dbp___1->dbenv, "page sizes must be a power-of-2");
    return (22);
  }
  dbp___1->pgsize = db_pagesize;
  return (0);
}
}
static int __db_set_paniccall(DB *dbp___1 , void (*paniccall)(DB_ENV * , int  ) ) 
{ int tmp ;

  {
  tmp = __dbenv_set_paniccall(dbp___1->dbenv, paniccall);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-mTViKzKK.i","-O2")
int __os_fsync(DB_ENV *dbenv___0 , DB_FH *fhp ) ;
int __db_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) ;
int __db_init_subdb(DB *mdbp , DB *dbp___1 , char const   *name , DB_TXN *txn ) ;
int __db_meta_setup(DB_ENV *dbenv___0 , DB *dbp___1 , char const   *name , DBMETA *meta ,
                    u_int32_t oflags , int do_metachk ) ;
int __fop_file_setup(DB *dbp___1 , DB_TXN *txn , char const   *name , int mode , u_int32_t flags ,
                     u_int32_t *retidp ) ;
int __fop_subdb_setup(DB *dbp___1 , DB_TXN *txn , char const   *mname , char const   *name ,
                      int mode , u_int32_t flags ) ;
int __txn_lockevent(DB_ENV *dbenv___0 , DB_TXN *txn , DB *dbp___1 , DB_LOCK *lock ,
                    u_int32_t locker ) ;
int __db_open(DB *dbp___1 , DB_TXN *txn , char const   *fname , char const   *dname ,
              DBTYPE type , u_int32_t flags , int mode , db_pgno_t meta_pgno ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  u_int32_t id ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  id = 0U;
  if (dbenv___0->flags & 1048576U) {
    flags |= 64U;
  }
  if (flags & 16U) {
    dbp___1->flags = dbp___1->flags | 524288U;
  }
  if (flags & 33554432U) {
    dbp___1->flags = dbp___1->flags | 128U;
  }
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    dbp___1->flags = dbp___1->flags | 536870912U;
  }
  dbp___1->type = type;
  if ((unsigned int )fname == (unsigned int )((void *)0)) {
    dbp___1->flags = dbp___1->flags | 8192U;
    if ((int )dbp___1->type == 5) {
      __db_err((DB_ENV const   *)dbenv___0, "DBTYPE of unknown without existing file");
      return (22);
    }
    if (dbp___1->pgsize == 0U) {
      dbp___1->pgsize = 8192U;
    }
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      ret = __lock_id(dbenv___0, (u_int32_t *)(dbp___1->fileid));
      if (ret != 0) {
        return (ret);
      }
    }
  } else {
    if ((unsigned int )dname == (unsigned int )((void *)0)) {
      if (meta_pgno == 0U) {
        ret = __fop_file_setup(dbp___1, txn, fname, mode, flags, & id);
        if (ret != 0) {
          return (ret);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      ret = __fop_subdb_setup(dbp___1, txn, fname, dname, mode, flags);
      if (ret != 0) {
        return (ret);
      }
      meta_pgno = dbp___1->meta_pgno;
    }
  }
  if ((unsigned int )dname == (unsigned int )((void *)0)) {
    if (dbp___1->flags & 8U) {
      flags |= 128U;
    }
  }
  ret = __db_dbenv_setup(dbp___1, txn, fname, id, flags);
  if (ret != 0) {
    return (ret);
  }
  dbp___1->flags = dbp___1->flags | 65536U;
  if ((unsigned int )fname == (unsigned int )((void *)0)) {
    ret = __db_new_file(dbp___1, txn, (DB_FH *)((void *)0), (char const   *)((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  switch ((int )dbp___1->type) {
  case 1: 
  ret = __bam_open(dbp___1, txn, fname, meta_pgno, flags);
  break;
  case 2: 
  ret = __ham_open(dbp___1, txn, fname, meta_pgno, flags);
  break;
  case 3: 
  ret = __ram_open(dbp___1, txn, fname, meta_pgno, flags);
  break;
  case 4: 
  ret = __qam_open(dbp___1, txn, fname, meta_pgno, mode, flags);
  break;
  case 5: 
  tmp = __db_unknown_type(dbenv___0, (char *)"__db_dbopen", dbp___1->type);
  return (tmp);
  }
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 2097152U)) {
    if ((unsigned int )fname != (unsigned int )((void *)0)) {
      if (dbp___1->handle_lock.off != 0U) {
        if ((unsigned int )txn != (unsigned int )((void *)0)) {
          ret = __txn_lockevent(dbenv___0, txn, dbp___1, & dbp___1->handle_lock, dbp___1->lid);
        } else {
          if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
            ret = __lock_downgrade(dbenv___0, & dbp___1->handle_lock, (enum __anonenum_db_lockmode_t_50 )1,
                                   0U);
          }
        }
      }
    }
  }
  err: 
  return (ret);
}
}
int __db_get_open_flags(DB *dbp___1 , u_int32_t *flagsp ) 
{ int tmp ;

  {
  if (! (dbp___1->flags & 65536U)) {
    tmp = __db_mi_open(dbp___1->dbenv, "DB->get_open_flags", 0);
    return (tmp);
  }
  (*flagsp) = dbp___1->open_flags;
  return (0);
}
}
int __db_new_file(DB *dbp___1 , DB_TXN *txn , DB_FH *fhp , char const   *name ) 
{ int ret ;

  {
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: 
  ret = __bam_new_file(dbp___1, txn, fhp, name);
  break;
  case 2: 
  ret = __ham_new_file(dbp___1, txn, fhp, name);
  break;
  case 4: 
  ret = __qam_new_file(dbp___1, txn, fhp, name);
  break;
  case 5: ;
  default: 
  __db_err((DB_ENV const   *)dbp___1->dbenv, "%s: Invalid type %d specified", name,
           dbp___1->type);
  ret = 22;
  break;
  }
  if (ret == 0) {
    if ((unsigned int )fhp != (unsigned int )((void *)0)) {
      ret = __os_fsync(dbp___1->dbenv, fhp);
    }
  }
  return (ret);
}
}
int __db_init_subdb(DB *mdbp , DB *dbp___1 , char const   *name , DB_TXN *txn ) 
{ DBMETA *meta ;
  DB_MPOOLFILE *mpf ;
  int ret ;
  int t_ret ;

  {
  ret = 0;
  if (! (dbp___1->flags & 8U)) {
    mpf = mdbp->mpf;
    ret = __memp_fget(mpf, & dbp___1->meta_pgno, 0U, (void *)(& meta));
    if (ret != 0) {
      goto err;
    }
    ret = __db_meta_setup(mdbp->dbenv, dbp___1, name, meta, 0U, 0);
    t_ret = __memp_fput(mpf, (void *)meta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret == 2) {
      ret = 0;
    }
    goto err;
  }
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: 
  ret = __bam_new_subdb(mdbp, dbp___1, txn);
  break;
  case 2: 
  ret = __ham_new_subdb(mdbp, dbp___1, txn);
  break;
  case 4: 
  ret = 22;
  break;
  case 5: ;
  default: 
  __db_err((DB_ENV const   *)dbp___1->dbenv, "Invalid subdatabase type %d specified",
           dbp___1->type);
  return (22);
  }
  err: 
  return (ret);
}
}
int __db_chk_meta(DB_ENV *dbenv___0 , DB *dbp___1 , DBMETA *meta , int do_metachk ) 
{ int is_hmac ;
  int ret ;
  int swapped ;
  u_int8_t *chksum ;
  u_int32_t orig_chk ;
  u_int32_t _tmp ;

  {
  ret = 0;
  if ((int )meta->metaflags & 1) {
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      dbp___1->flags = dbp___1->flags | 1U;
    }
    if ((int )meta->encrypt_alg == 0) {
      is_hmac = 0;
    } else {
      is_hmac = 1;
    }
    chksum = ((BTMETA *)meta)->chksum;
    if (do_metachk) {
      if (is_hmac == 0) {
        orig_chk = (*((u_int32_t *)chksum));
      }
      swapped = 0;
      chk_retry: 
      ret = __db_check_chksum(dbenv___0, (DB_CIPHER *)dbenv___0->crypto_handle, chksum,
                              (void *)meta, 512U, is_hmac);
      if (ret != 0) {
        if (is_hmac) {
          return (ret);
        } else {
          if (swapped) {
            return (ret);
          }
        }
        _tmp = orig_chk;
        (*((u_int8_t *)(& orig_chk) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
        (*((u_int8_t *)(& orig_chk) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
        (*((u_int8_t *)(& orig_chk) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
        (*((u_int8_t *)(& orig_chk) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
        swapped = 1;
        (*((u_int32_t *)chksum)) = orig_chk;
        goto chk_retry;
      }
    }
  } else {
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      dbp___1->flags = dbp___1->flags & 4294967294U;
    }
  }
  ret = __crypto_decrypt_meta(dbenv___0, dbp___1, (u_int8_t *)meta, do_metachk);
  return (ret);
}
}
int __db_meta_setup(DB_ENV *dbenv___0 , DB *dbp___1 , char const   *name , DBMETA *meta ,
                    u_int32_t oflags , int do_metachk ) 
{ u_int32_t flags ;
  u_int32_t magic ;
  int ret ;
  u_int32_t _tmp ;
  u_int32_t _tmp___0 ;
  int tmp ;

  {
  ret = 0;
  dbp___1->flags = dbp___1->flags & 4026531839U;
  magic = meta->magic;
  swap_retry: 
  switch ((int )magic) {
  case 340322: ;
  case 398689: ;
  case 270931: ;
  case 198656: ;
  break;
  case 0: ;
  if (dbp___1->flags & 134217728U) {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
        if (((DB_LOG *)dbenv___0->lg_handle)->flags & 2U) {
          return (2);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (meta->pgno != 0U) {
        return (2);
      }
    }
  }
  goto bad_format;
  default: ;
  if (dbp___1->flags & 268435456U) {
    goto bad_format;
  }
  _tmp = magic;
  (*((u_int8_t *)(& magic) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*((u_int8_t *)(& magic) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*((u_int8_t *)(& magic) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*((u_int8_t *)(& magic) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  dbp___1->flags = dbp___1->flags | 268435456U;
  goto swap_retry;
  }
  ret = __db_chk_meta(dbenv___0, dbp___1, meta, do_metachk);
  if (ret != 0) {
    if (ret == -1) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: metadata page checksum error", name);
    }
    goto bad_format;
  }
  switch ((int )magic) {
  case 340322: ;
  if ((int )dbp___1->type != 5) {
    if ((int )dbp___1->type != 3) {
      if ((int )dbp___1->type != 1) {
        goto bad_format;
      }
    }
  }
  flags = meta->flags;
  if (dbp___1->flags & 268435456U) {
    _tmp___0 = flags;
    (*((u_int8_t *)(& flags) + 0)) = (*((u_int8_t *)(& _tmp___0) + 3));
    (*((u_int8_t *)(& flags) + 1)) = (*((u_int8_t *)(& _tmp___0) + 2));
    (*((u_int8_t *)(& flags) + 2)) = (*((u_int8_t *)(& _tmp___0) + 1));
    (*((u_int8_t *)(& flags) + 3)) = (*((u_int8_t *)(& _tmp___0) + 0));
  }
  if (flags & 2U) {
    dbp___1->type = (enum __anonenum_DBTYPE_61 )3;
  } else {
    dbp___1->type = (enum __anonenum_DBTYPE_61 )1;
  }
  if ((oflags & 128U) == 0U) {
    ret = __bam_metachk(dbp___1, name, (BTMETA *)meta);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  case 398689: ;
  if ((int )dbp___1->type != 5) {
    if ((int )dbp___1->type != 2) {
      goto bad_format;
    }
  }
  dbp___1->type = (enum __anonenum_DBTYPE_61 )2;
  if ((oflags & 128U) == 0U) {
    ret = __ham_metachk(dbp___1, name, (HMETA *)meta);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  case 270931: ;
  if ((int )dbp___1->type != 5) {
    if ((int )dbp___1->type != 4) {
      goto bad_format;
    }
  }
  dbp___1->type = (enum __anonenum_DBTYPE_61 )4;
  if ((oflags & 128U) == 0U) {
    ret = __qam_metachk(dbp___1, name, (QMETA *)meta);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  case 198656: 
  dbp___1->flags = dbp___1->flags | 16384U;
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(meta->uid),
         20U);
  break;
  default: ;
  goto bad_format;
  }
  return (0);
  bad_format: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unexpected file type or format", name);
  if (ret == 0) {
    tmp = 22;
  } else {
    tmp = ret;
  }
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-rHijEAec.i","-O2")
int __os_urealloc(DB_ENV *dbenv___0 , size_t size , void *storep ) ;
int __db_goff(DB *dbp___1 , DBT *dbt , u_int32_t tlen , db_pgno_t pgno , void **bpp ,
              u_int32_t *bpsz ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_indx_t bytes ;
  u_int32_t curoff ;
  u_int32_t needed ;
  u_int32_t start ;
  u_int8_t *p ;
  u_int8_t *src ;
  int ret ;
  unsigned int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  mpf = dbp___1->mpf;
  if (dbt->flags & 8U) {
    start = dbt->doff;
    if (start > tlen) {
      needed = 0U;
    } else {
      if (dbt->dlen > tlen - start) {
        needed = tlen - start;
      } else {
        needed = dbt->dlen;
      }
    }
  } else {
    start = 0U;
    needed = tlen;
  }
  if (dbt->flags & 32U) {
    if (needed > dbt->ulen) {
      dbt->size = needed;
      return (12);
    }
  } else {
    if (dbt->flags & 4U) {
      ret = __os_umalloc(dbenv___0, needed, (void *)(& dbt->data));
      if (ret != 0) {
        return (ret);
      }
    } else {
      if (dbt->flags & 16U) {
        ret = __os_urealloc(dbenv___0, needed, (void *)(& dbt->data));
        if (ret != 0) {
          return (ret);
        }
      } else {
        if ((*bpsz) == 0U) {
          goto _L;
        } else {
          if ((*bpsz) < needed) {
            _L: 
            ret = __os_realloc(dbenv___0, needed, (void *)bpp);
            if (ret != 0) {
              return (ret);
            }
            (*bpsz) = needed;
            dbt->data = (*bpp);
          } else {
            dbt->data = (*bpp);
          }
        }
      }
    }
  }
  dbt->size = needed;
  curoff = 0U;
  p = (u_int8_t *)dbt->data;
  while (1) {
    if (pgno != 0U) {
      if (! (needed > 0U)) {
        break;
      }
    } else {
      break;
    }
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
    if (ret != 0) {
      return (ret);
    }
    if (curoff + (unsigned int )h->hf_offset >= start) {
      if (dbp___1->flags & 2048U) {
        tmp___0 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___0 = sizeof(PG_CHKSUM );
        } else {
          tmp___0 = 0U;
        }
      }
      src = (u_int8_t *)h + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                    26) +
                                                                                   tmp___0))));
      bytes = h->hf_offset;
      if (start > curoff) {
        src += start - curoff;
        bytes = (unsigned short )((unsigned int )bytes - (start - curoff));
      }
      if ((unsigned int )bytes > needed) {
        bytes = (unsigned short )needed;
      }
      memcpy((void * __restrict  )p, (void const   * __restrict  )src, (unsigned int )bytes);
      p += (int )bytes;
      needed -= (unsigned int )bytes;
    }
    curoff += (unsigned int )h->hf_offset;
    pgno = h->next_pgno;
    __memp_fput(mpf, (void *)h, 0U);
  }
  return (0);
}
}
int __db_poff(DBC *dbc , DBT const   *dbt , db_pgno_t *pgnop ) 
{ DB *dbp___1 ;
  DBT tmp_dbt ;
  DB_LSN new_lsn ;
  DB_LSN null_lsn ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  PAGE *lastp ;
  db_indx_t pagespace ;
  u_int32_t sz ;
  u_int8_t *p ;
  int ret ;
  int t_ret ;
  unsigned int tmp___0 ;
  DB_LSN *tmp___1 ;
  db_pgno_t tmp___2 ;
  unsigned int tmp___4 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  pagespace = (unsigned short )(dbp___1->pgsize - (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                   26) +
                                                                                                                  tmp___0)))));
  ret = 0;
  lastp = (PAGE *)((void *)0);
  p = (u_int8_t *)dbt->data;
  sz = dbt->size;
  while (sz > 0U) {
    if (sz < (unsigned int )pagespace) {
      pagespace = (unsigned short )sz;
    }
    ret = __db_new(dbc, 7U, & pagep);
    if (ret != 0) {
      break;
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___3;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            tmp_dbt.data = (void *)p;
            tmp_dbt.size = (unsigned int )pagespace;
            while (1) {
              null_lsn.file = 0U;
              null_lsn.offset = 0U;
              break;
            }
            if ((unsigned int )lastp == (unsigned int )((void *)0)) {
              tmp___1 = & null_lsn;
            } else {
              tmp___1 = & lastp->lsn;
            }
            if (lastp) {
              tmp___2 = lastp->pgno;
            } else {
              tmp___2 = 0U;
            }
            ret = __db_big_log(dbp___1, dbc->txn, & new_lsn, 0U, 3U, pagep->pgno,
                               tmp___2, 0U, (DBT const   *)(& tmp_dbt), & pagep->lsn,
                               tmp___1, & null_lsn);
            if (ret != 0) {
              if ((unsigned int )lastp != (unsigned int )((void *)0)) {
                __memp_fput(mpf, (void *)lastp, 2U);
              }
              lastp = pagep;
              break;
            }
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      while (1) {
        new_lsn.file = 0U;
        new_lsn.offset = 1U;
        break;
      }
    }
    if ((unsigned int )lastp != (unsigned int )((void *)0)) {
      lastp->lsn = new_lsn;
    }
    pagep->lsn = new_lsn;
    while (1) {
      pagep->pgno = pagep->pgno;
      pagep->prev_pgno = 0U;
      pagep->next_pgno = 0U;
      pagep->entries = (unsigned short)0;
      pagep->hf_offset = (unsigned short )dbp___1->pgsize;
      pagep->level = (unsigned char)0;
      pagep->type = (unsigned char)7;
      break;
    }
    pagep->hf_offset = pagespace;
    pagep->entries = (unsigned short)1;
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    memcpy((void * __restrict  )((u_int8_t *)pagep + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                             26) +
                                                                                                            tmp___4))))),
           (void const   * __restrict  )p, (unsigned int )pagespace);
    if ((unsigned int )lastp == (unsigned int )((void *)0)) {
      (*pgnop) = pagep->pgno;
    } else {
      lastp->next_pgno = pagep->pgno;
      pagep->prev_pgno = lastp->pgno;
      __memp_fput(mpf, (void *)lastp, 2U);
    }
    lastp = pagep;
    p += (int )pagespace;
    sz -= (unsigned int )pagespace;
  }
  if ((unsigned int )lastp != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mpf, (void *)lastp, 2U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_ovref(DBC *dbc , db_pgno_t pgno , int32_t adjust ) 
{ DB *dbp___1 ;
  DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    tmp = __db_pgerr(dbp___1, pgno, ret);
    return (tmp);
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! (dbc->flags & 16U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __db_ovref_log(dbp___1, dbc->txn, & h->lsn, 0U, h->pgno, adjust, & h->lsn);
          if (ret != 0) {
            __memp_fput(mpf, (void *)h, 0U);
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      h->lsn.file = 0U;
      h->lsn.offset = 1U;
      break;
    }
  }
  h->entries = (unsigned short )((int )h->entries + adjust);
  __memp_fput(mpf, (void *)h, 2U);
  return (0);
}
}
int __db_doff(DBC *dbc , db_pgno_t pgno ) 
{ DB *dbp___1 ;
  PAGE *pagep ;
  DB_LSN null_lsn ;
  DB_MPOOLFILE *mpf ;
  DBT tmp_dbt ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___2 ;

  {
  dbp___1 = dbc->dbp;
  mpf = dbp___1->mpf;
  while (1) {
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pagep));
    if (ret != 0) {
      tmp = __db_pgerr(dbp___1, pgno, ret);
      return (tmp);
    }
    if ((int )pagep->entries > 1) {
      __memp_fput(mpf, (void *)pagep, 0U);
      tmp___0 = __db_ovref(dbc, pgno, -1);
      return (tmp___0);
    }
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! (dbc->flags & 16U)) {
          if ((unsigned int )((dbc->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)((dbc->dbp)->dbenv)->rep_handle)->region)->flags & 516U) {
                goto _L___3;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
            if (dbp___1->flags & 2048U) {
              tmp___2 = sizeof(PG_CRYPTO );
            } else {
              if (dbp___1->flags & 1U) {
                tmp___2 = sizeof(PG_CHKSUM );
              } else {
                tmp___2 = 0U;
              }
            }
            tmp_dbt.data = (void *)((u_int8_t *)pagep + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                26) +
                                                                                                               tmp___2)))));
            tmp_dbt.size = (unsigned int )pagep->hf_offset;
            while (1) {
              null_lsn.file = 0U;
              null_lsn.offset = 0U;
              break;
            }
            ret = __db_big_log(dbp___1, dbc->txn, & pagep->lsn, 0U, 4U, pagep->pgno,
                               pagep->prev_pgno, pagep->next_pgno, (DBT const   *)(& tmp_dbt),
                               & pagep->lsn, & null_lsn, & null_lsn);
            if (ret != 0) {
              __memp_fput(mpf, (void *)pagep, 0U);
              return (ret);
            }
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: 
      while (1) {
        pagep->lsn.file = 0U;
        pagep->lsn.offset = 1U;
        break;
      }
    }
    pgno = pagep->next_pgno;
    pagep->hf_offset = (unsigned short)0;
    ret = __db_free(dbc, pagep);
    if (ret != 0) {
      return (ret);
    }
    if (! (pgno != 0U)) {
      break;
    }
  }
  return (0);
}
}
int __db_moff(DB *dbp___1 , DBT const   *dbt , db_pgno_t pgno , u_int32_t tlen , int (*cmpfunc)(DB * ,
                                                                                                DBT const   * ,
                                                                                                DBT const   * ) ,
              int *cmpp ) 
{ DBT local_dbt ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  void *buf ;
  u_int32_t bufsize ;
  u_int32_t cmp_bytes ;
  u_int32_t key_left ;
  u_int8_t *p1 ;
  u_int8_t *p2 ;
  int ret ;
  unsigned int tmp___0 ;
  u_int32_t tmp___1 ;

  {
  mpf = dbp___1->mpf;
  if ((unsigned int )cmpfunc != (unsigned int )((void *)0)) {
    memset((void *)(& local_dbt), 0, sizeof(local_dbt));
    buf = (void *)0;
    bufsize = 0U;
    ret = __db_goff(dbp___1, & local_dbt, tlen, pgno, & buf, & bufsize);
    if (ret != 0) {
      return (ret);
    }
    (*cmpp) = ((*cmpfunc))(dbp___1, dbt, (DBT const   *)(& local_dbt));
    __os_free(dbp___1->dbenv, buf);
    return (0);
  }
  (*cmpp) = 0;
  p1 = (u_int8_t *)dbt->data;
  key_left = dbt->size;
  while (1) {
    if (key_left > 0U) {
      if (! (pgno != 0U)) {
        break;
      }
    } else {
      break;
    }
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& pagep));
    if (ret != 0) {
      return (ret);
    }
    if ((unsigned int )pagep->hf_offset < key_left) {
      cmp_bytes = (unsigned int )pagep->hf_offset;
    } else {
      cmp_bytes = key_left;
    }
    tlen -= cmp_bytes;
    key_left -= cmp_bytes;
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    p2 = (u_int8_t *)pagep + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                     26) +
                                                                                    tmp___0))));
    while (1) {
      tmp___1 = cmp_bytes;
      cmp_bytes --;
      if (! (tmp___1 > 0U)) {
        break;
      }
      if ((int )(*p1) != (int )(*p2)) {
        (*cmpp) = (int )((long )(*p1) - (long )(*p2));
        break;
      }
      p1 ++;
      p2 ++;
    }
    pgno = pagep->next_pgno;
    ret = __memp_fput(mpf, (void *)pagep, 0U);
    if (ret != 0) {
      return (ret);
    }
    if ((*cmpp) != 0) {
      return (0);
    }
  }
  if (key_left > 0U) {
    (*cmpp) = 1;
  } else {
    if (tlen > 0U) {
      (*cmpp) = -1;
    } else {
      (*cmpp) = 0;
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-BaQg87ZW.i","-O2")
void __db_loadme(void) ;
int __db_dump(DB *dbp___1 , char *op , char *name ) ;
void __db_inmemdbflags(u_int32_t flags , void *cookie , void (*callback)(u_int32_t  ,
                                                                         FN const   * ,
                                                                         void * ) ) ;
int __db_prnpage(DB *dbp___1 , db_pgno_t pgno , FILE *fp ) ;
void __db_pr(u_int8_t *p , u_int32_t len , FILE *fp ) ;
void __db_prflags(u_int32_t flags , FN const   *fn___2 , void *vfp ) ;
char const   *__db_dbtype_to_string(DBTYPE type ) ;
static int __db_bmeta(DB *dbp___1 , FILE *fp , BTMETA *h , u_int32_t flags ) ;
static int __db_hmeta(DB *dbp___1 , FILE *fp , HMETA *h , u_int32_t flags ) ;
static void __db_meta(DB *dbp___1 , DBMETA *dbmeta , FILE *fp , FN const   *fn___2 ,
                      u_int32_t flags ) ;
static char const   *__db_pagetype_to_string(u_int32_t type ) ;
static void __db_prdb(DB *dbp___1 , FILE *fp ) ;
static void __db_proff(void *vp , FILE *fp ) ;
static int __db_prtree(DB *dbp___1 , FILE *fp , u_int32_t flags ) ;
static int __db_qmeta(DB *dbp___1 , FILE *fp , QMETA *h , u_int32_t flags ) ;
void __db_loadme(void) 
{ u_int32_t id ;

  {
  __os_id(& id);
  return;
}
}
int __db_dump(DB *dbp___1 , char *op , char *name ) 
{ FILE *fp ;
  u_int32_t flags ;
  int ret ;
  int tmp ;

  {
  flags = 0U;
  while ((int )(*op) != 0) {
    switch ((int )(*op)) {
    case 97: 
    flags |= 8U;
    break;
    case 104: ;
    break;
    case 114: 
    flags |= 16U;
    break;
    default: ;
    return (22);
    }
    op ++;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    fp = stdout;
  } else {
    fp = fopen((char const   * __restrict  )name, (char const   * __restrict  )"w");
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
      tmp = __os_get_errno();
      return (tmp);
    }
  }
  __db_prdb(dbp___1, fp);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\n", "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
  ret = __db_prtree(dbp___1, fp, flags);
  fflush(fp);
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    fclose(fp);
  }
  return (ret);
}
}
static FN const   fn[30]  = 
  {      {1U, "checksumming"}, 
        {2U, "client replica writer"}, 
        {4U, "created by compensating transaction"}, 
        {8U, "database created"}, 
        {16U, "encompassing file created"}, 
        {32U, "dbm/ndbm error"}, 
        {64U, "variable length"}, 
        {128U, "dirty reads"}, 
        {256U, "discard cached pages"}, 
        {512U, "duplicates"}, 
        {1024U, "sorted duplicates"}, 
        {2048U, "encrypted"}, 
        {4096U, "fixed-length records"}, 
        {8192U, "in-memory"}, 
        {16384U, "file is being renamed"}, 
        {65536U, "DB->open called"}, 
        {131072U, "pad value"}, 
        {262144U, "default page size"}, 
        {524288U, "read-only"}, 
        {1048576U, "Btree record numbers"}, 
        {2097152U, "opened for recovery"}, 
        {4194304U, "renumber"}, 
        {16777216U, "no reverse splits"}, 
        {33554432U, "secondary"}, 
        {67108864U, "load on open"}, 
        {134217728U, "subdatabases"}, 
        {268435456U, "needswap"}, 
        {536870912U, "transactional"}, 
        {1073741824U, "verifier"}, 
        {0U, (char const   *)((void *)0)}};
void __db_inmemdbflags(u_int32_t flags , void *cookie , void (*callback)(u_int32_t  ,
                                                                         FN const   * ,
                                                                         void * ) ) 
{ 

  {
  ((*callback))(flags, fn, cookie);
  return;
}
}
static void __db_prdb(DB *dbp___1 , FILE *fp ) 
{ BTREE *bt ;
  HASH *h ;
  QUEUE *q ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  tmp = __db_dbtype_to_string(dbp___1->type);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"In-memory DB structure:\n%s: %#lx",
          tmp, (unsigned long )dbp___1->flags);
  __db_inmemdbflags(dbp___1->flags, (void *)fp, & __db_prflags);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: 
  bt = (BTREE *)dbp___1->bt_internal;
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"bt_meta: %lu bt_root: %lu\n",
          (unsigned long )bt->bt_meta, (unsigned long )bt->bt_root);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"bt_maxkey: %lu bt_minkey: %lu\n",
          (unsigned long )bt->bt_maxkey, (unsigned long )bt->bt_minkey);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"bt_compare: %#lx bt_prefix: %#lx\n",
          (unsigned long )((unsigned int )bt->bt_compare), (unsigned long )((unsigned int )bt->bt_prefix));
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"bt_lpgno: %lu\n",
          (unsigned long )bt->bt_lpgno);
  if ((int )dbp___1->type == 3) {
    if ((unsigned int )bt->re_source == (unsigned int )((void *)0)) {
      tmp___0 = "";
    } else {
      tmp___0 = (char const   *)bt->re_source;
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"re_pad: %#lx re_delim: %#lx re_len: %lu re_source: %s\n",
            (unsigned long )bt->re_pad, (unsigned long )bt->re_delim, (unsigned long )bt->re_len,
            tmp___0);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"re_modified: %d re_eof: %d re_last: %lu\n",
            bt->re_modified, bt->re_eof, (unsigned long )bt->re_last);
  }
  break;
  case 2: 
  h = (HASH *)dbp___1->h_internal;
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"meta_pgno: %lu\n",
          (unsigned long )h->meta_pgno);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"h_ffactor: %lu\n",
          (unsigned long )h->h_ffactor);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"h_nelem: %lu\n",
          (unsigned long )h->h_nelem);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"h_hash: %#lx\n",
          (unsigned long )((unsigned int )h->h_hash));
  break;
  case 4: 
  q = (QUEUE *)dbp___1->q_internal;
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"q_meta: %lu\n", (unsigned long )q->q_meta);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"q_root: %lu\n", (unsigned long )q->q_root);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"re_pad: %#lx re_len: %lu\n",
          (unsigned long )q->re_pad, (unsigned long )q->re_len);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"rec_page: %lu\n",
          (unsigned long )q->rec_page);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"page_ext: %lu\n",
          (unsigned long )q->page_ext);
  break;
  case 5: ;
  default: ;
  break;
  }
}
}
static int __db_prtree(DB *dbp___1 , FILE *fp , u_int32_t flags ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t i ;
  db_pgno_t last ;
  int ret ;
  int tmp ;

  {
  mpf = dbp___1->mpf;
  if ((int )dbp___1->type == 4) {
    tmp = __db_prqueue(dbp___1, fp, flags);
    return (tmp);
  }
  __memp_last_pgno(mpf, & last);
  i = 0U;
  while (i <= last) {
    ret = __memp_fget(mpf, & i, 0U, (void *)(& h));
    if (ret != 0) {
      return (ret);
    }
    __db_prpage(dbp___1, h, fp, flags);
    ret = __memp_fput(mpf, (void *)h, 0U);
    if (ret != 0) {
      return (ret);
    }
    i ++;
  }
  return (0);
}
}
static void __db_meta(DB *dbp___1 , DBMETA *dbmeta , FILE *fp , FN const   *fn___2 ,
                      u_int32_t flags ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  db_pgno_t pgno ;
  u_int8_t *p ;
  int cnt ;
  int ret ;
  char const   *sep ;
  char *tmp ;
  u_int8_t *tmp___0 ;

  {
  mpf = dbp___1->mpf;
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tmagic: %#lx\n",
          (unsigned long )dbmeta->magic);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tversion: %lu\n",
          (unsigned long )dbmeta->version);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tpagesize: %lu\n",
          (unsigned long )dbmeta->pagesize);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\ttype: %lu\n", (unsigned long )dbmeta->type);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tkeys: %lu\trecords: %lu\n",
          (unsigned long )dbmeta->key_count, (unsigned long )dbmeta->record_count);
  if (! (flags & 16U)) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tfree list: %lu",
            (unsigned long )dbmeta->free);
    pgno = dbmeta->free;
    cnt = 0;
    sep = ", ";
    while (pgno != 0U) {
      ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
      if (ret != 0) {
        tmp = db_strerror(ret);
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Unable to retrieve free-list page: %lu: %s\n",
                (unsigned long )pgno, tmp);
        break;
      }
      pgno = h->next_pgno;
      __memp_fput(mpf, (void *)h, 0U);
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s%lu", sep,
              (unsigned long )pgno);
      cnt ++;
      if (cnt % 10 == 0) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
        cnt = 0;
        sep = "\t";
      } else {
        sep = ", ";
      }
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tlast_pgno: %lu\n",
            (unsigned long )dbmeta->last_pgno);
  }
  if ((unsigned int )fn___2 != (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tflags: %#lx",
            (unsigned long )dbmeta->flags);
    __db_prflags(dbmeta->flags, fn___2, (void *)fp);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tuid: ");
  p = dbmeta->uid;
  cnt = 0;
  while (cnt < 20) {
    tmp___0 = p;
    p ++;
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%x", (*tmp___0));
    if (cnt < 19) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" ");
    }
    cnt ++;
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  return;
}
}
static FN const   mfn[7]  = {      {1U, "duplicates"}, 
        {2U, "recno"}, 
        {4U, "btree:recnum"}, 
        {8U, "recno:fixed-length"}, 
        {16U, "recno:renumber"}, 
        {32U, "multiple-databases"}, 
        {0U, (char const   *)((void *)0)}};
static int __db_bmeta(DB *dbp___1 , FILE *fp , BTMETA *h , u_int32_t flags ) 
{ 

  {
  __db_meta(dbp___1, (DBMETA *)h, fp, mfn, flags);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tmaxkey: %lu minkey: %lu\n",
          (unsigned long )h->maxkey, (unsigned long )h->minkey);
  if ((int )dbp___1->type == 3) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tre_len: %#lx re_pad: %lu\n",
            (unsigned long )h->re_len, (unsigned long )h->re_pad);
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\troot: %lu\n", (unsigned long )h->root);
  return (0);
}
}
static FN const   mfn___0[3]  = {      {1U, "duplicates"}, 
        {2U, "multiple-databases"}, 
        {0U, (char const   *)((void *)0)}};
static int __db_hmeta(DB *dbp___1 , FILE *fp , HMETA *h , u_int32_t flags ) 
{ int i ;

  {
  __db_meta(dbp___1, (DBMETA *)h, fp, mfn___0, flags);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tmax_bucket: %lu\n",
          (unsigned long )h->max_bucket);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\thigh_mask: %#lx\n",
          (unsigned long )h->high_mask);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tlow_mask:  %#lx\n",
          (unsigned long )h->low_mask);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tffactor: %lu\n",
          (unsigned long )h->ffactor);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tnelem: %lu\n",
          (unsigned long )h->nelem);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\th_charkey: %#lx\n",
          (unsigned long )h->h_charkey);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tspare points: ");
  i = 0;
  while (i < 32) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%lu ", (unsigned long )h->spares[i]);
    i ++;
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  return (0);
}
}
static int __db_qmeta(DB *dbp___1 , FILE *fp , QMETA *h , u_int32_t flags ) 
{ 

  {
  __db_meta(dbp___1, (DBMETA *)h, fp, (FN const   *)((void *)0), flags);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tfirst_recno: %lu\n",
          (unsigned long )h->first_recno);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tcur_recno: %lu\n",
          (unsigned long )h->cur_recno);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tre_len: %#lx re_pad: %lu\n",
          (unsigned long )h->re_len, (unsigned long )h->re_pad);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\trec_page: %lu\n",
          (unsigned long )h->rec_page);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tpage_ext: %lu\n",
          (unsigned long )h->page_ext);
  return (0);
}
}
int __db_prnpage(DB *dbp___1 , db_pgno_t pgno , FILE *fp ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *h ;
  int ret ;
  int t_ret ;

  {
  mpf = dbp___1->mpf;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& h));
  if (ret != 0) {
    return (ret);
  }
  ret = __db_prpage(dbp___1, h, fp, 8U);
  t_ret = __memp_fput(mpf, (void *)h, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_prpage(DB *dbp___1 , PAGE *h , FILE *fp , u_int32_t flags ) 
{ BINTERNAL *bi ;
  BKEYDATA *bk ;
  HOFFPAGE a_hkd ;
  QAMDATA *qp ;
  QAMDATA *qep ;
  RINTERNAL *ri ;
  db_indx_t dlen ;
  db_indx_t len ;
  db_indx_t i ;
  db_indx_t *inp ;
  db_pgno_t pgno ;
  db_recno_t recno ;
  u_int32_t pagesize ;
  u_int32_t qlen ;
  u_int8_t *ep ;
  u_int8_t *hk ;
  u_int8_t *p ;
  int deleted ;
  int ret ;
  char const   *s ;
  void *sp ;
  db_pgno_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;
  unsigned int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___21 ;
  unsigned int tmp___23 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___28 ;
  unsigned int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___34 ;
  unsigned int tmp___36 ;
  unsigned int tmp___38 ;
  u_int32_t tmp___42 ;
  unsigned int tmp___44 ;
  unsigned int tmp___46 ;

  {
  if (flags & 16U) {
    if ((int )h->type == 0) {
      return (0);
    }
  }
  s = __db_pagetype_to_string((unsigned int )h->type);
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL PAGE TYPE: page: %lu type: %lu\n",
            (unsigned long )h->pgno, (unsigned long )h->type);
    return (1);
  }
  pagesize = ((dbp___1->mpf)->mfp)->stat.st_pagesize;
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"page %lu: %s level: %lu",
          (unsigned long )h->pgno, s, (unsigned long )h->level);
  if ((int )h->type == 3) {
    goto _L;
  } else {
    if ((int )h->type == 4) {
      goto _L;
    } else {
      if ((int )h->type == 6) {
        if (h->pgno == ((BTREE *)dbp___1->bt_internal)->bt_root) {
          _L: 
          if ((int )h->type == 3) {
            tmp___0 = h->prev_pgno;
          } else {
            if ((int )h->type == 4) {
              tmp___0 = h->prev_pgno;
            } else {
              if ((int )h->type == 5) {
                tmp___1 = (int )h->entries / 2;
              } else {
                tmp___1 = (int )h->entries;
              }
              tmp___0 = (unsigned int )tmp___1;
            }
          }
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" records: %lu",
                  (unsigned long )tmp___0);
        }
      }
    }
  }
  if (! (flags & 16U)) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" (lsn.file: %lu lsn.offset: %lu)\n",
            (unsigned long )h->lsn.file, (unsigned long )h->lsn.offset);
  }
  switch ((int )h->type) {
  case 9: 
  tmp___2 = __db_bmeta(dbp___1, fp, (BTMETA *)h, flags);
  return (tmp___2);
  case 8: 
  tmp___3 = __db_hmeta(dbp___1, fp, (HMETA *)h, flags);
  return (tmp___3);
  case 10: 
  tmp___4 = __db_qmeta(dbp___1, fp, (QMETA *)h, flags);
  return (tmp___4);
  case 11: ;
  if (! (flags & 8U)) {
    return (0);
  }
  qlen = ((QUEUE *)dbp___1->q_internal)->re_len;
  recno = (h->pgno - 1U) * ((QUEUE *)dbp___1->q_internal)->rec_page + 1U;
  i = (unsigned short)0;
  qep = (QAMDATA *)(((u_int8_t *)h + pagesize) - qlen);
  if (dbp___1->flags & 2048U) {
    tmp___6 = 64;
  } else {
    if (dbp___1->flags & 1U) {
      tmp___6 = 48;
    } else {
      tmp___6 = 28;
    }
  }
  qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___6 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                       (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                      (unsigned long long )sizeof(u_int32_t )) -
                                                                     1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                1ULL)) *
                                                                   (unsigned long long )i));
  while ((unsigned int )qp < (unsigned int )qep) {
    if (! ((int )qp->flags & 2)) {
      goto __Cont;
    }
    if ((int )qp->flags & 1) {
      tmp___9 = "\t";
    } else {
      tmp___9 = "       D";
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", tmp___9);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"[%03lu] %4lu ",
            (unsigned long )recno, (unsigned long )((u_int8_t *)qp - (u_int8_t *)h));
    __db_pr(qp->data, qlen, fp);
    __Cont: 
    recno ++;
    i = (unsigned short )((int )i + 1);
    if (dbp___1->flags & 2048U) {
      tmp___8 = 64;
    } else {
      if (dbp___1->flags & 1U) {
        tmp___8 = 48;
      } else {
        tmp___8 = 28;
      }
    }
    qp = (QAMDATA *)((u_int8_t *)h + ((unsigned long long )tmp___8 + (((((unsigned long long )((unsigned short )((unsigned int )(& ((QAMDATA *)0)->data[0]))) +
                                                                         (unsigned long long )((QUEUE *)dbp___1->q_internal)->re_len) +
                                                                        (unsigned long long )sizeof(u_int32_t )) -
                                                                       1ULL) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) *
                                                                     (unsigned long long )i));
  }
  return (0);
  default: ;
  break;
  }
  if (flags & 16U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" (lsn.file: %lu lsn.offset: %lu)\n",
            (unsigned long )h->lsn.file, (unsigned long )h->lsn.offset);
  }
  s = "\t";
  if ((int )h->type != 3) {
    if ((int )h->type != 4) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%sprev: %4lu next: %4lu",
              s, (unsigned long )h->prev_pgno, (unsigned long )h->next_pgno);
      s = " ";
    }
  }
  if ((int )h->type == 7) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%sref cnt: %4lu ",
            s, (unsigned long )h->entries);
    if (dbp___1->flags & 2048U) {
      tmp___11 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___11 = sizeof(PG_CHKSUM );
      } else {
        tmp___11 = 0U;
      }
    }
    __db_pr((u_int8_t *)h + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                    26) +
                                                                                   tmp___11)))),
            (unsigned int )h->hf_offset, fp);
    return (0);
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%sentries: %4lu",
          s, (unsigned long )h->entries);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" offset: %4lu\n",
          (unsigned long )h->hf_offset);
  if ((int )h->type == 0) {
    return (0);
  } else {
    if (! (flags & 8U)) {
      return (0);
    }
  }
  ret = 0;
  if (dbp___1->flags & 2048U) {
    tmp___13 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___13 = sizeof(PG_CHKSUM );
    } else {
      tmp___13 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)h + 26) + tmp___13);
  i = (unsigned short)0;
  while ((int )i < (int )h->entries) {
    if (dbp___1->flags & 2048U) {
      tmp___15 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___15 = sizeof(PG_CHKSUM );
      } else {
        tmp___15 = 0U;
      }
    }
    if (dbp___1->flags & 2048U) {
      tmp___17 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___17 = sizeof(PG_CHKSUM );
      } else {
        tmp___17 = 0U;
      }
    }
    if ((unsigned int )(((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                                tmp___15) + (int )i))) -
                        (u_int8_t *)h) < (unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                          26) +
                                                                                                         tmp___17))))) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL PAGE OFFSET: indx: %lu of %lu\n",
              (unsigned long )i, (unsigned long )(*(inp + (int )i)));
      ret = 22;
      goto __Cont___0;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___19 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___19 = sizeof(PG_CHKSUM );
        } else {
          tmp___19 = 0U;
        }
      }
      if ((unsigned int )(((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                   26) + tmp___19) +
                                                    (int )i))) - (u_int8_t *)h) >=
          pagesize) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL PAGE OFFSET: indx: %lu of %lu\n",
                (unsigned long )i, (unsigned long )(*(inp + (int )i)));
        ret = 22;
        goto __Cont___0;
      }
    }
    deleted = 0;
    switch ((int )h->type) {
    case 2: ;
    case 3: ;
    case 4: ;
    if (dbp___1->flags & 2048U) {
      tmp___21 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___21 = sizeof(PG_CHKSUM );
      } else {
        tmp___21 = 0U;
      }
    }
    sp = (void *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___21) +
                                           (int )i)));
    break;
    case 5: ;
    if (dbp___1->flags & 2048U) {
      tmp___23 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___23 = sizeof(PG_CHKSUM );
      } else {
        tmp___23 = 0U;
      }
    }
    sp = (void *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___23) +
                                           (int )i)));
    if ((int )i % 2 == 0) {
      if (dbp___1->flags & 2048U) {
        tmp___25 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___25 = sizeof(PG_CHKSUM );
        } else {
          tmp___25 = 0U;
        }
      }
      if ((int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                      26) + tmp___25) +
                                                       ((int )i + 1)))))->type & 128) {
        tmp___26 = 1;
      } else {
        tmp___26 = 0;
      }
    } else {
      tmp___26 = 0;
    }
    deleted = tmp___26;
    break;
    case 12: ;
    case 6: ;
    if (dbp___1->flags & 2048U) {
      tmp___28 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___28 = sizeof(PG_CHKSUM );
      } else {
        tmp___28 = 0U;
      }
    }
    sp = (void *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___28) +
                                           (int )i)));
    if (dbp___1->flags & 2048U) {
      tmp___30 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___30 = sizeof(PG_CHKSUM );
      } else {
        tmp___30 = 0U;
      }
    }
    deleted = (int )((BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                          26) + tmp___30) +
                                                           (int )i))))->type & 128;
    break;
    default: ;
    goto type_err;
    }
    if (deleted) {
      tmp___31 = "       D";
    } else {
      tmp___31 = "\t";
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", tmp___31);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"[%03lu] %4lu ",
            (unsigned long )i, (unsigned long )(*(inp + (int )i)));
    switch ((int )h->type) {
    case 2: 
    hk = (u_int8_t *)sp;
    switch ((int )(*hk)) {
    case 4: 
    memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )(hk + (int )((unsigned short )((unsigned int )(& ((HOFFDUP *)0)->pgno)))),
           sizeof(db_pgno_t ));
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%4lu [offpage dups]\n",
            (unsigned long )pgno);
    break;
    case 2: ;
    if ((int )i != 0) {
      if ((int )i == 0) {
        tmp___34 = 0;
      } else {
        if (dbp___1->flags & 2048U) {
          tmp___36 = sizeof(PG_CRYPTO );
        } else {
          if (dbp___1->flags & 1U) {
            tmp___36 = sizeof(PG_CHKSUM );
          } else {
            tmp___36 = 0U;
          }
        }
        tmp___34 = (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___36) + ((int )i -
                                                                              1)));
      }
      if (dbp___1->flags & 2048U) {
        tmp___38 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___38 = sizeof(PG_CHKSUM );
        } else {
          tmp___38 = 0U;
        }
      }
      len = (unsigned short )((tmp___34 - (int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                  26) + tmp___38) +
                                                   (int )i))) - (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
    } else {
      len = (unsigned short)1;
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Duplicates:\n");
    p = hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])));
    ep = p + (int )len;
    while ((unsigned int )p < (unsigned int )ep) {
      memcpy((void * __restrict  )(& dlen), (void const   * __restrict  )p, sizeof(db_indx_t ));
      p += sizeof(db_indx_t );
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t\t");
      __db_pr(p, (unsigned int )dlen, fp);
      p += sizeof(db_indx_t ) + (unsigned int )dlen;
    }
    break;
    case 1: ;
    if ((int )i == 0) {
      if ((int )i == 0) {
        tmp___42 = pagesize;
      } else {
        tmp___42 = 0U;
      }
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___44 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___44 = sizeof(PG_CHKSUM );
        } else {
          tmp___44 = 0U;
        }
      }
      tmp___42 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___44) +
                                   ((int )i - 1)));
    }
    if (dbp___1->flags & 2048U) {
      tmp___46 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___46 = sizeof(PG_CHKSUM );
      } else {
        tmp___46 = 0U;
      }
    }
    __db_pr(hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))),
            (unsigned int )((unsigned short )((tmp___42 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                           26) +
                                                                                          tmp___46) +
                                                                            (int )i))) -
                                              (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))))),
            fp);
    break;
    case 3: 
    memcpy((void * __restrict  )(& a_hkd), (void const   * __restrict  )hk, sizeof(HOFFPAGE ));
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"overflow: total len: %4lu page: %4lu\n",
            (unsigned long )a_hkd.tlen, (unsigned long )a_hkd.pgno);
    break;
    default: 
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL HASH PAGE TYPE: %lu\n",
            (unsigned long )(*hk));
    ret = 22;
    break;
    }
    break;
    case 3: 
    bi = (BINTERNAL *)sp;
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"count: %4lu pgno: %4lu type: %4lu",
            (unsigned long )bi->nrecs, (unsigned long )bi->pgno, (unsigned long )bi->type);
    switch ((int )bi->type & -129) {
    case 1: 
    __db_pr(bi->data, (unsigned int )bi->len, fp);
    break;
    case 2: ;
    case 3: 
    __db_proff((void *)(bi->data), fp);
    break;
    default: 
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL BINTERNAL TYPE: %lu\n",
            (unsigned long )((int )bi->type & -129));
    ret = 22;
    break;
    }
    break;
    case 4: 
    ri = (RINTERNAL *)sp;
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"entries %4lu pgno %4lu\n",
            (unsigned long )ri->nrecs, (unsigned long )ri->pgno);
    break;
    case 5: ;
    case 12: ;
    case 6: 
    bk = (BKEYDATA *)sp;
    switch ((int )bk->type & -129) {
    case 1: 
    __db_pr(bk->data, (unsigned int )bk->len, fp);
    break;
    case 2: ;
    case 3: 
    __db_proff((void *)bk, fp);
    break;
    default: 
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL DUPLICATE/LBTREE/LRECNO TYPE: %lu\n",
            (unsigned long )((int )bk->type & -129));
    ret = 22;
    break;
    }
    break;
    default: ;
    type_err: 
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"ILLEGAL PAGE TYPE: %lu\n",
            (unsigned long )h->type);
    ret = 22;
    goto __Cont___0;
    }
    __Cont___0: 
    i = (unsigned short )((int )i + 1);
  }
  fflush(fp);
  return (ret);
}
}
void __db_pr(u_int8_t *p , u_int32_t len , FILE *fp ) 
{ u_int32_t i ;
  int lastch ;
  unsigned short const   **tmp ;

  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"len: %3lu", (unsigned long )len);
  lastch = '.';
  if (len != 0U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" data: ");
    if (len <= 20U) {
      i = len;
    } else {
      i = 20U;
    }
    while (i > 0U) {
      lastch = (int )(*p);
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )(*p))) & 16384) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", (*p));
      } else {
        if ((int )(*p) == 10) {
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", (*p));
        } else {
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"0x%.2x",
                  (unsigned int )(*p));
        }
      }
      i --;
      p ++;
    }
    if (len > 20U) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"...");
      lastch = '.';
    }
  }
  if (lastch != 10) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
  return;
}
}
static u_char const   hex[17]  = 
  {      (u_char const   )((unsigned char )'0'),      (u_char const   )((unsigned char )'1'),      (u_char const   )((unsigned char )'2'),      (u_char const   )((unsigned char )'3'), 
        (u_char const   )((unsigned char )'4'),      (u_char const   )((unsigned char )'5'),      (u_char const   )((unsigned char )'6'),      (u_char const   )((unsigned char )'7'), 
        (u_char const   )((unsigned char )'8'),      (u_char const   )((unsigned char )'9'),      (u_char const   )((unsigned char )'a'),      (u_char const   )((unsigned char )'b'), 
        (u_char const   )((unsigned char )'c'),      (u_char const   )((unsigned char )'d'),      (u_char const   )((unsigned char )'e'),      (u_char const   )((unsigned char )'f'), 
        (u_char const   )((unsigned char )'\000')};
int __db_prdbt(DBT *dbtp , int checkprint , char const   *prefix , void *handle ,
               int (*callback)(void * , void const   * ) , int is_recno , VRFY_DBINFO *vdp ) 
{ db_recno_t recno ;
  size_t len ;
  int ret ;
  u_int8_t *p ;
  u_int8_t *hp ;
  char buf[100] ;
  char hbuf[100] ;
  u_int8_t *tmp ;
  u_int8_t *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  if ((unsigned int )vdp != (unsigned int )((void *)0)) {
    if (vdp->flags & 2U) {
      __db_prheader((DB *)((void *)0), (char *)"__OTHER__", 0, 0, handle, callback,
                    vdp, 0U);
    }
    vdp->flags = vdp->flags & 4294967293U;
    vdp->flags = vdp->flags | 4U;
    if (vdp->flags & 1U) {
      checkprint = 1;
    }
  }
  if ((unsigned int )prefix != (unsigned int )((void *)0)) {
    ret = ((*callback))(handle, (void const   *)prefix);
    if (ret != 0) {
      return (ret);
    }
  }
  if (is_recno) {
    __ua_memcpy((void *)(& recno), (void const   *)dbtp->data, sizeof(recno));
    snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"%lu",
             (unsigned long )recno);
    if (! checkprint) {
      len = strlen((char const   *)(buf));
      p = (u_int8_t *)(buf);
      hp = (u_int8_t *)(hbuf);
      while (1) {
        tmp___1 = len;
        len --;
        if (! (tmp___1 > 0U)) {
          break;
        }
        tmp = hp;
        hp ++;
        (*tmp) = hex[(int )((unsigned char )((int )(*p) & 240)) >> 4];
        tmp___0 = hp;
        hp ++;
        (*tmp___0) = hex[(int )(*p) & 15];
        p ++;
      }
      (*hp) = (unsigned char )'\000';
      ret = ((*callback))(handle, (void const   *)(hbuf));
    } else {
      ret = ((*callback))(handle, (void const   *)(buf));
    }
    if (ret != 0) {
      return (ret);
    }
  } else {
    if (checkprint) {
      len = dbtp->size;
      p = (u_int8_t *)dbtp->data;
      while (1) {
        tmp___3 = len;
        len --;
        if (! tmp___3) {
          break;
        }
        tmp___2 = __ctype_b_loc();
        if ((int const   )(*((*tmp___2) + (int )(*p))) & 16384) {
          if ((int )(*p) == 92) {
            ret = ((*callback))(handle, (void const   *)"\\");
            if (ret != 0) {
              return (ret);
            }
          }
          snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"%c",
                   (*p));
          ret = ((*callback))(handle, (void const   *)(buf));
          if (ret != 0) {
            return (ret);
          }
        } else {
          snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"\\%c%c",
                   hex[(int )((unsigned char )((int )(*p) & 240)) >> 4], hex[(int )(*p) &
                                                                             15]);
          ret = ((*callback))(handle, (void const   *)(buf));
          if (ret != 0) {
            return (ret);
          }
        }
        p ++;
      }
    } else {
      len = dbtp->size;
      p = (u_int8_t *)dbtp->data;
      while (1) {
        tmp___4 = len;
        len --;
        if (! tmp___4) {
          break;
        }
        snprintf((char * __restrict  )(buf), 100U, (char const   * __restrict  )"%c%c",
                 hex[(int )((unsigned char )((int )(*p) & 240)) >> 4], hex[(int )(*p) &
                                                                           15]);
        ret = ((*callback))(handle, (void const   *)(buf));
        if (ret != 0) {
          return (ret);
        }
        p ++;
      }
    }
  }
  tmp___5 = ((*callback))(handle, (void const   *)"\n");
  return (tmp___5);
}
}
static void __db_proff(void *vp , FILE *fp ) 
{ BOVERFLOW *bo ;

  {
  bo = (BOVERFLOW *)vp;
  switch ((int )bo->type & -129) {
  case 3: 
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"overflow: total len: %4lu page: %4lu\n",
          (unsigned long )bo->tlen, (unsigned long )bo->pgno);
  break;
  case 2: 
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"duplicate: page: %4lu\n",
          (unsigned long )bo->pgno);
  break;
  default: ;
  break;
  }
}
}
void __db_prflags(u_int32_t flags , FN const   *fn___2 , void *vfp ) 
{ FILE *fp ;
  FN const   *fnp ;
  int found ;
  char const   *sep ;

  {
  fp = (FILE *)vfp;
  sep = " (";
  found = 0;
  fnp = fn___2;
  while (fnp->mask != 0U) {
    if (flags & fnp->mask) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s%s", sep, fnp->name);
      sep = ", ";
      found = 1;
    }
    fnp ++;
  }
  if (found) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )")");
  }
  return;
}
}
char const   *__db_dbtype_to_string(DBTYPE type ) 
{ 

  {
  switch ((int )type) {
  case 1: ;
  return ("btree");
  case 2: ;
  return ("hash");
  case 3: ;
  return ("recno");
  case 4: ;
  return ("queue");
  case 5: ;
  default: ;
  return ("UNKNOWN TYPE");
  }
}
}
static char const   *__db_pagetype_to_string(u_int32_t type ) 
{ char *s ;

  {
  s = (char *)((void *)0);
  switch ((int )type) {
  case 9: 
  s = (char *)"btree metadata";
  break;
  case 12: 
  s = (char *)"duplicate";
  break;
  case 2: 
  s = (char *)"hash";
  break;
  case 8: 
  s = (char *)"hash metadata";
  break;
  case 3: 
  s = (char *)"btree internal";
  break;
  case 0: 
  s = (char *)"invalid";
  break;
  case 4: 
  s = (char *)"recno internal";
  break;
  case 5: 
  s = (char *)"btree leaf";
  break;
  case 6: 
  s = (char *)"recno leaf";
  break;
  case 7: 
  s = (char *)"overflow";
  break;
  case 10: 
  s = (char *)"queue metadata";
  break;
  case 11: 
  s = (char *)"queue";
  break;
  default: ;
  break;
  }
  return ((char const   *)s);
}
}
int __db_prheader(DB *dbp___1 , char *subname , int pflag , int keyflag , void *handle ,
                  int (*callback)(void * , void const   * ) , VRFY_DBINFO *vdp , db_pgno_t meta_pgno ) 
{ DBT dbt ;
  DB_BTREE_STAT *btsp ;
  DB_ENV *dbenv___0 ;
  DB_HASH_STAT *hsp ;
  DB_QUEUE_STAT *qsp ;
  DBTYPE dbtype ;
  VRFY_PAGEINFO *pip ;
  size_t buflen ;
  char *buf ;
  int using_vdp ;
  int ret ;
  int t_ret ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  btsp = (DB_BTREE_STAT *)((void *)0);
  hsp = (DB_HASH_STAT *)((void *)0);
  qsp = (DB_QUEUE_STAT *)((void *)0);
  ret = 0;
  buf = (char *)((void *)0);
  buflen = 0U;
  buflen = buflen;
  if ((unsigned int )dbp___1 == (unsigned int )((void *)0)) {
    dbenv___0 = (DB_ENV *)((void *)0);
  } else {
    dbenv___0 = dbp___1->dbenv;
  }
  if ((unsigned int )vdp != (unsigned int )((void *)0)) {
    ret = __db_vrfy_getpageinfo(vdp, meta_pgno, & pip);
    if (ret != 0) {
      return (ret);
    }
    if (vdp->flags & 1U) {
      pflag = 1;
    }
    using_vdp = 1;
  } else {
    pip = (VRFY_PAGEINFO *)((void *)0);
    using_vdp = 0;
  }
  if ((unsigned int )dbp___1 == (unsigned int )((void *)0)) {
    dbtype = (enum __anonenum_DBTYPE_61 )1;
  } else {
    if (using_vdp) {
      switch ((int )pip->type) {
      case 9: ;
      if (pip->flags & 256U) {
        dbtype = (enum __anonenum_DBTYPE_61 )3;
      } else {
        dbtype = (enum __anonenum_DBTYPE_61 )1;
      }
      break;
      case 8: 
      dbtype = (enum __anonenum_DBTYPE_61 )2;
      break;
      case 10: 
      dbtype = (enum __anonenum_DBTYPE_61 )4;
      break;
      default: 
      dbtype = (enum __anonenum_DBTYPE_61 )1;
      break;
      }
    } else {
      dbtype = dbp___1->type;
    }
  }
  ret = ((*callback))(handle, (void const   *)"VERSION=3\n");
  if (ret != 0) {
    goto err;
  }
  if (pflag) {
    ret = ((*callback))(handle, (void const   *)"format=print\n");
    if (ret != 0) {
      goto err;
    }
  } else {
    ret = ((*callback))(handle, (void const   *)"format=bytevalue\n");
    if (ret != 0) {
      goto err;
    }
  }
  buflen = 64U;
  ret = __os_malloc(dbenv___0, buflen, (void *)(& buf));
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )subname != (unsigned int )((void *)0)) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"database=");
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
    memset((void *)(& dbt), 0, sizeof(dbt));
    dbt.data = (void *)subname;
    tmp = strlen((char const   *)subname);
    dbt.size = tmp;
    ret = __db_prdbt(& dbt, 1, (char const   *)((void *)0), handle, callback, 0, (VRFY_DBINFO *)((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  switch ((int )dbtype) {
  case 1: 
  ret = ((*callback))(handle, (void const   *)"type=btree\n");
  if (ret != 0) {
    goto err;
  }
  if (using_vdp) {
    if (pip->flags & 16U) {
      ret = ((*callback))(handle, (void const   *)"recnum=1\n");
      if (ret != 0) {
        goto err;
      }
    }
    if (pip->bt_maxkey != 0U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"bt_maxkey=%lu\n",
               (unsigned long )pip->bt_maxkey);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
    if (pip->bt_minkey != 0U) {
      if (pip->bt_minkey != 2U) {
        snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"bt_minkey=%lu\n",
                 (unsigned long )pip->bt_minkey);
        ret = ((*callback))(handle, (void const   *)buf);
        if (ret != 0) {
          goto err;
        }
      }
    }
    break;
  }
  ret = __db_stat(dbp___1, (void *)(& btsp), 0U);
  if (ret != 0) {
    tmp___0 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbp___1->dbenv, "DB->stat: %s", tmp___0);
    goto err;
  }
  if (dbp___1->flags & 1048576U) {
    ret = ((*callback))(handle, (void const   *)"recnum=1\n");
    if (ret != 0) {
      goto err;
    }
  }
  if (btsp->bt_maxkey != 0U) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"bt_maxkey=%lu\n",
             (unsigned long )btsp->bt_maxkey);
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
  }
  if (btsp->bt_minkey != 0U) {
    if (btsp->bt_minkey != 2U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"bt_minkey=%lu\n",
               (unsigned long )btsp->bt_minkey);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
  }
  break;
  case 2: 
  ret = ((*callback))(handle, (void const   *)"type=hash\n");
  if (ret != 0) {
    goto err;
  }
  if (using_vdp) {
    if (pip->h_ffactor != 0U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"h_ffactor=%lu\n",
               (unsigned long )pip->h_ffactor);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
    if (pip->h_nelem != 0U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"h_nelem=%lu\n",
               (unsigned long )pip->h_nelem);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
    break;
  }
  ret = __db_stat(dbp___1, (void *)(& hsp), 0U);
  if (ret != 0) {
    tmp___1 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbp___1->dbenv, "DB->stat: %s", tmp___1);
    goto err;
  }
  if (hsp->hash_ffactor != 0U) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"h_ffactor=%lu\n",
             (unsigned long )hsp->hash_ffactor);
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
  }
  if (hsp->hash_nkeys != 0U) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"h_nelem=%lu\n",
             (unsigned long )hsp->hash_nkeys);
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
  }
  break;
  case 4: 
  ret = ((*callback))(handle, (void const   *)"type=queue\n");
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )vdp != (unsigned int )((void *)0)) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"re_len=%lu\n",
             (unsigned long )vdp->re_len);
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
    break;
  }
  ret = __db_stat(dbp___1, (void *)(& qsp), 0U);
  if (ret != 0) {
    tmp___2 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbp___1->dbenv, "DB->stat: %s", tmp___2);
    goto err;
  }
  snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"re_len=%lu\n",
           (unsigned long )qsp->qs_re_len);
  ret = ((*callback))(handle, (void const   *)buf);
  if (ret != 0) {
    goto err;
  }
  if (qsp->qs_re_pad != 0U) {
    if (qsp->qs_re_pad != 32U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"re_pad=%#x\n",
               qsp->qs_re_pad);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (qsp->qs_extentsize != 0U) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"extentsize=%lu\n",
             (unsigned long )qsp->qs_extentsize);
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
  }
  break;
  case 3: 
  ret = ((*callback))(handle, (void const   *)"type=recno\n");
  if (ret != 0) {
    goto err;
  }
  if (using_vdp) {
    if (pip->flags & 512U) {
      ret = ((*callback))(handle, (void const   *)"renumber=1\n");
      if (ret != 0) {
        goto err;
      }
    }
    if (pip->re_len > 0U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"re_len=%lu\n",
               (unsigned long )pip->re_len);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
    break;
  }
  ret = __db_stat(dbp___1, (void *)(& btsp), 0U);
  if (ret != 0) {
    tmp___3 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbp___1->dbenv, "DB->stat: %s", tmp___3);
    goto err;
  }
  if (dbp___1->flags & 4194304U) {
    ret = ((*callback))(handle, (void const   *)"renumber=1\n");
    if (ret != 0) {
      goto err;
    }
  }
  if (dbp___1->flags & 4096U) {
    snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"re_len=%lu\n",
             (unsigned long )btsp->bt_re_len);
    ret = ((*callback))(handle, (void const   *)buf);
    if (ret != 0) {
      goto err;
    }
  }
  if (btsp->bt_re_pad != 0U) {
    if (btsp->bt_re_pad != 32U) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"re_pad=%#x\n",
               btsp->bt_re_pad);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
  }
  break;
  case 5: 
  __db_err((DB_ENV const   *)dbenv___0, "Impossible DB type in __db_prheader");
  ret = 22;
  goto err;
  }
  if (using_vdp) {
    if (pip->flags & 2U) {
      ret = ((*callback))(handle, (void const   *)"duplicates=1\n");
      if (ret != 0) {
        goto err;
      }
    }
    if (pip->flags & 4U) {
      ret = ((*callback))(handle, (void const   *)"dupsort=1\n");
      if (ret != 0) {
        goto err;
      }
    }
  } else {
    if (dbp___1->flags & 1U) {
      ret = ((*callback))(handle, (void const   *)"chksum=1\n");
      if (ret != 0) {
        goto err;
      }
    }
    if (dbp___1->flags & 512U) {
      ret = ((*callback))(handle, (void const   *)"duplicates=1\n");
      if (ret != 0) {
        goto err;
      }
    }
    if (dbp___1->flags & 1024U) {
      ret = ((*callback))(handle, (void const   *)"dupsort=1\n");
      if (ret != 0) {
        goto err;
      }
    }
    if (! (dbp___1->flags & 262144U)) {
      snprintf((char * __restrict  )buf, buflen, (char const   * __restrict  )"db_pagesize=%lu\n",
               (unsigned long )dbp___1->pgsize);
      ret = ((*callback))(handle, (void const   *)buf);
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (keyflag) {
    ret = ((*callback))(handle, (void const   *)"keys=1\n");
    if (ret != 0) {
      goto err;
    }
  }
  ret = ((*callback))(handle, (void const   *)"HEADER=END\n");
  err: 
  if (using_vdp) {
    t_ret = __db_vrfy_putpageinfo(dbenv___0, vdp, pip);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )btsp != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, (void *)btsp);
  }
  if ((unsigned int )hsp != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, (void *)hsp);
  }
  if ((unsigned int )qsp != (unsigned int )((void *)0)) {
    __os_ufree(dbenv___0, (void *)qsp);
  }
  if ((unsigned int )buf != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)buf);
  }
  return (ret);
}
}
int __db_prfooter(void *handle , int (*callback)(void * , void const   * ) ) 
{ int tmp ;

  {
  tmp = ((*callback))(handle, (void const   *)"DATA=END\n");
  return (tmp);
}
}
int __db_pr_callback(void *handle , void const   *str_arg ) 
{ char *str ;
  FILE *f ;
  int tmp ;
  size_t tmp___0 ;

  {
  str = (char *)str_arg;
  f = (FILE *)handle;
  tmp = fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s", str);
  tmp___0 = strlen((char const   *)str);
  if (tmp != (int )tmp___0) {
    return (5);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-njwnBtZu.i","-O2")
static int __db_pg_free_recover_int(DB_ENV *dbenv___0 , __db_pg_freedata_args *argp ,
                                    DB *file_dbp , DB_LSN *lsnp , DB_MPOOLFILE *mpf ,
                                    db_recops op , int data ) ;
int __db_addrem_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __db_addrem_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t change ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  DBT *tmp ;
  DBT *tmp___0 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_addrem_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_addrem_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        } else {
          ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  change = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___11;
    } else {
      if ((int )op == 1) {
        _L___11: 
        if (argp->opcode == 1U) {
          goto _L___5;
        } else {
          goto _L___10;
        }
      } else {
        goto _L___10;
      }
    }
  } else {
    _L___10: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___8;
      } else {
        if ((int )op == 3) {
          goto _L___8;
        } else {
          if ((int )op == 2) {
            _L___8: 
            if (argp->opcode == 2U) {
              _L___5: 
              if (argp->dbt.size == 0U) {
                tmp = (DBT *)((void *)0);
              } else {
                tmp = & argp->dbt;
              }
              if (argp->hdr.size == 0U) {
                tmp___0 = (DBT *)((void *)0);
              } else {
                tmp___0 = & argp->hdr;
              }
              ret = __db_pitem(dbc, pagep, argp->indx, argp->nbytes, tmp___0, tmp);
              if (ret != 0) {
                goto out;
              }
              change = 2U;
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        }
      }
    } else {
      _L___7: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___4;
        } else {
          if ((int )op == 3) {
            goto _L___4;
          } else {
            if ((int )op == 2) {
              _L___4: 
              if (argp->opcode == 1U) {
                goto _L___0;
              } else {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          }
        }
      } else {
        _L___3: 
        if (cmp_p == 0) {
          if ((int )op == 4) {
            goto _L___1;
          } else {
            if ((int )op == 1) {
              _L___1: 
              if (argp->opcode == 2U) {
                _L___0: 
                ret = __db_ditem(dbc, pagep, argp->indx, argp->nbytes);
                if (ret != 0) {
                  goto out;
                }
                change = 2U;
              }
            }
          }
        }
      }
    }
  }
  if (change) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
      } else {
        pagep->lsn = argp->pagelsn;
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, change);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_big_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                     void *info ) 
{ __db_big_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t change ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  unsigned int tmp___0 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_big_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_big_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      ret = 0;
      goto ppage;
    } else {
      if ((int )op == 3) {
        ret = 0;
        goto ppage;
      } else {
        if ((int )op == 2) {
          ret = 0;
          goto ppage;
        } else {
          ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
          if (ret != 0) {
            goto out;
          }
        }
      }
    }
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->pagelsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->pagelsn.file, (unsigned long )argp->pagelsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  change = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___10;
    } else {
      if ((int )op == 1) {
        _L___10: 
        if (argp->opcode == 3U) {
          goto _L___4;
        } else {
          goto _L___9;
        }
      } else {
        goto _L___9;
      }
    }
  } else {
    _L___9: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___7;
      } else {
        if ((int )op == 3) {
          goto _L___7;
        } else {
          if ((int )op == 2) {
            _L___7: 
            if (argp->opcode == 4U) {
              _L___4: 
              while (1) {
                pagep->pgno = argp->pgno;
                pagep->prev_pgno = argp->prev_pgno;
                pagep->next_pgno = argp->next_pgno;
                pagep->entries = (unsigned short)0;
                pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                pagep->level = (unsigned char)0;
                pagep->type = (unsigned char)7;
                break;
              }
              pagep->hf_offset = (unsigned short )argp->dbt.size;
              pagep->entries = (unsigned short)1;
              if (file_dbp->flags & 2048U) {
                tmp___0 = sizeof(PG_CRYPTO );
              } else {
                if (file_dbp->flags & 1U) {
                  tmp___0 = sizeof(PG_CHKSUM );
                } else {
                  tmp___0 = 0U;
                }
              }
              memcpy((void * __restrict  )((u_int8_t *)pagep + (int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                       26) +
                                                                                                                      tmp___0))))),
                     (void const   * __restrict  )argp->dbt.data, argp->dbt.size);
              pagep->prev_pgno = argp->prev_pgno;
              change = 2U;
            } else {
              goto _L___6;
            }
          } else {
            goto _L___6;
          }
        }
      }
    } else {
      _L___6: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___3;
        } else {
          if ((int )op == 3) {
            goto _L___3;
          } else {
            if ((int )op == 2) {
              _L___3: 
              if (argp->opcode == 3U) {
                change = 2U;
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          }
        }
      } else {
        _L___2: 
        if (cmp_p == 0) {
          if ((int )op == 4) {
            goto _L___0;
          } else {
            if ((int )op == 1) {
              _L___0: 
              if (argp->opcode == 4U) {
                change = 2U;
              }
            }
          }
        }
      }
    }
  }
  if (change) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
      } else {
        pagep->lsn = argp->pagelsn;
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, change);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  if (argp->opcode == 4U) {
    goto done;
  }
  ppage: 
  if (argp->prev_pgno != 0U) {
    change = 0U;
    ret = __memp_fget(mpf, & argp->prev_pgno, 0U, (void *)(& pagep));
    if (ret != 0) {
      if ((int )op == 0) {
        (*lsnp) = argp->prev_lsn;
        ret = 0;
        goto npage;
      } else {
        if ((int )op == 3) {
          (*lsnp) = argp->prev_lsn;
          ret = 0;
          goto npage;
        } else {
          if ((int )op == 2) {
            (*lsnp) = argp->prev_lsn;
            ret = 0;
            goto npage;
          } else {
            ret = __memp_fget(mpf, & argp->prev_pgno, 1U, (void *)(& pagep));
            if (ret != 0) {
              goto out;
            }
          }
        }
      }
    }
    cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->prevlsn));
    if ((int )op == 4) {
      goto _L___11;
    } else {
      if ((int )op == 1) {
        _L___11: 
        if (cmp_p < 0) {
          if (pagep->lsn.file == 0U) {
            if (! (pagep->lsn.offset == 1U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                       (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                       (unsigned long )argp->prevlsn.file, (unsigned long )argp->prevlsn.offset);
              ret = 22;
              goto out;
            }
          } else {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->prevlsn.file, (unsigned long )argp->prevlsn.offset);
            ret = 22;
            goto out;
          }
        }
      }
    }
    if (cmp_p == 0) {
      if ((int )op == 4) {
        goto _L___15;
      } else {
        if ((int )op == 1) {
          _L___15: 
          if (argp->opcode == 3U) {
            pagep->next_pgno = argp->pgno;
            change = 2U;
          } else {
            goto _L___14;
          }
        } else {
          goto _L___14;
        }
      }
    } else {
      _L___14: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___12;
        } else {
          if ((int )op == 3) {
            goto _L___12;
          } else {
            if ((int )op == 2) {
              _L___12: 
              if (argp->opcode == 3U) {
                pagep->next_pgno = argp->next_pgno;
                change = 2U;
              }
            }
          }
        }
      }
    }
    if (change) {
      if ((int )op == 4) {
        pagep->lsn = (*lsnp);
      } else {
        if ((int )op == 1) {
          pagep->lsn = (*lsnp);
        } else {
          pagep->lsn = argp->prevlsn;
        }
      }
    }
    ret = __memp_fput(mpf, (void *)pagep, change);
    if (ret != 0) {
      goto out;
    }
  }
  pagep = (PAGE *)((void *)0);
  npage: 
  if (argp->next_pgno != 0U) {
    change = 0U;
    ret = __memp_fget(mpf, & argp->next_pgno, 0U, (void *)(& pagep));
    if (ret != 0) {
      if ((int )op == 0) {
        goto done;
      } else {
        if ((int )op == 3) {
          goto done;
        } else {
          if ((int )op == 2) {
            goto done;
          } else {
            ret = __memp_fget(mpf, & argp->next_pgno, 1U, (void *)(& pagep));
            if (ret != 0) {
              goto out;
            }
          }
        }
      }
    }
    cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->nextlsn));
    if ((int )op == 4) {
      goto _L___16;
    } else {
      if ((int )op == 1) {
        _L___16: 
        if (cmp_p < 0) {
          if (pagep->lsn.file == 0U) {
            if (! (pagep->lsn.offset == 1U)) {
              __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                       (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                       (unsigned long )argp->nextlsn.file, (unsigned long )argp->nextlsn.offset);
              ret = 22;
              goto out;
            }
          } else {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->nextlsn.file, (unsigned long )argp->nextlsn.offset);
            ret = 22;
            goto out;
          }
        }
      }
    }
    if (cmp_p == 0) {
      if ((int )op == 4) {
        pagep->prev_pgno = 0U;
        change = 2U;
      } else {
        if ((int )op == 1) {
          pagep->prev_pgno = 0U;
          change = 2U;
        } else {
          goto _L___17;
        }
      }
    } else {
      _L___17: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          pagep->prev_pgno = argp->pgno;
          change = 2U;
        } else {
          if ((int )op == 3) {
            pagep->prev_pgno = argp->pgno;
            change = 2U;
          } else {
            if ((int )op == 2) {
              pagep->prev_pgno = argp->pgno;
              change = 2U;
            }
          }
        }
      }
    }
    if (change) {
      if ((int )op == 4) {
        pagep->lsn = (*lsnp);
      } else {
        if ((int )op == 1) {
          pagep->lsn = (*lsnp);
        } else {
          pagep->lsn = argp->nextlsn;
        }
      }
    }
    ret = __memp_fput(mpf, (void *)pagep, change);
    if (ret != 0) {
      goto out;
    }
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_ovref_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) 
{ __db_ovref_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int cmp ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_ovref_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_ovref_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 0) {
      goto done;
    } else {
      if ((int )op == 3) {
        goto done;
      } else {
        if ((int )op == 2) {
          goto done;
        }
      }
    }
    ret = __db_pgerr(file_dbp, argp->pgno, ret);
    goto out;
  }
  modified = 0;
  cmp = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp == 0) {
    if ((int )op == 4) {
      pagep->entries = (unsigned short )((int )pagep->entries + argp->adjust);
      pagep->lsn = (*lsnp);
      modified = 1;
    } else {
      if ((int )op == 1) {
        pagep->entries = (unsigned short )((int )pagep->entries + argp->adjust);
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: 
    tmp = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    if (tmp == 0) {
      if ((int )op == 0) {
        pagep->entries = (unsigned short )((int )pagep->entries - argp->adjust);
        pagep->lsn = argp->lsn;
        modified = 1;
      } else {
        if ((int )op == 3) {
          pagep->entries = (unsigned short )((int )pagep->entries - argp->adjust);
          pagep->lsn = argp->lsn;
          modified = 1;
        } else {
          if ((int )op == 2) {
            pagep->entries = (unsigned short )((int )pagep->entries - argp->adjust);
            pagep->lsn = argp->lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_relink_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __db_relink_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_relink_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_relink_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, argp->pgno, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, argp->pgno, ret);
        goto out;
      }
    }
    goto next2;
  }
  modified = 0;
  if (argp->opcode == 5U) {
    goto next1;
  }
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn.file, (unsigned long )argp->lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
      modified = 1;
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: 
    tmp = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    if (tmp == 0) {
      if ((int )op == 0) {
        pagep->next_pgno = argp->next;
        pagep->prev_pgno = argp->prev;
        pagep->lsn = argp->lsn;
        modified = 1;
      } else {
        if ((int )op == 3) {
          pagep->next_pgno = argp->next;
          pagep->prev_pgno = argp->prev;
          pagep->lsn = argp->lsn;
          modified = 1;
        } else {
          if ((int )op == 2) {
            pagep->next_pgno = argp->next;
            pagep->prev_pgno = argp->prev;
            pagep->lsn = argp->lsn;
            modified = 1;
          }
        }
      }
    }
  }
  next1: 
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  next2: 
  ret = __memp_fget(mpf, & argp->next, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, argp->next, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, argp->next, ret);
        goto out;
      }
    }
    goto prev;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn_next));
  if ((int )op == 4) {
    goto _L___1;
  } else {
    if ((int )op == 1) {
      _L___1: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn_next.file, (unsigned long )argp->lsn_next.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn_next.file, (unsigned long )argp->lsn_next.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (argp->opcode == 6U) {
    if (cmp_p == 0) {
      if ((int )op == 4) {
        pagep->prev_pgno = argp->prev;
        modified = 1;
      } else {
        if ((int )op == 1) {
          pagep->prev_pgno = argp->prev;
          modified = 1;
        } else {
          goto _L___7;
        }
      }
    } else {
      goto _L___7;
    }
  } else {
    _L___7: 
    if (argp->opcode == 5U) {
      if (cmp_n == 0) {
        if ((int )op == 0) {
          pagep->prev_pgno = argp->prev;
          modified = 1;
        } else {
          if ((int )op == 3) {
            pagep->prev_pgno = argp->prev;
            modified = 1;
          } else {
            if ((int )op == 2) {
              pagep->prev_pgno = argp->prev;
              modified = 1;
            } else {
              goto _L___5;
            }
          }
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
      if (argp->opcode == 6U) {
        if (cmp_n == 0) {
          if ((int )op == 0) {
            pagep->prev_pgno = argp->pgno;
            modified = 1;
          } else {
            if ((int )op == 3) {
              pagep->prev_pgno = argp->pgno;
              modified = 1;
            } else {
              if ((int )op == 2) {
                pagep->prev_pgno = argp->pgno;
                modified = 1;
              } else {
                goto _L___3;
              }
            }
          }
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        if (argp->opcode == 5U) {
          if (cmp_p == 0) {
            if ((int )op == 4) {
              pagep->prev_pgno = argp->pgno;
              modified = 1;
            } else {
              if ((int )op == 1) {
                pagep->prev_pgno = argp->pgno;
                modified = 1;
              }
            }
          }
        }
      }
    }
  }
  if (modified == 1) {
    if ((int )op == 0) {
      pagep->lsn = argp->lsn_next;
    } else {
      if ((int )op == 3) {
        pagep->lsn = argp->lsn_next;
      } else {
        if ((int )op == 2) {
          pagep->lsn = argp->lsn_next;
        } else {
          pagep->lsn = (*lsnp);
        }
      }
    }
  }
  if (modified) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___1);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  if (argp->opcode == 5U) {
    goto done;
  }
  prev: 
  ret = __memp_fget(mpf, & argp->prev, 0U, (void *)(& pagep));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, argp->prev, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, argp->prev, ret);
        goto out;
      }
    }
    goto done;
  }
  modified = 0;
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->lsn_prev));
  if ((int )op == 4) {
    goto _L___8;
  } else {
    if ((int )op == 1) {
      _L___8: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->lsn_prev.file, (unsigned long )argp->lsn_prev.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->lsn_prev.file, (unsigned long )argp->lsn_prev.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      pagep->next_pgno = argp->next;
      modified = 1;
    } else {
      if ((int )op == 1) {
        pagep->next_pgno = argp->next;
        modified = 1;
      } else {
        goto _L___9;
      }
    }
  } else {
    _L___9: 
    tmp___2 = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
    if (tmp___2 == 0) {
      if ((int )op == 0) {
        pagep->next_pgno = argp->pgno;
        modified = 1;
      } else {
        if ((int )op == 3) {
          pagep->next_pgno = argp->pgno;
          modified = 1;
        } else {
          if ((int )op == 2) {
            pagep->next_pgno = argp->pgno;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified == 1) {
    if ((int )op == 0) {
      pagep->lsn = argp->lsn_prev;
    } else {
      if ((int )op == 3) {
        pagep->lsn = argp->lsn_prev;
      } else {
        if ((int )op == 2) {
          pagep->lsn = argp->lsn_prev;
        } else {
          pagep->lsn = (*lsnp);
        }
      }
    }
  }
  if (modified) {
    tmp___3 = 2;
  } else {
    tmp___3 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___3);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_debug_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) 
{ __db_debug_args *argp ;
  int ret ;

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  op = (enum __anonenum_db_recops_55 )0;
  op = op;
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_debug_args *)((void *)0);
    ret = __db_debug_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
int __db_noop_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) 
{ __db_noop_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  u_int32_t change ;
  int cmp_n ;
  int cmp_p ;
  int ret ;
  int __t_ret ;

  {
  pagep = (PAGE *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_noop_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_noop_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    goto out;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->prevlsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->prevlsn.file, (unsigned long )argp->prevlsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->prevlsn.file, (unsigned long )argp->prevlsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  change = 0U;
  if (cmp_p == 0) {
    if ((int )op == 4) {
      pagep->lsn = (*lsnp);
      change = 2U;
    } else {
      if ((int )op == 1) {
        pagep->lsn = (*lsnp);
        change = 2U;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        pagep->lsn = argp->prevlsn;
        change = 2U;
      } else {
        if ((int )op == 3) {
          pagep->lsn = argp->prevlsn;
          change = 2U;
        } else {
          if ((int )op == 2) {
            pagep->lsn = argp->prevlsn;
            change = 2U;
          }
        }
      }
    }
  }
  ret = __memp_fput(mpf, (void *)pagep, change);
  pagep = (PAGE *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_pg_alloc_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __db_pg_alloc_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DBMETA *meta ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  int cmp_n ;
  int cmp_p ;
  int created ;
  int level ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __t_ret ;

  {
  meta = (DBMETA *)((void *)0);
  pagep = (PAGE *)((void *)0);
  while (1) {
    argp = (__db_pg_alloc_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_pg_alloc_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  pgno = 0U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, pgno, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, pgno, ret);
        goto out;
      } else {
        goto done;
      }
    }
  }
  modified = 0;
  created = modified;
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
    if (ret != 0) {
      if (ret == 28) {
        goto do_meta;
      }
      ret = __db_pgerr(file_dbp, argp->pgno, ret);
      goto out;
    }
    modified = 1;
    created = modified;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->page_lsn));
  if (pagep->lsn.file == 0U) {
    cmp_p = 0;
  }
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->page_lsn.file, (unsigned long )argp->page_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->page_lsn.file, (unsigned long )argp->page_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if ((int )op == 4) {
    goto _L___4;
  } else {
    if ((int )op == 1) {
      _L___4: 
      if (cmp_p == 0) {
        goto _L___3;
      } else {
        if (argp->page_lsn.file == 0U) {
          if (pagep->lsn.file == 1U) {
            if (pagep->lsn.offset == 0U) {
              _L___3: 
              switch ((int )argp->ptype) {
              case 5: ;
              case 6: ;
              case 12: 
              level = 1;
              break;
              default: 
              level = 0;
              break;
              }
              while (1) {
                pagep->pgno = argp->pgno;
                pagep->prev_pgno = 0U;
                pagep->next_pgno = 0U;
                pagep->entries = (unsigned short)0;
                pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                pagep->level = (unsigned char )level;
                pagep->type = (unsigned char )argp->ptype;
                break;
              }
              pagep->lsn = (*lsnp);
              modified = 1;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      _L___2: 
      if ((int )op == 0) {
        goto _L___1;
      } else {
        if ((int )op == 3) {
          goto _L___1;
        } else {
          if ((int )op == 2) {
            _L___1: 
            if (cmp_n == 0) {
              goto _L___0;
            } else {
              if (created) {
                _L___0: 
                while (1) {
                  pagep->pgno = argp->pgno;
                  pagep->prev_pgno = 0U;
                  pagep->next_pgno = argp->next;
                  pagep->entries = (unsigned short)0;
                  pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                  pagep->level = (unsigned char)0;
                  pagep->type = (unsigned char)0;
                  break;
                }
                pagep->lsn = argp->page_lsn;
                modified = 1;
              }
            }
          }
        }
      }
    }
  }
  if (pagep->lsn.file == 0U) {
    if (argp->page_lsn.file == 0U) {
      if ((int )op == 0) {
        goto _L___5;
      } else {
        if ((int )op == 3) {
          goto _L___5;
        } else {
          if ((int )op == 2) {
            _L___5: 
            ret = __db_add_limbo(dbenv___0, info, argp->fileid, argp->pgno, 1);
            if (ret != 0) {
              goto out;
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  do_meta: 
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& argp->meta_lsn));
  if ((int )op == 4) {
    goto _L___6;
  } else {
    if ((int )op == 1) {
      _L___6: 
      if (cmp_p < 0) {
        if (((PAGE *)meta)->lsn.file == 0U) {
          if (! (((PAGE *)meta)->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                     (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                   (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      ((PAGE *)meta)->lsn = (*lsnp);
      meta->free = argp->next;
      modified = 1;
    } else {
      if ((int )op == 1) {
        ((PAGE *)meta)->lsn = (*lsnp);
        meta->free = argp->next;
        modified = 1;
      } else {
        goto _L___8;
      }
    }
  } else {
    _L___8: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___7;
      } else {
        if ((int )op == 3) {
          goto _L___7;
        } else {
          if ((int )op == 2) {
            _L___7: 
            ((PAGE *)meta)->lsn = argp->meta_lsn;
            if (! (argp->page_lsn.file == 0U)) {
              meta->free = argp->pgno;
            }
            modified = 1;
          }
        }
      }
    }
  }
  if (argp->pgno > meta->last_pgno) {
    meta->last_pgno = argp->pgno;
    modified = 1;
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  meta = (DBMETA *)((void *)0);
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, 0U);
  }
  if (ret == 2) {
    if ((int )op == 2) {
      ret = 0;
    }
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
static int __db_pg_free_recover_int(DB_ENV *dbenv___0 , __db_pg_freedata_args *argp ,
                                    DB *file_dbp , DB_LSN *lsnp , DB_MPOOLFILE *mpf ,
                                    db_recops op , int data ) 
{ DBMETA *meta ;
  DB_LSN copy_lsn ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  meta = (DBMETA *)((void *)0);
  pagep = (PAGE *)((void *)0);
  ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
  if (ret != 0) {
    goto out;
  }
  modified = 0;
  __ua_memcpy((void *)(& copy_lsn), (void const   *)(& ((PAGE *)argp->header.data)->lsn),
              sizeof(DB_LSN ));
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& copy_lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )copy_lsn.file, (unsigned long )copy_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )copy_lsn.file, (unsigned long )copy_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if ((int )op == 4) {
    goto _L___3;
  } else {
    if ((int )op == 1) {
      _L___3: 
      if (cmp_p == 0) {
        goto _L___2;
      } else {
        if (copy_lsn.file == 0U) {
          tmp = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->meta_lsn));
          if (tmp <= 0) {
            _L___2: 
            while (1) {
              pagep->pgno = argp->pgno;
              pagep->prev_pgno = 0U;
              pagep->next_pgno = argp->next;
              pagep->entries = (unsigned short)0;
              pagep->hf_offset = (unsigned short )file_dbp->pgsize;
              pagep->level = (unsigned char)0;
              pagep->type = (unsigned char)0;
              break;
            }
            pagep->lsn = (*lsnp);
            modified = 1;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      }
    } else {
      _L___1: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___0;
        } else {
          if ((int )op == 3) {
            goto _L___0;
          } else {
            if ((int )op == 2) {
              _L___0: 
              memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->header.data,
                     argp->header.size);
              if (data) {
                memcpy((void * __restrict  )((u_int8_t *)pagep + (int )pagep->hf_offset),
                       (void const   * __restrict  )argp->data.data, argp->data.size);
              }
              modified = 1;
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  pgno = 0U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    ret = __db_pgerr(file_dbp, pgno, ret);
    goto out;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& argp->meta_lsn));
  if ((int )op == 4) {
    goto _L___4;
  } else {
    if ((int )op == 1) {
      _L___4: 
      if (cmp_p < 0) {
        if (((PAGE *)meta)->lsn.file == 0U) {
          if (! (((PAGE *)meta)->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                     (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                   (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___6;
    } else {
      if ((int )op == 1) {
        _L___6: 
        meta->free = argp->pgno;
        if (meta->last_pgno < meta->free) {
          meta->last_pgno = meta->free;
        }
        ((PAGE *)meta)->lsn = (*lsnp);
        modified = 1;
      } else {
        goto _L___5;
      }
    }
  } else {
    _L___5: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        meta->free = argp->next;
        ((PAGE *)meta)->lsn = argp->meta_lsn;
        modified = 1;
      } else {
        if ((int )op == 3) {
          meta->free = argp->next;
          ((PAGE *)meta)->lsn = argp->meta_lsn;
          modified = 1;
        } else {
          if ((int )op == 2) {
            meta->free = argp->next;
            ((PAGE *)meta)->lsn = argp->meta_lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___1);
  if (ret != 0) {
    goto out;
  }
  meta = (DBMETA *)((void *)0);
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, 0U);
  }
  return (ret);
}
}
int __db_pg_free_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  __db_pg_free_args *argp ;
  int ret ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_pg_free_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_pg_free_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto done;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto done;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto done;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __db_pg_free_recover_int(dbenv___0, (__db_pg_freedata_args *)argp, file_dbp,
                                 lsnp, mpf, op, 0);
  done: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_pg_new_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  __db_pg_free_args *argp ;
  int ret ;
  int __t_ret ;

  {
  while (1) {
    argp = (__db_pg_free_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_pg_free_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto done;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto done;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto done;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  op = (enum __anonenum_db_recops_55 )0;
  op = op;
  ret = __db_add_limbo(dbenv___0, info, argp->fileid, argp->pgno, 1);
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  done: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_pg_freedata_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                             void *info ) 
{ DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  __db_pg_freedata_args *argp ;
  int ret ;
  int __t_ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__db_pg_freedata_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_pg_freedata_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto done;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto done;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto done;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  ret = __db_pg_free_recover_int(dbenv___0, argp, file_dbp, lsnp, mpf, op, 1);
  done: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_cksum_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                       void *info ) 
{ __db_cksum_args *argp ;
  int ret ;

  {
  info = (void *)0;
  info = info;
  lsnp = (DB_LSN *)((void *)0);
  lsnp = lsnp;
  op = (enum __anonenum_db_recops_55 )0;
  op = op;
  ret = __db_cksum_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (dbenv___0->flags & 128U) {
    ret = 0;
  } else {
    __db_err((DB_ENV const   *)dbenv___0, "Checksum failure requires catastrophic recovery");
    ret = __db_panic(dbenv___0, -30978);
  }
  __os_free(dbenv___0, (void *)argp);
  return (ret);
}
}
int __db_pg_prepare_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                            void *info ) 
{ __db_pg_prepare_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  int ret ;
  int t_ret ;
  int __t_ret ;

  {
  while (1) {
    argp = (__db_pg_prepare_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_pg_prepare_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 1);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags = dbc->flags | 16U;
    mpf = file_dbp->mpf;
    break;
  }
  mpf = file_dbp->mpf;
  if ((int )op == 0) {
    ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
    if (ret != 0) {
      goto out;
    }
    while (1) {
      pagep->pgno = argp->pgno;
      pagep->prev_pgno = 0U;
      pagep->next_pgno = 0U;
      pagep->entries = (unsigned short)0;
      pagep->hf_offset = (unsigned short )file_dbp->pgsize;
      pagep->level = (unsigned char)0;
      pagep->type = (unsigned char)0;
      break;
    }
    while (1) {
      pagep->lsn.file = 0U;
      pagep->lsn.offset = 0U;
      break;
    }
    ret = __db_add_limbo(dbenv___0, info, argp->fileid, argp->pgno, 1);
    t_ret = __memp_fput(mpf, (void *)pagep, 2U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  done: 
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-t3jM6N8a.i","-O2")
int __db_traverse_big(DB *dbp___1 , db_pgno_t pgno , int (*callback)(DB * , PAGE * ,
                                                                     void * , int * ) ,
                      void *cookie ) 
{ DB_MPOOLFILE *mpf ;
  PAGE *p ;
  int did_put ;
  int ret ;

  {
  mpf = dbp___1->mpf;
  while (1) {
    did_put = 0;
    ret = __memp_fget(mpf, & pgno, 0U, (void *)(& p));
    if (ret != 0) {
      return (ret);
    }
    pgno = p->next_pgno;
    ret = ((*callback))(dbp___1, p, cookie, & did_put);
    if (ret == 0) {
      if (! did_put) {
        ret = __memp_fput(mpf, (void *)p, 0U);
      }
    }
    if (ret == 0) {
      if (! (pgno != 0U)) {
        break;
      }
    } else {
      break;
    }
  }
  return (ret);
}
}
int __db_reclaim_callback(DB *dbp___1 , PAGE *p , void *cookie , int *putp ) 
{ int ret ;

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  ret = __db_free((DBC *)cookie, p);
  if (ret != 0) {
    return (ret);
  }
  (*putp) = 1;
  return (0);
}
}
int __db_truncate_callback(DB *dbp___1 , PAGE *p , void *cookie , int *putp ) 
{ DB_MPOOLFILE *mpf ;
  db_indx_t indx ;
  db_indx_t len ;
  db_indx_t off ;
  db_indx_t tlen ;
  db_indx_t top ;
  db_trunc_param *param ;
  u_int8_t *hk ;
  u_int8_t type ;
  int ret ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  int tmp___9 ;
  unsigned int tmp___11 ;
  unsigned int tmp___13 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  top = p->entries;
  mpf = dbp___1->mpf;
  param = (db_trunc_param *)cookie;
  (*putp) = 1;
  switch ((int )p->type) {
  case 5: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___0 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___0 = sizeof(PG_CHKSUM );
      } else {
        tmp___0 = 0U;
      }
    }
    type = ((BKEYDATA *)((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) +
                                                                tmp___0) + ((int )indx +
                                                                            1)))))->type;
    if (! ((int )type & 128)) {
      if (((int )type & -129) != 2) {
        param->count = param->count + 1U;
      }
    }
    indx = (unsigned short )((int )indx + 2);
  }
  case 3: ;
  case 4: ;
  case 0: ;
  if ((int )dbp___1->type != 2) {
    if (((BTREE *)dbp___1->bt_internal)->bt_root == p->pgno) {
      if ((int )dbp___1->type == 3) {
        type = (unsigned char)6;
      } else {
        type = (unsigned char)5;
      }
      goto reinit;
    }
  }
  break;
  case 7: ;
  if ((unsigned int )(param->dbc)->txn != (unsigned int )((void *)0)) {
    if ((unsigned int )(((param->dbc)->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
      if (! ((param->dbc)->flags & 16U)) {
        if ((unsigned int )(((param->dbc)->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
          if (((DB_REP *)(((param->dbc)->dbp)->dbenv)->rep_handle)->region) {
            if ((((DB_REP *)(((param->dbc)->dbp)->dbenv)->rep_handle)->region)->flags &
                516U) {
              goto _L___3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          ret = __db_ovref_log(dbp___1, (param->dbc)->txn, & p->lsn, 0U, p->pgno,
                               -1, & p->lsn);
          if (ret != 0) {
            return (ret);
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    while (1) {
      p->lsn.file = 0U;
      p->lsn.offset = 1U;
      break;
    }
  }
  p->entries = (unsigned short )((int )p->entries - 1);
  if ((int )p->entries != 0) {
    (*putp) = 0;
  }
  break;
  case 6: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___2 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___2 = sizeof(PG_CHKSUM );
      } else {
        tmp___2 = 0U;
      }
    }
    type = ((BKEYDATA *)((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) +
                                                                tmp___2) + (int )indx))))->type;
    if (! ((int )type & 128)) {
      param->count = param->count + 1U;
    }
    indx = (unsigned short )((int )indx + 1);
  }
  if (((BTREE *)dbp___1->bt_internal)->bt_root == p->pgno) {
    type = (unsigned char)6;
    goto reinit;
  }
  break;
  case 12: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___4 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___4 = sizeof(PG_CHKSUM );
      } else {
        tmp___4 = 0U;
      }
    }
    if (! ((int )((BKEYDATA *)((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p +
                                                                       26) + tmp___4) +
                                                        (int )indx))))->type & 128)) {
      param->count = param->count + 1U;
    }
    indx = (unsigned short )((int )indx + 1);
  }
  break;
  case 2: 
  indx = (unsigned short)0;
  while ((int )indx < (int )top) {
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    switch ((int )(*((u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) +
                                                            tmp___6) + ((int )indx +
                                                                        1)))))) {
    case 4: ;
    case 3: ;
    break;
    case 1: 
    param->count = param->count + 1U;
    break;
    case 2: ;
    if ((int )indx + 1 == 0) {
      tmp___9 = 0;
    } else {
      if (dbp___1->flags & 2048U) {
        tmp___11 = sizeof(PG_CRYPTO );
      } else {
        if (dbp___1->flags & 1U) {
          tmp___11 = sizeof(PG_CHKSUM );
        } else {
          tmp___11 = 0U;
        }
      }
      tmp___9 = (int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___11) + (((int )indx +
                                                                            1) - 1)));
    }
    if (dbp___1->flags & 2048U) {
      tmp___13 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___13 = sizeof(PG_CHKSUM );
      } else {
        tmp___13 = 0U;
      }
    }
    tlen = (unsigned short )((tmp___9 - (int )(*((db_indx_t *)(((u_int8_t *)p + 26) +
                                                               tmp___13) + ((int )indx +
                                                                            1)))) -
                             (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
    if (dbp___1->flags & 2048U) {
      tmp___15 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___15 = sizeof(PG_CHKSUM );
      } else {
        tmp___15 = 0U;
      }
    }
    hk = (u_int8_t *)p + (int )(*((db_indx_t *)(((u_int8_t *)p + 26) + tmp___15) +
                                  ((int )indx + 1)));
    off = (unsigned short)0;
    while ((int )off < (int )tlen) {
      param->count = param->count + 1U;
      memcpy((void * __restrict  )(& len), (void const   * __restrict  )((hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0])))) +
                                                                         (int )off),
             sizeof(db_indx_t ));
      off = (unsigned short )((unsigned int )off + ((unsigned int )len + 2U * sizeof(db_indx_t )));
    }
    break;
    default: 
    tmp___16 = __db_pgfmt(dbp___1->dbenv, p->pgno);
    return (tmp___16);
    }
    indx = (unsigned short )((int )indx + 2);
  }
  if (p->prev_pgno == 0U) {
    type = (unsigned char)2;
    reinit: 
    (*putp) = 0;
    if ((unsigned int )(param->dbc)->txn != (unsigned int )((void *)0)) {
      if ((unsigned int )(((param->dbc)->dbp)->dbenv)->lg_handle != (unsigned int )((void *)0)) {
        if (! ((param->dbc)->flags & 16U)) {
          if ((unsigned int )(((param->dbc)->dbp)->dbenv)->rep_handle != (unsigned int )((void *)0)) {
            if (((DB_REP *)(((param->dbc)->dbp)->dbenv)->rep_handle)->region) {
              if ((((DB_REP *)(((param->dbc)->dbp)->dbenv)->rep_handle)->region)->flags &
                  516U) {
                goto _L___8;
              } else {
                goto _L___6;
              }
            } else {
              goto _L___6;
            }
          } else {
            _L___6: 
            ret = __db_free(param->dbc, p);
            if (ret != 0) {
              return (ret);
            }
            ret = __db_new(param->dbc, (unsigned int )type, & p);
            if (ret != 0) {
              return (ret);
            }
          }
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      _L___8: 
      while (1) {
        p->lsn.file = 0U;
        p->lsn.offset = 1U;
        break;
      }
    }
    while (1) {
      p->pgno = p->pgno;
      p->prev_pgno = 0U;
      p->next_pgno = 0U;
      p->entries = (unsigned short)0;
      p->hf_offset = (unsigned short )dbp___1->pgsize;
      if ((int )type == 2) {
        p->level = (unsigned char)0;
      } else {
        p->level = (unsigned char)1;
      }
      p->type = type;
      break;
    }
  }
  break;
  default: 
  tmp___17 = __db_pgfmt(dbp___1->dbenv, p->pgno);
  return (tmp___17);
  }
  if ((*putp) == 1) {
    ret = __db_free(param->dbc, p);
    if (ret != 0) {
      return (ret);
    }
  } else {
    ret = __memp_fput(mpf, (void *)p, 2U);
    if (ret != 0) {
      return (ret);
    }
    (*putp) = 1;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-vJQ64Pl2.i","-O2")
int __dbenv_dbrename_pp(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , char const   *subdb ,
                        char const   *newname , u_int32_t flags ) ;
int __db_rename(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                char const   *newname ) ;
int __db_rename_int(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                    char const   *newname ) ;
int __fop_lock_handle(DB_ENV *dbenv___0 , DB *dbp___1 , u_int32_t locker , db_lockmode_t mode ,
                      DB_LOCK *elock , u_int32_t flags ) ;
int __fop_remove_setup(DB *dbp___1 , DB_TXN *txn , char const   *name , u_int32_t flags ) ;
int __fop_dummy(DB *dbp___1 , DB_TXN *txn , char const   *old , char const   *new ,
                u_int32_t flags ) ;
int __fop_dbrename(DB *dbp___1 , char const   *old , char const   *new ) ;
static int __dbenv_dbrename(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name ,
                            char const   *subdb , char const   *newname , int txn_local ) ;
static int __db_subdb_rename(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                             char const   *newname ) ;
int __dbenv_dbrename_pp(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , char const   *subdb ,
                        char const   *newname , u_int32_t flags ) 
{ int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbenv___0->flags & 8192U)) {
    tmp___0 = __db_mi_open(dbenv___0, "DB_ENV->dbrename", 0);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB->rename", flags, 16777216U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 16777216U) {
    goto _L;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            return (ret);
          }
          txn_local = 1;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
          tmp___1 = __db_not_txn_env(dbenv___0);
          return (tmp___1);
        }
      }
      txn_local = 0;
    }
  }
  ret = __dbenv_dbrename(dbenv___0, txn, name, subdb, newname, txn_local);
  if (txn_local) {
    tmp___3 = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
static int __dbenv_dbrename(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name ,
                            char const   *subdb , char const   *newname , int txn_local ) 
{ DB *dbp___1 ;
  int handle_check ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  ret = db_create(& dbp___1, dbenv___0, 0U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    dbp___1->flags = dbp___1->flags | 536870912U;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  handle_check = tmp;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_rename_int(dbp___1, txn, name, subdb, newname);
  if (txn_local) {
    dbp___1->handle_lock.off = 0U;
    dbp___1->lid = 0U;
  } else {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      dbp___1->lid = 0U;
    }
  }
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  t_ret = __db_close(dbp___1, txn, 23U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_rename_pp(DB *dbp___1 , char const   *name , char const   *subdb , char const   *newname ,
                   u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  handle_check = 0;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (dbp___1->flags & 65536U) {
    ret = __db_mi_open(dbenv___0, "DB->rename", 1);
    goto err;
  }
  ret = __db_fchk(dbenv___0, "DB->rename", flags, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_check_txn(dbp___1, (DB_TXN *)((void *)0), 0U, 0);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, 0);
    if (ret != 0) {
      handle_check = 0;
      goto err;
    }
  }
  ret = __db_rename(dbp___1, (DB_TXN *)((void *)0), name, subdb, newname);
  err: 
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_rename(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                char const   *newname ) 
{ int ret ;
  int t_ret ;

  {
  ret = __db_rename_int(dbp___1, txn, name, subdb, newname);
  t_ret = __db_close(dbp___1, txn, 23U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_rename_int(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                    char const   *newname ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  char *real_name ;

  {
  dbenv___0 = dbp___1->dbenv;
  real_name = (char *)((void *)0);
  if ((unsigned int )subdb != (unsigned int )((void *)0)) {
    ret = __db_subdb_rename(dbp___1, txn, name, subdb, newname);
    goto err;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, name, 0U, (DB_FH **)((void *)0),
                     & real_name);
  if (ret != 0) {
    goto err;
  }
  ret = __fop_remove_setup(dbp___1, txn, (char const   *)real_name, 0U);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbp___1->db_am_rename != (unsigned int )((void *)0)) {
    ret = ((*(dbp___1->db_am_rename)))(dbp___1, txn, name, subdb, newname);
    if (ret != 0) {
      goto err;
    }
  }
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    ret = __fop_dummy(dbp___1, txn, name, newname, 0U);
    if (ret != 0) {
      goto err;
    }
  } else {
    ret = __fop_dbrename(dbp___1, name, newname);
    if (ret != 0) {
      goto err;
    }
  }
  err: 
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  return (ret);
}
}
static int __db_subdb_rename(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                             char const   *newname ) 
{ DB *mdbp ;
  DB_ENV *dbenv___0 ;
  PAGE *meta ;
  int ret ;
  int t_ret ;

  {
  mdbp = (DB *)((void *)0);
  meta = (PAGE *)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  dbp___1->flags = dbp___1->flags | 134217728U;
  ret = __db_master_open(dbp___1, txn, name, 0U, 0, & mdbp);
  if (ret != 0) {
    goto err;
  }
  ret = __db_master_update(mdbp, dbp___1, txn, subdb, dbp___1->type, (enum __anonenum_mu_action_40 )2,
                           (char const   *)((void *)0), 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fget(mdbp->mpf, & dbp___1->meta_pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    goto err;
  }
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(((DBMETA *)meta)->uid),
         20U);
  ret = __fop_lock_handle(dbenv___0, dbp___1, mdbp->lid, (enum __anonenum_db_lockmode_t_50 )2,
                          (DB_LOCK *)((void *)0), 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_fput(mdbp->mpf, (void *)meta, 0U);
  meta = (PAGE *)((void *)0);
  if (ret != 0) {
    goto err;
  }
  ret = __db_master_update(mdbp, dbp___1, txn, subdb, dbp___1->type, (enum __anonenum_mu_action_40 )1,
                           newname, 0U);
  if (ret != 0) {
    goto err;
  }
  err: 
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    t_ret = __memp_fput(mdbp->mpf, (void *)meta, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )mdbp != (unsigned int )((void *)0)) {
    t_ret = __db_close(mdbp, txn, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-MpCyDX4N.i","-O2")
int __os_unlink(DB_ENV *dbenv___0 , char const   *path ) ;
int __dbenv_dbremove_pp(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , char const   *subdb ,
                        u_int32_t flags ) ;
static int __db_dbtxn_remove(DB *dbp___1 , DB_TXN *txn , char const   *name ) ;
static int __db_subdb_remove(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ) ;
int __dbenv_dbremove_pp(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , char const   *subdb ,
                        u_int32_t flags ) 
{ DB *dbp___1 ;
  int handle_check ;
  int ret ;
  int t_ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbenv___0->flags & 8192U)) {
    tmp___0 = __db_mi_open(dbenv___0, "DB_ENV->dbremove", 0);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB->remove", flags, 16777216U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 16777216U) {
    goto _L;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            return (ret);
          }
          txn_local = 1;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
          tmp___1 = __db_not_txn_env(dbenv___0);
          return (tmp___1);
        }
      }
      txn_local = 0;
    }
  }
  ret = db_create(& dbp___1, dbenv___0, 0U);
  if (ret != 0) {
    goto err;
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  handle_check = tmp___2;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_remove_int(dbp___1, txn, name, subdb, flags);
  if (txn_local) {
    dbp___1->handle_lock.off = 0U;
    dbp___1->lid = 0U;
  } else {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      dbp___1->lid = 0U;
    }
  }
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  err: 
  if (txn_local) {
    ret = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  }
  t_ret = __db_close(dbp___1, (DB_TXN *)((void *)0), 23U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_remove_pp(DB *dbp___1 , char const   *name , char const   *subdb , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (dbp___1->flags & 65536U) {
    ret = __db_mi_open(dbenv___0, "DB->remove", 1);
    return (ret);
  }
  ret = __db_fchk(dbenv___0, "DB->remove", flags, 0U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_check_txn(dbp___1, (DB_TXN *)((void *)0), 0U, 0);
  if (ret != 0) {
    return (ret);
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  handle_check = tmp___0;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, 0);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_remove(dbp___1, (DB_TXN *)((void *)0), name, subdb, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __db_remove(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                u_int32_t flags ) 
{ int ret ;
  int t_ret ;

  {
  ret = __db_remove_int(dbp___1, txn, name, subdb, flags);
  t_ret = __db_close(dbp___1, txn, 23U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_remove_int(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                    u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_LSN newlsn ;
  int ret ;
  char *real_name ;
  char *tmpname ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  tmpname = (char *)((void *)0);
  real_name = tmpname;
  if ((unsigned int )subdb != (unsigned int )((void *)0)) {
    ret = __db_subdb_remove(dbp___1, txn, name, subdb);
    goto err;
  }
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    ret = __db_dbtxn_remove(dbp___1, txn, name);
    goto err;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, name, 0U, (DB_FH **)((void *)0),
                     & real_name);
  if (ret != 0) {
    goto err;
  }
  if (flags & 4U) {
    ret = __db_backup_name(dbenv___0, (char const   *)real_name, (DB_TXN *)((void *)0),
                           & tmpname);
    if (ret == 0) {
      __os_unlink(dbenv___0, (char const   *)tmpname);
    }
  }
  ret = __fop_remove_setup(dbp___1, (DB_TXN *)((void *)0), (char const   *)real_name,
                           0U);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbp___1->db_am_remove != (unsigned int )((void *)0)) {
    ret = ((*(dbp___1->db_am_remove)))(dbp___1, (DB_TXN *)((void *)0), name, subdb,
                                       & newlsn);
    if (ret != 0) {
      goto err;
    }
  }
  if (dbp___1->flags & 32768U) {
    tmp = 16;
  } else {
    tmp = 0;
  }
  ret = __fop_remove(dbenv___0, (DB_TXN *)((void *)0), dbp___1->fileid, name, (enum __anonenum_APPNAME_39 )1,
                     (unsigned int )tmp);
  err: 
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  if ((unsigned int )tmpname != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)tmpname);
  }
  return (ret);
}
}
static int __db_subdb_remove(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ) 
{ DB *mdbp ;
  DB *sdbp ;
  int ret ;
  int t_ret ;

  {
  sdbp = (DB *)((void *)0);
  mdbp = sdbp;
  ret = db_create(& sdbp, dbp___1->dbenv, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_open(sdbp, txn, name, subdb, (enum __anonenum_DBTYPE_61 )5, 32768U, 0,
                  0U);
  if (ret != 0) {
    goto err;
  }
  switch ((int )sdbp->type) {
  case 1: ;
  case 3: 
  ret = __bam_reclaim(sdbp, txn);
  if (ret != 0) {
    goto err;
  }
  break;
  case 2: 
  ret = __ham_reclaim(sdbp, txn);
  if (ret != 0) {
    goto err;
  }
  break;
  case 4: ;
  case 5: ;
  default: 
  ret = __db_unknown_type(sdbp->dbenv, (char *)"__db_subdb_remove", sdbp->type);
  goto err;
  }
  ret = __db_master_open(sdbp, txn, name, 0U, 0, & mdbp);
  if (ret != 0) {
    goto err;
  }
  ret = __db_master_update(mdbp, sdbp, txn, subdb, sdbp->type, (enum __anonenum_mu_action_40 )0,
                           (char const   *)((void *)0), 0U);
  if (ret != 0) {
    goto err;
  }
  err: 
  t_ret = __db_close(sdbp, txn, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )mdbp != (unsigned int )((void *)0)) {
    t_ret = __db_close(mdbp, txn, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
static int __db_dbtxn_remove(DB *dbp___1 , DB_TXN *txn , char const   *name ) 
{ DB_ENV *dbenv___0 ;
  DB_LSN newlsn ;
  int ret ;
  char *tmpname ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  tmpname = (char *)((void *)0);
  ret = __db_backup_name(dbenv___0, name, txn, & tmpname);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_rename_int(dbp___1, txn, name, (char const   *)((void *)0), (char const   *)tmpname);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbp___1->db_am_remove != (unsigned int )((void *)0)) {
    ret = ((*(dbp___1->db_am_remove)))(dbp___1, txn, (char const   *)tmpname, (char const   *)((void *)0),
                                       & newlsn);
    if (ret != 0) {
      goto err;
    }
  }
  if (dbp___1->flags & 32768U) {
    tmp = 16;
  } else {
    tmp = 0;
  }
  ret = __fop_remove(dbenv___0, txn, dbp___1->fileid, (char const   *)tmpname, (enum __anonenum_APPNAME_39 )1,
                     (unsigned int )tmp);
  err: 
  if ((unsigned int )tmpname != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)tmpname);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-TpzognsR.i","-O2")
int __db_ret(DB *dbp___1 , PAGE *h , u_int32_t indx , DBT *dbt , void **memp , u_int32_t *memsize ) 
{ BKEYDATA *bk ;
  HOFFPAGE ho ;
  BOVERFLOW *bo ;
  u_int32_t len ;
  u_int8_t *hk ;
  void *data ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  u_int32_t tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  switch ((int )h->type) {
  case 2: ;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  hk = (u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___0) + indx));
  if ((int )(*hk) == 3) {
    memcpy((void * __restrict  )(& ho), (void const   * __restrict  )hk, sizeof(HOFFPAGE ));
    tmp___1 = __db_goff(dbp___1, dbt, ho.tlen, ho.pgno, memp, memsize);
    return (tmp___1);
  }
  if (indx == 0U) {
    tmp___4 = dbp___1->pgsize;
  } else {
    if (dbp___1->flags & 2048U) {
      tmp___6 = sizeof(PG_CRYPTO );
    } else {
      if (dbp___1->flags & 1U) {
        tmp___6 = sizeof(PG_CHKSUM );
      } else {
        tmp___6 = 0U;
      }
    }
    tmp___4 = (unsigned int )(*((db_indx_t *)(((u_int8_t *)h + 26) + tmp___6) + (indx -
                                                                                 1U)));
  }
  if (dbp___1->flags & 2048U) {
    tmp___8 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___8 = sizeof(PG_CHKSUM );
    } else {
      tmp___8 = 0U;
    }
  }
  len = (unsigned int )((unsigned short )((tmp___4 - (unsigned int )(*((db_indx_t *)(((u_int8_t *)h +
                                                                                      26) +
                                                                                     tmp___8) +
                                                                       indx))) - (unsigned int )((int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))))));
  data = (void *)(hk + (int )((unsigned short )((unsigned int )(& ((HKEYDATA *)0)->data[0]))));
  break;
  case 5: ;
  case 12: ;
  case 6: ;
  if (dbp___1->flags & 2048U) {
    tmp___10 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___10 = sizeof(PG_CHKSUM );
    } else {
      tmp___10 = 0U;
    }
  }
  bk = (BKEYDATA *)((u_int8_t *)h + (int )(*((db_indx_t *)(((u_int8_t *)h + 26) +
                                                           tmp___10) + indx)));
  if (((int )bk->type & -129) == 3) {
    bo = (BOVERFLOW *)bk;
    tmp___11 = __db_goff(dbp___1, dbt, bo->tlen, bo->pgno, memp, memsize);
    return (tmp___11);
  }
  len = (unsigned int )bk->len;
  data = (void *)(bk->data);
  break;
  default: 
  tmp___12 = __db_pgfmt(dbp___1->dbenv, h->pgno);
  return (tmp___12);
  }
  tmp___13 = __db_retcopy(dbp___1->dbenv, dbt, data, len, memp, memsize);
  return (tmp___13);
}
}
int __db_retcopy(DB_ENV *dbenv___0 , DBT *dbt , void *data , u_int32_t len , void **memp ,
                 u_int32_t *memsize ) 
{ int ret ;

  {
  ret = 0;
  if (dbt->flags & 8U) {
    data = (void *)((u_int8_t *)data + dbt->doff);
    if (len > dbt->doff) {
      len -= dbt->doff;
      if (len > dbt->dlen) {
        len = dbt->dlen;
      }
    } else {
      len = 0U;
    }
  }
  if (dbt->flags & 4U) {
    ret = __os_umalloc(dbenv___0, len, (void *)(& dbt->data));
  } else {
    if (dbt->flags & 16U) {
      if ((unsigned int )dbt->data == (unsigned int )((void *)0)) {
        ret = __os_urealloc(dbenv___0, len, (void *)(& dbt->data));
      } else {
        if (dbt->size == 0U) {
          ret = __os_urealloc(dbenv___0, len, (void *)(& dbt->data));
        } else {
          if (dbt->size < len) {
            ret = __os_urealloc(dbenv___0, len, (void *)(& dbt->data));
          }
        }
      }
    } else {
      if (dbt->flags & 32U) {
        if (len != 0U) {
          if ((unsigned int )dbt->data == (unsigned int )((void *)0)) {
            ret = 12;
          } else {
            if (dbt->ulen < len) {
              ret = 12;
            }
          }
        }
      } else {
        if ((unsigned int )memp == (unsigned int )((void *)0)) {
          ret = 22;
        } else {
          if ((unsigned int )memsize == (unsigned int )((void *)0)) {
            ret = 22;
          } else {
            if (len != 0U) {
              if ((*memsize) == 0U) {
                goto _L;
              } else {
                if ((*memsize) < len) {
                  _L: 
                  ret = __os_realloc(dbenv___0, len, (void *)memp);
                  if (ret == 0) {
                    (*memsize) = len;
                  } else {
                    (*memsize) = 0U;
                  }
                }
              }
            }
            if (ret == 0) {
              dbt->data = (*memp);
            }
          }
        }
      }
    }
  }
  if (ret == 0) {
    if (len != 0U) {
      memcpy((void * __restrict  )dbt->data, (void const   * __restrict  )data, len);
    }
  }
  dbt->size = len;
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-UEtaD7Bz.i","-O2")
void __db_shalloc_init(void *area , size_t size ) ;
int __db_shalloc_size(size_t len , size_t align ) ;
size_t __db_shsizeof(void *ptr ) ;
void __db_shalloc_dump(void *addr , FILE *fp ) ;
void __db_shalloc_init(void *area , size_t size ) 
{ struct __data *elp ;
  struct __head *hp ;
  int tmp ;

  {
  hp = (struct __head *)area;
  hp->slh_first = -1;
  elp = (struct __data *)(hp + 1);
  elp->len = (size - sizeof(struct __head )) - sizeof(elp->len);
  while (1) {
    if (hp->slh_first != -1) {
      elp->links.sle_next = hp->slh_first - ((u_int8_t *)elp - (u_int8_t *)hp);
      if (elp->links.sle_next == -1) {
        tmp = 0;
      } else {
        tmp = - elp->links.sle_next;
      }
      ((struct __data *)((u_int8_t *)hp + hp->slh_first))->links.sle_prev = tmp +
                                                                            ((u_int8_t *)(& elp->links.sle_next) -
                                                                             (u_int8_t *)elp);
    } else {
      elp->links.sle_next = -1;
    }
    hp->slh_first = (u_int8_t *)elp - (u_int8_t *)hp;
    elp->links.sle_prev = (u_int8_t *)(& hp->slh_first) - (u_int8_t *)elp;
    break;
  }
  return;
}
}
int __db_shalloc_size(size_t len , size_t align ) 
{ 

  {
  if (len < sizeof(struct __data )) {
    len = sizeof(struct __data );
  }
  if (align <= sizeof(db_align_t )) {
    align = sizeof(db_align_t );
  }
  return ((int )(((unsigned long long )((len + align) - 1U) & ~ ((unsigned long long )align -
                                                                 1ULL)) + (unsigned long long )sizeof(struct __data )));
}
}
int __db_shalloc(void *p , size_t len , size_t align , void *retp ) 
{ struct __data *elp ;
  size_t *sp ;
  void *rp ;

  {
  if (len < sizeof(struct __data )) {
    len = sizeof(struct __data );
  }
  if (align <= sizeof(db_align_t )) {
    align = sizeof(db_align_t );
  }
  if (((struct __head *)p)->slh_first == -1) {
    elp = (struct __data *)((void *)0);
  } else {
    elp = (struct __data *)((u_int8_t *)((struct __head *)p) + ((struct __head *)p)->slh_first);
  }
  while ((unsigned int )elp != (unsigned int )((void *)0)) {
    rp = (void *)(((u_int8_t *)elp + sizeof(size_t )) + elp->len);
    rp = (void *)((u_int8_t *)rp - len);
    rp = (void *)((u_int8_t *)((unsigned int )rp & ~ (align - 1U)));
    if ((unsigned int )((u_int8_t *)rp) < (unsigned int )((u_int8_t *)(& elp->links))) {
      goto __Cont;
    }
    (*((void **)retp)) = rp;
    if ((unsigned int )((u_int8_t *)rp) >= (unsigned int )((u_int8_t *)(& elp->links) +
                                                           32)) {
      sp = (size_t *)rp;
      sp --;
      (*sp) = elp->len - (unsigned int )((u_int8_t *)rp - (u_int8_t *)(& elp->links));
      elp->len -= (*sp) + sizeof(size_t );
      return (0);
    }
    while (1) {
      if (elp->links.sle_next != -1) {
        ((struct __data *)((u_int8_t *)elp + elp->links.sle_next))->links.sle_prev = elp->links.sle_prev -
                                                                                     elp->links.sle_next;
        (*((ssize_t *)((u_int8_t *)elp + elp->links.sle_prev))) = (*((ssize_t *)((u_int8_t *)elp +
                                                                                 elp->links.sle_prev))) +
                                                                  elp->links.sle_next;
      } else {
        (*((ssize_t *)((u_int8_t *)elp + elp->links.sle_prev))) = -1;
      }
      break;
    }
    sp = (size_t *)rp;
    while (1) {
      sp --;
      if (! ((unsigned int )((u_int8_t *)sp) >= (unsigned int )((u_int8_t *)(& elp->links)))) {
        break;
      }
      (*sp) = 1U;
    }
    return (0);
    __Cont: 
    if (elp->links.sle_next == -1) {
      elp = (struct __data *)((void *)0);
    } else {
      elp = (struct __data *)((u_int8_t *)elp + elp->links.sle_next);
    }
  }
  return (12);
}
}
void __db_shalloc_free(void *regionp , void *ptr ) 
{ struct __data *elp ;
  struct __data *lastp ;
  struct __data *newp ;
  struct __head *hp ;
  size_t free_size ;
  size_t *sp ;
  int merged ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  sp = (size_t *)ptr;
  while ((*(sp + -1)) == 1U) {
    sp --;
  }
  ptr = (void *)sp;
  newp = (struct __data *)((u_int8_t *)ptr - sizeof(size_t ));
  free_size = newp->len;
  hp = (struct __head *)regionp;
  if (hp->slh_first == -1) {
    elp = (struct __data *)((void *)0);
  } else {
    elp = (struct __data *)((u_int8_t *)hp + hp->slh_first);
  }
  lastp = (struct __data *)((void *)0);
  while (1) {
    if ((unsigned int )elp != (unsigned int )((void *)0)) {
      if (! ((unsigned int )((void *)elp) < (unsigned int )ptr)) {
        break;
      }
    } else {
      break;
    }
    lastp = elp;
    if (elp->links.sle_next == -1) {
      elp = (struct __data *)((void *)0);
    } else {
      elp = (struct __data *)((u_int8_t *)elp + elp->links.sle_next);
    }
  }
  merged = 0;
  if ((unsigned int )((u_int8_t *)ptr + free_size) == (unsigned int )((u_int8_t *)elp)) {
    newp->len += elp->len + sizeof(size_t );
    while (1) {
      if (elp->links.sle_next != -1) {
        ((struct __data *)((u_int8_t *)elp + elp->links.sle_next))->links.sle_prev = elp->links.sle_prev -
                                                                                     elp->links.sle_next;
        (*((ssize_t *)((u_int8_t *)elp + elp->links.sle_prev))) = (*((ssize_t *)((u_int8_t *)elp +
                                                                                 elp->links.sle_prev))) +
                                                                  elp->links.sle_next;
      } else {
        (*((ssize_t *)((u_int8_t *)elp + elp->links.sle_prev))) = -1;
      }
      break;
    }
    if ((unsigned int )lastp != (unsigned int )((void *)0)) {
      while (1) {
        if (lastp->links.sle_next != -1) {
          newp->links.sle_next = (u_int8_t *)((struct __data *)((u_int8_t *)lastp +
                                                                lastp->links.sle_next)) -
                                 (u_int8_t *)newp;
          if (newp->links.sle_next == -1) {
            tmp = 0;
          } else {
            tmp = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t *)lastp + lastp->links.sle_next))->links.sle_prev = tmp +
                                                                                           ((u_int8_t *)(& newp->links.sle_next) -
                                                                                            (u_int8_t *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        lastp->links.sle_next = (u_int8_t *)newp - (u_int8_t *)lastp;
        if (lastp->links.sle_next == -1) {
          tmp___0 = 0;
        } else {
          tmp___0 = - lastp->links.sle_next;
        }
        newp->links.sle_prev = tmp___0 + ((u_int8_t *)(& lastp->links.sle_next) -
                                          (u_int8_t *)lastp);
        break;
      }
    } else {
      while (1) {
        if (hp->slh_first != -1) {
          newp->links.sle_next = hp->slh_first - ((u_int8_t *)newp - (u_int8_t *)hp);
          if (newp->links.sle_next == -1) {
            tmp___1 = 0;
          } else {
            tmp___1 = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t *)hp + hp->slh_first))->links.sle_prev = tmp___1 +
                                                                                ((u_int8_t *)(& newp->links.sle_next) -
                                                                                 (u_int8_t *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        hp->slh_first = (u_int8_t *)newp - (u_int8_t *)hp;
        newp->links.sle_prev = (u_int8_t *)(& hp->slh_first) - (u_int8_t *)newp;
        break;
      }
    }
    merged = 1;
  }
  if ((unsigned int )lastp != (unsigned int )((void *)0)) {
    if ((unsigned int )(((u_int8_t *)lastp + lastp->len) + sizeof(size_t )) == (unsigned int )((u_int8_t *)newp)) {
      lastp->len += newp->len + sizeof(size_t );
      if (merged) {
        while (1) {
          if (newp->links.sle_next != -1) {
            ((struct __data *)((u_int8_t *)newp + newp->links.sle_next))->links.sle_prev = newp->links.sle_prev -
                                                                                           newp->links.sle_next;
            (*((ssize_t *)((u_int8_t *)newp + newp->links.sle_prev))) = (*((ssize_t *)((u_int8_t *)newp +
                                                                                       newp->links.sle_prev))) +
                                                                        newp->links.sle_next;
          } else {
            (*((ssize_t *)((u_int8_t *)newp + newp->links.sle_prev))) = -1;
          }
          break;
        }
      }
      merged = 1;
    }
  }
  if (! merged) {
    if ((unsigned int )lastp == (unsigned int )((void *)0)) {
      while (1) {
        if (hp->slh_first != -1) {
          newp->links.sle_next = hp->slh_first - ((u_int8_t *)newp - (u_int8_t *)hp);
          if (newp->links.sle_next == -1) {
            tmp___2 = 0;
          } else {
            tmp___2 = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t *)hp + hp->slh_first))->links.sle_prev = tmp___2 +
                                                                                ((u_int8_t *)(& newp->links.sle_next) -
                                                                                 (u_int8_t *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        hp->slh_first = (u_int8_t *)newp - (u_int8_t *)hp;
        newp->links.sle_prev = (u_int8_t *)(& hp->slh_first) - (u_int8_t *)newp;
        break;
      }
    } else {
      while (1) {
        if (lastp->links.sle_next != -1) {
          newp->links.sle_next = (u_int8_t *)((struct __data *)((u_int8_t *)lastp +
                                                                lastp->links.sle_next)) -
                                 (u_int8_t *)newp;
          if (newp->links.sle_next == -1) {
            tmp___3 = 0;
          } else {
            tmp___3 = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t *)lastp + lastp->links.sle_next))->links.sle_prev = tmp___3 +
                                                                                           ((u_int8_t *)(& newp->links.sle_next) -
                                                                                            (u_int8_t *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        lastp->links.sle_next = (u_int8_t *)newp - (u_int8_t *)lastp;
        if (lastp->links.sle_next == -1) {
          tmp___4 = 0;
        } else {
          tmp___4 = - lastp->links.sle_next;
        }
        newp->links.sle_prev = tmp___4 + ((u_int8_t *)(& lastp->links.sle_next) -
                                          (u_int8_t *)lastp);
        break;
      }
    }
  }
  return;
}
}
size_t __db_shsizeof(void *ptr ) 
{ struct __data *elp ;
  size_t *sp ;

  {
  sp = (size_t *)ptr;
  while ((*(sp + -1)) == 1U) {
    sp --;
  }
  elp = (struct __data *)((u_int8_t *)sp - sizeof(size_t ));
  return (elp->len);
}
}
void __db_shalloc_dump(void *addr , FILE *fp ) 
{ struct __data *elp ;

  {
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    fp = stderr;
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nMemory free list\n",
          "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
  if (((struct __head *)addr)->slh_first == -1) {
    elp = (struct __data *)((void *)0);
  } else {
    elp = (struct __data *)((u_int8_t *)((struct __head *)addr) + ((struct __head *)addr)->slh_first);
  }
  while ((unsigned int )elp != (unsigned int )((void *)0)) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%#lx: %lu\t", (unsigned long )((unsigned int )elp),
            (unsigned long )elp->len);
    if (elp->links.sle_next == -1) {
      elp = (struct __data *)((void *)0);
    } else {
      elp = (struct __data *)((u_int8_t *)elp + elp->links.sle_next);
    }
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  return;
}
}
#pragma merger(0,"/tmp/cil-OS82kIUF.i","-O2")
int __db_tablesize(u_int32_t n_buckets ) ;
void __db_hashinit(void *begin , u_int32_t nelements ) ;
static struct __anonstruct_list_53  const  list___0[39]  = 
  {      {32U, 37U}, 
        {64U, 67U}, 
        {128U, 131U}, 
        {256U, 257U}, 
        {512U, 521U}, 
        {1024U, 1031U}, 
        {2048U, 2053U}, 
        {4096U, 4099U}, 
        {8192U, 8191U}, 
        {16384U, 16381U}, 
        {32768U, 32771U}, 
        {65536U, 65537U}, 
        {131072U, 131071U}, 
        {262144U, 262147U}, 
        {393216U, 393209U}, 
        {524288U, 524287U}, 
        {786432U, 786431U}, 
        {1048576U, 1048573U}, 
        {1572864U, 1572869U}, 
        {2097152U, 2097169U}, 
        {3145728U, 3145721U}, 
        {4194304U, 4194301U}, 
        {6291456U, 6291449U}, 
        {8388608U, 8388617U}, 
        {12582912U, 12582917U}, 
        {16777216U, 16777213U}, 
        {25165824U, 25165813U}, 
        {33554432U, 33554393U}, 
        {50331648U, 50331653U}, 
        {67108864U, 67108859U}, 
        {100663296U, 100663291U}, 
        {134217728U, 134217757U}, 
        {201326592U, 201326611U}, 
        {268435456U, 268435459U}, 
        {402653184U, 402653189U}, 
        {536870912U, 536870909U}, 
        {805306368U, 805306357U}, 
        {1073741824U, 1073741827U}, 
        {0U, 0U}};
int __db_tablesize(u_int32_t n_buckets ) 
{ int i ;

  {
  if (n_buckets < 32U) {
    n_buckets = 32U;
  }
  i = 0;
  while (1) {
    if (list___0[i].power == 0U) {
      i --;
      break;
    }
    if (list___0[i].power >= n_buckets) {
      break;
    }
    i ++;
  }
  return ((int )list___0[i].prime);
}
}
void __db_hashinit(void *begin , u_int32_t nelements ) 
{ u_int32_t i ;
  struct hash_head *headp ;

  {
  headp = (struct hash_head *)begin;
  i = 0U;
  while (i < nelements) {
    headp->stqh_first = -1;
    headp->stqh_last = (u_int8_t *)(& headp->stqh_first) - (u_int8_t *)headp;
    i ++;
    headp ++;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-xpIGbVVJ.i","-O2")
static int __db_cursor_check(DB *dbp___1 ) ;
int __db_truncate_pp(DB *dbp___1 , DB_TXN *txn , u_int32_t *countp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int handle_check ;
  int ret ;
  int txn_local ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (dbp___1->flags & 33554432U) {
    if (! (flags & 34U)) {
      __db_err((DB_ENV const   *)dbenv___0, "DBP->truncate forbidden on secondary indices");
      return (22);
    }
  }
  flags &= 4294967261U;
  ret = __db_fchk(dbenv___0, "DB->truncate", flags, 16777216U);
  if (ret != 0) {
    return (ret);
  }
  tmp___0 = __db_cursor_check(dbp___1);
  if (tmp___0 != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "DB->truncate not permitted with active cursors");
    return (22);
  }
  txn_local = 0;
  if (flags & 16777216U) {
    goto _L;
  } else {
    if ((unsigned int )txn == (unsigned int )((void *)0)) {
      if (dbenv___0->flags & 1U) {
        if (! (flags & 67108864U)) {
          _L: 
          ret = __db_txn_auto_init(dbenv___0, & txn);
          if (ret != 0) {
            goto err;
          }
          txn_local = 1;
          flags &= 4278190079U;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
          ret = __db_not_txn_env(dbenv___0);
          return (ret);
        }
      }
    }
  }
  if (! (dbp___1->flags & 10485760U)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  handle_check = tmp___1;
  if (handle_check) {
    ret = __db_rep_enter(dbp___1, 1, (unsigned int )txn != (unsigned int )((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_truncate(dbp___1, txn, countp, flags);
  if (handle_check) {
    __db_rep_exit(dbenv___0);
  }
  err: 
  if (txn_local) {
    tmp___3 = __db_txn_auto_resolve(dbenv___0, txn, 0, ret);
  } else {
    tmp___3 = ret;
  }
  return (tmp___3);
}
}
int __db_truncate(DB *dbp___1 , DB_TXN *txn , u_int32_t *countp , u_int32_t flags ) 
{ DB *sdbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  u_int32_t scount ;
  int ret ;
  int t_ret ;

  {
  flags = 0U;
  flags = flags;
  dbenv___0 = dbp___1->dbenv;
  dbc = (DBC *)((void *)0);
  ret = 0;
  if ((int )dbp___1->type != 4) {
    if ((unsigned int )dbp___1->s_secondaries.lh_first != (unsigned int )((void *)0)) {
      sdbp = __db_s_first(dbp___1);
      while (1) {
        if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
          if (! (ret == 0)) {
            break;
          }
        } else {
          break;
        }
        ret = __db_truncate(sdbp, txn, & scount, 34U);
        if (ret != 0) {
          return (ret);
        }
        ret = __db_s_next(& sdbp);
      }
    }
  }
  ret = __db_cursor(dbp___1, txn, & dbc, 0U);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )dbp___1->type) {
  case 1: ;
  case 3: 
  ret = __bam_truncate(dbc, countp);
  break;
  case 2: 
  ret = __ham_truncate(dbc, countp);
  break;
  case 4: 
  ret = __qam_truncate(dbc, countp);
  break;
  case 5: ;
  default: 
  ret = __db_unknown_type(dbenv___0, (char *)"DB->truncate", dbp___1->type);
  break;
  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    t_ret = __db_c_close(dbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
static int __db_cursor_check(DB *dbp___1 ) 
{ DB *ldbp ;
  DBC *dbc ;
  DB_ENV *dbenv___0 ;
  int found ;

  {
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  found = 0;
  ldbp = __dblist_get(dbenv___0, dbp___1->adj_fileid);
  while (1) {
    if ((unsigned int )ldbp != (unsigned int )((void *)0)) {
      if (! (ldbp->adj_fileid == dbp___1->adj_fileid)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
      }
    }
    dbc = ldbp->active_queue.tqh_first;
    while ((unsigned int )dbc != (unsigned int )((void *)0)) {
      if ((dbc->internal)->pgno != 0U) {
        found = 1;
        break;
      }
      dbc = dbc->links.tqe_next;
    }
    if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbp___1->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
      }
    }
    if (found == 1) {
      break;
    }
    ldbp = ldbp->dblistlinks.le_next;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  return (found);
}
}
#pragma merger(0,"/tmp/cil-PeisWy2g.i","-O2")
int __os_ioinfo(DB_ENV *dbenv___0 , char const   *path , DB_FH *fhp , u_int32_t *mbytesp ,
                u_int32_t *bytesp , u_int32_t *iosizep ) ;
int __db_upgrade(DB *dbp___1 , char const   *fname , u_int32_t flags ) ;
static int (* const  func_31_list[13])(DB * , char * , u_int32_t  , DB_FH * , PAGE * ,
                                       int * )  = 
  {      (int (* const  )(DB * , char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))(& __ham_31_hash),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0), 
        (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))(& __bam_31_lbtree),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0), 
        (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))(& __ham_31_hashmeta),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))(& __bam_31_btreemeta),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0),      (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0), 
        (int (* const  )(DB * ,
                      char * , u_int32_t  , DB_FH * , PAGE * , int * ))((void *)0)};
static int __db_page_pass(DB *dbp___1 , char *real_name , u_int32_t flags , int (* const  *fl)(DB * ,
                                                                                               char * ,
                                                                                               u_int32_t  ,
                                                                                               DB_FH * ,
                                                                                               PAGE * ,
                                                                                               int * ) ,
                          DB_FH *fhp ) ;
int __db_upgrade_pp(DB *dbp___1 , char const   *fname , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  if (! ((dbp___1->dbenv)->flags & 4096U)) {
    if ((unsigned int )(dbp___1->dbenv)->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)(dbp___1->dbenv)->reginfo)->primary)->envpanic !=
          0) {
        tmp = __db_panic_msg(dbp___1->dbenv);
        return (tmp);
      }
    }
  }
  ret = __db_fchk(dbenv___0, "DB->upgrade", flags, 4U);
  if (ret != 0) {
    return (ret);
  }
  tmp___0 = __db_upgrade(dbp___1, fname, flags);
  return (tmp___0);
}
}
int __db_upgrade(DB *dbp___1 , char const   *fname , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  size_t n ;
  int ret ;
  int t_ret ;
  u_int8_t mbuf[256] ;
  char *real_name ;
  char *tmp ;
  u_int32_t _tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  fhp = (DB_FH *)((void *)0);
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, fname, 0U, (DB_FH **)((void *)0),
                     & real_name);
  if (ret != 0) {
    return (ret);
  }
  ret = __os_open(dbenv___0, (char const   *)real_name, 0U, 0, & fhp);
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", real_name, tmp);
    return (ret);
  }
  if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
    ((*(dbp___1->db_feedback)))(dbp___1, 1, 0);
  }
  ret = __os_read(dbenv___0, fhp, (void *)(mbuf), sizeof(mbuf), & n);
  if (ret != 0) {
    goto err;
  }
  switch ((int )((DBMETA *)(mbuf))->magic) {
  case 340322: ;
  switch ((int )((DBMETA *)(mbuf))->version) {
  case 6: 
  ret = __bam_30_btreemeta(dbp___1, real_name, mbuf);
  if (ret != 0) {
    goto err;
  }
  ret = __os_seek(dbenv___0, fhp, 0U, 0U, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  ret = __os_write(dbenv___0, fhp, (void *)(mbuf), 256U, & n);
  if (ret != 0) {
    goto err;
  }
  case 7: 
  memcpy((void * __restrict  )(& dbp___1->pgsize), (void const   * __restrict  )(mbuf +
                                                                                 20),
         sizeof(u_int32_t ));
  ret = __db_page_pass(dbp___1, real_name, flags, func_31_list, fhp);
  if (ret != 0) {
    goto err;
  }
  case 8: ;
  case 9: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unsupported btree version: %lu", real_name,
           (unsigned long )((DBMETA *)(mbuf))->version);
  ret = -30989;
  goto err;
  }
  break;
  case 398689: ;
  switch ((int )((DBMETA *)(mbuf))->version) {
  case 4: ;
  case 5: 
  ret = __ham_30_hashmeta(dbp___1, real_name, mbuf);
  if (ret != 0) {
    goto err;
  }
  ret = __os_seek(dbenv___0, fhp, 0U, 0U, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  ret = __os_write(dbenv___0, fhp, (void *)(mbuf), 256U, & n);
  if (ret != 0) {
    goto err;
  }
  ret = __ham_30_sizefix(dbp___1, fhp, real_name, mbuf);
  if (ret != 0) {
    goto err;
  }
  case 6: 
  memcpy((void * __restrict  )(& dbp___1->pgsize), (void const   * __restrict  )(mbuf +
                                                                                 20),
         sizeof(u_int32_t ));
  ret = __db_page_pass(dbp___1, real_name, flags, func_31_list, fhp);
  if (ret != 0) {
    goto err;
  }
  case 7: ;
  case 8: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unsupported hash version: %lu", real_name,
           (unsigned long )((DBMETA *)(mbuf))->version);
  ret = -30989;
  goto err;
  }
  break;
  case 270931: ;
  switch ((int )((DBMETA *)(mbuf))->version) {
  case 1: 
  ret = __qam_31_qammeta(dbp___1, real_name, mbuf);
  if (ret != 0) {
    return (ret);
  }
  case 2: 
  ret = __qam_32_qammeta(dbp___1, real_name, mbuf);
  if (ret != 0) {
    return (ret);
  }
  ret = __os_seek(dbenv___0, fhp, 0U, 0U, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  ret = __os_write(dbenv___0, fhp, (void *)(mbuf), 256U, & n);
  if (ret != 0) {
    goto err;
  }
  case 3: ;
  case 4: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unsupported queue version: %lu", real_name,
           (unsigned long )((DBMETA *)(mbuf))->version);
  ret = -30989;
  goto err;
  }
  break;
  default: 
  _tmp = ((DBMETA *)(mbuf))->magic;
  (*((u_int8_t *)(& ((DBMETA *)(mbuf))->magic) + 0)) = (*((u_int8_t *)(& _tmp) + 3));
  (*((u_int8_t *)(& ((DBMETA *)(mbuf))->magic) + 1)) = (*((u_int8_t *)(& _tmp) + 2));
  (*((u_int8_t *)(& ((DBMETA *)(mbuf))->magic) + 2)) = (*((u_int8_t *)(& _tmp) + 1));
  (*((u_int8_t *)(& ((DBMETA *)(mbuf))->magic) + 3)) = (*((u_int8_t *)(& _tmp) + 0));
  switch ((int )((DBMETA *)(mbuf))->magic) {
  case 340322: ;
  case 398689: ;
  case 270931: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: DB->upgrade only supported on native byte-order systems",
           real_name);
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: unrecognized file type", real_name);
  break;
  }
  ret = 22;
  goto err;
  }
  ret = __os_fsync(dbenv___0, fhp);
  err: 
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    t_ret = __os_closehandle(dbenv___0, fhp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  __os_free(dbenv___0, (void *)real_name);
  if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
    ((*(dbp___1->db_feedback)))(dbp___1, 1, 100);
  }
  return (ret);
}
}
static int __db_page_pass(DB *dbp___1 , char *real_name , u_int32_t flags , int (* const  *fl)(DB * ,
                                                                                               char * ,
                                                                                               u_int32_t  ,
                                                                                               DB_FH * ,
                                                                                               PAGE * ,
                                                                                               int * ) ,
                          DB_FH *fhp ) 
{ DB_ENV *dbenv___0 ;
  PAGE *page ;
  db_pgno_t i ;
  db_pgno_t pgno_last ;
  size_t n ;
  int dirty ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __db_lastpgno(dbp___1, real_name, fhp, & pgno_last);
  if (ret != 0) {
    return (ret);
  }
  ret = __os_malloc(dbenv___0, dbp___1->pgsize, (void *)(& page));
  if (ret != 0) {
    return (ret);
  }
  i = 0U;
  while (i < pgno_last) {
    if ((unsigned int )dbp___1->db_feedback != (unsigned int )((void *)0)) {
      ((*(dbp___1->db_feedback)))(dbp___1, 1, (int )((i * 100U) / pgno_last));
    }
    ret = __os_seek(dbenv___0, fhp, dbp___1->pgsize, i, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
    if (ret != 0) {
      break;
    }
    ret = __os_read(dbenv___0, fhp, (void *)page, dbp___1->pgsize, & n);
    if (ret != 0) {
      break;
    }
    dirty = 0;
    if ((unsigned int )(*(fl + (int )page->type)) != (unsigned int )((void *)0)) {
      ret = ((*((*(fl + (int )page->type)))))(dbp___1, real_name, flags, fhp, page,
                                              & dirty);
      if (ret != 0) {
        break;
      }
    }
    if (dirty) {
      ret = __os_seek(dbenv___0, fhp, dbp___1->pgsize, i, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
      if (ret != 0) {
        break;
      }
      ret = __os_write(dbenv___0, fhp, (void *)page, dbp___1->pgsize, & n);
      if (ret != 0) {
        break;
      }
    }
    i ++;
  }
  __os_free(dbp___1->dbenv, (void *)page);
  return (ret);
}
}
int __db_lastpgno(DB *dbp___1 , char *real_name , DB_FH *fhp , db_pgno_t *pgno_lastp ) 
{ DB_ENV *dbenv___0 ;
  db_pgno_t pgno_last ;
  u_int32_t mbytes ;
  u_int32_t bytes ;
  int ret ;
  char *tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __os_ioinfo(dbenv___0, (char const   *)real_name, fhp, & mbytes, & bytes,
                    (u_int32_t *)((void *)0));
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", real_name, tmp);
    return (ret);
  }
  if (bytes % dbp___1->pgsize != 0U) {
    __db_err((DB_ENV const   *)dbenv___0, "%s: file size not a multiple of the pagesize",
             real_name);
    return (22);
  }
  pgno_last = mbytes * (1048576U / dbp___1->pgsize);
  pgno_last += bytes / dbp___1->pgsize;
  (*pgno_lastp) = pgno_last;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-Gc8IQkVB.i","-O2")
static int __db_build_bi(DB *dbp___1 , DB_FH *fhp , PAGE *ipage , PAGE *page , u_int32_t indx ,
                         int *nomemp ) ;
static int __db_build_ri(DB *dbp___1 , DB_FH *fhp , PAGE *ipage , PAGE *page , u_int32_t indx ,
                         int *nomemp ) ;
static int __db_up_ovref(DB *dbp___1 , DB_FH *fhp , db_pgno_t pgno ) ;
int __db_31_offdup(DB *dbp___1 , char *real_name , DB_FH *fhp , int sorted , db_pgno_t *pgnop ) 
{ PAGE *ipage ;
  PAGE *page ;
  db_indx_t indx ;
  db_pgno_t cur_cnt ;
  db_pgno_t i ;
  db_pgno_t next_cnt ;
  db_pgno_t pgno ;
  db_pgno_t *pgno_cur ;
  db_pgno_t pgno_last ;
  db_pgno_t *pgno_next ;
  db_pgno_t pgno_max ;
  db_pgno_t *tmp ;
  db_recno_t nrecs ;
  size_t n ;
  int level ;
  int nomem ;
  int ret ;
  db_pgno_t tmp___0 ;
  db_pgno_t tmp___1 ;
  db_pgno_t tmp___2 ;

  {
  page = (PAGE *)((void *)0);
  ipage = page;
  pgno_next = (db_pgno_t *)((void *)0);
  pgno_cur = pgno_next;
  ret = __os_malloc(dbp___1->dbenv, dbp___1->pgsize, (void *)(& page));
  if (ret != 0) {
    goto err;
  }
  nrecs = 0U;
  pgno_max = 0U;
  cur_cnt = pgno_max;
  pgno = (*pgnop);
  while (pgno != 0U) {
    if (pgno_max == cur_cnt) {
      pgno_max += 20U;
      ret = __os_realloc(dbp___1->dbenv, pgno_max * sizeof(db_pgno_t ), (void *)(& pgno_cur));
      if (ret != 0) {
        goto err;
      }
    }
    tmp___0 = cur_cnt;
    cur_cnt ++;
    (*(pgno_cur + tmp___0)) = pgno;
    ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, pgno, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
    if (ret != 0) {
      goto err;
    }
    ret = __os_read(dbp___1->dbenv, fhp, (void *)page, dbp___1->pgsize, & n);
    if (ret != 0) {
      goto err;
    }
    nrecs += (unsigned int )page->entries;
    page->level = (unsigned char)1;
    if (sorted) {
      page->type = (unsigned char)12;
    } else {
      page->type = (unsigned char)6;
    }
    while (1) {
      page->lsn.file = 0U;
      page->lsn.offset = 0U;
      break;
    }
    ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, pgno, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
    if (ret != 0) {
      goto err;
    }
    ret = __os_write(dbp___1->dbenv, fhp, (void *)page, dbp___1->pgsize, & n);
    if (ret != 0) {
      goto err;
    }
    pgno = page->next_pgno;
  }
  if (cur_cnt > 1U) {
    ret = __os_malloc(dbp___1->dbenv, cur_cnt * sizeof(db_pgno_t ), (void *)(& pgno_next));
    if (ret != 0) {
      goto err;
    }
    ret = __db_lastpgno(dbp___1, real_name, fhp, & pgno_last);
    if (ret != 0) {
      goto err;
    }
    ret = __os_malloc(dbp___1->dbenv, dbp___1->pgsize, (void *)(& ipage));
    if (ret != 0) {
      goto err;
    }
    ipage->pgno = 0U;
  }
  level = 2;
  while (cur_cnt > 1U) {
    indx = (unsigned short)0;
    next_cnt = 0U;
    i = next_cnt;
    while (i < cur_cnt) {
      if ((int )indx == 0) {
        while (1) {
          ipage->pgno = pgno_last;
          ipage->prev_pgno = 0U;
          ipage->next_pgno = 0U;
          ipage->entries = (unsigned short)0;
          ipage->hf_offset = (unsigned short )dbp___1->pgsize;
          ipage->level = (unsigned char )level;
          if (sorted) {
            ipage->type = (unsigned char)3;
          } else {
            ipage->type = (unsigned char)4;
          }
          break;
        }
        while (1) {
          ipage->lsn.file = 0U;
          ipage->lsn.offset = 0U;
          break;
        }
        tmp___1 = next_cnt;
        next_cnt ++;
        tmp___2 = pgno_last;
        pgno_last ++;
        (*(pgno_next + tmp___1)) = tmp___2;
      }
      ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, (*(pgno_cur + i)), 0U,
                      0, (enum __anonenum_DB_OS_SEEK_52 )2);
      if (ret != 0) {
        goto err;
      }
      ret = __os_read(dbp___1->dbenv, fhp, (void *)page, dbp___1->pgsize, & n);
      if (ret != 0) {
        goto err;
      }
      nomem = 0;
      if (sorted) {
        ret = __db_build_bi(dbp___1, fhp, ipage, page, (unsigned int )indx, & nomem);
        if (ret != 0) {
          goto err;
        }
      } else {
        ret = __db_build_ri(dbp___1, fhp, ipage, page, (unsigned int )indx, & nomem);
        if (ret != 0) {
          goto err;
        }
      }
      if (nomem) {
        indx = (unsigned short)0;
        ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, ipage->pgno, 0U, 0,
                        (enum __anonenum_DB_OS_SEEK_52 )2);
        if (ret != 0) {
          goto err;
        }
        ret = __os_write(dbp___1->dbenv, fhp, (void *)ipage, dbp___1->pgsize, & n);
        if (ret != 0) {
          goto err;
        }
      } else {
        indx = (unsigned short )((int )indx + 1);
        ipage->entries = (unsigned short )((int )ipage->entries + 1);
        i ++;
      }
    }
    if (next_cnt == 1U) {
      ipage->prev_pgno = nrecs;
    }
    ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, ipage->pgno, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
    if (ret != 0) {
      goto err;
    }
    ret = __os_write(dbp___1->dbenv, fhp, (void *)ipage, dbp___1->pgsize, & n);
    if (ret != 0) {
      goto err;
    }
    cur_cnt = next_cnt;
    tmp = pgno_cur;
    pgno_cur = pgno_next;
    pgno_next = tmp;
    level ++;
  }
  (*pgnop) = (*(pgno_cur + 0));
  err: 
  if ((unsigned int )pgno_cur != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)pgno_cur);
  }
  if ((unsigned int )pgno_next != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)pgno_next);
  }
  if ((unsigned int )ipage != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)ipage);
  }
  if ((unsigned int )page != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)page);
  }
  return (ret);
}
}
static int __db_build_bi(DB *dbp___1 , DB_FH *fhp , PAGE *ipage , PAGE *page , u_int32_t indx ,
                         int *nomemp ) 
{ BINTERNAL bi ;
  BINTERNAL *child_bi ;
  BKEYDATA *child_bk ;
  u_int8_t *p ;
  int ret ;
  db_indx_t *inp ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;
  unsigned int tmp___6 ;
  unsigned int tmp___8 ;
  unsigned int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned int tmp___14 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)ipage + 26) + tmp___0);
  switch ((int )page->type) {
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  child_bi = (BINTERNAL *)((u_int8_t *)page + (int )(*((db_indx_t *)(((u_int8_t *)page +
                                                                      26) + tmp___2) +
                                                       0)));
  if (dbp___1->flags & 2048U) {
    tmp___4 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___4 = sizeof(PG_CHKSUM );
    } else {
      tmp___4 = 0U;
    }
  }
  if ((unsigned long long )((unsigned int )ipage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                26) +
                                                                                                                               tmp___4)))) +
                                                               (unsigned int )ipage->entries *
                                                               sizeof(db_indx_t ))) <
      ((unsigned long long )(((unsigned int )((int )child_bi->len + (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                              sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                             1ULL)) + (unsigned long long )sizeof(db_indx_t )) {
    (*nomemp) = 1;
    return (0);
  }
  ipage->hf_offset = (unsigned short )((unsigned long long )ipage->hf_offset - ((unsigned long long )(((unsigned int )((int )child_bi->len +
                                                                                                                       (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                                       sizeof(u_int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL)));
  (*(inp + indx)) = ipage->hf_offset;
  if (dbp___1->flags & 2048U) {
    tmp___6 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___6 = sizeof(PG_CHKSUM );
    } else {
      tmp___6 = 0U;
    }
  }
  p = (u_int8_t *)ipage + (int )(*((db_indx_t *)(((u_int8_t *)ipage + 26) + tmp___6) +
                                   indx));
  bi.len = child_bi->len;
  bi.type = child_bi->type;
  bi.pgno = page->pgno;
  bi.nrecs = __bam_total(dbp___1, page);
  memcpy((void * __restrict  )p, (void const   * __restrict  )(& bi), (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0]))));
  p += (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  memcpy((void * __restrict  )p, (void const   * __restrict  )(child_bi->data), (unsigned int )child_bi->len);
  if (((int )child_bi->type & -129) == 3) {
    ret = __db_up_ovref(dbp___1, fhp, ((BOVERFLOW *)(child_bi->data))->pgno);
    if (ret != 0) {
      return (ret);
    }
  }
  break;
  case 12: ;
  if (dbp___1->flags & 2048U) {
    tmp___8 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___8 = sizeof(PG_CHKSUM );
    } else {
      tmp___8 = 0U;
    }
  }
  child_bk = (BKEYDATA *)((u_int8_t *)page + (int )(*((db_indx_t *)(((u_int8_t *)page +
                                                                     26) + tmp___8) +
                                                      0)));
  switch ((int )child_bk->type & -129) {
  case 1: ;
  if (dbp___1->flags & 2048U) {
    tmp___10 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___10 = sizeof(PG_CHKSUM );
    } else {
      tmp___10 = 0U;
    }
  }
  if ((unsigned long long )((unsigned int )ipage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                26) +
                                                                                                                               tmp___10)))) +
                                                               (unsigned int )ipage->entries *
                                                               sizeof(db_indx_t ))) <
      ((unsigned long long )(((unsigned int )((int )child_bk->len + (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                              sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                             1ULL)) + (unsigned long long )sizeof(db_indx_t )) {
    (*nomemp) = 1;
    return (0);
  }
  ipage->hf_offset = (unsigned short )((unsigned long long )ipage->hf_offset - ((unsigned long long )(((unsigned int )((int )child_bk->len +
                                                                                                                       (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                                       sizeof(u_int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL)));
  (*(inp + indx)) = ipage->hf_offset;
  if (dbp___1->flags & 2048U) {
    tmp___12 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___12 = sizeof(PG_CHKSUM );
    } else {
      tmp___12 = 0U;
    }
  }
  p = (u_int8_t *)ipage + (int )(*((db_indx_t *)(((u_int8_t *)ipage + 26) + tmp___12) +
                                   indx));
  bi.len = child_bk->len;
  bi.type = child_bk->type;
  bi.pgno = page->pgno;
  bi.nrecs = __bam_total(dbp___1, page);
  memcpy((void * __restrict  )p, (void const   * __restrict  )(& bi), (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0]))));
  p += (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  memcpy((void * __restrict  )p, (void const   * __restrict  )(child_bk->data), (unsigned int )child_bk->len);
  break;
  case 3: ;
  if (dbp___1->flags & 2048U) {
    tmp___14 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___14 = sizeof(PG_CHKSUM );
    } else {
      tmp___14 = 0U;
    }
  }
  if ((unsigned long long )((unsigned int )ipage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                26) +
                                                                                                                               tmp___14)))) +
                                                               (unsigned int )ipage->entries *
                                                               sizeof(db_indx_t ))) <
      ((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                              sizeof(u_int32_t )) -
                                                                                             1U) &
                                                                       ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                          1ULL))) +
                                              (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                              sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                             1ULL)) + (unsigned long long )sizeof(db_indx_t )) {
    (*nomemp) = 1;
    return (0);
  }
  ipage->hf_offset = (unsigned short )((unsigned long long )ipage->hf_offset - ((unsigned long long )(((unsigned int )((int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                                                                       sizeof(u_int32_t )) -
                                                                                                                                                                      1U) &
                                                                                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                                                                                   1ULL))) +
                                                                                                                       (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])))) +
                                                                                                       sizeof(u_int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL)));
  (*(inp + indx)) = ipage->hf_offset;
  if (dbp___1->flags & 2048U) {
    tmp___16 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___16 = sizeof(PG_CHKSUM );
    } else {
      tmp___16 = 0U;
    }
  }
  p = (u_int8_t *)ipage + (int )(*((db_indx_t *)(((u_int8_t *)ipage + 26) + tmp___16) +
                                   indx));
  bi.len = (unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) + sizeof(u_int32_t )) -
                                                   1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                            1ULL));
  bi.type = child_bk->type;
  bi.pgno = page->pgno;
  bi.nrecs = __bam_total(dbp___1, page);
  memcpy((void * __restrict  )p, (void const   * __restrict  )(& bi), (unsigned int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0]))));
  p += (int )((unsigned short )((unsigned int )(& ((BINTERNAL *)0)->data[0])));
  memcpy((void * __restrict  )p, (void const   * __restrict  )child_bk, (unsigned int )((unsigned short )((unsigned long long )((sizeof(BOVERFLOW ) +
                                                                                                                                 sizeof(u_int32_t )) -
                                                                                                                                1U) &
                                                                                                          ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                                             1ULL))));
  ret = __db_up_ovref(dbp___1, fhp, ((BOVERFLOW *)child_bk)->pgno);
  if (ret != 0) {
    return (ret);
  }
  break;
  default: 
  tmp___17 = __db_pgfmt(dbp___1->dbenv, page->pgno);
  return (tmp___17);
  }
  break;
  default: 
  tmp___18 = __db_pgfmt(dbp___1->dbenv, page->pgno);
  return (tmp___18);
  }
  return (0);
}
}
static int __db_build_ri(DB *dbp___1 , DB_FH *fhp , PAGE *ipage , PAGE *page , u_int32_t indx ,
                         int *nomemp ) 
{ RINTERNAL ri ;
  db_indx_t *inp ;
  unsigned int tmp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___4 ;

  {
  fhp = (DB_FH *)((void *)0);
  fhp = fhp;
  if (dbp___1->flags & 2048U) {
    tmp___0 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___0 = sizeof(PG_CHKSUM );
    } else {
      tmp___0 = 0U;
    }
  }
  inp = (db_indx_t *)(((u_int8_t *)ipage + 26) + tmp___0);
  if (dbp___1->flags & 2048U) {
    tmp___2 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___2 = sizeof(PG_CHKSUM );
    } else {
      tmp___2 = 0U;
    }
  }
  if ((unsigned long long )((unsigned int )ipage->hf_offset - ((unsigned int )((unsigned short )((unsigned int )((db_indx_t *)(((u_int8_t *)0 +
                                                                                                                                26) +
                                                                                                                               tmp___2)))) +
                                                               (unsigned int )ipage->entries *
                                                               sizeof(db_indx_t ))) <
      ((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                  1ULL)) +
      (unsigned long long )sizeof(db_indx_t )) {
    (*nomemp) = 1;
    return (0);
  }
  ri.pgno = page->pgno;
  ri.nrecs = __bam_total(dbp___1, page);
  ipage->hf_offset = (unsigned short )((unsigned long long )ipage->hf_offset - ((unsigned long long )((sizeof(RINTERNAL ) +
                                                                                                       sizeof(u_int32_t )) -
                                                                                                      1U) &
                                                                                ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL)));
  (*(inp + indx)) = ipage->hf_offset;
  if (dbp___1->flags & 2048U) {
    tmp___4 = sizeof(PG_CRYPTO );
  } else {
    if (dbp___1->flags & 1U) {
      tmp___4 = sizeof(PG_CHKSUM );
    } else {
      tmp___4 = 0U;
    }
  }
  memcpy((void * __restrict  )((u_int8_t *)ipage + (int )(*((db_indx_t *)(((u_int8_t *)ipage +
                                                                           26) + tmp___4) +
                                                            indx))), (void const   * __restrict  )(& ri),
         (unsigned int )((unsigned long long )((sizeof(RINTERNAL ) + sizeof(u_int32_t )) -
                                               1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                        1ULL)));
  return (0);
}
}
static int __db_up_ovref(DB *dbp___1 , DB_FH *fhp , db_pgno_t pgno ) 
{ PAGE *page ;
  size_t n ;
  int ret ;

  {
  ret = __os_malloc(dbp___1->dbenv, dbp___1->pgsize, (void *)(& page));
  if (ret != 0) {
    return (ret);
  }
  ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, pgno, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  ret = __os_read(dbp___1->dbenv, fhp, (void *)page, dbp___1->pgsize, & n);
  if (ret != 0) {
    goto err;
  }
  page->entries = (unsigned short )((int )page->entries + 1);
  ret = __os_seek(dbp___1->dbenv, fhp, dbp___1->pgsize, pgno, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  ret = __os_write(dbp___1->dbenv, fhp, (void *)page, dbp___1->pgsize, & n);
  if (ret != 0) {
    goto err;
  }
  err: 
  __os_free(dbp___1->dbenv, (void *)page);
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-mm8dwmld.i","-O2")
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
int __db_ndbm_clearerr(DBM *dbm ) ;
void __db_ndbm_close(DBM *dbm ) ;
int __db_ndbm_delete(DBM *dbm , datum key ) ;
int __db_ndbm_dirfno(DBM *dbm ) ;
int __db_ndbm_error(DBM *dbm ) ;
datum __db_ndbm_fetch(DBM *dbm , datum key ) ;
datum __db_ndbm_firstkey(DBM *dbm ) ;
datum __db_ndbm_nextkey(DBM *dbm ) ;
DBM *__db_ndbm_open(char const   *file , int oflags , int mode ) ;
int __db_ndbm_pagfno(DBM *dbm ) ;
int __db_ndbm_rdonly(DBM *dbm ) ;
int __db_ndbm_store(DBM *dbm , datum key , datum data , int flags ) ;
int __db_dbm_close(void) ;
int __db_dbm_delete(datum key ) ;
datum __db_dbm_fetch(datum key ) ;
datum __db_dbm_firstkey(void) ;
int __db_dbm_init(char *file ) ;
datum __db_dbm_nextkey(datum key ) ;
int __db_dbm_store(datum key , datum dat ) ;
u_int32_t __db_oflags(int oflags ) ;
static DBM *__cur_db  ;
static void __db_no_open(void) ;
int __db_dbm_init(char *file ) 
{ int tmp ;

  {
  if ((unsigned int )__cur_db != (unsigned int )((void *)0)) {
    __db_ndbm_close(__cur_db);
  }
  tmp = __db_omode("rw----");
  __cur_db = __db_ndbm_open((char const   *)file, 66, tmp);
  if ((unsigned int )__cur_db != (unsigned int )((void *)0)) {
    return (0);
  }
  __cur_db = __db_ndbm_open((char const   *)file, 0, 0);
  if ((unsigned int )__cur_db != (unsigned int )((void *)0)) {
    return (0);
  }
  return (-1);
}
}
int __db_dbm_close(void) 
{ 

  {
  if ((unsigned int )__cur_db != (unsigned int )((void *)0)) {
    __db_ndbm_close(__cur_db);
    __cur_db = (DBM *)((void *)0);
  }
  return (0);
}
}
datum __db_dbm_fetch(datum key ) 
{ datum item ;
  datum tmp ;

  {
  if ((unsigned int )__cur_db == (unsigned int )((void *)0)) {
    __db_no_open();
    item.dptr = (char *)0;
    return (item);
  }
  tmp = __db_ndbm_fetch(__cur_db, key);
  return (tmp);
}
}
datum __db_dbm_firstkey(void) 
{ datum item ;
  datum tmp ;

  {
  if ((unsigned int )__cur_db == (unsigned int )((void *)0)) {
    __db_no_open();
    item.dptr = (char *)0;
    return (item);
  }
  tmp = __db_ndbm_firstkey(__cur_db);
  return (tmp);
}
}
datum __db_dbm_nextkey(datum key ) 
{ datum item ;
  datum tmp ;

  {
  key.dsize = 0;
  key.dsize = key.dsize;
  if ((unsigned int )__cur_db == (unsigned int )((void *)0)) {
    __db_no_open();
    item.dptr = (char *)0;
    return (item);
  }
  tmp = __db_ndbm_nextkey(__cur_db);
  return (tmp);
}
}
int __db_dbm_delete(datum key ) 
{ int tmp ;

  {
  if ((unsigned int )__cur_db == (unsigned int )((void *)0)) {
    __db_no_open();
    return (-1);
  }
  tmp = __db_ndbm_delete(__cur_db, key);
  return (tmp);
}
}
int __db_dbm_store(datum key , datum dat ) 
{ int tmp ;

  {
  if ((unsigned int )__cur_db == (unsigned int )((void *)0)) {
    __db_no_open();
    return (-1);
  }
  tmp = __db_ndbm_store(__cur_db, key, dat, 1);
  return (tmp);
}
}
static void __db_no_open(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dbm: no open database.\n");
  return;
}
}
DBM *__db_ndbm_open(char const   *file , int oflags , int mode ) 
{ DB *dbp___1 ;
  DBC *dbc ;
  int ret ;
  char path[1024] ;
  size_t tmp ;
  size_t tmp___0 ;
  u_int32_t tmp___1 ;

  {
  tmp = strlen(file);
  tmp___0 = strlen(".db");
  if ((tmp + tmp___0) + 1U > sizeof(path)) {
    __os_set_errno(36);
    return ((DBM *)((void *)0));
  }
  strcpy((char * __restrict  )(path), (char const   * __restrict  )file);
  strcat((char * __restrict  )(path), (char const   * __restrict  )".db");
  ret = db_create(& dbp___1, (DB_ENV *)((void *)0), 0U);
  if (ret != 0) {
    __os_set_errno(ret);
    return ((DBM *)((void *)0));
  }
  if (oflags & 1) {
    oflags &= -2;
    oflags |= 2;
  }
  ret = ((*(dbp___1->set_pagesize)))(dbp___1, 4096U);
  if (ret != 0) {
    __os_set_errno(ret);
    return ((DBM *)((void *)0));
  } else {
    ret = ((*(dbp___1->set_h_ffactor)))(dbp___1, 40U);
    if (ret != 0) {
      __os_set_errno(ret);
      return ((DBM *)((void *)0));
    } else {
      ret = ((*(dbp___1->set_h_nelem)))(dbp___1, 1U);
      if (ret != 0) {
        __os_set_errno(ret);
        return ((DBM *)((void *)0));
      } else {
        tmp___1 = __db_oflags(oflags);
        ret = ((*(dbp___1->open)))(dbp___1, (DB_TXN *)((void *)0), (char const   *)(path),
                                   (char const   *)((void *)0), (enum __anonenum_DBTYPE_61 )2,
                                   tmp___1, mode);
        if (ret != 0) {
          __os_set_errno(ret);
          return ((DBM *)((void *)0));
        }
      }
    }
  }
  ret = ((*(dbp___1->cursor)))(dbp___1, (DB_TXN *)((void *)0), & dbc, 0U);
  if (ret != 0) {
    ((*(dbp___1->close)))(dbp___1, 0U);
    __os_set_errno(ret);
    return ((DBM *)((void *)0));
  }
  return ((DBM *)dbc);
}
}
void __db_ndbm_close(DBM *dbm ) 
{ DBC *dbc ;

  {
  dbc = (DBC *)dbm;
  ((*((dbc->dbp)->close)))(dbc->dbp, 0U);
  return;
}
}
datum __db_ndbm_fetch(DBM *dbm , datum key ) 
{ DBC *dbc ;
  DBT _key ;
  DBT _data ;
  datum data ;
  int ret ;

  {
  dbc = (DBC *)dbm;
  memset((void *)(& _key), 0, sizeof(DBT ));
  memset((void *)(& _data), 0, sizeof(DBT ));
  _key.size = (unsigned int )key.dsize;
  _key.data = (void *)key.dptr;
  ret = ((*((dbc->dbp)->get)))(dbc->dbp, (DB_TXN *)((void *)0), & _key, & _data, 0U);
  if (ret == 0) {
    data.dptr = (char *)_data.data;
    data.dsize = (int )_data.size;
  } else {
    data.dptr = (char *)((void *)0);
    data.dsize = 0;
    if (ret == -30990) {
      __os_set_errno(2);
    } else {
      __os_set_errno(ret);
      (dbc->dbp)->flags = (dbc->dbp)->flags | 32U;
    }
  }
  return (data);
}
}
datum __db_ndbm_firstkey(DBM *dbm ) 
{ DBC *dbc ;
  DBT _key ;
  DBT _data ;
  datum key ;
  int ret ;

  {
  dbc = (DBC *)dbm;
  memset((void *)(& _key), 0, sizeof(DBT ));
  memset((void *)(& _data), 0, sizeof(DBT ));
  ret = ((*(dbc->c_get)))(dbc, & _key, & _data, 9U);
  if (ret == 0) {
    key.dptr = (char *)_key.data;
    key.dsize = (int )_key.size;
  } else {
    key.dptr = (char *)((void *)0);
    key.dsize = 0;
    if (ret == -30990) {
      __os_set_errno(2);
    } else {
      __os_set_errno(ret);
      (dbc->dbp)->flags = (dbc->dbp)->flags | 32U;
    }
  }
  return (key);
}
}
datum __db_ndbm_nextkey(DBM *dbm ) 
{ DBC *dbc ;
  DBT _key ;
  DBT _data ;
  datum key ;
  int ret ;

  {
  dbc = (DBC *)dbm;
  memset((void *)(& _key), 0, sizeof(DBT ));
  memset((void *)(& _data), 0, sizeof(DBT ));
  ret = ((*(dbc->c_get)))(dbc, & _key, & _data, 18U);
  if (ret == 0) {
    key.dptr = (char *)_key.data;
    key.dsize = (int )_key.size;
  } else {
    key.dptr = (char *)((void *)0);
    key.dsize = 0;
    if (ret == -30990) {
      __os_set_errno(2);
    } else {
      __os_set_errno(ret);
      (dbc->dbp)->flags = (dbc->dbp)->flags | 32U;
    }
  }
  return (key);
}
}
int __db_ndbm_delete(DBM *dbm , datum key ) 
{ DBC *dbc ;
  DBT _key ;
  int ret ;

  {
  dbc = (DBC *)dbm;
  memset((void *)(& _key), 0, sizeof(DBT ));
  _key.data = (void *)key.dptr;
  _key.size = (unsigned int )key.dsize;
  ret = ((*((dbc->dbp)->del)))(dbc->dbp, (DB_TXN *)((void *)0), & _key, 0U);
  if (ret == 0) {
    return (0);
  }
  if (ret == -30990) {
    __os_set_errno(2);
  } else {
    __os_set_errno(ret);
    (dbc->dbp)->flags = (dbc->dbp)->flags | 32U;
  }
  return (-1);
}
}
int __db_ndbm_store(DBM *dbm , datum key , datum data , int flags ) 
{ DBC *dbc ;
  DBT _key ;
  DBT _data ;
  int ret ;
  int tmp ;

  {
  dbc = (DBC *)dbm;
  memset((void *)(& _key), 0, sizeof(DBT ));
  _key.data = (void *)key.dptr;
  _key.size = (unsigned int )key.dsize;
  memset((void *)(& _data), 0, sizeof(DBT ));
  _data.data = (void *)data.dptr;
  _data.size = (unsigned int )data.dsize;
  if (flags == 0) {
    tmp = 22;
  } else {
    tmp = 0;
  }
  ret = ((*((dbc->dbp)->put)))(dbc->dbp, (DB_TXN *)((void *)0), & _key, & _data, (unsigned int )tmp);
  if (ret == 0) {
    return (0);
  }
  if (ret == -30996) {
    return (1);
  }
  __os_set_errno(ret);
  (dbc->dbp)->flags = (dbc->dbp)->flags | 32U;
  return (-1);
}
}
int __db_ndbm_error(DBM *dbm ) 
{ DBC *dbc ;

  {
  dbc = (DBC *)dbm;
  return ((int )((dbc->dbp)->flags & 32U));
}
}
int __db_ndbm_clearerr(DBM *dbm ) 
{ DBC *dbc ;

  {
  dbc = (DBC *)dbm;
  (dbc->dbp)->flags = (dbc->dbp)->flags & 4294967263U;
  return (0);
}
}
int __db_ndbm_rdonly(DBM *dbm ) 
{ DBC *dbc ;
  int tmp ;

  {
  dbc = (DBC *)dbm;
  if ((dbc->dbp)->flags & 524288U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int __db_ndbm_dirfno(DBM *dbm ) 
{ int tmp ;

  {
  tmp = __db_ndbm_pagfno(dbm);
  return (tmp);
}
}
int __db_ndbm_pagfno(DBM *dbm ) 
{ DBC *dbc ;
  int fd ;

  {
  dbc = (DBC *)dbm;
  ((*((dbc->dbp)->fd)))(dbc->dbp, & fd);
  return (fd);
}
}
#pragma merger(0,"/tmp/cil-PW5pc9xr.i","-O2")
int __dbreg_get_id(DB *dbp___1 , DB_TXN *txn , int32_t *idp ) ;
int __dbreg_assign_id(DB *dbp___1 , int32_t id ) ;
int __dbreg_register_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                         u_int32_t opcode , DBT const   *name , DBT const   *uid ,
                         int32_t fileid , DBTYPE ftype , db_pgno_t meta_pgno , u_int32_t id ) ;
int __dbreg_add_dbentry(DB_ENV *dbenv___0 , DB_LOG *dblp , DB *dbp___1 , int32_t ndx ) ;
void __dbreg_rem_dbentry(DB_LOG *dblp , int32_t ndx ) ;
int __dbreg_id_to_db_int(DB_ENV *dbenv___0 , DB_TXN *txn , DB **dbpp , int32_t ndx ,
                         int inc , int tryopen ) ;
int __dbreg_push_id(DB_ENV *dbenv___0 , int32_t id ) ;
int __dbreg_pop_id(DB_ENV *dbenv___0 , int32_t *id ) ;
int __dbreg_pluck_id(DB_ENV *dbenv___0 , int32_t id ) ;
int __dbreg_setup(DB *dbp___1 , char const   *name , u_int32_t create_txnid ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  FNAME *fnp ;
  int ret ;
  size_t len ;
  void *namep ;
  size_t tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  fnp = (FNAME *)((void *)0);
  namep = (void *)0;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  ret = __db_shalloc(dblp->reginfo.addr, sizeof(FNAME ), 0U, (void *)(& fnp));
  if (ret != 0) {
    goto err;
  }
  memset((void *)fnp, 0, sizeof(FNAME ));
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    tmp = strlen(name);
    len = tmp + 1U;
    ret = __db_shalloc(dblp->reginfo.addr, len, 0U, (void *)(& namep));
    if (ret != 0) {
      goto err;
    }
    fnp->name_off = (unsigned int )((u_int8_t *)namep - (u_int8_t *)dblp->reginfo.addr);
    memcpy((void * __restrict  )namep, (void const   * __restrict  )name, len);
  } else {
    fnp->name_off = 0U;
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  fnp->id = -1;
  fnp->s_type = dbp___1->type;
  memcpy((void * __restrict  )(fnp->ufid), (void const   * __restrict  )(dbp___1->fileid),
         20U);
  fnp->meta_pgno = dbp___1->meta_pgno;
  fnp->create_txnid = create_txnid;
  dbp___1->log_filename = fnp;
  return (0);
  err: 
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (ret == 12) {
    __db_err((DB_ENV const   *)dbenv___0, "Logging region out of memory; you may need to increase its size");
  }
  return (ret);
}
}
int __dbreg_teardown(DB *dbp___1 ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  FNAME *fnp ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  fnp = dbp___1->log_filename;
  if ((unsigned int )fnp == (unsigned int )((void *)0)) {
    return (0);
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (fnp->name_off != 0U) {
    __db_shalloc_free(dblp->reginfo.addr, (void *)((u_int8_t *)dblp->reginfo.addr +
                                                   fnp->name_off));
  }
  __db_shalloc_free(dblp->reginfo.addr, (void *)fnp);
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  dbp___1->log_filename = (FNAME *)((void *)0);
  return (0);
}
}
int __dbreg_new_id(DB *dbp___1 , DB_TXN *txn ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  FNAME *fnp ;
  LOG *lp ;
  int32_t id ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  fnp = dbp___1->log_filename;
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
  }
  if (fnp->id != -1) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
    }
    return (0);
  }
  ret = __dbreg_get_id(dbp___1, txn, & id);
  if (ret == 0) {
    fnp->id = id;
  }
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
  }
  return (ret);
}
}
int __dbreg_get_id(DB *dbp___1 , DB_TXN *txn , int32_t *idp ) 
{ DBT fid_dbt ;
  DBT r_name ;
  DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  DB_LSN unused ;
  FNAME *fnp ;
  LOG *lp ;
  int32_t id ;
  int ret ;
  int32_t tmp ;
  size_t tmp___0 ;
  DBT *tmp___1 ;
  int tmp___2 ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  fnp = dbp___1->log_filename;
  ret = __dbreg_pop_id(dbenv___0, & id);
  if (ret != 0) {
    goto err;
  }
  if (id == -1) {
    tmp = lp->fid_max;
    lp->fid_max = lp->fid_max + 1;
    id = tmp;
  }
  fnp->is_durable = (! (dbp___1->flags & 32768U) != 0) != 0;
  while (1) {
    if (lp->fq.stqh_first != -1) {
      fnp->q.stqe_next = lp->fq.stqh_first - ((u_int8_t *)fnp - (u_int8_t *)(& lp->fq));
      if (fnp->q.stqe_next == -1) {
        ((struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first))->q.stqe_prev = 0;
      } else {
        ((struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first))->q.stqe_prev = - fnp->q.stqe_next +
                                                                                        ((u_int8_t *)(& fnp->q.stqe_next) -
                                                                                         (u_int8_t *)fnp);
      }
    } else {
      lp->fq.stqh_last = (u_int8_t *)(& fnp->q.stqe_next) - (u_int8_t *)(& lp->fq);
      fnp->q.stqe_next = -1;
    }
    lp->fq.stqh_first = (u_int8_t *)fnp - (u_int8_t *)(& lp->fq);
    fnp->q.stqe_prev = (u_int8_t *)(& lp->fq.stqh_first) - (u_int8_t *)fnp;
    break;
  }
  memset((void *)(& fid_dbt), 0, sizeof(fid_dbt));
  memset((void *)(& r_name), 0, sizeof(r_name));
  if (fnp->name_off != 0U) {
    r_name.data = (void *)((u_int8_t *)dblp->reginfo.addr + fnp->name_off);
    tmp___0 = strlen((char const   *)((char *)r_name.data));
    r_name.size = tmp___0 + 1U;
  }
  fid_dbt.data = (void *)(dbp___1->fileid);
  fid_dbt.size = 20U;
  if (r_name.size == 0U) {
    tmp___1 = (DBT *)((void *)0);
  } else {
    tmp___1 = & r_name;
  }
  if (dbp___1->flags & 32768U) {
    tmp___2 = 16;
  } else {
    tmp___2 = 0;
  }
  ret = __dbreg_register_log(dbenv___0, txn, & unused, (unsigned int )tmp___2, 3U,
                             (DBT const   *)tmp___1, (DBT const   *)(& fid_dbt), id,
                             fnp->s_type, fnp->meta_pgno, fnp->create_txnid);
  if (ret != 0) {
    goto err;
  }
  fnp->create_txnid = 0U;
  ret = __dbreg_add_dbentry(dbenv___0, dblp, dbp___1, id);
  if (ret != 0) {
    goto err;
  }
  err: 
  if (ret != 0) {
    if (id != -1) {
      __dbreg_revoke_id(dbp___1, 1, id);
      id = -1;
    }
  }
  (*idp) = id;
  return (ret);
}
}
int __dbreg_assign_id(DB *dbp___1 , int32_t id ) 
{ DB *close_dbp ;
  DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  FNAME *close_fnp ;
  FNAME *fnp ;
  LOG *lp ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  fnp = dbp___1->log_filename;
  close_dbp = (DB *)((void *)0);
  close_fnp = (FNAME *)((void *)0);
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
  }
  tmp = __dbreg_id_to_fname(dblp, id, 1, & close_fnp);
  if (tmp == 0) {
    ret = __dbreg_id_to_db_int(dbenv___0, (DB_TXN *)((void *)0), & close_dbp, id,
                               0, 0);
    if (ret == 2) {
      ret = 0;
      goto cont;
    } else {
      if (ret != 0) {
        goto err;
      }
    }
    ret = __dbreg_revoke_id(close_dbp, 1, -1);
    if (ret != 0) {
      goto err;
    }
  }
  cont: 
  ret = __dbreg_pluck_id(dbenv___0, id);
  if (ret != 0) {
    goto err;
  }
  if (id >= lp->fid_max) {
    lp->fid_max = id + 1;
  }
  fnp->id = id;
  fnp->is_durable = (! (dbp___1->flags & 32768U) != 0) != 0;
  while (1) {
    if (lp->fq.stqh_first != -1) {
      fnp->q.stqe_next = lp->fq.stqh_first - ((u_int8_t *)fnp - (u_int8_t *)(& lp->fq));
      if (fnp->q.stqe_next == -1) {
        ((struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first))->q.stqe_prev = 0;
      } else {
        ((struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first))->q.stqe_prev = - fnp->q.stqe_next +
                                                                                        ((u_int8_t *)(& fnp->q.stqe_next) -
                                                                                         (u_int8_t *)fnp);
      }
    } else {
      lp->fq.stqh_last = (u_int8_t *)(& fnp->q.stqe_next) - (u_int8_t *)(& lp->fq);
      fnp->q.stqe_next = -1;
    }
    lp->fq.stqh_first = (u_int8_t *)fnp - (u_int8_t *)(& lp->fq);
    fnp->q.stqe_prev = (u_int8_t *)(& lp->fq.stqh_first) - (u_int8_t *)fnp;
    break;
  }
  ret = __dbreg_add_dbentry(dbenv___0, dblp, dbp___1, id);
  if (ret != 0) {
    goto err;
  }
  err: 
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
  }
  if ((unsigned int )close_dbp != (unsigned int )((void *)0)) {
    __db_close(close_dbp, (DB_TXN *)((void *)0), 23U);
  }
  return (ret);
}
}
int __dbreg_revoke_id(DB *dbp___1 , int have_lock , int32_t force_id ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  FNAME *fnp ;
  LOG *lp ;
  int32_t id ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  fnp = dbp___1->log_filename;
  if ((unsigned int )fnp == (unsigned int )((void *)0)) {
    return (0);
  }
  if (force_id != -1) {
    id = force_id;
  } else {
    if (fnp->id == -1) {
      return (0);
    } else {
      id = fnp->id;
    }
  }
  if (! have_lock) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
    }
  }
  fnp->id = -1;
  while (1) {
    if (fnp->q.stqe_next != -1) {
      ((struct __fname *)((u_int8_t *)fnp + fnp->q.stqe_next))->q.stqe_prev = fnp->q.stqe_prev +
                                                                              ((u_int8_t *)fnp -
                                                                               (u_int8_t *)((struct __fname *)((u_int8_t *)fnp +
                                                                                                               fnp->q.stqe_next)));
      (*((ssize_t *)((u_int8_t *)fnp + fnp->q.stqe_prev))) = (*((ssize_t *)((u_int8_t *)fnp +
                                                                            fnp->q.stqe_prev))) +
                                                             fnp->q.stqe_next;
    } else {
      lp->fq.stqh_last = fnp->q.stqe_prev + ((u_int8_t *)fnp - (u_int8_t *)(& lp->fq));
      (*((ssize_t *)((u_int8_t *)fnp + fnp->q.stqe_prev))) = -1;
    }
    break;
  }
  __dbreg_rem_dbentry(dblp, id);
  ret = __dbreg_push_id(dbenv___0, id);
  if (! have_lock) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
    }
  }
  return (ret);
}
}
int __dbreg_close_id(DB *dbp___1 , DB_TXN *txn ) 
{ DBT fid_dbt ;
  DBT r_name ;
  DBT *dbtp ;
  DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  DB_LSN r_unused ;
  FNAME *fnp ;
  LOG *lp ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  fnp = dbp___1->log_filename;
  if ((unsigned int )fnp == (unsigned int )((void *)0)) {
    return (0);
  } else {
    if (fnp->id == -1) {
      return (0);
    }
  }
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
  }
  if (fnp->name_off == 0U) {
    dbtp = (DBT *)((void *)0);
  } else {
    memset((void *)(& r_name), 0, sizeof(r_name));
    r_name.data = (void *)((u_int8_t *)dblp->reginfo.addr + fnp->name_off);
    tmp = strlen((char const   *)((char *)r_name.data));
    r_name.size = tmp + 1U;
    dbtp = & r_name;
  }
  memset((void *)(& fid_dbt), 0, sizeof(fid_dbt));
  fid_dbt.data = (void *)(fnp->ufid);
  fid_dbt.size = 20U;
  if (dbp___1->flags & 32768U) {
    tmp___0 = 16;
  } else {
    tmp___0 = 0;
  }
  ret = __dbreg_register_log(dbenv___0, txn, & r_unused, (unsigned int )tmp___0, 2U,
                             (DBT const   *)dbtp, (DBT const   *)(& fid_dbt), fnp->id,
                             fnp->s_type, fnp->meta_pgno, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __dbreg_revoke_id(dbp___1, 1, -1);
  err: 
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-DjTI2meY.i","-O2")
int __dbreg_register_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                              void *summary ) ;
int __dbreg_register_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                           void *notused3 ) ;
int __dbreg_register_read(DB_ENV *dbenv___0 , void *recbuf , __dbreg_register_args **argpp ) ;
int __dbreg_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __dbreg_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                             db_recops  , void * ) ,
                          size_t *dtabsizep ) ;
int __dbreg_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                            db_recops  , void * ) ,
                         size_t *dtabsizep ) ;
int __dbreg_register_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                             void *info ) ;
int __dbreg_register_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                         u_int32_t opcode , DBT const   *name , DBT const   *uid ,
                         int32_t fileid , DBTYPE ftype , db_pgno_t meta_pgno , u_int32_t id ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  rectype = 2U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = name->size;
  }
  if ((unsigned int )uid == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = uid->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t )) +
                    tmp___0) + sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& name->size), sizeof(name->size));
    bp += sizeof(name->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )name->data, name->size);
    bp += name->size;
  }
  if ((unsigned int )uid == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uid->size), sizeof(uid->size));
    bp += sizeof(uid->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )uid->data, uid->size);
    bp += uid->size;
  }
  uinttmp = (unsigned int )fileid;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )ftype;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = meta_pgno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = id;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __dbreg_register_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                              void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __dbreg_register_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                           void *notused3 ) 
{ __dbreg_register_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __dbreg_register_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__dbreg_register%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\tname: ");
  i = 0U;
  while (i < argp->name.size) {
    ch = (int )(*((u_int8_t *)argp->name.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tuid: ");
  i = 0U;
  while (i < argp->uid.size) {
    ch = (int )(*((u_int8_t *)argp->uid.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tfileid: %ld\n", (long )argp->fileid);
  printf((char const   * __restrict  )"\tftype: 0x%lx\n", (unsigned long )argp->ftype);
  printf((char const   * __restrict  )"\tmeta_pgno: %lu\n", (unsigned long )argp->meta_pgno);
  printf((char const   * __restrict  )"\tid: 0x%lx\n", (unsigned long )argp->id);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __dbreg_register_read(DB_ENV *dbenv___0 , void *recbuf , __dbreg_register_args **argpp ) 
{ __dbreg_register_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__dbreg_register_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->name), 0, sizeof(argp->name));
  memcpy((void * __restrict  )(& argp->name.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->name.data = (void *)bp;
  bp += argp->name.size;
  memset((void *)(& argp->uid), 0, sizeof(argp->uid));
  memcpy((void * __restrict  )(& argp->uid.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->uid.data = (void *)bp;
  bp += argp->uid.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->ftype = (enum __anonenum_DBTYPE_61 )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->id = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __dbreg_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __dbreg_register_print, 2U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __dbreg_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                             db_recops  , void * ) ,
                          size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __dbreg_register_getpgnos,
                          2U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __dbreg_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                            db_recops  , void * ) ,
                         size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __dbreg_register_recover,
                          2U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-wneAr5ro.i","-O2")
int __dbreg_do_open(DB_ENV *dbenv___0 , DB_TXN *txn , DB_LOG *lp , u_int8_t *uid ,
                    char *name , DBTYPE ftype , int32_t ndx , db_pgno_t meta_pgno ,
                    void *info , u_int32_t id ) ;
static int __dbreg_open_file(DB_ENV *dbenv___0 , DB_TXN *txn , __dbreg_register_args *argp ,
                             void *info ) ;
int __dbreg_register_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                             void *info ) 
{ DB_ENTRY *dbe ;
  DB_LOG *dblp ;
  DB *dbp___1 ;
  __dbreg_register_args *argp ;
  int do_close ;
  int do_open ;
  int do_rem ;
  int ret ;
  int t_ret ;
  DB_TXN *tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  dbp___1 = (DB *)((void *)0);
  do_close = 0;
  do_open = do_close;
  ret = __dbreg_register_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    goto out;
  }
  switch ((int )argp->opcode) {
  case 3: ;
  if ((int )op == 4) {
    do_open = 1;
  } else {
    if ((int )op == 1) {
      do_open = 1;
    } else {
      if ((int )op == 6) {
        do_open = 1;
      } else {
        if ((int )op == 7) {
          do_open = 1;
        } else {
          do_close = 1;
        }
      }
    }
  }
  break;
  case 2: ;
  if ((int )op == 0) {
    do_open = 1;
  } else {
    if ((int )op == 3) {
      do_open = 1;
    } else {
      if ((int )op == 2) {
        do_open = 1;
      } else {
        do_close = 1;
      }
    }
  }
  break;
  case 4: ;
  if ((int )op == 0) {
    do_open = 1;
  } else {
    if ((int )op == 3) {
      do_open = 1;
    } else {
      if ((int )op == 2) {
        do_open = 1;
      } else {
        if ((int )op == 7) {
          do_open = 1;
        } else {
          do_close = 1;
        }
      }
    }
  }
  break;
  case 1: ;
  if ((int )op == 0) {
    do_open = 1;
  } else {
    if ((int )op == 3) {
      do_open = 1;
    } else {
      if ((int )op == 2) {
        do_open = 1;
      } else {
        if ((int )op == 6) {
          do_open = 1;
        } else {
          if ((int )op == 7) {
            do_open = 1;
          }
        }
      }
    }
  }
  break;
  }
  if (do_open) {
    if ((int )op == 6) {
      if (argp->opcode != 1U) {
        dblp->flags = dblp->flags | 2U;
      }
    }
    if ((int )op == 0) {
      tmp = argp->txnid;
    } else {
      if ((int )op == 7) {
        tmp = argp->txnid;
      } else {
        tmp = (DB_TXN *)((void *)0);
      }
    }
    ret = __dbreg_open_file(dbenv___0, tmp, argp, info);
    if (ret == 2) {
      goto _L;
    } else {
      if (ret == 22) {
        _L: 
        if ((int )op == 4) {
          if ((unsigned int )argp->txnid != (unsigned int )((DB_TXN *)0)) {
            if ((dblp->dbentry + argp->fileid)->deleted) {
              (dblp->dbentry + argp->fileid)->deleted = 0;
              ret = __dbreg_open_file(dbenv___0, (DB_TXN *)((void *)0), argp, info);
            }
          }
        }
        if (ret == 2) {
          ret = 0;
        }
      }
    }
    dblp->flags = dblp->flags & 4294967293U;
  }
  if (do_close) {
    do_rem = 0;
    if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dblp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dblp->mutexp);
      }
    }
    if (argp->fileid < dblp->dbentry_cnt) {
      dbe = dblp->dbentry + argp->fileid;
      if ((unsigned int )dbe->dbp == (unsigned int )((void *)0)) {
        if (! dbe->deleted) {
          if ((int )op == 4) {
            __db_err((DB_ENV const   *)dbenv___0, "Improper file close at %lu/%lu",
                     (unsigned long )lsnp->file, (unsigned long )lsnp->offset);
            ret = 22;
          } else {
            if ((int )op == 1) {
              __db_err((DB_ENV const   *)dbenv___0, "Improper file close at %lu/%lu",
                       (unsigned long )lsnp->file, (unsigned long )lsnp->offset);
              ret = 22;
            } else {
              if (argp->opcode == 1U) {
                __db_err((DB_ENV const   *)dbenv___0, "Improper file close at %lu/%lu",
                         (unsigned long )lsnp->file, (unsigned long )lsnp->offset);
                ret = 22;
              }
            }
          }
          if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
            if (! ((dblp->mutexp)->flags & 2U)) {
              __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
            }
          }
          goto done;
        }
      }
      dbp___1 = dbe->dbp;
      if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
        if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
          if (! ((dblp->mutexp)->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
          }
        }
        __dbreg_revoke_id(dbp___1, 0, -1);
        if (dbp___1->flags & 2097152U) {
          do_rem = 1;
        } else {
          if ((int )op == 0) {
            do_rem = 1;
          }
        }
      } else {
        if (dbe->deleted) {
          if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
            if (! ((dblp->mutexp)->flags & 2U)) {
              __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
            }
          }
          __dbreg_rem_dbentry(dblp, argp->fileid);
        }
      }
    } else {
      if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
        if (! ((dblp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
        }
      }
    }
    if (do_rem) {
      if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
        if (argp->id != 0U) {
          dbp___1->flags = dbp___1->flags | 256U;
        }
        if ((int )op == 0) {
          if (! (dbp___1->flags & 2097152U)) {
            t_ret = __db_refresh(dbp___1, (DB_TXN *)((void *)0), 23U, (int *)((void *)0));
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if ((int )op == 1) {
            __db_sync(dbp___1);
          }
          t_ret = __db_close(dbp___1, (DB_TXN *)((void *)0), 23U);
        }
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
      }
    }
  }
  done: 
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  out: 
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
static int __dbreg_open_file(DB_ENV *dbenv___0 , DB_TXN *txn , __dbreg_register_args *argp ,
                             void *info ) 
{ DB_ENTRY *dbe ;
  DB_LOG *lp ;
  DB *dbp___1 ;
  u_int32_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  lp = (DB_LOG *)dbenv___0->lg_handle;
  if (argp->name.size == 0U) {
    __dbreg_add_dbentry(dbenv___0, lp, (DB *)((void *)0), argp->fileid);
    return (2);
  }
  if ((unsigned int )lp->mutexp != (unsigned int )((void *)0)) {
    if (! ((lp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, lp->mutexp);
    }
  }
  if (argp->fileid < lp->dbentry_cnt) {
    dbe = lp->dbentry + argp->fileid;
  } else {
    dbe = (DB_ENTRY *)((void *)0);
  }
  if ((unsigned int )dbe != (unsigned int )((void *)0)) {
    if (dbe->deleted) {
      if ((unsigned int )lp->mutexp != (unsigned int )((void *)0)) {
        if (! ((lp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, lp->mutexp);
        }
      }
      return (2);
    }
    dbp___1 = dbe->dbp;
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      if (dbp___1->meta_pgno != argp->meta_pgno) {
        goto _L;
      } else {
        tmp = memcmp((void const   *)(dbp___1->fileid), (void const   *)argp->uid.data,
                     20U);
        if (tmp != 0) {
          _L: 
          if ((unsigned int )lp->mutexp != (unsigned int )((void *)0)) {
            if (! ((lp->mutexp)->flags & 2U)) {
              __db_pthread_mutex_unlock(dbenv___0, lp->mutexp);
            }
          }
          __dbreg_revoke_id(dbp___1, 0, -1);
          if (dbp___1->flags & 2097152U) {
            __db_close(dbp___1, (DB_TXN *)((void *)0), 23U);
          }
          goto reopen;
        }
      }
      if ((unsigned int )lp->mutexp != (unsigned int )((void *)0)) {
        if (! ((lp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, lp->mutexp);
        }
      }
      if (argp->id != 0U) {
        tmp___0 = __db_txnlist_update(dbenv___0, info, argp->id, 6, (DB_LSN *)((void *)0));
        if (tmp___0 == 4) {
          __db_txnlist_add(dbenv___0, info, argp->id, 6, (DB_LSN *)((void *)0));
        }
      }
      return (0);
    }
  }
  if ((unsigned int )lp->mutexp != (unsigned int )((void *)0)) {
    if (! ((lp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, lp->mutexp);
    }
  }
  reopen: 
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    id = txn->txnid;
    memset((void *)txn, 0, sizeof(DB_TXN ));
    txn->txnid = id;
    txn->mgrp = (DB_TXNMGR *)dbenv___0->tx_handle;
  }
  tmp___1 = __dbreg_do_open(dbenv___0, txn, lp, (u_int8_t *)argp->uid.data, (char *)argp->name.data,
                            argp->ftype, argp->fileid, argp->meta_pgno, info, argp->id);
  return (tmp___1);
}
}
#pragma merger(0,"/tmp/cil-uSkoCGyR.i","-O2")
int __dbreg_open_files(DB_ENV *dbenv___0 ) ;
int __dbreg_fid_to_fname(DB_LOG *dblp , u_int8_t *fid , int have_lock , FNAME **fnamep ) ;
int __dbreg_get_name(DB_ENV *dbenv___0 , u_int8_t *fid , char **namep ) ;
int __txn_begin(DB_ENV *dbenv___0 , DB_TXN *parent , DB_TXN **txnpp , u_int32_t flags ) ;
static int __dbreg_check_master(DB_ENV *dbenv___0 , u_int8_t *uid , char *name ) ;
int __dbreg_add_dbentry(DB_ENV *dbenv___0 , DB_LOG *dblp , DB *dbp___1 , int32_t ndx ) 
{ int32_t i ;
  int ret ;

  {
  ret = 0;
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dblp->mutexp);
    }
  }
  if (dblp->dbentry_cnt <= ndx) {
    ret = __os_realloc(dbenv___0, (unsigned int )(ndx + 64) * sizeof(DB_ENTRY ), (void *)(& dblp->dbentry));
    if (ret != 0) {
      goto err;
    }
    i = dblp->dbentry_cnt;
    while (i < ndx + 64) {
      (dblp->dbentry + i)->dbp = (DB *)((void *)0);
      (dblp->dbentry + i)->deleted = 0;
      i ++;
    }
    dblp->dbentry_cnt = i;
  }
  (dblp->dbentry + ndx)->deleted = (unsigned int )dbp___1 == (unsigned int )((void *)0);
  (dblp->dbentry + ndx)->dbp = dbp___1;
  err: 
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
    }
  }
  return (ret);
}
}
void __dbreg_rem_dbentry(DB_LOG *dblp , int32_t ndx ) 
{ 

  {
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dblp->dbenv, dblp->mutexp);
    }
  }
  if (dblp->dbentry_cnt > ndx) {
    (dblp->dbentry + ndx)->dbp = (DB *)((void *)0);
    (dblp->dbentry + ndx)->deleted = 0;
  }
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dblp->dbenv, dblp->mutexp);
    }
  }
  return;
}
}
int __dbreg_open_files(DB_ENV *dbenv___0 ) 
{ DB_LOG *dblp ;
  DB_LSN r_unused ;
  DBT *dbtp ;
  DBT fid_dbt ;
  DBT t ;
  FNAME *fnp ;
  LOG *lp ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  ret = 0;
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
  }
  if (lp->fq.stqh_first == -1) {
    fnp = (FNAME *)((void *)0);
  } else {
    fnp = (struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first);
  }
  while ((unsigned int )fnp != (unsigned int )((void *)0)) {
    if (fnp->name_off == 0U) {
      dbtp = (DBT *)((void *)0);
    } else {
      memset((void *)(& t), 0, sizeof(t));
      t.data = (void *)((u_int8_t *)dblp->reginfo.addr + fnp->name_off);
      tmp = strlen((char const   *)t.data);
      t.size = tmp + 1U;
      dbtp = & t;
    }
    memset((void *)(& fid_dbt), 0, sizeof(fid_dbt));
    fid_dbt.data = (void *)(fnp->ufid);
    fid_dbt.size = 20U;
    if (dblp->flags & 1U) {
      tmp___0 = 4;
    } else {
      tmp___0 = 1;
    }
    if (fnp->is_durable) {
      tmp___1 = 0;
    } else {
      tmp___1 = 16;
    }
    ret = __dbreg_register_log(dbenv___0, (DB_TXN *)((void *)0), & r_unused, (unsigned int )tmp___1,
                               (unsigned int )tmp___0, (DBT const   *)dbtp, (DBT const   *)(& fid_dbt),
                               fnp->id, fnp->s_type, fnp->meta_pgno, 0U);
    if (ret != 0) {
      break;
    }
    if (fnp->q.stqe_next == -1) {
      fnp = (FNAME *)((void *)0);
    } else {
      fnp = (struct __fname *)((u_int8_t *)fnp + fnp->q.stqe_next);
    }
  }
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
  }
  return (ret);
}
}
int __dbreg_close_files(DB_ENV *dbenv___0 ) 
{ DB_LOG *dblp ;
  DB *dbp___1 ;
  int ret ;
  int t_ret ;
  int32_t i ;
  int tmp ;

  {
  if (! ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  ret = 0;
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dblp->mutexp);
    }
  }
  i = 0;
  while (i < dblp->dbentry_cnt) {
    dbp___1 = (dblp->dbentry + i)->dbp;
    if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
      if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
        if (! ((dblp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
        }
      }
      if (dbp___1->flags & 2097152U) {
        if ((unsigned int )dbp___1->mpf == (unsigned int )((void *)0)) {
          tmp = 23;
        } else {
          tmp = 0;
        }
        t_ret = __db_close(dbp___1, (DB_TXN *)((void *)0), (unsigned int )tmp);
      } else {
        t_ret = __dbreg_revoke_id(dbp___1, 0, -1);
      }
      if (ret == 0) {
        ret = t_ret;
      }
      if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
        if (! ((dblp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, dblp->mutexp);
        }
      }
    }
    (dblp->dbentry + i)->deleted = 0;
    (dblp->dbentry + i)->dbp = (DB *)((void *)0);
    i ++;
  }
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
    }
  }
  return (ret);
}
}
int __dbreg_id_to_db(DB_ENV *dbenv___0 , DB_TXN *txn , DB **dbpp , int32_t ndx , int inc ) 
{ int tmp ;

  {
  tmp = __dbreg_id_to_db_int(dbenv___0, txn, dbpp, ndx, inc, 1);
  return (tmp);
}
}
int __dbreg_id_to_db_int(DB_ENV *dbenv___0 , DB_TXN *txn , DB **dbpp , int32_t ndx ,
                         int inc , int tryopen ) 
{ DB_LOG *dblp ;
  FNAME *fname ;
  int ret ;
  char *name ;
  int tmp ;

  {
  ret = 0;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  inc = 0;
  inc = inc;
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dblp->mutexp);
    }
  }
  if (ndx >= dblp->dbentry_cnt) {
    goto _L;
  } else {
    if (! (dblp->dbentry + ndx)->deleted) {
      if ((unsigned int )(dblp->dbentry + ndx)->dbp == (unsigned int )((void *)0)) {
        _L: 
        if (! tryopen) {
          ret = 2;
          goto err;
        } else {
          if (dblp->flags & 1U) {
            ret = 2;
            goto err;
          }
        }
        if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
          if (! ((dblp->mutexp)->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
          }
        }
        tmp = __dbreg_id_to_fname(dblp, ndx, 0, & fname);
        if (tmp != 0) {
          return (2);
        }
        name = (char *)((void *)((u_int8_t *)dblp->reginfo.addr + fname->name_off));
        ret = __dbreg_do_open(dbenv___0, txn, dblp, fname->ufid, name, fname->s_type,
                              ndx, fname->meta_pgno, (void *)0, 0U);
        if (ret != 0) {
          return (ret);
        }
        (*dbpp) = (dblp->dbentry + ndx)->dbp;
        return (0);
      }
    }
  }
  if ((dblp->dbentry + ndx)->deleted) {
    ret = -30898;
    goto err;
  }
  (*dbpp) = (dblp->dbentry + ndx)->dbp;
  if ((unsigned int )(*dbpp) == (unsigned int )((void *)0)) {
    ret = 2;
  }
  err: 
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dblp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dblp->mutexp);
    }
  }
  return (ret);
}
}
int __dbreg_id_to_fname(DB_LOG *dblp , int32_t lid , int have_lock , FNAME **fnamep ) 
{ DB_ENV *dbenv___0 ;
  FNAME *fnp ;
  LOG *lp ;
  int ret ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  ret = -1;
  if (! have_lock) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
    }
  }
  if (lp->fq.stqh_first == -1) {
    fnp = (FNAME *)((void *)0);
  } else {
    fnp = (struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first);
  }
  while ((unsigned int )fnp != (unsigned int )((void *)0)) {
    if (fnp->id == lid) {
      (*fnamep) = fnp;
      ret = 0;
      break;
    }
    if (fnp->q.stqe_next == -1) {
      fnp = (FNAME *)((void *)0);
    } else {
      fnp = (struct __fname *)((u_int8_t *)fnp + fnp->q.stqe_next);
    }
  }
  if (! have_lock) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
    }
  }
  return (ret);
}
}
int __dbreg_fid_to_fname(DB_LOG *dblp , u_int8_t *fid , int have_lock , FNAME **fnamep ) 
{ DB_ENV *dbenv___0 ;
  FNAME *fnp ;
  LOG *lp ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  ret = -1;
  if (! have_lock) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
    }
  }
  if (lp->fq.stqh_first == -1) {
    fnp = (FNAME *)((void *)0);
  } else {
    fnp = (struct __fname *)((u_int8_t *)(& lp->fq) + lp->fq.stqh_first);
  }
  while ((unsigned int )fnp != (unsigned int )((void *)0)) {
    tmp = memcmp((void const   *)(fnp->ufid), (void const   *)fid, 20U);
    if (tmp == 0) {
      (*fnamep) = fnp;
      ret = 0;
      break;
    }
    if (fnp->q.stqe_next == -1) {
      fnp = (FNAME *)((void *)0);
    } else {
      fnp = (struct __fname *)((u_int8_t *)fnp + fnp->q.stqe_next);
    }
  }
  if (! have_lock) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
    }
  }
  return (ret);
}
}
int __dbreg_get_name(DB_ENV *dbenv___0 , u_int8_t *fid , char **namep ) 
{ DB_LOG *dblp ;
  FNAME *fname ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if ((unsigned int )dblp != (unsigned int )((void *)0)) {
    tmp = __dbreg_fid_to_fname(dblp, fid, 0, & fname);
    if (tmp == 0) {
      (*namep) = (char *)((void *)((u_int8_t *)dblp->reginfo.addr + fname->name_off));
      return (0);
    }
  }
  return (-1);
}
}
int __dbreg_do_open(DB_ENV *dbenv___0 , DB_TXN *txn , DB_LOG *lp , u_int8_t *uid ,
                    char *name , DBTYPE ftype , int32_t ndx , db_pgno_t meta_pgno ,
                    void *info , u_int32_t id ) 
{ DB *dbp___1 ;
  int ret ;
  u_int32_t cstat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ret = db_create(& dbp___1, lp->dbenv, 0U);
  if (ret != 0) {
    return (ret);
  }
  dbp___1->flags = dbp___1->flags | 2097152U;
  if (meta_pgno != 0U) {
    memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )uid,
           20U);
    dbp___1->meta_pgno = meta_pgno;
  }
  tmp___1 = __db_omode("rw----");
  ret = __db_open(dbp___1, txn, (char const   *)name, (char const   *)((void *)0),
                  ftype, 16384U, tmp___1, meta_pgno);
  if (ret == 0) {
    if (meta_pgno != 0U) {
      tmp = __dbreg_check_master(dbenv___0, uid, name);
      if (tmp != 0) {
        cstat = 5U;
      } else {
        goto _L;
      }
    } else {
      _L: 
      tmp___0 = memcmp((void const   *)uid, (void const   *)(dbp___1->fileid), 20U);
      if (tmp___0 != 0) {
        cstat = 5U;
      } else {
        cstat = 6U;
      }
    }
    ret = __dbreg_assign_id(dbp___1, ndx);
    if (ret != 0) {
      goto err;
    }
    if (id != 0U) {
      ret = __db_txnlist_update(dbenv___0, info, id, (int )cstat, (DB_LSN *)((void *)0));
      if (ret == 4) {
        ret = __db_txnlist_add(dbenv___0, info, id, (int )cstat, (DB_LSN *)((void *)0));
      } else {
        if (ret > 0) {
          ret = 0;
        }
      }
    }
    err: 
    if (cstat == 5U) {
      goto not_right;
    }
    return (ret);
  } else {
    if (ret == 2) {
      if (id != 0U) {
        ret = __db_txnlist_update(dbenv___0, info, id, 7, (DB_LSN *)((void *)0));
        if (ret == 4) {
          ret = __db_txnlist_add(dbenv___0, info, id, 7, (DB_LSN *)((void *)0));
        }
      }
    }
  }
  not_right: 
  __db_close(dbp___1, (DB_TXN *)((void *)0), 0U);
  __dbreg_add_dbentry(dbenv___0, lp, (DB *)((void *)0), ndx);
  return (ret);
}
}
static int __dbreg_check_master(DB_ENV *dbenv___0 , u_int8_t *uid , char *name ) 
{ DB *dbp___1 ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  ret = 0;
  ret = db_create(& dbp___1, dbenv___0, 0U);
  if (ret != 0) {
    return (ret);
  }
  dbp___1->flags = dbp___1->flags | 2097152U;
  tmp = __db_omode("rw----");
  ret = __db_open(dbp___1, (DB_TXN *)((void *)0), (char const   *)name, (char const   *)((void *)0),
                  (enum __anonenum_DBTYPE_61 )1, 0U, tmp, 0U);
  if (ret == 0) {
    tmp___0 = memcmp((void const   *)uid, (void const   *)(dbp___1->fileid), 20U);
    if (tmp___0 != 0) {
      ret = 22;
    }
  }
  __db_close(dbp___1, (DB_TXN *)((void *)0), 0U);
  return (ret);
}
}
int __dbreg_lazy_id(DB *dbp___1 ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  DB_TXN *txn ;
  FNAME *fnp ;
  LOG *lp ;
  int32_t id ;
  int ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  dbenv___0 = dbp___1->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  fnp = dbp___1->log_filename;
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & lp->fq_mutex);
  }
  if (fnp->id != -1) {
    if (! (lp->fq_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
    }
    return (0);
  }
  id = -1;
  ret = __txn_begin(dbenv___0, (DB_TXN *)((void *)0), & txn, 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __dbreg_get_id(dbp___1, txn, & id);
  if (ret != 0) {
    __txn_abort(txn);
    goto err;
  }
  ret = __txn_commit(txn, 256U);
  if (ret != 0) {
    goto err;
  }
  fnp->id = id;
  err: 
  if (ret != 0) {
    if (id != -1) {
      __dbreg_revoke_id(dbp___1, 1, id);
    }
  }
  if (! (lp->fq_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & lp->fq_mutex);
  }
  return (ret);
}
}
int __dbreg_push_id(DB_ENV *dbenv___0 , int32_t id ) 
{ DB_LOG *dblp ;
  LOG *lp ;
  int32_t *stack ;
  int32_t *newstack ;
  int ret ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (lp->free_fid_stack != 0U) {
    stack = (int32_t *)((void *)((u_int8_t *)dblp->reginfo.addr + lp->free_fid_stack));
  } else {
    stack = (int32_t *)((void *)0);
  }
  if (lp->free_fids_alloced <= lp->free_fids + 1) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    ret = __db_shalloc(dblp->reginfo.addr, (unsigned int )(lp->free_fids_alloced +
                                                           20) * sizeof(u_int32_t ),
                       0U, (void *)(& newstack));
    if (ret != 0) {
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      return (ret);
    }
    memcpy((void * __restrict  )newstack, (void const   * __restrict  )stack, (unsigned int )lp->free_fids_alloced *
                                                                              sizeof(u_int32_t ));
    lp->free_fid_stack = (unsigned int )((u_int8_t *)newstack - (u_int8_t *)dblp->reginfo.addr);
    lp->free_fids_alloced = lp->free_fids_alloced + 20;
    if ((unsigned int )stack != (unsigned int )((void *)0)) {
      __db_shalloc_free(dblp->reginfo.addr, (void *)stack);
    }
    stack = newstack;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  tmp = lp->free_fids;
  lp->free_fids = lp->free_fids + 1;
  (*(stack + tmp)) = id;
  return (0);
}
}
int __dbreg_pop_id(DB_ENV *dbenv___0 , int32_t *id ) 
{ DB_LOG *dblp ;
  LOG *lp ;
  int32_t *stack ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (lp->free_fid_stack != 0U) {
    if (lp->free_fids > 0) {
      stack = (int32_t *)((void *)((u_int8_t *)dblp->reginfo.addr + lp->free_fid_stack));
      lp->free_fids = lp->free_fids - 1;
      (*id) = (*(stack + lp->free_fids));
    } else {
      (*id) = -1;
    }
  } else {
    (*id) = -1;
  }
  return (0);
}
}
int __dbreg_pluck_id(DB_ENV *dbenv___0 , int32_t id ) 
{ DB_LOG *dblp ;
  LOG *lp ;
  int32_t *stack ;
  int i ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (lp->free_fid_stack != 0U) {
    stack = (int32_t *)((void *)((u_int8_t *)dblp->reginfo.addr + lp->free_fid_stack));
    i = 0;
    while (i < lp->free_fids) {
      if (id == (*(stack + i))) {
        (*(stack + i)) = (*(stack + (lp->free_fids - 1)));
        lp->free_fids = lp->free_fids - 1;
        return (0);
      }
      i ++;
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-RHocb18z.i","-O2")
int __db_fileinit(DB_ENV *dbenv___0 , DB_FH *fhp , size_t size , int zerofill ) ;
int __db_overwrite(DB_ENV *dbenv___0 , char const   *path ) ;
static int __db_overwrite_pass(DB_ENV *dbenv___0 , char const   *path , DB_FH *fhp ,
                               u_int32_t mbytes , u_int32_t bytes , int pattern ) ;
int __db_fileinit(DB_ENV *dbenv___0 , DB_FH *fhp , size_t size , int zerofill ) 
{ db_pgno_t pages ;
  size_t i ;
  size_t nw ;
  u_int32_t relative ;
  int ret ;
  char buf[8192] ;

  {
  memset((void *)(buf), 0, sizeof(buf));
  ret = __os_seek(dbenv___0, fhp, 0U, 0U, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )1);
  if (ret != 0) {
    return (ret);
  }
  pages = (size - 8192U) / 1048576U;
  relative = (size - 8192U) % 1048576U;
  ret = __os_seek(dbenv___0, fhp, 1048576U, pages, relative, 0, (enum __anonenum_DB_OS_SEEK_52 )0);
  if (ret != 0) {
    return (ret);
  }
  ret = __os_write(dbenv___0, fhp, (void *)(buf), sizeof(buf), & nw);
  if (ret != 0) {
    return (ret);
  }
  if (zerofill) {
    pages = size / 1048576U;
    relative = size % 1048576U;
    ret = __os_seek(dbenv___0, fhp, 1048576U, pages, relative, 1, (enum __anonenum_DB_OS_SEEK_52 )1);
    if (ret != 0) {
      return (ret);
    }
    i = 0U;
    while (i < size) {
      ret = __os_write(dbenv___0, fhp, (void *)(buf), 1U, & nw);
      if (ret != 0) {
        return (ret);
      }
      ret = __os_seek(dbenv___0, fhp, 0U, 0U, 8191U, 0, (enum __anonenum_DB_OS_SEEK_52 )0);
      if (ret != 0) {
        return (ret);
      }
      i += 8192U;
    }
  }
  return (0);
}
}
int __db_overwrite(DB_ENV *dbenv___0 , char const   *path ) 
{ DB_FH *fhp ;
  u_int32_t mbytes ;
  u_int32_t bytes ;
  int ret ;
  char *tmp ;

  {
  ret = __os_open(dbenv___0, path, 32U, 0, & fhp);
  if (ret == 0) {
    ret = __os_ioinfo(dbenv___0, path, fhp, & mbytes, & bytes, (u_int32_t *)((void *)0));
    if (ret == 0) {
      ret = __db_overwrite_pass(dbenv___0, path, fhp, mbytes, bytes, 255);
      if (ret != 0) {
        goto err;
      }
      ret = __db_overwrite_pass(dbenv___0, path, fhp, mbytes, bytes, 0);
      if (ret != 0) {
        goto err;
      }
      ret = __db_overwrite_pass(dbenv___0, path, fhp, mbytes, bytes, 255);
      if (ret != 0) {
        goto err;
      }
    } else {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", path, tmp);
    }
  } else {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", path, tmp);
  }
  err: 
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, fhp);
  }
  return (ret);
}
}
static int __db_overwrite_pass(DB_ENV *dbenv___0 , char const   *path , DB_FH *fhp ,
                               u_int32_t mbytes , u_int32_t bytes , int pattern ) 
{ size_t len ;
  size_t nw ;
  int i ;
  int ret ;
  char buf[8192] ;
  char *tmp ;

  {
  ret = __os_seek(dbenv___0, fhp, 0U, 0U, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  memset((void *)(buf), pattern, sizeof(buf));
  while (mbytes > 0U) {
    i = (int )(1048576U / sizeof(buf));
    while (i > 0) {
      ret = __os_write(dbenv___0, fhp, (void *)(buf), sizeof(buf), & nw);
      if (ret != 0) {
        goto err;
      }
      i --;
    }
    mbytes --;
  }
  while (bytes > 0U) {
    if (bytes < sizeof(buf)) {
      len = bytes;
    } else {
      len = sizeof(buf);
    }
    ret = __os_write(dbenv___0, fhp, (void *)(buf), len, & nw);
    if (ret != 0) {
      goto err;
    }
    bytes -= len;
  }
  ret = __os_fsync(dbenv___0, fhp);
  if (ret != 0) {
    err: 
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", path, tmp);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-kaRVjtco.i","-O2")
struct __db_globals __db_global_values  = 
     {{(struct __db_env *)((void *)0), & __db_global_values.db_envq.tqh_first}, (int (*)(int  ))((void *)0),
    (void (*)(char ** , int  ))((void *)0), (int (*)(char const   * , char *** , int * ))((void *)0),
    (int (*)(char const   * , int * ))((void *)0), (void (*)(void * ))((void *)0),
    (int (*)(int  ))((void *)0), (int (*)(char const   * , int  , u_int32_t * , u_int32_t * ,
                                          u_int32_t * ))((void *)0), (void *(*)(size_t  ))((void *)0),
    (int (*)(char * , size_t  , int  , int  , void ** ))((void *)0), (int (*)(char const   * ,
                                                                              int  
                                                                              , ...))((void *)0),
    (ssize_t (*)(int  , void * , size_t  ))((void *)0), (void *(*)(void * , size_t  ))((void *)0),
    (int (*)(char const   * , char const   * ))((void *)0), (int (*)(int  , size_t  ,
                                                                     db_pgno_t  ,
                                                                     u_int32_t  ,
                                                                     int  , int  ))((void *)0),
    (int (*)(u_long  , u_long  ))((void *)0), (int (*)(char const   * ))((void *)0),
    (int (*)(void * , size_t  ))((void *)0), (ssize_t (*)(int  , void const   * ,
                                                          size_t  ))((void *)0), (int (*)(void))((void *)0)};
int __dbenv_set_flags(DB_ENV *dbenv___0 , u_int32_t flags , int on ) ;
int __dbenv_set_data_dir(DB_ENV *dbenv___0 , char const   *dir ) ;
int __dbenv_set_shm_key(DB_ENV *dbenv___0 , long shm_key ) ;
int __dbenv_set_tas_spins(DB_ENV *dbenv___0 , u_int32_t tas_spins ) ;
int __dbenv_set_tmp_dir(DB_ENV *dbenv___0 , char const   *dir ) ;
int __dbenv_set_verbose(DB_ENV *dbenv___0 , u_int32_t which , int on ) ;
int __dbenv_remove(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) ;
int __dbenv_close_pp(DB_ENV *dbenv___0 , u_int32_t flags ) ;
int __dbenv_get_open_flags(DB_ENV *dbenv___0 , u_int32_t *flagsp ) ;
int __os_have_direct(void) ;
void __os_spin(DB_ENV *dbenv___0 ) ;
void __db_derive_mac(u_int8_t *passwd , size_t plen , u_int8_t *mac_key ) ;
void __lock_dbenv_create(DB_ENV *dbenv___0 ) ;
void __log_dbenv_create(DB_ENV *dbenv___0 ) ;
void __memp_dbenv_create(DB_ENV *dbenv___0 ) ;
void __txn_dbenv_create(DB_ENV *dbenv___0 ) ;
static int __dbenv_init(DB_ENV *dbenv___0 ) ;
static void __dbenv_err(DB_ENV const   *dbenv___0 , int error , char const   *fmt 
                        , ...) ;
static void __dbenv_errx(DB_ENV const   *dbenv___0 , char const   *fmt  , ...) ;
static int __dbenv_get_home(DB_ENV *dbenv___0 , char const   **homep ) ;
static int __dbenv_set_app_dispatch(DB_ENV *dbenv___0 , int (*app_dispatch)(DB_ENV * ,
                                                                            DBT * ,
                                                                            DB_LSN * ,
                                                                            db_recops  ) ) ;
static int __dbenv_get_data_dirs(DB_ENV *dbenv___0 , char const   ***dirpp ) ;
static int __dbenv_set_feedback(DB_ENV *dbenv___0 , void (*feedback)(DB_ENV * , int  ,
                                                                     int  ) ) ;
static void __dbenv_map_flags(DB_ENV *dbenv___0 , u_int32_t *inflagsp , u_int32_t *outflagsp ) ;
static int __dbenv_get_flags(DB_ENV *dbenv___0 , u_int32_t *flagsp ) ;
static int __dbenv_set_rpc_server_noclnt(DB_ENV *dbenv___0 , void *cl , char const   *host ,
                                         long tsec , long ssec , u_int32_t flags ) ;
static int __dbenv_get_shm_key(DB_ENV *dbenv___0 , long *shm_keyp ) ;
static int __dbenv_get_tas_spins(DB_ENV *dbenv___0 , u_int32_t *tas_spinsp ) ;
static int __dbenv_get_tmp_dir(DB_ENV *dbenv___0 , char const   **dirp ) ;
static int __dbenv_get_verbose(DB_ENV *dbenv___0 , u_int32_t which , int *onoffp ) ;
int db_env_create(DB_ENV **dbenvpp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;

  {
  if (flags != 0U) {
    if (! (flags & 1U)) {
      return (22);
    }
  }
  ret = __os_calloc((DB_ENV *)((void *)0), 1U, sizeof((*dbenv___0)), (void *)(& dbenv___0));
  if (ret != 0) {
    return (ret);
  }
  ret = __dbenv_init(dbenv___0);
  if (ret != 0) {
    __os_free((DB_ENV *)((void *)0), (void *)dbenv___0);
    return (ret);
  }
  (*dbenvpp) = dbenv___0;
  return (0);
}
}
static int __dbenv_init(DB_ENV *dbenv___0 ) 
{ int ret ;

  {
  dbenv___0->err = & __dbenv_err;
  dbenv___0->errx = & __dbenv_errx;
  dbenv___0->set_errcall = & __dbenv_set_errcall;
  dbenv___0->get_errfile = & __dbenv_get_errfile;
  dbenv___0->set_errfile = & __dbenv_set_errfile;
  dbenv___0->get_errpfx = & __dbenv_get_errpfx;
  dbenv___0->set_errpfx = & __dbenv_set_errpfx;
  dbenv___0->close = & __dbenv_close_pp;
  dbenv___0->dbremove = & __dbenv_dbremove_pp;
  dbenv___0->dbrename = & __dbenv_dbrename_pp;
  dbenv___0->open = & __dbenv_open;
  dbenv___0->remove = & __dbenv_remove;
  dbenv___0->get_home = & __dbenv_get_home;
  dbenv___0->get_open_flags = & __dbenv_get_open_flags;
  dbenv___0->set_alloc = & __dbenv_set_alloc;
  dbenv___0->set_app_dispatch = & __dbenv_set_app_dispatch;
  dbenv___0->get_data_dirs = & __dbenv_get_data_dirs;
  dbenv___0->set_data_dir = & __dbenv_set_data_dir;
  dbenv___0->get_encrypt_flags = & __dbenv_get_encrypt_flags;
  dbenv___0->set_encrypt = & __dbenv_set_encrypt;
  dbenv___0->set_feedback = & __dbenv_set_feedback;
  dbenv___0->get_flags = & __dbenv_get_flags;
  dbenv___0->set_flags = & __dbenv_set_flags;
  dbenv___0->set_paniccall = & __dbenv_set_paniccall;
  dbenv___0->set_rpc_server = & __dbenv_set_rpc_server_noclnt;
  dbenv___0->get_shm_key = & __dbenv_get_shm_key;
  dbenv___0->set_shm_key = & __dbenv_set_shm_key;
  dbenv___0->get_tas_spins = & __dbenv_get_tas_spins;
  dbenv___0->set_tas_spins = & __dbenv_set_tas_spins;
  dbenv___0->get_tmp_dir = & __dbenv_get_tmp_dir;
  dbenv___0->set_tmp_dir = & __dbenv_set_tmp_dir;
  dbenv___0->get_verbose = & __dbenv_get_verbose;
  dbenv___0->set_verbose = & __dbenv_set_verbose;
  dbenv___0->shm_key = -1L;
  dbenv___0->db_ref = 0;
  __os_spin(dbenv___0);
  __log_dbenv_create(dbenv___0);
  __lock_dbenv_create(dbenv___0);
  __memp_dbenv_create(dbenv___0);
  ret = __rep_dbenv_create(dbenv___0);
  if (ret != 0) {
    return (ret);
  }
  __txn_dbenv_create(dbenv___0);
  return (0);
}
}
static void __dbenv_err(DB_ENV const   *dbenv___0 , int error , char const   *fmt 
                        , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errcall != (unsigned int )((void *)0)) {
      __db_errcall(dbenv___0, error, 1, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errfile != (unsigned int )((void *)0)) {
      __db_errfile(dbenv___0, error, 1, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
    __db_errfile(dbenv___0, error, 1, fmt, ap);
  } else {
    if ((unsigned int )dbenv___0->db_errcall == (unsigned int )((void *)0)) {
      if ((unsigned int )dbenv___0->db_errfile == (unsigned int )((void *)0)) {
        __db_errfile(dbenv___0, error, 1, fmt, ap);
      }
    }
  }
  __builtin_va_end(ap);
  return;
}
}
static void __dbenv_errx(DB_ENV const   *dbenv___0 , char const   *fmt  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errcall != (unsigned int )((void *)0)) {
      __db_errcall(dbenv___0, 0, 0, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_errfile != (unsigned int )((void *)0)) {
      __db_errfile(dbenv___0, 0, 0, fmt, ap);
    }
  }
  __builtin_va_end(ap);
  __builtin_va_start(ap, fmt);
  if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
    __db_errfile(dbenv___0, 0, 0, fmt, ap);
  } else {
    if ((unsigned int )dbenv___0->db_errcall == (unsigned int )((void *)0)) {
      if ((unsigned int )dbenv___0->db_errfile == (unsigned int )((void *)0)) {
        __db_errfile(dbenv___0, 0, 0, fmt, ap);
      }
    }
  }
  __builtin_va_end(ap);
  return;
}
}
static int __dbenv_get_home(DB_ENV *dbenv___0 , char const   **homep ) 
{ int tmp ;

  {
  if (! (dbenv___0->flags & 8192U)) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->get_home", 0);
    return (tmp);
  }
  (*homep) = (char const   *)dbenv___0->db_home;
  return (0);
}
}
int __dbenv_set_alloc(DB_ENV *dbenv___0 , void *(*mal_func)(size_t  ) , void *(*real_func)(void * ,
                                                                                           size_t  ) ,
                      void (*free_func)(void * ) ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_alloc", 1);
    return (tmp);
  }
  dbenv___0->db_malloc = mal_func;
  dbenv___0->db_realloc = real_func;
  dbenv___0->db_free = free_func;
  return (0);
}
}
static int __dbenv_set_app_dispatch(DB_ENV *dbenv___0 , int (*app_dispatch)(DB_ENV * ,
                                                                            DBT * ,
                                                                            DB_LSN * ,
                                                                            db_recops  ) ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_app_dispatch", 1);
    return (tmp);
  }
  dbenv___0->app_dispatch = app_dispatch;
  return (0);
}
}
int __dbenv_get_encrypt_flags(DB_ENV *dbenv___0 , u_int32_t *flagsp ) 
{ DB_CIPHER *db_cipher ;

  {
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if ((unsigned int )db_cipher != (unsigned int )((void *)0)) {
    if ((int )db_cipher->alg == 1) {
      (*flagsp) = 1U;
    } else {
      (*flagsp) = 0U;
    }
  } else {
    (*flagsp) = 0U;
  }
  return (0);
}
}
int __dbenv_set_encrypt(DB_ENV *dbenv___0 , char const   *passwd , u_int32_t flags ) 
{ DB_CIPHER *db_cipher ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_encrypt", 1);
    return (tmp);
  }
  if (flags != 0U) {
    if (flags & 4294967294U) {
      tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB_ENV->set_encrypt", 0);
      return (tmp___0);
    }
  }
  if ((unsigned int )passwd == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Empty password specified to set_encrypt");
    return (22);
  } else {
    tmp___1 = strlen(passwd);
    if (tmp___1 == 0U) {
      __db_err((DB_ENV const   *)dbenv___0, "Empty password specified to set_encrypt");
      return (22);
    }
  }
  if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
    ret = __os_calloc(dbenv___0, 1U, sizeof(DB_CIPHER ), (void *)(& db_cipher));
    if (ret != 0) {
      goto err;
    }
    dbenv___0->crypto_handle = (void *)db_cipher;
  } else {
    db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  }
  if ((unsigned int )dbenv___0->passwd != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->passwd);
  }
  ret = __os_strdup(dbenv___0, passwd, (void *)(& dbenv___0->passwd));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)db_cipher);
    goto err;
  }
  tmp___2 = strlen((char const   *)dbenv___0->passwd);
  dbenv___0->passwd_len = tmp___2 + 1U;
  __db_derive_mac((u_int8_t *)dbenv___0->passwd, dbenv___0->passwd_len, db_cipher->mac_key);
  switch ((int )flags) {
  case 0: 
  db_cipher->flags = db_cipher->flags | 1U;
  break;
  case 1: 
  ret = __crypto_algsetup(dbenv___0, db_cipher, 1U, 0);
  if (ret != 0) {
    goto err1;
  }
  break;
  default: ;
  break;
  }
  return (0);
  err1: 
  __os_free(dbenv___0, (void *)dbenv___0->passwd);
  __os_free(dbenv___0, (void *)db_cipher);
  dbenv___0->crypto_handle = (void *)0;
  err: 
  return (ret);
}
}
static void __dbenv_map_flags(DB_ENV *dbenv___0 , u_int32_t *inflagsp , u_int32_t *outflagsp ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  if ((*inflagsp) & 16777216U) {
    (*outflagsp) |= 1U;
    (*inflagsp) &= 4278190079U;
  }
  if ((*inflagsp) & 4096U) {
    (*outflagsp) |= 4U;
    (*inflagsp) &= 4294963199U;
  }
  if ((*inflagsp) & 8192U) {
    (*outflagsp) |= 32U;
    (*inflagsp) &= 4294959103U;
  }
  if ((*inflagsp) & 16384U) {
    (*outflagsp) |= 64U;
    (*inflagsp) &= 4294950911U;
  }
  if ((*inflagsp) & 32768U) {
    (*outflagsp) |= 512U;
    (*inflagsp) &= 4294934527U;
  }
  if ((*inflagsp) & 65536U) {
    (*outflagsp) |= 1024U;
    (*inflagsp) &= 4294901759U;
  }
  if ((*inflagsp) & 8U) {
    (*outflagsp) |= 2048U;
    (*inflagsp) &= 4294967287U;
  }
  if ((*inflagsp) & 131072U) {
    (*outflagsp) |= 4096U;
    (*inflagsp) &= 4294836223U;
  }
  if ((*inflagsp) & 262144U) {
    (*outflagsp) |= 16384U;
    (*inflagsp) &= 4294705151U;
  }
  if ((*inflagsp) & 1048576U) {
    (*outflagsp) |= 65536U;
    (*inflagsp) &= 4293918719U;
  }
  if ((*inflagsp) & 2097152U) {
    (*outflagsp) |= 2097152U;
    (*inflagsp) &= 4292870143U;
  }
  if ((*inflagsp) & 256U) {
    (*outflagsp) |= 4194304U;
    (*inflagsp) &= 4294967039U;
  }
  if ((*inflagsp) & 512U) {
    (*outflagsp) |= 8388608U;
    (*inflagsp) &= 4294966783U;
  }
  if ((*inflagsp) & 4194304U) {
    (*outflagsp) |= 16777216U;
    (*inflagsp) &= 4290772991U;
  }
  if ((*inflagsp) & 8388608U) {
    (*outflagsp) |= 33554432U;
    (*inflagsp) &= 4286578687U;
  }
  return;
}
}
static u_int32_t const   env_flags[16]  = 
  {      (u_int32_t const   )16777216U,      (u_int32_t const   )4096U,      (u_int32_t const   )8192U,      (u_int32_t const   )16384U, 
        (u_int32_t const   )32768U,      (u_int32_t const   )65536U,      (u_int32_t const   )8U,      (u_int32_t const   )131072U, 
        (u_int32_t const   )262144U,      (u_int32_t const   )1048576U,      (u_int32_t const   )2097152U,      (u_int32_t const   )256U, 
        (u_int32_t const   )512U,      (u_int32_t const   )4194304U,      (u_int32_t const   )8388608U,      (u_int32_t const   )0U};
static int __dbenv_get_flags(DB_ENV *dbenv___0 , u_int32_t *flagsp ) 
{ u_int32_t f ;
  u_int32_t flags ;
  u_int32_t mapped_flag ;
  int i ;

  {
  flags = 0U;
  i = 0;
  while (1) {
    f = env_flags[i];
    if (! (f != 0U)) {
      break;
    }
    mapped_flag = 0U;
    __dbenv_map_flags(dbenv___0, & f, & mapped_flag);
    if ((dbenv___0->flags & mapped_flag) == mapped_flag) {
      flags |= env_flags[i];
    }
    i ++;
  }
  if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
    if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
      flags |= 524288U;
    }
  }
  (*flagsp) = flags;
  return (0);
}
}
int __dbenv_set_flags(DB_ENV *dbenv___0 , u_int32_t flags , int on ) 
{ u_int32_t mapped_flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (flags & 4261416183U) {
    tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DB_ENV->set_flags", 0);
    return (tmp);
  }
  if (on) {
    ret = __db_fcchk(dbenv___0, "DB_ENV->set_flags", flags, 256U, 512U);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_fcchk(dbenv___0, "DB_ENV->set_flags", flags, 256U, 4194304U);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_fcchk(dbenv___0, "DB_ENV->set_flags", flags, 512U, 4194304U);
    if (ret != 0) {
      return (ret);
    }
    if (flags & 24576U) {
      tmp___0 = __os_have_direct();
      if (tmp___0 == 0) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_flags: direct I/O is not supported by this platform");
        return (22);
      }
    }
  }
  if (flags & 4096U) {
    if (dbenv___0->flags & 8192U) {
      tmp___1 = __db_mi_open(dbenv___0, "DB_ENV->set_flags: DB_CDB_ALLDB", 1);
      return (tmp___1);
    }
  }
  if (flags & 524288U) {
    if (! (dbenv___0->flags & 8192U)) {
      tmp___2 = __db_mi_open(dbenv___0, "DB_ENV->set_flags: DB_PANIC_ENVIRONMENT",
                             0);
      return (tmp___2);
    }
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      ((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic = on;
    }
  }
  if (flags & 1048576U) {
    if (dbenv___0->flags & 8192U) {
      tmp___3 = __db_mi_open(dbenv___0, "DB_ENV->set_flags: DB_REGION_INIT", 1);
      return (tmp___3);
    }
  }
  mapped_flags = 0U;
  __dbenv_map_flags(dbenv___0, & flags, & mapped_flags);
  if (on) {
    dbenv___0->flags = dbenv___0->flags | mapped_flags;
  } else {
    dbenv___0->flags = dbenv___0->flags & ~ mapped_flags;
  }
  return (0);
}
}
static int __dbenv_get_data_dirs(DB_ENV *dbenv___0 , char const   ***dirpp ) 
{ 

  {
  (*dirpp) = (char const   **)dbenv___0->db_data_dir;
  return (0);
}
}
int __dbenv_set_data_dir(DB_ENV *dbenv___0 , char const   *dir ) 
{ int ret ;
  int tmp ;

  {
  if ((unsigned int )dbenv___0->db_data_dir == (unsigned int )((void *)0)) {
    ret = __os_calloc(dbenv___0, 20U, sizeof(char **), (void *)(& dbenv___0->db_data_dir));
    if (ret != 0) {
      return (ret);
    }
    dbenv___0->data_cnt = 20;
  } else {
    if (dbenv___0->data_next == dbenv___0->data_cnt - 2) {
      dbenv___0->data_cnt = dbenv___0->data_cnt * 2;
      ret = __os_realloc(dbenv___0, (unsigned int )dbenv___0->data_cnt * sizeof(char **),
                         (void *)(& dbenv___0->db_data_dir));
      if (ret != 0) {
        return (ret);
      }
    }
  }
  tmp = dbenv___0->data_next;
  dbenv___0->data_next = dbenv___0->data_next + 1;
  ret = __os_strdup(dbenv___0, dir, (void *)(dbenv___0->db_data_dir + tmp));
  (*(dbenv___0->db_data_dir + dbenv___0->data_next)) = (char *)((void *)0);
  return (ret);
}
}
void __dbenv_set_errcall(DB_ENV *dbenv___0 , void (*errcall)(char const   * , char * ) ) 
{ 

  {
  dbenv___0->db_errcall = errcall;
  return;
}
}
void __dbenv_get_errfile(DB_ENV *dbenv___0 , FILE **errfilep ) 
{ 

  {
  (*errfilep) = dbenv___0->db_errfile;
  return;
}
}
void __dbenv_set_errfile(DB_ENV *dbenv___0 , FILE *errfile ) 
{ 

  {
  dbenv___0->db_errfile = errfile;
  return;
}
}
void __dbenv_get_errpfx(DB_ENV *dbenv___0 , char const   **errpfxp ) 
{ 

  {
  (*errpfxp) = dbenv___0->db_errpfx;
  return;
}
}
void __dbenv_set_errpfx(DB_ENV *dbenv___0 , char const   *errpfx ) 
{ 

  {
  dbenv___0->db_errpfx = errpfx;
  return;
}
}
static int __dbenv_set_feedback(DB_ENV *dbenv___0 , void (*feedback)(DB_ENV * , int  ,
                                                                     int  ) ) 
{ 

  {
  dbenv___0->db_feedback = feedback;
  return (0);
}
}
int __dbenv_set_paniccall(DB_ENV *dbenv___0 , void (*paniccall)(DB_ENV * , int  ) ) 
{ 

  {
  dbenv___0->db_paniccall = paniccall;
  return (0);
}
}
static int __dbenv_get_shm_key(DB_ENV *dbenv___0 , long *shm_keyp ) 
{ 

  {
  (*shm_keyp) = dbenv___0->shm_key;
  return (0);
}
}
int __dbenv_set_shm_key(DB_ENV *dbenv___0 , long shm_key ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_shm_key", 1);
    return (tmp);
  }
  dbenv___0->shm_key = shm_key;
  return (0);
}
}
static int __dbenv_get_tas_spins(DB_ENV *dbenv___0 , u_int32_t *tas_spinsp ) 
{ 

  {
  (*tas_spinsp) = dbenv___0->tas_spins;
  return (0);
}
}
int __dbenv_set_tas_spins(DB_ENV *dbenv___0 , u_int32_t tas_spins ) 
{ 

  {
  dbenv___0->tas_spins = tas_spins;
  return (0);
}
}
static int __dbenv_get_tmp_dir(DB_ENV *dbenv___0 , char const   **dirp ) 
{ 

  {
  (*dirp) = (char const   *)dbenv___0->db_tmp_dir;
  return (0);
}
}
int __dbenv_set_tmp_dir(DB_ENV *dbenv___0 , char const   *dir ) 
{ int tmp ;

  {
  if ((unsigned int )dbenv___0->db_tmp_dir != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->db_tmp_dir);
  }
  tmp = __os_strdup(dbenv___0, dir, (void *)(& dbenv___0->db_tmp_dir));
  return (tmp);
}
}
static int __dbenv_get_verbose(DB_ENV *dbenv___0 , u_int32_t which , int *onoffp ) 
{ 

  {
  switch ((int )which) {
  case 1: ;
  case 2: ;
  case 4: ;
  case 8: ;
  case 16: ;
  if (dbenv___0->verbose & which) {
    (*onoffp) = 1;
  } else {
    (*onoffp) = 0;
  }
  break;
  default: ;
  return (22);
  }
  return (0);
}
}
int __dbenv_set_verbose(DB_ENV *dbenv___0 , u_int32_t which , int on ) 
{ 

  {
  switch ((int )which) {
  case 1: ;
  case 2: ;
  case 4: ;
  case 8: ;
  case 16: ;
  if (on) {
    dbenv___0->verbose = dbenv___0->verbose | which;
  } else {
    dbenv___0->verbose = dbenv___0->verbose & ~ which;
  }
  break;
  default: ;
  return (22);
  }
  return (0);
}
}
int __db_mi_env(DB_ENV *dbenv___0 , char const   *name ) 
{ 

  {
  __db_err((DB_ENV const   *)dbenv___0, "%s: method not permitted in shared environment",
           name);
  return (22);
}
}
int __db_mi_open(DB_ENV *dbenv___0 , char const   *name , int after ) 
{ char const   *tmp ;

  {
  if (after) {
    tmp = "after";
  } else {
    tmp = "before";
  }
  __db_err((DB_ENV const   *)dbenv___0, "%s: method not permitted %s handle\'s open method",
           name, tmp);
  return (22);
}
}
int __db_env_config(DB_ENV *dbenv___0 , char *i , u_int32_t flags ) 
{ char *sub ;

  {
  switch ((int )flags) {
  case 8192: 
  sub = (char *)"locking";
  break;
  case 16384: 
  sub = (char *)"logging";
  break;
  case 32768: 
  sub = (char *)"memory pool";
  break;
  case 65536: 
  sub = (char *)"replication";
  break;
  case 131072: 
  sub = (char *)"transaction";
  break;
  default: 
  sub = (char *)"<unspecified>";
  break;
  }
  __db_err((DB_ENV const   *)dbenv___0, "%s interface requires an environment configured for the %s subsystem",
           i, sub);
  return (22);
}
}
static int __dbenv_set_rpc_server_noclnt(DB_ENV *dbenv___0 , void *cl , char const   *host ,
                                         long tsec , long ssec , u_int32_t flags ) 
{ 

  {
  host = (char const   *)((void *)0);
  host = host;
  cl = (void *)0;
  cl = cl;
  tsec = 0L;
  tsec = tsec;
  ssec = 0L;
  ssec = ssec;
  flags = 0U;
  flags = flags;
  __db_err((DB_ENV const   *)dbenv___0, "set_rpc_server method not permitted in non-RPC environment");
  return (95);
}
}
#pragma merger(0,"/tmp/cil-3yalMR8k.i","-O2")
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern void *__rawmemchr(void const   *__s , int __c ) ;
//extern int __builtin_strchr() ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
char *db_version(int *majverp , int *minverp , int *patchp ) ;
int __db_home(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) ;
int __db_e_attach(DB_ENV *dbenv___0 , u_int32_t *init_flagsp ) ;
int __db_e_detach(DB_ENV *dbenv___0 , int destroy ) ;
int __db_e_remove(DB_ENV *dbenv___0 , u_int32_t flags ) ;
int __os_abspath(char const   *path ) ;
int __os_isroot(void) ;
int __os_exists(char const   *path , int *isdirp ) ;
int __os_tmpdir(DB_ENV *dbenv___0 , u_int32_t flags ) ;
int __fop_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
void __lock_dbenv_close(DB_ENV *dbenv___0 ) ;
int __lock_set_lk_detect(DB_ENV *dbenv___0 , u_int32_t lk_detect ) ;
int __lock_set_lk_max(DB_ENV *dbenv___0 , u_int32_t lk_max ) ;
int __lock_set_lk_max_locks(DB_ENV *dbenv___0 , u_int32_t lk_max ) ;
int __lock_set_lk_max_lockers(DB_ENV *dbenv___0 , u_int32_t lk_max ) ;
int __lock_set_lk_max_objects(DB_ENV *dbenv___0 , u_int32_t lk_max ) ;
int __lock_set_env_timeout(DB_ENV *dbenv___0 , db_timeout_t timeout , u_int32_t flags ) ;
int __lock_open(DB_ENV *dbenv___0 ) ;
int __lock_dbenv_refresh(DB_ENV *dbenv___0 ) ;
int __log_open(DB_ENV *dbenv___0 ) ;
int __log_dbenv_refresh(DB_ENV *dbenv___0 ) ;
int __log_set_lg_bsize(DB_ENV *dbenv___0 , u_int32_t lg_bsize ) ;
int __log_set_lg_max(DB_ENV *dbenv___0 , u_int32_t lg_max ) ;
int __log_set_lg_regionmax(DB_ENV *dbenv___0 , u_int32_t lg_regionmax ) ;
int __log_set_lg_dir(DB_ENV *dbenv___0 , char const   *dir ) ;
int __memp_set_mp_mmapsize(DB_ENV *dbenv___0 , size_t mp_mmapsize ) ;
int __memp_open(DB_ENV *dbenv___0 ) ;
int __memp_dbenv_refresh(DB_ENV *dbenv___0 ) ;
int __txn_preclose(DB_ENV *dbenv___0 ) ;
int __txn_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) ;
int __txn_set_tx_max(DB_ENV *dbenv___0 , u_int32_t tx_max ) ;
int __txn_open(DB_ENV *dbenv___0 ) ;
int __txn_dbenv_refresh(DB_ENV *dbenv___0 ) ;
static int __db_parse(DB_ENV *dbenv___0 , char *s ) ;
static int __db_tmp_open(DB_ENV *dbenv___0 , u_int32_t tmp_oflags , char *path , DB_FH **fhpp ) ;
static int __dbenv_config(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) ;
static int __dbenv_refresh(DB_ENV *dbenv___0 , u_int32_t orig_flags , int rep_check ) ;
static int __dbenv_remove_int(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) ;
char *db_version(int *majverp , int *minverp , int *patchp ) 
{ 

  {
  if ((unsigned int )majverp != (unsigned int )((void *)0)) {
    (*majverp) = 4;
  }
  if ((unsigned int )minverp != (unsigned int )((void *)0)) {
    (*minverp) = 2;
  }
  if ((unsigned int )patchp != (unsigned int )((void *)0)) {
    (*patchp) = 52;
  }
  return ((char *)"Sleepycat Software: Berkeley DB 4.2.52: (December  3, 2003)");
}
}
int __dbenv_open(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags , int mode ) 
{ DB_MPOOL *dbmp ;
  u_int32_t init_flags ;
  u_int32_t orig_flags ;
  int rep_check ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  orig_flags = dbenv___0->flags;
  rep_check = 0;
  ret = __db_fchk(dbenv___0, "DB_ENV->open", flags, 8387681U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 4096U) {
    ret = __db_fchk(dbenv___0, "DB_ENV->open", flags, 5807169U);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __db_fcchk(dbenv___0, "DB_ENV->open", flags, 1048576U, 4194304U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fcchk(dbenv___0, "DB_ENV->open", flags, 32U, 2097152U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fcchk(dbenv___0, "DB_ENV->open", flags, 262144U, 3399713U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 65536U) {
    if (! (flags & 131072U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Replication must be used with transactions");
      return (22);
    }
  }
  if (flags & 65536U) {
    if (! (flags & 8192U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Replication must be used with locking");
      return (22);
    }
  }
  if (dbenv___0->flags & 8388608U) {
    if (! (flags & 131072U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Setting non-durability only valid with transactions");
      return (22);
    }
  }
  if (! (flags & 1048576U)) {
    __db_err((DB_ENV const   *)dbenv___0, "Berkeley DB library configured to support only DB_PRIVATE environments");
    return (22);
  }
  if (flags & 2097184U) {
    ret = __dbenv_remove_int(dbenv___0, db_home, 4U);
    if (ret != 0) {
      return (ret);
    } else {
      ret = __dbenv_refresh(dbenv___0, orig_flags, 0);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  ret = __dbenv_config(dbenv___0, db_home, flags);
  if (ret != 0) {
    goto err;
  }
  if (flags & 1U) {
    dbenv___0->flags = dbenv___0->flags | 8U;
  }
  if (flags & 524288U) {
    dbenv___0->flags = dbenv___0->flags | 256U;
  }
  if (flags & 1048576U) {
    dbenv___0->flags = dbenv___0->flags | 32768U;
  }
  if (flags & 2097152U) {
    dbenv___0->flags = dbenv___0->flags | 128U;
  }
  if (flags & 4194304U) {
    dbenv___0->flags = dbenv___0->flags | 524288U;
  }
  if (flags & 64U) {
    dbenv___0->flags = dbenv___0->flags | 1048576U;
  }
  if (mode == 0) {
    dbenv___0->db_mode = __db_omode("rwrw--");
  } else {
    dbenv___0->db_mode = mode;
  }
  init_flags = 0U;
  if (flags & 4096U) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  init_flags |= (unsigned int )tmp___0;
  if (flags & 8192U) {
    tmp___1 = 4;
  } else {
    tmp___1 = 0;
  }
  init_flags |= (unsigned int )tmp___1;
  if (flags & 16384U) {
    tmp___2 = 8;
  } else {
    tmp___2 = 0;
  }
  init_flags |= (unsigned int )tmp___2;
  if (flags & 32768U) {
    tmp___3 = 16;
  } else {
    tmp___3 = 0;
  }
  init_flags |= (unsigned int )tmp___3;
  if (flags & 65536U) {
    tmp___4 = 32;
  } else {
    tmp___4 = 0;
  }
  init_flags |= (unsigned int )tmp___4;
  if (flags & 131072U) {
    tmp___5 = 64;
  } else {
    tmp___5 = 0;
  }
  init_flags |= (unsigned int )tmp___5;
  if (dbenv___0->flags & 4U) {
    tmp___6 = 2;
  } else {
    tmp___6 = 0;
  }
  init_flags |= (unsigned int )tmp___6;
  ret = __db_e_attach(dbenv___0, & init_flags);
  if (ret != 0) {
    goto err;
  }
  if (flags & 262144U) {
    flags &= 4294705151U;
    if (init_flags & 1U) {
      tmp___7 = 4096;
    } else {
      tmp___7 = 0;
    }
    flags |= (unsigned int )tmp___7;
    if (init_flags & 4U) {
      tmp___8 = 8192;
    } else {
      tmp___8 = 0;
    }
    flags |= (unsigned int )tmp___8;
    if (init_flags & 8U) {
      tmp___9 = 16384;
    } else {
      tmp___9 = 0;
    }
    flags |= (unsigned int )tmp___9;
    if (init_flags & 16U) {
      tmp___10 = 32768;
    } else {
      tmp___10 = 0;
    }
    flags |= (unsigned int )tmp___10;
    if (init_flags & 32U) {
      tmp___11 = 65536;
    } else {
      tmp___11 = 0;
    }
    flags |= (unsigned int )tmp___11;
    if (init_flags & 64U) {
      tmp___12 = 131072;
    } else {
      tmp___12 = 0;
    }
    flags |= (unsigned int )tmp___12;
    if (flags & 2U) {
      ret = __dbenv_set_flags(dbenv___0, 4096U, 1);
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (flags & 4096U) {
    flags |= 8192U;
    dbenv___0->flags = dbenv___0->flags | 2U;
  }
  if (flags & 2097184U) {
    if (! (flags & 131072U)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_RECOVER and DB_RECOVER_FATAL require DB_TXN_INIT in DB_ENV->open");
      ret = 22;
      goto err;
    }
  }
  dbenv___0->open_flags = flags;
  if (flags & 65536U) {
    ret = __rep_open(dbenv___0);
    if (ret != 0) {
      goto err;
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  if (flags & 32768U) {
    ret = __memp_open(dbenv___0);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __crypto_region_init(dbenv___0);
  if (ret != 0) {
    goto err;
  }
  if (flags & 147456U) {
    ret = __log_open(dbenv___0);
    if (ret != 0) {
      goto err;
    }
  }
  if (flags & 8192U) {
    ret = __lock_open(dbenv___0);
    if (ret != 0) {
      goto err;
    }
  }
  if (flags & 131072U) {
    ret = __txn_open(dbenv___0);
    if (ret != 0) {
      goto err;
    }
    ret = __bam_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __crdel_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __db_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __dbreg_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __fop_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __ham_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __qam_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    ret = __txn_init_recover(dbenv___0, & dbenv___0->recover_dtab, & dbenv___0->recover_dtab_size);
    if (ret != 0) {
      goto err;
    }
    if (flags & 2097184U) {
      ret = __db_apprec(dbenv___0, (DB_LSN *)((void *)0), (DB_LSN *)((void *)0), 1U,
                        flags & 2097184U);
      if (ret != 0) {
        goto err;
      }
    }
  }
  while (1) {
    dbenv___0->dblist.lh_first = (struct __db *)((void *)0);
    break;
  }
  if (dbenv___0->flags & 1048576U) {
    if (flags & 32768U) {
      dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
      ret = __db_mutex_setup(dbenv___0, dbmp->reginfo, (void *)(& dbenv___0->dblist_mutexp),
                             257U);
      if (ret != 0) {
        goto err;
      }
      ret = __db_mutex_setup(dbenv___0, dbmp->reginfo, (void *)(& dbenv___0->mt_mutexp),
                             257U);
      if (ret != 0) {
        goto err;
      }
    }
  }
  if ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0)) {
    if (((REGINFO *)dbenv___0->reginfo)->flags & 1U) {
      if (! (flags & 2097184U)) {
        ret = __txn_reset(dbenv___0);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (0);
  err: 
  if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
    if (((REGINFO *)dbenv___0->reginfo)->flags & 1U) {
      ret = __db_panic(dbenv___0, ret);
      __dbenv_refresh(dbenv___0, orig_flags, rep_check);
      __dbenv_remove_int(dbenv___0, db_home, 4U);
      __dbenv_refresh(dbenv___0, orig_flags, 0);
    } else {
      __dbenv_refresh(dbenv___0, orig_flags, rep_check);
    }
  } else {
    __dbenv_refresh(dbenv___0, orig_flags, rep_check);
  }
  return (ret);
}
}
int __dbenv_remove(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) 
{ int ret ;
  int t_ret ;
  int tmp ;

  {
  ret = __db_fchk(dbenv___0, "DB_ENV->remove", flags, 3076U);
  if (ret != 0) {
    return (ret);
  }
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->remove", 1);
    return (tmp);
  }
  ret = __dbenv_remove_int(dbenv___0, db_home, flags);
  t_ret = __dbenv_close(dbenv___0, 0);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
static int __dbenv_remove_int(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) 
{ int ret ;
  int tmp ;

  {
  ret = __dbenv_config(dbenv___0, db_home, flags);
  if (ret != 0) {
    return (ret);
  }
  tmp = __db_e_remove(dbenv___0, flags);
  return (tmp);
}
}
static int __dbenv_config(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) 
{ FILE *fp ;
  int ret ;
  char *p ;
  char buf[256] ;
  size_t tmp ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;

  {
  ret = __db_home(dbenv___0, db_home, flags);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )0, "DB_CONFIG", 0U, (DB_FH **)((void *)0),
                     & p);
  if (ret != 0) {
    return (ret);
  }
  fp = fopen((char const   * __restrict  )p, (char const   * __restrict  )"r");
  __os_free(dbenv___0, (void *)p);
  if ((unsigned int )fp != (unsigned int )((void *)0)) {
    while (1) {
      tmp___6 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fp);
      if (! ((unsigned int )tmp___6 != (unsigned int )((void *)0))) {
        break;
      }
      tmp___4 = __builtin_constant_p((int )(buf));
      if (tmp___4) {
        p = (char *)__builtin_strchr(buf, '\n');
      } else {
        p = (char *)__builtin_strchr(buf, '\n');
      }
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        (*p) = (char )'\000';
      } else {
        tmp = strlen((char const   *)(buf));
        if (tmp + 1U == sizeof(buf)) {
          __db_err((DB_ENV const   *)dbenv___0, "DB_CONFIG: line too long");
          fclose(fp);
          return (22);
        }
      }
      if ((int )buf[0] == 0) {
        continue;
      } else {
        if ((int )buf[0] == 35) {
          continue;
        } else {
          tmp___5 = __ctype_b_loc();
          if ((int const   )(*((*tmp___5) + (int )buf[0])) & 8192) {
            continue;
          }
        }
      }
      ret = __db_parse(dbenv___0, buf);
      if (ret != 0) {
        fclose(fp);
        return (ret);
      }
    }
    fclose(fp);
  }
  if ((unsigned int )dbenv___0->db_tmp_dir == (unsigned int )((void *)0)) {
    ret = __os_tmpdir(dbenv___0, flags);
    if (ret != 0) {
      return (ret);
    }
  }
  dbenv___0->flags = dbenv___0->flags | 8192U;
  return (0);
}
}
int __dbenv_close_pp(DB_ENV *dbenv___0 , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  ret = 0;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (flags != 0U) {
    t_ret = __db_ferr((DB_ENV const   *)dbenv___0, "DB_ENV->close", 0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  t_ret = __dbenv_close(dbenv___0, rep_check);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __dbenv_close(DB_ENV *dbenv___0 , int rep_check ) 
{ int ret ;
  int t_ret ;
  char **p ;

  {
  ret = 0;
  if ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0)) {
    t_ret = __txn_preclose(dbenv___0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    t_ret = __rep_preclose(dbenv___0, 1);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (dbenv___0->db_ref != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Database handles open during environment close");
    if (ret == 0) {
      ret = 22;
    }
  }
  t_ret = __dbenv_refresh(dbenv___0, 0U, rep_check);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  __lock_dbenv_close(dbenv___0);
  t_ret = __rep_dbenv_close(dbenv___0);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __crypto_dbenv_close(dbenv___0);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )dbenv___0->db_log_dir != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->db_log_dir);
  }
  if ((unsigned int )dbenv___0->db_tmp_dir != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->db_tmp_dir);
  }
  if ((unsigned int )dbenv___0->db_data_dir != (unsigned int )((void *)0)) {
    p = dbenv___0->db_data_dir;
    while ((unsigned int )(*p) != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)(*p));
      p ++;
    }
    __os_free(dbenv___0, (void *)dbenv___0->db_data_dir);
  }
  memset((void *)dbenv___0, 219, sizeof(DB_ENV ));
  __os_free((DB_ENV *)((void *)0), (void *)dbenv___0);
  return (ret);
}
}
static int __dbenv_refresh(DB_ENV *dbenv___0 , u_int32_t orig_flags , int rep_check ) 
{ DB_MPOOL *dbmp ;
  int ret ;
  int t_ret ;

  {
  ret = 0;
  if ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0)) {
    t_ret = __txn_dbenv_refresh(dbenv___0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    t_ret = __log_dbenv_refresh(dbenv___0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    t_ret = __lock_dbenv_refresh(dbenv___0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  while (1) {
    dbenv___0->dblist.lh_first = (struct __db *)((void *)0);
    break;
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
    __db_mutex_free(dbenv___0, dbmp->reginfo, dbenv___0->dblist_mutexp);
  }
  if ((unsigned int )dbenv___0->mt_mutexp != (unsigned int )((void *)0)) {
    dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
    __db_mutex_free(dbenv___0, dbmp->reginfo, dbenv___0->mt_mutexp);
  }
  if ((unsigned int )dbenv___0->mt != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->mt);
    dbenv___0->mt = (u_long *)((void *)0);
  }
  if ((unsigned int )dbenv___0->mp_handle != (unsigned int )((void *)0)) {
    if (dbenv___0->flags & 32768U) {
      t_ret = __memp_sync(dbenv___0, (DB_LSN *)((void *)0));
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    t_ret = __memp_dbenv_refresh(dbenv___0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  __rep_dbenv_refresh(dbenv___0);
  if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
    t_ret = __db_e_detach(dbenv___0, 0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbenv___0->db_home != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->db_home);
    dbenv___0->db_home = (char *)((void *)0);
  }
  dbenv___0->open_flags = 0U;
  dbenv___0->db_mode = 0;
  if ((unsigned int )dbenv___0->recover_dtab != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->recover_dtab);
    dbenv___0->recover_dtab = (int (**)(DB_ENV * , DBT * , DB_LSN * , db_recops  ,
                                        void * ))((void *)0);
    dbenv___0->recover_dtab_size = 0U;
  }
  dbenv___0->flags = orig_flags;
  return (ret);
}
}
int __dbenv_get_open_flags(DB_ENV *dbenv___0 , u_int32_t *flagsp ) 
{ int tmp ;

  {
  if (! (dbenv___0->flags & 8192U)) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->get_open_flags", 0);
    return (tmp);
  }
  (*flagsp) = dbenv___0->open_flags;
  return (0);
}
}
int __db_appname(DB_ENV *dbenv___0 , APPNAME appname , char const   *file , u_int32_t tmp_oflags ,
                 DB_FH **fhpp , char **namep ) 
{ size_t len ;
  size_t str_len ;
  int data_entry ;
  int ret ;
  int slash ;
  int tmp_create ;
  char const   *a ;
  char const   *b ;
  char *p ;
  char *str ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___16 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___26 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  char *tmp___36 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
  b = (char const   *)((void *)0);
  a = b;
  data_entry = -1;
  tmp_create = 0;
  if ((unsigned int )fhpp != (unsigned int )((void *)0)) {
    (*fhpp) = (DB_FH *)((void *)0);
  }
  if ((unsigned int )namep != (unsigned int )((void *)0)) {
    (*namep) = (char *)((void *)0);
  }
  if ((unsigned int )file != (unsigned int )((void *)0)) {
    tmp___0 = __os_abspath(file);
    if (tmp___0) {
      tmp = __os_strdup(dbenv___0, file, (void *)namep);
      return (tmp);
    }
  }
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    a = (char const   *)dbenv___0->db_home;
  }
  retry: 
  switch ((int )appname) {
  case 0: ;
  break;
  case 1: ;
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_data_dir != (unsigned int )((void *)0)) {
      data_entry ++;
      b = (char const   *)(*(dbenv___0->db_data_dir + data_entry));
      if ((unsigned int )b == (unsigned int )((void *)0)) {
        data_entry = -1;
        b = (char const   *)(*(dbenv___0->db_data_dir + 0));
      }
    }
  }
  break;
  case 2: ;
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    b = (char const   *)dbenv___0->db_log_dir;
  }
  break;
  case 3: ;
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    b = (char const   *)dbenv___0->db_tmp_dir;
  }
  tmp_create = 1;
  break;
  }
  if ((unsigned int )a == (unsigned int )((void *)0)) {
    tmp___2 = 0U;
  } else {
    tmp___3 = strlen(a);
    tmp___2 = tmp___3 + 1U;
  }
  if ((unsigned int )b == (unsigned int )((void *)0)) {
    tmp___5 = 0U;
  } else {
    tmp___6 = strlen(b);
    tmp___5 = tmp___6 + 1U;
  }
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    tmp___8 = 0U;
  } else {
    tmp___9 = strlen(file);
    tmp___8 = tmp___9 + 1U;
  }
  len = (tmp___2 + tmp___5) + tmp___8;
  str_len = (len + sizeof("BDBXXXXX")) + 10U;
  ret = __os_malloc(dbenv___0, str_len, (void *)(& str));
  if (ret != 0) {
    return (ret);
  }
  slash = 0;
  p = str;
  if ((unsigned int )a != (unsigned int )((void *)0)) {
    tmp___10 = __os_abspath(a);
    if (tmp___10) {
      p = str;
      slash = 0;
    }
    len = strlen(a);
    if (slash) {
      tmp___11 = p;
      p ++;
      (*tmp___11) = (char )(*("/" + 0));
    }
    memcpy((void * __restrict  )p, (void const   * __restrict  )a, len);
    p += len;
    tmp___18 = __builtin_constant_p((int )(*(p + -1)));
    if (tmp___18) {
      tmp___19 = __builtin_constant_p((int )"/");
      if (tmp___19) {
        tmp___16 = (char *)__builtin_strchr("/", (*(p + -1)));
      } else {
        if ((int )(*(p + -1)) == 0) {
          tmp___16 = (char *)__rawmemchr((void const   *)"/", (int )(*(p + -1)));
        } else {
          tmp___16 = (char *)__builtin_strchr("/", (*(p + -1)));
        }
      }
    } else {
      tmp___16 = (char *)__builtin_strchr("/", (*(p + -1)));
    }
    slash = (unsigned int )tmp___16 == (unsigned int )((void *)0);
  }
  if ((unsigned int )b != (unsigned int )((void *)0)) {
    tmp___20 = __os_abspath(b);
    if (tmp___20) {
      p = str;
      slash = 0;
    }
    len = strlen(b);
    if (slash) {
      tmp___21 = p;
      p ++;
      (*tmp___21) = (char )(*("/" + 0));
    }
    memcpy((void * __restrict  )p, (void const   * __restrict  )b, len);
    p += len;
    tmp___28 = __builtin_constant_p((int )(*(p + -1)));
    if (tmp___28) {
      tmp___29 = __builtin_constant_p((int )"/");
      if (tmp___29) {
        tmp___26 = (char *)__builtin_strchr("/", (*(p + -1)));
      } else {
        if ((int )(*(p + -1)) == 0) {
          tmp___26 = (char *)__rawmemchr((void const   *)"/", (int )(*(p + -1)));
        } else {
          tmp___26 = (char *)__builtin_strchr("/", (*(p + -1)));
        }
      }
    } else {
      tmp___26 = (char *)__builtin_strchr("/", (*(p + -1)));
    }
    slash = (unsigned int )tmp___26 == (unsigned int )((void *)0);
  }
  if ((unsigned int )file != (unsigned int )((void *)0)) {
    tmp___30 = __os_abspath(file);
    if (tmp___30) {
      p = str;
      slash = 0;
    }
    len = strlen(file);
    if (slash) {
      tmp___31 = p;
      p ++;
      (*tmp___31) = (char )(*("/" + 0));
    }
    memcpy((void * __restrict  )p, (void const   * __restrict  )file, len);
    p += len;
    tmp___38 = __builtin_constant_p((int )(*(p + -1)));
    if (tmp___38) {
      tmp___39 = __builtin_constant_p((int )"/");
      if (tmp___39) {
        tmp___36 = (char *)__builtin_strchr("/", (*(p + -1)));
      } else {
        if ((int )(*(p + -1)) == 0) {
          tmp___36 = (char *)__rawmemchr((void const   *)"/", (int )(*(p + -1)));
        } else {
          tmp___36 = (char *)__builtin_strchr("/", (*(p + -1)));
        }
      }
    } else {
      tmp___36 = (char *)__builtin_strchr("/", (*(p + -1)));
    }
    slash = (unsigned int )tmp___36 == (unsigned int )((void *)0);
  }
  (*p) = (char )'\000';
  tmp___40 = __os_exists((char const   *)str, (int *)((void *)0));
  if (tmp___40 != 0) {
    if (data_entry != -1) {
      __os_free(dbenv___0, (void *)str);
      b = (char const   *)((void *)0);
      goto retry;
    }
  }
  if (tmp_create) {
    ret = __db_tmp_open(dbenv___0, tmp_oflags, str, fhpp);
    if (ret != 0) {
      __os_free(dbenv___0, (void *)str);
      return (ret);
    }
  }
  if ((unsigned int )namep == (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)str);
  } else {
    (*namep) = str;
  }
  return (0);
}
}
int __db_home(DB_ENV *dbenv___0 , char const   *db_home , u_int32_t flags ) 
{ char const   *p ;
  int tmp ;
  int tmp___1 ;

  {
  p = db_home;
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    if (flags & 1024U) {
      goto _L;
    } else {
      if (flags & 2048U) {
        tmp = __os_isroot();
        if (tmp) {
          _L: 
          p = getenv("DB_HOME");
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            if ((int const   )(*(p + 0)) == 0) {
              __db_err((DB_ENV const   *)dbenv___0, "illegal DB_HOME environment variable");
              return (22);
            }
          }
        }
      }
    }
  }
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    tmp___1 = 0;
  } else {
    tmp___1 = __os_strdup(dbenv___0, p, (void *)(& dbenv___0->db_home));
  }
  return (tmp___1);
}
}
static int __db_parse(DB_ENV *dbenv___0 , char *s ) 
{ u_long __max ;
  u_long __v ;
  u_long v1 ;
  u_long v2 ;
  u_long v3 ;
  u_int32_t flags ;
  char *name ;
  char *p ;
  char *value ;
  char v4 ;
  char arg[45] ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;

  {
  name = s;
  p = name;
  while (1) {
    if ((int )(*p) != 0) {
      tmp = __ctype_b_loc();
      if ((int const   )(*((*tmp) + (int )(*p))) & 8192) {
        break;
      }
    } else {
      break;
    }
    p ++;
  }
  if ((int )(*p) == 0) {
    goto illegal;
  } else {
    if ((unsigned int )p == (unsigned int )name) {
      goto illegal;
    }
  }
  (*p) = (char )'\000';
  p ++;
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___0) + (int )(*p))) & 8192)) {
      break;
    }
    p ++;
  }
  if ((int )(*p) == 0) {
    goto illegal;
  }
  value = p;
  p ++;
  while ((int )(*p) != 0) {
    p ++;
  }
  p --;
  while (1) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )(*((*tmp___1) + (int )(*p))) & 8192)) {
      break;
    }
    p --;
  }
  p ++;
  if ((unsigned int )p == (unsigned int )value) {
    illegal: 
    __db_err((DB_ENV const   *)dbenv___0, "mis-formatted name-value pair: %s", s);
    return (22);
  }
  (*p) = (char )'\000';
  tmp___4 = strcasecmp((char const   *)name, "set_cachesize");
  if (! tmp___4) {
    tmp___2 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %lu %lu %c",
                     & v1, & v2, & v3, & v4);
    if (tmp___2 != 3) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    if (v2 > 4294967295UL) {
      __v = v2;
      __max = 4294967295UL;
      goto toobig;
    }
    if (v3 > 10000UL) {
      __v = v3;
      __max = 10000UL;
      goto toobig;
    }
    tmp___3 = __memp_set_cachesize(dbenv___0, (unsigned int )v1, (unsigned int )v2,
                                   (int )v3);
    return (tmp___3);
  }
  tmp___6 = strcasecmp((char const   *)name, "set_data_dir");
  if (tmp___6) {
    tmp___7 = strcasecmp((char const   *)name, "db_data_dir");
    if (! tmp___7) {
      tmp___5 = __dbenv_set_data_dir(dbenv___0, (char const   *)value);
      return (tmp___5);
    }
  } else {
    tmp___5 = __dbenv_set_data_dir(dbenv___0, (char const   *)value);
    return (tmp___5);
  }
  tmp___37 = strcasecmp((char const   *)name, "set_flags");
  if (! tmp___37) {
    tmp___8 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%40s %c",
                     arg, & v4);
    if (tmp___8 != 1) {
      goto badarg;
    }
    tmp___10 = strcasecmp((char const   *)value, "db_auto_commit");
    if (! tmp___10) {
      tmp___9 = __dbenv_set_flags(dbenv___0, 16777216U, 1);
      return (tmp___9);
    }
    tmp___12 = strcasecmp((char const   *)value, "db_cdb_alldb");
    if (! tmp___12) {
      tmp___11 = __dbenv_set_flags(dbenv___0, 4096U, 1);
      return (tmp___11);
    }
    tmp___14 = strcasecmp((char const   *)value, "db_direct_db");
    if (! tmp___14) {
      tmp___13 = __dbenv_set_flags(dbenv___0, 8192U, 1);
      return (tmp___13);
    }
    tmp___16 = strcasecmp((char const   *)value, "db_direct_log");
    if (! tmp___16) {
      tmp___15 = __dbenv_set_flags(dbenv___0, 16384U, 1);
      return (tmp___15);
    }
    tmp___18 = strcasecmp((char const   *)value, "db_log_autoremove");
    if (! tmp___18) {
      tmp___17 = __dbenv_set_flags(dbenv___0, 32768U, 1);
      return (tmp___17);
    }
    tmp___20 = strcasecmp((char const   *)value, "db_nolocking");
    if (! tmp___20) {
      tmp___19 = __dbenv_set_flags(dbenv___0, 65536U, 1);
      return (tmp___19);
    }
    tmp___22 = strcasecmp((char const   *)value, "db_nommap");
    if (! tmp___22) {
      tmp___21 = __dbenv_set_flags(dbenv___0, 8U, 1);
      return (tmp___21);
    }
    tmp___24 = strcasecmp((char const   *)value, "db_nopanic");
    if (! tmp___24) {
      tmp___23 = __dbenv_set_flags(dbenv___0, 131072U, 1);
      return (tmp___23);
    }
    tmp___26 = strcasecmp((char const   *)value, "db_overwrite");
    if (! tmp___26) {
      tmp___25 = __dbenv_set_flags(dbenv___0, 262144U, 1);
      return (tmp___25);
    }
    tmp___28 = strcasecmp((char const   *)value, "db_region_init");
    if (! tmp___28) {
      tmp___27 = __dbenv_set_flags(dbenv___0, 1048576U, 1);
      return (tmp___27);
    }
    tmp___30 = strcasecmp((char const   *)value, "db_txn_nosync");
    if (! tmp___30) {
      tmp___29 = __dbenv_set_flags(dbenv___0, 256U, 1);
      return (tmp___29);
    }
    tmp___32 = strcasecmp((char const   *)value, "db_txn_not_durable");
    if (! tmp___32) {
      tmp___31 = __dbenv_set_flags(dbenv___0, 512U, 1);
      return (tmp___31);
    }
    tmp___34 = strcasecmp((char const   *)value, "db_txn_write_nosync");
    if (! tmp___34) {
      tmp___33 = __dbenv_set_flags(dbenv___0, 4194304U, 1);
      return (tmp___33);
    }
    tmp___36 = strcasecmp((char const   *)value, "db_yieldcpu");
    if (! tmp___36) {
      tmp___35 = __dbenv_set_flags(dbenv___0, 8388608U, 1);
      return (tmp___35);
    }
    goto badarg;
  }
  tmp___40 = strcasecmp((char const   *)name, "set_lg_bsize");
  if (! tmp___40) {
    tmp___38 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___38 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___39 = __log_set_lg_bsize(dbenv___0, (unsigned int )v1);
    return (tmp___39);
  }
  tmp___43 = strcasecmp((char const   *)name, "set_lg_max");
  if (! tmp___43) {
    tmp___41 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___41 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___42 = __log_set_lg_max(dbenv___0, (unsigned int )v1);
    return (tmp___42);
  }
  tmp___46 = strcasecmp((char const   *)name, "set_lg_regionmax");
  if (! tmp___46) {
    tmp___44 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___44 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___45 = __log_set_lg_regionmax(dbenv___0, (unsigned int )v1);
    return (tmp___45);
  }
  tmp___48 = strcasecmp((char const   *)name, "set_lg_dir");
  if (tmp___48) {
    tmp___49 = strcasecmp((char const   *)name, "db_log_dir");
    if (! tmp___49) {
      tmp___47 = __log_set_lg_dir(dbenv___0, (char const   *)value);
      return (tmp___47);
    }
  } else {
    tmp___47 = __log_set_lg_dir(dbenv___0, (char const   *)value);
    return (tmp___47);
  }
  tmp___60 = strcasecmp((char const   *)name, "set_lk_detect");
  if (! tmp___60) {
    tmp___50 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%40s %c",
                      arg, & v4);
    if (tmp___50 != 1) {
      goto badarg;
    }
    tmp___58 = strcasecmp((char const   *)value, "db_lock_default");
    if (tmp___58) {
      tmp___57 = strcasecmp((char const   *)value, "db_lock_expire");
      if (tmp___57) {
        tmp___56 = strcasecmp((char const   *)value, "db_lock_maxlocks");
        if (tmp___56) {
          tmp___55 = strcasecmp((char const   *)value, "db_lock_minlocks");
          if (tmp___55) {
            tmp___54 = strcasecmp((char const   *)value, "db_lock_minwrite");
            if (tmp___54) {
              tmp___53 = strcasecmp((char const   *)value, "db_lock_oldest");
              if (tmp___53) {
                tmp___52 = strcasecmp((char const   *)value, "db_lock_random");
                if (tmp___52) {
                  tmp___51 = strcasecmp((char const   *)value, "db_lock_youngest");
                  if (tmp___51) {
                    goto badarg;
                  } else {
                    flags = 8U;
                  }
                } else {
                  flags = 7U;
                }
              } else {
                flags = 6U;
              }
            } else {
              flags = 5U;
            }
          } else {
            flags = 4U;
          }
        } else {
          flags = 3U;
        }
      } else {
        flags = 2U;
      }
    } else {
      flags = 1U;
    }
    tmp___59 = __lock_set_lk_detect(dbenv___0, flags);
    return (tmp___59);
  }
  tmp___63 = strcasecmp((char const   *)name, "set_lk_max");
  if (! tmp___63) {
    tmp___61 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___61 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___62 = __lock_set_lk_max(dbenv___0, (unsigned int )v1);
    return (tmp___62);
  }
  tmp___66 = strcasecmp((char const   *)name, "set_lk_max_locks");
  if (! tmp___66) {
    tmp___64 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___64 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___65 = __lock_set_lk_max_locks(dbenv___0, (unsigned int )v1);
    return (tmp___65);
  }
  tmp___69 = strcasecmp((char const   *)name, "set_lk_max_lockers");
  if (! tmp___69) {
    tmp___67 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___67 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___68 = __lock_set_lk_max_lockers(dbenv___0, (unsigned int )v1);
    return (tmp___68);
  }
  tmp___72 = strcasecmp((char const   *)name, "set_lk_max_objects");
  if (! tmp___72) {
    tmp___70 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___70 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___71 = __lock_set_lk_max_objects(dbenv___0, (unsigned int )v1);
    return (tmp___71);
  }
  tmp___75 = strcasecmp((char const   *)name, "set_lock_timeout");
  if (! tmp___75) {
    tmp___73 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___73 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___74 = __lock_set_env_timeout(dbenv___0, (unsigned int )v1, 29U);
    return (tmp___74);
  }
  tmp___78 = strcasecmp((char const   *)name, "set_mp_mmapsize");
  if (! tmp___78) {
    tmp___76 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___76 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___77 = __memp_set_mp_mmapsize(dbenv___0, (unsigned int )v1);
    return (tmp___77);
  }
  tmp___82 = strcasecmp((char const   *)name, "set_region_init");
  if (! tmp___82) {
    tmp___79 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___79 != 1) {
      goto badarg;
    } else {
      if (v1 != 1UL) {
        goto badarg;
      }
    }
    if (v1 == 0UL) {
      tmp___80 = 0;
    } else {
      tmp___80 = 1;
    }
    tmp___81 = __dbenv_set_flags(dbenv___0, 1048576U, tmp___80);
    return (tmp___81);
  }
  tmp___85 = strcasecmp((char const   *)name, "set_shm_key");
  if (! tmp___85) {
    tmp___83 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___83 != 1) {
      goto badarg;
    }
    tmp___84 = __dbenv_set_shm_key(dbenv___0, (long )v1);
    return (tmp___84);
  }
  tmp___88 = strcasecmp((char const   *)name, "set_tas_spins");
  if (! tmp___88) {
    tmp___86 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___86 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___87 = __dbenv_set_tas_spins(dbenv___0, (unsigned int )v1);
    return (tmp___87);
  }
  tmp___90 = strcasecmp((char const   *)name, "set_tmp_dir");
  if (tmp___90) {
    tmp___91 = strcasecmp((char const   *)name, "db_tmp_dir");
    if (! tmp___91) {
      tmp___89 = __dbenv_set_tmp_dir(dbenv___0, (char const   *)value);
      return (tmp___89);
    }
  } else {
    tmp___89 = __dbenv_set_tmp_dir(dbenv___0, (char const   *)value);
    return (tmp___89);
  }
  tmp___94 = strcasecmp((char const   *)name, "set_tx_max");
  if (! tmp___94) {
    tmp___92 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___92 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___93 = __txn_set_tx_max(dbenv___0, (unsigned int )v1);
    return (tmp___93);
  }
  tmp___97 = strcasecmp((char const   *)name, "set_txn_timeout");
  if (! tmp___97) {
    tmp___95 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%lu %c",
                      & v1, & v4);
    if (tmp___95 != 1) {
      goto badarg;
    }
    if (v1 > 4294967295UL) {
      __v = v1;
      __max = 4294967295UL;
      goto toobig;
    }
    tmp___96 = __lock_set_env_timeout(dbenv___0, (unsigned int )v1, 33U);
    return (tmp___96);
  }
  tmp___105 = strcasecmp((char const   *)name, "set_verbose");
  if (! tmp___105) {
    tmp___98 = sscanf((char const   * __restrict  )value, (char const   * __restrict  )"%40s %c",
                      arg, & v4);
    if (tmp___98 != 1) {
      goto badarg;
    }
    tmp___103 = strcasecmp((char const   *)value, "db_verb_chkpoint");
    if (tmp___103) {
      tmp___102 = strcasecmp((char const   *)value, "db_verb_deadlock");
      if (tmp___102) {
        tmp___101 = strcasecmp((char const   *)value, "db_verb_recovery");
        if (tmp___101) {
          tmp___100 = strcasecmp((char const   *)value, "db_verb_replication");
          if (tmp___100) {
            tmp___99 = strcasecmp((char const   *)value, "db_verb_waitsfor");
            if (tmp___99) {
              goto badarg;
            } else {
              flags = 16U;
            }
          } else {
            flags = 8U;
          }
        } else {
          flags = 4U;
        }
      } else {
        flags = 2U;
      }
    } else {
      flags = 1U;
    }
    tmp___104 = __dbenv_set_verbose(dbenv___0, flags, 1);
    return (tmp___104);
  }
  __db_err((DB_ENV const   *)dbenv___0, "unrecognized name-value pair: %s", s);
  return (22);
  badarg: 
  __db_err((DB_ENV const   *)dbenv___0, "incorrect arguments for name-value pair: %s",
           s);
  return (22);
  toobig: 
  __db_err((DB_ENV const   *)dbenv___0, "%s: %lu larger than maximum value %lu", s,
           __v, __max);
  return (22);
}
}
static int __db_tmp_open(DB_ENV *dbenv___0 , u_int32_t tmp_oflags , char *path , DB_FH **fhpp ) 
{ u_int32_t id ;
  int mode ;
  int isdir ;
  int ret ;
  char const   *p ;
  char *trv ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  ret = __os_exists((char const   *)path, & isdir);
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", path, tmp);
    return (ret);
  }
  if (! isdir) {
    tmp___0 = db_strerror(22);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", path, tmp___0);
    return (22);
  }
  trv = path;
  while ((int )(*trv) != 0) {
    trv ++;
  }
  (*trv) = (char )(*("/" + 0));
  p = "BDBXXXXX";
  while (1) {
    trv ++;
    (*trv) = (char )(*p);
    if (! ((int )(*trv) != 0)) {
      break;
    }
    p ++;
  }
  __os_id(& id);
  while (1) {
    trv --;
    if (! ((int )(*trv) == 88)) {
      break;
    }
    switch ((int )(id % 10U)) {
    case 0: 
    (*trv) = (char )'0';
    break;
    case 1: 
    (*trv) = (char )'1';
    break;
    case 2: 
    (*trv) = (char )'2';
    break;
    case 3: 
    (*trv) = (char )'3';
    break;
    case 4: 
    (*trv) = (char )'4';
    break;
    case 5: 
    (*trv) = (char )'5';
    break;
    case 6: 
    (*trv) = (char )'6';
    break;
    case 7: 
    (*trv) = (char )'7';
    break;
    case 8: 
    (*trv) = (char )'8';
    break;
    case 9: 
    (*trv) = (char )'9';
    break;
    default: ;
    break;
    }
    id /= 10U;
  }
  trv ++;
  mode = __db_omode("rw----");
  while (1) {
    ret = __os_open(dbenv___0, (char const   *)path, ((tmp_oflags | 1U) | 4U) | 128U,
                    mode, fhpp);
    if (ret == 0) {
      return (0);
    }
    if (ret != 17) {
      tmp___1 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "tmp_open: %s: %s", path, tmp___1);
      return (ret);
    }
    while (1) {
      if ((int )(*trv) == 0) {
        return (22);
      }
      if ((int )(*trv) == 122) {
        tmp___2 = trv;
        trv ++;
        (*tmp___2) = (char )'a';
      } else {
        tmp___3 = __ctype_b_loc();
        if ((int const   )(*((*tmp___3) + (int )(*trv))) & 2048) {
          (*trv) = (char )'a';
        } else {
          (*trv) = (char )((int )(*trv) + 1);
        }
        break;
      }
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-h0tNK37Q.i","-O2")
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
int __env_openfiles(DB_ENV *dbenv___0 , DB_LOGC *logc , void *txninfo , DBT *data ,
                    DB_LSN *open_lsn , DB_LSN *last_lsn , double nfiles , int in_recovery ) ;
static int __log_backup(DB_ENV *dbenv___0 , DB_LOGC *logc , DB_LSN *max_lsn , DB_LSN *start_lsn ) ;
static int __log_earliest(DB_ENV *dbenv___0 , DB_LOGC *logc , int32_t *lowtime , DB_LSN *lowlsn ) ;
static double __lsn_diff(DB_LSN *low , DB_LSN *high , DB_LSN *current , u_int32_t max ,
                         int is_forward ) ;
int __db_apprec(DB_ENV *dbenv___0 , DB_LSN *max_lsn , DB_LSN *trunclsn , u_int32_t update ,
                u_int32_t flags ) 
{ DBT data ;
  DB_LOGC *logc ;
  DB_LSN ckp_lsn ;
  DB_LSN first_lsn ;
  DB_LSN last_lsn ;
  DB_LSN lowlsn ;
  DB_LSN lsn ;
  DB_LSN stop_lsn ;
  DB_REP *db_rep ;
  DB_TXNREGION *region ;
  REP *rep ;
  __txn_ckp_args *ckp_args ;
  time_t now ;
  time_t tlow ;
  int32_t log_size ;
  int32_t low ;
  double nfiles ;
  int have_rec ;
  int is_thread ;
  int progress ;
  int ret ;
  int t_ret ;
  int (**dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ;
  u_int32_t hi_txn ;
  u_int32_t txnid ;
  char *p ;
  char *pass ;
  char t1[60] ;
  char t2[60] ;
  void *txninfo ;
  char *tmp ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  unsigned int tmp___18 ;

  {
  nfiles = (double )0;
  nfiles = nfiles;
  logc = (DB_LOGC *)((void *)0);
  ckp_args = (__txn_ckp_args *)((void *)0);
  dtab = (int (**)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ))((void *)0);
  hi_txn = 4294967295U;
  txninfo = (void *)0;
  pass = (char *)"initial";
  log_size = (int )((LOG *)((DB_LOG *)dbenv___0->lg_handle)->reginfo.primary)->log_size;
  if (dbenv___0->flags & 1048576U) {
    is_thread = 1;
  } else {
    is_thread = 0;
  }
  dbenv___0->flags = dbenv___0->flags & 4293918719U;
  if (update) {
    db_rep = (DB_REP *)dbenv___0->rep_handle;
    if ((unsigned int )db_rep != (unsigned int )((void *)0)) {
      rep = db_rep->region;
      if ((unsigned int )rep != (unsigned int )((void *)0)) {
        time(& rep->timestamp);
      }
    }
  }
  ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags |
                                            1U;
  region = (DB_TXNREGION *)((DB_TXNMGR *)dbenv___0->tx_handle)->reginfo.primary;
  region->flags = region->flags | 1U;
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    lowlsn.file = 0U;
    lowlsn.offset = 0U;
    break;
  }
  if ((unsigned int )max_lsn != (unsigned int )((void *)0)) {
    ret = __log_backup(dbenv___0, logc, max_lsn, & lowlsn);
    if (ret != 0) {
      goto err;
    }
  } else {
    if (dbenv___0->tx_timestamp != 0L) {
      ret = __log_earliest(dbenv___0, logc, & low, & lowlsn);
      if (ret != 0) {
        goto err;
      }
      if ((int )dbenv___0->tx_timestamp < low) {
        tmp = ctime((time_t const   *)(& dbenv___0->tx_timestamp));
        snprintf((char * __restrict  )(t1), sizeof(t1), (char const   * __restrict  )"%s",
                 tmp);
        tmp___4 = __builtin_constant_p((int )(t1));
        if (tmp___4) {
          p = (char *)__builtin_strchr(t1, '\n');
        } else {
          p = (char *)__builtin_strchr(t1, '\n');
        }
        if ((unsigned int )p != (unsigned int )((void *)0)) {
          (*p) = (char )'\000';
        }
        tlow = (long )low;
        tmp___5 = ctime((time_t const   *)(& tlow));
        snprintf((char * __restrict  )(t2), sizeof(t2), (char const   * __restrict  )"%s",
                 tmp___5);
        tmp___10 = __builtin_constant_p((int )(t2));
        if (tmp___10) {
          p = (char *)__builtin_strchr(t2, '\n');
        } else {
          p = (char *)__builtin_strchr(t2, '\n');
        }
        if ((unsigned int )p != (unsigned int )((void *)0)) {
          (*p) = (char )'\000';
        }
        __db_err((DB_ENV const   *)dbenv___0, "Invalid recovery timestamp %s; earliest time is %s",
                 t1, t2);
        ret = 22;
        goto err;
      }
    }
  }
  memset((void *)(& data), 0, sizeof(data));
  ret = __log_c_get(logc, & last_lsn, & data, 17U);
  if (ret != 0) {
    if (ret == -30990) {
      ret = 0;
    } else {
      __db_err((DB_ENV const   *)dbenv___0, "Last log record not found");
    }
    goto err;
  }
  while (1) {
    memcpy((void * __restrict  )(& txnid), (void const   * __restrict  )((u_int8_t *)data.data +
                                                                         sizeof(u_int32_t )),
           sizeof(txnid));
    if (txnid != 0U) {
      break;
    }
    ret = __log_c_get(logc, & lsn, & data, 25U);
    if (! (ret == 0)) {
      break;
    }
  }
  if (ret == -30990) {
    ret = 0;
  } else {
    if (ret != 0) {
      goto err;
    }
  }
  hi_txn = txnid;
  ret = __log_c_get(logc, & ckp_lsn, & data, 9U);
  if (ret != 0) {
    if (ret == -30990) {
      ret = 0;
    } else {
      __db_err((DB_ENV const   *)dbenv___0, "First log record not found");
    }
    goto err;
  }
  first_lsn = ckp_lsn;
  have_rec = 1;
  if (! (flags & 2097152U)) {
    ret = __txn_getckp(dbenv___0, & ckp_lsn);
    if (ret == 0) {
      ret = __log_c_get(logc, & ckp_lsn, & data, 28U);
      if (ret == 0) {
        ret = __txn_ckp_read(dbenv___0, data.data, & ckp_args);
        if (ret != 0) {
          __db_err((DB_ENV const   *)dbenv___0, "Invalid checkpoint record at [%ld][%ld]",
                   (unsigned long )ckp_lsn.file, (unsigned long )ckp_lsn.offset);
          goto err;
        }
        first_lsn = ckp_args->ckp_lsn;
        have_rec = 0;
      }
    }
    if (dbenv___0->tx_timestamp != 0L) {
      goto _L;
    } else {
      if ((unsigned int )max_lsn != (unsigned int )((void *)0)) {
        _L: 
        tmp___11 = log_compare((DB_LSN const   *)(& lowlsn), (DB_LSN const   *)(& first_lsn));
        if (tmp___11 < 0) {
          first_lsn = lowlsn;
        }
      }
    }
  }
  if (! have_rec) {
    ret = __log_c_get(logc, & first_lsn, & data, 28U);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "Checkpoint LSN record [%ld][%ld] not found",
               (unsigned long )first_lsn.file, (unsigned long )first_lsn.offset);
      goto err;
    }
  }
  if ((unsigned int )dbenv___0->db_feedback != (unsigned int )((void *)0)) {
    if (last_lsn.file == first_lsn.file) {
      nfiles = (double )(last_lsn.offset - first_lsn.offset) / (double )log_size;
    } else {
      nfiles = (double )(last_lsn.file - first_lsn.file) + (double )(((unsigned int )log_size -
                                                                      first_lsn.offset) +
                                                                     last_lsn.offset) /
                                                           (double )log_size;
    }
    if (nfiles == (double )0) {
      nfiles = 0.001;
    }
  }
  ret = 0;
  if (hi_txn != 0U) {
    while (1) {
      memcpy((void * __restrict  )(& txnid), (void const   * __restrict  )((u_int8_t *)data.data +
                                                                           sizeof(u_int32_t )),
             sizeof(txnid));
      if (txnid != 0U) {
        break;
      }
      ret = __log_c_get(logc, & lsn, & data, 18U);
      if (! (ret == 0)) {
        break;
      }
    }
  }
  if (ret == -30990) {
    ret = 0;
  }
  if (ret != 0) {
    goto err;
  } else {
    ret = __log_c_get(logc, & first_lsn, & data, 28U);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_txnlist_init(dbenv___0, txnid, hi_txn, max_lsn, (void *)(& txninfo));
  if (ret != 0) {
    goto err;
  }
  ret = __env_openfiles(dbenv___0, logc, txninfo, & data, & first_lsn, & last_lsn,
                        nfiles, 1);
  if (ret != 0) {
    goto err;
  }
  if (hi_txn == 0U) {
    if ((unsigned int )max_lsn == (unsigned int )((void *)0)) {
      goto done;
    }
  }
  if (dbenv___0->verbose & 4U) {
    __db_err((DB_ENV const   *)dbenv___0, "Recovery starting from [%lu][%lu]", (unsigned long )first_lsn.file,
             (unsigned long )first_lsn.offset);
  }
  pass = (char *)"backward";
  ret = __log_c_get(logc, & lsn, & data, 17U);
  while (1) {
    if (ret == 0) {
      tmp___13 = log_compare((DB_LSN const   *)(& lsn), (DB_LSN const   *)(& first_lsn));
      if (! (tmp___13 >= 0)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned int )dbenv___0->db_feedback != (unsigned int )((void *)0)) {
      tmp___12 = __lsn_diff(& first_lsn, & last_lsn, & lsn, (unsigned int )log_size,
                            0);
      progress = 34 + (int )((double )33 * (tmp___12 / nfiles));
      ((*(dbenv___0->db_feedback)))(dbenv___0, 32, progress);
    }
    ret = __db_dispatch(dbenv___0, dbenv___0->recover_dtab, dbenv___0->recover_dtab_size,
                        & data, & lsn, (enum __anonenum_db_recops_55 )3, txninfo);
    if (ret != 0) {
      if (ret != -30892) {
        goto msgerr;
      } else {
        ret = 0;
      }
    }
    ret = __log_c_get(logc, & lsn, & data, 25U);
  }
  if (ret != 0) {
    if (ret != -30990) {
      goto err;
    }
  }
  pass = (char *)"forward";
  stop_lsn = last_lsn;
  if ((unsigned int )max_lsn != (unsigned int )((void *)0)) {
    stop_lsn = ((DB_TXNHEAD *)txninfo)->maxlsn;
  } else {
    if (dbenv___0->tx_timestamp != 0L) {
      stop_lsn = ((DB_TXNHEAD *)txninfo)->maxlsn;
    }
  }
  ret = __log_c_get(logc, & lsn, & data, 18U);
  while (ret == 0) {
    tmp___14 = log_compare((DB_LSN const   *)(& lsn), (DB_LSN const   *)(& stop_lsn));
    if (tmp___14 > 0) {
      break;
    }
    if ((unsigned int )dbenv___0->db_feedback != (unsigned int )((void *)0)) {
      tmp___15 = __lsn_diff(& first_lsn, & last_lsn, & lsn, (unsigned int )log_size,
                            1);
      progress = 67 + (int )((double )33 * (tmp___15 / nfiles));
      ((*(dbenv___0->db_feedback)))(dbenv___0, 32, progress);
    }
    ret = __db_dispatch(dbenv___0, dbenv___0->recover_dtab, dbenv___0->recover_dtab_size,
                        & data, & lsn, (enum __anonenum_db_recops_55 )4, txninfo);
    if (ret != 0) {
      if (ret != -30892) {
        goto msgerr;
      } else {
        ret = 0;
      }
    }
    ret = __log_c_get(logc, & lsn, & data, 18U);
  }
  if (ret != 0) {
    if (ret != -30990) {
      goto err;
    }
  }
  if (dbenv___0->tx_timestamp != 0L) {
    tmp___16 = 3;
  } else {
    tmp___16 = 2;
  }
  ret = __db_do_the_limbo(dbenv___0, (DB_TXN *)((void *)0), (DB_TXN *)((void *)0),
                          (DB_TXNHEAD *)txninfo, (enum __anonenum_db_limbo_state_68 )tmp___16);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )max_lsn == (unsigned int )((void *)0)) {
    region->last_txnid = ((DB_TXNHEAD *)txninfo)->maxid;
  }
  if (dbenv___0->tx_timestamp != 0L) {
    if ((unsigned int )logc != (unsigned int )((void *)0)) {
      ret = __log_c_close(logc);
      if (ret != 0) {
        goto err;
      }
    }
    logc = (DB_LOGC *)((void *)0);
    ret = __memp_sync(dbenv___0, (DB_LSN *)((void *)0));
    if (ret != 0) {
      goto err;
    }
    region->last_ckp = ((DB_TXNHEAD *)txninfo)->ckplsn;
    __log_vtruncate(dbenv___0, & ((DB_TXNHEAD *)txninfo)->maxlsn, & ((DB_TXNHEAD *)txninfo)->ckplsn,
                    trunclsn);
    ret = __db_do_the_limbo(dbenv___0, (DB_TXN *)((void *)0), (DB_TXN *)((void *)0),
                            (DB_TXNHEAD *)txninfo, (enum __anonenum_db_limbo_state_68 )4);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __txn_checkpoint(dbenv___0, 0U, 0U, 4U);
  if (ret != 0) {
    goto err;
  }
  ret = __dbreg_close_files(dbenv___0);
  if (ret != 0) {
    goto err;
  }
  done: 
  if ((unsigned int )max_lsn != (unsigned int )((void *)0)) {
    region->last_ckp = ((DB_TXNHEAD *)txninfo)->ckplsn;
    if ((unsigned int )logc != (unsigned int )((void *)0)) {
      ret = __log_c_close(logc);
      if (ret != 0) {
        goto err;
      }
    }
    __log_vtruncate(dbenv___0, max_lsn, & ((DB_TXNHEAD *)txninfo)->ckplsn, trunclsn);
    ret = __log_cursor(dbenv___0, & logc);
    if (ret != 0) {
      goto err;
    }
    ret = __log_c_get(logc, & first_lsn, & data, 9U);
    if (ret != 0) {
      if (ret == -30990) {
        ret = 0;
      } else {
        __db_err((DB_ENV const   *)dbenv___0, "First log record not found");
      }
      goto err;
    }
    ret = __txn_getckp(dbenv___0, & first_lsn);
    if (ret == 0) {
      ret = __log_c_get(logc, & first_lsn, & data, 28U);
      if (ret == 0) {
        ret = __txn_ckp_read(dbenv___0, data.data, & ckp_args);
        if (ret != 0) {
          __db_err((DB_ENV const   *)dbenv___0, "Invalid checkpoint record at [%ld][%ld]",
                   (unsigned long )first_lsn.file, (unsigned long )first_lsn.offset);
          goto err;
        }
        first_lsn = ckp_args->ckp_lsn;
      }
    }
    ret = __log_c_get(logc, & first_lsn, & data, 28U);
    if (ret != 0) {
      goto err;
    }
    ret = __env_openfiles(dbenv___0, logc, txninfo, & data, & first_lsn, (DB_LSN *)((void *)0),
                          nfiles, 1);
    if (ret != 0) {
      goto err;
    }
  } else {
    if (region->stat.st_nrestores == 0U) {
      ret = __txn_reset(dbenv___0);
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (dbenv___0->verbose & 4U) {
    time(& now);
    tmp___17 = ctime((time_t const   *)(& now));
    __db_err((DB_ENV const   *)dbenv___0, "Recovery complete at %.24s", tmp___17);
    if ((unsigned int )txninfo == (unsigned int )((void *)0)) {
      tmp___18 = 2147483648U;
    } else {
      tmp___18 = ((DB_TXNHEAD *)txninfo)->maxid;
    }
    __db_err((DB_ENV const   *)dbenv___0, "%s %lx %s [%lu][%lu]", "Maximum transaction ID",
             (unsigned long )tmp___18, "Recovery checkpoint", (unsigned long )region->last_ckp.file,
             (unsigned long )region->last_ckp.offset);
  }
  if (0) {
    msgerr: 
    __db_err((DB_ENV const   *)dbenv___0, "Recovery function for LSN %lu %lu failed on %s pass",
             (unsigned long )lsn.file, (unsigned long )lsn.offset, pass);
  }
  err: 
  if ((unsigned int )logc != (unsigned int )((void *)0)) {
    t_ret = __log_c_close(logc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )txninfo != (unsigned int )((void *)0)) {
    __db_txnlist_end(dbenv___0, txninfo);
  }
  if ((unsigned int )dtab != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dtab);
  }
  if ((unsigned int )ckp_args != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)ckp_args);
  }
  dbenv___0->tx_timestamp = 0L;
  if (is_thread) {
    dbenv___0->flags = dbenv___0->flags | 1048576U;
  }
  ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags &
                                            4294967294U;
  region->flags = region->flags & 4294967294U;
  return (ret);
}
}
static double __lsn_diff(DB_LSN *low , DB_LSN *high , DB_LSN *current , u_int32_t max ,
                         int is_forward ) 
{ double nf ;

  {
  if (is_forward) {
    if (current->file == low->file) {
      nf = (double )(current->offset - low->offset) / (double )max;
    } else {
      if (current->offset < low->offset) {
        nf = (double )((current->file - low->file) - 1U) + (double )((max - low->offset) +
                                                                     current->offset) /
                                                           (double )max;
      } else {
        nf = (double )(current->file - low->file) + (double )(current->offset - low->offset) /
                                                    (double )max;
      }
    }
  } else {
    if (current->file == high->file) {
      nf = (double )(high->offset - current->offset) / (double )max;
    } else {
      if (current->offset > high->offset) {
        nf = (double )((high->file - current->file) - 1U) + (double )((max - current->offset) +
                                                                      high->offset) /
                                                            (double )max;
      } else {
        nf = (double )(high->file - current->file) + (double )(high->offset - current->offset) /
                                                     (double )max;
      }
    }
  }
  return (nf);
}
}
static int __log_backup(DB_ENV *dbenv___0 , DB_LOGC *logc , DB_LSN *max_lsn , DB_LSN *start_lsn ) 
{ DB_LSN lsn ;
  DBT data ;
  __txn_ckp_args *ckp_args ;
  int ret ;
  int tmp ;

  {
  memset((void *)(& data), 0, sizeof(data));
  ckp_args = (__txn_ckp_args *)((void *)0);
  ret = __txn_getckp(dbenv___0, & lsn);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    ret = __log_c_get(logc, & lsn, & data, 28U);
    if (! (ret == 0)) {
      break;
    }
    ret = __txn_ckp_read(dbenv___0, data.data, & ckp_args);
    if (ret != 0) {
      return (ret);
    }
    tmp = log_compare((DB_LSN const   *)(& ckp_args->ckp_lsn), (DB_LSN const   *)max_lsn);
    if (tmp <= 0) {
      (*start_lsn) = ckp_args->ckp_lsn;
      break;
    }
    lsn = ckp_args->last_ckp;
    if (lsn.file == 0U) {
      break;
    }
    __os_free(dbenv___0, (void *)ckp_args);
  }
  if ((unsigned int )ckp_args != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)ckp_args);
  }
  err: 
  if (start_lsn->file == 0U) {
    if (ret == 0) {
      ret = __log_c_get(logc, start_lsn, & data, 9U);
    } else {
      if (ret == -30990) {
        ret = __log_c_get(logc, start_lsn, & data, 9U);
      }
    }
  }
  return (ret);
}
}
static int __log_earliest(DB_ENV *dbenv___0 , DB_LOGC *logc , int32_t *lowtime , DB_LSN *lowlsn ) 
{ DB_LSN first_lsn ;
  DB_LSN lsn ;
  DBT data ;
  __txn_ckp_args *ckpargs ;
  u_int32_t rectype ;
  int cmp ;
  int ret ;

  {
  memset((void *)(& data), 0, sizeof(data));
  ret = __log_c_get(logc, & first_lsn, & data, 9U);
  while (ret == 0) {
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )data.data,
           sizeof(rectype));
    if (rectype != 11U) {
      goto __Cont;
    }
    ret = __txn_ckp_read(dbenv___0, data.data, & ckpargs);
    if (ret == 0) {
      cmp = log_compare((DB_LSN const   *)(& ckpargs->ckp_lsn), (DB_LSN const   *)(& first_lsn));
      (*lowlsn) = ckpargs->ckp_lsn;
      (*lowtime) = ckpargs->timestamp;
      __os_free(dbenv___0, (void *)ckpargs);
      if (cmp >= 0) {
        break;
      }
    }
    __Cont: 
    ret = __log_c_get(logc, & lsn, & data, 18U);
  }
  return (ret);
}
}
int __env_openfiles(DB_ENV *dbenv___0 , DB_LOGC *logc , void *txninfo , DBT *data ,
                    DB_LSN *open_lsn , DB_LSN *last_lsn , double nfiles , int in_recovery ) 
{ DB_LSN lsn ;
  u_int32_t log_size ;
  int progress ;
  int ret ;
  double tmp ;
  int tmp___0 ;

  {
  log_size = ((LOG *)((DB_LOG *)dbenv___0->lg_handle)->reginfo.primary)->log_size;
  lsn = (*open_lsn);
  while (1) {
    if (in_recovery) {
      if ((unsigned int )dbenv___0->db_feedback != (unsigned int )((void *)0)) {
        tmp = __lsn_diff(open_lsn, last_lsn, & lsn, log_size, 1);
        progress = (int )((double )33 * (tmp / nfiles));
        ((*(dbenv___0->db_feedback)))(dbenv___0, 32, progress);
      }
    }
    if (in_recovery) {
      tmp___0 = 6;
    } else {
      tmp___0 = 7;
    }
    ret = __db_dispatch(dbenv___0, dbenv___0->recover_dtab, dbenv___0->recover_dtab_size,
                        data, & lsn, (enum __anonenum_db_recops_55 )tmp___0, txninfo);
    if (ret != 0) {
      if (ret != -30892) {
        __db_err((DB_ENV const   *)dbenv___0, "Recovery function for LSN %lu %lu failed",
                 (unsigned long )lsn.file, (unsigned long )lsn.offset);
        break;
      }
    }
    ret = __log_c_get(logc, & lsn, data, 18U);
    if (ret != 0) {
      if (ret == -30990) {
        ret = 0;
      }
      break;
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-97Ud2W76.i","-O2")
int __db_e_stat(DB_ENV *dbenv___0 , REGENV *arg_renv , REGION *arg_regions , int *arg_regions_cnt ,
                u_int32_t flags ) ;
int __db_r_attach(DB_ENV *dbenv___0 , REGINFO *infop , size_t size ) ;
int __db_r_detach(DB_ENV *dbenv___0 , REGINFO *infop , int destroy ) ;
int __os_r_attach(DB_ENV *dbenv___0 , REGINFO *infop , REGION *rp ) ;
int __os_r_detach(DB_ENV *dbenv___0 , REGINFO *infop , int destroy ) ;
void __lock_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) ;
void __log_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) ;
void __mpool_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) ;
void __txn_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) ;
static int __db_des_destroy(DB_ENV *dbenv___0 , REGION *rp , int shmem_safe ) ;
static int __db_des_get(DB_ENV *dbenv___0 , REGINFO *env_infop , REGINFO *infop ,
                        REGION **rpp ) ;
static int __db_e_remfile(DB_ENV *dbenv___0 ) ;
static int __db_faultmem(DB_ENV *dbenv___0 , void *addr , size_t size , int created ) ;
static void __db_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) ;
int __db_e_attach(DB_ENV *dbenv___0 , u_int32_t *init_flagsp ) 
{ REGENV *renv ;
  REGENV_REF ref ;
  REGINFO *infop ;
  REGION *rp ;
  REGION tregion ;
  size_t size ;
  size_t nrw ;
  u_int32_t mbytes ;
  u_int32_t bytes ;
  int retry_cnt ;
  int ret ;
  int segid ;
  char buf[(int )(sizeof("__db.%03d") + 20U)] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  retry_cnt = 0;
  loop: 
  renv = (REGENV *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(REGINFO ), (void *)(& infop));
  if (ret != 0) {
    return (ret);
  }
  infop->type = (enum __anonenum_reg_type_50 )1;
  infop->id = 1U;
  infop->mode = dbenv___0->db_mode;
  infop->flags = 4U;
  if (dbenv___0->flags & 8U) {
    infop->flags = infop->flags | 2U;
  }
  if (dbenv___0->flags & 32768U) {
    ret = __os_strdup(dbenv___0, "process-private", (void *)(& infop->name));
    if (ret != 0) {
      goto err;
    }
    goto creation;
  }
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s",
           "__db.001");
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )0, (char const   *)(buf),
                     0U, (DB_FH **)((void *)0), & infop->name);
  if (ret != 0) {
    goto err;
  }
  if (dbenv___0->flags & 8U) {
    ret = __os_open(dbenv___0, (char const   *)infop->name, 39U, dbenv___0->db_mode,
                    & dbenv___0->lockfhp);
    if (ret == 0) {
      goto creation;
    }
    if (ret != 17) {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", infop->name, tmp);
      goto err;
    }
  }
  ret = __os_open(dbenv___0, (char const   *)infop->name, 34U, dbenv___0->db_mode,
                  & dbenv___0->lockfhp);
  if (ret != 0) {
    goto err;
  }
  infop->flags = infop->flags & 4294967293U;
  ret = __os_ioinfo(dbenv___0, (char const   *)infop->name, dbenv___0->lockfhp, & mbytes,
                    & bytes, (u_int32_t *)((void *)0));
  if (ret != 0) {
    tmp___0 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", infop->name, tmp___0);
    goto err;
  }
  size = mbytes * 1048576U + bytes;
  if (size <= sizeof(ref)) {
    if (size != sizeof(ref)) {
      goto err;
    }
    ret = __os_read(dbenv___0, dbenv___0->lockfhp, (void *)(& ref), sizeof(ref), & nrw);
    if (ret != 0) {
      goto _L;
    } else {
      if (nrw < sizeof(ref)) {
        _L: 
        if (ret == 0) {
          ret = 5;
        }
        tmp___1 = db_strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "%s: unable to read system-memory information from: %s",
                 infop->name, tmp___1);
        goto err;
      }
    }
    size = ref.size;
    segid = (int )ref.segid;
    dbenv___0->flags = dbenv___0->flags | 524288U;
  } else {
    if (dbenv___0->flags & 524288U) {
      ret = 22;
      tmp___2 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: existing environment not created in system memory: %s",
               infop->name, tmp___2);
      goto err;
    } else {
      segid = -1;
    }
  }
  __os_closehandle(dbenv___0, dbenv___0->lockfhp);
  dbenv___0->lockfhp = (DB_FH *)((void *)0);
  memset((void *)(& tregion), 0, sizeof(tregion));
  tregion.size = size;
  tregion.segid = (long )segid;
  ret = __os_r_attach(dbenv___0, infop, & tregion);
  if (ret != 0) {
    goto err;
  }
  infop->primary = (void *)((u_int8_t *)infop->addr + 0);
  infop->addr = (void *)((u_int8_t *)infop->addr + sizeof(REGENV ));
  renv = (REGENV *)infop->primary;
  if (renv->majver != 4) {
    __db_err((DB_ENV const   *)dbenv___0, "Program version %d.%d doesn\'t match environment version",
             4, 2);
    ret = 22;
    goto err;
  } else {
    if (renv->minver != 2) {
      __db_err((DB_ENV const   *)dbenv___0, "Program version %d.%d doesn\'t match environment version",
               4, 2);
      ret = 22;
      goto err;
    }
  }
  if (renv->envpanic) {
    if (! (dbenv___0->flags & 4096U)) {
      ret = __db_panic_msg(dbenv___0);
      goto err;
    }
  }
  if (renv->magic != 1181847U) {
    goto err;
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  if (renv->envpanic) {
    if (! (dbenv___0->flags & 4096U)) {
      ret = __db_panic_msg(dbenv___0);
      goto err_unlock;
    }
  }
  ret = __db_des_get(dbenv___0, infop, infop, & rp);
  if (ret != 0) {
    goto _L___0;
  } else {
    if ((unsigned int )rp == (unsigned int )((void *)0)) {
      _L___0: 
      if (! (renv->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
      }
      goto find_err;
    }
  }
  infop->rp = rp;
  if (rp->size != size) {
    err_unlock: 
    if (! (renv->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
    }
    goto err;
  }
  renv->refcnt = renv->refcnt + 1U;
  if ((unsigned int )init_flagsp != (unsigned int )((void *)0)) {
    (*init_flagsp) = renv->init_flags;
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  __db_faultmem(dbenv___0, infop->primary, rp->size, 0);
  dbenv___0->reginfo = (void *)infop;
  return (0);
  creation: 
  infop->flags = infop->flags | 1U;
  memset((void *)(& tregion), 0, sizeof(tregion));
  tregion.size = (50U * sizeof(REGION ) + dbenv___0->passwd_len) + 2048U;
  tregion.segid = -1L;
  ret = __os_r_attach(dbenv___0, infop, & tregion);
  if (ret != 0) {
    goto err;
  }
  __db_faultmem(dbenv___0, infop->addr, tregion.size, 1);
  infop->primary = (void *)((u_int8_t *)infop->addr + 0);
  infop->addr = (void *)((u_int8_t *)infop->addr + sizeof(REGENV ));
  __db_shalloc_init(infop->addr, tregion.size - sizeof(REGENV ));
  renv = (REGENV *)infop->primary;
  renv->envpanic = 0;
  db_version(& renv->majver, & renv->minver, & renv->patch);
  renv->regionq.slh_first = -1;
  renv->refcnt = 1U;
  renv->cipher_off = 0U;
  renv->rep_off = 0U;
  if ((unsigned int )init_flagsp == (unsigned int )((void *)0)) {
    renv->init_flags = 0U;
  } else {
    renv->init_flags = (*init_flagsp);
  }
  ret = __db_mutex_setup(dbenv___0, infop, (void *)(& renv->mutex), 96U);
  if (ret != 0) {
    tmp___3 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: unable to initialize environment lock: %s",
             infop->name, tmp___3);
    goto err;
  }
  if (! (renv->mutex.flags & 2U)) {
    ret = __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
    if (ret != 0) {
      tmp___4 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: unable to acquire environment lock: %s",
               infop->name, tmp___4);
      goto err;
    }
  }
  ret = __db_des_get(dbenv___0, infop, infop, & rp);
  if (ret != 0) {
    find_err: 
    __db_err((DB_ENV const   *)dbenv___0, "%s: unable to find environment", infop->name);
    if (ret == 0) {
      ret = 22;
    }
    goto err;
  }
  infop->rp = rp;
  rp->size = tregion.size;
  rp->segid = tregion.segid;
  if (tregion.segid != -1L) {
    ref.size = tregion.size;
    ref.segid = tregion.segid;
    ret = __os_write(dbenv___0, dbenv___0->lockfhp, (void *)(& ref), sizeof(ref),
                     & nrw);
    if (ret != 0) {
      tmp___5 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: unable to write out public environment ID: %s",
               infop->name, tmp___5);
      goto err;
    }
  }
  if ((unsigned int )dbenv___0->lockfhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, dbenv___0->lockfhp);
    dbenv___0->lockfhp = (DB_FH *)((void *)0);
  }
  renv->magic = 1181847U;
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  dbenv___0->reginfo = (void *)infop;
  return (0);
  err: 
  if ((unsigned int )dbenv___0->lockfhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, dbenv___0->lockfhp);
    dbenv___0->lockfhp = (DB_FH *)((void *)0);
  }
  if ((unsigned int )infop->addr != (unsigned int )((void *)0)) {
    if ((unsigned int )infop->rp == (unsigned int )((void *)0)) {
      infop->rp = & tregion;
    }
    infop->addr = infop->primary;
    __os_r_detach(dbenv___0, infop, (int )(infop->flags & 1U));
  }
  if ((unsigned int )infop->name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)infop->name);
  }
  __os_free(dbenv___0, (void *)infop);
  if (ret == 0) {
    retry_cnt ++;
    if (retry_cnt > 3) {
      __db_err((DB_ENV const   *)dbenv___0, "unable to join the environment");
      ret = 11;
    } else {
      __os_sleep(dbenv___0, (unsigned long )(retry_cnt * 3), 0UL);
      goto loop;
    }
  }
  return (ret);
}
}
int __db_e_detach(DB_ENV *dbenv___0 , int destroy ) 
{ REGENV *renv ;
  REGINFO *infop ;

  {
  infop = (REGINFO *)dbenv___0->reginfo;
  renv = (REGENV *)infop->primary;
  if (dbenv___0->flags & 32768U) {
    destroy = 1;
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  if (renv->refcnt == 0U) {
    __db_err((DB_ENV const   *)dbenv___0, "region %lu (environment): reference count went negative",
             (unsigned long )(infop->rp)->id);
  } else {
    renv->refcnt = renv->refcnt - 1U;
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  if ((unsigned int )dbenv___0->lockfhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, dbenv___0->lockfhp);
    dbenv___0->lockfhp = (DB_FH *)((void *)0);
  }
  infop->addr = infop->primary;
  if (destroy) {
    __rep_region_destroy(dbenv___0);
    __db_pthread_mutex_destroy(& renv->mutex);
    __db_pthread_mutex_destroy(& (infop->rp)->mutex);
  }
  __os_r_detach(dbenv___0, infop, destroy);
  if ((unsigned int )infop->name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)infop->name);
  }
  __os_free(dbenv___0, dbenv___0->reginfo);
  dbenv___0->reginfo = (void *)0;
  return (0);
}
}
int __db_e_remove(DB_ENV *dbenv___0 , u_int32_t flags ) 
{ REGENV *renv ;
  REGINFO *infop ;
  REGINFO reginfo ;
  REGION *rp ;
  u_int32_t db_env_reset ;
  int force ;
  int ret ;
  int tmp ;

  {
  if (flags & 4U) {
    force = 1;
  } else {
    force = 0;
  }
  db_env_reset = dbenv___0->flags & 5120U;
  if (force) {
    dbenv___0->flags = dbenv___0->flags | 1024U;
  }
  dbenv___0->flags = dbenv___0->flags | 4096U;
  ret = __db_e_attach(dbenv___0, (u_int32_t *)((void *)0));
  if (ret != 0) {
    ret = 0;
    if (force) {
      goto remfiles;
    }
    goto done;
  }
  infop = (REGINFO *)dbenv___0->reginfo;
  renv = (REGENV *)infop->primary;
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  if (renv->refcnt == 1U) {
    goto _L;
  } else {
    if (renv->envpanic == 1) {
      goto _L;
    } else {
      if (force) {
        _L: 
        renv->envpanic = 1;
        renv->magic = 0U;
        if (! (renv->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
        }
        memset((void *)(& reginfo), 0, sizeof(reginfo));
        if (renv->regionq.slh_first == -1) {
          rp = (REGION *)((void *)0);
        } else {
          rp = (struct __db_region *)((u_int8_t *)(& renv->regionq) + renv->regionq.slh_first);
        }
        while ((unsigned int )rp != (unsigned int )((void *)0)) {
          if ((int )rp->type == 1) {
            goto __Cont;
          }
          reginfo.id = rp->id;
          reginfo.flags = 2U;
          tmp = __db_r_attach(dbenv___0, & reginfo, 0U);
          if (tmp == 0) {
            if (! ((reginfo.rp)->mutex.flags & 2U)) {
              __db_pthread_mutex_unlock(dbenv___0, & (reginfo.rp)->mutex);
            }
            __db_r_detach(dbenv___0, & reginfo, 1);
          }
          __Cont: 
          if (rp->q.sle_next == -1) {
            rp = (REGION *)((void *)0);
          } else {
            rp = (struct __db_region *)((u_int8_t *)rp + rp->q.sle_next);
          }
        }
        __db_e_detach(dbenv___0, 1);
        remfiles: 
        __db_e_remfile(dbenv___0);
      } else {
        if (! (renv->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
        }
        __db_e_detach(dbenv___0, 0);
        ret = 16;
      }
    }
  }
  done: 
  dbenv___0->flags = dbenv___0->flags & 4294962175U;
  dbenv___0->flags = dbenv___0->flags | db_env_reset;
  return (ret);
}
}
static int __db_e_remfile(DB_ENV *dbenv___0 ) 
{ int cnt ;
  int fcnt ;
  int lastrm ;
  int ret ;
  u_int8_t saved_byte ;
  char const   *dir ;
  char *p ;
  char **names ;
  char *path ;
  char buf[(int )(sizeof("__db.%03d") + 20U)] ;
  char *tmp ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;
  int tmp___224 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___260 ;
  unsigned char const   *__s2___30 ;
  register int __result___90 ;
  int tmp___279 ;
  unsigned char const   *__s1___62 ;
  register int __result___94 ;
  int tmp___288 ;
  int tmp___289 ;
  int tmp___290 ;
  int tmp___291 ;
  int tmp___292 ;
  int tmp___293 ;
  int tmp___294 ;
  size_t tmp___295 ;
  int tmp___296 ;
  size_t tmp___297 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___333 ;
  unsigned char const   *__s2___38 ;
  register int __result___114 ;
  int tmp___352 ;
  unsigned char const   *__s1___78 ;
  register int __result___118 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___366 ;
  size_t tmp___367 ;
  int tmp___368 ;
  int tmp___369 ;

  {
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s",
           "__db.001");
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )0, (char const   *)(buf),
                     0U, (DB_FH **)((void *)0), & path);
  if (ret != 0) {
    return (ret);
  }
  p = __db_rpath((char const   *)path);
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    p = path;
    saved_byte = (unsigned char )(*p);
    dir = ".";
  } else {
    saved_byte = (unsigned char )(*p);
    (*p) = (char )'\000';
    dir = (char const   *)path;
  }
  ret = __os_dirlist(dbenv___0, dir, & names, & fcnt);
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", dir, tmp);
  }
  (*p) = (char )saved_byte;
  __os_free(dbenv___0, (void *)path);
  if (ret != 0) {
    return (ret);
  }
  lastrm = -1;
  cnt = fcnt;
  while (1) {
    cnt --;
    if (! (cnt >= 0)) {
      break;
    }
    tmp___145 = __builtin_constant_p((int )(sizeof("__db") - 1U));
    if (tmp___145) {
      tmp___146 = __builtin_constant_p((int )(*(names + cnt)));
      if (tmp___146) {
        tmp___147 = strlen((char const   *)(*(names + cnt)));
        if (tmp___147 < sizeof("__db") - 1U) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
        tmp___148 = __builtin_constant_p((int )"__db");
        if (tmp___148) {
          tmp___149 = strlen("__db");
          if (tmp___149 < sizeof("__db") - 1U) {
            _L___39: 
            tmp___142 = __builtin_constant_p((int )(*(names + cnt)));
            if (tmp___142) {
              tmp___143 = __builtin_constant_p((int )"__db");
              if (tmp___143) {
                __s1_len___0 = strlen((char const   *)(*(names + cnt)));
                __s2_len___0 = strlen("__db");
                if (! ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                    cnt))) ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)("__db" + 1)) - (unsigned int )((void const   *)"__db") ==
                           1U)) {
                      tmp___144 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___144 = 1;
                      } else {
                        tmp___144 = 0;
                      }
                    }
                  } else {
                    tmp___144 = 0;
                  }
                }
                if (tmp___144) {
                  tmp___111 = __builtin_strcmp((*(names + cnt)), "__db");
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___141 = __builtin_constant_p((int )(*(names + cnt)));
              if (tmp___141) {
                if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                 cnt))) ==
                    1U) {
                  __s1_len___0 = strlen((char const   *)(*(names + cnt)));
                  if (__s1_len___0 < 4U) {
                    tmp___130 = __builtin_constant_p((int )"__db");
                    if (tmp___130) {
                      if ((unsigned int )((void const   *)("__db" + 1)) - (unsigned int )((void const   *)"__db") ==
                          1U) {
                        tmp___111 = __builtin_strcmp((*(names + cnt)), "__db");
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)"__db";
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                           cnt))) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                               cnt))) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                   cnt))) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                       cnt))) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___111 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___140 = __builtin_constant_p((int )"__db");
                if (tmp___140) {
                  if ((unsigned int )((void const   *)("__db" + 1)) - (unsigned int )((void const   *)"__db") ==
                      1U) {
                    __s2_len___0 = strlen("__db");
                    if (__s2_len___0 < 4U) {
                      tmp___139 = __builtin_constant_p((int )(*(names + cnt)));
                      if (tmp___139) {
                        if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) -
                            (unsigned int )((void const   *)(*(names + cnt))) == 1U) {
                          tmp___111 = __builtin_strcmp((*(names + cnt)), "__db");
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)((char const   *)(*(names +
                                                                                 cnt)));
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)"__db" +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"__db" +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"__db" +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"__db" +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___111 = __result___46;
                      }
                    } else {
                      tmp___111 = __builtin_strcmp((*(names + cnt)), "__db");
                    }
                  } else {
                    tmp___111 = __builtin_strcmp((*(names + cnt)), "__db");
                  }
                } else {
                  tmp___111 = __builtin_strcmp((*(names + cnt)), "__db");
                }
              }
            }
            tmp___75 = tmp___111;
          } else {
            tmp___75 = strncmp((char const   *)(*(names + cnt)), "__db", sizeof("__db") -
                                                                         1U);
          }
        } else {
          tmp___75 = strncmp((char const   *)(*(names + cnt)), "__db", sizeof("__db") -
                                                                       1U);
        }
      }
    } else {
      tmp___75 = strncmp((char const   *)(*(names + cnt)), "__db", sizeof("__db") -
                                                                   1U);
    }
    if (tmp___75) {
      goto __Cont;
    }
    tmp___294 = __builtin_constant_p((int )(*(names + cnt)));
    if (tmp___294) {
      tmp___295 = strlen((char const   *)(*(names + cnt)));
      if (tmp___295 < 6U) {
        goto _L___81;
      } else {
        goto _L___82;
      }
    } else {
      _L___82: 
      tmp___296 = __builtin_constant_p((int )"__dbq.");
      if (tmp___296) {
        tmp___297 = strlen("__dbq.");
        if (tmp___297 < 6U) {
          _L___81: 
          tmp___291 = __builtin_constant_p((int )(*(names + cnt)));
          if (tmp___291) {
            tmp___292 = __builtin_constant_p((int )"__dbq.");
            if (tmp___292) {
              __s1_len___2 = strlen((char const   *)(*(names + cnt)));
              __s2_len___2 = strlen("__dbq.");
              if (! ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                  cnt))) ==
                     1U)) {
                goto _L___78;
              } else {
                if (__s1_len___2 >= 4U) {
                  _L___78: 
                  if (! ((unsigned int )((void const   *)("__dbq." + 1)) - (unsigned int )((void const   *)"__dbq.") ==
                         1U)) {
                    tmp___293 = 1;
                  } else {
                    if (__s2_len___2 >= 4U) {
                      tmp___293 = 1;
                    } else {
                      tmp___293 = 0;
                    }
                  }
                } else {
                  tmp___293 = 0;
                }
              }
              if (tmp___293) {
                tmp___260 = __builtin_strcmp((*(names + cnt)), "__dbq.");
              } else {
                goto _L___80;
              }
            } else {
              goto _L___80;
            }
          } else {
            _L___80: 
            tmp___290 = __builtin_constant_p((int )(*(names + cnt)));
            if (tmp___290) {
              if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                               cnt))) ==
                  1U) {
                __s1_len___2 = strlen((char const   *)(*(names + cnt)));
                if (__s1_len___2 < 4U) {
                  tmp___279 = __builtin_constant_p((int )"__dbq.");
                  if (tmp___279) {
                    if ((unsigned int )((void const   *)("__dbq." + 1)) - (unsigned int )((void const   *)"__dbq.") ==
                        1U) {
                      tmp___260 = __builtin_strcmp((*(names + cnt)), "__dbq.");
                    } else {
                      goto _L___73;
                    }
                  } else {
                    _L___73: 
                    __s2___30 = (unsigned char const   *)"__dbq.";
                    __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                         cnt))) +
                                                            0)) - (int const   )(*(__s2___30 +
                                                                                   0)));
                    if (__s1_len___2 > 0U) {
                      if (__result___90 == 0) {
                        __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                             cnt))) +
                                                                1)) - (int const   )(*(__s2___30 +
                                                                                       1)));
                        if (__s1_len___2 > 1U) {
                          if (__result___90 == 0) {
                            __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                 cnt))) +
                                                                    2)) - (int const   )(*(__s2___30 +
                                                                                           2)));
                            if (__s1_len___2 > 2U) {
                              if (__result___90 == 0) {
                                __result___90 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                     cnt))) +
                                                                        3)) - (int const   )(*(__s2___30 +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___260 = __result___90;
                  }
                } else {
                  goto _L___77;
                }
              } else {
                goto _L___77;
              }
            } else {
              _L___77: 
              tmp___289 = __builtin_constant_p((int )"__dbq.");
              if (tmp___289) {
                if ((unsigned int )((void const   *)("__dbq." + 1)) - (unsigned int )((void const   *)"__dbq.") ==
                    1U) {
                  __s2_len___2 = strlen("__dbq.");
                  if (__s2_len___2 < 4U) {
                    tmp___288 = __builtin_constant_p((int )(*(names + cnt)));
                    if (tmp___288) {
                      if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) -
                          (unsigned int )((void const   *)(*(names + cnt))) == 1U) {
                        tmp___260 = __builtin_strcmp((*(names + cnt)), "__dbq.");
                      } else {
                        goto _L___75;
                      }
                    } else {
                      _L___75: 
                      __s1___62 = (unsigned char const   *)((char const   *)(*(names +
                                                                               cnt)));
                      __result___94 = (int )((int const   )(*(__s1___62 + 0)) - (int const   )(*((unsigned char const   *)"__dbq." +
                                                                                                 0)));
                      if (__s2_len___2 > 0U) {
                        if (__result___94 == 0) {
                          __result___94 = (int )((int const   )(*(__s1___62 + 1)) -
                                                 (int const   )(*((unsigned char const   *)"__dbq." +
                                                                  1)));
                          if (__s2_len___2 > 1U) {
                            if (__result___94 == 0) {
                              __result___94 = (int )((int const   )(*(__s1___62 +
                                                                      2)) - (int const   )(*((unsigned char const   *)"__dbq." +
                                                                                             2)));
                              if (__s2_len___2 > 2U) {
                                if (__result___94 == 0) {
                                  __result___94 = (int )((int const   )(*(__s1___62 +
                                                                          3)) - (int const   )(*((unsigned char const   *)"__dbq." +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___260 = __result___94;
                    }
                  } else {
                    tmp___260 = __builtin_strcmp((*(names + cnt)), "__dbq.");
                  }
                } else {
                  tmp___260 = __builtin_strcmp((*(names + cnt)), "__dbq.");
                }
              } else {
                tmp___260 = __builtin_strcmp((*(names + cnt)), "__dbq.");
              }
            }
          }
          tmp___224 = tmp___260;
        } else {
          tmp___224 = strncmp((char const   *)(*(names + cnt)), "__dbq.", 6U);
        }
      } else {
        tmp___224 = strncmp((char const   *)(*(names + cnt)), "__dbq.", 6U);
      }
    }
    if (tmp___224 == 0) {
      goto __Cont;
    }
    tmp___364 = __builtin_constant_p((int )(*(names + cnt)));
    if (tmp___364) {
      tmp___365 = __builtin_constant_p((int )"__db.001");
      if (tmp___365) {
        __s1_len___3 = strlen((char const   *)(*(names + cnt)));
        __s2_len___3 = strlen("__db.001");
        if (! ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                            cnt))) ==
               1U)) {
          goto _L___100;
        } else {
          if (__s1_len___3 >= 4U) {
            _L___100: 
            if (! ((unsigned int )((void const   *)("__db.001" + 1)) - (unsigned int )((void const   *)"__db.001") ==
                   1U)) {
              tmp___366 = 1;
            } else {
              if (__s2_len___3 >= 4U) {
                tmp___366 = 1;
              } else {
                tmp___366 = 0;
              }
            }
          } else {
            tmp___366 = 0;
          }
        }
        if (tmp___366) {
          tmp___333 = __builtin_strcmp((*(names + cnt)), "__db.001");
        } else {
          goto _L___102;
        }
      } else {
        goto _L___102;
      }
    } else {
      _L___102: 
      tmp___363 = __builtin_constant_p((int )(*(names + cnt)));
      if (tmp___363) {
        if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                         cnt))) ==
            1U) {
          __s1_len___3 = strlen((char const   *)(*(names + cnt)));
          if (__s1_len___3 < 4U) {
            tmp___352 = __builtin_constant_p((int )"__db.001");
            if (tmp___352) {
              if ((unsigned int )((void const   *)("__db.001" + 1)) - (unsigned int )((void const   *)"__db.001") ==
                  1U) {
                tmp___333 = __builtin_strcmp((*(names + cnt)), "__db.001");
              } else {
                goto _L___95;
              }
            } else {
              _L___95: 
              __s2___38 = (unsigned char const   *)"__db.001";
              __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                    cnt))) +
                                                       0)) - (int const   )(*(__s2___38 +
                                                                              0)));
              if (__s1_len___3 > 0U) {
                if (__result___114 == 0) {
                  __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                        cnt))) +
                                                           1)) - (int const   )(*(__s2___38 +
                                                                                  1)));
                  if (__s1_len___3 > 1U) {
                    if (__result___114 == 0) {
                      __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                            cnt))) +
                                                               2)) - (int const   )(*(__s2___38 +
                                                                                      2)));
                      if (__s1_len___3 > 2U) {
                        if (__result___114 == 0) {
                          __result___114 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                cnt))) +
                                                                   3)) - (int const   )(*(__s2___38 +
                                                                                          3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___333 = __result___114;
            }
          } else {
            goto _L___99;
          }
        } else {
          goto _L___99;
        }
      } else {
        _L___99: 
        tmp___362 = __builtin_constant_p((int )"__db.001");
        if (tmp___362) {
          if ((unsigned int )((void const   *)("__db.001" + 1)) - (unsigned int )((void const   *)"__db.001") ==
              1U) {
            __s2_len___3 = strlen("__db.001");
            if (__s2_len___3 < 4U) {
              tmp___361 = __builtin_constant_p((int )(*(names + cnt)));
              if (tmp___361) {
                if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                 cnt))) ==
                    1U) {
                  tmp___333 = __builtin_strcmp((*(names + cnt)), "__db.001");
                } else {
                  goto _L___97;
                }
              } else {
                _L___97: 
                __s1___78 = (unsigned char const   *)((char const   *)(*(names + cnt)));
                __result___118 = (int )((int const   )(*(__s1___78 + 0)) - (int const   )(*((unsigned char const   *)"__db.001" +
                                                                                            0)));
                if (__s2_len___3 > 0U) {
                  if (__result___118 == 0) {
                    __result___118 = (int )((int const   )(*(__s1___78 + 1)) - (int const   )(*((unsigned char const   *)"__db.001" +
                                                                                                1)));
                    if (__s2_len___3 > 1U) {
                      if (__result___118 == 0) {
                        __result___118 = (int )((int const   )(*(__s1___78 + 2)) -
                                                (int const   )(*((unsigned char const   *)"__db.001" +
                                                                 2)));
                        if (__s2_len___3 > 2U) {
                          if (__result___118 == 0) {
                            __result___118 = (int )((int const   )(*(__s1___78 + 3)) -
                                                    (int const   )(*((unsigned char const   *)"__db.001" +
                                                                     3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___333 = __result___118;
              }
            } else {
              tmp___333 = __builtin_strcmp((*(names + cnt)), "__db.001");
            }
          } else {
            tmp___333 = __builtin_strcmp((*(names + cnt)), "__db.001");
          }
        } else {
          tmp___333 = __builtin_strcmp((*(names + cnt)), "__db.001");
        }
      }
    }
    if (tmp___333 == 0) {
      lastrm = cnt;
      goto __Cont;
    }
    tmp___368 = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )0, (char const   *)(*(names +
                                                                                           cnt)),
                             0U, (DB_FH **)((void *)0), & path);
    if (tmp___368 == 0) {
      if (dbenv___0->flags & 16384U) {
        tmp___367 = strlen((char const   *)(*(names + cnt)));
        if (tmp___367 == 8U) {
          __db_overwrite(dbenv___0, (char const   *)path);
        }
      }
      __os_unlink(dbenv___0, (char const   *)path);
      __os_free(dbenv___0, (void *)path);
    }
    __Cont: ;
  }
  if (lastrm != -1) {
    tmp___369 = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )0, (char const   *)(*(names +
                                                                                           lastrm)),
                             0U, (DB_FH **)((void *)0), & path);
    if (tmp___369 == 0) {
      if (dbenv___0->flags & 16384U) {
        __db_overwrite(dbenv___0, (char const   *)path);
      }
      __os_unlink(dbenv___0, (char const   *)path);
      __os_free(dbenv___0, (void *)path);
    }
  }
  __os_dirfree(dbenv___0, names, fcnt);
  return (0);
}
}
int __db_e_stat(DB_ENV *dbenv___0 , REGENV *arg_renv , REGION *arg_regions , int *arg_regions_cnt ,
                u_int32_t flags ) 
{ REGENV *renv ;
  REGINFO *infop ;
  REGION *rp ;
  int n ;
  int ret ;

  {
  infop = (REGINFO *)dbenv___0->reginfo;
  renv = (REGENV *)infop->primary;
  rp = infop->rp;
  ret = __db_fchk(dbenv___0, "DB_ENV->stat", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  if (! (rp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & rp->mutex);
  }
  (*arg_renv) = (*renv);
  if (flags & 1U) {
    renv->mutex.mutex_set_nowait = 0U;
    renv->mutex.mutex_set_wait = 0U;
  }
  n = 0;
  if (renv->regionq.slh_first == -1) {
    rp = (REGION *)((void *)0);
  } else {
    rp = (struct __db_region *)((u_int8_t *)(& renv->regionq) + renv->regionq.slh_first);
  }
  while (1) {
    if (n < (*arg_regions_cnt)) {
      if (! ((unsigned int )rp != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    (*(arg_regions + n)) = (*rp);
    if (flags & 1U) {
      rp->mutex.mutex_set_nowait = 0U;
      rp->mutex.mutex_set_wait = 0U;
    }
    n ++;
    if (rp->q.sle_next == -1) {
      rp = (REGION *)((void *)0);
    } else {
      rp = (struct __db_region *)((u_int8_t *)rp + rp->q.sle_next);
    }
  }
  rp = infop->rp;
  if (! (rp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & rp->mutex);
  }
  if (n == 0) {
    (*arg_regions_cnt) = n;
  } else {
    (*arg_regions_cnt) = n - 1;
  }
  return (0);
}
}
int __db_r_attach(DB_ENV *dbenv___0 , REGINFO *infop , size_t size ) 
{ REGENV *renv ;
  REGION *rp ;
  int ret ;
  char buf[(int )(sizeof("__db.%03d") + 20U)] ;

  {
  renv = (REGENV *)((REGINFO *)dbenv___0->reginfo)->primary;
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  infop->flags = infop->flags & 4294967294U;
  ret = __db_des_get(dbenv___0, (REGINFO *)dbenv___0->reginfo, infop, & rp);
  if (ret != 0) {
    if (! (renv->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
    }
    return (ret);
  }
  infop->rp = rp;
  infop->type = rp->type;
  infop->id = rp->id;
  if (infop->flags & 1U) {
    rp->size = size;
  }
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"__db.%03d",
           infop->id);
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )0, (char const   *)(buf),
                     0U, (DB_FH **)((void *)0), & infop->name);
  if (ret != 0) {
    goto err;
  }
  ret = __os_r_attach(dbenv___0, infop, rp);
  if (ret != 0) {
    goto err;
  }
  __db_faultmem(dbenv___0, infop->addr, rp->size, (int )(infop->flags & 1U));
  if (infop->flags & 1U) {
    __db_shalloc_init(infop->addr, rp->size);
  }
  if ((int )infop->type != 1) {
    if (! (rp->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & rp->mutex);
    }
    if (! (renv->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
    }
  }
  return (0);
  err: 
  if ((unsigned int )infop->addr != (unsigned int )((void *)0)) {
    __os_r_detach(dbenv___0, infop, (int )(infop->flags & 1U));
  }
  infop->rp = (REGION *)((void *)0);
  infop->id = 0U;
  if (infop->flags & 1U) {
    __db_des_destroy(dbenv___0, rp, 1);
    infop->flags = infop->flags & 4294967294U;
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  return (ret);
}
}
int __db_r_detach(DB_ENV *dbenv___0 , REGINFO *infop , int destroy ) 
{ REGENV *renv ;
  REGION *rp ;
  int ret ;
  int t_ret ;

  {
  renv = (REGENV *)((REGINFO *)dbenv___0->reginfo)->primary;
  rp = infop->rp;
  if (dbenv___0->flags & 32768U) {
    destroy = 1;
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & renv->mutex);
  }
  if (! (rp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & rp->mutex);
  }
  if (destroy) {
    __db_region_destroy(dbenv___0, infop);
  }
  ret = __os_r_detach(dbenv___0, infop, destroy);
  if (! (rp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & rp->mutex);
  }
  if (destroy) {
    t_ret = __db_des_destroy(dbenv___0, rp, 0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (! (renv->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & renv->mutex);
  }
  if ((unsigned int )infop->name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)infop->name);
  }
  return (ret);
}
}
static int __db_des_get(DB_ENV *dbenv___0 , REGINFO *env_infop , REGINFO *infop ,
                        REGION **rpp ) 
{ REGENV *renv ;
  REGION *rp ;
  REGION *first_type ;
  u_int32_t maxid ;
  int ret ;
  int tmp ;

  {
  (*rpp) = (REGION *)((void *)0);
  renv = (REGENV *)env_infop->primary;
  maxid = 1U;
  first_type = (REGION *)((void *)0);
  if (renv->regionq.slh_first == -1) {
    rp = (REGION *)((void *)0);
  } else {
    rp = (struct __db_region *)((u_int8_t *)(& renv->regionq) + renv->regionq.slh_first);
  }
  while ((unsigned int )rp != (unsigned int )((void *)0)) {
    if (infop->id != 0U) {
      if (infop->id == rp->id) {
        break;
      }
      goto __Cont;
    }
    if ((int )infop->type == (int )rp->type) {
      if (infop->flags & 4U) {
        if ((unsigned int )first_type == (unsigned int )((void *)0)) {
          first_type = rp;
        } else {
          if (first_type->id > rp->id) {
            first_type = rp;
          }
        }
      }
    }
    if (rp->id > maxid) {
      maxid = rp->id;
    }
    __Cont: 
    if (rp->q.sle_next == -1) {
      rp = (REGION *)((void *)0);
    } else {
      rp = (struct __db_region *)((u_int8_t *)rp + rp->q.sle_next);
    }
  }
  if ((unsigned int )rp == (unsigned int )((void *)0)) {
    rp = first_type;
  }
  if ((unsigned int )rp == (unsigned int )((void *)0)) {
    if (! (infop->flags & 2U)) {
      return (2);
    }
  }
  if ((unsigned int )rp == (unsigned int )((void *)0)) {
    ret = __db_shalloc(env_infop->addr, sizeof(REGION ), 1U, (void *)(& rp));
    if (ret != 0) {
      return (ret);
    }
    memset((void *)rp, 0, sizeof((*rp)));
    ret = __db_mutex_setup(dbenv___0, env_infop, (void *)(& rp->mutex), 96U);
    if (ret != 0) {
      __db_shalloc_free(env_infop->addr, (void *)rp);
      return (ret);
    }
    rp->segid = -1L;
    rp->type = infop->type;
    if (infop->id == 0U) {
      rp->id = maxid + 1U;
    } else {
      rp->id = infop->id;
    }
    while (1) {
      if (renv->regionq.slh_first != -1) {
        rp->q.sle_next = renv->regionq.slh_first - ((u_int8_t *)rp - (u_int8_t *)(& renv->regionq));
        if (rp->q.sle_next == -1) {
          tmp = 0;
        } else {
          tmp = - rp->q.sle_next;
        }
        ((struct __db_region *)((u_int8_t *)(& renv->regionq) + renv->regionq.slh_first))->q.sle_prev = tmp +
                                                                                                        ((u_int8_t *)(& rp->q.sle_next) -
                                                                                                         (u_int8_t *)rp);
      } else {
        rp->q.sle_next = -1;
      }
      renv->regionq.slh_first = (u_int8_t *)rp - (u_int8_t *)(& renv->regionq);
      rp->q.sle_prev = (u_int8_t *)(& renv->regionq.slh_first) - (u_int8_t *)rp;
      break;
    }
    infop->flags = infop->flags | 1U;
  }
  (*rpp) = rp;
  return (0);
}
}
static int __db_des_destroy(DB_ENV *dbenv___0 , REGION *rp , int shmem_safe ) 
{ REGINFO *infop ;

  {
  infop = (REGINFO *)dbenv___0->reginfo;
  if (shmem_safe) {
    while (1) {
      if (rp->q.sle_next != -1) {
        ((struct __db_region *)((u_int8_t *)rp + rp->q.sle_next))->q.sle_prev = rp->q.sle_prev -
                                                                                rp->q.sle_next;
        (*((ssize_t *)((u_int8_t *)rp + rp->q.sle_prev))) = (*((ssize_t *)((u_int8_t *)rp +
                                                                           rp->q.sle_prev))) +
                                                            rp->q.sle_next;
      } else {
        (*((ssize_t *)((u_int8_t *)rp + rp->q.sle_prev))) = -1;
      }
      break;
    }
  }
  __db_pthread_mutex_destroy(& rp->mutex);
  if (shmem_safe) {
    __db_shalloc_free(infop->addr, (void *)rp);
  }
  return (0);
}
}
static int __db_faultmem(DB_ENV *dbenv___0 , void *addr , size_t size , int created ) 
{ int ret ;
  u_int8_t *p ;
  u_int8_t *t ;

  {
  ret = 0;
  if (dbenv___0->flags & 65536U) {
    if (created) {
      p = (u_int8_t *)addr;
      t = (u_int8_t *)addr + size;
      while ((unsigned int )p < (unsigned int )t) {
        (*(p + 0)) = (unsigned char)219;
        p += 8192;
      }
    } else {
      p = (u_int8_t *)addr;
      t = (u_int8_t *)addr + size;
      while ((unsigned int )p < (unsigned int )t) {
        ret |= (int )(*(p + 0));
        p += 8192;
      }
    }
  }
  return (ret);
}
}
static void __db_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) 
{ 

  {
  switch ((int )infop->type) {
  case 2: 
  __lock_region_destroy(dbenv___0, infop);
  break;
  case 3: 
  __log_region_destroy(dbenv___0, infop);
  break;
  case 4: 
  __mpool_region_destroy(dbenv___0, infop);
  break;
  case 6: 
  __txn_region_destroy(dbenv___0, infop);
  break;
  case 1: ;
  case 5: ;
  break;
  default: ;
  break;
  }
}
}
#pragma merger(0,"/tmp/cil-ugLgIc6J.i","-O2")
int __fop_create_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DBT const   *name , u_int32_t appname , u_int32_t mode ) ;
int __fop_create_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __fop_create_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __fop_create_read(DB_ENV *dbenv___0 , void *recbuf , __fop_create_args **argpp ) ;
int __fop_remove_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DBT const   *name , DBT const   *fid , u_int32_t appname ) ;
int __fop_remove_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __fop_remove_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __fop_remove_read(DB_ENV *dbenv___0 , void *recbuf , __fop_remove_args **argpp ) ;
int __fop_write_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    DBT const   *name , u_int32_t appname , u_int32_t pgsize , db_pgno_t pageno ,
                    u_int32_t offset , DBT const   *page , u_int32_t flag ) ;
int __fop_write_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __fop_write_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __fop_write_read(DB_ENV *dbenv___0 , void *recbuf , __fop_write_args **argpp ) ;
int __fop_rename_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DBT const   *oldname , DBT const   *newname , DBT const   *fileid ,
                     u_int32_t appname ) ;
int __fop_rename_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) ;
int __fop_rename_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) ;
int __fop_rename_read(DB_ENV *dbenv___0 , void *recbuf , __fop_rename_args **argpp ) ;
int __fop_file_remove_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                          DBT const   *real_fid , DBT const   *tmp_fid , DBT const   *name ,
                          u_int32_t appname , u_int32_t child ) ;
int __fop_file_remove_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                               void *summary ) ;
int __fop_file_remove_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                            void *notused3 ) ;
int __fop_file_remove_read(DB_ENV *dbenv___0 , void *recbuf , __fop_file_remove_args **argpp ) ;
int __fop_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) ;
int __fop_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) ;
int __fop_create_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __fop_remove_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __fop_write_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __fop_rename_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) ;
int __fop_file_remove_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                              void *info ) ;
int __fop_create_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DBT const   *name , u_int32_t appname , u_int32_t mode ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  rectype = 143U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = name->size;
  }
  logrec.size = (((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                  tmp) + sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& name->size), sizeof(name->size));
    bp += sizeof(name->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )name->data, name->size);
    bp += name->size;
  }
  uinttmp = appname;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = mode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __fop_create_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __fop_create_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __fop_create_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __fop_create_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__fop_create%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tname: ");
  i = 0U;
  while (i < argp->name.size) {
    ch = (int )(*((u_int8_t *)argp->name.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tappname: %lu\n", (unsigned long )argp->appname);
  printf((char const   * __restrict  )"\tmode: %o\n", argp->mode);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __fop_create_read(DB_ENV *dbenv___0 , void *recbuf , __fop_create_args **argpp ) 
{ __fop_create_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__fop_create_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memset((void *)(& argp->name), 0, sizeof(argp->name));
  memcpy((void * __restrict  )(& argp->name.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->name.data = (void *)bp;
  bp += argp->name.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->appname = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->mode = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __fop_remove_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DBT const   *name , DBT const   *fid , u_int32_t appname ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  rectype = 144U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = name->size;
  }
  if ((unsigned int )fid == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = fid->size;
  }
  logrec.size = ((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                   tmp) + sizeof(u_int32_t )) + tmp___0) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& name->size), sizeof(name->size));
    bp += sizeof(name->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )name->data, name->size);
    bp += name->size;
  }
  if ((unsigned int )fid == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& fid->size), sizeof(fid->size));
    bp += sizeof(fid->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )fid->data, fid->size);
    bp += fid->size;
  }
  uinttmp = appname;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __fop_remove_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __fop_remove_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __fop_remove_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __fop_remove_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__fop_remove%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tname: ");
  i = 0U;
  while (i < argp->name.size) {
    ch = (int )(*((u_int8_t *)argp->name.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tfid: ");
  i = 0U;
  while (i < argp->fid.size) {
    ch = (int )(*((u_int8_t *)argp->fid.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tappname: %lu\n", (unsigned long )argp->appname);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __fop_remove_read(DB_ENV *dbenv___0 , void *recbuf , __fop_remove_args **argpp ) 
{ __fop_remove_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__fop_remove_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memset((void *)(& argp->name), 0, sizeof(argp->name));
  memcpy((void * __restrict  )(& argp->name.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->name.data = (void *)bp;
  bp += argp->name.size;
  memset((void *)(& argp->fid), 0, sizeof(argp->fid));
  memcpy((void * __restrict  )(& argp->fid.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->fid.data = (void *)bp;
  bp += argp->fid.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->appname = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __fop_write_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    DBT const   *name , u_int32_t appname , u_int32_t pgsize , db_pgno_t pageno ,
                    u_int32_t offset , DBT const   *page , u_int32_t flag ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  rectype = 145U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = name->size;
  }
  if ((unsigned int )page == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = page->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                    sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof(u_int32_t )) +
                 tmp___0) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& name->size), sizeof(name->size));
    bp += sizeof(name->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )name->data, name->size);
    bp += name->size;
  }
  uinttmp = appname;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pgsize;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = pageno;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = offset;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )page == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& page->size), sizeof(page->size));
    bp += sizeof(page->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )page->data, page->size);
    bp += page->size;
  }
  uinttmp = flag;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __fop_write_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __fop_write_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __fop_write_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __fop_write_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__fop_write%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tname: ");
  i = 0U;
  while (i < argp->name.size) {
    ch = (int )(*((u_int8_t *)argp->name.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tappname: %lu\n", (unsigned long )argp->appname);
  printf((char const   * __restrict  )"\tpgsize: %lu\n", (unsigned long )argp->pgsize);
  printf((char const   * __restrict  )"\tpageno: %lu\n", (unsigned long )argp->pageno);
  printf((char const   * __restrict  )"\toffset: %lu\n", (unsigned long )argp->offset);
  printf((char const   * __restrict  )"\tpage: ");
  i = 0U;
  while (i < argp->page.size) {
    ch = (int )(*((u_int8_t *)argp->page.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tflag: %lu\n", (unsigned long )argp->flag);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __fop_write_read(DB_ENV *dbenv___0 , void *recbuf , __fop_write_args **argpp ) 
{ __fop_write_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__fop_write_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memset((void *)(& argp->name), 0, sizeof(argp->name));
  memcpy((void * __restrict  )(& argp->name.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->name.data = (void *)bp;
  bp += argp->name.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->appname = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgsize = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pageno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->offset = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->page), 0, sizeof(argp->page));
  memcpy((void * __restrict  )(& argp->page.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->page.data = (void *)bp;
  bp += argp->page.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->flag = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __fop_rename_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                     DBT const   *oldname , DBT const   *newname , DBT const   *fileid ,
                     u_int32_t appname ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;

  {
  rectype = 146U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )oldname == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = oldname->size;
  }
  if ((unsigned int )newname == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = newname->size;
  }
  if ((unsigned int )fileid == (unsigned int )((void *)0)) {
    tmp___1 = 0U;
  } else {
    tmp___1 = fileid->size;
  }
  logrec.size = ((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                     tmp) + sizeof(u_int32_t )) + tmp___0) + sizeof(u_int32_t )) +
                 tmp___1) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )oldname == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& oldname->size),
           sizeof(oldname->size));
    bp += sizeof(oldname->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )oldname->data, oldname->size);
    bp += oldname->size;
  }
  if ((unsigned int )newname == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& newname->size),
           sizeof(newname->size));
    bp += sizeof(newname->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )newname->data, newname->size);
    bp += newname->size;
  }
  if ((unsigned int )fileid == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& fileid->size),
           sizeof(fileid->size));
    bp += sizeof(fileid->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )fileid->data, fileid->size);
    bp += fileid->size;
  }
  uinttmp = appname;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __fop_rename_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                          void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __fop_rename_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                       void *notused3 ) 
{ __fop_rename_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __fop_rename_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__fop_rename%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\toldname: ");
  i = 0U;
  while (i < argp->oldname.size) {
    ch = (int )(*((u_int8_t *)argp->oldname.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tnewname: ");
  i = 0U;
  while (i < argp->newname.size) {
    ch = (int )(*((u_int8_t *)argp->newname.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tfileid: ");
  i = 0U;
  while (i < argp->fileid.size) {
    ch = (int )(*((u_int8_t *)argp->fileid.data + i));
    tmp___8 = __ctype_b_loc();
    if ((int const   )(*((*tmp___8) + ch)) & 16384) {
      tmp___7 = "%c";
    } else {
      if (ch == 10) {
        tmp___7 = "%c";
      } else {
        tmp___7 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___7, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tappname: %lu\n", (unsigned long )argp->appname);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __fop_rename_read(DB_ENV *dbenv___0 , void *recbuf , __fop_rename_args **argpp ) 
{ __fop_rename_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__fop_rename_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memset((void *)(& argp->oldname), 0, sizeof(argp->oldname));
  memcpy((void * __restrict  )(& argp->oldname.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->oldname.data = (void *)bp;
  bp += argp->oldname.size;
  memset((void *)(& argp->newname), 0, sizeof(argp->newname));
  memcpy((void * __restrict  )(& argp->newname.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->newname.data = (void *)bp;
  bp += argp->newname.size;
  memset((void *)(& argp->fileid), 0, sizeof(argp->fileid));
  memcpy((void * __restrict  )(& argp->fileid.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->fileid.data = (void *)bp;
  bp += argp->fileid.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->appname = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __fop_file_remove_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                          DBT const   *real_fid , DBT const   *tmp_fid , DBT const   *name ,
                          u_int32_t appname , u_int32_t child ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;

  {
  rectype = 141U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )real_fid == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = real_fid->size;
  }
  if ((unsigned int )tmp_fid == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = tmp_fid->size;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    tmp___1 = 0U;
  } else {
    tmp___1 = name->size;
  }
  logrec.size = (((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                      tmp) + sizeof(u_int32_t )) + tmp___0) + sizeof(u_int32_t )) +
                  tmp___1) + sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )real_fid == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& real_fid->size),
           sizeof(real_fid->size));
    bp += sizeof(real_fid->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )real_fid->data, real_fid->size);
    bp += real_fid->size;
  }
  if ((unsigned int )tmp_fid == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& tmp_fid->size),
           sizeof(tmp_fid->size));
    bp += sizeof(tmp_fid->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )tmp_fid->data, tmp_fid->size);
    bp += tmp_fid->size;
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& name->size), sizeof(name->size));
    bp += sizeof(name->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )name->data, name->size);
    bp += name->size;
  }
  uinttmp = appname;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = child;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __fop_file_remove_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                               void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __fop_file_remove_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                            void *notused3 ) 
{ __fop_file_remove_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __fop_file_remove_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__fop_file_remove%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\treal_fid: ");
  i = 0U;
  while (i < argp->real_fid.size) {
    ch = (int )(*((u_int8_t *)argp->real_fid.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\ttmp_fid: ");
  i = 0U;
  while (i < argp->tmp_fid.size) {
    ch = (int )(*((u_int8_t *)argp->tmp_fid.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tname: ");
  i = 0U;
  while (i < argp->name.size) {
    ch = (int )(*((u_int8_t *)argp->name.data + i));
    tmp___8 = __ctype_b_loc();
    if ((int const   )(*((*tmp___8) + ch)) & 16384) {
      tmp___7 = "%c";
    } else {
      if (ch == 10) {
        tmp___7 = "%c";
      } else {
        tmp___7 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___7, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tappname: %lu\n", (unsigned long )argp->appname);
  printf((char const   * __restrict  )"\tchild: 0x%lx\n", (unsigned long )argp->child);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __fop_file_remove_read(DB_ENV *dbenv___0 , void *recbuf , __fop_file_remove_args **argpp ) 
{ __fop_file_remove_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__fop_file_remove_args ) + sizeof(DB_TXN ),
                    (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memset((void *)(& argp->real_fid), 0, sizeof(argp->real_fid));
  memcpy((void * __restrict  )(& argp->real_fid.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->real_fid.data = (void *)bp;
  bp += argp->real_fid.size;
  memset((void *)(& argp->tmp_fid), 0, sizeof(argp->tmp_fid));
  memcpy((void * __restrict  )(& argp->tmp_fid.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->tmp_fid.data = (void *)bp;
  bp += argp->tmp_fid.size;
  memset((void *)(& argp->name), 0, sizeof(argp->name));
  memcpy((void * __restrict  )(& argp->name.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->name.data = (void *)bp;
  bp += argp->name.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->appname = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->child = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __fop_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_create_print, 143U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_remove_print, 144U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_write_print, 145U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_rename_print, 146U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_file_remove_print,
                          141U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __fop_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_create_getpgnos, 143U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_remove_getpgnos, 144U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_write_getpgnos, 145U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_rename_getpgnos, 146U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_file_remove_getpgnos,
                          141U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __fop_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_create_recover, 143U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_remove_recover, 144U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_write_recover, 145U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_rename_recover, 146U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __fop_file_remove_recover,
                          141U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-dMSEu8jW.i","-O2")
int __fop_create(DB_ENV *dbenv___0 , DB_TXN *txn , DB_FH **fhpp , char const   *name ,
                 APPNAME appname , int mode , u_int32_t flags ) ;
int __txn_remevent(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , u_int8_t *fileid ) ;
int __fop_create(DB_ENV *dbenv___0 , DB_TXN *txn , DB_FH **fhpp , char const   *name ,
                 APPNAME appname , int mode , u_int32_t flags ) 
{ DB_FH *fhp ;
  DB_LSN lsn ;
  DBT data ;
  int ret ;
  char *real_name ;
  size_t tmp ;

  {
  real_name = (char *)((void *)0);
  ret = __db_appname(dbenv___0, appname, name, 0U, (DB_FH **)((void *)0), & real_name);
  if (ret != 0) {
    return (ret);
  }
  if (mode == 0) {
    mode = __db_omode("rw----");
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        memset((void *)(& data), 0, sizeof(data));
        data.data = (void *)name;
        tmp = strlen(name);
        data.size = tmp + 1U;
        ret = __fop_create_log(dbenv___0, txn, & lsn, flags | 1U, (DBT const   *)(& data),
                               (unsigned int )appname, (unsigned int )mode);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  if ((unsigned int )fhpp == (unsigned int )((void *)0)) {
    fhpp = & fhp;
  }
  ret = __os_open(dbenv___0, (char const   *)real_name, 5U, mode, fhpp);
  err: 
  if ((unsigned int )fhpp == (unsigned int )(& fhp)) {
    if ((unsigned int )fhp != (unsigned int )((void *)0)) {
      __os_closehandle(dbenv___0, fhp);
    }
  }
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  return (ret);
}
}
int __fop_remove(DB_ENV *dbenv___0 , DB_TXN *txn , u_int8_t *fileid , char const   *name ,
                 APPNAME appname , u_int32_t flags ) 
{ DB_LSN lsn ;
  DBT fdbt ;
  DBT ndbt ;
  char *real_name ;
  int ret ;
  size_t tmp ;

  {
  real_name = (char *)((void *)0);
  ret = __db_appname(dbenv___0, appname, name, 0U, (DB_FH **)((void *)0), & real_name);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )txn == (unsigned int )((void *)0)) {
    if ((unsigned int )fileid != (unsigned int )((void *)0)) {
      ret = __memp_nameop(dbenv___0, fileid, (char const   *)((void *)0), (char const   *)real_name,
                          (char const   *)((void *)0));
      if (ret != 0) {
        goto err;
      }
    }
  } else {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if (((DB_REP *)dbenv___0->rep_handle)->region) {
          if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
          if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
            goto _L;
          }
        } else {
          _L: 
          memset((void *)(& fdbt), 0, sizeof(ndbt));
          fdbt.data = (void *)fileid;
          if ((unsigned int )fileid == (unsigned int )((void *)0)) {
            fdbt.size = 0U;
          } else {
            fdbt.size = 20U;
          }
          memset((void *)(& ndbt), 0, sizeof(ndbt));
          ndbt.data = (void *)name;
          tmp = strlen(name);
          ndbt.size = tmp + 1U;
          ret = __fop_remove_log(dbenv___0, txn, & lsn, flags, (DBT const   *)(& ndbt),
                                 (DBT const   *)(& fdbt), (unsigned int )appname);
          if (ret != 0) {
            goto err;
          }
        }
      }
    }
    ret = __txn_remevent(dbenv___0, txn, (char const   *)real_name, fileid);
  }
  err: 
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  return (ret);
}
}
int __fop_write(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , APPNAME appname ,
                DB_FH *fhp , u_int32_t pgsize , db_pgno_t pageno , u_int32_t off ,
                u_int8_t *buf , u_int32_t size , u_int32_t istmp , u_int32_t flags ) 
{ DB_LSN lsn ;
  DBT data ;
  DBT namedbt ;
  size_t nbytes ;
  int local_open ;
  int ret ;
  int t_ret ;
  char *real_name ;
  size_t tmp ;

  {
  local_open = 0;
  ret = local_open;
  real_name = (char *)((void *)0);
  ret = __db_appname(dbenv___0, appname, name, 0U, (DB_FH **)((void *)0), & real_name);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        memset((void *)(& data), 0, sizeof(data));
        data.data = (void *)buf;
        data.size = size;
        memset((void *)(& namedbt), 0, sizeof(namedbt));
        namedbt.data = (void *)name;
        tmp = strlen(name);
        namedbt.size = tmp + 1U;
        ret = __fop_write_log(dbenv___0, txn, & lsn, flags, (DBT const   *)(& namedbt),
                              (unsigned int )appname, pgsize, pageno, off, (DBT const   *)(& data),
                              istmp);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  if ((unsigned int )fhp == (unsigned int )((void *)0)) {
    ret = __os_open(dbenv___0, (char const   *)real_name, 0U, 0, & fhp);
    if (ret != 0) {
      goto err;
    }
    local_open = 1;
  }
  ret = __os_seek(dbenv___0, fhp, pgsize, pageno, off, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  ret = __os_write(dbenv___0, fhp, (void *)buf, size, & nbytes);
  if (ret != 0) {
    goto err;
  }
  err: 
  if (local_open) {
    t_ret = __os_closehandle(dbenv___0, fhp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  return (ret);
}
}
int __fop_rename(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *oldname , char const   *newname ,
                 u_int8_t *fid , APPNAME appname , u_int32_t flags ) 
{ DB_LSN lsn ;
  DBT fiddbt ;
  DBT new ;
  DBT old ;
  int ret ;
  char *n ;
  char *o ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  ret = __db_appname(dbenv___0, appname, oldname, 0U, (DB_FH **)((void *)0), & o);
  if (ret != 0) {
    goto err;
  }
  ret = __db_appname(dbenv___0, appname, newname, 0U, (DB_FH **)((void *)0), & n);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        memset((void *)(& old), 0, sizeof(old));
        memset((void *)(& new), 0, sizeof(new));
        memset((void *)(& fiddbt), 0, sizeof(fiddbt));
        old.data = (void *)oldname;
        tmp = strlen(oldname);
        old.size = tmp + 1U;
        new.data = (void *)newname;
        tmp___0 = strlen(newname);
        new.size = tmp___0 + 1U;
        fiddbt.data = (void *)fid;
        fiddbt.size = 20U;
        ret = __fop_rename_log(dbenv___0, txn, & lsn, flags | 1U, (DBT const   *)(& old),
                               (DBT const   *)(& new), (DBT const   *)(& fiddbt),
                               (unsigned int )appname);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  ret = __memp_nameop(dbenv___0, fid, newname, (char const   *)o, (char const   *)n);
  err: 
  if ((unsigned int )o != (unsigned int )oldname) {
    __os_free(dbenv___0, (void *)o);
  }
  if ((unsigned int )n != (unsigned int )newname) {
    __os_free(dbenv___0, (void *)n);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-0eBb3OyJ.i","-O2")
int __fop_read_meta(DB_ENV *dbenv___0 , char const   *name , u_int8_t *buf , size_t size ,
                    DB_FH *fhp , int errok , size_t *nbytesp ) ;
int __fop_create_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ DB_FH *fhp ;
  __fop_create_args *argp ;
  char *real_name ;
  int ret ;

  {
  real_name = (char *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__fop_create_args *)((void *)0);
    ret = __fop_create_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )argp->appname, (char const   *)argp->name.data,
                     0U, (DB_FH **)((void *)0), & real_name);
  if (ret != 0) {
    goto out;
  }
  if ((int )op == 0) {
    __os_unlink(dbenv___0, (char const   *)real_name);
  } else {
    if ((int )op == 3) {
      __os_unlink(dbenv___0, (char const   *)real_name);
    } else {
      if ((int )op == 2) {
        __os_unlink(dbenv___0, (char const   *)real_name);
      } else {
        if ((int )op == 4) {
          goto _L;
        } else {
          if ((int )op == 1) {
            _L: 
            ret = __os_open(dbenv___0, (char const   *)real_name, 5U, (int )argp->mode,
                            & fhp);
            if (ret == 0) {
              __os_closehandle(dbenv___0, fhp);
            } else {
              goto out;
            }
          }
        }
      }
    }
  }
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
int __fop_remove_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __fop_remove_args *argp ;
  char *real_name ;
  int ret ;

  {
  real_name = (char *)((void *)0);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__fop_remove_args *)((void *)0);
    ret = __fop_remove_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )argp->appname, (char const   *)argp->name.data,
                     0U, (DB_FH **)((void *)0), & real_name);
  if (ret != 0) {
    goto out;
  }
  if ((int )op == 4) {
    __memp_nameop(dbenv___0, (u_int8_t *)argp->fid.data, (char const   *)((void *)0),
                  (char const   *)real_name, (char const   *)((void *)0));
  } else {
    if ((int )op == 1) {
      __memp_nameop(dbenv___0, (u_int8_t *)argp->fid.data, (char const   *)((void *)0),
                    (char const   *)real_name, (char const   *)((void *)0));
    }
  }
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
int __fop_write_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __fop_write_args *argp ;
  int ret ;

  {
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__fop_write_args *)((void *)0);
    ret = __fop_write_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  ret = 0;
  if (! ((int )op == 0)) {
    if (! ((int )op == 3)) {
      if (! ((int )op == 2)) {
        if ((int )op == 4) {
          ret = __fop_write(dbenv___0, argp->txnid, (char const   *)argp->name.data,
                            (enum __anonenum_APPNAME_39 )argp->appname, (DB_FH *)((void *)0),
                            argp->pgsize, argp->pageno, argp->offset, (u_int8_t *)argp->page.data,
                            argp->page.size, argp->flag, 0U);
        } else {
          if ((int )op == 1) {
            ret = __fop_write(dbenv___0, argp->txnid, (char const   *)argp->name.data,
                              (enum __anonenum_APPNAME_39 )argp->appname, (DB_FH *)((void *)0),
                              argp->pgsize, argp->pageno, argp->offset, (u_int8_t *)argp->page.data,
                              argp->page.size, argp->flag, 0U);
          }
        }
      }
    }
  }
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
int __fop_rename_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                         void *info ) 
{ __fop_rename_args *argp ;
  DB_FH *fhp ;
  DBMETA *meta ;
  char *real_new ;
  char *real_old ;
  char *src ;
  int ret ;
  u_int8_t *fileid ;
  u_int8_t mbuf[512] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  real_new = (char *)((void *)0);
  real_old = (char *)((void *)0);
  ret = 0;
  fhp = (DB_FH *)((void *)0);
  meta = (DBMETA *)(mbuf);
  info = (void *)0;
  info = info;
  while (1) {
    argp = (__fop_rename_args *)((void *)0);
    ret = __fop_rename_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  fileid = (u_int8_t *)argp->fileid.data;
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )argp->appname, (char const   *)argp->newname.data,
                     0U, (DB_FH **)((void *)0), & real_new);
  if (ret != 0) {
    goto out;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )argp->appname, (char const   *)argp->oldname.data,
                     0U, (DB_FH **)((void *)0), & real_old);
  if (ret != 0) {
    goto out;
  }
  if ((int )op != 0) {
    if ((int )op != 1) {
      if ((int )op == 0) {
        src = real_new;
      } else {
        if ((int )op == 3) {
          src = real_new;
        } else {
          if ((int )op == 2) {
            src = real_new;
          } else {
            src = real_old;
          }
        }
      }
      tmp = __os_open(dbenv___0, (char const   *)src, 0U, 0, & fhp);
      if (tmp != 0) {
        goto done;
      }
      tmp___0 = __fop_read_meta(dbenv___0, (char const   *)src, mbuf, 512U, fhp, 1,
                                (size_t *)((void *)0));
      if (tmp___0 != 0) {
        goto done;
      }
      tmp___1 = __db_chk_meta(dbenv___0, (DB *)((void *)0), meta, 1);
      if (tmp___1 != 0) {
        goto done;
      }
      tmp___2 = memcmp((void const   *)argp->fileid.data, (void const   *)(meta->uid),
                       20U);
      if (tmp___2 != 0) {
        goto done;
      }
      __os_closehandle(dbenv___0, fhp);
      fhp = (DB_FH *)((void *)0);
    }
  }
  if ((int )op == 0) {
    __memp_nameop(dbenv___0, fileid, (char const   *)argp->oldname.data, (char const   *)real_new,
                  (char const   *)real_old);
  } else {
    if ((int )op == 3) {
      __memp_nameop(dbenv___0, fileid, (char const   *)argp->oldname.data, (char const   *)real_new,
                    (char const   *)real_old);
    } else {
      if ((int )op == 2) {
        __memp_nameop(dbenv___0, fileid, (char const   *)argp->oldname.data, (char const   *)real_new,
                      (char const   *)real_old);
      }
    }
  }
  if ((int )op == 4) {
    __memp_nameop(dbenv___0, fileid, (char const   *)argp->newname.data, (char const   *)real_old,
                  (char const   *)real_new);
  } else {
    if ((int )op == 1) {
      __memp_nameop(dbenv___0, fileid, (char const   *)argp->newname.data, (char const   *)real_old,
                    (char const   *)real_new);
    }
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  out: 
  if ((unsigned int )real_new != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_new);
  }
  if ((unsigned int )real_old != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_old);
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, fhp);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
int __fop_file_remove_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                              void *info ) 
{ __fop_file_remove_args *argp ;
  DBMETA *meta ;
  DB_FH *fhp ;
  char *real_name ;
  int is_real ;
  int is_tmp ;
  int ret ;
  size_t len ;
  u_int8_t mbuf[512] ;
  u_int32_t cstat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  fhp = (DB_FH *)((void *)0);
  is_tmp = 0;
  is_real = is_tmp;
  real_name = (char *)((void *)0);
  meta = (DBMETA *)(mbuf);
  while (1) {
    argp = (__fop_file_remove_args *)((void *)0);
    ret = __fop_file_remove_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      return (ret);
    }
    break;
  }
  if ((int )op != 3) {
    if ((int )op != 4) {
      if ((int )op != 1) {
        goto done;
      }
    }
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )argp->appname, (char const   *)argp->name.data,
                     0U, (DB_FH **)((void *)0), & real_name);
  if (ret != 0) {
    goto out;
  }
  len = 0U;
  tmp___1 = __os_open(dbenv___0, (char const   *)real_name, 0U, 0, & fhp);
  if (tmp___1 != 0) {
    goto _L;
  } else {
    ret = __fop_read_meta(dbenv___0, (char const   *)real_name, mbuf, 512U, fhp, 1,
                          & len);
    if (ret != 0) {
      _L: 
      if (len != 0U) {
        goto out;
      }
      cstat = 6U;
    } else {
      __db_chk_meta(dbenv___0, (DB *)((void *)0), meta, 1);
      tmp = memcmp((void const   *)argp->real_fid.data, (void const   *)(meta->uid),
                   20U);
      is_real = tmp == 0;
      tmp___0 = memcmp((void const   *)argp->tmp_fid.data, (void const   *)(meta->uid),
                       20U);
      is_tmp = tmp___0 == 0;
      if (! is_real) {
        if (! is_tmp) {
          cstat = 5U;
        } else {
          cstat = 1U;
        }
      } else {
        cstat = 1U;
      }
    }
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, fhp);
    fhp = (DB_FH *)((void *)0);
  }
  if ((int )op == 0) {
    goto _L___1;
  } else {
    if ((int )op == 3) {
      goto _L___1;
    } else {
      if ((int )op == 2) {
        _L___1: 
        ret = __db_txnlist_update(dbenv___0, info, argp->child, (int )cstat, (DB_LSN *)((void *)0));
        if (ret == 4) {
          ret = __db_txnlist_add(dbenv___0, info, argp->child, (int )cstat, (DB_LSN *)((void *)0));
        }
        if (ret != 0) {
          goto out;
        }
      } else {
        if ((int )op == 4) {
          goto _L___0;
        } else {
          if ((int )op == 1) {
            _L___0: 
            if (cstat == 1U) {
              if (is_real) {
                tmp___2 = argp->real_fid.data;
              } else {
                tmp___2 = argp->tmp_fid.data;
              }
              __memp_nameop(dbenv___0, (u_int8_t *)tmp___2, (char const   *)((void *)0),
                            (char const   *)real_name, (char const   *)((void *)0));
            }
          }
        }
      }
    }
  }
  done: 
  (*lsnp) = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, fhp);
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)argp);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-jKrJv3mm.i","-O2")
int __memp_get_refcnt(DB_ENV *dbenv___0 , u_int8_t *fileid , int *refp ) ;
void __txn_remrem(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name ) ;
static int __fop_set_pgsize(DB *dbp___1 , DB_FH *fhp , char const   *name ) ;
int __fop_lock_handle(DB_ENV *dbenv___0 , DB *dbp___1 , u_int32_t locker , db_lockmode_t mode ,
                      DB_LOCK *elock , u_int32_t flags ) 
{ DBT fileobj ;
  DB_LOCKREQ reqs[2] ;
  DB_LOCKREQ *ereq ;
  DB_LOCK_ILOCK lock_desc ;
  int ret ;

  {
  if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
    return (0);
  } else {
    if (dbp___1->flags & 2097156U) {
      return (0);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      if ((unsigned int )elock != (unsigned int )((void *)0)) {
        if (! (! (elock->off != 0U))) {
          __lock_put(dbenv___0, elock);
        }
      }
      return (0);
    }
  }
  memcpy((void * __restrict  )(& lock_desc.fileid), (void const   * __restrict  )(& dbp___1->fileid),
         20U);
  lock_desc.pgno = dbp___1->meta_pgno;
  lock_desc.type = 1U;
  memset((void *)(& fileobj), 0, sizeof(fileobj));
  fileobj.data = (void *)(& lock_desc);
  fileobj.size = sizeof(lock_desc);
  if ((unsigned int )elock == (unsigned int )((void *)0)) {
    ret = __lock_get(dbenv___0, locker, flags, (DBT const   *)(& fileobj), mode, & dbp___1->handle_lock);
  } else {
    reqs[0].op = (enum __anonenum_db_lockop_t_51 )4;
    reqs[0].lock = (*elock);
    reqs[1].op = (enum __anonenum_db_lockop_t_51 )1;
    reqs[1].mode = mode;
    reqs[1].obj = & fileobj;
    reqs[1].timeout = 0U;
    ret = __lock_vec(dbenv___0, locker, flags, reqs, 2, & ereq);
    if (ret == 0) {
      dbp___1->handle_lock = reqs[1].lock;
      elock->off = 0U;
    } else {
      if ((unsigned int )ereq != (unsigned int )(reqs)) {
        elock->off = 0U;
      }
    }
  }
  dbp___1->cur_lid = locker;
  return (ret);
}
}
int __fop_file_setup(DB *dbp___1 , DB_TXN *txn , char const   *name , int mode , u_int32_t flags ,
                     u_int32_t *retidp ) 
{ DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  DB_LOCK elock ;
  DB_TXN *stxn ;
  size_t len ;
  u_int32_t dflags ;
  u_int32_t locker ;
  u_int32_t oflags ;
  u_int8_t mbuf[512] ;
  int created_locker ;
  int ret ;
  int t_ret ;
  int tmp_created ;
  int truncating ;
  char *real_name ;
  char *real_tmpname ;
  char *tmpname ;
  DBT __dbt ;
  u_int32_t __lockval ;
  int tmp ;
  DBT __dbt___0 ;
  u_int32_t __lockval___0 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  (*retidp) = 0U;
  dbenv___0 = dbp___1->dbenv;
  fhp = (DB_FH *)((void *)0);
  elock.off = 0U;
  stxn = (DB_TXN *)((void *)0);
  truncating = 0;
  tmp_created = truncating;
  created_locker = tmp_created;
  tmpname = (char *)((void *)0);
  real_tmpname = tmpname;
  real_name = real_tmpname;
  if (dbp___1->flags & 32768U) {
    dflags = 16U;
  } else {
    dflags = 0U;
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    if (! (dbp___1->flags & 4U)) {
      if (dbp___1->lid == 0U) {
        ret = __lock_id(dbenv___0, & dbp___1->lid);
        if (ret != 0) {
          goto err;
        }
        created_locker = 1;
      }
    }
  }
  dbp___1->handle_lock.off = 0U;
  if ((unsigned int )txn == (unsigned int )((void *)0)) {
    locker = dbp___1->lid;
  } else {
    locker = txn->txnid;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, name, 0U, (DB_FH **)((void *)0),
                     & real_name);
  if (ret != 0) {
    goto err;
  }
  if (mode == 0) {
    mode = __db_omode("rwrw--");
  }
  oflags = 0U;
  if (flags & 16U) {
    oflags |= 16U;
  }
  if (flags & 128U) {
    oflags |= 256U;
  }
  retry: 
  if (! (dbp___1->flags & 4U)) {
    while (1) {
      if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
        __lockval = 1U;
        __dbt.data = (void *)(& __lockval);
        __dbt.size = sizeof(__lockval);
        ret = __lock_get(dbenv___0, locker, 0U, (DBT const   *)(& __dbt), (enum __anonenum_db_lockmode_t_50 )2,
                         & elock);
        if (ret != 0) {
          goto err;
        }
      }
      break;
    }
  }
  ret = __os_exists((char const   *)real_name, (int *)((void *)0));
  if (ret == 0) {
    reopen: 
    ret = __os_open(dbenv___0, (char const   *)real_name, oflags, 0, & fhp);
    if (ret != 0) {
      goto err;
    }
    if (flags & 128U) {
      if (flags & 4096U) {
        ret = 17;
        goto err;
      }
      tmpname = (char *)name;
      goto creat2;
    }
    if (flags & 8192U) {
      if ((unsigned int )txn == (unsigned int )((void *)0)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    ret = __fop_read_meta(dbenv___0, (char const   *)real_name, mbuf, sizeof(mbuf),
                          fhp, tmp, & len);
    if (ret != 0) {
      if (len == 0U) {
        if ((unsigned int )txn == (unsigned int )((void *)0)) {
          if (flags & 4096U) {
            ret = 17;
            goto err;
          }
          tmpname = (char *)name;
          goto creat2;
        }
      }
    }
    if (ret != 0) {
      goto err;
    }
    ret = __db_meta_setup(dbenv___0, dbp___1, (char const   *)real_name, (DBMETA *)(mbuf),
                          flags, 1);
    if (ret != 0) {
      goto err;
    }
    ret = __fop_lock_handle(dbenv___0, dbp___1, locker, (enum __anonenum_db_lockmode_t_50 )1,
                            (DB_LOCK *)((void *)0), 1U);
    if (ret == 0) {
      if (! (elock.off != 0U)) {
        ret = 0;
      } else {
        ret = __lock_put(dbenv___0, & elock);
      }
      if (ret != 0) {
        goto err;
      }
    } else {
      if (ret == -30994) {
        ret = __os_closehandle(dbenv___0, fhp);
        if (ret != 0) {
          goto err;
        }
        fhp = (DB_FH *)((void *)0);
        ret = __fop_lock_handle(dbenv___0, dbp___1, locker, (enum __anonenum_db_lockmode_t_50 )1,
                                & elock, 0U);
        if (ret == -30897) {
          goto retry;
        }
        if (ret != 0) {
          goto err;
        }
        ret = __os_open(dbenv___0, (char const   *)real_name, 0U, 0, & fhp);
        if (ret != 0) {
          goto err;
        }
      } else {
        goto err;
      }
    }
    if (dbp___1->flags & 16384U) {
      if (flags & 1U) {
        ret = __os_closehandle(dbenv___0, fhp);
        if (ret != 0) {
          goto err;
        }
        goto create;
      } else {
        ret = 2;
        goto err;
      }
    }
    if (flags & 4096U) {
      if (dbp___1->handle_lock.off != 0U) {
        __lock_put(dbenv___0, & dbp___1->handle_lock);
      }
      dbp___1->handle_lock.off = 0U;
      ret = 17;
      goto err;
    }
    goto done;
  }
  if (! (flags & 1U)) {
    goto err;
  }
  ret = 0;
  if (! (elock.off != 0U)) {
    ret = 0;
  } else {
    ret = __lock_put(dbenv___0, & elock);
  }
  if (ret != 0) {
    goto err;
  }
  create: 
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
          __db_err((DB_ENV const   *)dbenv___0, "Transactional create on replication client disallowed");
          ret = 22;
          goto err;
        }
      }
    }
  }
  ret = __db_backup_name(dbenv___0, name, txn, & tmpname);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      ret = __txn_begin(dbenv___0, txn, & stxn, 0U);
      if (ret != 0) {
        goto err;
      }
    }
  }
  ret = __fop_create(dbenv___0, stxn, & fhp, (char const   *)tmpname, (enum __anonenum_APPNAME_39 )1,
                     mode, dflags);
  if (ret != 0) {
    if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
      if (ret == 17) {
        __os_free(dbenv___0, (void *)tmpname);
        tmpname = (char *)((void *)0);
        goto retry;
      }
    }
    goto err;
  }
  tmp_created = 1;
  creat2: 
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, (char const   *)tmpname,
                     0U, (DB_FH **)((void *)0), & real_tmpname);
  if (ret != 0) {
    goto err;
  }
  if (dbp___1->pgsize == 0U) {
    ret = __fop_set_pgsize(dbp___1, fhp, (char const   *)real_tmpname);
    if (ret != 0) {
      goto errmsg;
    }
  }
  ret = __os_fileid(dbenv___0, (char const   *)real_tmpname, 1, dbp___1->fileid);
  if (ret != 0) {
    goto errmsg;
  }
  ret = __db_new_file(dbp___1, stxn, fhp, (char const   *)tmpname);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    if (flags & 8192U) {
      dbp___1->saved_open_fhp = fhp;
    } else {
      t_ret = __os_closehandle(dbp___1->dbenv, fhp);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
        goto err;
      }
    }
    fhp = (DB_FH *)((void *)0);
  }
  if (! (dbp___1->flags & 4U)) {
    while (1) {
      if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
        __lockval___0 = 1U;
        __dbt___0.data = (void *)(& __lockval___0);
        __dbt___0.size = sizeof(__lockval___0);
        ret = __lock_get(dbenv___0, locker, 0U, (DBT const   *)(& __dbt___0), (enum __anonenum_db_lockmode_t_50 )2,
                         & elock);
        if (ret != 0) {
          goto err;
        }
      }
      break;
    }
  }
  if (dbp___1->flags & 16384U) {
    dbp___1->flags = dbp___1->flags & 4294950911U;
    __txn_remrem(dbenv___0, txn, (char const   *)real_name);
  } else {
    if (! ((unsigned int )name == (unsigned int )tmpname)) {
      tmp___2 = __os_exists((char const   *)real_name, (int *)((void *)0));
      if (tmp___2 == 0) {
        __fop_remove(dbenv___0, (DB_TXN *)((void *)0), dbp___1->fileid, (char const   *)tmpname,
                     (enum __anonenum_APPNAME_39 )1, dflags);
        if (dbp___1->handle_lock.off != 0U) {
          __lock_put(dbenv___0, & dbp___1->handle_lock);
        }
        dbp___1->handle_lock.off = 0U;
        if ((unsigned int )stxn != (unsigned int )((void *)0)) {
          ret = __txn_abort(stxn);
          stxn = (DB_TXN *)((void *)0);
        }
        if (ret != 0) {
          goto err;
        }
        goto reopen;
      }
    }
  }
  ret = __fop_lock_handle(dbenv___0, dbp___1, locker, (enum __anonenum_db_lockmode_t_50 )2,
                          & elock, 0U);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )tmpname != (unsigned int )name) {
    ret = __fop_rename(dbenv___0, stxn, (char const   *)tmpname, name, dbp___1->fileid,
                       (enum __anonenum_APPNAME_39 )1, dflags);
    if (ret != 0) {
      goto err;
    }
  }
  if ((unsigned int )stxn != (unsigned int )((void *)0)) {
    (*retidp) = stxn->txnid;
    ret = __txn_commit(stxn, 0U);
    stxn = (DB_TXN *)((void *)0);
  } else {
    (*retidp) = 0U;
  }
  if (ret != 0) {
    goto err;
  }
  dbp___1->flags = dbp___1->flags | 8U;
  if (0) {
    errmsg: 
    tmp___3 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", name, tmp___3);
    err: 
    if ((unsigned int )fhp != (unsigned int )((void *)0)) {
      if (flags & 8192U) {
        dbp___1->saved_open_fhp = fhp;
      } else {
        t_ret = __os_closehandle(dbp___1->dbenv, fhp);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
          goto err;
        }
      }
      fhp = (DB_FH *)((void *)0);
    }
    if ((unsigned int )stxn != (unsigned int )((void *)0)) {
      __txn_abort(stxn);
    }
    if (tmp_created) {
      if ((unsigned int )txn == (unsigned int )((void *)0)) {
        __fop_remove(dbenv___0, (DB_TXN *)((void *)0), (u_int8_t *)((void *)0), (char const   *)tmpname,
                     (enum __anonenum_APPNAME_39 )1, dflags);
      }
    }
    if (dbp___1->handle_lock.off != 0U) {
      if ((unsigned int )txn == (unsigned int )((void *)0)) {
        __lock_put(dbenv___0, & dbp___1->handle_lock);
      }
    }
    if (elock.off != 0U) {
      if (! (! (elock.off != 0U))) {
        __lock_put(dbenv___0, & elock);
      }
    }
    if (created_locker) {
      __lock_id_free(dbenv___0, dbp___1->lid);
      dbp___1->lid = 0U;
    }
  }
  done: 
  if (! truncating) {
    if ((unsigned int )tmpname != (unsigned int )((void *)0)) {
      if ((unsigned int )tmpname != (unsigned int )name) {
        __os_free(dbenv___0, (void *)tmpname);
      }
    }
  }
  if ((unsigned int )real_name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_name);
  }
  if ((unsigned int )real_tmpname != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_tmpname);
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    if (flags & 8192U) {
      dbp___1->saved_open_fhp = fhp;
    } else {
      t_ret = __os_closehandle(dbp___1->dbenv, fhp);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
        goto err;
      }
    }
    fhp = (DB_FH *)((void *)0);
  }
  return (ret);
}
}
static int __fop_set_pgsize(DB *dbp___1 , DB_FH *fhp , char const   *name ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t iopsize ;
  int ret ;
  char *tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = __os_ioinfo(dbenv___0, name, fhp, (u_int32_t *)((void *)0), (u_int32_t *)((void *)0),
                    & iopsize);
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", name, tmp);
    return (ret);
  }
  if (iopsize < 512U) {
    iopsize = 512U;
  }
  if (iopsize > 16384U) {
    iopsize = 16384U;
  }
  if ((iopsize & (iopsize - 1U)) == 0U) {
    if (iopsize >= 512U) {
      if (! (iopsize <= 65536U)) {
        iopsize = 8192U;
      }
    } else {
      iopsize = 8192U;
    }
  } else {
    iopsize = 8192U;
  }
  dbp___1->pgsize = iopsize;
  dbp___1->flags = dbp___1->flags | 262144U;
  return (0);
}
}
int __fop_subdb_setup(DB *dbp___1 , DB_TXN *txn , char const   *mname , char const   *name ,
                      int mode , u_int32_t flags ) 
{ DB *mdbp ;
  DB_ENV *dbenv___0 ;
  int ret ;
  int t_ret ;
  int tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;

  {
  mdbp = (DB *)((void *)0);
  dbenv___0 = dbp___1->dbenv;
  ret = __db_master_open(dbp___1, txn, mname, flags, mode, & mdbp);
  if (ret != 0) {
    return (ret);
  }
  if (mdbp->flags & 8U) {
    mdbp->flags = mdbp->flags | 256U;
  }
  if (flags & 8192U) {
    dbp___1->saved_open_fhp = mdbp->saved_open_fhp;
    mdbp->saved_open_fhp = (DB_FH *)((void *)0);
  }
  dbp___1->pgsize = mdbp->pgsize;
  dbp___1->flags = dbp___1->flags | 134217728U;
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    ret = __db_master_update(mdbp, dbp___1, txn, name, dbp___1->type, (enum __anonenum_mu_action_40 )2,
                             (char const   *)((void *)0), flags);
    if (ret != 0) {
      goto err;
    }
  }
  dbp___1->lid = mdbp->lid;
  mdbp->lid = 0U;
  memcpy((void * __restrict  )(dbp___1->fileid), (void const   * __restrict  )(mdbp->fileid),
         20U);
  if (dbp___1->flags & 8U) {
    tmp = 2;
  } else {
    if (flags & 32768U) {
      tmp = 2;
    } else {
      tmp = 1;
    }
  }
  if ((unsigned int )txn == (unsigned int )((void *)0)) {
    tmp___0 = dbp___1->lid;
  } else {
    tmp___0 = txn->txnid;
  }
  ret = __fop_lock_handle(dbenv___0, dbp___1, tmp___0, (enum __anonenum_db_lockmode_t_50 )tmp,
                          (DB_LOCK *)((void *)0), 0U);
  if (ret != 0) {
    goto err;
  }
  ret = __db_init_subdb(mdbp, dbp___1, name, txn);
  if (ret != 0) {
    if (dbp___1->flags & 8U) {
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        __db_master_update(mdbp, dbp___1, txn, name, dbp___1->type, (enum __anonenum_mu_action_40 )0,
                           (char const   *)((void *)0), 0U);
      }
    }
    dbp___1->flags = dbp___1->flags & 4294967287U;
    goto err;
  }
  dbp___1->flags = dbp___1->flags & 4026531839U;
  dbp___1->flags = dbp___1->flags | (mdbp->flags & 268435456U);
  if (mdbp->flags & 8U) {
    dbp___1->flags = dbp___1->flags | 16U;
    mdbp->flags = mdbp->flags & 4294967039U;
  }
  if (0) {
    err: 
    if (dbp___1->handle_lock.off != 0U) {
      if ((unsigned int )txn == (unsigned int )((void *)0)) {
        __lock_put(dbenv___0, & dbp___1->handle_lock);
      }
    }
  }
  if (! (dbp___1->flags & 2097152U)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      __txn_remlock(dbenv___0, txn, & mdbp->handle_lock, 0U);
      if (dbp___1->lid == 0U) {
        tmp___1 = mdbp->lid;
      } else {
        tmp___1 = dbp___1->lid;
      }
      t_ret = __txn_lockevent(dbenv___0, txn, dbp___1, & mdbp->handle_lock, tmp___1);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  mdbp->handle_lock.off = 0U;
  t_ret = __db_close(mdbp, txn, 0U);
  if (t_ret) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __fop_remove_setup(DB *dbp___1 , DB_TXN *txn , char const   *name , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  DB_LOCK elock ;
  u_int8_t mbuf[512] ;
  int cnt ;
  int ret ;
  int tmp ;
  DBT __dbt ;
  u_int32_t __lockval ;

  {
  flags = 0U;
  flags = flags;
  dbenv___0 = dbp___1->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  elock.off = 0U;
  retry: 
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      dbp___1->lid = txn->txnid;
    } else {
      if (dbp___1->lid == 0U) {
        ret = __lock_id(dbenv___0, & dbp___1->lid);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  fhp = dbp___1->saved_open_fhp;
  while (1) {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      __lockval = 1U;
      __dbt.data = (void *)(& __lockval);
      __dbt.size = sizeof(__lockval);
      ret = __lock_get(dbenv___0, dbp___1->lid, 0U, (DBT const   *)(& __dbt), (enum __anonenum_db_lockmode_t_50 )2,
                       & elock);
      if (ret != 0) {
        goto err;
      }
    }
    break;
  }
  if ((unsigned int )fhp == (unsigned int )((void *)0)) {
    ret = __os_open(dbenv___0, name, 16U, 0, & fhp);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __fop_read_meta(dbenv___0, name, mbuf, sizeof(mbuf), fhp, 0, (size_t *)((void *)0));
  if (ret != 0) {
    goto err;
  }
  ret = __db_meta_setup(dbenv___0, dbp___1, name, (DBMETA *)(mbuf), flags, 1);
  if (ret != 0) {
    goto err;
  }
  ret = __fop_lock_handle(dbenv___0, dbp___1, dbp___1->lid, (enum __anonenum_db_lockmode_t_50 )2,
                          (DB_LOCK *)((void *)0), 1U);
  if (ret != 0) {
    if (! (flags & 8192U)) {
      __os_closehandle(dbenv___0, fhp);
      fhp = (DB_FH *)((void *)0);
    }
    if (ret == -30897) {
      if (! (elock.off != 0U)) {
        ret = 0;
      } else {
        ret = __lock_put(dbenv___0, & elock);
      }
      if (ret != 0) {
        goto err;
      }
    } else {
      if (ret != -30994) {
        goto err;
      } else {
        ret = __fop_lock_handle(dbenv___0, dbp___1, dbp___1->lid, (enum __anonenum_db_lockmode_t_50 )2,
                                & elock, 0U);
        if (ret != 0) {
          if (ret != -30897) {
            goto err;
          }
        }
      }
    }
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      dbp___1->lid = 0U;
    }
    __db_refresh(dbp___1, txn, 23U, (int *)((void *)0));
    goto retry;
  } else {
    if (! (elock.off != 0U)) {
      ret = 0;
    } else {
      ret = __lock_put(dbenv___0, & elock);
    }
    if (ret != 0) {
      goto err;
    }
  }
  ret = __memp_get_refcnt(dbenv___0, dbp___1->fileid, & cnt);
  if (ret != 0) {
    goto err;
  }
  if (cnt != 0) {
    ret = -30998;
  } else {
    if (dbp___1->flags & 16384U) {
      ret = 2;
    }
  }
  if (0) {
    err: 
    if (! (! (elock.off != 0U))) {
      __lock_put(dbenv___0, & elock);
    }
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    if (! (flags & 8192U)) {
      __os_closehandle(dbenv___0, fhp);
    }
  }
  if (ret == 0) {
    dbp___1->flags = dbp___1->flags | 256U;
  }
  return (ret);
}
}
int __fop_read_meta(DB_ENV *dbenv___0 , char const   *name , u_int8_t *buf , size_t size ,
                    DB_FH *fhp , int errok , size_t *nbytesp ) 
{ size_t nr ;
  int ret ;
  char *tmp ;

  {
  if ((unsigned int )nbytesp != (unsigned int )((void *)0)) {
    (*nbytesp) = 0U;
  }
  nr = 0U;
  ret = __os_read(dbenv___0, fhp, (void *)buf, size, & nr);
  if ((unsigned int )nbytesp != (unsigned int )((void *)0)) {
    (*nbytesp) = nr;
  }
  if (ret != 0) {
    if (! errok) {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", name, tmp);
    }
    goto err;
  }
  if (nr != size) {
    if (! errok) {
      __db_err((DB_ENV const   *)dbenv___0, "%s: unexpected file type or format",
               name);
    }
    ret = 22;
  }
  err: 
  return (ret);
}
}
int __fop_dummy(DB *dbp___1 , DB_TXN *txn , char const   *old , char const   *new ,
                u_int32_t flags ) 
{ DB *tmpdbp ;
  DB *t2dbp ;
  DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  DB_LOCK elock ;
  DB_LSN lsn ;
  DBT fiddbt ;
  DBT namedbt ;
  DBT tmpdbt ;
  DB_TXN *stxn ;
  char *back ;
  char *realback ;
  char *realnew ;
  char *realold ;
  int ret ;
  int t_ret ;
  size_t len ;
  u_int8_t mbuf[512] ;
  u_int32_t dflags ;
  u_int32_t locker ;
  u_int32_t stxnid ;
  DBT __dbt ;
  u_int32_t __lockval ;
  int tmp ;
  size_t tmp___0 ;

  {
  dbenv___0 = dbp___1->dbenv;
  elock.off = 0U;
  realback = (char *)((void *)0);
  realnew = (char *)((void *)0);
  realold = (char *)((void *)0);
  back = (char *)((void *)0);
  stxn = (DB_TXN *)((void *)0);
  t2dbp = (DB *)((void *)0);
  tmpdbp = t2dbp;
  fhp = (DB_FH *)((void *)0);
  if (dbp___1->flags & 32768U) {
    dflags = 16U;
  } else {
    dflags = 0U;
  }
  locker = txn->txnid;
  if ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0)) {
    ret = __txn_begin(dbenv___0, txn, & stxn, 0U);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __db_backup_name(dbenv___0, new, stxn, & back);
  if (ret != 0) {
    goto err;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, (char const   *)back,
                     flags, (DB_FH **)((void *)0), & realback);
  if (ret != 0) {
    goto err;
  }
  ret = __fop_create(dbenv___0, stxn, (DB_FH **)((void *)0), (char const   *)back,
                     (enum __anonenum_APPNAME_39 )1, 0, dflags);
  if (ret != 0) {
    goto err;
  }
  memset((void *)(mbuf), 0, sizeof(mbuf));
  ret = __os_fileid(dbenv___0, (char const   *)realback, 1, ((DBMETA *)(mbuf))->uid);
  if (ret != 0) {
    goto err;
  }
  ((DBMETA *)(mbuf))->magic = 198656U;
  ret = __fop_write(dbenv___0, stxn, (char const   *)back, (enum __anonenum_APPNAME_39 )1,
                    (DB_FH *)((void *)0), 0U, 0U, 0U, mbuf, 512U, 1U, dflags);
  if (ret != 0) {
    goto err;
  }
  ret = db_create(& tmpdbp, dbenv___0, 0U);
  if (ret != 0) {
    goto err;
  }
  memcpy((void * __restrict  )(& tmpdbp->fileid), (void const   * __restrict  )(((DBMETA *)(mbuf))->uid),
         20U);
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, new, 0U, (DB_FH **)((void *)0),
                     & realnew);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      __lockval = 1U;
      __dbt.data = (void *)(& __lockval);
      __dbt.size = sizeof(__lockval);
      ret = __lock_get(dbenv___0, locker, 0U, (DBT const   *)(& __dbt), (enum __anonenum_db_lockmode_t_50 )2,
                       & elock);
      if (ret != 0) {
        goto err;
      }
    }
    break;
  }
  tmp = __os_exists((char const   *)realnew, (int *)((void *)0));
  if (tmp == 0) {
    ret = db_create(& t2dbp, dbenv___0, 0U);
    if (ret != 0) {
      goto err;
    }
    ret = __os_open(dbenv___0, (char const   *)realnew, 0U, 0, & fhp);
    if (ret != 0) {
      goto err;
    }
    ret = __fop_read_meta(dbenv___0, (char const   *)realnew, mbuf, sizeof(mbuf),
                          fhp, 0, & len);
    if (ret != 0) {
      ret = 17;
      goto err;
    } else {
      ret = __db_meta_setup(dbenv___0, t2dbp, (char const   *)realnew, (DBMETA *)(mbuf),
                            0U, 1);
      if (ret != 0) {
        ret = 17;
        goto err;
      }
    }
    ret = __fop_lock_handle(dbenv___0, t2dbp, locker, (enum __anonenum_db_lockmode_t_50 )2,
                            (DB_LOCK *)((void *)0), 1U);
    if (ret != 0) {
      ret = 17;
    } else {
      __lock_put(dbenv___0, & t2dbp->handle_lock);
      if (! (t2dbp->flags & 16384U)) {
        ret = 17;
      }
    }
    t_ret = __os_closehandle(dbenv___0, fhp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    fhp = (DB_FH *)((void *)0);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __fop_rename(dbenv___0, stxn, old, new, dbp___1->fileid, (enum __anonenum_APPNAME_39 )1,
                     dflags);
  if (ret != 0) {
    goto err;
  }
  ret = __fop_rename(dbenv___0, stxn, (char const   *)back, old, tmpdbp->fileid, (enum __anonenum_APPNAME_39 )1,
                     dflags);
  if (ret != 0) {
    goto err;
  }
  ret = __fop_lock_handle(dbenv___0, tmpdbp, locker, (enum __anonenum_db_lockmode_t_50 )2,
                          & elock, 0U);
  if (ret != 0) {
    goto err;
  }
  tmpdbp->handle_lock.off = 0U;
  if ((unsigned int )stxn != (unsigned int )((void *)0)) {
    stxnid = stxn->txnid;
    ret = __txn_commit(stxn, 0U);
    stxn = (DB_TXN *)((void *)0);
    memset((void *)(& fiddbt), 0, sizeof(fiddbt));
    memset((void *)(& tmpdbt), 0, sizeof(fiddbt));
    memset((void *)(& namedbt), 0, sizeof(namedbt));
    fiddbt.data = (void *)(dbp___1->fileid);
    fiddbt.size = 20U;
    tmpdbt.data = (void *)(tmpdbp->fileid);
    tmpdbt.size = 20U;
    namedbt.data = (void *)old;
    tmp___0 = strlen(old);
    namedbt.size = tmp___0 + 1U;
    t_ret = __fop_file_remove_log(dbenv___0, txn, & lsn, 0U, (DBT const   *)(& fiddbt),
                                  (DBT const   *)(& tmpdbt), (DBT const   *)(& namedbt),
                                  1U, stxnid);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, old, flags, (DB_FH **)((void *)0),
                     & realold);
  if (ret != 0) {
    goto err;
  }
  ret = __txn_remevent(dbenv___0, txn, (char const   *)realold, (u_int8_t *)((void *)0));
  if (ret != 0) {
    goto err;
  }
  err: 
  if (! (! (elock.off != 0U))) {
    __lock_put(dbenv___0, & elock);
  }
  if ((unsigned int )stxn != (unsigned int )((void *)0)) {
    __txn_abort(stxn);
  }
  if ((unsigned int )tmpdbp != (unsigned int )((void *)0)) {
    t_ret = __db_close(tmpdbp, (DB_TXN *)((void *)0), 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )t2dbp != (unsigned int )((void *)0)) {
    t_ret = __db_close(t2dbp, (DB_TXN *)((void *)0), 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, fhp);
  }
  if ((unsigned int )realold != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)realold);
  }
  if ((unsigned int )realnew != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)realnew);
  }
  if ((unsigned int )realback != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)realback);
  }
  if ((unsigned int )back != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)back);
  }
  return (ret);
}
}
int __fop_dbrename(DB *dbp___1 , char const   *old , char const   *new ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCK elock ;
  char *real_new ;
  char *real_old ;
  int ret ;
  int tret ;
  DBT __dbt ;
  u_int32_t __lockval ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  real_new = (char *)((void *)0);
  real_old = (char *)((void *)0);
  elock.off = 0U;
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, new, 0U, (DB_FH **)((void *)0),
                     & real_new);
  if (ret != 0) {
    goto err;
  }
  while (1) {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      __lockval = 1U;
      __dbt.data = (void *)(& __lockval);
      __dbt.size = sizeof(__lockval);
      ret = __lock_get(dbenv___0, dbp___1->lid, 0U, (DBT const   *)(& __dbt), (enum __anonenum_db_lockmode_t_50 )2,
                       & elock);
      if (ret != 0) {
        goto err;
      }
    }
    break;
  }
  tmp = __os_exists((char const   *)real_new, (int *)((void *)0));
  if (tmp == 0) {
    ret = 17;
    __db_err((DB_ENV const   *)dbenv___0, "rename: file %s exists", real_new);
    goto err;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, old, 0U, (DB_FH **)((void *)0),
                     & real_old);
  if (ret != 0) {
    goto err;
  }
  ret = __memp_nameop(dbenv___0, dbp___1->fileid, new, (char const   *)real_old, (char const   *)real_new);
  err: 
  if (! (elock.off != 0U)) {
    tret = 0;
  } else {
    tret = __lock_put(dbenv___0, & elock);
  }
  if (tret != 0) {
    if (ret == 0) {
      ret = tret;
    }
  }
  if ((unsigned int )real_old != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_old);
  }
  if ((unsigned int )real_new != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)real_new);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-jV6aeYjo.i","-O2")
u_int32_t __ham_func2(DB *dbp___1 , void const   *key , u_int32_t len ) ;
u_int32_t __ham_func3(DB *dbp___1 , void const   *key , u_int32_t len ) ;
u_int32_t __ham_test(DB *dbp___1 , void const   *key , u_int32_t len ) ;
u_int32_t __ham_func2(DB *dbp___1 , void const   *key , u_int32_t len ) 
{ u_int8_t const   *e ;
  u_int8_t const   *k ;
  u_int32_t h ;
  u_int8_t c ;
  u_int8_t const   *tmp ;

  {
  if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
    dbp___1 = (DB *)((void *)0);
  }
  dbp___1 = dbp___1;
  k = (u_int8_t const   *)key;
  e = k + len;
  h = 0U;
  while ((unsigned int )k != (unsigned int )e) {
    tmp = k;
    k ++;
    c = (*tmp);
    if (! c) {
      if ((unsigned int )k > (unsigned int )e) {
        break;
      }
    }
    h = (1673936089U * h + 2621031229U) + (unsigned int )c;
  }
  return (h);
}
}
u_int32_t __ham_func3(DB *dbp___1 , void const   *key , u_int32_t len ) 
{ u_int8_t const   *k ;
  u_int32_t n ;
  u_int32_t loop ;
  u_int8_t const   *tmp ;
  u_int8_t const   *tmp___0 ;
  u_int8_t const   *tmp___1 ;
  u_int8_t const   *tmp___2 ;
  u_int8_t const   *tmp___3 ;
  u_int8_t const   *tmp___4 ;
  u_int8_t const   *tmp___5 ;
  u_int8_t const   *tmp___6 ;

  {
  if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
    dbp___1 = (DB *)((void *)0);
  }
  dbp___1 = dbp___1;
  if (len == 0U) {
    return (0U);
  }
  n = 0U;
  k = (u_int8_t const   *)key;
  loop = ((len + 8U) - 1U) >> 3;
  switch ((int )(len & 7U)) {
  case 0: ;
  while (1) {
    tmp = k;
    k ++;
    n = (unsigned int )(*tmp) + 65599U * n;
    case 7: 
    tmp___0 = k;
    k ++;
    n = (unsigned int )(*tmp___0) + 65599U * n;
    case 6: 
    tmp___1 = k;
    k ++;
    n = (unsigned int )(*tmp___1) + 65599U * n;
    case 5: 
    tmp___2 = k;
    k ++;
    n = (unsigned int )(*tmp___2) + 65599U * n;
    case 4: 
    tmp___3 = k;
    k ++;
    n = (unsigned int )(*tmp___3) + 65599U * n;
    case 3: 
    tmp___4 = k;
    k ++;
    n = (unsigned int )(*tmp___4) + 65599U * n;
    case 2: 
    tmp___5 = k;
    k ++;
    n = (unsigned int )(*tmp___5) + 65599U * n;
    case 1: 
    tmp___6 = k;
    k ++;
    n = (unsigned int )(*tmp___6) + 65599U * n;
    loop --;
    if (! loop) {
      break;
    }
  }
  }
  return (n);
}
}
u_int32_t __ham_func4(DB *dbp___1 , void const   *key , u_int32_t len ) 
{ u_int8_t const   *k ;
  u_int32_t h ;
  u_int32_t loop ;
  u_int8_t const   *tmp ;
  u_int8_t const   *tmp___0 ;
  u_int8_t const   *tmp___1 ;
  u_int8_t const   *tmp___2 ;
  u_int8_t const   *tmp___3 ;
  u_int8_t const   *tmp___4 ;
  u_int8_t const   *tmp___5 ;
  u_int8_t const   *tmp___6 ;

  {
  if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
    dbp___1 = (DB *)((void *)0);
  }
  dbp___1 = dbp___1;
  if (len == 0U) {
    return (0U);
  }
  h = 0U;
  k = (u_int8_t const   *)key;
  loop = ((len + 8U) - 1U) >> 3;
  switch ((int )(len & 7U)) {
  case 0: ;
  while (1) {
    tmp = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp);
    case 7: 
    tmp___0 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___0);
    case 6: 
    tmp___1 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___1);
    case 5: 
    tmp___2 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___2);
    case 4: 
    tmp___3 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___3);
    case 3: 
    tmp___4 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___4);
    case 2: 
    tmp___5 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___5);
    case 1: 
    tmp___6 = k;
    k ++;
    h = ((h << 5) + h) + (unsigned int )(*tmp___6);
    loop --;
    if (! loop) {
      break;
    }
  }
  }
  return (h);
}
}
u_int32_t __ham_func5(DB *dbp___1 , void const   *key , u_int32_t len ) 
{ u_int8_t const   *k ;
  u_int8_t const   *e ;
  u_int32_t h ;

  {
  if ((unsigned int )dbp___1 != (unsigned int )((void *)0)) {
    dbp___1 = (DB *)((void *)0);
  }
  dbp___1 = dbp___1;
  k = (u_int8_t const   *)key;
  e = k + len;
  h = 0U;
  while ((unsigned int )k < (unsigned int )e) {
    h *= 16777619U;
    h ^= (unsigned int )(*k);
    k ++;
  }
  return (h);
}
}
u_int32_t __ham_test(DB *dbp___1 , void const   *key , u_int32_t len ) 
{ 

  {
  dbp___1 = (DB *)((void *)0);
  dbp___1 = dbp___1;
  len = 0U;
  len = len;
  return ((unsigned int )(*((char *)key)));
}
}
#pragma merger(0,"/tmp/cil-UpfpArI4.i","-O2")
static void __db_hmac(u_int8_t *k , u_int8_t *data , size_t data_len , u_int8_t *mac ) ;
static void __db_hmac(u_int8_t *k , u_int8_t *data , size_t data_len , u_int8_t *mac ) 
{ SHA1_CTX ctx ;
  u_int8_t key[64] ;
  u_int8_t ipad[64] ;
  u_int8_t opad[64] ;
  u_int8_t tmp[20] ;
  int i ;

  {
  memset((void *)(key), 0, 64U);
  memset((void *)(ipad), 54, 64U);
  memset((void *)(opad), 92, 64U);
  memcpy((void * __restrict  )(key), (void const   * __restrict  )k, 20U);
  i = 0;
  while (i < 64) {
    ipad[i] = (unsigned char )((int )ipad[i] ^ (int )key[i]);
    opad[i] = (unsigned char )((int )opad[i] ^ (int )key[i]);
    i ++;
  }
  __db_SHA1Init(& ctx);
  __db_SHA1Update(& ctx, ipad, 64U);
  __db_SHA1Update(& ctx, data, data_len);
  __db_SHA1Final(tmp, & ctx);
  __db_SHA1Init(& ctx);
  __db_SHA1Update(& ctx, opad, 64U);
  __db_SHA1Update(& ctx, tmp, 20U);
  __db_SHA1Final(mac, & ctx);
  return;
}
}
void __db_chksum(u_int8_t *data , size_t data_len , u_int8_t *mac_key , u_int8_t *store ) 
{ int sumlen ;
  u_int32_t hash4 ;
  u_int8_t tmp[20] ;

  {
  if ((unsigned int )mac_key == (unsigned int )((void *)0)) {
    sumlen = (int )sizeof(u_int32_t );
  } else {
    sumlen = 20;
  }
  memset((void *)store, 0, (unsigned int )sumlen);
  if ((unsigned int )mac_key == (unsigned int )((void *)0)) {
    hash4 = __ham_func4((DB *)((void *)0), (void const   *)data, data_len);
    memcpy((void * __restrict  )store, (void const   * __restrict  )(& hash4), (unsigned int )sumlen);
  } else {
    memset((void *)(tmp), 0, 20U);
    __db_hmac(mac_key, data, data_len, tmp);
    memcpy((void * __restrict  )store, (void const   * __restrict  )(tmp), (unsigned int )sumlen);
  }
  return;
}
}
void __db_derive_mac(u_int8_t *passwd , size_t plen , u_int8_t *mac_key ) 
{ SHA1_CTX ctx ;
  size_t tmp ;

  {
  __db_SHA1Init(& ctx);
  __db_SHA1Update(& ctx, passwd, plen);
  tmp = strlen("mac derivation key magic value");
  __db_SHA1Update(& ctx, (u_int8_t *)"mac derivation key magic value", tmp);
  __db_SHA1Update(& ctx, passwd, plen);
  __db_SHA1Final(mac_key, & ctx);
  return;
}
}
int __db_check_chksum(DB_ENV *dbenv___0 , DB_CIPHER *db_cipher , u_int8_t *chksum ,
                      void *data , size_t data_len , int is_hmac ) 
{ int ret ;
  size_t sum_len ;
  u_int32_t hash4 ;
  u_int8_t *mac_key ;
  u_int8_t old[20] ;
  u_int8_t new[20] ;
  int tmp___0 ;
  int tmp___2 ;

  {
  if (is_hmac == 0) {
    if ((unsigned int )db_cipher != (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "Unencrypted checksum with a supplied encryption key");
      return (22);
    }
    sum_len = sizeof(u_int32_t );
    mac_key = (u_int8_t *)((void *)0);
  } else {
    if ((unsigned int )db_cipher == (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "Encrypted checksum: no encryption key specified");
      return (22);
    }
    sum_len = 20U;
    mac_key = db_cipher->mac_key;
  }
  memcpy((void * __restrict  )(old), (void const   * __restrict  )chksum, sum_len);
  memset((void *)chksum, 0, sum_len);
  if ((unsigned int )mac_key == (unsigned int )((void *)0)) {
    hash4 = __ham_func4((DB *)((void *)0), (void const   *)data, data_len);
    tmp___0 = memcmp((void const   *)((u_int32_t *)(old)), (void const   *)(& hash4),
                     sum_len);
    if (tmp___0) {
      ret = -1;
    } else {
      ret = 0;
    }
  } else {
    __db_hmac(mac_key, (u_int8_t *)data, data_len, new);
    tmp___2 = memcmp((void const   *)(old), (void const   *)(new), sum_len);
    if (tmp___2) {
      ret = -1;
    } else {
      ret = 0;
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-0U6bpLkE.i","-O2")
int __db_hcreate(size_t nel ) ;
ENTRY *__db_hsearch(ENTRY item , ACTION action ) ;
void __db_hdestroy(void) ;
static DB *dbp___0  ;
static ENTRY retval  ;
int __db_hcreate(size_t nel ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;

  {
  ret = db_create(& dbp___0, (DB_ENV *)((void *)0), 0U);
  if (ret != 0) {
    __os_set_errno(ret);
    return (1);
  }
  ret = ((*(dbp___0->set_pagesize)))(dbp___0, 512U);
  if (ret != 0) {
    __os_set_errno(ret);
  } else {
    ret = ((*(dbp___0->set_h_ffactor)))(dbp___0, 16U);
    if (ret != 0) {
      __os_set_errno(ret);
    } else {
      ret = ((*(dbp___0->set_h_nelem)))(dbp___0, nel);
      if (ret != 0) {
        __os_set_errno(ret);
      } else {
        tmp = __db_omode("rw----");
        ret = ((*(dbp___0->open)))(dbp___0, (DB_TXN *)((void *)0), (char const   *)((void *)0),
                                   (char const   *)((void *)0), (enum __anonenum_DBTYPE_61 )2,
                                   1U, tmp);
        if (ret != 0) {
          __os_set_errno(ret);
        }
      }
    }
  }
  if (ret == 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
ENTRY *__db_hsearch(ENTRY item , ACTION action ) 
{ DBT key ;
  DBT val ;
  int ret ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned int )dbp___0 == (unsigned int )((void *)0)) {
    __os_set_errno(22);
    return ((ENTRY *)((void *)0));
  }
  memset((void *)(& key), 0, sizeof(key));
  memset((void *)(& val), 0, sizeof(val));
  key.data = (void *)item.key;
  tmp = strlen((char const   *)item.key);
  key.size = tmp + 1U;
  switch ((int )action) {
  case 1: 
  val.data = (void *)item.data;
  tmp___0 = strlen((char const   *)item.data);
  val.size = tmp___0 + 1U;
  ret = ((*(dbp___0->put)))(dbp___0, (DB_TXN *)((void *)0), & key, & val, 22U);
  if (ret == 0) {
    break;
  }
  if (ret == -30996) {
    ret = ((*(dbp___0->get)))(dbp___0, (DB_TXN *)((void *)0), & key, & val, 0U);
    if (ret == 0) {
      break;
    }
  }
  if (ret > 0) {
    tmp___1 = ret;
  } else {
    tmp___1 = 22;
  }
  __os_set_errno(tmp___1);
  return ((ENTRY *)((void *)0));
  case 0: 
  ret = ((*(dbp___0->get)))(dbp___0, (DB_TXN *)((void *)0), & key, & val, 0U);
  if (ret != 0) {
    if (ret != -30990) {
      __os_set_errno(ret);
    }
    return ((ENTRY *)((void *)0));
  }
  item.data = (char *)val.data;
  break;
  default: 
  __os_set_errno(22);
  return ((ENTRY *)((void *)0));
  }
  retval.key = item.key;
  retval.data = item.data;
  return (& retval);
}
}
void __db_hdestroy(void) 
{ 

  {
  if ((unsigned int )dbp___0 != (unsigned int )((void *)0)) {
    ((*(dbp___0->close)))(dbp___0, 0U);
    dbp___0 = (DB *)((void *)0);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-hgdt6RC2.i","-O2")
int __lock_id_pp(DB_ENV *dbenv___0 , u_int32_t *idp ) ;
int __lock_id_free_pp(DB_ENV *dbenv___0 , u_int32_t id ) ;
int __lock_vec_pp(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DB_LOCKREQ *list___2 ,
                  int nlist___0 , DB_LOCKREQ **elistp ) ;
int __lock_get_pp(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DBT const   *obj ,
                  db_lockmode_t lock_mode , DB_LOCK *lock ) ;
int __lock_put_pp(DB_ENV *dbenv___0 , DB_LOCK *lock ) ;
int __lock_addfamilylocker(DB_ENV *dbenv___0 , u_int32_t pid , u_int32_t id ) ;
int __lock_freefamilylocker(DB_LOCKTAB *lt , u_int32_t locker ) ;
int __lock_set_timeout(DB_ENV *dbenv___0 , u_int32_t locker , db_timeout_t timeout ,
                       u_int32_t op ) ;
int __lock_inherit_timeout(DB_ENV *dbenv___0 , u_int32_t parent , u_int32_t locker ) ;
int __lock_getlocker(DB_LOCKTAB *lt , u_int32_t locker , u_int32_t indx , int create ,
                     DB_LOCKER **retp ) ;
int __lock_promote(DB_LOCKTAB *lt , DB_LOCKOBJ *obj , u_int32_t flags ) ;
int __lock_expired(DB_ENV *dbenv___0 , db_timeval_t *now , db_timeval_t *timevalp ) ;
int __lock_detect(DB_ENV *dbenv___0 , u_int32_t atype , int *abortp ) ;
int __lock_cmp(DBT const   *dbt , DB_LOCKOBJ *lock_obj ) ;
int __lock_locker_cmp(u_int32_t locker , DB_LOCKER *sh_locker ) ;
u_int32_t __lock_ohash(DBT const   *dbt ) ;
u_int32_t __lock_lhash(DB_LOCKOBJ *lock_obj ) ;
u_int32_t __lock_locker_hash(u_int32_t locker ) ;
static int __lock_freelock(DB_LOCKTAB *lt , struct __db_lock *lockp , u_int32_t locker ,
                           u_int32_t flags ) ;
static void __lock_expires(DB_ENV *dbenv___0 , db_timeval_t *timevalp , db_timeout_t timeout ) ;
static void __lock_freelocker(DB_LOCKTAB *lt , DB_LOCKREGION *region , DB_LOCKER *sh_locker ,
                              u_int32_t indx ) ;
static int __lock_get_internal(DB_LOCKTAB *lt , u_int32_t locker , u_int32_t flags ,
                               DBT const   *obj , db_lockmode_t lock_mode , db_timeout_t timeout ,
                               DB_LOCK *lock ) ;
static int __lock_getobj(DB_LOCKTAB *lt , DBT const   *obj , u_int32_t ndx , int create ,
                         DB_LOCKOBJ **retp ) ;
static int __lock_inherit_locks(DB_LOCKTAB *lt , u_int32_t locker , u_int32_t flags ) ;
static int __lock_is_parent(DB_LOCKTAB *lt , u_int32_t locker , DB_LOCKER *sh_locker ) ;
static int __lock_put_internal(DB_LOCKTAB *lt , struct __db_lock *lockp , u_int32_t obj_ndx ,
                               u_int32_t flags ) ;
static int __lock_put_nolock(DB_ENV *dbenv___0 , DB_LOCK *lock , int *runp , u_int32_t flags ) ;
static void __lock_remove_waiter(DB_LOCKTAB *lt , DB_LOCKOBJ *sh_obj , struct __db_lock *lockp ,
                                 db_status_t status ) ;
static int __lock_set_timeout_internal(DB_ENV *dbenv___0 , u_int32_t locker , db_timeout_t timeout ,
                                       u_int32_t op ) ;
static int __lock_trade(DB_ENV *dbenv___0 , DB_LOCK *lock , u_int32_t new_locker ) ;
static int __lock_sort_cmp(void const   *a , void const   *b ) ;
static int __lock_fix_list(DB_ENV *dbenv___0 , DBT *list_dbt , u_int32_t nlocks ) ;
static char const   __db_lock_err[34]  = 
  {      (char const   )'L',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'t',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'a',      (char const   )'v',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )'\000'};
static char const   __db_lock_invalid[28]  = 
  {      (char const   )'%',      (char const   )'s',      (char const   )':',      (char const   )' ', 
        (char const   )'L',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'n',      (char const   )'g',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
static char const   __db_locker_invalid[20]  = 
  {      (char const   )'L',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
int __lock_id_pp(DB_ENV *dbenv___0 , u_int32_t *idp ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_id", 8192U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_id(dbenv___0, idp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __lock_id(DB_ENV *dbenv___0 , u_int32_t *idp ) 
{ DB_LOCKER *lk ;
  DB_LOCKTAB *lt ;
  DB_LOCKREGION *region ;
  u_int32_t *ids ;
  u_int32_t locker_ndx ;
  int nids ;
  int ret ;
  int tmp ;
  u_int32_t tmp___0 ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  ret = 0;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  if (region->stat.st_id == 2147483647U) {
    if (region->stat.st_cur_maxid != 2147483647U) {
      region->stat.st_id = 0U;
    }
  }
  if (region->stat.st_id == region->stat.st_cur_maxid) {
    ret = __os_malloc(dbenv___0, sizeof(u_int32_t ) * region->stat.st_nlockers, (void *)(& ids));
    if (ret != 0) {
      goto err;
    }
    nids = 0;
    if (region->lockers.stqh_first == -1) {
      lk = (DB_LOCKER *)((void *)0);
    } else {
      lk = (struct __db_locker *)((u_int8_t *)(& region->lockers) + region->lockers.stqh_first);
    }
    while ((unsigned int )lk != (unsigned int )((void *)0)) {
      tmp = nids;
      nids ++;
      (*(ids + tmp)) = lk->id;
      if (lk->ulinks.stqe_next == -1) {
        lk = (DB_LOCKER *)((void *)0);
      } else {
        lk = (struct __db_locker *)((u_int8_t *)lk + lk->ulinks.stqe_next);
      }
    }
    region->stat.st_id = 0U;
    region->stat.st_cur_maxid = 2147483647U;
    if (nids != 0) {
      __db_idspace(ids, nids, & region->stat.st_id, & region->stat.st_cur_maxid);
    }
    __os_free(dbenv___0, (void *)ids);
  }
  region->stat.st_id = region->stat.st_id + 1U;
  (*idp) = region->stat.st_id;
  tmp___0 = __lock_locker_hash((*idp));
  locker_ndx = tmp___0 % region->locker_t_size;
  ret = __lock_getlocker(lt, (*idp), locker_ndx, 1, & lk);
  err: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __lock_id_free_pp(DB_ENV *dbenv___0 , u_int32_t id ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_id_free", 8192U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_id_free(dbenv___0, id);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __lock_id_free(DB_ENV *dbenv___0 , u_int32_t id ) 
{ DB_LOCKER *sh_locker ;
  DB_LOCKTAB *lt ;
  DB_LOCKREGION *region ;
  u_int32_t locker_ndx ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  u_int32_t tmp___1 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_id_free", 8192U);
    return (tmp___0);
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  tmp___1 = __lock_locker_hash(id);
  locker_ndx = tmp___1 % region->locker_t_size;
  ret = __lock_getlocker(lt, id, locker_ndx, 0, & sh_locker);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
    ret = 22;
    goto err;
  }
  if (sh_locker->nlocks != 0U) {
    __db_err((DB_ENV const   *)dbenv___0, "Locker still has locks");
    ret = 22;
    goto err;
  }
  __lock_freelocker(lt, region, sh_locker, locker_ndx);
  err: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __lock_vec_pp(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DB_LOCKREQ *list___2 ,
                  int nlist___0 , DB_LOCKREQ **elistp ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_vec", 8192U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->lock_vec", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_vec(dbenv___0, locker, flags, list___2, nlist___0, elistp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __lock_vec(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DB_LOCKREQ *list___2 ,
               int nlist___0 , DB_LOCKREQ **elistp ) 
{ struct __db_lock *lp ;
  struct __db_lock *next_lock ;
  DB_LOCK lock ;
  DB_LOCKER *sh_locker ;
  DB_LOCKOBJ *sh_obj ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  DBT *objlist ;
  DBT *np ;
  u_int32_t lndx ;
  u_int32_t ndx ;
  int did_abort ;
  int i ;
  int ret ;
  int run_dd ;
  int upgrade ;
  int writes ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;

  {
  if (dbenv___0->flags & 1024U) {
    return (0);
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  run_dd = 0;
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  i = 0;
  ret = 0;
  while (1) {
    if (i < nlist___0) {
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    switch ((int )(list___2 + i)->op) {
    case 2: 
    flags |= 8U;
    case 1: ;
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
        (list___2 + i)->lock.off = 0U;
        break;
      }
    }
    ret = __lock_get_internal((DB_LOCKTAB *)dbenv___0->lk_handle, locker, flags, (DBT const   *)(list___2 +
                                                                                                 i)->obj,
                              (list___2 + i)->mode, (list___2 + i)->timeout, & (list___2 +
                                                                                i)->lock);
    break;
    case 3: 
    ret = __lock_inherit_locks(lt, locker, flags);
    break;
    case 4: 
    ret = __lock_put_nolock(dbenv___0, & (list___2 + i)->lock, & run_dd, flags);
    break;
    case 5: ;
    case 7: ;
    case 10: 
    tmp = __lock_locker_hash(locker);
    ndx = tmp % region->locker_t_size;
    ret = __lock_getlocker(lt, locker, ndx, 0, & sh_locker);
    if (ret != 0) {
      break;
    } else {
      if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
        break;
      } else {
        if (sh_locker->flags & 1U) {
          break;
        }
      }
    }
    upgrade = 0;
    writes = 1;
    if ((int )(list___2 + i)->op == 7) {
      writes = 0;
    } else {
      if ((int )(list___2 + i)->op == 10) {
        if (sh_locker->flags & 2U) {
          upgrade = 1;
        }
        writes = 0;
      }
    }
    objlist = (list___2 + i)->obj;
    if ((unsigned int )objlist != (unsigned int )((void *)0)) {
      objlist->size = sh_locker->nwrites * sizeof(DBT );
      ret = __os_malloc(dbenv___0, objlist->size, (void *)(& objlist->data));
      if (ret != 0) {
        goto up_done;
      }
      memset(objlist->data, 0, objlist->size);
      np = (DBT *)objlist->data;
    } else {
      np = (DBT *)((void *)0);
    }
    sh_locker->flags |= 1U;
    if (sh_locker->heldby.slh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first);
    }
    while ((unsigned int )lp != (unsigned int )((void *)0)) {
      sh_obj = (DB_LOCKOBJ *)((u_int8_t *)lp + lp->obj);
      if (lp->locker_links.sle_next == -1) {
        next_lock = (struct __db_lock *)((void *)0);
      } else {
        next_lock = (struct __db_lock *)((u_int8_t *)lp + lp->locker_links.sle_next);
      }
      if (writes == 1) {
        goto _L;
      } else {
        if ((int )lp->mode == 1) {
          goto _L;
        } else {
          if ((int )lp->mode == 7) {
            _L: 
            while (1) {
              if (lp->locker_links.sle_next != -1) {
                ((struct __db_lock *)((u_int8_t *)lp + lp->locker_links.sle_next))->locker_links.sle_prev = lp->locker_links.sle_prev -
                                                                                                            lp->locker_links.sle_next;
                (*((ssize_t *)((u_int8_t *)lp + lp->locker_links.sle_prev))) = (*((ssize_t *)((u_int8_t *)lp +
                                                                                              lp->locker_links.sle_prev))) +
                                                                               lp->locker_links.sle_next;
              } else {
                (*((ssize_t *)((u_int8_t *)lp + lp->locker_links.sle_prev))) = -1;
              }
              break;
            }
            sh_obj = (DB_LOCKOBJ *)((u_int8_t *)lp + lp->obj);
            tmp___0 = __lock_lhash(sh_obj);
            lndx = tmp___0 % region->object_t_size;
            sh_locker->nlocks --;
            if ((int )lp->mode == 2) {
              sh_locker->nwrites --;
            } else {
              if ((int )lp->mode == 8) {
                sh_locker->nwrites --;
              } else {
                if ((int )lp->mode == 4) {
                  sh_locker->nwrites --;
                } else {
                  if ((int )lp->mode == 6) {
                    sh_locker->nwrites --;
                  }
                }
              }
            }
            ret = __lock_put_internal(lt, lp, lndx, 196608U);
            if (ret != 0) {
              break;
            }
            goto __Cont;
          }
        }
      }
      if ((unsigned int )objlist != (unsigned int )((void *)0)) {
        np->data = (void *)((u_int8_t *)(& sh_obj->lockobj) + sh_obj->lockobj.off);
        np->size = sh_obj->lockobj.size;
        np ++;
      }
      __Cont: 
      lp = next_lock;
    }
    if (ret != 0) {
      goto up_done;
    }
    if ((unsigned int )objlist != (unsigned int )((void *)0)) {
      ret = __lock_fix_list(dbenv___0, objlist, sh_locker->nwrites);
      if (ret != 0) {
        goto up_done;
      }
    }
    switch ((int )(list___2 + i)->op) {
    case 10: ;
    if (upgrade != 1) {
      goto up_done;
    }
    if (sh_locker->heldby.slh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first);
    }
    while ((unsigned int )lp != (unsigned int )((void *)0)) {
      if ((int )lp->mode != 8) {
        goto __Cont___0;
      }
      lock.off = (unsigned int )((u_int8_t *)lp - (u_int8_t *)lt->reginfo.addr);
      lock.gen = lp->gen;
      sh_locker->flags |= 4U;
      ret = __lock_get_internal(lt, locker, 32U, (DBT const   *)((void *)0), (enum __anonenum_db_lockmode_t_50 )2,
                                0U, & lock);
      if (ret != 0) {
        break;
      }
      __Cont___0: 
      if (lp->locker_links.sle_next == -1) {
        lp = (struct __db_lock *)((void *)0);
      } else {
        lp = (struct __db_lock *)((u_int8_t *)lp + lp->locker_links.sle_next);
      }
    }
    up_done: 
    case 7: ;
    case 5: 
    sh_locker->flags &= 4294967294U;
    break;
    default: ;
    break;
    }
    break;
    case 6: 
    tmp___1 = __lock_ohash((DBT const   *)(list___2 + i)->obj);
    ndx = tmp___1 % region->object_t_size;
    ret = __lock_getobj(lt, (DBT const   *)(list___2 + i)->obj, ndx, 0, & sh_obj);
    if (ret != 0) {
      goto _L___0;
    } else {
      if ((unsigned int )sh_obj == (unsigned int )((void *)0)) {
        _L___0: 
        if (ret == 0) {
          ret = 22;
        }
        break;
      }
    }
    if (sh_obj->waiters.stqh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
    }
    while (1) {
      if (ret == 0) {
        if (! ((unsigned int )lp != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      ret = __lock_put_internal(lt, lp, ndx, 851968U);
      if (sh_obj->waiters.stqh_first == -1) {
        lp = (struct __db_lock *)((void *)0);
      } else {
        lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
      }
    }
    if (sh_obj->holders.stqh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->holders) + sh_obj->holders.stqh_first);
    }
    while (1) {
      if (ret == 0) {
        if (! ((unsigned int )lp != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      if (lp->links.stqe_next == -1) {
        next_lock = (struct __db_lock *)((void *)0);
      } else {
        next_lock = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
      }
      ret = __lock_put_internal(lt, lp, ndx, 851968U);
      lp = next_lock;
    }
    break;
    case 8: 
    ret = __lock_set_timeout_internal(dbenv___0, locker, 0U, 32U);
    break;
    case 9: 
    ret = __lock_trade(dbenv___0, & (list___2 + i)->lock, locker);
    break;
    default: 
    __db_err((DB_ENV const   *)dbenv___0, "Invalid lock operation: %d", (list___2 +
                                                                         i)->op);
    ret = 22;
    break;
    }
    i ++;
  }
  if (ret == 0) {
    if (region->detect != 0U) {
      if (region->need_dd) {
        run_dd = 1;
      } else {
        if (region->next_timeout.tv_sec != 0U) {
          run_dd = 1;
        }
      }
    }
  }
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  if (run_dd) {
    __lock_detect(dbenv___0, region->detect, & did_abort);
  }
  if (ret != 0) {
    if ((unsigned int )elistp != (unsigned int )((void *)0)) {
      (*elistp) = list___2 + (i - 1);
    }
  }
  return (ret);
}
}
int __lock_get_pp(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DBT const   *obj ,
                  db_lockmode_t lock_mode , DB_LOCK *lock ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_get", 8192U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->lock_get", flags, 49U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_get(dbenv___0, locker, flags, obj, lock_mode, lock);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __lock_get(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , DBT const   *obj ,
               db_lockmode_t lock_mode , DB_LOCK *lock ) 
{ int ret ;

  {
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      lock->off = 0U;
      return (0);
    }
  }
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  ret = __lock_get_internal((DB_LOCKTAB *)dbenv___0->lk_handle, locker, flags, obj,
                            lock_mode, 0U, lock);
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static int __lock_get_internal(DB_LOCKTAB *lt , u_int32_t locker , u_int32_t flags ,
                               DBT const   *obj , db_lockmode_t lock_mode , db_timeout_t timeout ,
                               DB_LOCK *lock ) 
{ struct __db_lock *newl ;
  struct __db_lock *lp ;
  struct __db_lock *wwrite ;
  DB_ENV *dbenv___0 ;
  DB_LOCKER *sh_locker ;
  DB_LOCKOBJ *sh_obj ;
  DB_LOCKREGION *region ;
  u_int32_t holder ;
  u_int32_t locker_ndx ;
  u_int32_t obj_ndx ;
  int did_abort ;
  int ihold ;
  int grant_dirty ;
  int no_dd ;
  int ret ;
  int t_ret ;
  enum __anonenum_action_70 action ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct __db_locker *tmp___3 ;
  struct __db_lock *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int32_t tmp___9 ;
  int tmp___10 ;

  {
  dbenv___0 = lt->dbenv;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (dbenv___0->flags & 1024U) {
    return (0);
  }
  ret = 0;
  no_dd = ret;
  newl = (struct __db_lock *)((void *)0);
  if (! (flags & 48U)) {
    lock->off = 0U;
  }
  if ((unsigned int )lock_mode >= region->stat.st_nmodes) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->lock_get: invalid lock mode %lu",
             (unsigned long )lock_mode);
    return (22);
  }
  region->stat.st_nrequests = region->stat.st_nrequests + 1U;
  if ((unsigned int )obj == (unsigned int )((void *)0)) {
    lp = (struct __db_lock *)((void *)((u_int8_t *)lt->reginfo.addr + lock->off));
    sh_obj = (DB_LOCKOBJ *)((u_int8_t *)lp + lp->obj);
  } else {
    tmp = __lock_ohash(obj);
    lock->ndx = tmp % region->object_t_size;
    ret = __lock_getobj(lt, obj, lock->ndx, 1, & sh_obj);
    if (ret != 0) {
      goto err;
    }
  }
  tmp___0 = __lock_locker_hash(locker);
  locker_ndx = tmp___0 % region->locker_t_size;
  if (locker > 2147483647U) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  ret = __lock_getlocker(lt, locker, locker_ndx, tmp___1, & sh_locker);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Locker does not exist");
    ret = 22;
    goto err;
  }
  ihold = 0;
  grant_dirty = 0;
  holder = 0U;
  wwrite = (struct __db_lock *)((void *)0);
  if (flags & 16U) {
    lp = (struct __db_lock *)((void *)0);
  } else {
    if (sh_obj->holders.stqh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->holders) + sh_obj->holders.stqh_first);
    }
  }
  while ((unsigned int )lp != (unsigned int )((void *)0)) {
    if (locker == lp->holder) {
      if ((int )lp->mode == (int )lock_mode) {
        if ((int )lp->status == 5) {
          if (flags & 32U) {
            goto upgrade;
          }
          lp->refcount ++;
          lock->off = (unsigned int )((u_int8_t *)lp - (u_int8_t *)lt->reginfo.addr);
          lock->gen = lp->gen;
          lock->mode = lp->mode;
          goto done;
        } else {
          goto _L;
        }
      } else {
        _L: 
        ihold = 1;
        if ((int )lock_mode == 2) {
          if ((int )lp->mode == 8) {
            wwrite = lp;
          }
        }
      }
    } else {
      tmp___2 = __lock_is_parent(lt, lp->holder, sh_locker);
      if (tmp___2) {
        ihold = 1;
      } else {
        if ((*(lt->conflicts + ((unsigned int )lp->mode * region->stat.st_nmodes +
                                (unsigned int )lock_mode)))) {
          break;
        } else {
          if ((int )lp->mode == 1) {
            grant_dirty = 1;
            holder = lp->holder;
          } else {
            if ((int )lp->mode == 8) {
              grant_dirty = 1;
              holder = lp->holder;
            }
          }
        }
      }
    }
    if (lp->links.stqe_next == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
    }
  }
  if ((unsigned int )lp != (unsigned int )((void *)0)) {
    if (flags & 32U) {
      action = (enum __anonenum_action_70 )2;
    } else {
      if ((unsigned int )wwrite != (unsigned int )((void *)0)) {
        action = (enum __anonenum_action_70 )2;
      } else {
        if ((int )lock_mode == 7) {
          action = (enum __anonenum_action_70 )2;
        } else {
          action = (enum __anonenum_action_70 )4;
        }
      }
    }
  } else {
    if (flags & 16U) {
      action = (enum __anonenum_action_70 )4;
    } else {
      if (flags & 32U) {
        action = (enum __anonenum_action_70 )1;
      } else {
        if ((unsigned int )wwrite != (unsigned int )((void *)0)) {
          action = (enum __anonenum_action_70 )1;
        } else {
          if (ihold) {
            action = (enum __anonenum_action_70 )0;
          } else {
            if (sh_obj->waiters.stqh_first == -1) {
              lp = (struct __db_lock *)((void *)0);
            } else {
              lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
            }
            while ((unsigned int )lp != (unsigned int )((void *)0)) {
              if ((*(lt->conflicts + ((unsigned int )lp->mode * region->stat.st_nmodes +
                                      (unsigned int )lock_mode)))) {
                if (locker != lp->holder) {
                  break;
                }
              }
              if (lp->links.stqe_next == -1) {
                lp = (struct __db_lock *)((void *)0);
              } else {
                lp = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
              }
            }
            if ((unsigned int )lp == (unsigned int )((void *)0)) {
              action = (enum __anonenum_action_70 )0;
            } else {
              if ((int )lock_mode == 7) {
                if (grant_dirty) {
                  if (sh_obj->waiters.stqh_first == -1) {
                    lp = (struct __db_lock *)((void *)0);
                  } else {
                    lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
                  }
                  if ((int )lp->mode == 2) {
                    if (lp->holder == holder) {
                      action = (enum __anonenum_action_70 )3;
                    } else {
                      action = (enum __anonenum_action_70 )0;
                    }
                  } else {
                    action = (enum __anonenum_action_70 )0;
                  }
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: 
                if ((int )lock_mode == 7) {
                  action = (enum __anonenum_action_70 )3;
                } else {
                  action = (enum __anonenum_action_70 )4;
                }
              }
            }
          }
        }
      }
    }
  }
  switch ((int )action) {
  case 2: ;
  case 4: ;
  case 3: ;
  case 0: 
  region->stat.st_nlocks = region->stat.st_nlocks + 1U;
  if (region->stat.st_nlocks > region->stat.st_maxnlocks) {
    region->stat.st_maxnlocks = region->stat.st_nlocks;
  }
  if (region->free_locks.stqh_first == -1) {
    newl = (struct __db_lock *)((void *)0);
  } else {
    newl = (struct __db_lock *)((u_int8_t *)(& region->free_locks) + region->free_locks.stqh_first);
  }
  if ((unsigned int )newl != (unsigned int )((void *)0)) {
    while (1) {
      if (newl->links.stqe_next != -1) {
        ((struct __db_lock *)((u_int8_t *)newl + newl->links.stqe_next))->links.stqe_prev = newl->links.stqe_prev +
                                                                                            ((u_int8_t *)newl -
                                                                                             (u_int8_t *)((struct __db_lock *)((u_int8_t *)newl +
                                                                                                                               newl->links.stqe_next)));
        (*((ssize_t *)((u_int8_t *)newl + newl->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)newl +
                                                                                    newl->links.stqe_prev))) +
                                                                     newl->links.stqe_next;
      } else {
        region->free_locks.stqh_last = newl->links.stqe_prev + ((u_int8_t *)newl -
                                                                (u_int8_t *)(& region->free_locks));
        (*((ssize_t *)((u_int8_t *)newl + newl->links.stqe_prev))) = -1;
      }
      break;
    }
  }
  if ((unsigned int )newl == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, __db_lock_err, "locks");
    return (12);
  }
  newl->holder = locker;
  newl->refcount = 1U;
  newl->mode = lock_mode;
  newl->obj = (u_int8_t *)sh_obj - (u_int8_t *)newl;
  if (sh_locker->master_locker == 0U) {
    if (sh_locker->child_locker.slh_first == -1) {
      tmp___3 = (struct __db_locker *)((void *)0);
    } else {
      tmp___3 = (struct __db_locker *)((u_int8_t *)(& sh_locker->child_locker) + sh_locker->child_locker.slh_first);
    }
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
      if (sh_locker->heldby.slh_first == -1) {
        tmp___4 = (struct __db_lock *)((void *)0);
      } else {
        tmp___4 = (struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first);
      }
      if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  no_dd = tmp___5;
  while (1) {
    if (sh_locker->heldby.slh_first != -1) {
      newl->locker_links.sle_next = sh_locker->heldby.slh_first - ((u_int8_t *)newl -
                                                                   (u_int8_t *)(& sh_locker->heldby));
      if (newl->locker_links.sle_next == -1) {
        tmp___6 = 0;
      } else {
        tmp___6 = - newl->locker_links.sle_next;
      }
      ((struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first))->locker_links.sle_prev = tmp___6 +
                                                                                                                       ((u_int8_t *)(& newl->locker_links.sle_next) -
                                                                                                                        (u_int8_t *)newl);
    } else {
      newl->locker_links.sle_next = -1;
    }
    sh_locker->heldby.slh_first = (u_int8_t *)newl - (u_int8_t *)(& sh_locker->heldby);
    newl->locker_links.sle_prev = (u_int8_t *)(& sh_locker->heldby.slh_first) - (u_int8_t *)newl;
    break;
  }
  break;
  case 1: ;
  upgrade: 
  if ((unsigned int )wwrite != (unsigned int )((void *)0)) {
    lp = wwrite;
    lp->refcount ++;
    lock->off = (unsigned int )((u_int8_t *)lp - (u_int8_t *)lt->reginfo.addr);
    lock->gen = lp->gen;
    lock->mode = lock_mode;
  } else {
    lp = (struct __db_lock *)((void *)((u_int8_t *)lt->reginfo.addr + lock->off));
  }
  if ((int )lock_mode == 2) {
    goto _L___1;
  } else {
    if ((int )lock_mode == 8) {
      goto _L___1;
    } else {
      if ((int )lock_mode == 4) {
        goto _L___1;
      } else {
        if ((int )lock_mode == 6) {
          _L___1: 
          if (! ((int )lp->mode == 2)) {
            if (! ((int )lp->mode == 8)) {
              if (! ((int )lp->mode == 4)) {
                if (! ((int )lp->mode == 6)) {
                  sh_locker->nwrites ++;
                }
              }
            }
          }
        }
      }
    }
  }
  lp->mode = lock_mode;
  goto done;
  }
  switch ((int )action) {
  case 1: ;
  break;
  case 0: 
  newl->status = (enum __anonenum_db_status_t_29 )5;
  while (1) {
    newl->links.stqe_next = -1;
    newl->links.stqe_prev = - ((u_int8_t *)newl - (u_int8_t *)(& sh_obj->holders)) +
                            sh_obj->holders.stqh_last;
    if (sh_obj->holders.stqh_last == (u_int8_t *)(& sh_obj->holders.stqh_first) -
                                     (u_int8_t *)(& sh_obj->holders)) {
      sh_obj->holders.stqh_first = (u_int8_t *)newl - (u_int8_t *)(& sh_obj->holders);
    } else {
      (*((ssize_t *)((u_int8_t *)(& sh_obj->holders) + sh_obj->holders.stqh_last))) = (- sh_obj->holders.stqh_last +
                                                                                       ((u_int8_t *)(& newl->links.stqe_next) -
                                                                                        (u_int8_t *)newl)) +
                                                                                      ((u_int8_t *)newl -
                                                                                       (u_int8_t *)(& sh_obj->holders));
    }
    sh_obj->holders.stqh_last = (u_int8_t *)(& newl->links.stqe_next) - (u_int8_t *)(& sh_obj->holders);
    break;
  }
  break;
  case 2: ;
  case 4: ;
  case 3: ;
  if (flags & 1U) {
    ret = -30994;
    region->stat.st_nnowaits = region->stat.st_nnowaits + 1U;
    goto err;
  }
  if (sh_obj->waiters.stqh_first == -1) {
    lp = (struct __db_lock *)((void *)0);
  } else {
    lp = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
  }
  if ((unsigned int )lp == (unsigned int )((void *)0)) {
    while (1) {
      if (region->dd_objs.stqh_first != -1) {
        sh_obj->dd_links.stqe_next = region->dd_objs.stqh_first - ((u_int8_t *)sh_obj -
                                                                   (u_int8_t *)(& region->dd_objs));
        if (sh_obj->dd_links.stqe_next == -1) {
          ((struct __db_lockobj *)((u_int8_t *)(& region->dd_objs) + region->dd_objs.stqh_first))->dd_links.stqe_prev = 0;
        } else {
          ((struct __db_lockobj *)((u_int8_t *)(& region->dd_objs) + region->dd_objs.stqh_first))->dd_links.stqe_prev = - sh_obj->dd_links.stqe_next +
                                                                                                                        ((u_int8_t *)(& sh_obj->dd_links.stqe_next) -
                                                                                                                         (u_int8_t *)sh_obj);
        }
      } else {
        region->dd_objs.stqh_last = (u_int8_t *)(& sh_obj->dd_links.stqe_next) - (u_int8_t *)(& region->dd_objs);
        sh_obj->dd_links.stqe_next = -1;
      }
      region->dd_objs.stqh_first = (u_int8_t *)sh_obj - (u_int8_t *)(& region->dd_objs);
      sh_obj->dd_links.stqe_prev = (u_int8_t *)(& region->dd_objs.stqh_first) - (u_int8_t *)sh_obj;
      break;
    }
  }
  switch ((int )action) {
  case 2: ;
  while (1) {
    if (sh_obj->waiters.stqh_first != -1) {
      newl->links.stqe_next = sh_obj->waiters.stqh_first - ((u_int8_t *)newl - (u_int8_t *)(& sh_obj->waiters));
      if (newl->links.stqe_next == -1) {
        ((struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first))->links.stqe_prev = 0;
      } else {
        ((struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first))->links.stqe_prev = - newl->links.stqe_next +
                                                                                                                ((u_int8_t *)(& newl->links.stqe_next) -
                                                                                                                 (u_int8_t *)newl);
      }
    } else {
      sh_obj->waiters.stqh_last = (u_int8_t *)(& newl->links.stqe_next) - (u_int8_t *)(& sh_obj->waiters);
      newl->links.stqe_next = -1;
    }
    sh_obj->waiters.stqh_first = (u_int8_t *)newl - (u_int8_t *)(& sh_obj->waiters);
    newl->links.stqe_prev = (u_int8_t *)(& sh_obj->waiters.stqh_first) - (u_int8_t *)newl;
    break;
  }
  break;
  case 3: ;
  while (1) {
    if (lp->links.stqe_next != -1) {
      newl->links.stqe_next = lp->links.stqe_next - ((u_int8_t *)newl - (u_int8_t *)lp);
      if (newl->links.stqe_next == -1) {
        ((struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next))->links.stqe_prev = 0;
      } else {
        ((struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next))->links.stqe_prev = - newl->links.stqe_next +
                                                                                        ((u_int8_t *)(& newl->links.stqe_next) -
                                                                                         (u_int8_t *)newl);
      }
    } else {
      newl->links.stqe_next = -1;
      sh_obj->waiters.stqh_last = (u_int8_t *)(& newl->links.stqe_next) - (u_int8_t *)(& sh_obj->waiters);
    }
    lp->links.stqe_next = (u_int8_t *)newl - (u_int8_t *)lp;
    if (lp->links.stqe_next == -1) {
      newl->links.stqe_prev = 0;
    } else {
      newl->links.stqe_prev = - lp->links.stqe_next + ((u_int8_t *)(& lp->links.stqe_next) -
                                                       (u_int8_t *)lp);
    }
    break;
  }
  break;
  case 4: ;
  while (1) {
    newl->links.stqe_next = -1;
    newl->links.stqe_prev = - ((u_int8_t *)newl - (u_int8_t *)(& sh_obj->waiters)) +
                            sh_obj->waiters.stqh_last;
    if (sh_obj->waiters.stqh_last == (u_int8_t *)(& sh_obj->waiters.stqh_first) -
                                     (u_int8_t *)(& sh_obj->waiters)) {
      sh_obj->waiters.stqh_first = (u_int8_t *)newl - (u_int8_t *)(& sh_obj->waiters);
    } else {
      (*((ssize_t *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_last))) = (- sh_obj->waiters.stqh_last +
                                                                                       ((u_int8_t *)(& newl->links.stqe_next) -
                                                                                        (u_int8_t *)newl)) +
                                                                                      ((u_int8_t *)newl -
                                                                                       (u_int8_t *)(& sh_obj->waiters));
    }
    sh_obj->waiters.stqh_last = (u_int8_t *)(& newl->links.stqe_next) - (u_int8_t *)(& sh_obj->waiters);
    break;
  }
  break;
  default: ;
  }
  if (flags & 16U) {
    ret = __lock_put_nolock(dbenv___0, lock, & ihold, 1048576U);
    if (ret != 0) {
      __lock_remove_waiter(lt, sh_obj, newl, (enum __anonenum_db_status_t_29 )4);
      goto err;
    }
  }
  newl->status = (enum __anonenum_db_status_t_29 )8;
  region->stat.st_nconflicts = region->stat.st_nconflicts + 1U;
  region->need_dd = 1U;
  tmp___7 = __lock_expired(dbenv___0, & sh_locker->lk_expire, & sh_locker->tx_expire);
  if (tmp___7) {
    newl->status = (enum __anonenum_db_status_t_29 )3;
    sh_locker->lk_expire = sh_locker->tx_expire;
    goto expired;
  }
  if (! (flags & 8U)) {
    if (sh_locker->flags & 8U) {
      timeout = sh_locker->lk_timeout;
    } else {
      timeout = region->lk_timeout;
    }
  }
  if (timeout != 0U) {
    __lock_expires(dbenv___0, & sh_locker->lk_expire, timeout);
  } else {
    sh_locker->lk_expire.tv_sec = 0U;
  }
  if (sh_locker->tx_expire.tv_sec != 0U) {
    if (timeout == 0U) {
      sh_locker->lk_expire = sh_locker->tx_expire;
    } else {
      tmp___8 = __lock_expired(dbenv___0, & sh_locker->lk_expire, & sh_locker->tx_expire);
      if (tmp___8) {
        sh_locker->lk_expire = sh_locker->tx_expire;
      }
    }
  }
  if (sh_locker->lk_expire.tv_sec != 0U) {
    if (! (region->next_timeout.tv_sec != 0U)) {
      region->next_timeout = sh_locker->lk_expire;
    } else {
      if (region->next_timeout.tv_sec > sh_locker->lk_expire.tv_sec) {
        region->next_timeout = sh_locker->lk_expire;
      } else {
        if (region->next_timeout.tv_sec == sh_locker->lk_expire.tv_sec) {
          if (region->next_timeout.tv_usec > sh_locker->lk_expire.tv_usec) {
            region->next_timeout = sh_locker->lk_expire;
          }
        }
      }
    }
  }
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  if (region->detect != 0U) {
    if (! no_dd) {
      __lock_detect(dbenv___0, region->detect, & did_abort);
    }
  }
  if (! (newl->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & newl->mutex);
  }
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  if ((int )newl->status != 3) {
    sh_locker->lk_expire.tv_sec = 0U;
  }
  if ((int )newl->status != 7) {
    switch ((int )newl->status) {
    case 1: 
    ret = -30995;
    break;
    case 6: 
    ret = -30897;
    break;
    case 3: ;
    expired: 
    tmp___9 = __lock_lhash(sh_obj);
    obj_ndx = tmp___9 % region->object_t_size;
    tmp___10 = __lock_put_internal(lt, newl, obj_ndx, 655360U);
    ret = tmp___10 != 0;
    if (ret) {
      goto err;
    }
    if (sh_locker->lk_expire.tv_sec == sh_locker->tx_expire.tv_sec) {
      if (sh_locker->lk_expire.tv_usec == sh_locker->tx_expire.tv_usec) {
        region->stat.st_ntxntimeouts = region->stat.st_ntxntimeouts + 1U;
        return (-30994);
      } else {
        region->stat.st_nlocktimeouts = region->stat.st_nlocktimeouts + 1U;
        return (-30994);
      }
    } else {
      region->stat.st_nlocktimeouts = region->stat.st_nlocktimeouts + 1U;
      return (-30994);
    }
    default: 
    ret = 22;
    break;
    }
    goto err;
  } else {
    if (flags & 32U) {
      while (1) {
        if (newl->links.stqe_next != -1) {
          ((struct __db_lock *)((u_int8_t *)newl + newl->links.stqe_next))->links.stqe_prev = newl->links.stqe_prev +
                                                                                              ((u_int8_t *)newl -
                                                                                               (u_int8_t *)((struct __db_lock *)((u_int8_t *)newl +
                                                                                                                                 newl->links.stqe_next)));
          (*((ssize_t *)((u_int8_t *)newl + newl->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)newl +
                                                                                      newl->links.stqe_prev))) +
                                                                       newl->links.stqe_next;
        } else {
          sh_obj->holders.stqh_last = newl->links.stqe_prev + ((u_int8_t *)newl -
                                                               (u_int8_t *)(& sh_obj->holders));
          (*((ssize_t *)((u_int8_t *)newl + newl->links.stqe_prev))) = -1;
        }
        break;
      }
      newl->links.stqe_prev = -1;
      goto upgrade;
    } else {
      newl->status = (enum __anonenum_db_status_t_29 )5;
    }
  }
  }
  lock->off = (unsigned int )((u_int8_t *)newl - (u_int8_t *)lt->reginfo.addr);
  lock->gen = newl->gen;
  lock->mode = newl->mode;
  sh_locker->nlocks ++;
  if ((int )newl->mode == 2) {
    sh_locker->nwrites ++;
  } else {
    if ((int )newl->mode == 8) {
      sh_locker->nwrites ++;
    } else {
      if ((int )newl->mode == 4) {
        sh_locker->nwrites ++;
      } else {
        if ((int )newl->mode == 6) {
          sh_locker->nwrites ++;
        }
      }
    }
  }
  return (0);
  done: 
  ret = 0;
  err: 
  if ((unsigned int )newl != (unsigned int )((void *)0)) {
    t_ret = __lock_freelock(lt, newl, locker, 655360U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __lock_put_pp(DB_ENV *dbenv___0 , DB_LOCK *lock ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_LOCK->lock_put", 8192U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_put(dbenv___0, lock);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __lock_put(DB_ENV *dbenv___0 , DB_LOCK *lock ) 
{ DB_LOCKTAB *lt ;
  int ret ;
  int run_dd ;

  {
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      return (0);
    }
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  ret = __lock_put_nolock(dbenv___0, lock, & run_dd, 0U);
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  if (ret == 0) {
    if (run_dd) {
      __lock_detect(dbenv___0, ((DB_LOCKREGION *)lt->reginfo.primary)->detect, (int *)((void *)0));
    }
  }
  return (ret);
}
}
static int __lock_put_nolock(DB_ENV *dbenv___0 , DB_LOCK *lock , int *runp , u_int32_t flags ) 
{ struct __db_lock *lockp ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  int ret ;

  {
  if (dbenv___0->flags & 1024U) {
    return (0);
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  lockp = (struct __db_lock *)((void *)((u_int8_t *)lt->reginfo.addr + lock->off));
  lock->off = 0U;
  if (lock->gen != lockp->gen) {
    __db_err((DB_ENV const   *)dbenv___0, __db_lock_invalid, "DB_LOCK->lock_put");
    return (22);
  }
  ret = __lock_put_internal(lt, lockp, lock->ndx, (flags | 524288U) | 131072U);
  (*runp) = 0;
  if (ret == 0) {
    if (region->detect != 0U) {
      if (region->need_dd) {
        (*runp) = 1;
      } else {
        if (region->next_timeout.tv_sec != 0U) {
          (*runp) = 1;
        }
      }
    }
  }
  return (ret);
}
}
int __lock_downgrade(DB_ENV *dbenv___0 , DB_LOCK *lock , db_lockmode_t new_mode ,
                     u_int32_t flags ) 
{ struct __db_lock *lockp ;
  DB_LOCKER *sh_locker ;
  DB_LOCKOBJ *obj ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  u_int32_t indx ;
  int ret ;
  int tmp ;
  u_int32_t tmp___0 ;

  {
  flags = 0U;
  flags = flags;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = 0;
  if (dbenv___0->flags & 1024U) {
    return (0);
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  lockp = (struct __db_lock *)((void *)((u_int8_t *)lt->reginfo.addr + lock->off));
  if (lock->gen != lockp->gen) {
    __db_err((DB_ENV const   *)dbenv___0, __db_lock_invalid, "lock_downgrade");
    ret = 22;
    goto out;
  }
  tmp___0 = __lock_locker_hash(lockp->holder);
  indx = tmp___0 % region->locker_t_size;
  ret = __lock_getlocker(lt, lockp->holder, indx, 0, & sh_locker);
  if (ret != 0) {
    goto _L;
  } else {
    if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
      _L: 
      if (ret == 0) {
        ret = 22;
      }
      __db_err((DB_ENV const   *)dbenv___0, __db_locker_invalid);
      goto out;
    }
  }
  if ((int )lockp->mode == 2) {
    goto _L___0;
  } else {
    if ((int )lockp->mode == 8) {
      goto _L___0;
    } else {
      if ((int )lockp->mode == 4) {
        goto _L___0;
      } else {
        if ((int )lockp->mode == 6) {
          _L___0: 
          if (! ((int )new_mode == 2)) {
            if (! ((int )new_mode == 8)) {
              if (! ((int )new_mode == 4)) {
                if (! ((int )new_mode == 6)) {
                  sh_locker->nwrites --;
                }
              }
            }
          }
        }
      }
    }
  }
  if ((int )new_mode == 8) {
    sh_locker->flags |= 2U;
  }
  lockp->mode = new_mode;
  obj = (DB_LOCKOBJ *)((u_int8_t *)lockp + lockp->obj);
  __lock_promote(lt, obj, flags & 1048576U);
  out: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static int __lock_put_internal(DB_LOCKTAB *lt , struct __db_lock *lockp , u_int32_t obj_ndx ,
                               u_int32_t flags ) 
{ DB_LOCKOBJ *sh_obj ;
  DB_LOCKREGION *region ;
  int ret ;
  int state_changed ;
  DB_HASHTAB *__bucket ;
  struct __db_lock *tmp ;
  struct __db_lock *tmp___0 ;

  {
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  state_changed = 0;
  ret = state_changed;
  if (! (lockp->links.stqe_prev != -1)) {
    __lock_freelock(lt, lockp, 0U, 131072U);
    return (0);
  }
  if (flags & 65536U) {
    region->stat.st_nreleases = region->stat.st_nreleases + lockp->refcount;
  } else {
    region->stat.st_nreleases = region->stat.st_nreleases + 1U;
  }
  if (! (flags & 65536U)) {
    if (lockp->refcount > 1U) {
      lockp->refcount --;
      return (0);
    }
  }
  lockp->gen ++;
  sh_obj = (DB_LOCKOBJ *)((u_int8_t *)lockp + lockp->obj);
  if ((int )lockp->status != 5) {
    if ((int )lockp->status != 7) {
      __lock_remove_waiter(lt, sh_obj, lockp, (enum __anonenum_db_status_t_29 )4);
    } else {
      goto _L;
    }
  } else {
    _L: 
    while (1) {
      if (lockp->links.stqe_next != -1) {
        ((struct __db_lock *)((u_int8_t *)lockp + lockp->links.stqe_next))->links.stqe_prev = lockp->links.stqe_prev +
                                                                                              ((u_int8_t *)lockp -
                                                                                               (u_int8_t *)((struct __db_lock *)((u_int8_t *)lockp +
                                                                                                                                 lockp->links.stqe_next)));
        (*((ssize_t *)((u_int8_t *)lockp + lockp->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)lockp +
                                                                                      lockp->links.stqe_prev))) +
                                                                       lockp->links.stqe_next;
      } else {
        sh_obj->holders.stqh_last = lockp->links.stqe_prev + ((u_int8_t *)lockp -
                                                              (u_int8_t *)(& sh_obj->holders));
        (*((ssize_t *)((u_int8_t *)lockp + lockp->links.stqe_prev))) = -1;
      }
      break;
    }
    lockp->links.stqe_prev = -1;
  }
  if (flags & 262144U) {
    state_changed = 0;
  } else {
    state_changed = __lock_promote(lt, sh_obj, flags & 1048580U);
  }
  if (sh_obj->holders.stqh_first == -1) {
    tmp = (struct __db_lock *)((void *)0);
  } else {
    tmp = (struct __db_lock *)((u_int8_t *)(& sh_obj->holders) + sh_obj->holders.stqh_first);
  }
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    if (sh_obj->waiters.stqh_first == -1) {
      tmp___0 = (struct __db_lock *)((void *)0);
    } else {
      tmp___0 = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
    }
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
      __bucket = lt->obj_tab + obj_ndx;
      while (1) {
        if (sh_obj->links.stqe_next != -1) {
          ((struct __db_lockobj *)((u_int8_t *)sh_obj + sh_obj->links.stqe_next))->links.stqe_prev = sh_obj->links.stqe_prev +
                                                                                                     ((u_int8_t *)sh_obj -
                                                                                                      (u_int8_t *)((struct __db_lockobj *)((u_int8_t *)sh_obj +
                                                                                                                                           sh_obj->links.stqe_next)));
          (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_obj +
                                                                                          sh_obj->links.stqe_prev))) +
                                                                           sh_obj->links.stqe_next;
        } else {
          __bucket->stqh_last = sh_obj->links.stqe_prev + ((u_int8_t *)sh_obj - (u_int8_t *)__bucket);
          (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->links.stqe_prev))) = -1;
        }
        break;
      }
      if (sh_obj->lockobj.size > sizeof(sh_obj->objdata)) {
        __db_shalloc_free(lt->reginfo.addr, (void *)((u_int8_t *)(& sh_obj->lockobj) +
                                                     sh_obj->lockobj.off));
      }
      while (1) {
        if (region->free_objs.stqh_first != -1) {
          sh_obj->links.stqe_next = region->free_objs.stqh_first - ((u_int8_t *)sh_obj -
                                                                    (u_int8_t *)(& region->free_objs));
          if (sh_obj->links.stqe_next == -1) {
            ((struct __db_lockobj *)((u_int8_t *)(& region->free_objs) + region->free_objs.stqh_first))->links.stqe_prev = 0;
          } else {
            ((struct __db_lockobj *)((u_int8_t *)(& region->free_objs) + region->free_objs.stqh_first))->links.stqe_prev = - sh_obj->links.stqe_next +
                                                                                                                           ((u_int8_t *)(& sh_obj->links.stqe_next) -
                                                                                                                            (u_int8_t *)sh_obj);
          }
        } else {
          region->free_objs.stqh_last = (u_int8_t *)(& sh_obj->links.stqe_next) -
                                        (u_int8_t *)(& region->free_objs);
          sh_obj->links.stqe_next = -1;
        }
        region->free_objs.stqh_first = (u_int8_t *)sh_obj - (u_int8_t *)(& region->free_objs);
        sh_obj->links.stqe_prev = (u_int8_t *)(& region->free_objs.stqh_first) - (u_int8_t *)sh_obj;
        break;
      }
      region->stat.st_nobjects = region->stat.st_nobjects - 1U;
      state_changed = 1;
    }
  }
  if (flags & 655360U) {
    ret = __lock_freelock(lt, lockp, lockp->holder, flags);
  }
  if (state_changed == 0) {
    region->need_dd = 1U;
  }
  return (ret);
}
}
static int __lock_freelock(DB_LOCKTAB *lt , struct __db_lock *lockp , u_int32_t locker ,
                           u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKER *sh_locker ;
  DB_LOCKREGION *region ;
  u_int32_t indx ;
  int ret ;
  u_int32_t tmp ;

  {
  dbenv___0 = lt->dbenv;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  ret = 0;
  if (flags & 524288U) {
    tmp = __lock_locker_hash(locker);
    indx = tmp % region->locker_t_size;
    ret = __lock_getlocker(lt, locker, indx, 0, & sh_locker);
    if (ret != 0) {
      goto _L;
    } else {
      if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
        _L: 
        if (ret == 0) {
          ret = 22;
        }
        __db_err((DB_ENV const   *)dbenv___0, __db_locker_invalid);
        return (ret);
      }
    }
    while (1) {
      if (lockp->locker_links.sle_next != -1) {
        ((struct __db_lock *)((u_int8_t *)lockp + lockp->locker_links.sle_next))->locker_links.sle_prev = lockp->locker_links.sle_prev -
                                                                                                          lockp->locker_links.sle_next;
        (*((ssize_t *)((u_int8_t *)lockp + lockp->locker_links.sle_prev))) = (*((ssize_t *)((u_int8_t *)lockp +
                                                                                            lockp->locker_links.sle_prev))) +
                                                                             lockp->locker_links.sle_next;
      } else {
        (*((ssize_t *)((u_int8_t *)lockp + lockp->locker_links.sle_prev))) = -1;
      }
      break;
    }
    if ((int )lockp->status == 5) {
      sh_locker->nlocks --;
      if ((int )lockp->mode == 2) {
        sh_locker->nwrites --;
      } else {
        if ((int )lockp->mode == 8) {
          sh_locker->nwrites --;
        } else {
          if ((int )lockp->mode == 4) {
            sh_locker->nwrites --;
          } else {
            if ((int )lockp->mode == 6) {
              sh_locker->nwrites --;
            }
          }
        }
      }
    }
  }
  if (flags & 131072U) {
    lockp->status = (enum __anonenum_db_status_t_29 )4;
    while (1) {
      if (region->free_locks.stqh_first != -1) {
        lockp->links.stqe_next = region->free_locks.stqh_first - ((u_int8_t *)lockp -
                                                                  (u_int8_t *)(& region->free_locks));
        if (lockp->links.stqe_next == -1) {
          ((struct __db_lock *)((u_int8_t *)(& region->free_locks) + region->free_locks.stqh_first))->links.stqe_prev = 0;
        } else {
          ((struct __db_lock *)((u_int8_t *)(& region->free_locks) + region->free_locks.stqh_first))->links.stqe_prev = - lockp->links.stqe_next +
                                                                                                                        ((u_int8_t *)(& lockp->links.stqe_next) -
                                                                                                                         (u_int8_t *)lockp);
        }
      } else {
        region->free_locks.stqh_last = (u_int8_t *)(& lockp->links.stqe_next) - (u_int8_t *)(& region->free_locks);
        lockp->links.stqe_next = -1;
      }
      region->free_locks.stqh_first = (u_int8_t *)lockp - (u_int8_t *)(& region->free_locks);
      lockp->links.stqe_prev = (u_int8_t *)(& region->free_locks.stqh_first) - (u_int8_t *)lockp;
      break;
    }
    region->stat.st_nlocks = region->stat.st_nlocks - 1U;
  }
  return (ret);
}
}
int __lock_addfamilylocker(DB_ENV *dbenv___0 , u_int32_t pid , u_int32_t id ) 
{ DB_LOCKER *lockerp ;
  DB_LOCKER *mlockerp ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  u_int32_t ndx ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  int tmp___1 ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  tmp = __lock_locker_hash(pid);
  ndx = tmp % region->locker_t_size;
  ret = __lock_getlocker((DB_LOCKTAB *)dbenv___0->lk_handle, pid, ndx, 1, & mlockerp);
  if (ret != 0) {
    goto err;
  }
  tmp___0 = __lock_locker_hash(id);
  ndx = tmp___0 % region->locker_t_size;
  ret = __lock_getlocker((DB_LOCKTAB *)dbenv___0->lk_handle, id, ndx, 1, & lockerp);
  if (ret != 0) {
    goto err;
  }
  lockerp->parent_locker = (unsigned int )((u_int8_t *)mlockerp - (u_int8_t *)lt->reginfo.addr);
  if (mlockerp->master_locker == 0U) {
    lockerp->master_locker = (unsigned int )((u_int8_t *)mlockerp - (u_int8_t *)lt->reginfo.addr);
  } else {
    lockerp->master_locker = mlockerp->master_locker;
    mlockerp = (DB_LOCKER *)((void *)((u_int8_t *)lt->reginfo.addr + mlockerp->master_locker));
  }
  while (1) {
    if (mlockerp->child_locker.slh_first != -1) {
      lockerp->child_link.sle_next = mlockerp->child_locker.slh_first - ((u_int8_t *)lockerp -
                                                                         (u_int8_t *)(& mlockerp->child_locker));
      if (lockerp->child_link.sle_next == -1) {
        tmp___1 = 0;
      } else {
        tmp___1 = - lockerp->child_link.sle_next;
      }
      ((struct __db_locker *)((u_int8_t *)(& mlockerp->child_locker) + mlockerp->child_locker.slh_first))->child_link.sle_prev = tmp___1 +
                                                                                                                                 ((u_int8_t *)(& lockerp->child_link.sle_next) -
                                                                                                                                  (u_int8_t *)lockerp);
    } else {
      lockerp->child_link.sle_next = -1;
    }
    mlockerp->child_locker.slh_first = (u_int8_t *)lockerp - (u_int8_t *)(& mlockerp->child_locker);
    lockerp->child_link.sle_prev = (u_int8_t *)(& mlockerp->child_locker.slh_first) -
                                   (u_int8_t *)lockerp;
    break;
  }
  err: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __lock_freefamilylocker(DB_LOCKTAB *lt , u_int32_t locker ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKER *sh_locker ;
  DB_LOCKREGION *region ;
  u_int32_t indx ;
  int ret ;
  u_int32_t tmp ;
  struct __db_lock *tmp___0 ;

  {
  dbenv___0 = lt->dbenv;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  tmp = __lock_locker_hash(locker);
  indx = tmp % region->locker_t_size;
  ret = __lock_getlocker(lt, locker, indx, 0, & sh_locker);
  if (ret != 0) {
    goto err;
  } else {
    if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
      goto err;
    }
  }
  if (sh_locker->heldby.slh_first == -1) {
    tmp___0 = (struct __db_lock *)((void *)0);
  } else {
    tmp___0 = (struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first);
  }
  if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
    ret = 22;
    __db_err((DB_ENV const   *)dbenv___0, "Freeing locker with locks");
    goto err;
  }
  if (sh_locker->master_locker != 0U) {
    while (1) {
      if (sh_locker->child_link.sle_next != -1) {
        ((struct __db_locker *)((u_int8_t *)sh_locker + sh_locker->child_link.sle_next))->child_link.sle_prev = sh_locker->child_link.sle_prev -
                                                                                                                sh_locker->child_link.sle_next;
        (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->child_link.sle_prev))) = (*((ssize_t *)((u_int8_t *)sh_locker +
                                                                                                  sh_locker->child_link.sle_prev))) +
                                                                                   sh_locker->child_link.sle_next;
      } else {
        (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->child_link.sle_prev))) = -1;
      }
      break;
    }
  }
  __lock_freelocker(lt, region, sh_locker, indx);
  err: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static void __lock_freelocker(DB_LOCKTAB *lt , DB_LOCKREGION *region , DB_LOCKER *sh_locker ,
                              u_int32_t indx ) 
{ DB_HASHTAB *__bucket ;

  {
  __bucket = lt->locker_tab + indx;
  while (1) {
    if (sh_locker->links.stqe_next != -1) {
      ((struct __db_locker *)((u_int8_t *)sh_locker + sh_locker->links.stqe_next))->links.stqe_prev = sh_locker->links.stqe_prev +
                                                                                                      ((u_int8_t *)sh_locker -
                                                                                                       (u_int8_t *)((struct __db_locker *)((u_int8_t *)sh_locker +
                                                                                                                                           sh_locker->links.stqe_next)));
      (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_locker +
                                                                                            sh_locker->links.stqe_prev))) +
                                                                             sh_locker->links.stqe_next;
    } else {
      __bucket->stqh_last = sh_locker->links.stqe_prev + ((u_int8_t *)sh_locker -
                                                          (u_int8_t *)__bucket);
      (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->links.stqe_prev))) = -1;
    }
    break;
  }
  while (1) {
    if (region->free_lockers.stqh_first != -1) {
      sh_locker->links.stqe_next = region->free_lockers.stqh_first - ((u_int8_t *)sh_locker -
                                                                      (u_int8_t *)(& region->free_lockers));
      if (sh_locker->links.stqe_next == -1) {
        ((struct __db_locker *)((u_int8_t *)(& region->free_lockers) + region->free_lockers.stqh_first))->links.stqe_prev = 0;
      } else {
        ((struct __db_locker *)((u_int8_t *)(& region->free_lockers) + region->free_lockers.stqh_first))->links.stqe_prev = - sh_locker->links.stqe_next +
                                                                                                                            ((u_int8_t *)(& sh_locker->links.stqe_next) -
                                                                                                                             (u_int8_t *)sh_locker);
      }
    } else {
      region->free_lockers.stqh_last = (u_int8_t *)(& sh_locker->links.stqe_next) -
                                       (u_int8_t *)(& region->free_lockers);
      sh_locker->links.stqe_next = -1;
    }
    region->free_lockers.stqh_first = (u_int8_t *)sh_locker - (u_int8_t *)(& region->free_lockers);
    sh_locker->links.stqe_prev = (u_int8_t *)(& region->free_lockers.stqh_first) -
                                 (u_int8_t *)sh_locker;
    break;
  }
  while (1) {
    if (sh_locker->ulinks.stqe_next != -1) {
      ((struct __db_locker *)((u_int8_t *)sh_locker + sh_locker->ulinks.stqe_next))->ulinks.stqe_prev = sh_locker->ulinks.stqe_prev +
                                                                                                        ((u_int8_t *)sh_locker -
                                                                                                         (u_int8_t *)((struct __db_locker *)((u_int8_t *)sh_locker +
                                                                                                                                             sh_locker->ulinks.stqe_next)));
      (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->ulinks.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_locker +
                                                                                             sh_locker->ulinks.stqe_prev))) +
                                                                              sh_locker->ulinks.stqe_next;
    } else {
      region->lockers.stqh_last = sh_locker->ulinks.stqe_prev + ((u_int8_t *)sh_locker -
                                                                 (u_int8_t *)(& region->lockers));
      (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->ulinks.stqe_prev))) = -1;
    }
    break;
  }
  region->stat.st_nlockers = region->stat.st_nlockers - 1U;
  return;
}
}
int __lock_set_timeout(DB_ENV *dbenv___0 , u_int32_t locker , db_timeout_t timeout ,
                       u_int32_t op ) 
{ DB_LOCKTAB *lt ;
  int ret ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  ret = __lock_set_timeout_internal(dbenv___0, locker, timeout, op);
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static int __lock_set_timeout_internal(DB_ENV *dbenv___0 , u_int32_t locker , db_timeout_t timeout ,
                                       u_int32_t op ) 
{ DB_LOCKER *sh_locker ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  u_int32_t locker_ndx ;
  int ret ;
  u_int32_t tmp ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  tmp = __lock_locker_hash(locker);
  locker_ndx = tmp % region->locker_t_size;
  ret = __lock_getlocker(lt, locker, locker_ndx, 1, & sh_locker);
  if (ret != 0) {
    return (ret);
  }
  if (op == 33U) {
    if (timeout == 0U) {
      sh_locker->tx_expire.tv_sec = 0U;
    } else {
      __lock_expires(dbenv___0, & sh_locker->tx_expire, timeout);
    }
  } else {
    if (op == 29U) {
      sh_locker->lk_timeout = timeout;
      sh_locker->flags |= 8U;
    } else {
      if (op == 32U) {
        sh_locker->tx_expire.tv_sec = 0U;
        __lock_expires(dbenv___0, & sh_locker->tx_expire, 0U);
        sh_locker->lk_expire = sh_locker->tx_expire;
        if (! (region->next_timeout.tv_sec != 0U)) {
          region->next_timeout = sh_locker->lk_expire;
        } else {
          if (region->next_timeout.tv_sec > sh_locker->lk_expire.tv_sec) {
            region->next_timeout = sh_locker->lk_expire;
          } else {
            if (region->next_timeout.tv_sec == sh_locker->lk_expire.tv_sec) {
              if (region->next_timeout.tv_usec > sh_locker->lk_expire.tv_usec) {
                region->next_timeout = sh_locker->lk_expire;
              }
            }
          }
        }
      } else {
        return (22);
      }
    }
  }
  return (0);
}
}
int __lock_inherit_timeout(DB_ENV *dbenv___0 , u_int32_t parent , u_int32_t locker ) 
{ DB_LOCKER *parent_locker ;
  DB_LOCKER *sh_locker ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  u_int32_t locker_ndx ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  ret = 0;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  tmp = __lock_locker_hash(parent);
  locker_ndx = tmp % region->locker_t_size;
  ret = __lock_getlocker(lt, parent, locker_ndx, 0, & parent_locker);
  if (ret != 0) {
    goto done;
  }
  if ((unsigned int )parent_locker == (unsigned int )((void *)0)) {
    ret = 22;
    goto done;
  } else {
    if (parent_locker->tx_expire.tv_sec != 0U) {
      if (! (parent_locker->flags & 8U)) {
        ret = 22;
        goto done;
      }
    }
  }
  tmp___0 = __lock_locker_hash(locker);
  locker_ndx = tmp___0 % region->locker_t_size;
  ret = __lock_getlocker(lt, locker, locker_ndx, 1, & sh_locker);
  if (ret != 0) {
    goto done;
  }
  sh_locker->tx_expire = parent_locker->tx_expire;
  if (parent_locker->flags & 8U) {
    sh_locker->lk_timeout = parent_locker->lk_timeout;
    sh_locker->flags |= 8U;
    if (! (parent_locker->tx_expire.tv_sec != 0U)) {
      ret = 22;
    }
  }
  done: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __lock_getlocker(DB_LOCKTAB *lt , u_int32_t locker , u_int32_t indx , int create ,
                     DB_LOCKER **retp ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKER *sh_locker ;
  DB_LOCKREGION *region ;
  DB_HASHTAB *__bucket ;
  int tmp ;
  DB_HASHTAB *__bucket___0 ;

  {
  dbenv___0 = lt->dbenv;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  while (1) {
    __bucket = lt->locker_tab + indx;
    if (__bucket->stqh_first == -1) {
      sh_locker = (DB_LOCKER *)((void *)0);
    } else {
      sh_locker = (struct __db_locker *)((u_int8_t *)__bucket + __bucket->stqh_first);
    }
    while ((unsigned int )sh_locker != (unsigned int )((void *)0)) {
      tmp = __lock_locker_cmp(locker, sh_locker);
      if (tmp) {
        break;
      }
      if (sh_locker->links.stqe_next == -1) {
        sh_locker = (DB_LOCKER *)((void *)0);
      } else {
        sh_locker = (struct __db_locker *)((u_int8_t *)sh_locker + sh_locker->links.stqe_next);
      }
    }
    break;
  }
  if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
    if (create) {
      if (region->free_lockers.stqh_first == -1) {
        sh_locker = (DB_LOCKER *)((void *)0);
      } else {
        sh_locker = (struct __db_locker *)((u_int8_t *)(& region->free_lockers) +
                                           region->free_lockers.stqh_first);
      }
      if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
        __db_err((DB_ENV const   *)dbenv___0, __db_lock_err, "locker entries");
        return (12);
      }
      while (1) {
        if (sh_locker->links.stqe_next != -1) {
          ((struct __db_locker *)((u_int8_t *)sh_locker + sh_locker->links.stqe_next))->links.stqe_prev = sh_locker->links.stqe_prev +
                                                                                                          ((u_int8_t *)sh_locker -
                                                                                                           (u_int8_t *)((struct __db_locker *)((u_int8_t *)sh_locker +
                                                                                                                                               sh_locker->links.stqe_next)));
          (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_locker +
                                                                                                sh_locker->links.stqe_prev))) +
                                                                                 sh_locker->links.stqe_next;
        } else {
          region->free_lockers.stqh_last = sh_locker->links.stqe_prev + ((u_int8_t *)sh_locker -
                                                                         (u_int8_t *)(& region->free_lockers));
          (*((ssize_t *)((u_int8_t *)sh_locker + sh_locker->links.stqe_prev))) = -1;
        }
        break;
      }
      region->stat.st_nlockers = region->stat.st_nlockers + 1U;
      if (region->stat.st_nlockers > region->stat.st_maxnlockers) {
        region->stat.st_maxnlockers = region->stat.st_nlockers;
      }
      sh_locker->id = locker;
      sh_locker->dd_id = 0U;
      sh_locker->master_locker = 0U;
      sh_locker->parent_locker = 0U;
      sh_locker->child_locker.slh_first = -1;
      sh_locker->flags = 0U;
      sh_locker->heldby.slh_first = -1;
      sh_locker->nlocks = 0U;
      sh_locker->nwrites = 0U;
      sh_locker->lk_timeout = 0U;
      sh_locker->tx_expire.tv_sec = 0U;
      sh_locker->lk_expire.tv_sec = 0U;
      while (1) {
        __bucket___0 = lt->locker_tab + indx;
        while (1) {
          if (__bucket___0->stqh_first != -1) {
            sh_locker->links.stqe_next = __bucket___0->stqh_first - ((u_int8_t *)sh_locker -
                                                                     (u_int8_t *)__bucket___0);
            if (sh_locker->links.stqe_next == -1) {
              ((struct __db_locker *)((u_int8_t *)__bucket___0 + __bucket___0->stqh_first))->links.stqe_prev = 0;
            } else {
              ((struct __db_locker *)((u_int8_t *)__bucket___0 + __bucket___0->stqh_first))->links.stqe_prev = - sh_locker->links.stqe_next +
                                                                                                               ((u_int8_t *)(& sh_locker->links.stqe_next) -
                                                                                                                (u_int8_t *)sh_locker);
            }
          } else {
            __bucket___0->stqh_last = (u_int8_t *)(& sh_locker->links.stqe_next) -
                                      (u_int8_t *)__bucket___0;
            sh_locker->links.stqe_next = -1;
          }
          __bucket___0->stqh_first = (u_int8_t *)sh_locker - (u_int8_t *)__bucket___0;
          sh_locker->links.stqe_prev = (u_int8_t *)(& __bucket___0->stqh_first) -
                                       (u_int8_t *)sh_locker;
          break;
        }
        break;
      }
      while (1) {
        if (region->lockers.stqh_first != -1) {
          sh_locker->ulinks.stqe_next = region->lockers.stqh_first - ((u_int8_t *)sh_locker -
                                                                      (u_int8_t *)(& region->lockers));
          if (sh_locker->ulinks.stqe_next == -1) {
            ((struct __db_locker *)((u_int8_t *)(& region->lockers) + region->lockers.stqh_first))->ulinks.stqe_prev = 0;
          } else {
            ((struct __db_locker *)((u_int8_t *)(& region->lockers) + region->lockers.stqh_first))->ulinks.stqe_prev = - sh_locker->ulinks.stqe_next +
                                                                                                                       ((u_int8_t *)(& sh_locker->ulinks.stqe_next) -
                                                                                                                        (u_int8_t *)sh_locker);
          }
        } else {
          region->lockers.stqh_last = (u_int8_t *)(& sh_locker->ulinks.stqe_next) -
                                      (u_int8_t *)(& region->lockers);
          sh_locker->ulinks.stqe_next = -1;
        }
        region->lockers.stqh_first = (u_int8_t *)sh_locker - (u_int8_t *)(& region->lockers);
        sh_locker->ulinks.stqe_prev = (u_int8_t *)(& region->lockers.stqh_first) -
                                      (u_int8_t *)sh_locker;
        break;
      }
    }
  }
  (*retp) = sh_locker;
  return (0);
}
}
static int __lock_getobj(DB_LOCKTAB *lt , DBT const   *obj , u_int32_t ndx , int create ,
                         DB_LOCKOBJ **retp ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKOBJ *sh_obj ;
  DB_LOCKREGION *region ;
  int ret ;
  void *p ;
  DB_HASHTAB *__bucket ;
  int tmp ;
  DB_HASHTAB *__bucket___0 ;

  {
  dbenv___0 = lt->dbenv;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  while (1) {
    __bucket = lt->obj_tab + ndx;
    if (__bucket->stqh_first == -1) {
      sh_obj = (DB_LOCKOBJ *)((void *)0);
    } else {
      sh_obj = (struct __db_lockobj *)((u_int8_t *)__bucket + __bucket->stqh_first);
    }
    while ((unsigned int )sh_obj != (unsigned int )((void *)0)) {
      tmp = __lock_cmp(obj, sh_obj);
      if (tmp) {
        break;
      }
      if (sh_obj->links.stqe_next == -1) {
        sh_obj = (DB_LOCKOBJ *)((void *)0);
      } else {
        sh_obj = (struct __db_lockobj *)((u_int8_t *)sh_obj + sh_obj->links.stqe_next);
      }
    }
    break;
  }
  if ((unsigned int )sh_obj == (unsigned int )((void *)0)) {
    if (create) {
      if (region->free_objs.stqh_first == -1) {
        sh_obj = (DB_LOCKOBJ *)((void *)0);
      } else {
        sh_obj = (struct __db_lockobj *)((u_int8_t *)(& region->free_objs) + region->free_objs.stqh_first);
      }
      if ((unsigned int )sh_obj == (unsigned int )((void *)0)) {
        __db_err((DB_ENV const   *)lt->dbenv, __db_lock_err, "object entries");
        ret = 12;
        goto err;
      }
      if (obj->size <= sizeof(sh_obj->objdata)) {
        p = (void *)(sh_obj->objdata);
      } else {
        ret = __db_shalloc(lt->reginfo.addr, obj->size, 0U, (void *)(& p));
        if (ret != 0) {
          __db_err((DB_ENV const   *)dbenv___0, "No space for lock object storage");
          goto err;
        }
      }
      memcpy((void * __restrict  )p, (void const   * __restrict  )obj->data, obj->size);
      while (1) {
        if (sh_obj->links.stqe_next != -1) {
          ((struct __db_lockobj *)((u_int8_t *)sh_obj + sh_obj->links.stqe_next))->links.stqe_prev = sh_obj->links.stqe_prev +
                                                                                                     ((u_int8_t *)sh_obj -
                                                                                                      (u_int8_t *)((struct __db_lockobj *)((u_int8_t *)sh_obj +
                                                                                                                                           sh_obj->links.stqe_next)));
          (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_obj +
                                                                                          sh_obj->links.stqe_prev))) +
                                                                           sh_obj->links.stqe_next;
        } else {
          region->free_objs.stqh_last = sh_obj->links.stqe_prev + ((u_int8_t *)sh_obj -
                                                                   (u_int8_t *)(& region->free_objs));
          (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->links.stqe_prev))) = -1;
        }
        break;
      }
      region->stat.st_nobjects = region->stat.st_nobjects + 1U;
      if (region->stat.st_nobjects > region->stat.st_maxnobjects) {
        region->stat.st_maxnobjects = region->stat.st_nobjects;
      }
      sh_obj->waiters.stqh_first = -1;
      sh_obj->waiters.stqh_last = (u_int8_t *)(& sh_obj->waiters.stqh_first) - (u_int8_t *)(& sh_obj->waiters);
      sh_obj->holders.stqh_first = -1;
      sh_obj->holders.stqh_last = (u_int8_t *)(& sh_obj->holders.stqh_first) - (u_int8_t *)(& sh_obj->holders);
      sh_obj->lockobj.size = obj->size;
      sh_obj->lockobj.off = (u_int8_t *)p - (u_int8_t *)(& sh_obj->lockobj);
      while (1) {
        __bucket___0 = lt->obj_tab + ndx;
        while (1) {
          if (__bucket___0->stqh_first != -1) {
            sh_obj->links.stqe_next = __bucket___0->stqh_first - ((u_int8_t *)sh_obj -
                                                                  (u_int8_t *)__bucket___0);
            if (sh_obj->links.stqe_next == -1) {
              ((struct __db_lockobj *)((u_int8_t *)__bucket___0 + __bucket___0->stqh_first))->links.stqe_prev = 0;
            } else {
              ((struct __db_lockobj *)((u_int8_t *)__bucket___0 + __bucket___0->stqh_first))->links.stqe_prev = - sh_obj->links.stqe_next +
                                                                                                                ((u_int8_t *)(& sh_obj->links.stqe_next) -
                                                                                                                 (u_int8_t *)sh_obj);
            }
          } else {
            __bucket___0->stqh_last = (u_int8_t *)(& sh_obj->links.stqe_next) - (u_int8_t *)__bucket___0;
            sh_obj->links.stqe_next = -1;
          }
          __bucket___0->stqh_first = (u_int8_t *)sh_obj - (u_int8_t *)__bucket___0;
          sh_obj->links.stqe_prev = (u_int8_t *)(& __bucket___0->stqh_first) - (u_int8_t *)sh_obj;
          break;
        }
        break;
      }
    }
  }
  (*retp) = sh_obj;
  return (0);
  err: 
  return (ret);
}
}
static int __lock_is_parent(DB_LOCKTAB *lt , u_int32_t locker , DB_LOCKER *sh_locker ) 
{ DB_LOCKER *parent ;

  {
  parent = sh_locker;
  while (parent->parent_locker != 0U) {
    parent = (DB_LOCKER *)((void *)((u_int8_t *)lt->reginfo.addr + parent->parent_locker));
    if (parent->id == locker) {
      return (1);
    }
  }
  return (0);
}
}
static int __lock_inherit_locks(DB_LOCKTAB *lt , u_int32_t locker , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKER *sh_locker ;
  DB_LOCKER *sh_parent ;
  DB_LOCKOBJ *obj ;
  DB_LOCKREGION *region ;
  int ret ;
  struct __db_lock *hlp ;
  struct __db_lock *lp ;
  u_int32_t ndx ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  int tmp___1 ;

  {
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  dbenv___0 = lt->dbenv;
  tmp = __lock_locker_hash(locker);
  ndx = tmp % region->locker_t_size;
  ret = __lock_getlocker(lt, locker, ndx, 0, & sh_locker);
  if (ret != 0) {
    goto _L;
  } else {
    if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if (sh_locker->flags & 1U) {
        _L: 
        if (ret == 0) {
          if ((unsigned int )sh_locker != (unsigned int )((void *)0)) {
            ret = 22;
          }
        }
        __db_err((DB_ENV const   *)dbenv___0, __db_locker_invalid);
        goto err;
      }
    }
  }
  if (sh_locker->parent_locker == 0U) {
    __db_err((DB_ENV const   *)dbenv___0, "Not a child transaction");
    ret = 22;
    goto err;
  }
  sh_parent = (DB_LOCKER *)((void *)((u_int8_t *)lt->reginfo.addr + sh_locker->parent_locker));
  sh_locker->flags |= 1U;
  tmp___0 = __lock_locker_hash(locker);
  ndx = tmp___0 % region->locker_t_size;
  if (sh_parent->flags & 1U) {
    if (ret == 0) {
      __db_err((DB_ENV const   *)dbenv___0, "Parent locker is not valid");
      ret = 22;
    }
    goto err;
  }
  if (sh_locker->heldby.slh_first == -1) {
    lp = (struct __db_lock *)((void *)0);
  } else {
    lp = (struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first);
  }
  while ((unsigned int )lp != (unsigned int )((void *)0)) {
    while (1) {
      if (lp->locker_links.sle_next != -1) {
        ((struct __db_lock *)((u_int8_t *)lp + lp->locker_links.sle_next))->locker_links.sle_prev = lp->locker_links.sle_prev -
                                                                                                    lp->locker_links.sle_next;
        (*((ssize_t *)((u_int8_t *)lp + lp->locker_links.sle_prev))) = (*((ssize_t *)((u_int8_t *)lp +
                                                                                      lp->locker_links.sle_prev))) +
                                                                       lp->locker_links.sle_next;
      } else {
        (*((ssize_t *)((u_int8_t *)lp + lp->locker_links.sle_prev))) = -1;
      }
      break;
    }
    obj = (DB_LOCKOBJ *)((u_int8_t *)lp + lp->obj);
    if (obj->holders.stqh_first == -1) {
      hlp = (struct __db_lock *)((void *)0);
    } else {
      hlp = (struct __db_lock *)((u_int8_t *)(& obj->holders) + obj->holders.stqh_first);
    }
    while ((unsigned int )hlp != (unsigned int )((void *)0)) {
      if (hlp->holder == sh_parent->id) {
        if ((int )lp->mode == (int )hlp->mode) {
          break;
        }
      }
      if (hlp->links.stqe_next == -1) {
        hlp = (struct __db_lock *)((void *)0);
      } else {
        hlp = (struct __db_lock *)((u_int8_t *)hlp + hlp->links.stqe_next);
      }
    }
    if ((unsigned int )hlp != (unsigned int )((void *)0)) {
      hlp->refcount += lp->refcount;
      while (1) {
        if (lp->links.stqe_next != -1) {
          ((struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next))->links.stqe_prev = lp->links.stqe_prev +
                                                                                          ((u_int8_t *)lp -
                                                                                           (u_int8_t *)((struct __db_lock *)((u_int8_t *)lp +
                                                                                                                             lp->links.stqe_next)));
          (*((ssize_t *)((u_int8_t *)lp + lp->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)lp +
                                                                                  lp->links.stqe_prev))) +
                                                                   lp->links.stqe_next;
        } else {
          obj->holders.stqh_last = lp->links.stqe_prev + ((u_int8_t *)lp - (u_int8_t *)(& obj->holders));
          (*((ssize_t *)((u_int8_t *)lp + lp->links.stqe_prev))) = -1;
        }
        break;
      }
      __lock_freelock(lt, lp, locker, 131072U);
    } else {
      while (1) {
        if (sh_parent->heldby.slh_first != -1) {
          lp->locker_links.sle_next = sh_parent->heldby.slh_first - ((u_int8_t *)lp -
                                                                     (u_int8_t *)(& sh_parent->heldby));
          if (lp->locker_links.sle_next == -1) {
            tmp___1 = 0;
          } else {
            tmp___1 = - lp->locker_links.sle_next;
          }
          ((struct __db_lock *)((u_int8_t *)(& sh_parent->heldby) + sh_parent->heldby.slh_first))->locker_links.sle_prev = tmp___1 +
                                                                                                                           ((u_int8_t *)(& lp->locker_links.sle_next) -
                                                                                                                            (u_int8_t *)lp);
        } else {
          lp->locker_links.sle_next = -1;
        }
        sh_parent->heldby.slh_first = (u_int8_t *)lp - (u_int8_t *)(& sh_parent->heldby);
        lp->locker_links.sle_prev = (u_int8_t *)(& sh_parent->heldby.slh_first) -
                                    (u_int8_t *)lp;
        break;
      }
      lp->holder = sh_parent->id;
    }
    __lock_promote(lt, obj, flags & 1048576U);
    if (sh_locker->heldby.slh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first);
    }
  }
  sh_parent->nlocks += sh_locker->nlocks;
  sh_parent->nwrites += sh_locker->nwrites;
  err: 
  return (ret);
}
}
int __lock_promote(DB_LOCKTAB *lt , DB_LOCKOBJ *obj , u_int32_t flags ) 
{ struct __db_lock *lp_w ;
  struct __db_lock *lp_h ;
  struct __db_lock *next_waiter ;
  DB_LOCKER *sh_locker ;
  DB_LOCKREGION *region ;
  u_int32_t locker_ndx ;
  int had_waiters ;
  int state_changed ;
  u_int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct __db_lock *tmp___2 ;

  {
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  had_waiters = 0;
  if (obj->waiters.stqh_first == -1) {
    lp_w = (struct __db_lock *)((void *)0);
  } else {
    lp_w = (struct __db_lock *)((u_int8_t *)(& obj->waiters) + obj->waiters.stqh_first);
  }
  state_changed = (unsigned int )lp_w == (unsigned int )((void *)0);
  while ((unsigned int )lp_w != (unsigned int )((void *)0)) {
    had_waiters = 1;
    if (lp_w->links.stqe_next == -1) {
      next_waiter = (struct __db_lock *)((void *)0);
    } else {
      next_waiter = (struct __db_lock *)((u_int8_t *)lp_w + lp_w->links.stqe_next);
    }
    if ((int )lp_w->status != 8) {
      goto __Cont;
    }
    if (flags & 1048576U) {
      if ((int )lp_w->mode == 3) {
        goto __Cont;
      }
    }
    if (flags & 4U) {
      __lock_remove_waiter(lt, obj, lp_w, (enum __anonenum_db_status_t_29 )6);
      goto __Cont;
    }
    if (obj->holders.stqh_first == -1) {
      lp_h = (struct __db_lock *)((void *)0);
    } else {
      lp_h = (struct __db_lock *)((u_int8_t *)(& obj->holders) + obj->holders.stqh_first);
    }
    while ((unsigned int )lp_h != (unsigned int )((void *)0)) {
      if (lp_h->holder != lp_w->holder) {
        if ((*(lt->conflicts + ((unsigned int )lp_h->mode * region->stat.st_nmodes +
                                (unsigned int )lp_w->mode)))) {
          tmp = __lock_locker_hash(lp_w->holder);
          locker_ndx = tmp % region->locker_t_size;
          tmp___0 = __lock_getlocker(lt, lp_w->holder, locker_ndx, 0, & sh_locker);
          if (tmp___0 != 0) {
            break;
          }
          tmp___1 = __lock_is_parent(lt, lp_h->holder, sh_locker);
          if (! tmp___1) {
            break;
          }
        }
      }
      if (lp_h->links.stqe_next == -1) {
        lp_h = (struct __db_lock *)((void *)0);
      } else {
        lp_h = (struct __db_lock *)((u_int8_t *)lp_h + lp_h->links.stqe_next);
      }
    }
    if ((unsigned int )lp_h != (unsigned int )((void *)0)) {
      break;
    }
    while (1) {
      if (lp_w->links.stqe_next != -1) {
        ((struct __db_lock *)((u_int8_t *)lp_w + lp_w->links.stqe_next))->links.stqe_prev = lp_w->links.stqe_prev +
                                                                                            ((u_int8_t *)lp_w -
                                                                                             (u_int8_t *)((struct __db_lock *)((u_int8_t *)lp_w +
                                                                                                                               lp_w->links.stqe_next)));
        (*((ssize_t *)((u_int8_t *)lp_w + lp_w->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)lp_w +
                                                                                    lp_w->links.stqe_prev))) +
                                                                     lp_w->links.stqe_next;
      } else {
        obj->waiters.stqh_last = lp_w->links.stqe_prev + ((u_int8_t *)lp_w - (u_int8_t *)(& obj->waiters));
        (*((ssize_t *)((u_int8_t *)lp_w + lp_w->links.stqe_prev))) = -1;
      }
      break;
    }
    lp_w->status = (enum __anonenum_db_status_t_29 )7;
    while (1) {
      lp_w->links.stqe_next = -1;
      lp_w->links.stqe_prev = - ((u_int8_t *)lp_w - (u_int8_t *)(& obj->holders)) +
                              obj->holders.stqh_last;
      if (obj->holders.stqh_last == (u_int8_t *)(& obj->holders.stqh_first) - (u_int8_t *)(& obj->holders)) {
        obj->holders.stqh_first = (u_int8_t *)lp_w - (u_int8_t *)(& obj->holders);
      } else {
        (*((ssize_t *)((u_int8_t *)(& obj->holders) + obj->holders.stqh_last))) = (- obj->holders.stqh_last +
                                                                                   ((u_int8_t *)(& lp_w->links.stqe_next) -
                                                                                    (u_int8_t *)lp_w)) +
                                                                                  ((u_int8_t *)lp_w -
                                                                                   (u_int8_t *)(& obj->holders));
      }
      obj->holders.stqh_last = (u_int8_t *)(& lp_w->links.stqe_next) - (u_int8_t *)(& obj->holders);
      break;
    }
    if (! (lp_w->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(lt->dbenv, & lp_w->mutex);
    }
    state_changed = 1;
    __Cont: 
    lp_w = next_waiter;
  }
  if (had_waiters) {
    if (obj->waiters.stqh_first == -1) {
      tmp___2 = (struct __db_lock *)((void *)0);
    } else {
      tmp___2 = (struct __db_lock *)((u_int8_t *)(& obj->waiters) + obj->waiters.stqh_first);
    }
    if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
      while (1) {
        if (obj->dd_links.stqe_next != -1) {
          ((struct __db_lockobj *)((u_int8_t *)obj + obj->dd_links.stqe_next))->dd_links.stqe_prev = obj->dd_links.stqe_prev +
                                                                                                     ((u_int8_t *)obj -
                                                                                                      (u_int8_t *)((struct __db_lockobj *)((u_int8_t *)obj +
                                                                                                                                           obj->dd_links.stqe_next)));
          (*((ssize_t *)((u_int8_t *)obj + obj->dd_links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)obj +
                                                                                       obj->dd_links.stqe_prev))) +
                                                                        obj->dd_links.stqe_next;
        } else {
          region->dd_objs.stqh_last = obj->dd_links.stqe_prev + ((u_int8_t *)obj -
                                                                 (u_int8_t *)(& region->dd_objs));
          (*((ssize_t *)((u_int8_t *)obj + obj->dd_links.stqe_prev))) = -1;
        }
        break;
      }
    }
  }
  return (state_changed);
}
}
static void __lock_remove_waiter(DB_LOCKTAB *lt , DB_LOCKOBJ *sh_obj , struct __db_lock *lockp ,
                                 db_status_t status ) 
{ DB_LOCKREGION *region ;
  int do_wakeup ;
  struct __db_lock *tmp ;

  {
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  do_wakeup = (int )lockp->status == 8;
  while (1) {
    if (lockp->links.stqe_next != -1) {
      ((struct __db_lock *)((u_int8_t *)lockp + lockp->links.stqe_next))->links.stqe_prev = lockp->links.stqe_prev +
                                                                                            ((u_int8_t *)lockp -
                                                                                             (u_int8_t *)((struct __db_lock *)((u_int8_t *)lockp +
                                                                                                                               lockp->links.stqe_next)));
      (*((ssize_t *)((u_int8_t *)lockp + lockp->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)lockp +
                                                                                    lockp->links.stqe_prev))) +
                                                                     lockp->links.stqe_next;
    } else {
      sh_obj->waiters.stqh_last = lockp->links.stqe_prev + ((u_int8_t *)lockp - (u_int8_t *)(& sh_obj->waiters));
      (*((ssize_t *)((u_int8_t *)lockp + lockp->links.stqe_prev))) = -1;
    }
    break;
  }
  lockp->links.stqe_prev = -1;
  lockp->status = status;
  if (sh_obj->waiters.stqh_first == -1) {
    tmp = (struct __db_lock *)((void *)0);
  } else {
    tmp = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
  }
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    while (1) {
      if (sh_obj->dd_links.stqe_next != -1) {
        ((struct __db_lockobj *)((u_int8_t *)sh_obj + sh_obj->dd_links.stqe_next))->dd_links.stqe_prev = sh_obj->dd_links.stqe_prev +
                                                                                                         ((u_int8_t *)sh_obj -
                                                                                                          (u_int8_t *)((struct __db_lockobj *)((u_int8_t *)sh_obj +
                                                                                                                                               sh_obj->dd_links.stqe_next)));
        (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->dd_links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_obj +
                                                                                           sh_obj->dd_links.stqe_prev))) +
                                                                            sh_obj->dd_links.stqe_next;
      } else {
        region->dd_objs.stqh_last = sh_obj->dd_links.stqe_prev + ((u_int8_t *)sh_obj -
                                                                  (u_int8_t *)(& region->dd_objs));
        (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->dd_links.stqe_prev))) = -1;
      }
      break;
    }
  }
  if (do_wakeup) {
    if (! (lockp->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(lt->dbenv, & lockp->mutex);
    }
  }
  return;
}
}
static void __lock_expires(DB_ENV *dbenv___0 , db_timeval_t *timevalp , db_timeout_t timeout ) 
{ 

  {
  if (! (timevalp->tv_sec != 0U)) {
    __os_clock(dbenv___0, & timevalp->tv_sec, & timevalp->tv_usec);
  }
  if (timeout > 1000000U) {
    timevalp->tv_sec += timeout / 1000000U;
    timevalp->tv_usec += timeout % 1000000U;
  } else {
    timevalp->tv_usec += timeout;
  }
  if (timevalp->tv_usec > 1000000U) {
    timevalp->tv_sec ++;
    timevalp->tv_usec -= 1000000U;
  }
  return;
}
}
int __lock_expired(DB_ENV *dbenv___0 , db_timeval_t *now , db_timeval_t *timevalp ) 
{ int tmp ;

  {
  if (! (timevalp->tv_sec != 0U)) {
    return (0);
  }
  if (! (now->tv_sec != 0U)) {
    __os_clock(dbenv___0, & now->tv_sec, & now->tv_usec);
  }
  if (now->tv_sec > timevalp->tv_sec) {
    tmp = 1;
  } else {
    if (now->tv_sec == timevalp->tv_sec) {
      if (now->tv_usec >= timevalp->tv_usec) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  }
  return (tmp);
}
}
static int __lock_trade(DB_ENV *dbenv___0 , DB_LOCK *lock , u_int32_t new_locker ) 
{ struct __db_lock *lp ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  DB_LOCKER *sh_locker ;
  int ret ;
  u_int32_t locker_ndx ;
  u_int32_t tmp ;
  int tmp___0 ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  lp = (struct __db_lock *)((void *)((u_int8_t *)lt->reginfo.addr + lock->off));
  if (lp->gen != lock->gen) {
    return (-30990);
  }
  tmp = __lock_locker_hash(new_locker);
  locker_ndx = tmp % region->locker_t_size;
  ret = __lock_getlocker(lt, new_locker, locker_ndx, 0, & sh_locker);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Locker does not exist");
    return (22);
  }
  ret = __lock_freelock(lt, lp, lp->holder, 524288U);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    if (sh_locker->heldby.slh_first != -1) {
      lp->locker_links.sle_next = sh_locker->heldby.slh_first - ((u_int8_t *)lp -
                                                                 (u_int8_t *)(& sh_locker->heldby));
      if (lp->locker_links.sle_next == -1) {
        tmp___0 = 0;
      } else {
        tmp___0 = - lp->locker_links.sle_next;
      }
      ((struct __db_lock *)((u_int8_t *)(& sh_locker->heldby) + sh_locker->heldby.slh_first))->locker_links.sle_prev = tmp___0 +
                                                                                                                       ((u_int8_t *)(& lp->locker_links.sle_next) -
                                                                                                                        (u_int8_t *)lp);
    } else {
      lp->locker_links.sle_next = -1;
    }
    sh_locker->heldby.slh_first = (u_int8_t *)lp - (u_int8_t *)(& sh_locker->heldby);
    lp->locker_links.sle_prev = (u_int8_t *)(& sh_locker->heldby.slh_first) - (u_int8_t *)lp;
    break;
  }
  sh_locker->nlocks ++;
  if ((int )lp->mode == 2) {
    sh_locker->nwrites ++;
  } else {
    if ((int )lp->mode == 8) {
      sh_locker->nwrites ++;
    } else {
      if ((int )lp->mode == 4) {
        sh_locker->nwrites ++;
      } else {
        if ((int )lp->mode == 6) {
          sh_locker->nwrites ++;
        }
      }
    }
  }
  lp->holder = new_locker;
  return (0);
}
}
static int __lock_fix_list(DB_ENV *dbenv___0 , DBT *list_dbt , u_int32_t nlocks ) 
{ DBT *obj ;
  DB_LOCK_ILOCK *lock ;
  DB_LOCK_ILOCK *plock ;
  u_int32_t i ;
  u_int32_t j ;
  u_int32_t nfid ;
  u_int32_t npgno ;
  u_int32_t size ;
  int ret ;
  u_int8_t *data ;
  u_int8_t *dp ;
  u_int32_t *ip ;
  u_int16_t *ip___0 ;
  u_int16_t *ip___1 ;
  int tmp ;
  u_int32_t *ip___2 ;
  u_int16_t *ip___3 ;
  u_int16_t *ip___4 ;
  db_pgno_t *ip___5 ;

  {
  size = list_dbt->size;
  if (size == 0U) {
    return (0);
  }
  obj = (DBT *)list_dbt->data;
  switch ((int )nlocks) {
  case 1: 
  size = (obj->size + sizeof(u_int32_t )) + 2U * sizeof(u_int16_t );
  ret = __os_malloc(dbenv___0, size, (void *)(& data));
  if (ret != 0) {
    return (ret);
  }
  dp = data;
  while (1) {
    ip = (u_int32_t *)dp;
    (*ip) = 1U;
    dp = dp + sizeof(u_int32_t );
    break;
  }
  while (1) {
    ip___0 = (u_int16_t *)dp;
    (*ip___0) = (unsigned short)0;
    dp = dp + sizeof(u_int16_t );
    break;
  }
  while (1) {
    ip___1 = (u_int16_t *)dp;
    (*ip___1) = (unsigned short )obj->size;
    dp = dp + sizeof(u_int16_t );
    break;
  }
  while (1) {
    memcpy((void * __restrict  )dp, (void const   * __restrict  )obj->data, obj->size);
    dp = dp + ((unsigned long long )((obj->size + sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                 1ULL));
    break;
  }
  break;
  default: 
  qsort(list_dbt->data, nlocks, sizeof(DBT ), & __lock_sort_cmp);
  case 2: 
  npgno = 0U;
  nfid = npgno;
  i = 0U;
  if (obj->size != sizeof(DB_LOCK_ILOCK )) {
    goto not_ilock;
  }
  nfid = 1U;
  plock = (DB_LOCK_ILOCK *)obj->data;
  j = 0U;
  (obj + 0)->ulen = 0U;
  i = 1U;
  while (i < nlocks) {
    if ((obj + i)->size != sizeof(DB_LOCK_ILOCK )) {
      break;
    }
    lock = (DB_LOCK_ILOCK *)(obj + i)->data;
    if ((obj + j)->ulen < 65535U) {
      if (lock->type == plock->type) {
        tmp = memcmp((void const   *)(lock->fileid), (void const   *)(plock->fileid),
                     20U);
        if (tmp == 0) {
          (obj + j)->ulen = (obj + j)->ulen + 1U;
          npgno ++;
        } else {
          nfid ++;
          plock = lock;
          j = i;
          (obj + j)->ulen = 0U;
        }
      } else {
        nfid ++;
        plock = lock;
        j = i;
        (obj + j)->ulen = 0U;
      }
    } else {
      nfid ++;
      plock = lock;
      j = i;
      (obj + j)->ulen = 0U;
    }
    i ++;
  }
  not_ilock: 
  size = nfid * sizeof(DB_LOCK_ILOCK );
  size += npgno * sizeof(db_pgno_t );
  nfid += nlocks - i;
  while (i < nlocks) {
    size += (obj + i)->size;
    (obj + i)->ulen = 0U;
    i ++;
  }
  size = (size + sizeof(u_int32_t )) + (nfid * 2U) * sizeof(u_int16_t );
  ret = __os_malloc(dbenv___0, size, (void *)(& data));
  if (ret != 0) {
    return (ret);
  }
  dp = data;
  while (1) {
    ip___2 = (u_int32_t *)dp;
    (*ip___2) = nfid;
    dp = dp + sizeof(u_int32_t );
    break;
  }
  i = 0U;
  while (i < nlocks) {
    while (1) {
      ip___3 = (u_int16_t *)dp;
      (*ip___3) = (unsigned short )(obj + i)->ulen;
      dp = dp + sizeof(u_int16_t );
      break;
    }
    while (1) {
      ip___4 = (u_int16_t *)dp;
      (*ip___4) = (unsigned short )(obj + i)->size;
      dp = dp + sizeof(u_int16_t );
      break;
    }
    while (1) {
      memcpy((void * __restrict  )dp, (void const   * __restrict  )obj->data, obj->size);
      dp = dp + ((unsigned long long )((obj->size + sizeof(u_int32_t )) - 1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                                   1ULL));
      break;
    }
    lock = (DB_LOCK_ILOCK *)(obj + i)->data;
    j = i + 1U;
    while (j <= i + (obj + i)->ulen) {
      lock = (DB_LOCK_ILOCK *)(obj + j)->data;
      while (1) {
        ip___5 = (db_pgno_t *)dp;
        (*ip___5) = lock->pgno;
        dp = dp + sizeof(db_pgno_t );
        break;
      }
      j ++;
    }
    i = j;
  }
  }
  __os_free(dbenv___0, list_dbt->data);
  list_dbt->data = (void *)data;
  list_dbt->size = size;
  return (0);
}
}
int __lock_get_list(DB_ENV *dbenv___0 , u_int32_t locker , u_int32_t flags , db_lockmode_t lock_mode ,
                    DBT *list___2 ) 
{ DBT obj_dbt ;
  DB_LOCK ret_lock ;
  DB_LOCK_ILOCK *lock ;
  DB_LOCKTAB *lt ;
  DB_LOCKREGION *region ;
  db_pgno_t save_pgno ;
  u_int16_t npgno ;
  u_int16_t size ;
  u_int32_t i ;
  u_int32_t nlocks ;
  int ret ;
  void *dp ;
  u_int16_t tmp ;

  {
  if (list___2->size == 0U) {
    return (0);
  }
  ret = 0;
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  dp = list___2->data;
  while (1) {
    nlocks = (*((u_int32_t *)dp));
    dp = (void *)((u_int8_t *)dp + sizeof(u_int32_t ));
    break;
  }
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  i = 0U;
  while (i < nlocks) {
    while (1) {
      npgno = (*((u_int16_t *)dp));
      dp = (void *)((u_int8_t *)dp + sizeof(u_int16_t ));
      break;
    }
    while (1) {
      size = (*((u_int16_t *)dp));
      dp = (void *)((u_int8_t *)dp + sizeof(u_int16_t ));
      break;
    }
    lock = (DB_LOCK_ILOCK *)dp;
    save_pgno = lock->pgno;
    obj_dbt.data = dp;
    obj_dbt.size = (unsigned int )size;
    dp = (void *)((u_int8_t *)dp + ((unsigned long long )(((unsigned int )size + sizeof(u_int32_t )) -
                                                          1U) & ~ ((unsigned long long )sizeof(u_int32_t ) -
                                                                   1ULL)));
    while (1) {
      ret = __lock_get_internal(lt, locker, flags, (DBT const   *)(& obj_dbt), lock_mode,
                                0U, & ret_lock);
      if (ret != 0) {
        lock->pgno = save_pgno;
        goto err;
      }
      if ((int )npgno != 0) {
        while (1) {
          lock->pgno = (*((db_pgno_t *)dp));
          dp = (void *)((u_int8_t *)dp + sizeof(db_pgno_t ));
          break;
        }
      }
      tmp = npgno;
      npgno = (unsigned short )((int )npgno - 1);
      if (! ((int )tmp != 0)) {
        break;
      }
    }
    lock->pgno = save_pgno;
    i ++;
  }
  err: 
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static int __lock_sort_cmp(void const   *a , void const   *b ) 
{ DBT const   *d1 ;
  DBT const   *d2 ;
  DB_LOCK_ILOCK *l1 ;
  DB_LOCK_ILOCK *l2 ;
  int tmp ;

  {
  d1 = (DBT const   *)a;
  d2 = (DBT const   *)b;
  if (d1->size != sizeof(DB_LOCK_ILOCK )) {
    if (d2->size != sizeof(DB_LOCK_ILOCK )) {
      return ((int )(d1->size - d2->size));
    } else {
      return (1);
    }
  } else {
    if (d2->size != sizeof(DB_LOCK_ILOCK )) {
      return (-1);
    }
  }
  l1 = (DB_LOCK_ILOCK *)d1->data;
  l2 = (DB_LOCK_ILOCK *)d2->data;
  if (l1->type != l2->type) {
    return ((int )(l1->type - l2->type));
  }
  tmp = memcmp((void const   *)(l1->fileid), (void const   *)(l2->fileid), 20U);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-1Ln2pE3z.i","-O2")
int __lock_detect_pp(DB_ENV *dbenv___0 , u_int32_t flags , u_int32_t atype , int *abortp ) ;
static int __dd_abort(DB_ENV *dbenv___0 , locker_info *info ) ;
static int __dd_build(DB_ENV *dbenv___0 , u_int32_t atype , u_int32_t **bmp , u_int32_t *nlockers ,
                      u_int32_t *allocp , locker_info **idmap ) ;
static int __dd_find(DB_ENV *dbenv___0 , u_int32_t *bmp , locker_info *idmap , u_int32_t nlockers ,
                     u_int32_t nalloc , u_int32_t ***deadp ) ;
static int __dd_isolder(u_int32_t a , u_int32_t b , u_int32_t lock_max , u_int32_t txn_max ) ;
static int __dd_verify(locker_info *idmap , u_int32_t *deadmap , u_int32_t *tmpmap ,
                       u_int32_t *origmap , u_int32_t nlockers , u_int32_t nalloc ,
                       u_int32_t which ) ;
int __lock_detect_pp(DB_ENV *dbenv___0 , u_int32_t flags , u_int32_t atype , int *abortp ) 
{ int ret ;
  int rep_check ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_detect", 8192U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->lock_detect", flags, 0U);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )atype) {
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->lock_detect: unknown deadlock detection mode specified");
  return (22);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_detect(dbenv___0, atype, abortp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __lock_detect(DB_ENV *dbenv___0 , u_int32_t atype , int *abortp ) 
{ DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  DB_TXNMGR *tmgr ;
  db_timeval_t now ;
  locker_info *idmap ;
  u_int32_t *bitmap ;
  u_int32_t *copymap ;
  u_int32_t **deadp ;
  u_int32_t **free_me ;
  u_int32_t *tmpmap ;
  u_int32_t i ;
  u_int32_t keeper ;
  u_int32_t killid ;
  u_int32_t limit ;
  u_int32_t nalloc ;
  u_int32_t nlockers ;
  u_int32_t lock_max ;
  u_int32_t txn_max ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = __rep_is_client(dbenv___0);
  if (tmp) {
    atype = 5U;
  }
  free_me = (u_int32_t **)((void *)0);
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  if ((unsigned int )abortp != (unsigned int )((void *)0)) {
    (*abortp) = 0;
  }
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  now.tv_sec = 0U;
  if (region->need_dd == 0U) {
    if (! (region->next_timeout.tv_sec != 0U)) {
      goto _L;
    } else {
      tmp___0 = __lock_expired(dbenv___0, & now, & region->next_timeout);
      if (! tmp___0) {
        _L: 
        if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
        }
        return (0);
      }
    }
  }
  if (region->need_dd == 0U) {
    atype = 2U;
  }
  region->need_dd = 0U;
  ret = __dd_build(dbenv___0, atype, & bitmap, & nlockers, & nalloc, & idmap);
  lock_max = region->stat.st_cur_maxid;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  tmgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  if ((unsigned int )tmgr != (unsigned int )((void *)0)) {
    if (! ((tmgr->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (tmgr->reginfo.rp)->mutex);
    }
    txn_max = ((DB_TXNREGION *)tmgr->reginfo.primary)->cur_maxid;
    if (! ((tmgr->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (tmgr->reginfo.rp)->mutex);
    }
  } else {
    txn_max = 4294967295U;
  }
  if (ret != 0) {
    return (ret);
  } else {
    if (atype == 2U) {
      return (ret);
    }
  }
  if (nlockers == 0U) {
    return (0);
  }
  ret = __os_calloc(dbenv___0, nlockers, sizeof(u_int32_t ) * nalloc, (void *)(& copymap));
  if (ret != 0) {
    goto err;
  }
  memcpy((void * __restrict  )copymap, (void const   * __restrict  )bitmap, (nlockers *
                                                                             sizeof(u_int32_t )) *
                                                                            nalloc);
  ret = __os_calloc(dbenv___0, sizeof(u_int32_t ), nalloc, (void *)(& tmpmap));
  if (ret != 0) {
    goto err1;
  }
  ret = __dd_find(dbenv___0, bitmap, idmap, nlockers, nalloc, & deadp);
  if (ret != 0) {
    return (ret);
  }
  killid = 4294967295U;
  free_me = deadp;
  while ((unsigned int )(*deadp) != (unsigned int )((void *)0)) {
    if ((unsigned int )abortp != (unsigned int )((void *)0)) {
      (*abortp) ++;
    }
    killid = (unsigned int )((*deadp) - bitmap) / nalloc;
    limit = killid;
    keeper = 4294967295U;
    if (atype == 1U) {
      goto dokill;
    } else {
      if (atype == 7U) {
        goto dokill;
      }
    }
    if (killid == 4294967295U) {
      break;
    }
    i = (killid + 1U) % nlockers;
    while (i != limit) {
      if (! ((*((*deadp) + i / 32U)) & (unsigned int )(1 << i % 32U))) {
        goto __Cont;
      } else {
        if ((idmap + i)->in_abort) {
          goto __Cont;
        }
      }
      switch ((int )atype) {
      case 6: 
      tmp___1 = __dd_isolder((idmap + killid)->id, (idmap + i)->id, lock_max, txn_max);
      if (tmp___1) {
        goto __Cont;
      }
      keeper = i;
      break;
      case 8: 
      tmp___2 = __dd_isolder((idmap + i)->id, (idmap + killid)->id, lock_max, txn_max);
      if (tmp___2) {
        goto __Cont;
      }
      keeper = i;
      break;
      case 3: ;
      if ((idmap + i)->count < (idmap + killid)->count) {
        goto __Cont;
      }
      keeper = i;
      break;
      case 4: ;
      case 5: ;
      if ((idmap + i)->count > (idmap + killid)->count) {
        goto __Cont;
      }
      keeper = i;
      break;
      default: 
      killid = 4294967295U;
      ret = 22;
      goto dokill;
      }
      tmp___3 = __dd_verify(idmap, (*deadp), tmpmap, copymap, nlockers, nalloc, i);
      if (tmp___3) {
        killid = i;
      }
      __Cont: 
      i = (i + 1U) % nlockers;
    }
    dokill: 
    if (killid == 4294967295U) {
      goto __Cont___0;
    }
    if (keeper != 4294967295U) {
      if (killid == limit) {
        tmp___4 = __dd_verify(idmap, (*deadp), tmpmap, copymap, nlockers, nalloc,
                              killid);
        if (tmp___4 == 0) {
          if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
            __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
          }
          region->need_dd = 1U;
          if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
          }
          killid = keeper;
        }
      }
    }
    ret = __dd_abort(dbenv___0, idmap + killid);
    if (ret != 0) {
      if (ret == -30899) {
        ret = 0;
      } else {
        __db_err((DB_ENV const   *)dbenv___0, "warning: unable to abort locker %lx",
                 (unsigned long )(idmap + killid)->id);
      }
    } else {
      if (dbenv___0->verbose & 2U) {
        __db_err((DB_ENV const   *)dbenv___0, "Aborting locker %lx", (unsigned long )(idmap +
                                                                                      killid)->id);
      }
    }
    __Cont___0: 
    deadp ++;
  }
  __os_free(dbenv___0, (void *)tmpmap);
  err1: 
  __os_free(dbenv___0, (void *)copymap);
  err: 
  if ((unsigned int )free_me != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)free_me);
  }
  __os_free(dbenv___0, (void *)bitmap);
  __os_free(dbenv___0, (void *)idmap);
  return (ret);
}
}
static int __dd_build(DB_ENV *dbenv___0 , u_int32_t atype , u_int32_t **bmp , u_int32_t *nlockers ,
                      u_int32_t *allocp , locker_info **idmap ) 
{ struct __db_lock *lp ;
  DB_LOCKER *lip ;
  DB_LOCKER *lockerp ;
  DB_LOCKER *child ;
  DB_LOCKOBJ *op ;
  DB_LOCKOBJ *lo ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  locker_info *id_array ;
  db_timeval_t now ;
  db_timeval_t min_timeout ;
  u_int32_t *bitmap ;
  u_int32_t count ;
  u_int32_t dd ;
  u_int32_t *entryp ;
  u_int32_t id ;
  u_int32_t ndx ;
  u_int32_t nentries ;
  u_int32_t *tmpmap ;
  u_int8_t *pptr ;
  int expire_only ;
  int is_first ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t __i ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;
  int tmp___2 ;
  u_int32_t __i___0 ;
  u_int32_t tmp___3 ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  now.tv_sec = 0U;
  min_timeout.tv_sec = 4294967295U;
  expire_only = atype == 2U;
  if (expire_only) {
    count = 0U;
    nentries = 0U;
    goto obj_loop;
  }
  retry: 
  count = region->stat.st_nlockers;
  if (count == 0U) {
    (*nlockers) = 0U;
    return (0);
  }
  if (dbenv___0->verbose & 2U) {
    __db_err((DB_ENV const   *)dbenv___0, "%lu lockers", (unsigned long )count);
  }
  count += 20U;
  nentries = (unsigned int )(((unsigned long long )((count + 32U) - 1U) & 0xffffffffffffffe0ULL) /
                             32ULL);
  ret = __os_calloc(dbenv___0, count, sizeof(u_int32_t ) * nentries, (void *)(& bitmap));
  if (ret != 0) {
    return (ret);
  }
  ret = __os_calloc(dbenv___0, sizeof(u_int32_t ), nentries, (void *)(& tmpmap));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)bitmap);
    return (ret);
  }
  ret = __os_calloc(dbenv___0, count, sizeof(locker_info ), (void *)(& id_array));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)bitmap);
    __os_free(dbenv___0, (void *)tmpmap);
    return (ret);
  }
  if (region->stat.st_nlockers > count) {
    __os_free(dbenv___0, (void *)bitmap);
    __os_free(dbenv___0, (void *)tmpmap);
    __os_free(dbenv___0, (void *)id_array);
    goto retry;
  }
  id = 0U;
  if (region->lockers.stqh_first == -1) {
    lip = (DB_LOCKER *)((void *)0);
  } else {
    lip = (struct __db_locker *)((u_int8_t *)(& region->lockers) + region->lockers.stqh_first);
  }
  while ((unsigned int )lip != (unsigned int )((void *)0)) {
    if (lip->master_locker == 0U) {
      tmp = id;
      id ++;
      lip->dd_id = tmp;
      (id_array + lip->dd_id)->id = lip->id;
      if (atype == 4U) {
        (id_array + lip->dd_id)->count = lip->nlocks;
      } else {
        if (atype == 3U) {
          (id_array + lip->dd_id)->count = lip->nlocks;
        }
      }
      if (atype == 5U) {
        (id_array + lip->dd_id)->count = lip->nwrites;
      }
      if (lip->flags & 4U) {
        (id_array + lip->dd_id)->in_abort = 1;
      }
    } else {
      lip->dd_id = 4294967295U;
    }
    if (lip->ulinks.stqe_next == -1) {
      lip = (DB_LOCKER *)((void *)0);
    } else {
      lip = (struct __db_locker *)((u_int8_t *)lip + lip->ulinks.stqe_next);
    }
  }
  obj_loop: 
  if (region->dd_objs.stqh_first == -1) {
    op = (DB_LOCKOBJ *)((void *)0);
  } else {
    op = (struct __db_lockobj *)((u_int8_t *)(& region->dd_objs) + region->dd_objs.stqh_first);
  }
  while ((unsigned int )op != (unsigned int )((void *)0)) {
    if (expire_only) {
      goto look_waiters;
    }
    __i = 0U;
    while (__i < nentries) {
      (*(tmpmap + __i)) = 0U;
      __i ++;
    }
    if (op->holders.stqh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& op->holders) + op->holders.stqh_first);
    }
    while ((unsigned int )lp != (unsigned int )((void *)0)) {
      tmp___0 = __lock_locker_hash(lp->holder);
      ndx = tmp___0 % region->locker_t_size;
      ret = __lock_getlocker(lt, lp->holder, ndx, 0, & lockerp);
      if (ret != 0) {
        goto __Cont;
      }
      if (lockerp->dd_id == 4294967295U) {
        dd = ((DB_LOCKER *)((void *)((u_int8_t *)lt->reginfo.addr + lockerp->master_locker)))->dd_id;
        lockerp->dd_id = dd;
        if (atype == 4U) {
          (id_array + dd)->count = (id_array + dd)->count + lockerp->nlocks;
        } else {
          if (atype == 3U) {
            (id_array + dd)->count = (id_array + dd)->count + lockerp->nlocks;
          }
        }
        if (atype == 5U) {
          (id_array + dd)->count = (id_array + dd)->count + lockerp->nwrites;
        }
        if (lockerp->flags & 4U) {
          (id_array + dd)->in_abort = 1;
        }
      } else {
        dd = lockerp->dd_id;
      }
      (id_array + dd)->valid = 1;
      if ((int )lp->status == 5) {
        (*(tmpmap + dd / 32U)) = (*(tmpmap + dd / 32U)) | (unsigned int )(1 << dd %
                                                                               32U);
      }
      __Cont: 
      if (lp->links.stqe_next == -1) {
        lp = (struct __db_lock *)((void *)0);
      } else {
        lp = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
      }
    }
    look_waiters: 
    is_first = 1;
    if (op->waiters.stqh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& op->waiters) + op->waiters.stqh_first);
    }
    while ((unsigned int )lp != (unsigned int )((void *)0)) {
      tmp___1 = __lock_locker_hash(lp->holder);
      ndx = tmp___1 % region->locker_t_size;
      ret = __lock_getlocker(lt, lp->holder, ndx, 0, & lockerp);
      if (ret != 0) {
        goto __Cont___0;
      }
      if ((int )lp->status == 8) {
        tmp___2 = __lock_expired(dbenv___0, & now, & lockerp->lk_expire);
        if (tmp___2) {
          lp->status = (enum __anonenum_db_status_t_29 )3;
          if (! (lp->mutex.flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, & lp->mutex);
          }
          goto __Cont___0;
        }
        if (min_timeout.tv_sec > lockerp->lk_expire.tv_sec) {
          min_timeout = lockerp->lk_expire;
        } else {
          if (min_timeout.tv_sec == lockerp->lk_expire.tv_sec) {
            if (min_timeout.tv_usec > lockerp->lk_expire.tv_usec) {
              min_timeout = lockerp->lk_expire;
            }
          }
        }
      }
      if (expire_only) {
        goto __Cont___0;
      }
      if (lockerp->dd_id == 4294967295U) {
        dd = ((DB_LOCKER *)((void *)((u_int8_t *)lt->reginfo.addr + lockerp->master_locker)))->dd_id;
        lockerp->dd_id = dd;
        if (atype == 4U) {
          (id_array + dd)->count = (id_array + dd)->count + lockerp->nlocks;
        } else {
          if (atype == 3U) {
            (id_array + dd)->count = (id_array + dd)->count + lockerp->nlocks;
          }
        }
        if (atype == 5U) {
          (id_array + dd)->count = (id_array + dd)->count + lockerp->nwrites;
        }
      } else {
        dd = lockerp->dd_id;
      }
      (id_array + dd)->valid = 1;
      if ((int )lp->status != 8) {
        goto __Cont___0;
      }
      entryp = bitmap + nentries * dd;
      __i___0 = 0U;
      while (__i___0 < nentries) {
        (*(entryp + __i___0)) = (*(entryp + __i___0)) | (*(tmpmap + __i___0));
        __i___0 ++;
      }
      if (is_first) {
        if ((*(entryp + dd / 32U)) & (unsigned int )(1 << dd % 32U)) {
          (id_array + dd)->self_wait = 1;
        }
        (*(entryp + dd / 32U)) = (*(entryp + dd / 32U)) & (unsigned int )(~ (1 <<
                                                                             dd %
                                                                             32U));
      }
      __Cont___0: 
      is_first = 0;
      if (lp->links.stqe_next == -1) {
        lp = (struct __db_lock *)((void *)0);
      } else {
        lp = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
      }
    }
    if (op->dd_links.stqe_next == -1) {
      op = (DB_LOCKOBJ *)((void *)0);
    } else {
      op = (struct __db_lockobj *)((u_int8_t *)op + op->dd_links.stqe_next);
    }
  }
  if (region->next_timeout.tv_sec != 0U) {
    if (min_timeout.tv_sec == 4294967295U) {
      region->next_timeout.tv_sec = 0U;
    } else {
      region->next_timeout = min_timeout;
    }
  }
  if (expire_only) {
    return (0);
  }
  id = 0U;
  while (id < count) {
    if (! (id_array + id)->valid) {
      goto __Cont___1;
    }
    tmp___3 = __lock_locker_hash((id_array + id)->id);
    ndx = tmp___3 % region->locker_t_size;
    ret = __lock_getlocker(lt, (id_array + id)->id, ndx, 0, & lockerp);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "No locks for locker %lu", (unsigned long )(id_array +
                                                                                        id)->id);
      goto __Cont___1;
    }
    if (lockerp->child_locker.slh_first == -1) {
      child = (DB_LOCKER *)((void *)0);
    } else {
      child = (struct __db_locker *)((u_int8_t *)(& lockerp->child_locker) + lockerp->child_locker.slh_first);
    }
    if ((unsigned int )child != (unsigned int )((void *)0)) {
      while (1) {
        if (child->heldby.slh_first == -1) {
          lp = (struct __db_lock *)((void *)0);
        } else {
          lp = (struct __db_lock *)((u_int8_t *)(& child->heldby) + child->heldby.slh_first);
        }
        if ((unsigned int )lp != (unsigned int )((void *)0)) {
          if ((int )lp->status == 8) {
            (id_array + id)->last_locker_id = child->id;
            goto get_lock;
          }
        }
        if (child->child_link.sle_next == -1) {
          child = (DB_LOCKER *)((void *)0);
        } else {
          child = (struct __db_locker *)((u_int8_t *)child + child->child_link.sle_next);
        }
        if (! ((unsigned int )child != (unsigned int )((void *)0))) {
          break;
        }
      }
    }
    if (lockerp->heldby.slh_first == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)(& lockerp->heldby) + lockerp->heldby.slh_first);
    }
    if ((unsigned int )lp != (unsigned int )((void *)0)) {
      (id_array + id)->last_locker_id = lockerp->id;
      get_lock: 
      (id_array + id)->last_lock = (unsigned int )((u_int8_t *)lp - (u_int8_t *)lt->reginfo.addr);
      (id_array + id)->last_obj = lp->obj;
      lo = (DB_LOCKOBJ *)((u_int8_t *)lp + lp->obj);
      pptr = (u_int8_t *)((void *)((u_int8_t *)(& lo->lockobj) + lo->lockobj.off));
      if (lo->lockobj.size >= sizeof(db_pgno_t )) {
        memcpy((void * __restrict  )(& (id_array + id)->pgno), (void const   * __restrict  )pptr,
               sizeof(db_pgno_t ));
      } else {
        (id_array + id)->pgno = 0U;
      }
    }
    __Cont___1: 
    id ++;
  }
  region->need_dd = 0U;
  (*nlockers) = id;
  (*idmap) = id_array;
  (*bmp) = bitmap;
  (*allocp) = nentries;
  __os_free(dbenv___0, (void *)tmpmap);
  return (0);
}
}
static int __dd_find(DB_ENV *dbenv___0 , u_int32_t *bmp , locker_info *idmap , u_int32_t nlockers ,
                     u_int32_t nalloc , u_int32_t ***deadp ) 
{ u_int32_t i ;
  u_int32_t j ;
  u_int32_t k ;
  u_int32_t *mymap ;
  u_int32_t *tmpmap ;
  u_int32_t **retp ;
  int ndead ;
  int ndeadalloc ;
  int ret ;
  u_int32_t __i ;
  int tmp ;
  int tmp___0 ;

  {
  ndeadalloc = 8;
  ndead = 0;
  ret = __os_malloc(dbenv___0, (unsigned int )ndeadalloc * sizeof(u_int32_t *), (void *)(& retp));
  if (ret != 0) {
    return (ret);
  }
  mymap = bmp;
  i = 0U;
  while (i < nlockers) {
    if (! (idmap + i)->valid) {
      goto __Cont;
    } else {
      if ((idmap + i)->in_abort) {
        goto __Cont;
      }
    }
    j = 0U;
    while (j < nlockers) {
      if (! ((*(mymap + j / 32U)) & (unsigned int )(1 << j % 32U))) {
        goto __Cont___0;
      }
      tmpmap = bmp + nalloc * j;
      __i = 0U;
      while (__i < nalloc) {
        (*(mymap + __i)) = (*(mymap + __i)) | (*(tmpmap + __i));
        __i ++;
      }
      if (! ((*(mymap + i / 32U)) & (unsigned int )(1 << i % 32U))) {
        goto __Cont___0;
      }
      if (ndead + 2 >= ndeadalloc) {
        ndeadalloc <<= 1;
        tmp = __os_realloc(dbenv___0, (unsigned int )ndeadalloc * sizeof(u_int32_t ),
                           (void *)(& retp));
        if (tmp != 0) {
          (*(retp + ndead)) = (u_int32_t *)((void *)0);
          (*deadp) = retp;
          return (0);
        }
      }
      tmp___0 = ndead;
      ndead ++;
      (*(retp + tmp___0)) = mymap;
      k = 0U;
      while (k < nlockers) {
        if ((*(mymap + k / 32U)) & (unsigned int )(1 << k % 32U)) {
          (idmap + k)->valid = 0;
        }
        k ++;
      }
      break;
      __Cont___0: 
      j ++;
    }
    __Cont: 
    i ++;
    mymap += nalloc;
  }
  (*(retp + ndead)) = (u_int32_t *)((void *)0);
  (*deadp) = retp;
  return (0);
}
}
static int __dd_abort(DB_ENV *dbenv___0 , locker_info *info ) 
{ struct __db_lock *lockp ;
  DB_LOCKER *lockerp ;
  DB_LOCKOBJ *sh_obj ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  u_int32_t ndx ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  struct __db_lock *tmp___1 ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  tmp = __lock_locker_hash(info->last_locker_id);
  ndx = tmp % region->locker_t_size;
  ret = __lock_getlocker(lt, info->last_locker_id, ndx, 0, & lockerp);
  if (ret != 0) {
    goto _L;
  } else {
    if ((unsigned int )lockerp == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if (lockerp->flags & 4U) {
        _L: 
        if (ret == 0) {
          ret = -30899;
        }
        goto out;
      }
    }
  }
  if (lockerp->heldby.slh_first == -1) {
    lockp = (struct __db_lock *)((void *)0);
  } else {
    lockp = (struct __db_lock *)((u_int8_t *)(& lockerp->heldby) + lockerp->heldby.slh_first);
  }
  if ((unsigned int )lockp == (unsigned int )((void *)0)) {
    ret = -30899;
    goto out;
  }
  if ((unsigned int )((u_int8_t *)lockp - (u_int8_t *)lt->reginfo.addr) != info->last_lock) {
    ret = -30899;
    goto out;
  } else {
    if (lockp->holder != lockerp->id) {
      ret = -30899;
      goto out;
    } else {
      if (lockp->obj != info->last_obj) {
        ret = -30899;
        goto out;
      } else {
        if ((int )lockp->status != 8) {
          ret = -30899;
          goto out;
        }
      }
    }
  }
  sh_obj = (DB_LOCKOBJ *)((u_int8_t *)lockp + lockp->obj);
  tmp___0 = __lock_lhash(sh_obj);
  ndx = tmp___0 % region->object_t_size;
  lockp->status = (enum __anonenum_db_status_t_29 )1;
  while (1) {
    if (lockp->links.stqe_next != -1) {
      ((struct __db_lock *)((u_int8_t *)lockp + lockp->links.stqe_next))->links.stqe_prev = lockp->links.stqe_prev +
                                                                                            ((u_int8_t *)lockp -
                                                                                             (u_int8_t *)((struct __db_lock *)((u_int8_t *)lockp +
                                                                                                                               lockp->links.stqe_next)));
      (*((ssize_t *)((u_int8_t *)lockp + lockp->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)lockp +
                                                                                    lockp->links.stqe_prev))) +
                                                                     lockp->links.stqe_next;
    } else {
      sh_obj->waiters.stqh_last = lockp->links.stqe_prev + ((u_int8_t *)lockp - (u_int8_t *)(& sh_obj->waiters));
      (*((ssize_t *)((u_int8_t *)lockp + lockp->links.stqe_prev))) = -1;
    }
    break;
  }
  if (sh_obj->waiters.stqh_first == -1) {
    tmp___1 = (struct __db_lock *)((void *)0);
  } else {
    tmp___1 = (struct __db_lock *)((u_int8_t *)(& sh_obj->waiters) + sh_obj->waiters.stqh_first);
  }
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
    while (1) {
      if (sh_obj->dd_links.stqe_next != -1) {
        ((struct __db_lockobj *)((u_int8_t *)sh_obj + sh_obj->dd_links.stqe_next))->dd_links.stqe_prev = sh_obj->dd_links.stqe_prev +
                                                                                                         ((u_int8_t *)sh_obj -
                                                                                                          (u_int8_t *)((struct __db_lockobj *)((u_int8_t *)sh_obj +
                                                                                                                                               sh_obj->dd_links.stqe_next)));
        (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->dd_links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)sh_obj +
                                                                                           sh_obj->dd_links.stqe_prev))) +
                                                                            sh_obj->dd_links.stqe_next;
      } else {
        region->dd_objs.stqh_last = sh_obj->dd_links.stqe_prev + ((u_int8_t *)sh_obj -
                                                                  (u_int8_t *)(& region->dd_objs));
        (*((ssize_t *)((u_int8_t *)sh_obj + sh_obj->dd_links.stqe_prev))) = -1;
      }
      break;
    }
  } else {
    ret = __lock_promote(lt, sh_obj, 0U);
  }
  if (! (lockp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & lockp->mutex);
  }
  region->stat.st_ndeadlocks = region->stat.st_ndeadlocks + 1U;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (0);
  out: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static int __dd_verify(locker_info *idmap , u_int32_t *deadmap , u_int32_t *tmpmap ,
                       u_int32_t *origmap , u_int32_t nlockers , u_int32_t nalloc ,
                       u_int32_t which ) 
{ u_int32_t *tmap ;
  u_int32_t j ;
  int count ;
  u_int32_t __i ;

  {
  memset((void *)tmpmap, 0, sizeof(u_int32_t ) * nalloc);
  count = 0;
  j = 0U;
  while (j < nlockers) {
    if (! ((*(deadmap + j / 32U)) & (unsigned int )(1 << j % 32U))) {
      goto __Cont;
    } else {
      if (j == which) {
        goto __Cont;
      }
    }
    tmap = origmap + nalloc * j;
    if ((idmap + j)->self_wait) {
      (*(tmap + j / 32U)) = (*(tmap + j / 32U)) | (unsigned int )(1 << j % 32U);
    }
    __i = 0U;
    while (__i < nalloc) {
      (*(tmpmap + __i)) = (*(tmpmap + __i)) | (*(tmap + __i));
      __i ++;
    }
    count ++;
    __Cont: 
    j ++;
  }
  if (count == 1) {
    return (1);
  }
  j = 0U;
  while (j < nlockers) {
    if (! ((*(deadmap + j / 32U)) & (unsigned int )(1 << j % 32U))) {
      goto __Cont___0;
    } else {
      if (j == which) {
        goto __Cont___0;
      }
    }
    if (! ((*(tmpmap + j / 32U)) & (unsigned int )(1 << j % 32U))) {
      return (1);
    }
    __Cont___0: 
    j ++;
  }
  return (0);
}
}
static int __dd_isolder(u_int32_t a , u_int32_t b , u_int32_t lock_max , u_int32_t txn_max ) 
{ u_int32_t max ;

  {
  if (a <= 2147483647U) {
    if (b > 2147483647U) {
      return (1);
    }
  }
  if (b <= 2147483647U) {
    if (a > 2147483647U) {
      return (0);
    }
  }
  max = txn_max;
  if (a <= 2147483647U) {
    max = lock_max;
  }
  if (a > max) {
    if (b < max) {
      return (1);
    }
  }
  if (b > max) {
    if (a < max) {
      return (0);
    }
  }
  return (a < b);
}
}
#pragma merger(0,"/tmp/cil-jWPTLhX2.i","-O2")
int __lock_stat_pp(DB_ENV *dbenv___0 , DB_LOCK_STAT **statp , u_int32_t flags ) ;
int __lock_dump_region(DB_ENV *dbenv___0 , char const   *area , FILE *fp ) ;
static int __lock_get_lk_conflicts(DB_ENV *dbenv___0 , u_int8_t const   **lk_conflictsp ,
                                   int *lk_modesp ) ;
static int __lock_set_lk_conflicts(DB_ENV *dbenv___0 , u_int8_t *lk_conflicts , int lk_modes ) ;
static int __lock_get_lk_detect(DB_ENV *dbenv___0 , u_int32_t *lk_detectp ) ;
static int __lock_get_lk_max_lockers(DB_ENV *dbenv___0 , u_int32_t *lk_maxp ) ;
static int __lock_get_lk_max_locks(DB_ENV *dbenv___0 , u_int32_t *lk_maxp ) ;
static int __lock_get_lk_max_objects(DB_ENV *dbenv___0 , u_int32_t *lk_maxp ) ;
static int __lock_get_env_timeout(DB_ENV *dbenv___0 , db_timeout_t *timeoutp , u_int32_t flag ) ;
void __lock_dbenv_create(DB_ENV *dbenv___0 ) 
{ 

  {
  dbenv___0->lk_max = 1000U;
  dbenv___0->lk_max_lockers = 1000U;
  dbenv___0->lk_max_objects = 1000U;
  dbenv___0->get_lk_conflicts = & __lock_get_lk_conflicts;
  dbenv___0->set_lk_conflicts = & __lock_set_lk_conflicts;
  dbenv___0->get_lk_detect = & __lock_get_lk_detect;
  dbenv___0->set_lk_detect = & __lock_set_lk_detect;
  dbenv___0->set_lk_max = & __lock_set_lk_max;
  dbenv___0->get_lk_max_lockers = & __lock_get_lk_max_lockers;
  dbenv___0->set_lk_max_lockers = & __lock_set_lk_max_lockers;
  dbenv___0->get_lk_max_locks = & __lock_get_lk_max_locks;
  dbenv___0->set_lk_max_locks = & __lock_set_lk_max_locks;
  dbenv___0->get_lk_max_objects = & __lock_get_lk_max_objects;
  dbenv___0->set_lk_max_objects = & __lock_set_lk_max_objects;
  dbenv___0->get_timeout = & __lock_get_env_timeout;
  dbenv___0->set_timeout = & __lock_set_env_timeout;
  dbenv___0->lock_detect = & __lock_detect_pp;
  dbenv___0->lock_dump_region = & __lock_dump_region;
  dbenv___0->lock_get = & __lock_get_pp;
  dbenv___0->lock_id = & __lock_id_pp;
  dbenv___0->lock_id_free = & __lock_id_free_pp;
  dbenv___0->lock_put = & __lock_put_pp;
  dbenv___0->lock_stat = & __lock_stat_pp;
  dbenv___0->lock_vec = & __lock_vec_pp;
  return;
}
}
void __lock_dbenv_close(DB_ENV *dbenv___0 ) 
{ 

  {
  if ((unsigned int )dbenv___0->lk_conflicts != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->lk_conflicts);
    dbenv___0->lk_conflicts = (u_int8_t *)((void *)0);
  }
  return;
}
}
static int __lock_get_lk_conflicts(DB_ENV *dbenv___0 , u_int8_t const   **lk_conflictsp ,
                                   int *lk_modesp ) 
{ 

  {
  if ((unsigned int )lk_conflictsp != (unsigned int )((void *)0)) {
    (*lk_conflictsp) = (u_int8_t const   *)dbenv___0->lk_conflicts;
  }
  if ((unsigned int )lk_modesp != (unsigned int )((void *)0)) {
    (*lk_modesp) = (int )dbenv___0->lk_modes;
  }
  return (0);
}
}
static int __lock_set_lk_conflicts(DB_ENV *dbenv___0 , u_int8_t *lk_conflicts , int lk_modes ) 
{ int ret ;
  int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lk_conflicts", 1);
    return (tmp);
  }
  if ((unsigned int )dbenv___0->lk_conflicts != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->lk_conflicts);
    dbenv___0->lk_conflicts = (u_int8_t *)((void *)0);
  }
  ret = __os_malloc(dbenv___0, (unsigned int )(lk_modes * lk_modes), (void *)(& dbenv___0->lk_conflicts));
  if (ret != 0) {
    return (ret);
  }
  memcpy((void * __restrict  )dbenv___0->lk_conflicts, (void const   * __restrict  )lk_conflicts,
         (unsigned int )(lk_modes * lk_modes));
  dbenv___0->lk_modes = (unsigned int )lk_modes;
  return (0);
}
}
static int __lock_get_lk_detect(DB_ENV *dbenv___0 , u_int32_t *lk_detectp ) 
{ 

  {
  (*lk_detectp) = dbenv___0->lk_detect;
  return (0);
}
}
int __lock_set_lk_detect(DB_ENV *dbenv___0 , u_int32_t lk_detect ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lk_detect", 1);
    return (tmp);
  }
  switch ((int )lk_detect) {
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 7: ;
  case 8: ;
  break;
  default: 
  __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->set_lk_detect: unknown deadlock detection mode specified");
  return (22);
  }
  dbenv___0->lk_detect = lk_detect;
  return (0);
}
}
int __lock_set_lk_max(DB_ENV *dbenv___0 , u_int32_t lk_max ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lk_max", 1);
    return (tmp);
  }
  dbenv___0->lk_max = lk_max;
  dbenv___0->lk_max_objects = lk_max;
  dbenv___0->lk_max_lockers = lk_max;
  return (0);
}
}
static int __lock_get_lk_max_locks(DB_ENV *dbenv___0 , u_int32_t *lk_maxp ) 
{ 

  {
  (*lk_maxp) = dbenv___0->lk_max;
  return (0);
}
}
int __lock_set_lk_max_locks(DB_ENV *dbenv___0 , u_int32_t lk_max ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lk_max_locks", 1);
    return (tmp);
  }
  dbenv___0->lk_max = lk_max;
  return (0);
}
}
static int __lock_get_lk_max_lockers(DB_ENV *dbenv___0 , u_int32_t *lk_maxp ) 
{ 

  {
  (*lk_maxp) = dbenv___0->lk_max_lockers;
  return (0);
}
}
int __lock_set_lk_max_lockers(DB_ENV *dbenv___0 , u_int32_t lk_max ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lk_max_lockers", 1);
    return (tmp);
  }
  dbenv___0->lk_max_lockers = lk_max;
  return (0);
}
}
static int __lock_get_lk_max_objects(DB_ENV *dbenv___0 , u_int32_t *lk_maxp ) 
{ 

  {
  (*lk_maxp) = dbenv___0->lk_max_objects;
  return (0);
}
}
int __lock_set_lk_max_objects(DB_ENV *dbenv___0 , u_int32_t lk_max ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lk_max_objects", 1);
    return (tmp);
  }
  dbenv___0->lk_max_objects = lk_max;
  return (0);
}
}
static int __lock_get_env_timeout(DB_ENV *dbenv___0 , db_timeout_t *timeoutp , u_int32_t flag ) 
{ int tmp ;

  {
  switch ((int )flag) {
  case 29: 
  (*timeoutp) = dbenv___0->lk_timeout;
  break;
  case 33: 
  (*timeoutp) = dbenv___0->tx_timeout;
  break;
  default: 
  tmp = __db_ferr((DB_ENV const   *)dbenv___0, "DB_ENV->get_timeout", 0);
  return (tmp);
  }
  return (0);
}
}
int __lock_set_env_timeout(DB_ENV *dbenv___0 , db_timeout_t timeout , u_int32_t flags ) 
{ DB_LOCKREGION *region ;
  int tmp ;
  int tmp___0 ;

  {
  region = (DB_LOCKREGION *)((void *)0);
  if (dbenv___0->flags & 8192U) {
    if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
      tmp = __db_env_config(dbenv___0, (char *)"set_timeout", 8192U);
      return (tmp);
    }
    region = (DB_LOCKREGION *)((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.primary;
  }
  switch ((int )flags) {
  case 29: 
  dbenv___0->lk_timeout = timeout;
  if ((unsigned int )region != (unsigned int )((void *)0)) {
    region->lk_timeout = timeout;
  }
  break;
  case 33: 
  dbenv___0->tx_timeout = timeout;
  if ((unsigned int )region != (unsigned int )((void *)0)) {
    region->tx_timeout = timeout;
  }
  break;
  default: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB_ENV->set_timeout", 0);
  return (tmp___0);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-iWR02vNj.i","-O2")
int __lock_id_set(DB_ENV *dbenv___0 , u_int32_t cur_id , u_int32_t max_id ) ;
static int __lock_init(DB_ENV *dbenv___0 , DB_LOCKTAB *lt ) ;
static size_t __lock_region_size(DB_ENV *dbenv___0 ) ;
static u_int8_t const   db_riw_conflicts[81]  = 
  {      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)1};
static u_int8_t const   db_cdb_conflicts[25]  = 
  {      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1, 
        (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)0,      (u_int8_t const   )(unsigned char)1,      (u_int8_t const   )(unsigned char)0, 
        (u_int8_t const   )(unsigned char)1};
int __lock_open(DB_ENV *dbenv___0 ) 
{ DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  size_t size ;
  int ret ;

  {
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_LOCKTAB ), (void *)(& lt));
  if (ret != 0) {
    return (ret);
  }
  lt->dbenv = dbenv___0;
  lt->reginfo.type = (enum __anonenum_reg_type_50 )2;
  lt->reginfo.id = 0U;
  lt->reginfo.mode = dbenv___0->db_mode;
  lt->reginfo.flags = 4U;
  if (dbenv___0->flags & 8U) {
    lt->reginfo.flags = lt->reginfo.flags | 2U;
  }
  size = __lock_region_size(dbenv___0);
  ret = __db_r_attach(dbenv___0, & lt->reginfo, size);
  if (ret != 0) {
    goto err;
  }
  if (lt->reginfo.flags & 1U) {
    ret = __lock_init(dbenv___0, lt);
    if (ret != 0) {
      goto err;
    }
  }
  lt->reginfo.primary = (void *)((u_int8_t *)lt->reginfo.addr + (lt->reginfo.rp)->primary);
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (dbenv___0->lk_detect != 0U) {
    if (region->detect != 0U) {
      if (dbenv___0->lk_detect != 1U) {
        if (region->detect != dbenv___0->lk_detect) {
          __db_err((DB_ENV const   *)dbenv___0, "lock_open: incompatible deadlock detector mode");
          ret = 22;
          goto err;
        }
      }
    }
    if (region->detect == 0U) {
      region->detect = dbenv___0->lk_detect;
    }
  }
  if (dbenv___0->lk_timeout != 0U) {
    region->lk_timeout = dbenv___0->lk_timeout;
  }
  if (dbenv___0->tx_timeout != 0U) {
    region->tx_timeout = dbenv___0->tx_timeout;
  }
  lt->conflicts = (u_int8_t *)((void *)((u_int8_t *)lt->reginfo.addr + region->conf_off));
  lt->obj_tab = (DB_HASHTAB *)((void *)((u_int8_t *)lt->reginfo.addr + region->obj_off));
  lt->locker_tab = (DB_HASHTAB *)((void *)((u_int8_t *)lt->reginfo.addr + region->locker_off));
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  dbenv___0->lk_handle = (void *)lt;
  return (0);
  err: 
  if ((unsigned int )lt->reginfo.addr != (unsigned int )((void *)0)) {
    if (lt->reginfo.flags & 1U) {
      ret = __db_panic(dbenv___0, ret);
    }
    if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
    }
    __db_r_detach(dbenv___0, & lt->reginfo, 0);
  }
  __os_free(dbenv___0, (void *)lt);
  return (ret);
}
}
static int __lock_init(DB_ENV *dbenv___0 , DB_LOCKTAB *lt ) 
{ u_int8_t const   *lk_conflicts ;
  struct __db_lock *lp ;
  DB_LOCKER *lidp ;
  DB_LOCKOBJ *op ;
  DB_LOCKREGION *region ;
  u_int32_t i ;
  u_int32_t lk_modes ;
  u_int8_t *addr ;
  int ret ;

  {
  ret = __db_shalloc(lt->reginfo.addr, sizeof(DB_LOCKREGION ), 0U, (void *)(& lt->reginfo.primary));
  if (ret != 0) {
    goto mem_err;
  }
  (lt->reginfo.rp)->primary = (unsigned int )((u_int8_t *)lt->reginfo.primary - (u_int8_t *)lt->reginfo.addr);
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  memset((void *)region, 0, sizeof((*region)));
  if (dbenv___0->lk_modes == 0U) {
    if (dbenv___0->flags & 2U) {
      lk_modes = 5U;
      lk_conflicts = db_cdb_conflicts;
    } else {
      lk_modes = 9U;
      lk_conflicts = db_riw_conflicts;
    }
  } else {
    lk_modes = dbenv___0->lk_modes;
    lk_conflicts = (u_int8_t const   *)dbenv___0->lk_conflicts;
  }
  region->need_dd = 0U;
  region->next_timeout.tv_sec = 0U;
  region->detect = 0U;
  region->lk_timeout = dbenv___0->lk_timeout;
  region->tx_timeout = dbenv___0->tx_timeout;
  region->locker_t_size = (u_int32_t )__db_tablesize(dbenv___0->lk_max_lockers);
  region->object_t_size = (u_int32_t )__db_tablesize(dbenv___0->lk_max_objects);
  memset((void *)(& region->stat), 0, sizeof(region->stat));
  region->stat.st_id = 0U;
  region->stat.st_cur_maxid = 2147483647U;
  region->stat.st_maxlocks = dbenv___0->lk_max;
  region->stat.st_maxlockers = dbenv___0->lk_max_lockers;
  region->stat.st_maxobjects = dbenv___0->lk_max_objects;
  region->stat.st_nmodes = lk_modes;
  ret = __db_shalloc(lt->reginfo.addr, lk_modes * lk_modes, 0U, (void *)(& addr));
  if (ret != 0) {
    goto mem_err;
  }
  memcpy((void * __restrict  )addr, (void const   * __restrict  )lk_conflicts, lk_modes *
                                                                               lk_modes);
  region->conf_off = (unsigned int )(addr - (u_int8_t *)lt->reginfo.addr);
  ret = __db_shalloc(lt->reginfo.addr, region->object_t_size * sizeof(DB_HASHTAB ),
                     0U, (void *)(& addr));
  if (ret != 0) {
    goto mem_err;
  }
  __db_hashinit((void *)addr, region->object_t_size);
  region->obj_off = (unsigned int )(addr - (u_int8_t *)lt->reginfo.addr);
  ret = __db_shalloc(lt->reginfo.addr, region->locker_t_size * sizeof(DB_HASHTAB ),
                     0U, (void *)(& addr));
  if (ret != 0) {
    goto mem_err;
  }
  __db_hashinit((void *)addr, region->locker_t_size);
  region->locker_off = (unsigned int )(addr - (u_int8_t *)lt->reginfo.addr);
  region->free_locks.stqh_first = -1;
  region->free_locks.stqh_last = (u_int8_t *)(& region->free_locks.stqh_first) - (u_int8_t *)(& region->free_locks);
  i = 0U;
  while (i < region->stat.st_maxlocks) {
    ret = __db_shalloc(lt->reginfo.addr, sizeof(struct __db_lock ), 1U, (void *)(& lp));
    if (ret != 0) {
      goto mem_err;
    }
    lp->status = (enum __anonenum_db_status_t_29 )4;
    lp->gen = 0U;
    ret = __db_mutex_setup(dbenv___0, & lt->reginfo, (void *)(& lp->mutex), 200U);
    if (ret != 0) {
      return (ret);
    }
    if (! (lp->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & lp->mutex);
    }
    while (1) {
      if (region->free_locks.stqh_first != -1) {
        lp->links.stqe_next = region->free_locks.stqh_first - ((u_int8_t *)lp - (u_int8_t *)(& region->free_locks));
        if (lp->links.stqe_next == -1) {
          ((struct __db_lock *)((u_int8_t *)(& region->free_locks) + region->free_locks.stqh_first))->links.stqe_prev = 0;
        } else {
          ((struct __db_lock *)((u_int8_t *)(& region->free_locks) + region->free_locks.stqh_first))->links.stqe_prev = - lp->links.stqe_next +
                                                                                                                        ((u_int8_t *)(& lp->links.stqe_next) -
                                                                                                                         (u_int8_t *)lp);
        }
      } else {
        region->free_locks.stqh_last = (u_int8_t *)(& lp->links.stqe_next) - (u_int8_t *)(& region->free_locks);
        lp->links.stqe_next = -1;
      }
      region->free_locks.stqh_first = (u_int8_t *)lp - (u_int8_t *)(& region->free_locks);
      lp->links.stqe_prev = (u_int8_t *)(& region->free_locks.stqh_first) - (u_int8_t *)lp;
      break;
    }
    i ++;
  }
  region->dd_objs.stqh_first = -1;
  region->dd_objs.stqh_last = (u_int8_t *)(& region->dd_objs.stqh_first) - (u_int8_t *)(& region->dd_objs);
  region->free_objs.stqh_first = -1;
  region->free_objs.stqh_last = (u_int8_t *)(& region->free_objs.stqh_first) - (u_int8_t *)(& region->free_objs);
  i = 0U;
  while (i < region->stat.st_maxobjects) {
    ret = __db_shalloc(lt->reginfo.addr, sizeof(DB_LOCKOBJ ), 0U, (void *)(& op));
    if (ret != 0) {
      goto mem_err;
    }
    while (1) {
      if (region->free_objs.stqh_first != -1) {
        op->links.stqe_next = region->free_objs.stqh_first - ((u_int8_t *)op - (u_int8_t *)(& region->free_objs));
        if (op->links.stqe_next == -1) {
          ((struct __db_lockobj *)((u_int8_t *)(& region->free_objs) + region->free_objs.stqh_first))->links.stqe_prev = 0;
        } else {
          ((struct __db_lockobj *)((u_int8_t *)(& region->free_objs) + region->free_objs.stqh_first))->links.stqe_prev = - op->links.stqe_next +
                                                                                                                         ((u_int8_t *)(& op->links.stqe_next) -
                                                                                                                          (u_int8_t *)op);
        }
      } else {
        region->free_objs.stqh_last = (u_int8_t *)(& op->links.stqe_next) - (u_int8_t *)(& region->free_objs);
        op->links.stqe_next = -1;
      }
      region->free_objs.stqh_first = (u_int8_t *)op - (u_int8_t *)(& region->free_objs);
      op->links.stqe_prev = (u_int8_t *)(& region->free_objs.stqh_first) - (u_int8_t *)op;
      break;
    }
    i ++;
  }
  region->lockers.stqh_first = -1;
  region->lockers.stqh_last = (u_int8_t *)(& region->lockers.stqh_first) - (u_int8_t *)(& region->lockers);
  region->free_lockers.stqh_first = -1;
  region->free_lockers.stqh_last = (u_int8_t *)(& region->free_lockers.stqh_first) -
                                   (u_int8_t *)(& region->free_lockers);
  i = 0U;
  while (i < region->stat.st_maxlockers) {
    ret = __db_shalloc(lt->reginfo.addr, sizeof(DB_LOCKER ), 0U, (void *)(& lidp));
    if (ret != 0) {
      mem_err: 
      __db_err((DB_ENV const   *)dbenv___0, "Unable to allocate memory for the lock table");
      return (ret);
    }
    while (1) {
      if (region->free_lockers.stqh_first != -1) {
        lidp->links.stqe_next = region->free_lockers.stqh_first - ((u_int8_t *)lidp -
                                                                   (u_int8_t *)(& region->free_lockers));
        if (lidp->links.stqe_next == -1) {
          ((struct __db_locker *)((u_int8_t *)(& region->free_lockers) + region->free_lockers.stqh_first))->links.stqe_prev = 0;
        } else {
          ((struct __db_locker *)((u_int8_t *)(& region->free_lockers) + region->free_lockers.stqh_first))->links.stqe_prev = - lidp->links.stqe_next +
                                                                                                                              ((u_int8_t *)(& lidp->links.stqe_next) -
                                                                                                                               (u_int8_t *)lidp);
        }
      } else {
        region->free_lockers.stqh_last = (u_int8_t *)(& lidp->links.stqe_next) - (u_int8_t *)(& region->free_lockers);
        lidp->links.stqe_next = -1;
      }
      region->free_lockers.stqh_first = (u_int8_t *)lidp - (u_int8_t *)(& region->free_lockers);
      lidp->links.stqe_prev = (u_int8_t *)(& region->free_lockers.stqh_first) - (u_int8_t *)lidp;
      break;
    }
    i ++;
  }
  return (0);
}
}
int __lock_dbenv_refresh(DB_ENV *dbenv___0 ) 
{ DB_LOCKTAB *lt ;
  int ret ;

  {
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  ret = __db_r_detach(dbenv___0, & lt->reginfo, 0);
  __os_free(dbenv___0, (void *)lt);
  dbenv___0->lk_handle = (void *)0;
  return (ret);
}
}
static size_t __lock_region_size(DB_ENV *dbenv___0 ) 
{ size_t retval___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  retval___0 = 0U;
  tmp = __db_shalloc_size(sizeof(DB_LOCKREGION ), 1U);
  retval___0 += (unsigned int )tmp;
  tmp___0 = __db_shalloc_size(dbenv___0->lk_modes * dbenv___0->lk_modes, 1U);
  retval___0 += (unsigned int )tmp___0;
  tmp___1 = __db_tablesize(dbenv___0->lk_max_lockers);
  tmp___2 = __db_shalloc_size((unsigned int )tmp___1 * sizeof(DB_HASHTAB ), 1U);
  retval___0 += (unsigned int )tmp___2;
  tmp___3 = __db_tablesize(dbenv___0->lk_max_objects);
  tmp___4 = __db_shalloc_size((unsigned int )tmp___3 * sizeof(DB_HASHTAB ), 1U);
  retval___0 += (unsigned int )tmp___4;
  tmp___5 = __db_shalloc_size(sizeof(struct __db_lock ), 1U);
  retval___0 += (unsigned int )tmp___5 * dbenv___0->lk_max;
  tmp___6 = __db_shalloc_size(sizeof(DB_LOCKOBJ ), 1U);
  retval___0 += (unsigned int )tmp___6 * dbenv___0->lk_max_objects;
  tmp___7 = __db_shalloc_size(sizeof(DB_LOCKER ), 1U);
  retval___0 += (unsigned int )tmp___7 * dbenv___0->lk_max_lockers;
  tmp___8 = __db_shalloc_size(dbenv___0->lk_max * 16U, sizeof(size_t ));
  retval___0 += (unsigned int )tmp___8;
  retval___0 += retval___0 / 4U;
  return (retval___0);
}
}
void __lock_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  return;
}
}
int __lock_id_set(DB_ENV *dbenv___0 , u_int32_t cur_id , u_int32_t max_id ) 
{ DB_LOCKTAB *lt ;
  DB_LOCKREGION *region ;
  int tmp ;

  {
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp = __db_env_config(dbenv___0, (char *)"lock_id_set", 8192U);
    return (tmp);
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  region->stat.st_id = cur_id;
  region->stat.st_cur_maxid = max_id;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-EsNWDzyC.i","-O2")
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
void __lock_printlock(DB_LOCKTAB *lt , struct __db_lock *lp , int ispgno , FILE *fp ) ;
static void __lock_dump_locker(DB_LOCKTAB *lt , DB_LOCKER *lip , FILE *fp ) ;
static void __lock_dump_object(DB_LOCKTAB *lt , DB_LOCKOBJ *op , FILE *fp ) ;
static void __lock_printheader(FILE *fp ) ;
static int __lock_stat(DB_ENV *dbenv___0 , DB_LOCK_STAT **statp , u_int32_t flags ) ;
int __lock_stat_pp(DB_ENV *dbenv___0 , DB_LOCK_STAT **statp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->lock_stat", 8192U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->lock_stat", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __lock_stat(dbenv___0, statp, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __lock_stat(DB_ENV *dbenv___0 , DB_LOCK_STAT **statp , u_int32_t flags ) 
{ DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  DB_LOCK_STAT *stats___0 ;
  DB_LOCK_STAT tmp ;
  int ret ;

  {
  (*statp) = (DB_LOCK_STAT *)((void *)0);
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  ret = __os_umalloc(dbenv___0, sizeof((*stats___0)), (void *)(& stats___0));
  if (ret != 0) {
    return (ret);
  }
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  memcpy((void * __restrict  )stats___0, (void const   * __restrict  )(& region->stat),
         sizeof((*stats___0)));
  stats___0->st_locktimeout = region->lk_timeout;
  stats___0->st_txntimeout = region->tx_timeout;
  stats___0->st_region_wait = (lt->reginfo.rp)->mutex.mutex_set_wait;
  stats___0->st_region_nowait = (lt->reginfo.rp)->mutex.mutex_set_nowait;
  stats___0->st_regsize = (lt->reginfo.rp)->size;
  if (flags & 1U) {
    tmp = region->stat;
    memset((void *)(& region->stat), 0, sizeof(region->stat));
    (lt->reginfo.rp)->mutex.mutex_set_wait = 0U;
    (lt->reginfo.rp)->mutex.mutex_set_nowait = 0U;
    region->stat.st_id = tmp.st_id;
    region->stat.st_cur_maxid = tmp.st_cur_maxid;
    region->stat.st_maxlocks = tmp.st_maxlocks;
    region->stat.st_maxlockers = tmp.st_maxlockers;
    region->stat.st_maxobjects = tmp.st_maxobjects;
    region->stat.st_maxnlocks = tmp.st_nlocks;
    region->stat.st_nlocks = region->stat.st_maxnlocks;
    region->stat.st_maxnlockers = tmp.st_nlockers;
    region->stat.st_nlockers = region->stat.st_maxnlockers;
    region->stat.st_maxnobjects = tmp.st_nobjects;
    region->stat.st_nobjects = region->stat.st_maxnobjects;
    region->stat.st_nmodes = tmp.st_nmodes;
  }
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  (*statp) = stats___0;
  return (0);
}
}
int __lock_dump_region(DB_ENV *dbenv___0 , char const   *area , FILE *fp ) 
{ DB_LOCKER *lip ;
  DB_LOCKOBJ *op ;
  DB_LOCKREGION *lrp ;
  DB_LOCKTAB *lt ;
  u_int32_t flags ;
  u_int32_t i ;
  u_int32_t j ;
  char buf[64] ;
  int tmp ;
  int tmp___0 ;
  struct tm  const  * __restrict  tmp___1 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lk_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"lock_dump_region", 8192U);
    return (tmp___0);
  }
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    fp = stderr;
  }
  flags = 0U;
  while ((int const   )(*area) != 0) {
    switch ((int )(*area)) {
    case 65: 
    flags |= 31U;
    break;
    case 99: 
    flags |= 1U;
    break;
    case 108: 
    flags |= 2U;
    break;
    case 109: 
    flags |= 4U;
    break;
    case 111: 
    flags |= 8U;
    break;
    case 112: 
    flags |= 16U;
    break;
    }
    area ++;
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  lrp = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  if (flags & 16U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nLock region parameters\n",
            "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s: %lu, %s: %lu, %s: %lu,\n%s: %lu, %s: %lu, %s: %lu, %s: %lu\n",
            "locker table size", (unsigned long )lrp->locker_t_size, "object table size",
            (unsigned long )lrp->object_t_size, "obj_off", (unsigned long )lrp->obj_off,
            "osynch_off", (unsigned long )lrp->osynch_off, "locker_off", (unsigned long )lrp->locker_off,
            "lsynch_off", (unsigned long )lrp->lsynch_off, "need_dd", (unsigned long )lrp->need_dd);
    if (lrp->next_timeout.tv_sec != 0U) {
      tmp___1 = localtime((time_t const   *)((time_t *)(& lrp->next_timeout.tv_sec)));
      strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%m-%d-%H:%M:%S",
               tmp___1);
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"next_timeout: %s.%lu\n",
              buf, (unsigned long )lrp->next_timeout.tv_usec);
    }
  }
  if (flags & 1U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n%s\nConflict matrix\n",
            "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    i = 0U;
    while (i < lrp->stat.st_nmodes) {
      j = 0U;
      while (j < lrp->stat.st_nmodes) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%lu\t", (unsigned long )(*(lt->conflicts +
                                                                                                  (i *
                                                                                                   lrp->stat.st_nmodes +
                                                                                                   j))));
        j ++;
      }
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
      i ++;
    }
  }
  if (flags & 2U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nLocks grouped by lockers\n",
            "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    __lock_printheader(fp);
    i = 0U;
    while (i < lrp->locker_t_size) {
      if ((lt->locker_tab + i)->stqh_first == -1) {
        lip = (DB_LOCKER *)((void *)0);
      } else {
        lip = (struct __db_locker *)((u_int8_t *)(lt->locker_tab + i) + (lt->locker_tab +
                                                                         i)->stqh_first);
      }
      while ((unsigned int )lip != (unsigned int )((void *)0)) {
        __lock_dump_locker(lt, lip, fp);
        if (lip->links.stqe_next == -1) {
          lip = (DB_LOCKER *)((void *)0);
        } else {
          lip = (struct __db_locker *)((u_int8_t *)lip + lip->links.stqe_next);
        }
      }
      i ++;
    }
  }
  if (flags & 8U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nLocks grouped by object\n",
            "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    __lock_printheader(fp);
    i = 0U;
    while (i < lrp->object_t_size) {
      if ((lt->obj_tab + i)->stqh_first == -1) {
        op = (DB_LOCKOBJ *)((void *)0);
      } else {
        op = (struct __db_lockobj *)((u_int8_t *)(lt->obj_tab + i) + (lt->obj_tab +
                                                                      i)->stqh_first);
      }
      while ((unsigned int )op != (unsigned int )((void *)0)) {
        __lock_dump_object(lt, op, fp);
        if (op->links.stqe_next == -1) {
          op = (DB_LOCKOBJ *)((void *)0);
        } else {
          op = (struct __db_lockobj *)((u_int8_t *)op + op->links.stqe_next);
        }
      }
      i ++;
    }
  }
  if (flags & 4U) {
    __db_shalloc_dump(lt->reginfo.addr, fp);
  }
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (0);
}
}
static void __lock_dump_locker(DB_LOCKTAB *lt , DB_LOCKER *lip , FILE *fp ) 
{ struct __db_lock *lp ;
  time_t s ;
  char buf[64] ;
  char const   *tmp ;
  struct tm  const  * __restrict  tmp___0 ;
  struct tm  const  * __restrict  tmp___1 ;

  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%8lx dd=%2ld locks held %-4d write locks %-4d",
          (unsigned long )lip->id, (long )lip->dd_id, lip->nlocks, lip->nwrites);
  if (lip->flags & 1U) {
    tmp = "(D)";
  } else {
    tmp = "   ";
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", tmp);
  if (lip->tx_expire.tv_sec != 0U) {
    s = (long )lip->tx_expire.tv_sec;
    tmp___0 = localtime((time_t const   *)(& s));
    strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%m-%d-%H:%M:%S",
             tmp___0);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"expires %s.%lu",
            buf, (unsigned long )lip->tx_expire.tv_usec);
  }
  if (lip->flags & 8U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" lk timeout %u",
            lip->lk_timeout);
  }
  if (lip->lk_expire.tv_sec != 0U) {
    s = (long )lip->lk_expire.tv_sec;
    tmp___1 = localtime((time_t const   *)(& s));
    strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%m-%d-%H:%M:%S",
             tmp___1);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" lk expires %s.%lu",
            buf, (unsigned long )lip->lk_expire.tv_usec);
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  if (lip->heldby.slh_first == -1) {
    lp = (struct __db_lock *)((void *)0);
  } else {
    lp = (struct __db_lock *)((u_int8_t *)(& lip->heldby) + lip->heldby.slh_first);
  }
  if ((unsigned int )lp != (unsigned int )((void *)0)) {
    while ((unsigned int )lp != (unsigned int )((void *)0)) {
      __lock_printlock(lt, lp, 1, fp);
      if (lp->locker_links.sle_next == -1) {
        lp = (struct __db_lock *)((void *)0);
      } else {
        lp = (struct __db_lock *)((u_int8_t *)lp + lp->locker_links.sle_next);
      }
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
  return;
}
}
static void __lock_dump_object(DB_LOCKTAB *lt , DB_LOCKOBJ *op , FILE *fp ) 
{ struct __db_lock *lp ;

  {
  if (op->holders.stqh_first == -1) {
    lp = (struct __db_lock *)((void *)0);
  } else {
    lp = (struct __db_lock *)((u_int8_t *)(& op->holders) + op->holders.stqh_first);
  }
  while ((unsigned int )lp != (unsigned int )((void *)0)) {
    __lock_printlock(lt, lp, 1, fp);
    if (lp->links.stqe_next == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
    }
  }
  if (op->waiters.stqh_first == -1) {
    lp = (struct __db_lock *)((void *)0);
  } else {
    lp = (struct __db_lock *)((u_int8_t *)(& op->waiters) + op->waiters.stqh_first);
  }
  while ((unsigned int )lp != (unsigned int )((void *)0)) {
    __lock_printlock(lt, lp, 1, fp);
    if (lp->links.stqe_next == -1) {
      lp = (struct __db_lock *)((void *)0);
    } else {
      lp = (struct __db_lock *)((u_int8_t *)lp + lp->links.stqe_next);
    }
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  return;
}
}
static void __lock_printheader(FILE *fp ) 
{ 

  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-8s %-10s%-4s %-7s %s\n",
          "Locker", "Mode", "Count", "Status", "----------------- Object ---------------");
  return;
}
}
void __lock_printlock(DB_LOCKTAB *lt , struct __db_lock *lp , int ispgno , FILE *fp ) 
{ DB_LOCKOBJ *lockobj ;
  db_pgno_t pgno ;
  u_int32_t *fidp ;
  u_int32_t type ;
  u_int8_t *ptr ;
  char *namep ;
  char const   *mode ;
  char const   *status ;
  int tmp ;
  char const   *tmp___1 ;

  {
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    fp = stderr;
  }
  switch ((int )lp->mode) {
  case 7: 
  mode = "DIRTY_READ";
  break;
  case 5: 
  mode = "IREAD";
  break;
  case 6: 
  mode = "IWR";
  break;
  case 4: 
  mode = "IWRITE";
  break;
  case 0: 
  mode = "NG";
  break;
  case 1: 
  mode = "READ";
  break;
  case 2: 
  mode = "WRITE";
  break;
  case 8: 
  mode = "WAS_WRITE";
  break;
  case 3: 
  mode = "WAIT";
  break;
  default: 
  mode = "UNKNOWN";
  break;
  }
  switch ((int )lp->status) {
  case 1: 
  status = "ABORT";
  break;
  case 2: 
  status = "ERROR";
  break;
  case 4: 
  status = "FREE";
  break;
  case 5: 
  status = "HELD";
  break;
  case 8: 
  status = "WAIT";
  break;
  case 7: 
  status = "PENDING";
  break;
  case 3: 
  status = "EXPIRED";
  break;
  default: 
  status = "UNKNOWN";
  break;
  }
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%8lx %-10s %4lu %-7s ",
          (unsigned long )lp->holder, mode, (unsigned long )lp->refcount, status);
  lockobj = (DB_LOCKOBJ *)((u_int8_t *)lp + lp->obj);
  ptr = (u_int8_t *)((void *)((u_int8_t *)(& lockobj->lockobj) + lockobj->lockobj.off));
  if (ispgno) {
    if (lockobj->lockobj.size == sizeof(struct __db_ilock )) {
      memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )ptr, sizeof(db_pgno_t ));
      fidp = (u_int32_t *)(ptr + sizeof(db_pgno_t ));
      type = (*((u_int32_t *)((ptr + sizeof(db_pgno_t )) + 20)));
      tmp = __dbreg_get_name(lt->dbenv, (u_int8_t *)fidp, & namep);
      if (tmp != 0) {
        namep = (char *)((void *)0);
      }
      if ((unsigned int )namep == (unsigned int )((void *)0)) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"(%lx %lx %lx %lx %lx)",
                (unsigned long )(*(fidp + 0)), (unsigned long )(*(fidp + 1)), (unsigned long )(*(fidp +
                                                                                                 2)),
                (unsigned long )(*(fidp + 3)), (unsigned long )(*(fidp + 4)));
      } else {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-25s", namep);
      }
      if (type == 3U) {
        tmp___1 = "page";
      } else {
        if (type == 2U) {
          tmp___1 = "record";
        } else {
          tmp___1 = "handle";
        }
      }
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%-7s %7lu\n",
              tmp___1, (unsigned long )pgno);
    } else {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"0x%lx ", (unsigned long )((unsigned int )((u_int8_t *)lockobj -
                                                                                                               (u_int8_t *)lt->reginfo.addr)));
      __db_pr(ptr, lockobj->lockobj.size, fp);
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
  } else {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"0x%lx ", (unsigned long )((unsigned int )((u_int8_t *)lockobj -
                                                                                                             (u_int8_t *)lt->reginfo.addr)));
    __db_pr(ptr, lockobj->lockobj.size, fp);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
}
}
#pragma merger(0,"/tmp/cil-hkUbxAVT.i","-O2")
int __lock_cmp(DBT const   *dbt , DB_LOCKOBJ *lock_obj ) 
{ void *obj_data ;
  int tmp ;
  int tmp___0 ;

  {
  obj_data = (void *)((u_int8_t *)(& lock_obj->lockobj) + lock_obj->lockobj.off);
  if (dbt->size == lock_obj->lockobj.size) {
    tmp = memcmp((void const   *)dbt->data, (void const   *)obj_data, dbt->size);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int __lock_locker_cmp(u_int32_t locker , DB_LOCKER *sh_locker ) 
{ 

  {
  return (locker == sh_locker->id);
}
}
u_int32_t __lock_ohash(DBT const   *dbt ) 
{ u_int32_t __h ;
  u_int8_t *__cp ;
  u_int8_t *__hp ;
  u_int32_t tmp ;

  {
  if (dbt->size == sizeof(DB_LOCK_ILOCK )) {
    __hp = (u_int8_t *)(& __h);
    __cp = (u_int8_t *)dbt->data;
    (*(__hp + 0)) = (unsigned char )((int )(*(__cp + 0)) ^ (int )(*(__cp + 4)));
    (*(__hp + 1)) = (unsigned char )((int )(*(__cp + 1)) ^ (int )(*(__cp + 5)));
    (*(__hp + 2)) = (unsigned char )((int )(*(__cp + 2)) ^ (int )(*(__cp + 6)));
    (*(__hp + 3)) = (unsigned char )((int )(*(__cp + 3)) ^ (int )(*(__cp + 7)));
    return (__h);
  }
  tmp = __ham_func5((DB *)((void *)0), (void const   *)dbt->data, dbt->size);
  return (tmp);
}
}
u_int32_t __lock_lhash(DB_LOCKOBJ *lock_obj ) 
{ void *obj_data ;
  u_int32_t __h ;
  u_int8_t *__cp ;
  u_int8_t *__hp ;
  u_int32_t tmp ;

  {
  obj_data = (void *)((u_int8_t *)(& lock_obj->lockobj) + lock_obj->lockobj.off);
  if (lock_obj->lockobj.size == sizeof(DB_LOCK_ILOCK )) {
    __hp = (u_int8_t *)(& __h);
    __cp = (u_int8_t *)obj_data;
    (*(__hp + 0)) = (unsigned char )((int )(*(__cp + 0)) ^ (int )(*(__cp + 4)));
    (*(__hp + 1)) = (unsigned char )((int )(*(__cp + 1)) ^ (int )(*(__cp + 5)));
    (*(__hp + 2)) = (unsigned char )((int )(*(__cp + 2)) ^ (int )(*(__cp + 6)));
    (*(__hp + 3)) = (unsigned char )((int )(*(__cp + 3)) ^ (int )(*(__cp + 7)));
    return (__h);
  }
  tmp = __ham_func5((DB *)((void *)0), (void const   *)obj_data, lock_obj->lockobj.size);
  return (tmp);
}
}
u_int32_t __lock_locker_hash(u_int32_t locker ) 
{ 

  {
  return (locker);
}
}
#pragma merger(0,"/tmp/cil-Ged3BMCX.i","-O2")
int __log_find(DB_LOG *dblp , int find_first , u_int32_t *valp , logfile_validity *statusp ) ;
int __log_valid(DB_LOG *dblp , u_int32_t number , int set_persist , DB_FH **fhpp ,
                int flags , logfile_validity *statusp ) ;
int __log_stat_pp(DB_ENV *dbenv___0 , DB_LOG_STAT **statp , u_int32_t flags ) ;
void __log_get_cached_ckp_lsn(DB_ENV *dbenv___0 , DB_LSN *ckp_lsnp ) ;
int __log_archive(DB_ENV *dbenv___0 , char ***listp , u_int32_t flags ) ;
int __log_flush_int(DB_LOG *dblp , DB_LSN const   *lsnp , int release ) ;
int __log_name(DB_LOG *dblp , u_int32_t filenumber , char **namep , DB_FH **fhpp ,
               u_int32_t flags ) ;
static int __log_init(DB_ENV *dbenv___0 , DB_LOG *dblp ) ;
static int __log_recover(DB_LOG *dblp ) ;
static size_t __log_region_size(DB_ENV *dbenv___0 ) ;
static int __log_stat(DB_ENV *dbenv___0 , DB_LOG_STAT **statp , u_int32_t flags ) ;
static int __log_zero(DB_ENV *dbenv___0 , DB_LSN *from_lsn , DB_LSN *to_lsn ) ;
int __log_open(DB_ENV *dbenv___0 ) 
{ DB_LOG *dblp ;
  LOG *lp ;
  int ret ;
  size_t tmp ;

  {
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_LOG ), (void *)(& dblp));
  if (ret != 0) {
    return (ret);
  }
  dblp->dbenv = dbenv___0;
  dblp->reginfo.type = (enum __anonenum_reg_type_50 )3;
  dblp->reginfo.id = 0U;
  dblp->reginfo.mode = dbenv___0->db_mode;
  dblp->reginfo.flags = 4U;
  if (dbenv___0->flags & 8U) {
    dblp->reginfo.flags = dblp->reginfo.flags | 2U;
  }
  tmp = __log_region_size(dbenv___0);
  ret = __db_r_attach(dbenv___0, & dblp->reginfo, tmp);
  if (ret != 0) {
    goto err;
  }
  if (dblp->reginfo.flags & 1U) {
    ret = __log_init(dbenv___0, dblp);
    if (ret != 0) {
      goto err;
    }
  }
  dblp->reginfo.primary = (void *)((u_int8_t *)dblp->reginfo.addr + (dblp->reginfo.rp)->primary);
  lp = (LOG *)dblp->reginfo.primary;
  if (dbenv___0->flags & 1048576U) {
    ret = __db_mutex_setup(dbenv___0, & dblp->reginfo, (void *)(& dblp->mutexp), 65U);
    if (ret != 0) {
      goto err;
    }
  }
  dblp->bufp = (u_int8_t *)((void *)((u_int8_t *)dblp->reginfo.addr + lp->buffer_off));
  dbenv___0->lg_handle = (void *)dblp;
  if (dblp->reginfo.flags & 1U) {
    if (lp->log_size == 0U) {
      lp->log_size = 10485760U;
    }
    ret = __log_recover(dblp);
    if (ret != 0) {
      goto err;
    }
    if (lp->log_nsize == 0U) {
      lp->log_nsize = lp->log_size;
    }
    if (lp->lsn.file == 1U) {
      if (lp->lsn.offset == 0U) {
        ret = __log_newfile(dblp, (DB_LSN *)((void *)0));
        if (ret != 0) {
          goto err;
        }
      }
    }
    lp->ready_lsn = lp->lsn;
  } else {
    if (dbenv___0->lg_size != 0U) {
      lp->log_nsize = dbenv___0->lg_size;
    }
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  return (0);
  err: 
  dbenv___0->lg_handle = (void *)0;
  if ((unsigned int )dblp->reginfo.addr != (unsigned int )((void *)0)) {
    if (dblp->reginfo.flags & 1U) {
      ret = __db_panic(dbenv___0, ret);
    }
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
    __db_r_detach(dbenv___0, & dblp->reginfo, 0);
  }
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    __db_mutex_free(dbenv___0, & dblp->reginfo, dblp->mutexp);
  }
  __os_free(dbenv___0, (void *)dblp);
  return (ret);
}
}
static int __log_init(DB_ENV *dbenv___0 , DB_LOG *dblp ) 
{ DB_MUTEX *flush_mutexp ;
  LOG *region ;
  int ret ;
  void *p ;

  {
  ret = __db_shalloc(dblp->reginfo.addr, sizeof((*region)), 0U, (void *)(& dblp->reginfo.primary));
  if (ret != 0) {
    goto mem_err;
  }
  (dblp->reginfo.rp)->primary = (unsigned int )((u_int8_t *)dblp->reginfo.primary -
                                                (u_int8_t *)dblp->reginfo.addr);
  region = (LOG *)dblp->reginfo.primary;
  memset((void *)region, 0, sizeof((*region)));
  region->fid_max = 0;
  region->fq.stqh_first = -1;
  region->fq.stqh_last = (u_int8_t *)(& region->fq.stqh_first) - (u_int8_t *)(& region->fq);
  region->free_fid_stack = 0U;
  region->free_fids_alloced = 0;
  region->free_fids = region->free_fids_alloced;
  while (1) {
    region->lsn.file = 1U;
    region->lsn.offset = 0U;
    break;
  }
  while (1) {
    region->t_lsn.file = 1U;
    region->t_lsn.offset = 0U;
    break;
  }
  while (1) {
    region->waiting_lsn.file = 0U;
    region->waiting_lsn.offset = 0U;
    break;
  }
  while (1) {
    region->cached_ckp_lsn.file = 0U;
    region->cached_ckp_lsn.offset = 0U;
    break;
  }
  ret = __db_mutex_setup(dbenv___0, & dblp->reginfo, (void *)(& region->fq_mutex),
                         64U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_shalloc(dblp->reginfo.addr, sizeof(DB_MUTEX ), 1U, (void *)(& flush_mutexp));
  if (ret != 0) {
    goto mem_err;
  }
  ret = __db_mutex_setup(dbenv___0, & dblp->reginfo, (void *)flush_mutexp, 64U);
  if (ret != 0) {
    return (ret);
  }
  region->flush_mutex_off = (unsigned int )((u_int8_t *)flush_mutexp - (u_int8_t *)dblp->reginfo.addr);
  ret = __db_shalloc(dblp->reginfo.addr, dbenv___0->lg_bsize, 0U, (void *)(& p));
  if (ret != 0) {
    mem_err: 
    __db_err((DB_ENV const   *)dbenv___0, "Unable to allocate memory for the log buffer");
    return (ret);
  }
  region->buffer_size = dbenv___0->lg_bsize;
  region->buffer_off = (unsigned int )((u_int8_t *)p - (u_int8_t *)dblp->reginfo.addr);
  region->log_nsize = dbenv___0->lg_size;
  region->log_size = region->log_nsize;
  region->free_commits.stqh_first = -1;
  region->free_commits.stqh_last = (u_int8_t *)(& region->free_commits.stqh_first) -
                                   (u_int8_t *)(& region->free_commits);
  region->commits.stqh_first = -1;
  region->commits.stqh_last = (u_int8_t *)(& region->commits.stqh_first) - (u_int8_t *)(& region->commits);
  region->ncommit = 0U;
  region->persist.magic = 264584U;
  region->persist.version = 8U;
  region->persist.mode = (unsigned int )dbenv___0->db_mode;
  return (0);
}
}
static int __log_recover(DB_LOG *dblp ) 
{ DBT dbt ;
  DB_ENV *dbenv___0 ;
  DB_LOGC *logc ;
  DB_LSN lsn ;
  LOG *lp ;
  u_int32_t cnt ;
  u_int32_t rectype ;
  int ret ;
  logfile_validity status ;
  int tmp ;

  {
  logc = (DB_LOGC *)((void *)0);
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  ret = __log_find(dblp, 0, & cnt, & status);
  if (ret != 0) {
    return (ret);
  }
  if (cnt == 0U) {
    return (0);
  }
  if ((int )status == 3) {
    lp->s_lsn.file = cnt + 1U;
    lp->lsn.file = lp->s_lsn.file;
    lp->s_lsn.offset = 0U;
    lp->lsn.offset = lp->s_lsn.offset;
    goto skipsearch;
  } else {
    if ((int )status == 4) {
      lp->s_lsn.file = cnt + 1U;
      lp->lsn.file = lp->s_lsn.file;
      lp->s_lsn.offset = 0U;
      lp->lsn.offset = lp->s_lsn.offset;
      goto skipsearch;
    }
  }
  lp->lsn.file = cnt + 1U;
  lp->lsn.offset = 0U;
  lsn.file = cnt;
  lsn.offset = 0U;
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  logc->flags = logc->flags | 2U;
  memset((void *)(& dbt), 0, sizeof(dbt));
  ret = __log_c_get(logc, & lsn, & dbt, 28U);
  if (ret != 0) {
    goto err;
  }
  logc->flags = logc->flags | 4U;
  while (1) {
    tmp = __log_c_get(logc, & lsn, & dbt, 18U);
    if (! (tmp == 0)) {
      break;
    }
    if (dbt.size < sizeof(u_int32_t )) {
      continue;
    }
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )dbt.data,
           sizeof(u_int32_t ));
    if (rectype == 11U) {
      lp->cached_ckp_lsn = lsn;
    }
  }
  logc->flags = logc->flags & 4294967291U;
  lp->lsn = lsn;
  lp->s_lsn = lsn;
  lp->lsn.offset = lp->lsn.offset + logc->c_len;
  lp->s_lsn.offset = lp->s_lsn.offset + logc->c_len;
  lp->len = logc->c_len;
  lp->b_off = 0U;
  lp->w_off = lp->lsn.offset;
  skipsearch: 
  if (dbenv___0->verbose & 4U) {
    __db_err((DB_ENV const   *)dbenv___0, "Finding last valid log LSN: file: %lu offset %lu",
             (unsigned long )lp->lsn.file, (unsigned long )lp->lsn.offset);
  }
  err: 
  if ((unsigned int )logc != (unsigned int )((void *)0)) {
    __log_c_close(logc);
  }
  return (ret);
}
}
int __log_find(DB_LOG *dblp , int find_first , u_int32_t *valp , logfile_validity *statusp ) 
{ DB_ENV *dbenv___0 ;
  logfile_validity logval_status ;
  logfile_validity status ;
  u_int32_t clv ;
  u_int32_t logval ;
  int cnt ;
  int fcnt ;
  int ret ;
  char const   *dir ;
  char *c ;
  char **names ;
  char *p ;
  char *q ;
  char savech ;
  char *tmp ;
  int tmp___75 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___111 ;
  unsigned char const   *__s2___14 ;
  register int __result___42 ;
  int tmp___130 ;
  unsigned char const   *__s1___30 ;
  register int __result___46 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  int tmp___148 ;
  size_t tmp___149 ;
  unsigned short const   **tmp___150 ;
  char *tmp___151 ;

  {
  dbenv___0 = dblp->dbenv;
  status = (enum __anonenum_logfile_validity_65 )1;
  logval_status = status;
  (*valp) = 0U;
  ret = __log_name(dblp, 1U, & p, (DB_FH **)((void *)0), 0U);
  if (ret != 0) {
    return (ret);
  }
  q = __db_rpath((char const   *)p);
  if ((unsigned int )q == (unsigned int )((void *)0)) {
    savech = (char)0;
    savech = savech;
    dir = ".";
  } else {
    savech = (*q);
    (*q) = (char )'\000';
    dir = (char const   *)p;
  }
  ret = __os_dirlist(dbenv___0, dir, & names, & fcnt);
  if ((unsigned int )q != (unsigned int )((void *)0)) {
    (*q) = savech;
  }
  if (ret != 0) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", dir, tmp);
    __os_free(dbenv___0, (void *)p);
    return (ret);
  }
  cnt = fcnt;
  logval = 0U;
  clv = logval;
  while (1) {
    cnt --;
    if (! (cnt >= 0)) {
      break;
    }
    tmp___145 = __builtin_constant_p((int )(sizeof("log.") - 1U));
    if (tmp___145) {
      tmp___146 = __builtin_constant_p((int )(*(names + cnt)));
      if (tmp___146) {
        tmp___147 = strlen((char const   *)(*(names + cnt)));
        if (tmp___147 < sizeof("log.") - 1U) {
          goto _L___39;
        } else {
          goto _L___40;
        }
      } else {
        _L___40: 
        tmp___148 = __builtin_constant_p((int )"log.");
        if (tmp___148) {
          tmp___149 = strlen("log.");
          if (tmp___149 < sizeof("log.") - 1U) {
            _L___39: 
            tmp___142 = __builtin_constant_p((int )(*(names + cnt)));
            if (tmp___142) {
              tmp___143 = __builtin_constant_p((int )"log.");
              if (tmp___143) {
                __s1_len___0 = strlen((char const   *)(*(names + cnt)));
                __s2_len___0 = strlen("log.");
                if (! ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                    cnt))) ==
                       1U)) {
                  goto _L___36;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___36: 
                    if (! ((unsigned int )((void const   *)("log." + 1)) - (unsigned int )((void const   *)"log.") ==
                           1U)) {
                      tmp___144 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___144 = 1;
                      } else {
                        tmp___144 = 0;
                      }
                    }
                  } else {
                    tmp___144 = 0;
                  }
                }
                if (tmp___144) {
                  tmp___111 = __builtin_strcmp((*(names + cnt)), "log.");
                } else {
                  goto _L___38;
                }
              } else {
                goto _L___38;
              }
            } else {
              _L___38: 
              tmp___141 = __builtin_constant_p((int )(*(names + cnt)));
              if (tmp___141) {
                if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) - (unsigned int )((void const   *)(*(names +
                                                                                                                 cnt))) ==
                    1U) {
                  __s1_len___0 = strlen((char const   *)(*(names + cnt)));
                  if (__s1_len___0 < 4U) {
                    tmp___130 = __builtin_constant_p((int )"log.");
                    if (tmp___130) {
                      if ((unsigned int )((void const   *)("log." + 1)) - (unsigned int )((void const   *)"log.") ==
                          1U) {
                        tmp___111 = __builtin_strcmp((*(names + cnt)), "log.");
                      } else {
                        goto _L___31;
                      }
                    } else {
                      _L___31: 
                      __s2___14 = (unsigned char const   *)"log.";
                      __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                           cnt))) +
                                                              0)) - (int const   )(*(__s2___14 +
                                                                                     0)));
                      if (__s1_len___0 > 0U) {
                        if (__result___42 == 0) {
                          __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                               cnt))) +
                                                                  1)) - (int const   )(*(__s2___14 +
                                                                                         1)));
                          if (__s1_len___0 > 1U) {
                            if (__result___42 == 0) {
                              __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                   cnt))) +
                                                                      2)) - (int const   )(*(__s2___14 +
                                                                                             2)));
                              if (__s1_len___0 > 2U) {
                                if (__result___42 == 0) {
                                  __result___42 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(names +
                                                                                                                       cnt))) +
                                                                          3)) - (int const   )(*(__s2___14 +
                                                                                                 3)));
                                }
                              }
                            }
                          }
                        }
                      }
                      tmp___111 = __result___42;
                    }
                  } else {
                    goto _L___35;
                  }
                } else {
                  goto _L___35;
                }
              } else {
                _L___35: 
                tmp___140 = __builtin_constant_p((int )"log.");
                if (tmp___140) {
                  if ((unsigned int )((void const   *)("log." + 1)) - (unsigned int )((void const   *)"log.") ==
                      1U) {
                    __s2_len___0 = strlen("log.");
                    if (__s2_len___0 < 4U) {
                      tmp___139 = __builtin_constant_p((int )(*(names + cnt)));
                      if (tmp___139) {
                        if ((unsigned int )((void const   *)((*(names + cnt)) + 1)) -
                            (unsigned int )((void const   *)(*(names + cnt))) == 1U) {
                          tmp___111 = __builtin_strcmp((*(names + cnt)), "log.");
                        } else {
                          goto _L___33;
                        }
                      } else {
                        _L___33: 
                        __s1___30 = (unsigned char const   *)((char const   *)(*(names +
                                                                                 cnt)));
                        __result___46 = (int )((int const   )(*(__s1___30 + 0)) -
                                               (int const   )(*((unsigned char const   *)"log." +
                                                                0)));
                        if (__s2_len___0 > 0U) {
                          if (__result___46 == 0) {
                            __result___46 = (int )((int const   )(*(__s1___30 + 1)) -
                                                   (int const   )(*((unsigned char const   *)"log." +
                                                                    1)));
                            if (__s2_len___0 > 1U) {
                              if (__result___46 == 0) {
                                __result___46 = (int )((int const   )(*(__s1___30 +
                                                                        2)) - (int const   )(*((unsigned char const   *)"log." +
                                                                                               2)));
                                if (__s2_len___0 > 2U) {
                                  if (__result___46 == 0) {
                                    __result___46 = (int )((int const   )(*(__s1___30 +
                                                                            3)) -
                                                           (int const   )(*((unsigned char const   *)"log." +
                                                                            3)));
                                  }
                                }
                              }
                            }
                          }
                        }
                        tmp___111 = __result___46;
                      }
                    } else {
                      tmp___111 = __builtin_strcmp((*(names + cnt)), "log.");
                    }
                  } else {
                    tmp___111 = __builtin_strcmp((*(names + cnt)), "log.");
                  }
                } else {
                  tmp___111 = __builtin_strcmp((*(names + cnt)), "log.");
                }
              }
            }
            tmp___75 = tmp___111;
          } else {
            tmp___75 = strncmp((char const   *)(*(names + cnt)), "log.", sizeof("log.") -
                                                                         1U);
          }
        } else {
          tmp___75 = strncmp((char const   *)(*(names + cnt)), "log.", sizeof("log.") -
                                                                       1U);
        }
      }
    } else {
      tmp___75 = strncmp((char const   *)(*(names + cnt)), "log.", sizeof("log.") -
                                                                   1U);
    }
    if (tmp___75 != 0) {
      goto __Cont;
    }
    c = ((*(names + cnt)) + sizeof("log.")) - 1;
    while ((int )(*c) != 0) {
      tmp___150 = __ctype_b_loc();
      if (! ((int const   )(*((*tmp___150) + (int )(*c))) & 2048)) {
        break;
      }
      c ++;
    }
    if ((int )(*c) != 0) {
      goto __Cont;
    }
    clv = (u_int32_t )atol__extinline((char const   *)((*(names + cnt)) + (sizeof("log.") -
                                                                           1U)));
    if (find_first) {
      if (logval != 0U) {
        if ((int )status != 4) {
          if (clv > logval) {
            goto __Cont;
          }
        }
      }
    } else {
      if (logval != 0U) {
        if (clv < logval) {
          goto __Cont;
        }
      }
    }
    ret = __log_valid(dblp, clv, 1, (DB_FH **)((void *)0), 0, & status);
    if (ret != 0) {
      tmp___151 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "Invalid log file: %s: %s", (*(names +
                                                                           cnt)),
               tmp___151);
      goto err;
    }
    switch ((int )status) {
    case 1: ;
    break;
    case 0: ;
    if (find_first) {
      goto found;
    }
    break;
    case 4: ;
    if (! find_first) {
      goto found;
    } else {
      if (logval == 0U) {
        goto found;
      } else {
        if ((int )status == 4) {
          if (clv > logval) {
            goto found;
          }
        }
      }
    }
    break;
    case 2: ;
    case 3: ;
    found: 
    logval = clv;
    logval_status = status;
    break;
    }
    __Cont: ;
  }
  (*valp) = logval;
  err: 
  __os_dirfree(dbenv___0, names, fcnt);
  __os_free(dbenv___0, (void *)p);
  (*statusp) = logval_status;
  return (ret);
}
}
int __log_valid(DB_LOG *dblp , u_int32_t number , int set_persist , DB_FH **fhpp ,
                int flags , logfile_validity *statusp ) 
{ DB_CIPHER *db_cipher ;
  DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  HDR *hdr ;
  LOG *region ;
  LOGP *persist ;
  logfile_validity status ;
  size_t hdrsize ;
  size_t nw ;
  size_t recsize ;
  int is_hmac ;
  int ret ;
  u_int8_t *tmp ;
  char *fname ;
  u_int tmp___0 ;
  char *tmp___1 ;

  {
  dbenv___0 = dblp->dbenv;
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  fhp = (DB_FH *)((void *)0);
  persist = (LOGP *)((void *)0);
  status = (enum __anonenum_logfile_validity_65 )2;
  tmp = (u_int8_t *)((void *)0);
  if ((unsigned int )fhpp != (unsigned int )((void *)0)) {
    (*fhpp) = (DB_FH *)((void *)0);
  }
  if (flags == 0) {
    flags = 80;
  }
  ret = __log_name(dblp, number, & fname, & fhp, (unsigned int )flags);
  if (ret != 0) {
    __os_free(dbenv___0, (void *)fname);
    return (ret);
  }
  hdrsize = 12U;
  is_hmac = 0;
  recsize = sizeof(LOGP );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    hdrsize = 48U;
    recsize = sizeof(LOGP );
    tmp___0 = ((*(db_cipher->adj_size)))(recsize);
    recsize += tmp___0;
    is_hmac = 1;
  }
  ret = __os_calloc(dbenv___0, 1U, recsize + hdrsize, (void *)(& tmp));
  if (ret != 0) {
    goto err;
  }
  hdr = (HDR *)tmp;
  persist = (LOGP *)(tmp + hdrsize);
  ret = __os_read(dbenv___0, fhp, (void *)tmp, recsize + hdrsize, & nw);
  if (ret != 0) {
    goto _L;
  } else {
    if (nw != recsize + hdrsize) {
      _L: 
      if (ret == 0) {
        status = (enum __anonenum_logfile_validity_65 )0;
      } else {
        tmp___1 = db_strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "Ignoring log file: %s: %s", fname,
                 tmp___1);
      }
      goto err;
    }
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    if (hdr->len - hdrsize != sizeof(LOGP )) {
      __db_err((DB_ENV const   *)dbenv___0, "log record size mismatch");
      goto err;
    }
    ret = __db_check_chksum(dbenv___0, db_cipher, & hdr->chksum[0], (void *)((u_int8_t *)persist),
                            hdr->len - hdrsize, is_hmac);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "log record checksum mismatch");
      goto err;
    }
    ret = ((*(db_cipher->decrypt)))(dbenv___0, db_cipher->data, (void *)(& hdr->iv[0]),
                                    (u_int8_t *)persist, hdr->len - hdrsize);
    if (ret != 0) {
      goto err;
    }
  }
  if (persist->magic != 264584U) {
    __db_err((DB_ENV const   *)dbenv___0, "Ignoring log file: %s: magic number %lx, not %lx",
             fname, (unsigned long )persist->magic, 264584UL);
    ret = 22;
    goto err;
  }
  if (persist->version > 8U) {
    __db_err((DB_ENV const   *)dbenv___0, "Ignoring log file: %s: unsupported log version %lu",
             fname, (unsigned long )persist->version);
    ret = 22;
    goto err;
  } else {
    if (persist->version < 8U) {
      status = (enum __anonenum_logfile_validity_65 )4;
      __db_err((DB_ENV const   *)dbenv___0, "Ignoring log file: %s: unreadable log version %lu",
               fname, (unsigned long )persist->version);
      goto err;
    } else {
      if (persist->version < 8U) {
        status = (enum __anonenum_logfile_validity_65 )3;
      }
    }
  }
  if (! ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0))) {
    ret = __db_check_chksum(dbenv___0, db_cipher, & hdr->chksum[0], (void *)((u_int8_t *)persist),
                            hdr->len - hdrsize, is_hmac);
    if (ret != 0) {
      __db_err((DB_ENV const   *)dbenv___0, "log record checksum mismatch");
      goto err;
    }
  }
  if (set_persist) {
    region = (LOG *)dblp->reginfo.primary;
    region->log_size = persist->log_size;
    region->persist.mode = persist->mode;
  }
  err: 
  if ((unsigned int )fname != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)fname);
  }
  if (ret == 0) {
    if ((unsigned int )fhpp != (unsigned int )((void *)0)) {
      (*fhpp) = fhp;
    } else {
      __os_closehandle(dbenv___0, fhp);
    }
  } else {
    __os_closehandle(dbenv___0, fhp);
  }
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)tmp);
  }
  (*statusp) = status;
  return (ret);
}
}
int __log_dbenv_refresh(DB_ENV *dbenv___0 ) 
{ DB_LOG *dblp ;
  int ret ;
  int t_ret ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  dblp->flags = dblp->flags | 1U;
  ret = __dbreg_close_files(dbenv___0);
  if ((unsigned int )dblp->mutexp != (unsigned int )((void *)0)) {
    __db_mutex_free(dbenv___0, & dblp->reginfo, dblp->mutexp);
  }
  t_ret = __db_r_detach(dbenv___0, & dblp->reginfo, 0);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )dblp->lfhp != (unsigned int )((void *)0)) {
    t_ret = __os_closehandle(dbenv___0, dblp->lfhp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    dblp->lfhp = (DB_FH *)((void *)0);
  }
  if ((unsigned int )dblp->dbentry != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dblp->dbentry);
  }
  __os_free(dbenv___0, (void *)dblp);
  dbenv___0->lg_handle = (void *)0;
  return (ret);
}
}
int __log_stat_pp(DB_ENV *dbenv___0 , DB_LOG_STAT **statp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->log_stat", 16384U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->log_stat", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_stat(dbenv___0, statp, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __log_stat(DB_ENV *dbenv___0 , DB_LOG_STAT **statp , u_int32_t flags ) 
{ DB_LOG *dblp ;
  DB_LOG_STAT *stats___0 ;
  LOG *region ;
  int ret ;

  {
  (*statp) = (DB_LOG_STAT *)((void *)0);
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  region = (LOG *)dblp->reginfo.primary;
  ret = __os_umalloc(dbenv___0, sizeof(DB_LOG_STAT ), (void *)(& stats___0));
  if (ret != 0) {
    return (ret);
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  (*stats___0) = region->stat;
  if (flags & 1U) {
    memset((void *)(& region->stat), 0, sizeof(region->stat));
  }
  stats___0->st_magic = region->persist.magic;
  stats___0->st_version = region->persist.version;
  stats___0->st_mode = (int )region->persist.mode;
  stats___0->st_lg_bsize = region->buffer_size;
  stats___0->st_lg_size = region->log_nsize;
  stats___0->st_region_wait = (dblp->reginfo.rp)->mutex.mutex_set_wait;
  stats___0->st_region_nowait = (dblp->reginfo.rp)->mutex.mutex_set_nowait;
  if (flags & 1U) {
    (dblp->reginfo.rp)->mutex.mutex_set_wait = 0U;
    (dblp->reginfo.rp)->mutex.mutex_set_nowait = 0U;
  }
  stats___0->st_regsize = (dblp->reginfo.rp)->size;
  stats___0->st_cur_file = region->lsn.file;
  stats___0->st_cur_offset = region->lsn.offset;
  stats___0->st_disk_file = region->s_lsn.file;
  stats___0->st_disk_offset = region->s_lsn.offset;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  (*statp) = stats___0;
  return (0);
}
}
void __log_get_cached_ckp_lsn(DB_ENV *dbenv___0 , DB_LSN *ckp_lsnp ) 
{ DB_LOG *dblp ;
  LOG *lp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  (*ckp_lsnp) = lp->cached_ckp_lsn;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  return;
}
}
static size_t __log_region_size(DB_ENV *dbenv___0 ) 
{ size_t s ;

  {
  s = dbenv___0->lg_regionmax + dbenv___0->lg_bsize;
  return (s);
}
}
void __log_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  return;
}
}
int __log_vtruncate(DB_ENV *dbenv___0 , DB_LSN *lsn , DB_LSN *ckplsn , DB_LSN *trunclsn ) 
{ DBT log_dbt ;
  DB_LOG *dblp ;
  DB_LOGC *logc ;
  DB_LSN end_lsn ;
  DB_MUTEX *flush_mutexp ;
  LOG *lp ;
  u_int32_t bytes ;
  u_int32_t c_len ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& log_dbt), 0, sizeof(log_dbt));
  ret = __log_c_get(logc, lsn, & log_dbt, 28U);
  c_len = logc->c_len;
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret != 0) {
    return (ret);
  }
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  ret = __log_flush_int(dblp, (DB_LSN const   *)((void *)0), 0);
  if (ret != 0) {
    goto err;
  }
  end_lsn = lp->lsn;
  lp->lsn = (*lsn);
  lp->len = c_len;
  lp->lsn.offset = lp->lsn.offset + lp->len;
  bytes = 0U;
  if (ckplsn->file != lp->lsn.file) {
    bytes = lp->log_size - ckplsn->offset;
    if (lp->lsn.file > ckplsn->file + 1U) {
      bytes += lp->log_size * ((lp->lsn.file - ckplsn->file) - 1U);
    }
    bytes += lp->lsn.offset;
  } else {
    bytes = lp->lsn.offset - ckplsn->offset;
  }
  lp->stat.st_wc_mbytes = lp->stat.st_wc_mbytes + bytes / 1048576U;
  lp->stat.st_wc_bytes = lp->stat.st_wc_bytes + bytes % 1048576U;
  flush_mutexp = (DB_MUTEX *)((void *)((u_int8_t *)dblp->reginfo.addr + lp->flush_mutex_off));
  if (! (flush_mutexp->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, flush_mutexp);
  }
  tmp = log_compare((DB_LSN const   *)(& lp->s_lsn), (DB_LSN const   *)lsn);
  if (tmp > 0) {
    lp->s_lsn = lp->lsn;
  }
  if (! (flush_mutexp->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, flush_mutexp);
  }
  while (1) {
    lp->f_lsn.file = 0U;
    lp->f_lsn.offset = 0U;
    break;
  }
  lp->w_off = lp->lsn.offset;
  if ((unsigned int )trunclsn != (unsigned int )((void *)0)) {
    (*trunclsn) = lp->lsn;
  }
  ret = __log_zero(dbenv___0, & lp->lsn, & end_lsn);
  if (ret != 0) {
    goto err;
  }
  err: 
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __log_is_outdated(DB_ENV *dbenv___0 , u_int32_t fnum , int *outdatedp ) 
{ DB_LOG *dblp ;
  LOG *lp ;
  char *name ;
  int ret ;
  u_int32_t cfile ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  (*outdatedp) = 0;
  ret = __log_name(dblp, fnum, & name, (DB_FH **)((void *)0), 0U);
  if (ret != 0) {
    return (ret);
  }
  tmp = __os_exists((char const   *)name, (int *)((void *)0));
  if (tmp == 0) {
    goto out;
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  lp = (LOG *)dblp->reginfo.primary;
  cfile = lp->lsn.file;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (cfile > fnum) {
    (*outdatedp) = 1;
  }
  out: 
  __os_free(dbenv___0, (void *)name);
  return (ret);
}
}
static int __log_zero(DB_ENV *dbenv___0 , DB_LSN *from_lsn , DB_LSN *to_lsn ) 
{ DB_FH *fhp ;
  DB_LOG *dblp ;
  size_t nbytes ;
  size_t len ;
  size_t nw ;
  u_int8_t buf[4096] ;
  u_int32_t mbytes ;
  u_int32_t bytes ;
  int fn___2 ;
  int ret ;
  char *fname ;
  int tmp ;
  int tmp___0 ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  tmp = log_compare((DB_LSN const   *)from_lsn, (DB_LSN const   *)to_lsn);
  if (tmp > 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Warning: truncating to point beyond end of log");
    return (0);
  }
  if ((unsigned int )dblp->lfhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, dblp->lfhp);
    dblp->lfhp = (DB_FH *)((void *)0);
  }
  fn___2 = (int )(from_lsn->file + 1U);
  while (1) {
    tmp___0 = __log_name(dblp, (unsigned int )fn___2, & fname, & fhp, 16U);
    if (tmp___0 != 0) {
      __os_free(dbenv___0, (void *)fname);
      break;
    }
    __os_closehandle(dbenv___0, fhp);
    ret = __os_unlink(dbenv___0, (char const   *)fname);
    __os_free(dbenv___0, (void *)fname);
    if (ret != 0) {
      return (ret);
    }
    fn___2 ++;
  }
  ret = __log_name(dblp, from_lsn->file, & fname, & dblp->lfhp, 0U);
  if (ret != 0) {
    return (ret);
  }
  __os_free(dbenv___0, (void *)fname);
  ret = __os_ioinfo(dbenv___0, (char const   *)((void *)0), dblp->lfhp, & mbytes,
                    & bytes, (u_int32_t *)((void *)0));
  if (ret != 0) {
    goto err;
  }
  len = (mbytes * 1048576U + bytes) - from_lsn->offset;
  memset((void *)(buf), 0, sizeof(buf));
  ret = __os_seek(dbenv___0, dblp->lfhp, 0U, 0U, from_lsn->offset, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  while (len > 0U) {
    if (len > sizeof(buf)) {
      nbytes = sizeof(buf);
    } else {
      nbytes = len;
    }
    ret = __os_write(dbenv___0, dblp->lfhp, (void *)(buf), nbytes, & nw);
    if (ret != 0) {
      goto err;
    }
    len -= nbytes;
  }
  err: 
  __os_closehandle(dbenv___0, dblp->lfhp);
  dblp->lfhp = (DB_FH *)((void *)0);
  return (ret);
}
}
void __log_autoremove(DB_ENV *dbenv___0 ) 
{ char **begin ;
  char **list___2 ;
  int tmp ;

  {
  tmp = __log_archive(dbenv___0, & list___2, 1U);
  if (tmp != 0) {
    return;
  }
  if ((unsigned int )list___2 != (unsigned int )((void *)0)) {
    begin = list___2;
    while ((unsigned int )(*list___2) != (unsigned int )((void *)0)) {
      __os_unlink(dbenv___0, (char const   *)(*list___2));
      list___2 ++;
    }
    __os_ufree(dbenv___0, (void *)begin);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-tx3pJwC2.i","-O2")
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
int __log_archive_pp(DB_ENV *dbenv___0 , char ***listp , u_int32_t flags ) ;
static int __absname(DB_ENV *dbenv___0 , char *pref , char *name , char **newnamep ) ;
static int __build_data(DB_ENV *dbenv___0 , char *pref , char ***listp ) ;
static int __cmpfunc(void const   *p1 , void const   *p2 ) ;
static int __usermem(DB_ENV *dbenv___0 , char ***listp ) ;
int __log_archive_pp(DB_ENV *dbenv___0 , char ***listp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->log_archive", 16384U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_archive(dbenv___0, listp, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __log_archive(DB_ENV *dbenv___0 , char ***listp , u_int32_t flags ) 
{ DBT rec ;
  DB_LOG *dblp ;
  DB_LOGC *logc ;
  DB_LSN stable_lsn ;
  __txn_ckp_args *ckp_args ;
  char **array ;
  char **arrayp ;
  char *name ;
  char *p ;
  char *pref ;
  char buf[1024] ;
  int array_size ;
  int db_arch_abs ;
  int n ;
  int rep_check ;
  int ret ;
  u_int32_t fnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  ret = 0;
  name = (char *)((void *)0);
  array = (char **)((void *)0);
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  fnum = 0U;
  fnum = fnum;
  if (flags != 0U) {
    ret = __db_fchk(dbenv___0, "DB_ENV->log_archive", flags, 15U);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_fcchk(dbenv___0, "DB_ENV->log_archive", flags, 2U, 4U);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_fcchk(dbenv___0, "DB_ENV->log_archive", flags, 8U, 7U);
    if (ret != 0) {
      return (ret);
    }
  }
  if (flags & 1U) {
    db_arch_abs = 1;
    flags &= 4294967294U;
  } else {
    db_arch_abs = 0;
  }
  if (flags == 0U) {
    goto _L;
  } else {
    if (flags == 2U) {
      _L: 
      if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
        tmp = __db_env_config(dbenv___0, (char *)"DB_ENV->log_archive", 131072U);
        return (tmp);
      }
    }
  }
  rep_check = 0;
  if (flags == 0U) {
    goto _L___1;
  } else {
    if (flags == 8U) {
      goto _L___1;
    } else {
      if (db_arch_abs) {
        _L___1: 
        tmp___0 = __rep_noarchive(dbenv___0);
        if (tmp___0) {
          (*listp) = (char **)((void *)0);
          ret = 0;
          goto err;
        }
      } else {
        if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
          if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
            rep_check = 0;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
            if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
              if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
                rep_check = 1;
              } else {
                rep_check = 0;
              }
            } else {
              rep_check = 0;
            }
          } else {
            rep_check = 0;
          }
        }
        if (rep_check) {
          __env_rep_enter(dbenv___0);
        }
      }
    }
  }
  if (db_arch_abs) {
    __os_set_errno(0);
    pref = getcwd(buf, sizeof(buf));
    if ((unsigned int )pref == (unsigned int )((void *)0)) {
      tmp___1 = __os_get_errno();
      if (tmp___1 == 0) {
        __os_set_errno(12);
      }
      ret = __os_get_errno();
      goto err1;
    }
  } else {
    pref = (char *)((void *)0);
  }
  switch ((int )flags) {
  case 2: 
  tmp___2 = __build_data(dbenv___0, pref, listp);
  return (tmp___2);
  case 4: 
  memset((void *)(& rec), 0, sizeof(rec));
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto err1;
  }
  ret = __log_c_get(logc, & stable_lsn, & rec, 17U);
  __log_c_close(logc);
  if (ret != 0) {
    goto err1;
  }
  fnum = stable_lsn.file;
  break;
  case 8: 
  __log_autoremove(dbenv___0);
  goto err1;
  case 0: 
  memset((void *)(& rec), 0, sizeof(rec));
  tmp___3 = __txn_getckp(dbenv___0, & stable_lsn);
  if (tmp___3 != 0) {
    (*listp) = (char **)((void *)0);
    goto err1;
  }
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    goto err1;
  }
  ret = __log_c_get(logc, & stable_lsn, & rec, 28U);
  if (ret != 0) {
    goto _L___2;
  } else {
    ret = __txn_ckp_read(dbenv___0, rec.data, & ckp_args);
    if (ret != 0) {
      _L___2: 
      if (ret == -30990) {
        (*listp) = (char **)((void *)0);
        ret = 0;
      }
      __log_c_close(logc);
      goto err1;
    }
  }
  ret = __log_c_close(logc);
  if (ret != 0) {
    goto err1;
  }
  stable_lsn = ckp_args->ckp_lsn;
  __os_free(dbenv___0, (void *)ckp_args);
  fnum = stable_lsn.file - 1U;
  break;
  }
  array_size = 64;
  ret = __os_malloc(dbenv___0, sizeof(char *) * (unsigned int )array_size, (void *)(& array));
  if (ret != 0) {
    goto err1;
  }
  (*(array + 0)) = (char *)((void *)0);
  n = 0;
  while (fnum > 0U) {
    ret = __log_name(dblp, fnum, & name, (DB_FH **)((void *)0), 0U);
    if (ret != 0) {
      goto err;
    }
    tmp___4 = __os_exists((char const   *)name, (int *)((void *)0));
    if (tmp___4 != 0) {
      if (flags & 4U) {
        if (fnum == stable_lsn.file) {
          goto __Cont;
        }
      }
      __os_free(dbenv___0, (void *)name);
      name = (char *)((void *)0);
      break;
    }
    if (n >= array_size - 2) {
      array_size += 64;
      ret = __os_realloc(dbenv___0, sizeof(char *) * (unsigned int )array_size, (void *)(& array));
      if (ret != 0) {
        goto err;
      }
    }
    if (db_arch_abs) {
      ret = __absname(dbenv___0, pref, name, array + n);
      if (ret != 0) {
        goto err;
      }
      __os_free(dbenv___0, (void *)name);
    } else {
      p = __db_rpath((char const   *)name);
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        ret = __os_strdup(dbenv___0, (char const   *)(p + 1), (void *)(array + n));
        if (ret != 0) {
          goto err;
        }
        __os_free(dbenv___0, (void *)name);
      } else {
        (*(array + n)) = name;
      }
    }
    name = (char *)((void *)0);
    n ++;
    (*(array + n)) = (char *)((void *)0);
    __Cont: 
    fnum --;
  }
  if (n == 0) {
    (*listp) = (char **)((void *)0);
    ret = 0;
    goto err;
  }
  qsort((void *)array, (unsigned int )n, sizeof(char *), & __cmpfunc);
  ret = __usermem(dbenv___0, & array);
  if (ret != 0) {
    goto err;
  }
  (*listp) = array;
  return (0);
  err: 
  if ((unsigned int )array != (unsigned int )((void *)0)) {
    arrayp = array;
    while ((unsigned int )(*arrayp) != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)(*arrayp));
      arrayp ++;
    }
    __os_free(dbenv___0, (void *)array);
  }
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)name);
  }
  err1: 
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __build_data(DB_ENV *dbenv___0 , char *pref , char ***listp ) 
{ DBT rec ;
  DB_LOGC *logc ;
  DB_LSN lsn ;
  __dbreg_register_args *argp ;
  u_int32_t rectype ;
  int array_size ;
  int last ;
  int n ;
  int nxt ;
  int ret ;
  int t_ret ;
  char **array ;
  char **arrayp ;
  char **list___2 ;
  char **lp ;
  char *p ;
  char *real_name ;
  int tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___36 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___55 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
  array_size = 64;
  ret = __os_malloc(dbenv___0, sizeof(char *) * (unsigned int )array_size, (void *)(& array));
  if (ret != 0) {
    return (ret);
  }
  (*(array + 0)) = (char *)((void *)0);
  memset((void *)(& rec), 0, sizeof(rec));
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  n = 0;
  while (1) {
    ret = __log_c_get(logc, & lsn, & rec, 25U);
    if (! (ret == 0)) {
      break;
    }
    if (rec.size < sizeof(rectype)) {
      ret = 22;
      __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_archive: bad log record");
      goto free_continue;
    }
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )rec.data,
           sizeof(rectype));
    if (rectype != 2U) {
      goto __Cont;
    }
    ret = __dbreg_register_read(dbenv___0, rec.data, & argp);
    if (ret != 0) {
      ret = 22;
      __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_archive: unable to read log record");
      goto free_continue;
    }
    if (n >= array_size - 2) {
      array_size += 64;
      ret = __os_realloc(dbenv___0, sizeof(char *) * (unsigned int )array_size, (void *)(& array));
      if (ret != 0) {
        goto free_continue;
      }
    }
    tmp = n;
    n ++;
    ret = __os_strdup(dbenv___0, (char const   *)argp->name.data, (void *)(array +
                                                                           tmp));
    if (ret != 0) {
      goto free_continue;
    }
    (*(array + n)) = (char *)((void *)0);
    if ((int )argp->ftype == 4) {
      ret = __qam_extent_names(dbenv___0, (char *)argp->name.data, & list___2);
      if (ret != 0) {
        goto q_err;
      }
      lp = list___2;
      while (1) {
        if ((unsigned int )lp != (unsigned int )((void *)0)) {
          if (! ((unsigned int )(*lp) != (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
        if (n >= array_size - 2) {
          array_size += 64;
          ret = __os_realloc(dbenv___0, sizeof(char *) * (unsigned int )array_size,
                             (void *)(& array));
          if (ret != 0) {
            goto q_err;
          }
        }
        tmp___0 = n;
        n ++;
        ret = __os_strdup(dbenv___0, (char const   *)(*lp), (void *)(array + tmp___0));
        if (ret != 0) {
          goto q_err;
        }
        (*(array + n)) = (char *)((void *)0);
        lp ++;
      }
      q_err: 
      if ((unsigned int )list___2 != (unsigned int )((void *)0)) {
        __os_free(dbenv___0, (void *)list___2);
      }
    }
    free_continue: 
    __os_free(dbenv___0, (void *)argp);
    if (ret != 0) {
      break;
    }
    __Cont: ;
  }
  if (ret == -30990) {
    ret = 0;
  }
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret != 0) {
    goto err1;
  }
  if (n == 0) {
    ret = 0;
    (*listp) = (char **)((void *)0);
    goto err1;
  }
  qsort((void *)array, (unsigned int )n, sizeof(char *), & __cmpfunc);
  nxt = 0;
  last = nxt;
  while (nxt < n) {
    if (last != nxt) {
      (*(array + last)) = (*(array + nxt));
      (*(array + nxt)) = (char *)((void *)0);
    }
    nxt ++;
    while (1) {
      if (nxt < n) {
        tmp___67 = __builtin_constant_p((int )(*(array + last)));
        if (tmp___67) {
          tmp___68 = __builtin_constant_p((int )(*(array + nxt)));
          if (tmp___68) {
            __s1_len = strlen((char const   *)(*(array + last)));
            __s2_len = strlen((char const   *)(*(array + nxt)));
            if (! ((unsigned int )((void const   *)((*(array + last)) + 1)) - (unsigned int )((void const   *)(*(array +
                                                                                                                 last))) ==
                   1U)) {
              goto _L___16;
            } else {
              if (__s1_len >= 4U) {
                _L___16: 
                if (! ((unsigned int )((void const   *)((*(array + nxt)) + 1)) - (unsigned int )((void const   *)(*(array +
                                                                                                                    nxt))) ==
                       1U)) {
                  tmp___69 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___69 = 1;
                  } else {
                    tmp___69 = 0;
                  }
                }
              } else {
                tmp___69 = 0;
              }
            }
            if (tmp___69) {
              tmp___36 = __builtin_strcmp((*(array + last)), (*(array + nxt)));
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          _L___18: 
          tmp___66 = __builtin_constant_p((int )(*(array + last)));
          if (tmp___66) {
            if ((unsigned int )((void const   *)((*(array + last)) + 1)) - (unsigned int )((void const   *)(*(array +
                                                                                                              last))) ==
                1U) {
              __s1_len = strlen((char const   *)(*(array + last)));
              if (__s1_len < 4U) {
                tmp___55 = __builtin_constant_p((int )(*(array + nxt)));
                if (tmp___55) {
                  if ((unsigned int )((void const   *)((*(array + nxt)) + 1)) - (unsigned int )((void const   *)(*(array +
                                                                                                                   nxt))) ==
                      1U) {
                    tmp___36 = __builtin_strcmp((*(array + last)), (*(array + nxt)));
                  } else {
                    goto _L___11;
                  }
                } else {
                  _L___11: 
                  __s2___6 = (unsigned char const   *)((char const   *)(*(array +
                                                                          nxt)));
                  __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                       last))) +
                                                          0)) - (int const   )(*(__s2___6 +
                                                                                 0)));
                  if (__s1_len > 0U) {
                    if (__result___18 == 0) {
                      __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                           last))) +
                                                              1)) - (int const   )(*(__s2___6 +
                                                                                     1)));
                      if (__s1_len > 1U) {
                        if (__result___18 == 0) {
                          __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                               last))) +
                                                                  2)) - (int const   )(*(__s2___6 +
                                                                                         2)));
                          if (__s1_len > 2U) {
                            if (__result___18 == 0) {
                              __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                                   last))) +
                                                                      3)) - (int const   )(*(__s2___6 +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___36 = __result___18;
                }
              } else {
                goto _L___15;
              }
            } else {
              goto _L___15;
            }
          } else {
            _L___15: 
            tmp___65 = __builtin_constant_p((int )(*(array + nxt)));
            if (tmp___65) {
              if ((unsigned int )((void const   *)((*(array + nxt)) + 1)) - (unsigned int )((void const   *)(*(array +
                                                                                                               nxt))) ==
                  1U) {
                __s2_len = strlen((char const   *)(*(array + nxt)));
                if (__s2_len < 4U) {
                  tmp___64 = __builtin_constant_p((int )(*(array + last)));
                  if (tmp___64) {
                    if ((unsigned int )((void const   *)((*(array + last)) + 1)) -
                        (unsigned int )((void const   *)(*(array + last))) == 1U) {
                      tmp___36 = __builtin_strcmp((*(array + last)), (*(array + nxt)));
                    } else {
                      goto _L___13;
                    }
                  } else {
                    _L___13: 
                    __s1___14 = (unsigned char const   *)((char const   *)(*(array +
                                                                             last)));
                    __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                                                            nxt))) +
                                                                                               0)));
                    if (__s2_len > 0U) {
                      if (__result___22 == 0) {
                        __result___22 = (int )((int const   )(*(__s1___14 + 1)) -
                                               (int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                             nxt))) +
                                                                1)));
                        if (__s2_len > 1U) {
                          if (__result___22 == 0) {
                            __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                   (int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                                 nxt))) +
                                                                    2)));
                            if (__s2_len > 2U) {
                              if (__result___22 == 0) {
                                __result___22 = (int )((int const   )(*(__s1___14 +
                                                                        3)) - (int const   )(*((unsigned char const   *)((char const   *)(*(array +
                                                                                                                                            nxt))) +
                                                                                               3)));
                              }
                            }
                          }
                        }
                      }
                    }
                    tmp___36 = __result___22;
                  }
                } else {
                  tmp___36 = __builtin_strcmp((*(array + last)), (*(array + nxt)));
                }
              } else {
                tmp___36 = __builtin_strcmp((*(array + last)), (*(array + nxt)));
              }
            } else {
              tmp___36 = __builtin_strcmp((*(array + last)), (*(array + nxt)));
            }
          }
        }
        if (! (tmp___36 == 0)) {
          break;
        }
      } else {
        break;
      }
      __os_free(dbenv___0, (void *)(*(array + nxt)));
      (*(array + nxt)) = (char *)((void *)0);
      nxt ++;
    }
    ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, (char const   *)(*(array +
                                                                                     last)),
                       0U, (DB_FH **)((void *)0), & real_name);
    if (ret != 0) {
      goto err2;
    }
    tmp___70 = __os_exists((char const   *)real_name, (int *)((void *)0));
    if (tmp___70 != 0) {
      __os_free(dbenv___0, (void *)real_name);
      __os_free(dbenv___0, (void *)(*(array + last)));
      (*(array + last)) = (char *)((void *)0);
      goto __Cont___0;
    }
    __os_free(dbenv___0, (void *)(*(array + last)));
    (*(array + last)) = (char *)((void *)0);
    if ((unsigned int )pref != (unsigned int )((void *)0)) {
      ret = __absname(dbenv___0, pref, real_name, array + last);
      __os_free(dbenv___0, (void *)real_name);
      if (ret != 0) {
        goto err2;
      }
    } else {
      p = __db_rpath((char const   *)real_name);
      if ((unsigned int )p != (unsigned int )((void *)0)) {
        ret = __os_strdup(dbenv___0, (char const   *)(p + 1), (void *)(array + last));
        __os_free(dbenv___0, (void *)real_name);
        if (ret != 0) {
          goto err2;
        }
      } else {
        (*(array + last)) = real_name;
      }
    }
    last ++;
    __Cont___0: ;
  }
  (*(array + last)) = (char *)((void *)0);
  ret = __usermem(dbenv___0, & array);
  if (ret != 0) {
    goto err1;
  }
  (*listp) = array;
  return (0);
  err2: 
  if ((unsigned int )array != (unsigned int )((void *)0)) {
    while (nxt < n) {
      __os_free(dbenv___0, (void *)(*(array + nxt)));
      nxt ++;
    }
  }
  err1: 
  if ((unsigned int )array != (unsigned int )((void *)0)) {
    arrayp = array;
    while ((unsigned int )(*arrayp) != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)(*arrayp));
      arrayp ++;
    }
    __os_free(dbenv___0, (void *)array);
  }
  return (ret);
}
}
static int __absname(DB_ENV *dbenv___0 , char *pref , char *name , char **newnamep ) 
{ size_t l_pref ;
  size_t l_name ;
  int isabspath ;
  int ret ;
  char *newname ;
  size_t tmp___0 ;
  char *tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  l_name = strlen((char const   *)name);
  isabspath = __os_abspath((char const   *)name);
  if (isabspath) {
    l_pref = 0U;
  } else {
    l_pref = strlen((char const   *)pref);
  }
  ret = __os_malloc(dbenv___0, (l_pref + l_name) + 2U, (void *)(& newname));
  if (ret != 0) {
    return (ret);
  }
  (*newnamep) = newname;
  if (! isabspath) {
    memcpy((void * __restrict  )newname, (void const   * __restrict  )pref, l_pref);
    tmp___7 = __builtin_constant_p((int )(*(newname + (l_pref - 1U))));
    if (tmp___7) {
      tmp___8 = __builtin_constant_p((int )"/");
      if (tmp___8) {
        tmp___5 = (char *)__builtin_strchr("/", (*(newname + (l_pref - 1U))));
      } else {
        if ((int )(*(newname + (l_pref - 1U))) == 0) {
          tmp___5 = (char *)__rawmemchr((void const   *)"/", (int )(*(newname + (l_pref -
                                                                                 1U))));
        } else {
          tmp___5 = (char *)__builtin_strchr("/", (*(newname + (l_pref - 1U))));
        }
      }
    } else {
      tmp___5 = (char *)__builtin_strchr("/", (*(newname + (l_pref - 1U))));
    }
    if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
      tmp___0 = l_pref;
      l_pref ++;
      (*(newname + tmp___0)) = (char )(*("/" + 0));
    }
  }
  memcpy((void * __restrict  )(newname + l_pref), (void const   * __restrict  )name,
         l_name + 1U);
  return (0);
}
}
static int __usermem(DB_ENV *dbenv___0 , char ***listp ) 
{ size_t len ;
  int ret ;
  char **array ;
  char **arrayp ;
  char **orig ;
  char *strp ;
  size_t tmp ;

  {
  len = 0U;
  orig = (*listp);
  while ((unsigned int )(*orig) != (unsigned int )((void *)0)) {
    tmp = strlen((char const   *)(*orig));
    len += (sizeof(char *) + tmp) + 1U;
    orig ++;
  }
  len += sizeof(char *);
  ret = __os_umalloc(dbenv___0, len, (void *)(& array));
  if (ret != 0) {
    return (ret);
  }
  strp = (char *)((array + (orig - (*listp))) + 1);
  orig = (*listp);
  arrayp = array;
  while ((unsigned int )(*orig) != (unsigned int )((void *)0)) {
    len = strlen((char const   *)(*orig));
    memcpy((void * __restrict  )strp, (void const   * __restrict  )(*orig), len +
                                                                            1U);
    (*arrayp) = strp;
    strp += len + 1U;
    __os_free(dbenv___0, (void *)(*orig));
    orig ++;
    arrayp ++;
  }
  (*arrayp) = (char *)((void *)0);
  __os_free(dbenv___0, (void *)(*listp));
  (*listp) = array;
  return (0);
}
}
static int __cmpfunc(void const   *p1 , void const   *p2 ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  tmp___65 = __builtin_constant_p((int )(*((char * const  *)p1)));
  if (tmp___65) {
    tmp___66 = __builtin_constant_p((int )(*((char * const  *)p2)));
    if (tmp___66) {
      __s1_len = strlen((char const   *)(*((char * const  *)p1)));
      __s2_len = strlen((char const   *)(*((char * const  *)p2)));
      if (! ((unsigned int )((void const   *)((*((char * const  *)p1)) + 1)) - (unsigned int )((void const   *)(*((char * const  *)p1))) ==
             1U)) {
        goto _L___16;
      } else {
        if (__s1_len >= 4U) {
          _L___16: 
          if (! ((unsigned int )((void const   *)((*((char * const  *)p2)) + 1)) -
                 (unsigned int )((void const   *)(*((char * const  *)p2))) == 1U)) {
            tmp___67 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___67 = 1;
            } else {
              tmp___67 = 0;
            }
          }
        } else {
          tmp___67 = 0;
        }
      }
      if (tmp___67) {
        tmp___34 = __builtin_strcmp((*((char * const  *)p1)), (*((char * const  *)p2)));
      } else {
        goto _L___18;
      }
    } else {
      goto _L___18;
    }
  } else {
    _L___18: 
    tmp___64 = __builtin_constant_p((int )(*((char * const  *)p1)));
    if (tmp___64) {
      if ((unsigned int )((void const   *)((*((char * const  *)p1)) + 1)) - (unsigned int )((void const   *)(*((char * const  *)p1))) ==
          1U) {
        __s1_len = strlen((char const   *)(*((char * const  *)p1)));
        if (__s1_len < 4U) {
          tmp___53 = __builtin_constant_p((int )(*((char * const  *)p2)));
          if (tmp___53) {
            if ((unsigned int )((void const   *)((*((char * const  *)p2)) + 1)) -
                (unsigned int )((void const   *)(*((char * const  *)p2))) == 1U) {
              tmp___34 = __builtin_strcmp((*((char * const  *)p1)), (*((char * const  *)p2)));
            } else {
              goto _L___11;
            }
          } else {
            _L___11: 
            __s2___6 = (unsigned char const   *)((char const   *)(*((char * const  *)p2)));
            __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p1))) +
                                                    0)) - (int const   )(*(__s2___6 +
                                                                           0)));
            if (__s1_len > 0U) {
              if (__result___18 == 0) {
                __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p1))) +
                                                        1)) - (int const   )(*(__s2___6 +
                                                                               1)));
                if (__s1_len > 1U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p1))) +
                                                            2)) - (int const   )(*(__s2___6 +
                                                                                   2)));
                    if (__s1_len > 2U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p1))) +
                                                                3)) - (int const   )(*(__s2___6 +
                                                                                       3)));
                      }
                    }
                  }
                }
              }
            }
            tmp___34 = __result___18;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: 
      tmp___63 = __builtin_constant_p((int )(*((char * const  *)p2)));
      if (tmp___63) {
        if ((unsigned int )((void const   *)((*((char * const  *)p2)) + 1)) - (unsigned int )((void const   *)(*((char * const  *)p2))) ==
            1U) {
          __s2_len = strlen((char const   *)(*((char * const  *)p2)));
          if (__s2_len < 4U) {
            tmp___62 = __builtin_constant_p((int )(*((char * const  *)p1)));
            if (tmp___62) {
              if ((unsigned int )((void const   *)((*((char * const  *)p1)) + 1)) -
                  (unsigned int )((void const   *)(*((char * const  *)p1))) == 1U) {
                tmp___34 = __builtin_strcmp((*((char * const  *)p1)), (*((char * const  *)p2)));
              } else {
                goto _L___13;
              }
            } else {
              _L___13: 
              __s1___14 = (unsigned char const   *)((char const   *)(*((char * const  *)p1)));
              __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p2))) +
                                                                                         0)));
              if (__s2_len > 0U) {
                if (__result___22 == 0) {
                  __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p2))) +
                                                                                             1)));
                  if (__s2_len > 1U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 2)) - (int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p2))) +
                                                                                                 2)));
                      if (__s2_len > 2U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 3)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)(*((char * const  *)p2))) +
                                                                  3)));
                        }
                      }
                    }
                  }
                }
              }
              tmp___34 = __result___22;
            }
          } else {
            tmp___34 = __builtin_strcmp((*((char * const  *)p1)), (*((char * const  *)p2)));
          }
        } else {
          tmp___34 = __builtin_strcmp((*((char * const  *)p1)), (*((char * const  *)p2)));
        }
      } else {
        tmp___34 = __builtin_strcmp((*((char * const  *)p1)), (*((char * const  *)p2)));
      }
    }
  }
  return (tmp___34);
}
}
#pragma merger(0,"/tmp/cil-lXkEirXI.i","-O2")
int log_compare(DB_LSN const   *lsn0 , DB_LSN const   *lsn1 ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (lsn0->file != lsn1->file) {
    if (lsn0->file < lsn1->file) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
  if (lsn0->offset != lsn1->offset) {
    if (lsn0->offset < lsn1->offset) {
      tmp___0 = -1;
    } else {
      tmp___0 = 1;
    }
    return (tmp___0);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-H1dE77IX.i","-O2")
int __log_cursor_pp(DB_ENV *dbenv___0 , DB_LOGC **logcp , u_int32_t flags ) ;
static int __log_c_close_pp(DB_LOGC *logc , u_int32_t flags ) ;
static int __log_c_get_pp(DB_LOGC *logc , DB_LSN *alsn , DBT *dbt , u_int32_t flags ) ;
static int __log_c_get_int(DB_LOGC *logc , DB_LSN *alsn , DBT *dbt , u_int32_t flags ) ;
static int __log_c_hdrchk(DB_LOGC *logc , DB_LSN *lsn , HDR *hdr , int *eofp ) ;
static int __log_c_incursor(DB_LOGC *logc , DB_LSN *lsn , HDR *hdr , u_int8_t **pp ) ;
static int __log_c_inregion(DB_LOGC *logc , DB_LSN *lsn , RLOCK *rlockp , DB_LSN *last_lsn ,
                            HDR *hdr , u_int8_t **pp ) ;
static int __log_c_io(DB_LOGC *logc , u_int32_t fnum , u_int32_t offset , void *p ,
                      size_t *nrp , int *eofp ) ;
static int __log_c_ondisk(DB_LOGC *logc , DB_LSN *lsn , DB_LSN *last_lsn , int flags ,
                          HDR *hdr , u_int8_t **pp , int *eofp ) ;
static int __log_c_set_maxrec(DB_LOGC *logc , char *np ) ;
static int __log_c_shortread(DB_LOGC *logc , DB_LSN *lsn , int check_silent ) ;
int __log_cursor_pp(DB_ENV *dbenv___0 , DB_LOGC **logcp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->log_cursor", 16384U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->log_cursor", flags, 0U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_cursor(dbenv___0, logcp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __log_cursor(DB_ENV *dbenv___0 , DB_LOGC **logcp ) 
{ DB_LOGC *logc ;
  int ret ;

  {
  (*logcp) = (DB_LOGC *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_LOGC ), (void *)(& logc));
  if (ret != 0) {
    return (ret);
  }
  logc->bp_size = 32768U;
  logc->bp_maxrec = 1048576U;
  ret = __os_malloc(dbenv___0, logc->bp_size, (void *)(& logc->bp));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)logc);
    return (ret);
  }
  logc->dbenv = dbenv___0;
  logc->close = & __log_c_close_pp;
  logc->get = & __log_c_get_pp;
  (*logcp) = logc;
  return (0);
}
}
static int __log_c_close_pp(DB_LOGC *logc , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = logc->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_fchk(dbenv___0, "DB_LOGC->close", flags, 0U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_c_close(logc);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __log_c_close(DB_LOGC *logc ) 
{ DB_ENV *dbenv___0 ;

  {
  dbenv___0 = logc->dbenv;
  if ((unsigned int )logc->c_fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, logc->c_fhp);
    logc->c_fhp = (DB_FH *)((void *)0);
  }
  if ((unsigned int )logc->c_dbt.data != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, logc->c_dbt.data);
  }
  __os_free(dbenv___0, (void *)logc->bp);
  __os_free(dbenv___0, (void *)logc);
  return (0);
}
}
static int __log_c_get_pp(DB_LOGC *logc , DB_LSN *alsn , DBT *dbt , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = logc->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  switch ((int )flags) {
  case 7: ;
  case 9: ;
  case 17: ;
  case 18: ;
  case 25: ;
  break;
  case 28: ;
  if (alsn->file == 0U) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: invalid LSN: %lu/%lu", (unsigned long )alsn->file,
             (unsigned long )alsn->offset);
    return (22);
  }
  break;
  default: 
  tmp___0 = __db_ferr((DB_ENV const   *)dbenv___0, "DB_LOGC->get", 1);
  return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_c_get(logc, alsn, dbt, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __log_c_get(DB_LOGC *logc , DB_LSN *alsn , DBT *dbt , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_LSN saved_lsn ;
  int ret ;

  {
  dbenv___0 = logc->dbenv;
  saved_lsn = (*alsn);
  ret = __log_c_get_int(logc, alsn, dbt, flags);
  if (ret != 0) {
    (*alsn) = saved_lsn;
    return (ret);
  }
  if (alsn->offset == 0U) {
    if (flags == 9U) {
      goto _L;
    } else {
      if (flags == 18U) {
        goto _L;
      } else {
        if (flags == 17U) {
          goto _L;
        } else {
          if (flags == 25U) {
            _L: 
            switch ((int )flags) {
            case 9: 
            flags = 18U;
            break;
            case 17: 
            flags = 25U;
            break;
            }
            if (dbt->flags & 4U) {
              __os_free(dbenv___0, dbt->data);
              dbt->data = (void *)0;
            }
            ret = __log_c_get_int(logc, alsn, dbt, flags);
            if (ret != 0) {
              (*alsn) = saved_lsn;
              return (ret);
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static int __log_c_get_int(DB_LOGC *logc , DB_LSN *alsn , DBT *dbt , u_int32_t flags ) 
{ DB_CIPHER *db_cipher ;
  DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  DB_LSN last_lsn ;
  DB_LSN nlsn ;
  HDR hdr ;
  LOG *lp ;
  RLOCK rlock ;
  logfile_validity status ;
  u_int32_t cnt ;
  u_int8_t *rp ;
  int eof ;
  int is_hmac ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = logc->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  is_hmac = 0;
  if (logc->flags & 2U) {
    rlock = (enum __anonenum_RLOCK_69 )0;
  } else {
    rlock = (enum __anonenum_RLOCK_69 )2;
  }
  nlsn = logc->c_lsn;
  switch ((int )flags) {
  case 18: ;
  if (! (nlsn.file == 0U)) {
    nlsn.offset = nlsn.offset + logc->c_len;
    break;
  }
  flags = 9U;
  case 9: 
  ret = __log_find(dblp, 1, & cnt, & status);
  if (ret != 0) {
    goto err;
  }
  switch ((int )status) {
  case 0: ;
  case 2: ;
  case 3: 
  nlsn.file = cnt;
  break;
  case 1: 
  nlsn.file = 1U;
  break;
  case 4: 
  nlsn.file = cnt + 1U;
  break;
  }
  nlsn.offset = 0U;
  break;
  case 7: ;
  break;
  case 25: ;
  if (! (nlsn.file == 0U)) {
    if (nlsn.offset == 0U) {
      if (nlsn.file == 1U) {
        ret = -30990;
        goto err;
      } else {
        tmp = __log_valid(dblp, nlsn.file - 1U, 0, (DB_FH **)((void *)0), 0, & status);
        if (tmp != 0) {
          ret = -30990;
          goto err;
        }
      }
      if ((int )status != 2) {
        if ((int )status != 3) {
          ret = -30990;
          goto err;
        }
      }
      nlsn.file = nlsn.file - 1U;
    }
    nlsn.offset = logc->c_prev;
    break;
  }
  case 17: ;
  if ((int )rlock == 2) {
    rlock = (enum __anonenum_RLOCK_69 )1;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  nlsn.file = lp->lsn.file;
  nlsn.offset = lp->lsn.offset - lp->len;
  break;
  case 28: 
  nlsn = (*alsn);
  break;
  }
  if (0) {
    next_file: 
    nlsn.file = nlsn.file + 1U;
    nlsn.offset = 0U;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    hdr.size = 48U;
    is_hmac = 1;
  } else {
    hdr.size = 12U;
    is_hmac = 0;
  }
  ret = __log_c_incursor(logc, & nlsn, & hdr, & rp);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    goto cksum;
  }
  while (1) {
    last_lsn.file = 0U;
    last_lsn.offset = 0U;
    break;
  }
  if (! (logc->flags & 1U)) {
    goto _L;
  } else {
    tmp___0 = log_compare((DB_LSN const   *)(& nlsn), (DB_LSN const   *)(& logc->c_lsn));
    if (tmp___0 > 0) {
      _L: 
      logc->flags = logc->flags & 4294967294U;
      ret = __log_c_inregion(logc, & nlsn, & rlock, & last_lsn, & hdr, & rp);
      if (ret != 0) {
        goto err;
      }
      if ((unsigned int )rp != (unsigned int )((void *)0)) {
        goto cksum;
      }
    }
  }
  if ((int )rlock == 1) {
    rlock = (enum __anonenum_RLOCK_69 )2;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  ret = __log_c_ondisk(logc, & nlsn, & last_lsn, (int )flags, & hdr, & rp, & eof);
  if (ret != 0) {
    goto err;
  }
  if (eof == 1) {
    if (flags != 18U) {
      return (-30990);
    } else {
      if (nlsn.offset == 0U) {
        return (-30990);
      }
    }
    goto next_file;
  }
  logc->flags = logc->flags | 1U;
  cksum: 
  if ((int )rlock == 1) {
    rlock = (enum __anonenum_RLOCK_69 )2;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  ret = __db_check_chksum(dbenv___0, db_cipher, hdr.chksum, (void *)(rp + hdr.size),
                          hdr.len - hdr.size, is_hmac);
  if (ret != 0) {
    if (logc->flags & 4U) {
      if (ret == 0) {
        ret = 5;
      } else {
        if (ret == -1) {
          ret = 5;
        }
      }
    } else {
      if (ret == -1) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: log record LSN %lu/%lu: checksum mismatch",
                 (unsigned long )nlsn.file, (unsigned long )nlsn.offset);
        __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: catastrophic recovery may be required");
        ret = __db_panic(dbenv___0, -30978);
      }
    }
    goto err;
  }
  if (hdr.len == 0U) {
    switch ((int )flags) {
    case 9: ;
    case 18: ;
    goto next_file;
    case 17: ;
    case 25: 
    __db_err((DB_ENV const   *)dbenv___0, "Encountered zero length records while traversing backwards");
    case 28: ;
    default: ;
    break;
    }
  }
  ret = __db_retcopy(dbenv___0, dbt, (void *)(rp + hdr.size), hdr.len - hdr.size,
                     & logc->c_dbt.data, & logc->c_dbt.ulen);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    ret = ((*(db_cipher->decrypt)))(dbenv___0, db_cipher->data, (void *)(hdr.iv),
                                    (u_int8_t *)dbt->data, hdr.len - hdr.size);
    if (ret != 0) {
      ret = 11;
      goto err;
    }
    dbt->size = hdr.orig_size;
  }
  (*alsn) = nlsn;
  logc->c_lsn = nlsn;
  logc->c_len = hdr.len;
  logc->c_prev = hdr.prev;
  err: 
  if ((int )rlock == 1) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  return (ret);
}
}
static int __log_c_incursor(DB_LOGC *logc , DB_LSN *lsn , HDR *hdr , u_int8_t **pp ) 
{ u_int8_t *p ;
  int eof ;
  int tmp ;

  {
  (*pp) = (u_int8_t *)((void *)0);
  if (logc->bp_lsn.file != lsn->file) {
    return (0);
  }
  if (logc->bp_lsn.offset > lsn->offset) {
    return (0);
  }
  if (logc->bp_lsn.offset + logc->bp_rlen <= lsn->offset + hdr->size) {
    return (0);
  }
  p = logc->bp + (lsn->offset - logc->bp_lsn.offset);
  memcpy((void * __restrict  )hdr, (void const   * __restrict  )p, hdr->size);
  tmp = __log_c_hdrchk(logc, lsn, hdr, & eof);
  if (tmp) {
    return (-30990);
  }
  if (eof) {
    return (0);
  } else {
    if (logc->bp_lsn.offset + logc->bp_rlen < lsn->offset + hdr->len) {
      return (0);
    }
  }
  (*pp) = p;
  return (0);
}
}
static int __log_c_inregion(DB_LOGC *logc , DB_LSN *lsn , RLOCK *rlockp , DB_LSN *last_lsn ,
                            HDR *hdr , u_int8_t **pp ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  LOG *lp ;
  size_t len ;
  size_t nr ;
  u_int32_t b_disk ;
  u_int32_t b_region ;
  int ret ;
  u_int8_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = logc->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)((DB_LOG *)(logc->dbenv)->lg_handle)->reginfo.primary;
  ret = 0;
  (*pp) = (u_int8_t *)((void *)0);
  if ((int )(*rlockp) == 2) {
    (*rlockp) = (enum __anonenum_RLOCK_69 )1;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  (*last_lsn) = lp->lsn;
  if (last_lsn->offset > lp->w_off) {
    last_lsn->offset = lp->w_off;
  }
  if (lp->lsn.file == 0U) {
    return (0);
  }
  if (lsn->file > lp->lsn.file) {
    return (-30990);
  } else {
    if (lsn->file == lp->lsn.file) {
      if (lsn->offset >= lp->lsn.offset) {
        return (-30990);
      }
    }
  }
  if (lp->b_off == 0U) {
    return (0);
  }
  if (lsn->file < lp->f_lsn.file) {
    return (0);
  } else {
    if (lsn->offset < lp->f_lsn.offset) {
      return (0);
    }
  }
  while (1) {
    logc->bp_lsn.file = 0U;
    logc->bp_lsn.offset = 0U;
    break;
  }
  if (lsn->offset > lp->f_lsn.offset) {
    p = dblp->bufp + (lsn->offset - lp->w_off);
    memcpy((void * __restrict  )hdr, (void const   * __restrict  )p, hdr->size);
    tmp = __log_c_hdrchk(logc, lsn, hdr, (int *)((void *)0));
    if (tmp) {
      return (-30990);
    }
    if (lsn->offset + hdr->len > lp->w_off + lp->buffer_size) {
      return (-30990);
    }
    if (logc->bp_size <= hdr->len) {
      len = (unsigned int )((unsigned long long )((hdr->len * 2U + 128U) - 1U) & 0xffffffffffffff80ULL);
      ret = __os_realloc(logc->dbenv, len, (void *)(& logc->bp));
      if (ret != 0) {
        return (ret);
      }
      logc->bp_size = len;
    }
    memcpy((void * __restrict  )logc->bp, (void const   * __restrict  )p, hdr->len);
    (*pp) = logc->bp;
    return (0);
  }
  b_disk = lp->w_off - lsn->offset;
  if (lp->b_off <= lp->len) {
    b_region = lp->b_off;
  } else {
    p = dblp->bufp + (lp->b_off - lp->len);
    while (1) {
      memcpy((void * __restrict  )hdr, (void const   * __restrict  )p, hdr->size);
      if (hdr->prev == lsn->offset) {
        b_region = (unsigned int )(p - dblp->bufp);
        break;
      }
      p = dblp->bufp + (hdr->prev - lp->w_off);
    }
  }
  if (logc->bp_size <= b_region + b_disk) {
    len = (unsigned int )((unsigned long long )(((b_region + b_disk) * 2U + 128U) -
                                                1U) & 0xffffffffffffff80ULL);
    ret = __os_realloc(logc->dbenv, len, (void *)(& logc->bp));
    if (ret != 0) {
      return (ret);
    }
    logc->bp_size = len;
  }
  p = (logc->bp + logc->bp_size) - b_region;
  memcpy((void * __restrict  )p, (void const   * __restrict  )dblp->bufp, b_region);
  if ((int )(*rlockp) == 1) {
    (*rlockp) = (enum __anonenum_RLOCK_69 )2;
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  if (b_disk != 0U) {
    p -= b_disk;
    nr = b_disk;
    ret = __log_c_io(logc, lsn->file, lsn->offset, (void *)p, & nr, (int *)((void *)0));
    if (ret != 0) {
      return (ret);
    }
    if (nr < b_disk) {
      tmp___0 = __log_c_shortread(logc, lsn, 0);
      return (tmp___0);
    }
  }
  memcpy((void * __restrict  )hdr, (void const   * __restrict  )p, hdr->size);
  (*pp) = p;
  return (0);
}
}
static int __log_c_ondisk(DB_LOGC *logc , DB_LSN *lsn , DB_LSN *last_lsn , int flags ,
                          HDR *hdr , u_int8_t **pp , int *eofp ) 
{ DB_ENV *dbenv___0 ;
  size_t len ;
  size_t nr ;
  u_int32_t offset ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = logc->dbenv;
  (*eofp) = 0;
  nr = hdr->size;
  ret = __log_c_io(logc, lsn->file, lsn->offset, (void *)hdr, & nr, eofp);
  if (ret != 0) {
    return (ret);
  }
  if ((*eofp)) {
    return (0);
  }
  if (nr == 0U) {
    (*eofp) = 1;
    return (0);
  }
  ret = __log_c_hdrchk(logc, lsn, hdr, eofp);
  if (ret != 0) {
    return (ret);
  }
  if ((*eofp)) {
    return (0);
  }
  if (nr < hdr->size) {
    tmp = __log_c_shortread(logc, lsn, 1);
    return (tmp);
  }
  while (1) {
    logc->bp_lsn.file = 0U;
    logc->bp_lsn.offset = 0U;
    break;
  }
  if (logc->bp_size <= hdr->len) {
    len = (unsigned int )((unsigned long long )((hdr->len * 2U + 128U) - 1U) & 0xffffffffffffff80ULL);
    ret = __os_realloc(dbenv___0, len, (void *)(& logc->bp));
    if (ret != 0) {
      return (ret);
    }
    logc->bp_size = len;
  }
  if (flags == 9) {
    offset = lsn->offset;
  } else {
    if (flags == 18) {
      offset = lsn->offset;
    } else {
      if (lsn->offset + hdr->len < logc->bp_size) {
        offset = 0U;
      } else {
        offset = (lsn->offset + hdr->len) - logc->bp_size;
      }
    }
  }
  nr = logc->bp_size;
  if (lsn->file == last_lsn->file) {
    if (offset + nr >= last_lsn->offset) {
      nr = last_lsn->offset - offset;
    }
  }
  ret = __log_c_io(logc, lsn->file, offset, (void *)logc->bp, & nr, eofp);
  if (ret != 0) {
    return (ret);
  }
  if (nr < (lsn->offset + hdr->len) - offset) {
    tmp___0 = __log_c_shortread(logc, lsn, 1);
    return (tmp___0);
  }
  logc->bp_rlen = nr;
  logc->bp_lsn.file = lsn->file;
  logc->bp_lsn.offset = offset;
  (*pp) = logc->bp + (lsn->offset - offset);
  return (0);
}
}
static int __log_c_hdrchk(DB_LOGC *logc , DB_LSN *lsn , HDR *hdr , int *eofp ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  char *tmp ;

  {
  dbenv___0 = logc->dbenv;
  if ((unsigned int )eofp != (unsigned int )((void *)0)) {
    if (hdr->prev == 0U) {
      if ((int )hdr->chksum[0] == 0) {
        if (hdr->len == 0U) {
          (*eofp) = 1;
          return (0);
        }
      }
    }
    (*eofp) = 0;
  }
  if (hdr->len <= hdr->size) {
    goto err;
  }
  if (logc->bp_maxrec != 0U) {
    if (hdr->len > logc->bp_maxrec) {
      ret = __log_c_set_maxrec(logc, (char *)((void *)0));
      if (ret != 0) {
        tmp = db_strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: %s", tmp);
        return (ret);
      }
      if (logc->bp_maxrec != 0U) {
        if (hdr->len > logc->bp_maxrec) {
          goto err;
        }
      }
    }
  }
  return (0);
  err: 
  if (! (logc->flags & 4U)) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: LSN %lu/%lu: invalid log record header",
             (unsigned long )lsn->file, (unsigned long )lsn->offset);
  }
  return (5);
}
}
static int __log_c_io(DB_LOGC *logc , u_int32_t fnum , u_int32_t offset , void *p ,
                      size_t *nrp , int *eofp ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  int ret ;
  char *np ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  dbenv___0 = logc->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if ((unsigned int )logc->c_fhp != (unsigned int )((void *)0)) {
    if (logc->bp_lsn.file != fnum) {
      ret = __os_closehandle(dbenv___0, logc->c_fhp);
      logc->c_fhp = (DB_FH *)((void *)0);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if ((unsigned int )logc->c_fhp == (unsigned int )((void *)0)) {
    ret = __log_name(dblp, fnum, & np, & logc->c_fhp, 80U);
    if (ret != 0) {
      if ((unsigned int )eofp != (unsigned int )((void *)0)) {
        (*eofp) = 1;
        ret = 0;
      } else {
        if (! (logc->flags & 4U)) {
          tmp = db_strerror(ret);
          __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: %s: %s", np, tmp);
        }
      }
      __os_free(dbenv___0, (void *)np);
      return (ret);
    }
    ret = __log_c_set_maxrec(logc, np);
    if (ret != 0) {
      tmp___0 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: %s: %s", np, tmp___0);
      __os_free(dbenv___0, (void *)np);
      return (ret);
    }
    __os_free(dbenv___0, (void *)np);
  }
  ret = __os_seek(dbenv___0, logc->c_fhp, 0U, 0U, offset, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    if (! (logc->flags & 4U)) {
      tmp___1 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: LSN: %lu/%lu: seek: %s",
               (unsigned long )fnum, (unsigned long )offset, tmp___1);
    }
    return (ret);
  }
  ret = __os_read(dbenv___0, logc->c_fhp, p, (*nrp), nrp);
  if (ret != 0) {
    if (! (logc->flags & 4U)) {
      tmp___2 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "DB_LOGC->get: LSN: %lu/%lu: read: %s",
               (unsigned long )fnum, (unsigned long )offset, tmp___2);
    }
    return (ret);
  }
  return (0);
}
}
static int __log_c_shortread(DB_LOGC *logc , DB_LSN *lsn , int check_silent ) 
{ 

  {
  if (! check_silent) {
    __db_err((DB_ENV const   *)logc->dbenv, "DB_LOGC->get: LSN: %lu/%lu: short read",
             (unsigned long )lsn->file, (unsigned long )lsn->offset);
  } else {
    if (! (logc->flags & 4U)) {
      __db_err((DB_ENV const   *)logc->dbenv, "DB_LOGC->get: LSN: %lu/%lu: short read",
               (unsigned long )lsn->file, (unsigned long )lsn->offset);
    }
  }
  return (5);
}
}
static int __log_c_set_maxrec(DB_LOGC *logc , char *np ) 
{ DB_ENV *dbenv___0 ;
  DB_LOG *dblp ;
  LOG *lp ;
  u_int32_t mbytes ;
  u_int32_t bytes ;
  int ret ;

  {
  dbenv___0 = logc->dbenv;
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if ((unsigned int )logc->c_fhp != (unsigned int )((void *)0)) {
    ret = __os_ioinfo(dbenv___0, (char const   *)np, logc->c_fhp, & mbytes, & bytes,
                      (u_int32_t *)((void *)0));
    if (ret != 0) {
      return (ret);
    }
    if (logc->bp_maxrec < mbytes * 1048576U + bytes) {
      logc->bp_maxrec = mbytes * 1048576U + bytes;
    }
  }
  lp = (LOG *)dblp->reginfo.primary;
  if (logc->bp_maxrec < lp->buffer_size) {
    logc->bp_maxrec = lp->buffer_size;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-OXKWBo7O.i","-O2")
int __log_put_pp(DB_ENV *dbenv___0 , DB_LSN *lsnp , DBT const   *udbt , u_int32_t flags ) ;
int __log_flush_pp(DB_ENV *dbenv___0 , DB_LSN const   *lsn ) ;
int __log_file_pp(DB_ENV *dbenv___0 , DB_LSN const   *lsn , char *namep , size_t len ) ;
static int __log_get_lg_bsize(DB_ENV *dbenv___0 , u_int32_t *lg_bsizep ) ;
static int __log_get_lg_dir(DB_ENV *dbenv___0 , char const   **dirp ) ;
static int __log_get_lg_max(DB_ENV *dbenv___0 , u_int32_t *lg_maxp ) ;
static int __log_get_lg_regionmax(DB_ENV *dbenv___0 , u_int32_t *lg_regionmaxp ) ;
void __log_dbenv_create(DB_ENV *dbenv___0 ) 
{ 

  {
  dbenv___0->lg_bsize = 32768U;
  dbenv___0->lg_regionmax = 61440U;
  dbenv___0->get_lg_bsize = & __log_get_lg_bsize;
  dbenv___0->set_lg_bsize = & __log_set_lg_bsize;
  dbenv___0->get_lg_dir = & __log_get_lg_dir;
  dbenv___0->set_lg_dir = & __log_set_lg_dir;
  dbenv___0->get_lg_max = & __log_get_lg_max;
  dbenv___0->set_lg_max = & __log_set_lg_max;
  dbenv___0->get_lg_regionmax = & __log_get_lg_regionmax;
  dbenv___0->set_lg_regionmax = & __log_set_lg_regionmax;
  dbenv___0->log_archive = & __log_archive_pp;
  dbenv___0->log_cursor = & __log_cursor_pp;
  dbenv___0->log_file = & __log_file_pp;
  dbenv___0->log_flush = & __log_flush_pp;
  dbenv___0->log_put = & __log_put_pp;
  dbenv___0->log_stat = & __log_stat_pp;
  return;
}
}
static int __log_get_lg_bsize(DB_ENV *dbenv___0 , u_int32_t *lg_bsizep ) 
{ 

  {
  (*lg_bsizep) = dbenv___0->lg_bsize;
  return (0);
}
}
int __log_set_lg_bsize(DB_ENV *dbenv___0 , u_int32_t lg_bsize ) 
{ u_int32_t lg_max ;
  int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lg_bsize", 1);
    return (tmp);
  }
  if (lg_bsize == 0U) {
    lg_bsize = 32768U;
  }
  if (dbenv___0->lg_size == 0U) {
    lg_max = 10485760U;
  } else {
    lg_max = dbenv___0->lg_size;
  }
  if (lg_bsize > lg_max / 4U) {
    __db_err((DB_ENV const   *)dbenv___0, "log buffer size must be <= log file size / 4");
    return (22);
  }
  dbenv___0->lg_bsize = lg_bsize;
  return (0);
}
}
static int __log_get_lg_max(DB_ENV *dbenv___0 , u_int32_t *lg_maxp ) 
{ LOG *region ;
  int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    if (! ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0))) {
      tmp = __db_env_config(dbenv___0, (char *)"get_lg_max", 16384U);
      return (tmp);
    }
    region = (LOG *)((DB_LOG *)dbenv___0->lg_handle)->reginfo.primary;
    (*lg_maxp) = region->log_nsize;
  } else {
    (*lg_maxp) = dbenv___0->lg_size;
  }
  return (0);
}
}
int __log_set_lg_max(DB_ENV *dbenv___0 , u_int32_t lg_max ) 
{ LOG *region ;
  int tmp ;

  {
  if (lg_max == 0U) {
    lg_max = 10485760U;
  }
  if (dbenv___0->flags & 8192U) {
    if (! ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0))) {
      tmp = __db_env_config(dbenv___0, (char *)"set_lg_max", 16384U);
      return (tmp);
    }
    region = (LOG *)((DB_LOG *)dbenv___0->lg_handle)->reginfo.primary;
    if (lg_max < region->buffer_size * 4U) {
      goto err;
    }
    region->log_nsize = lg_max;
  } else {
    if (lg_max < dbenv___0->lg_bsize * 4U) {
      goto err;
    }
    dbenv___0->lg_size = lg_max;
  }
  return (0);
  err: 
  __db_err((DB_ENV const   *)dbenv___0, "log file size must be >= log buffer size * 4");
  return (22);
}
}
static int __log_get_lg_regionmax(DB_ENV *dbenv___0 , u_int32_t *lg_regionmaxp ) 
{ 

  {
  (*lg_regionmaxp) = dbenv___0->lg_regionmax;
  return (0);
}
}
int __log_set_lg_regionmax(DB_ENV *dbenv___0 , u_int32_t lg_regionmax ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_lg_regionmax", 1);
    return (tmp);
  }
  if (lg_regionmax != 0U) {
    if (lg_regionmax < 61440U) {
      __db_err((DB_ENV const   *)dbenv___0, "log file size must be >= %d", 61440);
      return (22);
    }
  }
  dbenv___0->lg_regionmax = lg_regionmax;
  return (0);
}
}
static int __log_get_lg_dir(DB_ENV *dbenv___0 , char const   **dirp ) 
{ 

  {
  (*dirp) = (char const   *)dbenv___0->db_log_dir;
  return (0);
}
}
int __log_set_lg_dir(DB_ENV *dbenv___0 , char const   *dir ) 
{ int tmp ;

  {
  if ((unsigned int )dbenv___0->db_log_dir != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)dbenv___0->db_log_dir);
  }
  tmp = __os_strdup(dbenv___0, dir, (void *)(& dbenv___0->db_log_dir));
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-WTCNtagZ.i","-O2")
int __os_open_extend(DB_ENV *dbenv___0 , char const   *name , u_int32_t log_size ,
                     u_int32_t page_size , u_int32_t flags , int mode , DB_FH **fhpp ) ;
void __log_txn_lsn(DB_ENV *dbenv___0 , DB_LSN *lsnp , u_int32_t *mbytesp , u_int32_t *bytesp ) ;
int __txn_force_abort(DB_ENV *dbenv___0 , u_int8_t *buffer ) ;
static int __log_encrypt_record(DB_ENV *dbenv___0 , DBT *dbt , HDR *hdr , u_int32_t orig ) ;
static int __log_file(DB_ENV *dbenv___0 , DB_LSN const   *lsn , char *namep , size_t len ) ;
static int __log_fill(DB_LOG *dblp , DB_LSN *lsn , void *addr , u_int32_t len ) ;
static int __log_flush_commit(DB_ENV *dbenv___0 , DB_LSN const   *lsnp , u_int32_t flags ) ;
static int __log_newfh(DB_LOG *dblp ) ;
static int __log_put_next(DB_ENV *dbenv___0 , DB_LSN *lsn , DBT const   *dbt , HDR *hdr ,
                          DB_LSN *old_lsnp ) ;
static int __log_putr(DB_LOG *dblp , DB_LSN *lsn , DBT const   *dbt , u_int32_t prev ,
                      HDR *h ) ;
static int __log_write(DB_LOG *dblp , void *addr , u_int32_t len ) ;
int __log_put_pp(DB_ENV *dbenv___0 , DB_LSN *lsnp , DBT const   *udbt , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->log_put", 16384U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->log_put", flags, 111U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 64U) {
    if (flags & 1U) {
      tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "DB_ENV->log_put", 1);
      return (tmp___1);
    }
  }
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    if (((DB_REP *)dbenv___0->rep_handle)->region) {
      if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_put is illegal on replication clients");
        return (22);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_put(dbenv___0, lsnp, udbt, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __log_put(DB_ENV *dbenv___0 , DB_LSN *lsnp , DBT const   *udbt , u_int32_t flags ) 
{ DB_CIPHER *db_cipher ;
  DBT *dbt ;
  DBT t ;
  DB_LOG *dblp ;
  DB_LSN lsn ;
  DB_LSN old_lsn ;
  HDR hdr ;
  LOG *lp ;
  int lock_held ;
  int need_free ;
  int ret ;
  u_int8_t *key ;
  u_int tmp ;
  int tmp___0 ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  dbt = & t;
  t = (*udbt);
  need_free = 0;
  lock_held = need_free;
  if (! (flags & 8U)) {
    goto _L;
  } else {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 8U) {
          _L: 
          if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
            tmp = ((*(db_cipher->adj_size)))(udbt->size);
            t.size = t.size + tmp;
          }
          ret = __os_calloc(dbenv___0, 1U, t.size, (void *)(& t.data));
          if (ret != 0) {
            goto err;
          }
          need_free = 1;
          memcpy((void * __restrict  )t.data, (void const   * __restrict  )udbt->data,
                 udbt->size);
        }
      }
    }
  }
  ret = __log_encrypt_record(dbenv___0, dbt, & hdr, udbt->size);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    key = db_cipher->mac_key;
  } else {
    key = (u_int8_t *)((void *)0);
  }
  __db_chksum((u_int8_t *)dbt->data, dbt->size, key, hdr.chksum);
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  lock_held = 1;
  while (1) {
    old_lsn.file = 0U;
    old_lsn.offset = 0U;
    break;
  }
  ret = __log_put_next(dbenv___0, & lsn, (DBT const   *)dbt, & hdr, & old_lsn);
  if (ret != 0) {
    goto panic_check;
  }
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    if (((DB_REP *)dbenv___0->rep_handle)->region) {
      if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 8U) {
        if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
        }
        lock_held = 0;
        if ((unsigned int )dbenv___0->rep_send == (unsigned int )((void *)0)) {
          __db_err((DB_ENV const   *)dbenv___0, "%s %s", "Non-replication DB_ENV handle attempting",
                   "to modify a replicated environment");
          ret = 22;
          goto err;
        }
        if (! (old_lsn.file == 0U)) {
          __rep_send_message(dbenv___0, -1, 12U, & old_lsn, (DBT const   *)((void *)0),
                             0U);
        }
        tmp___0 = __rep_send_message(dbenv___0, -1, 7U, & lsn, udbt, flags);
        if (tmp___0 != 0) {
          if (flags & 32U) {
            flags |= 1U;
          }
        }
      }
    }
  }
  if (flags & 65U) {
    if (! lock_held) {
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      lock_held = 1;
    }
    ret = __log_flush_commit(dbenv___0, (DB_LSN const   *)(& lsn), flags);
    if (ret != 0) {
      goto panic_check;
    }
  }
  (*lsnp) = lsn;
  if (flags & 2U) {
    lp->stat.st_wc_mbytes = 0U;
    lp->stat.st_wc_bytes = lp->stat.st_wc_mbytes;
  }
  if (0) {
    panic_check: 
    if (ret != 0) {
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if (((DB_REP *)dbenv___0->rep_handle)->region) {
          if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 8U) {
            ret = __db_panic(dbenv___0, ret);
          }
        }
      }
    }
  }
  err: 
  if (lock_held) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  if (need_free) {
    __os_free(dbenv___0, dbt->data);
  }
  if (ret == 0) {
    if (dbenv___0->flags & 512U) {
      if (! (old_lsn.file == 0U)) {
        __log_autoremove(dbenv___0);
      }
    }
  }
  return (ret);
}
}
void __log_txn_lsn(DB_ENV *dbenv___0 , DB_LSN *lsnp , u_int32_t *mbytesp , u_int32_t *bytesp ) 
{ DB_LOG *dblp ;
  LOG *lp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  (*lsnp) = lp->lsn;
  if (lp->lsn.offset > lp->len) {
    lsnp->offset = lsnp->offset - lp->len;
  }
  if ((unsigned int )mbytesp != (unsigned int )((void *)0)) {
    (*mbytesp) = lp->stat.st_wc_mbytes;
    (*bytesp) = lp->stat.st_wc_bytes + lp->b_off;
  }
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  return;
}
}
static int __log_put_next(DB_ENV *dbenv___0 , DB_LSN *lsn , DBT const   *dbt , HDR *hdr ,
                          DB_LSN *old_lsnp ) 
{ DB_LOG *dblp ;
  DB_LSN old_lsn ;
  LOG *lp ;
  int newfile ;
  int ret ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  old_lsn = lp->lsn;
  newfile = 0;
  if (lp->lsn.offset == 0U) {
    goto _L;
  } else {
    if ((lp->lsn.offset + hdr->size) + dbt->size > lp->log_size) {
      _L: 
      if ((hdr->size + sizeof(LOGP )) + dbt->size > lp->log_size) {
        __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_put: record larger than maximum file size (%lu > %lu)",
                 ((unsigned long )hdr->size + (unsigned long )sizeof(LOGP )) + (unsigned long )dbt->size,
                 (unsigned long )lp->log_size);
        return (22);
      }
      ret = __log_newfile(dblp, (DB_LSN *)((void *)0));
      if (ret != 0) {
        return (ret);
      }
      newfile = 1;
    }
  }
  (*lsn) = lp->lsn;
  if (newfile) {
    (*old_lsnp) = old_lsn;
  }
  tmp = __log_putr(dblp, lsn, dbt, lp->lsn.offset - lp->len, hdr);
  return (tmp);
}
}
static int __log_flush_commit(DB_ENV *dbenv___0 , DB_LSN const   *lsnp , u_int32_t flags ) 
{ DB_LOG *dblp ;
  DB_LSN flush_lsn ;
  LOG *lp ;
  int ret ;
  int tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  flush_lsn = (*lsnp);
  ret = 0;
  if (flags & 1U) {
    ret = __log_flush_int(dblp, (DB_LSN const   *)(& flush_lsn), 1);
  } else {
    if (lp->b_off != 0U) {
      ret = __log_write(dblp, (void *)dblp->bufp, lp->b_off);
      if (ret == 0) {
        lp->b_off = 0U;
      }
    }
  }
  if (ret == 0) {
    return (ret);
  } else {
    if (! (flags & 4U)) {
      return (ret);
    }
  }
  if (flush_lsn.file != lp->lsn.file) {
    return (0);
  } else {
    if (flush_lsn.offset < lp->w_off) {
      return (0);
    }
  }
  tmp = __txn_force_abort(dbenv___0, (dblp->bufp + flush_lsn.offset) - lp->w_off);
  if (tmp == 0) {
    __log_flush_int(dblp, (DB_LSN const   *)(& flush_lsn), 0);
  }
  return (ret);
}
}
int __log_newfile(DB_LOG *dblp , DB_LSN *lsnp ) 
{ DB_CIPHER *db_cipher ;
  DB_ENV *dbenv___0 ;
  DB_LSN lsn ;
  DBT t ;
  HDR hdr ;
  LOG *lp ;
  int need_free ;
  int ret ;
  u_int32_t lastoff ;
  size_t tsize ;
  u_int8_t *tmp ;
  u_int tmp___0 ;
  u_int8_t *tmp___1 ;
  u_int32_t tmp___2 ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  if (lp->lsn.offset != 0U) {
    ret = __log_flush_int(dblp, (DB_LSN const   *)((void *)0), 0);
    if (ret != 0) {
      return (ret);
    }
    lastoff = lp->lsn.offset;
    lp->lsn.file = lp->lsn.file + 1U;
    lp->lsn.offset = 0U;
    lp->w_off = 0U;
  } else {
    lastoff = 0U;
  }
  memset((void *)(& t), 0, sizeof(t));
  memset((void *)(& hdr), 0, sizeof(HDR ));
  need_free = 0;
  tsize = sizeof(LOGP );
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    tmp___0 = ((*(db_cipher->adj_size)))(tsize);
    tsize += tmp___0;
  }
  ret = __os_calloc(dbenv___0, 1U, tsize, (void *)(& tmp));
  if (ret != 0) {
    return (ret);
  }
  lp->log_size = lp->log_nsize;
  lp->persist.log_size = lp->log_size;
  memcpy((void * __restrict  )tmp, (void const   * __restrict  )(& lp->persist), sizeof(LOGP ));
  t.data = (void *)tmp;
  t.size = tsize;
  need_free = 1;
  ret = __log_encrypt_record(dbenv___0, & t, & hdr, tsize);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    tmp___1 = db_cipher->mac_key;
  } else {
    tmp___1 = (u_int8_t *)((void *)0);
  }
  __db_chksum((u_int8_t *)t.data, t.size, tmp___1, hdr.chksum);
  lsn = lp->lsn;
  if (lastoff == 0U) {
    tmp___2 = 0U;
  } else {
    tmp___2 = lastoff - lp->len;
  }
  ret = __log_putr(dblp, & lsn, (DBT const   *)(& t), tmp___2, & hdr);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )lsnp != (unsigned int )((void *)0)) {
    (*lsnp) = lp->lsn;
  }
  err: 
  if (need_free) {
    __os_free(dbenv___0, (void *)tmp);
  }
  return (ret);
}
}
static int __log_putr(DB_LOG *dblp , DB_LSN *lsn , DBT const   *dbt , u_int32_t prev ,
                      HDR *h ) 
{ DB_CIPHER *db_cipher ;
  DB_ENV *dbenv___0 ;
  DB_LSN f_lsn ;
  LOG *lp ;
  HDR tmp ;
  HDR *hdr ;
  int ret ;
  int t_ret ;
  size_t b_off ;
  size_t nr ;
  u_int32_t w_off ;
  u_int8_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if ((unsigned int )h == (unsigned int )((void *)0)) {
    hdr = & tmp;
    memset((void *)hdr, 0, sizeof(HDR ));
    if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
      hdr->size = 48U;
    } else {
      hdr->size = 12U;
    }
  } else {
    hdr = h;
  }
  b_off = lp->b_off;
  w_off = lp->w_off;
  f_lsn = lp->f_lsn;
  hdr->prev = prev;
  hdr->len = hdr->size + dbt->size;
  if ((int )hdr->chksum[0] == 0) {
    if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
      tmp___0 = db_cipher->mac_key;
    } else {
      tmp___0 = (u_int8_t *)((void *)0);
    }
    __db_chksum((u_int8_t *)dbt->data, dbt->size, tmp___0, hdr->chksum);
  }
  ret = __log_fill(dblp, lsn, (void *)hdr, hdr->size);
  if (ret != 0) {
    goto err;
  }
  ret = __log_fill(dblp, lsn, dbt->data, dbt->size);
  if (ret != 0) {
    goto err;
  }
  lp->len = hdr->size + dbt->size;
  lp->lsn.offset = lp->lsn.offset + (hdr->size + dbt->size);
  return (0);
  err: 
  if (w_off + lp->buffer_size < lp->w_off) {
    t_ret = __os_seek(dbenv___0, dblp->lfhp, 0U, 0U, w_off, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
    if (t_ret != 0) {
      tmp___1 = __db_panic(dbenv___0, t_ret);
      return (tmp___1);
    } else {
      t_ret = __os_read(dbenv___0, dblp->lfhp, (void *)dblp->bufp, b_off, & nr);
      if (t_ret != 0) {
        tmp___1 = __db_panic(dbenv___0, t_ret);
        return (tmp___1);
      }
    }
    if (nr != b_off) {
      __db_err((DB_ENV const   *)dbenv___0, "Short read while restoring log");
      tmp___2 = __db_panic(dbenv___0, 5);
      return (tmp___2);
    }
  }
  lp->w_off = w_off;
  lp->b_off = b_off;
  lp->f_lsn = f_lsn;
  return (ret);
}
}
int __log_flush_pp(DB_ENV *dbenv___0 , DB_LSN const   *lsn ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->log_flush", 16384U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_flush(dbenv___0, lsn);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __log_flush(DB_ENV *dbenv___0 , DB_LSN const   *lsn ) 
{ DB_LOG *dblp ;
  int ret ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  ret = __log_flush_int(dblp, lsn, 1);
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __log_flush_int(DB_LOG *dblp , DB_LSN const   *lsnp , int release ) 
{ struct __db_commit *commit ;
  DB_ENV *dbenv___0 ;
  DB_LSN flush_lsn ;
  DB_LSN f_lsn ;
  DB_MUTEX *flush_mutexp ;
  LOG *lp ;
  size_t b_off ;
  u_int32_t ncommit ;
  u_int32_t w_off ;
  int do_flush ;
  int first ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  flush_mutexp = (DB_MUTEX *)((void *)((u_int8_t *)dblp->reginfo.addr + lp->flush_mutex_off));
  ncommit = 0U;
  ret = 0;
  if ((unsigned int )lsnp == (unsigned int )((void *)0)) {
    flush_lsn.file = lp->lsn.file;
    flush_lsn.offset = lp->lsn.offset - lp->len;
  } else {
    if (lsnp->file > lp->lsn.file) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_flush: LSN of %lu/%lu past current end-of-log of %lu/%lu",
               (unsigned long )lsnp->file, (unsigned long )lsnp->offset, (unsigned long )lp->lsn.file,
               (unsigned long )lp->lsn.offset);
      __db_err((DB_ENV const   *)dbenv___0, "%s %s %s", "Database environment corrupt; the wrong log files may",
               "have been removed or incompatible database files imported", "from another environment");
      return (22);
    } else {
      if (lsnp->file == lp->lsn.file) {
        if (lsnp->offset > lp->lsn.offset - lp->len) {
          __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_flush: LSN of %lu/%lu past current end-of-log of %lu/%lu",
                   (unsigned long )lsnp->file, (unsigned long )lsnp->offset, (unsigned long )lp->lsn.file,
                   (unsigned long )lp->lsn.offset);
          __db_err((DB_ENV const   *)dbenv___0, "%s %s %s", "Database environment corrupt; the wrong log files may",
                   "have been removed or incompatible database files imported", "from another environment");
          return (22);
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (lp->s_lsn.file > lsnp->file) {
          return (0);
        }
        if (lp->s_lsn.file == lsnp->file) {
          if (lp->s_lsn.offset > lsnp->offset) {
            return (0);
          }
        }
        flush_lsn = (*lsnp);
      }
    }
  }
  if (release) {
    if (lp->in_flush != 0) {
      if (lp->free_commits.stqh_first == -1) {
        commit = (struct __db_commit *)((void *)0);
      } else {
        commit = (struct __db_commit *)((u_int8_t *)(& lp->free_commits) + lp->free_commits.stqh_first);
      }
      if ((unsigned int )commit == (unsigned int )((void *)0)) {
        ret = __db_shalloc(dblp->reginfo.addr, sizeof(struct __db_commit ), 1U, (void *)(& commit));
        if (ret != 0) {
          goto flush;
        }
        memset((void *)commit, 0, sizeof((*commit)));
        ret = __db_mutex_setup(dbenv___0, & dblp->reginfo, (void *)(& commit->mutex),
                               192U);
        if (ret != 0) {
          __db_shalloc_free(dblp->reginfo.addr, (void *)commit);
          return (ret);
        }
        if (! (commit->mutex.flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, & commit->mutex);
        }
      } else {
        while (1) {
          if (commit->links.stqe_next != -1) {
            ((struct __db_commit *)((u_int8_t *)commit + commit->links.stqe_next))->links.stqe_prev = commit->links.stqe_prev +
                                                                                                      ((u_int8_t *)commit -
                                                                                                       (u_int8_t *)((struct __db_commit *)((u_int8_t *)commit +
                                                                                                                                           commit->links.stqe_next)));
            (*((ssize_t *)((u_int8_t *)commit + commit->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)commit +
                                                                                            commit->links.stqe_prev))) +
                                                                             commit->links.stqe_next;
          } else {
            lp->free_commits.stqh_last = commit->links.stqe_prev + ((u_int8_t *)commit -
                                                                    (u_int8_t *)(& lp->free_commits));
            (*((ssize_t *)((u_int8_t *)commit + commit->links.stqe_prev))) = -1;
          }
          break;
        }
      }
      lp->ncommit = lp->ncommit + 1U;
      tmp = log_compare((DB_LSN const   *)(& lp->t_lsn), (DB_LSN const   *)(& flush_lsn));
      if (tmp < 0) {
        lp->t_lsn = flush_lsn;
      }
      commit->lsn = flush_lsn;
      while (1) {
        if (lp->commits.stqh_first != -1) {
          commit->links.stqe_next = lp->commits.stqh_first - ((u_int8_t *)commit -
                                                              (u_int8_t *)(& lp->commits));
          if (commit->links.stqe_next == -1) {
            ((struct __db_commit *)((u_int8_t *)(& lp->commits) + lp->commits.stqh_first))->links.stqe_prev = 0;
          } else {
            ((struct __db_commit *)((u_int8_t *)(& lp->commits) + lp->commits.stqh_first))->links.stqe_prev = - commit->links.stqe_next +
                                                                                                              ((u_int8_t *)(& commit->links.stqe_next) -
                                                                                                               (u_int8_t *)commit);
          }
        } else {
          lp->commits.stqh_last = (u_int8_t *)(& commit->links.stqe_next) - (u_int8_t *)(& lp->commits);
          commit->links.stqe_next = -1;
        }
        lp->commits.stqh_first = (u_int8_t *)commit - (u_int8_t *)(& lp->commits);
        commit->links.stqe_prev = (u_int8_t *)(& lp->commits.stqh_first) - (u_int8_t *)commit;
        break;
      }
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      if (! (commit->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & commit->mutex);
      }
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
      lp->ncommit = lp->ncommit - 1U;
      do_flush = (int )(commit->flags & 1U);
      commit->flags &= 4294967294U;
      while (1) {
        if (lp->free_commits.stqh_first != -1) {
          commit->links.stqe_next = lp->free_commits.stqh_first - ((u_int8_t *)commit -
                                                                   (u_int8_t *)(& lp->free_commits));
          if (commit->links.stqe_next == -1) {
            ((struct __db_commit *)((u_int8_t *)(& lp->free_commits) + lp->free_commits.stqh_first))->links.stqe_prev = 0;
          } else {
            ((struct __db_commit *)((u_int8_t *)(& lp->free_commits) + lp->free_commits.stqh_first))->links.stqe_prev = - commit->links.stqe_next +
                                                                                                                        ((u_int8_t *)(& commit->links.stqe_next) -
                                                                                                                         (u_int8_t *)commit);
          }
        } else {
          lp->free_commits.stqh_last = (u_int8_t *)(& commit->links.stqe_next) - (u_int8_t *)(& lp->free_commits);
          commit->links.stqe_next = -1;
        }
        lp->free_commits.stqh_first = (u_int8_t *)commit - (u_int8_t *)(& lp->free_commits);
        commit->links.stqe_prev = (u_int8_t *)(& lp->free_commits.stqh_first) - (u_int8_t *)commit;
        break;
      }
      if (do_flush) {
        lp->in_flush = lp->in_flush - 1;
        flush_lsn = lp->t_lsn;
      } else {
        return (0);
      }
    }
  }
  flush: 
  if (! (flush_mutexp->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, flush_mutexp);
  }
  if (flush_lsn.file < lp->s_lsn.file) {
    goto _L___0;
  } else {
    if (flush_lsn.file == lp->s_lsn.file) {
      if (flush_lsn.offset < lp->s_lsn.offset) {
        _L___0: 
        if (! (flush_mutexp->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, flush_mutexp);
        }
        goto done;
      }
    }
  }
  if (lp->b_off != 0U) {
    tmp___0 = log_compare((DB_LSN const   *)(& flush_lsn), (DB_LSN const   *)(& lp->f_lsn));
    if (tmp___0 >= 0) {
      ret = __log_write(dblp, (void *)dblp->bufp, lp->b_off);
      if (ret != 0) {
        if (! (flush_mutexp->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, flush_mutexp);
        }
        goto done;
      }
      lp->b_off = 0U;
    }
  }
  if ((unsigned int )dblp->lfhp == (unsigned int )((void *)0)) {
    goto _L___1;
  } else {
    if (dblp->lfname != lp->lsn.file) {
      _L___1: 
      ret = __log_newfh(dblp);
      if (ret != 0) {
        if (! (flush_mutexp->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, flush_mutexp);
        }
        goto done;
      }
    }
  }
  b_off = lp->b_off;
  w_off = lp->w_off;
  f_lsn = lp->f_lsn;
  lp->in_flush = lp->in_flush + 1;
  if (release) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  ret = __os_fsync(dbenv___0, dblp->lfhp);
  if (ret != 0) {
    if (! (flush_mutexp->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, flush_mutexp);
    }
    if (release) {
      if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
      }
    }
    ret = __db_panic(dbenv___0, ret);
    return (ret);
  }
  lp->s_lsn = f_lsn;
  if (b_off == 0U) {
    lp->s_lsn.offset = w_off;
  }
  if (! (flush_mutexp->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, flush_mutexp);
  }
  if (release) {
    if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
    }
  }
  lp->in_flush = lp->in_flush - 1;
  lp->stat.st_scount = lp->stat.st_scount + 1U;
  ncommit = 1U;
  done: 
  if (lp->ncommit != 0U) {
    first = 1;
    if (lp->commits.stqh_first == -1) {
      commit = (struct __db_commit *)((void *)0);
    } else {
      commit = (struct __db_commit *)((u_int8_t *)(& lp->commits) + lp->commits.stqh_first);
    }
    while ((unsigned int )commit != (unsigned int )((void *)0)) {
      tmp___1 = log_compare((DB_LSN const   *)(& lp->s_lsn), (DB_LSN const   *)(& commit->lsn));
      if (tmp___1 > 0) {
        if (! (commit->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & commit->mutex);
        }
        while (1) {
          if (commit->links.stqe_next != -1) {
            ((struct __db_commit *)((u_int8_t *)commit + commit->links.stqe_next))->links.stqe_prev = commit->links.stqe_prev +
                                                                                                      ((u_int8_t *)commit -
                                                                                                       (u_int8_t *)((struct __db_commit *)((u_int8_t *)commit +
                                                                                                                                           commit->links.stqe_next)));
            (*((ssize_t *)((u_int8_t *)commit + commit->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)commit +
                                                                                            commit->links.stqe_prev))) +
                                                                             commit->links.stqe_next;
          } else {
            lp->commits.stqh_last = commit->links.stqe_prev + ((u_int8_t *)commit -
                                                               (u_int8_t *)(& lp->commits));
            (*((ssize_t *)((u_int8_t *)commit + commit->links.stqe_prev))) = -1;
          }
          break;
        }
        ncommit ++;
      } else {
        if (first == 1) {
          commit->flags |= 1U;
          if (! (commit->mutex.flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, & commit->mutex);
          }
          while (1) {
            if (commit->links.stqe_next != -1) {
              ((struct __db_commit *)((u_int8_t *)commit + commit->links.stqe_next))->links.stqe_prev = commit->links.stqe_prev +
                                                                                                        ((u_int8_t *)commit -
                                                                                                         (u_int8_t *)((struct __db_commit *)((u_int8_t *)commit +
                                                                                                                                             commit->links.stqe_next)));
              (*((ssize_t *)((u_int8_t *)commit + commit->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)commit +
                                                                                              commit->links.stqe_prev))) +
                                                                               commit->links.stqe_next;
            } else {
              lp->commits.stqh_last = commit->links.stqe_prev + ((u_int8_t *)commit -
                                                                 (u_int8_t *)(& lp->commits));
              (*((ssize_t *)((u_int8_t *)commit + commit->links.stqe_prev))) = -1;
            }
            break;
          }
          lp->in_flush = lp->in_flush + 1;
          first = 0;
        }
      }
      if (commit->links.stqe_next == -1) {
        commit = (struct __db_commit *)((void *)0);
      } else {
        commit = (struct __db_commit *)((u_int8_t *)commit + commit->links.stqe_next);
      }
    }
  }
  if (lp->stat.st_maxcommitperflush < ncommit) {
    lp->stat.st_maxcommitperflush = ncommit;
  }
  if (lp->stat.st_mincommitperflush > ncommit) {
    lp->stat.st_mincommitperflush = ncommit;
  } else {
    if (lp->stat.st_mincommitperflush == 0U) {
      lp->stat.st_mincommitperflush = ncommit;
    }
  }
  return (ret);
}
}
static int __log_fill(DB_LOG *dblp , DB_LSN *lsn , void *addr , u_int32_t len ) 
{ LOG *lp ;
  u_int32_t bsize ;
  u_int32_t nrec ;
  size_t nw ;
  size_t remain ;
  int ret ;

  {
  lp = (LOG *)dblp->reginfo.primary;
  bsize = lp->buffer_size;
  while (len > 0U) {
    if (lp->b_off == 0U) {
      lp->f_lsn = (*lsn);
    }
    if (lp->b_off == 0U) {
      if (len >= bsize) {
        nrec = len / bsize;
        ret = __log_write(dblp, addr, nrec * bsize);
        if (ret != 0) {
          return (ret);
        }
        addr = (void *)((u_int8_t *)addr + nrec * bsize);
        len -= nrec * bsize;
        lp->stat.st_wcount_fill = lp->stat.st_wcount_fill + 1U;
        continue;
      }
    }
    remain = bsize - lp->b_off;
    if (remain > len) {
      nw = len;
    } else {
      nw = remain;
    }
    memcpy((void * __restrict  )(dblp->bufp + lp->b_off), (void const   * __restrict  )addr,
           nw);
    addr = (void *)((u_int8_t *)addr + nw);
    len -= nw;
    lp->b_off = lp->b_off + nw;
    if (lp->b_off == bsize) {
      ret = __log_write(dblp, (void *)dblp->bufp, bsize);
      if (ret != 0) {
        return (ret);
      }
      lp->b_off = 0U;
      lp->stat.st_wcount_fill = lp->stat.st_wcount_fill + 1U;
    }
  }
  return (0);
}
}
static int __log_write(DB_LOG *dblp , void *addr , u_int32_t len ) 
{ DB_ENV *dbenv___0 ;
  LOG *lp ;
  size_t nw ;
  int ret ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  if ((unsigned int )dblp->lfhp == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if (dblp->lfname != lp->lsn.file) {
      _L: 
      ret = __log_newfh(dblp);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  ret = __os_seek(dbenv___0, dblp->lfhp, 0U, 0U, lp->w_off, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    return (ret);
  } else {
    ret = __os_write(dbenv___0, dblp->lfhp, addr, len, & nw);
    if (ret != 0) {
      return (ret);
    }
  }
  lp->w_off = lp->w_off + len;
  lp->stat.st_w_bytes = lp->stat.st_w_bytes + len;
  if (lp->stat.st_w_bytes >= 1048576U) {
    lp->stat.st_w_bytes = lp->stat.st_w_bytes - 1048576U;
    lp->stat.st_w_mbytes = lp->stat.st_w_mbytes + 1U;
  }
  lp->stat.st_wc_bytes = lp->stat.st_wc_bytes + len;
  if (lp->stat.st_wc_bytes >= 1048576U) {
    lp->stat.st_wc_bytes = lp->stat.st_wc_bytes - 1048576U;
    lp->stat.st_wc_mbytes = lp->stat.st_wc_mbytes + 1U;
  }
  lp->stat.st_wcount = lp->stat.st_wcount + 1U;
  return (0);
}
}
int __log_file_pp(DB_ENV *dbenv___0 , DB_LSN const   *lsn , char *namep , size_t len ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->log_file", 16384U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __log_file(dbenv___0, lsn, namep, len);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __log_file(DB_ENV *dbenv___0 , DB_LSN const   *lsn , char *namep , size_t len ) 
{ DB_LOG *dblp ;
  int ret ;
  char *name ;
  size_t tmp ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  ret = __log_name(dblp, lsn->file, & name, (DB_FH **)((void *)0), 0U);
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (ret != 0) {
    return (ret);
  }
  tmp = strlen((char const   *)name);
  if (len < tmp + 1U) {
    (*namep) = (char )'\000';
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_file: name buffer is too short");
    return (22);
  }
  strcpy((char * __restrict  )namep, (char const   * __restrict  )name);
  __os_free(dbenv___0, (void *)name);
  return (0);
}
}
static int __log_newfh(DB_LOG *dblp ) 
{ DB_ENV *dbenv___0 ;
  LOG *lp ;
  u_int32_t flags ;
  int ret ;
  logfile_validity status ;
  int tmp ;
  char *tmp___0 ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  if ((unsigned int )dblp->lfhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, dblp->lfhp);
    dblp->lfhp = (DB_FH *)((void *)0);
  }
  if (dbenv___0->flags & 64U) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  flags = (unsigned int )(65 | tmp);
  dblp->lfname = lp->lsn.file;
  ret = __log_valid(dblp, dblp->lfname, 0, & dblp->lfhp, (int )flags, & status);
  if (ret != 0) {
    tmp___0 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "DB_ENV->log_put: %d: %s", lp->lsn.file,
             tmp___0);
  } else {
    if ((int )status != 2) {
      if ((int )status != 0) {
        ret = -30990;
      }
    }
  }
  return (ret);
}
}
int __log_name(DB_LOG *dblp , u_int32_t filenumber , char **namep , DB_FH **fhpp ,
               u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  LOG *lp ;
  int ret ;
  char *oname ;
  char old[(int )((sizeof("log.") + 5U) + 20U)] ;
  char new[(int )((sizeof("log.") + 10U) + 20U)] ;
  char *tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dblp->dbenv;
  lp = (LOG *)dblp->reginfo.primary;
  snprintf((char * __restrict  )(new), sizeof(new), (char const   * __restrict  )"log.%010d",
           filenumber);
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )2, (char const   *)(new),
                     0U, (DB_FH **)((void *)0), namep);
  if (ret != 0) {
    return (ret);
  } else {
    if ((unsigned int )fhpp == (unsigned int )((void *)0)) {
      return (ret);
    }
  }
  ret = __os_open_extend(dbenv___0, (char const   *)(*namep), lp->log_size, 0U, flags,
                         (int )lp->persist.mode, fhpp);
  if (ret == 0) {
    return (0);
  }
  if (! (flags & 16U)) {
    tmp = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: log file open failed: %s", (*namep),
             tmp);
    tmp___0 = __db_panic(dbenv___0, ret);
    return (tmp___0);
  }
  snprintf((char * __restrict  )(old), sizeof(old), (char const   * __restrict  )"log.%05d",
           filenumber);
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )2, (char const   *)(old),
                     0U, (DB_FH **)((void *)0), & oname);
  if (ret != 0) {
    goto err;
  }
  ret = __os_open(dbenv___0, (char const   *)oname, flags, (int )lp->persist.mode,
                  fhpp);
  if (ret == 0) {
    __os_free(dbenv___0, (void *)(*namep));
    (*namep) = oname;
    return (0);
  }
  err: 
  __os_free(dbenv___0, (void *)oname);
  return (ret);
}
}
int __log_rep_put(DB_ENV *dbenv___0 , DB_LSN *lsnp , DBT const   *rec ) 
{ DB_CIPHER *db_cipher ;
  DB_LOG *dblp ;
  HDR hdr ;
  DBT *dbt ;
  DBT t ;
  LOG *lp ;
  int need_free ;
  int ret ;
  u_int tmp ;
  u_int8_t *tmp___0 ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  lp = (LOG *)dblp->reginfo.primary;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  memset((void *)(& hdr), 0, sizeof(HDR ));
  t = (*rec);
  dbt = & t;
  need_free = 0;
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    tmp = ((*(db_cipher->adj_size)))(rec->size);
    t.size = t.size + tmp;
  }
  ret = __os_calloc(dbenv___0, 1U, t.size, (void *)(& t.data));
  if (ret != 0) {
    goto err;
  }
  need_free = 1;
  memcpy((void * __restrict  )t.data, (void const   * __restrict  )rec->data, rec->size);
  ret = __log_encrypt_record(dbenv___0, dbt, & hdr, rec->size);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    tmp___0 = db_cipher->mac_key;
  } else {
    tmp___0 = (u_int8_t *)((void *)0);
  }
  __db_chksum((u_int8_t *)t.data, t.size, tmp___0, hdr.chksum);
  ret = __log_putr(dblp, lsnp, (DBT const   *)dbt, lp->lsn.offset - lp->len, & hdr);
  err: 
  lp->ready_lsn = lp->lsn;
  if (! ((dblp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (dblp->reginfo.rp)->mutex);
  }
  if (need_free) {
    __os_free(dbenv___0, t.data);
  }
  return (ret);
}
}
static int __log_encrypt_record(DB_ENV *dbenv___0 , DBT *dbt , HDR *hdr , u_int32_t orig ) 
{ DB_CIPHER *db_cipher ;
  int ret ;

  {
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
    hdr->size = 48U;
    hdr->orig_size = orig;
    ret = ((*(db_cipher->encrypt)))(dbenv___0, db_cipher->data, (void *)(hdr->iv),
                                    (u_int8_t *)dbt->data, dbt->size);
    if (ret != 0) {
      return (ret);
    }
  } else {
    hdr->size = 12U;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-RtoU17u8.i","-O2")
int __memp_alloc(DB_MPOOL *dbmp , REGINFO *memreg , MPOOLFILE *mfp , size_t len ,
                 roff_t *offsetp , void *retp ) ;
int __memp_bhwrite(DB_MPOOL *dbmp , DB_MPOOL_HASH *hp , MPOOLFILE *mfp , BH *bhp ,
                   int open_extents ) ;
void __memp_bhfree(DB_MPOOL *dbmp , DB_MPOOL_HASH *hp , BH *bhp , int free_mem ) ;
int __memp_sync_int(DB_ENV *dbenv___0 , DB_MPOOLFILE *dbmfp , int trickle_max , db_sync_op op ,
                    int *wrotep ) ;
static void __memp_bad_buffer(DB_MPOOL_HASH *hp ) ;
int __memp_alloc(DB_MPOOL *dbmp , REGINFO *memreg , MPOOLFILE *mfp , size_t len ,
                 roff_t *offsetp , void *retp ) 
{ BH *bhp ;
  DB_ENV *dbenv___0 ;
  DB_MPOOL_HASH *dbht ;
  DB_MPOOL_HASH *hp ;
  DB_MPOOL_HASH *hp_end ;
  DB_MPOOL_HASH *hp_tmp ;
  DB_MUTEX *mutexp ;
  MPOOL *c_mp ;
  MPOOLFILE *bh_mfp ;
  size_t freed_space ;
  u_int32_t buckets ;
  u_int32_t buffers ;
  u_int32_t high_priority ;
  u_int32_t priority ;
  u_int32_t put_counter ;
  u_int32_t total_buckets ;
  int aggressive ;
  int giveup ;
  int ret ;
  void *p ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  struct __bh *tmp___1 ;
  size_t tmp___2 ;

  {
  dbenv___0 = dbmp->dbenv;
  c_mp = (MPOOL *)memreg->primary;
  dbht = (DB_MPOOL_HASH *)((void *)((u_int8_t *)memreg->addr + c_mp->htab));
  hp_end = dbht + c_mp->htab_buckets;
  total_buckets = 0U;
  put_counter = total_buckets;
  buffers = put_counter;
  buckets = buffers;
  giveup = 0;
  aggressive = giveup;
  hp_tmp = (DB_MPOOL_HASH *)((void *)0);
  c_mp->stat.st_alloc = c_mp->stat.st_alloc + 1U;
  if ((unsigned int )mfp != (unsigned int )((void *)0)) {
    len = (sizeof(BH ) - sizeof(u_int8_t )) + mfp->stat.st_pagesize;
  }
  if (! ((memreg->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (memreg->rp)->mutex);
  }
  high_priority = c_mp->lru_count - c_mp->stat.st_pages / 10U;
  alloc: 
  ret = __db_shalloc(memreg->addr, len, 1U, (void *)(& p));
  if (ret == 0) {
    if ((unsigned int )mfp != (unsigned int )((void *)0)) {
      c_mp->stat.st_pages = c_mp->stat.st_pages + 1U;
    }
    if (! ((memreg->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (memreg->rp)->mutex);
    }
    found: 
    if ((unsigned int )offsetp != (unsigned int )((void *)0)) {
      (*offsetp) = (unsigned int )((u_int8_t *)p - (u_int8_t *)memreg->addr);
    }
    (*((void **)retp)) = p;
    total_buckets += buckets;
    if (total_buckets != 0U) {
      if (total_buckets > c_mp->stat.st_alloc_max_buckets) {
        c_mp->stat.st_alloc_max_buckets = total_buckets;
      }
      c_mp->stat.st_alloc_buckets = c_mp->stat.st_alloc_buckets + total_buckets;
    }
    if (buffers != 0U) {
      if (buffers > c_mp->stat.st_alloc_max_pages) {
        c_mp->stat.st_alloc_max_pages = buffers;
      }
      c_mp->stat.st_alloc_pages = c_mp->stat.st_alloc_pages + buffers;
    }
    return (0);
  } else {
    if (giveup) {
      goto _L;
    } else {
      if (c_mp->stat.st_pages == 0U) {
        _L: 
        if (! ((memreg->rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & (memreg->rp)->mutex);
        }
        __db_err((DB_ENV const   *)dbenv___0, "unable to allocate space from the buffer cache");
        return (ret);
      }
    }
  }
  freed_space = 0U;
  total_buckets += buckets;
  buckets = 0U;
  while (1) {
    if (c_mp->stat.st_pages == 0U) {
      goto alloc;
    }
    tmp = c_mp->last_checked;
    c_mp->last_checked ++;
    hp = dbht + tmp;
    if ((unsigned int )hp >= (unsigned int )hp_end) {
      c_mp->last_checked = 0U;
      tmp___0 = c_mp->last_checked;
      c_mp->last_checked ++;
      hp = dbht + tmp___0;
    }
    if (hp->hash_bucket.stqh_first == -1) {
      tmp___1 = (struct __bh *)((void *)0);
    } else {
      tmp___1 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      goto __Cont;
    }
    buckets ++;
    if (buckets % (unsigned int )c_mp->htab_buckets == 0U) {
      if (freed_space > 0U) {
        goto alloc;
      }
      if (! ((memreg->rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & (memreg->rp)->mutex);
      }
      aggressive ++;
      switch (aggressive) {
      case 1: ;
      break;
      case 2: 
      put_counter = c_mp->put_counter;
      case 3: ;
      case 4: ;
      case 5: ;
      case 6: 
      __memp_sync_int(dbenv___0, (DB_MPOOLFILE *)((void *)0), 0, (enum __anonenum_db_sync_op_53 )0,
                      (int *)((void *)0));
      __os_sleep(dbenv___0, 1UL, 0UL);
      break;
      default: 
      aggressive = 1;
      if (put_counter == c_mp->put_counter) {
        giveup = 1;
      }
      break;
      }
      if (! ((memreg->rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (memreg->rp)->mutex);
      }
      goto alloc;
    }
    if (! aggressive) {
      if (hp->hash_priority > high_priority) {
        goto __Cont;
      }
      if ((unsigned int )hp_tmp == (unsigned int )((void *)0)) {
        hp_tmp = hp;
        goto __Cont;
      }
      if (hp->hash_priority > hp_tmp->hash_priority) {
        hp = hp_tmp;
      }
      hp_tmp = (DB_MPOOL_HASH *)((void *)0);
    }
    priority = hp->hash_priority;
    if (! ((memreg->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (memreg->rp)->mutex);
    }
    mutexp = & hp->hash_mutex;
    if (! (mutexp->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, mutexp);
    }
    if (hp->hash_bucket.stqh_first == -1) {
      bhp = (BH *)((void *)0);
    } else {
      bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    if ((unsigned int )bhp == (unsigned int )((void *)0)) {
      goto next_hb;
    } else {
      if ((int )bhp->ref != 0) {
        goto next_hb;
      } else {
        if (bhp->priority > priority) {
          goto next_hb;
        }
      }
    }
    buffers ++;
    bh_mfp = (MPOOLFILE *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + bhp->mf_offset));
    ret = 0;
    if ((int )bhp->flags & 2) {
      bhp->ref = (unsigned short )((int )bhp->ref + 1);
      ret = __memp_bhwrite(dbmp, hp, bh_mfp, bhp, 0);
      bhp->ref = (unsigned short )((int )bhp->ref - 1);
      if (ret == 0) {
        c_mp->stat.st_rw_evict = c_mp->stat.st_rw_evict + 1U;
      }
    } else {
      c_mp->stat.st_ro_evict = c_mp->stat.st_ro_evict + 1U;
    }
    if (ret != 0) {
      goto _L___0;
    } else {
      if ((int )bhp->ref != 0) {
        _L___0: 
        if (ret != 0) {
          if (aggressive) {
            __memp_bad_buffer(hp);
          }
        }
        goto next_hb;
      }
    }
    if ((unsigned int )mfp != (unsigned int )((void *)0)) {
      if (mfp->stat.st_pagesize == bh_mfp->stat.st_pagesize) {
        __memp_bhfree(dbmp, hp, bhp, 0);
        p = (void *)bhp;
        goto found;
      }
    }
    tmp___2 = __db_shsizeof((void *)bhp);
    freed_space += tmp___2;
    __memp_bhfree(dbmp, hp, bhp, 1);
    if (aggressive > 1) {
      aggressive = 1;
    }
    if (0) {
      next_hb: 
      if (! (mutexp->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, mutexp);
      }
    }
    if (! ((memreg->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (memreg->rp)->mutex);
    }
    if (freed_space >= 3U * len) {
      goto alloc;
    }
    __Cont: ;
  }
  return (0);
}
}
static void __memp_bad_buffer(DB_MPOOL_HASH *hp ) 
{ BH *bhp ;
  u_int32_t priority ;
  struct __bh *tmp___1 ;
  struct __bh *tmp___2 ;
  struct __bh *tmp___3 ;
  struct __bh *tmp___4 ;

  {
  if (hp->hash_bucket.stqh_first == -1) {
    bhp = (BH *)((void *)0);
  } else {
    bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
  }
  while (1) {
    if (bhp->hq.stqe_next != -1) {
      ((struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next))->hq.stqe_prev = bhp->hq.stqe_prev +
                                                                             ((u_int8_t *)bhp -
                                                                              (u_int8_t *)((struct __bh *)((u_int8_t *)bhp +
                                                                                                           bhp->hq.stqe_next)));
      (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = (*((ssize_t *)((u_int8_t *)bhp +
                                                                             bhp->hq.stqe_prev))) +
                                                              bhp->hq.stqe_next;
    } else {
      hp->hash_bucket.stqh_last = bhp->hq.stqe_prev + ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket));
      (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = -1;
    }
    break;
  }
  priority = bhp->priority;
  if (! (hp->hash_bucket.stqh_first == -1)) {
    if (hp->hash_bucket.stqh_first == -1) {
      tmp___1 = (struct __bh *)((void *)0);
    } else {
      if (hp->hash_bucket.stqh_first == -1) {
        tmp___2 = (struct __bh *)((void *)0);
      } else {
        tmp___2 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      if (hp->hash_bucket.stqh_first == -1) {
        tmp___3 = (struct __bh *)((void *)0);
      } else {
        tmp___3 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      tmp___1 = (struct __bh *)((int )(& hp->hash_bucket) + (hp->hash_bucket.stqh_last -
                                                             ((u_int8_t *)(& tmp___2->hq.stqe_next) -
                                                              (u_int8_t *)tmp___3)));
    }
    priority = tmp___1->priority;
  }
  bhp->priority = priority;
  while (1) {
    bhp->hq.stqe_next = -1;
    bhp->hq.stqe_prev = - ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket)) + hp->hash_bucket.stqh_last;
    if (hp->hash_bucket.stqh_last == (u_int8_t *)(& hp->hash_bucket.stqh_first) -
                                     (u_int8_t *)(& hp->hash_bucket)) {
      hp->hash_bucket.stqh_first = (u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket);
    } else {
      (*((ssize_t *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_last))) = (- hp->hash_bucket.stqh_last +
                                                                                       ((u_int8_t *)(& bhp->hq.stqe_next) -
                                                                                        (u_int8_t *)bhp)) +
                                                                                      ((u_int8_t *)bhp -
                                                                                       (u_int8_t *)(& hp->hash_bucket));
    }
    hp->hash_bucket.stqh_last = (u_int8_t *)(& bhp->hq.stqe_next) - (u_int8_t *)(& hp->hash_bucket);
    break;
  }
  if (hp->hash_bucket.stqh_first == -1) {
    tmp___4 = (struct __bh *)((void *)0);
  } else {
    tmp___4 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
  }
  hp->hash_priority = tmp___4->priority;
  return;
}
}
#pragma merger(0,"/tmp/cil-MYIClaYf.i","-O2")
int __os_io(DB_ENV *dbenv___0 , int op , DB_FH *fhp , db_pgno_t pgno , size_t pagesize ,
            u_int8_t *buf , size_t *niop ) ;
int __memp_pgread(DB_MPOOLFILE *dbmfp , DB_MUTEX *mutexp , BH *bhp , int can_create ) ;
int __memp_pg(DB_MPOOLFILE *dbmfp , BH *bhp , int is_pgin ) ;
int __memp_mf_discard(DB_MPOOL *dbmp , MPOOLFILE *mfp ) ;
char *__memp_fn(DB_MPOOLFILE *dbmfp ) ;
static int __memp_pgwrite(DB_ENV *dbenv___0 , DB_MPOOLFILE *dbmfp , DB_MPOOL_HASH *hp ,
                          BH *bhp ) ;
int __memp_bhwrite(DB_MPOOL *dbmp , DB_MPOOL_HASH *hp , MPOOLFILE *mfp , BH *bhp ,
                   int open_extents ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOLFILE *dbmfp ;
  DB_MPREG *mpreg ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbenv___0 = dbmp->dbenv;
  if (mfp->deadfile) {
    tmp = __memp_pgwrite(dbenv___0, (DB_MPOOLFILE *)((void *)0), hp, bhp);
    return (tmp);
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  dbmfp = dbmp->dbmfq.tqh_first;
  while ((unsigned int )dbmfp != (unsigned int )((void *)0)) {
    if ((unsigned int )dbmfp->mfp == (unsigned int )mfp) {
      if (! (dbmfp->flags & 8U)) {
        dbmfp->ref = dbmfp->ref + 1U;
        break;
      }
    }
    dbmfp = dbmfp->q.tqe_next;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if ((unsigned int )dbmfp != (unsigned int )((void *)0)) {
    if ((unsigned int )dbmfp->fhp == (unsigned int )((void *)0)) {
      if (mfp->no_backing_file) {
        return (1);
      }
      if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbmp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
        }
      }
      if ((unsigned int )dbmfp->fhp == (unsigned int )((void *)0)) {
        if (dbenv___0->flags & 32U) {
          tmp___0 = 2;
        } else {
          tmp___0 = 0;
        }
        ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )3, (char const   *)((void *)0),
                           (unsigned int )tmp___0, & dbmfp->fhp, (char **)((void *)0));
      } else {
        ret = 0;
      }
      if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbmp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
        }
      }
      if (ret != 0) {
        __db_err((DB_ENV const   *)dbenv___0, "unable to create temporary backing file");
        return (ret);
      }
    }
    goto pgwrite;
  }
  if (! open_extents) {
    if (mfp->flags & 4U) {
      return (1);
    }
  }
  if (mfp->flags & 256U) {
    return (1);
  }
  if (mfp->ftype != 0) {
    if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbmp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
      }
    }
    mpreg = dbmp->dbregq.lh_first;
    while ((unsigned int )mpreg != (unsigned int )((void *)0)) {
      if (mpreg->ftype == mfp->ftype) {
        break;
      }
      mpreg = mpreg->q.le_next;
    }
    if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbmp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
      }
    }
    if ((unsigned int )mpreg == (unsigned int )((void *)0)) {
      return (1);
    }
  }
  ret = __memp_fcreate(dbenv___0, & dbmfp);
  if (ret != 0) {
    return (ret);
  }
  ret = __memp_fopen(dbmfp, mfp, (char const   *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                           mfp->path_off)), 0U, 0,
                     mfp->stat.st_pagesize);
  if (ret != 0) {
    __memp_fclose(dbmfp, 0U);
    return (ret);
  }
  pgwrite: 
  ret = __memp_pgwrite(dbenv___0, dbmfp, hp, bhp);
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  if (dbmfp->ref == 1U) {
    dbmfp->flags = dbmfp->flags | 2U;
  } else {
    dbmfp->ref = dbmfp->ref - 1U;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  return (ret);
}
}
int __memp_pgread(DB_MPOOLFILE *dbmfp , DB_MUTEX *mutexp , BH *bhp , int can_create ) 
{ DB_ENV *dbenv___0 ;
  MPOOLFILE *mfp ;
  size_t len ;
  size_t nr ;
  size_t pagesize ;
  int ret ;

  {
  dbenv___0 = dbmfp->dbenv;
  mfp = dbmfp->mfp;
  pagesize = mfp->stat.st_pagesize;
  bhp->flags = (unsigned short )((int )bhp->flags | 48);
  if (! (bhp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & bhp->mutex);
  }
  if (! (mutexp->flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, mutexp);
  }
  nr = 0U;
  if ((unsigned int )dbmfp->fhp != (unsigned int )((void *)0)) {
    ret = __os_io(dbenv___0, 1, dbmfp->fhp, bhp->pgno, pagesize, bhp->buf, & nr);
    if (ret != 0) {
      goto err;
    }
  }
  if (nr < pagesize) {
    if (can_create == 0) {
      ret = -30988;
      goto err;
    }
    if (mfp->clear_len == 0U) {
      len = pagesize;
    } else {
      len = mfp->clear_len;
    }
    memset((void *)(bhp->buf), 0, len);
    mfp->stat.st_page_create = mfp->stat.st_page_create + 1U;
  } else {
    mfp->stat.st_page_in = mfp->stat.st_page_in + 1U;
  }
  if (mfp->ftype == 0) {
    ret = 0;
  } else {
    ret = __memp_pg(dbmfp, bhp, 1);
  }
  err: 
  if (! (bhp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & bhp->mutex);
  }
  if (! (mutexp->flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, mutexp);
  }
  bhp->flags = (unsigned short )((int )bhp->flags & -17);
  if (ret == 0) {
    bhp->flags = (unsigned short )((int )bhp->flags & -33);
  }
  return (ret);
}
}
static int __memp_pgwrite(DB_ENV *dbenv___0 , DB_MPOOLFILE *dbmfp , DB_MPOOL_HASH *hp ,
                          BH *bhp ) 
{ DB_LSN lsn ;
  MPOOLFILE *mfp ;
  size_t nw ;
  int callpgin ;
  int ret ;
  char *tmp ;

  {
  if ((unsigned int )dbmfp == (unsigned int )((void *)0)) {
    mfp = (MPOOLFILE *)((void *)0);
  } else {
    mfp = dbmfp->mfp;
  }
  ret = 0;
  callpgin = ret;
  if (! ((int )bhp->flags & 16)) {
    bhp->flags = (unsigned short )((int )bhp->flags | 16);
    if (! (bhp->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & bhp->mutex);
    }
    if (! (hp->hash_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
    }
  }
  if ((unsigned int )mfp == (unsigned int )((void *)0)) {
    goto err;
  } else {
    if (mfp->deadfile) {
      goto err;
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (mfp->lsn_off != -1) {
      memcpy((void * __restrict  )(& lsn), (void const   * __restrict  )(bhp->buf +
                                                                         mfp->lsn_off),
             sizeof(DB_LSN ));
      ret = __log_flush(dbenv___0, (DB_LSN const   *)(& lsn));
      if (ret != 0) {
        goto err;
      }
    }
  }
  if (mfp->ftype != 0) {
    if (! ((int )bhp->flags & 1)) {
      callpgin = 1;
      ret = __memp_pg(dbmfp, bhp, 0);
      if (ret != 0) {
        goto err;
      }
    }
  }
  ret = __os_io(dbenv___0, 2, dbmfp->fhp, bhp->pgno, mfp->stat.st_pagesize, bhp->buf,
                & nw);
  if (ret != 0) {
    tmp = __memp_fn(dbmfp);
    __db_err((DB_ENV const   *)dbenv___0, "%s: write failed for page %lu", tmp, (unsigned long )bhp->pgno);
    goto err;
  }
  mfp->file_written = 1;
  mfp->stat.st_page_out = mfp->stat.st_page_out + 1U;
  err: 
  if (! (bhp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & bhp->mutex);
  }
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
  }
  if (callpgin) {
    bhp->flags = (unsigned short )((int )bhp->flags | 1);
  }
  if (ret == 0) {
    hp->hash_page_dirty = hp->hash_page_dirty - 1U;
    bhp->flags = (unsigned short )((int )bhp->flags & -7);
  }
  bhp->ref_sync = (unsigned short)0;
  bhp->flags = (unsigned short )((int )bhp->flags & -17);
  return (ret);
}
}
int __memp_pg(DB_MPOOLFILE *dbmfp , BH *bhp , int is_pgin ) 
{ DBT dbt ;
  DBT *dbtp ;
  DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  DB_MPREG *mpreg ;
  MPOOLFILE *mfp ;
  int ftype ;
  int ret ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mfp = dbmfp->mfp;
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  ftype = mfp->ftype;
  mpreg = dbmp->dbregq.lh_first;
  while ((unsigned int )mpreg != (unsigned int )((void *)0)) {
    if (ftype != mpreg->ftype) {
      goto __Cont;
    }
    if (mfp->pgcookie_len == 0U) {
      dbtp = (DBT *)((void *)0);
    } else {
      dbt.size = mfp->pgcookie_len;
      dbt.data = (void *)((u_int8_t *)(dbmp->reginfo)->addr + mfp->pgcookie_off);
      dbtp = & dbt;
    }
    if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbmp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
      }
    }
    if (is_pgin) {
      if ((unsigned int )mpreg->pgin != (unsigned int )((void *)0)) {
        ret = ((*(mpreg->pgin)))(dbenv___0, bhp->pgno, (void *)(bhp->buf), dbtp);
        if (ret != 0) {
          goto err;
        }
      }
    } else {
      if ((unsigned int )mpreg->pgout != (unsigned int )((void *)0)) {
        ret = ((*(mpreg->pgout)))(dbenv___0, bhp->pgno, (void *)(bhp->buf), dbtp);
        if (ret != 0) {
          goto err;
        }
      }
    }
    break;
    __Cont: 
    mpreg = mpreg->q.le_next;
  }
  if ((unsigned int )mpreg == (unsigned int )((void *)0)) {
    if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbmp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
      }
    }
  }
  return (0);
  err: 
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if (is_pgin) {
    tmp = "pgin";
  } else {
    tmp = "pgout";
  }
  tmp___0 = __memp_fn(dbmfp);
  __db_err((DB_ENV const   *)dbenv___0, "%s: %s failed for page %lu", tmp___0, tmp,
           (unsigned long )bhp->pgno);
  return (ret);
}
}
void __memp_bhfree(DB_MPOOL *dbmp , DB_MPOOL_HASH *hp , BH *bhp , int free_mem ) 
{ DB_ENV *dbenv___0 ;
  MPOOL *c_mp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  u_int32_t n_cache ;
  struct __bh *tmp___1 ;
  struct __bh *tmp___2 ;

  {
  dbenv___0 = dbmp->dbenv;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  n_cache = (bhp->pgno ^ (bhp->mf_offset >> 3)) % mp->nreg;
  while (1) {
    if (bhp->hq.stqe_next != -1) {
      ((struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next))->hq.stqe_prev = bhp->hq.stqe_prev +
                                                                             ((u_int8_t *)bhp -
                                                                              (u_int8_t *)((struct __bh *)((u_int8_t *)bhp +
                                                                                                           bhp->hq.stqe_next)));
      (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = (*((ssize_t *)((u_int8_t *)bhp +
                                                                             bhp->hq.stqe_prev))) +
                                                              bhp->hq.stqe_next;
    } else {
      hp->hash_bucket.stqh_last = bhp->hq.stqe_prev + ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket));
      (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = -1;
    }
    break;
  }
  if (bhp->priority == hp->hash_priority) {
    if (hp->hash_bucket.stqh_first == -1) {
      tmp___2 = (struct __bh *)((void *)0);
    } else {
      tmp___2 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
      hp->hash_priority = 0U;
    } else {
      if (hp->hash_bucket.stqh_first == -1) {
        tmp___1 = (struct __bh *)((void *)0);
      } else {
        tmp___1 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      hp->hash_priority = tmp___1->priority;
    }
  }
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
  }
  mfp = (MPOOLFILE *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + bhp->mf_offset));
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
  }
  mfp->block_cnt = mfp->block_cnt - 1U;
  if (mfp->block_cnt == 0U) {
    if (mfp->mpf_cnt == 0U) {
      __memp_mf_discard(dbmp, mfp);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
    }
  }
  if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
  }
  if (free_mem) {
    __db_shalloc_free((dbmp->reginfo + n_cache)->addr, (void *)bhp);
    c_mp = (MPOOL *)(dbmp->reginfo + n_cache)->primary;
    c_mp->stat.st_pages = c_mp->stat.st_pages - 1U;
  }
  if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-D8j55iNe.i","-O2")
void __os_yield(DB_ENV *dbenv___0 , u_long usecs ) ;
int __memp_fget_pp(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr , u_int32_t flags , void *addrp ) ;
int __memp_fget_pp(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr , u_int32_t flags , void *addrp ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbmfp->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbmfp->flags & 4U)) {
    tmp___0 = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->get", 0);
    return (tmp___0);
  }
  if (flags != 0U) {
    ret = __db_fchk(dbenv___0, "memp_fget", flags, 7U);
    if (ret != 0) {
      return (ret);
    }
    switch ((int )flags) {
    case 1: ;
    case 2: ;
    case 4: ;
    break;
    default: 
    tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "memp_fget", 1);
    return (tmp___1);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __op_rep_enter(dbenv___0);
  }
  ret = __memp_fget(dbmfp, pgnoaddr, flags, addrp);
  if (ret != 0) {
    if (rep_check) {
      __op_rep_exit(dbenv___0);
    }
  }
  return (ret);
}
}
int __memp_fget(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr , u_int32_t flags , void *addrp ) 
{ enum __anonenum_state_60 state ;
  BH *alloc_bhp ;
  BH *bhp ;
  DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  DB_MPOOL_HASH *hp ;
  MPOOL *c_mp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  roff_t mf_offset ;
  u_int32_t n_cache ;
  u_int32_t st_hsearch ;
  int b_incr ;
  int extending ;
  int first ;
  int ret ;
  char *tmp ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct __bh *tmp___4 ;
  struct __bh *tmp___5 ;
  int tmp___6 ;

  {
  (*((void **)addrp)) = (void *)0;
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  c_mp = (MPOOL *)((void *)0);
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  mfp = dbmfp->mfp;
  mf_offset = (unsigned int )((u_int8_t *)mfp - (u_int8_t *)(dbmp->reginfo)->addr);
  bhp = (BH *)((void *)0);
  alloc_bhp = bhp;
  hp = (DB_MPOOL_HASH *)((void *)0);
  ret = 0;
  extending = ret;
  b_incr = extending;
  switch ((int )flags) {
  case 2: ;
  if (flags == 2U) {
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    (*pgnoaddr) = mfp->last_pgno;
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  break;
  case 4: ;
  if (flags == 4U) {
    goto alloc;
  }
  break;
  case 1: ;
  default: ;
  break;
  }
  if ((unsigned int )dbmfp->addr != (unsigned int )((void *)0)) {
    if (mfp->flags & 1U) {
      if ((*pgnoaddr) <= mfp->orig_last_pgno) {
        (*((void **)addrp)) = (void *)((u_int8_t *)dbmfp->addr + (*pgnoaddr) * mfp->stat.st_pagesize);
        mfp->stat.st_map = mfp->stat.st_map + 1U;
        return (0);
      }
    }
  }
  hb_search: 
  n_cache = ((*pgnoaddr) ^ (mf_offset >> 3)) % mp->nreg;
  c_mp = (MPOOL *)(dbmp->reginfo + n_cache)->primary;
  hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)(dbmp->reginfo + n_cache)->addr + c_mp->htab));
  hp = hp + ((*pgnoaddr) ^ (mf_offset << 9)) % (unsigned int )c_mp->htab_buckets;
  retry: 
  st_hsearch = 0U;
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
  }
  if (hp->hash_bucket.stqh_first == -1) {
    bhp = (BH *)((void *)0);
  } else {
    bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
  }
  while ((unsigned int )bhp != (unsigned int )((void *)0)) {
    st_hsearch ++;
    if (bhp->pgno != (*pgnoaddr)) {
      goto __Cont;
    } else {
      if (bhp->mf_offset != mf_offset) {
        goto __Cont;
      }
    }
    if ((int )bhp->ref == 65535) {
      tmp = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: page %lu: reference count overflow",
               tmp, (unsigned long )bhp->pgno);
      ret = 22;
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
      }
      goto err;
    }
    bhp->ref = (unsigned short )((int )bhp->ref + 1);
    b_incr = 1;
    first = 1;
    while (1) {
      if ((int )bhp->flags & 16) {
        if (! (! (dbenv___0->flags & 1024U))) {
          break;
        }
      } else {
        break;
      }
      if (! first) {
        if ((int )bhp->ref_sync != 0) {
          bhp->ref = (unsigned short )((int )bhp->ref - 1);
          b_incr = 0;
          if (! (hp->hash_mutex.flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
          }
          __os_yield(dbenv___0, 1UL);
          goto retry;
        }
      }
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
      }
      if (! first) {
        __os_yield(dbenv___0, 1UL);
      }
      if (! (bhp->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & bhp->mutex);
      }
      if (! (bhp->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & bhp->mutex);
      }
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
      }
      first = 0;
    }
    mfp->stat.st_cache_hit = mfp->stat.st_cache_hit + 1U;
    break;
    __Cont: 
    if (bhp->hq.stqe_next == -1) {
      bhp = (BH *)((void *)0);
    } else {
      bhp = (struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next);
    }
  }
  c_mp->stat.st_hash_searches = c_mp->stat.st_hash_searches + 1U;
  if (st_hsearch > c_mp->stat.st_hash_longest) {
    c_mp->stat.st_hash_longest = st_hsearch;
  }
  c_mp->stat.st_hash_examined = c_mp->stat.st_hash_examined + st_hsearch;
  if ((unsigned int )bhp == (unsigned int )((void *)0)) {
    if ((unsigned int )alloc_bhp == (unsigned int )((void *)0)) {
      state = (enum __anonenum_state_60 )1;
    } else {
      state = (enum __anonenum_state_60 )3;
    }
  } else {
    if ((unsigned int )alloc_bhp == (unsigned int )((void *)0)) {
      state = (enum __anonenum_state_60 )0;
    } else {
      state = (enum __anonenum_state_60 )2;
    }
  }
  switch ((int )state) {
  case 0: ;
  break;
  case 1: ;
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
  }
  alloc: 
  n_cache = 0U;
  n_cache = n_cache;
  ret = 0;
  extending = ret;
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  switch ((int )flags) {
  case 4: 
  extending = 1;
  if (mfp->maxpgno != 0U) {
    if (mfp->last_pgno >= mfp->maxpgno) {
      tmp___2 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: file limited to %lu pages", tmp___2,
               (unsigned long )mfp->maxpgno);
      ret = 28;
    } else {
      (*pgnoaddr) = mfp->last_pgno + 1U;
    }
  } else {
    (*pgnoaddr) = mfp->last_pgno + 1U;
  }
  break;
  case 1: ;
  if (mfp->maxpgno != 0U) {
    if ((*pgnoaddr) > mfp->maxpgno) {
      tmp___3 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: file limited to %lu pages", tmp___3,
               (unsigned long )mfp->maxpgno);
      ret = 28;
    } else {
      extending = (*pgnoaddr) > mfp->last_pgno;
    }
  } else {
    extending = (*pgnoaddr) > mfp->last_pgno;
  }
  break;
  default: ;
  if ((*pgnoaddr) > mfp->last_pgno) {
    ret = -30988;
  } else {
    ret = 0;
  }
  break;
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if (ret != 0) {
    goto err;
  }
  mf_offset = (unsigned int )((u_int8_t *)mfp - (u_int8_t *)(dbmp->reginfo)->addr);
  n_cache = ((*pgnoaddr) ^ (mf_offset >> 3)) % mp->nreg;
  c_mp = (MPOOL *)(dbmp->reginfo + n_cache)->primary;
  ret = __memp_alloc(dbmp, dbmp->reginfo + n_cache, mfp, 0U, (roff_t *)((void *)0),
                     (void *)(& alloc_bhp));
  if (ret != 0) {
    goto err;
  }
  if (extending) {
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  if (flags == 4U) {
    if ((*pgnoaddr) != mfp->last_pgno + 1U) {
      (*pgnoaddr) = mfp->last_pgno + 1U;
      if (n_cache != ((*pgnoaddr) ^ (mf_offset >> 3)) % mp->nreg) {
        if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
        }
        if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
        }
        __db_shalloc_free((dbmp->reginfo + n_cache)->addr, (void *)alloc_bhp);
        c_mp->stat.st_pages = c_mp->stat.st_pages - 1U;
        if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
        }
        alloc_bhp = (BH *)((void *)0);
        goto alloc;
      }
    }
  }
  if (extending) {
    if ((*pgnoaddr) > mfp->last_pgno) {
      mfp->last_pgno = (*pgnoaddr);
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    if (ret != 0) {
      goto err;
    }
  }
  goto hb_search;
  case 2: ;
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
  }
  if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
  }
  __db_shalloc_free((dbmp->reginfo + n_cache)->addr, (void *)alloc_bhp);
  c_mp->stat.st_pages = c_mp->stat.st_pages - 1U;
  alloc_bhp = (BH *)((void *)0);
  if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
  }
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
  }
  if (flags == 4U) {
    bhp->ref = (unsigned short )((int )bhp->ref - 1);
    b_incr = 0;
    goto alloc;
  }
  break;
  case 3: 
  bhp = alloc_bhp;
  alloc_bhp = (BH *)((void *)0);
  b_incr = 1;
  memset((void *)bhp, 0, sizeof(BH ));
  bhp->ref = (unsigned short)1;
  bhp->priority = 4294967295U;
  bhp->pgno = (*pgnoaddr);
  bhp->mf_offset = mf_offset;
  while (1) {
    bhp->hq.stqe_next = -1;
    bhp->hq.stqe_prev = - ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket)) + hp->hash_bucket.stqh_last;
    if (hp->hash_bucket.stqh_last == (u_int8_t *)(& hp->hash_bucket.stqh_first) -
                                     (u_int8_t *)(& hp->hash_bucket)) {
      hp->hash_bucket.stqh_first = (u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket);
    } else {
      (*((ssize_t *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_last))) = (- hp->hash_bucket.stqh_last +
                                                                                       ((u_int8_t *)(& bhp->hq.stqe_next) -
                                                                                        (u_int8_t *)bhp)) +
                                                                                      ((u_int8_t *)bhp -
                                                                                       (u_int8_t *)(& hp->hash_bucket));
    }
    hp->hash_bucket.stqh_last = (u_int8_t *)(& bhp->hq.stqe_next) - (u_int8_t *)(& hp->hash_bucket);
    break;
  }
  if (hp->hash_bucket.stqh_first == -1) {
    tmp___4 = (struct __bh *)((void *)0);
  } else {
    tmp___4 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
  }
  hp->hash_priority = tmp___4->priority;
  if (extending) {
    hp->hash_page_dirty = hp->hash_page_dirty + 1U;
    bhp->flags = (unsigned short )((int )bhp->flags | 6);
  }
  if (extending) {
    if (mfp->clear_len == 0U) {
      memset((void *)(bhp->buf), 0, mfp->stat.st_pagesize);
    } else {
      memset((void *)(bhp->buf), 0, mfp->clear_len);
    }
    if (flags == 1U) {
      if (mfp->ftype != 0) {
        bhp->flags = (unsigned short )((int )bhp->flags | 1);
      }
    }
    mfp->stat.st_page_create = mfp->stat.st_page_create + 1U;
  } else {
    bhp->flags = (unsigned short )((int )bhp->flags | 32);
    mfp->stat.st_cache_miss = mfp->stat.st_cache_miss + 1U;
  }
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
  }
  mfp->block_cnt = mfp->block_cnt + 1U;
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
  }
  ret = __db_mutex_setup(dbenv___0, dbmp->reginfo + n_cache, (void *)(& bhp->mutex),
                         0U);
  if (ret != 0) {
    goto err;
  }
  }
  if ((int )state != 3) {
    if ((int )bhp->ref == 1) {
      bhp->priority = 4294967295U;
      while (1) {
        if (bhp->hq.stqe_next != -1) {
          ((struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next))->hq.stqe_prev = bhp->hq.stqe_prev +
                                                                                 ((u_int8_t *)bhp -
                                                                                  (u_int8_t *)((struct __bh *)((u_int8_t *)bhp +
                                                                                                               bhp->hq.stqe_next)));
          (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = (*((ssize_t *)((u_int8_t *)bhp +
                                                                                 bhp->hq.stqe_prev))) +
                                                                  bhp->hq.stqe_next;
        } else {
          hp->hash_bucket.stqh_last = bhp->hq.stqe_prev + ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket));
          (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = -1;
        }
        break;
      }
      while (1) {
        bhp->hq.stqe_next = -1;
        bhp->hq.stqe_prev = - ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket)) +
                            hp->hash_bucket.stqh_last;
        if (hp->hash_bucket.stqh_last == (u_int8_t *)(& hp->hash_bucket.stqh_first) -
                                         (u_int8_t *)(& hp->hash_bucket)) {
          hp->hash_bucket.stqh_first = (u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket);
        } else {
          (*((ssize_t *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_last))) = (- hp->hash_bucket.stqh_last +
                                                                                           ((u_int8_t *)(& bhp->hq.stqe_next) -
                                                                                            (u_int8_t *)bhp)) +
                                                                                          ((u_int8_t *)bhp -
                                                                                           (u_int8_t *)(& hp->hash_bucket));
        }
        hp->hash_bucket.stqh_last = (u_int8_t *)(& bhp->hq.stqe_next) - (u_int8_t *)(& hp->hash_bucket);
        break;
      }
      if (hp->hash_bucket.stqh_first == -1) {
        tmp___5 = (struct __bh *)((void *)0);
      } else {
        tmp___5 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      hp->hash_priority = tmp___5->priority;
    }
  }
  if ((int )bhp->flags & 32) {
    if (flags & 1U) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
    ret = __memp_pgread(dbmfp, & hp->hash_mutex, bhp, tmp___6);
    if (ret != 0) {
      goto err;
    }
  }
  if ((int )bhp->flags & 1) {
    ret = __memp_pg(dbmfp, bhp, 1);
    if (ret != 0) {
      goto err;
    }
    bhp->flags = (unsigned short )((int )bhp->flags & -2);
  }
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
  }
  (*((void **)addrp)) = (void *)(bhp->buf);
  return (0);
  err: 
  if (b_incr) {
    if ((int )bhp->ref == 1) {
      __memp_bhfree(dbmp, hp, bhp, 1);
    } else {
      bhp->ref = (unsigned short )((int )bhp->ref - 1);
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
      }
    }
  }
  if ((unsigned int )alloc_bhp != (unsigned int )((void *)0)) {
    if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
    }
    __db_shalloc_free((dbmp->reginfo + n_cache)->addr, (void *)alloc_bhp);
    c_mp->stat.st_pages = c_mp->stat.st_pages - 1U;
    if (! (((dbmp->reginfo + n_cache)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo + n_cache)->rp)->mutex);
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-e9Iw2yIy.i","-O2")
int __os_mapfile(DB_ENV *dbenv___0 , char *path , DB_FH *fhp , size_t len , int is_rdonly ,
                 void **addrp ) ;
int __os_unmapfile(DB_ENV *dbenv___0 , void *addr , size_t len ) ;
int __memp_fcreate_pp(DB_ENV *dbenv___0 , DB_MPOOLFILE **retp , u_int32_t flags ) ;
int __memp_get_fileid(DB_MPOOLFILE *dbmfp , u_int8_t *fileid ) ;
int __memp_mf_sync(DB_MPOOL *dbmp , MPOOLFILE *mfp ) ;
char *__memp_fns(DB_MPOOL *dbmp , MPOOLFILE *mfp ) ;
int __memp_fput_pp(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) ;
int __memp_fset_pp(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) ;
int __memp_fsync_pp(DB_MPOOLFILE *dbmfp ) ;
static int __memp_fclose_pp(DB_MPOOLFILE *dbmfp , u_int32_t flags ) ;
static int __memp_fopen_pp(DB_MPOOLFILE *dbmfp , char const   *path , u_int32_t flags ,
                           int mode , size_t pagesize ) ;
static int __memp_get_clear_len(DB_MPOOLFILE *dbmfp , u_int32_t *clear_lenp ) ;
static int __memp_get_flags(DB_MPOOLFILE *dbmfp , u_int32_t *flagsp ) ;
static int __memp_get_lsn_offset(DB_MPOOLFILE *dbmfp , int32_t *lsn_offsetp ) ;
static int __memp_get_maxsize(DB_MPOOLFILE *dbmfp , u_int32_t *gbytesp , u_int32_t *bytesp ) ;
static int __memp_set_maxsize(DB_MPOOLFILE *dbmfp , u_int32_t gbytes , u_int32_t bytes ) ;
static int __memp_get_pgcookie(DB_MPOOLFILE *dbmfp , DBT *pgcookie ) ;
static int __memp_get_priority(DB_MPOOLFILE *dbmfp , DB_CACHE_PRIORITY *priorityp ) ;
static int __memp_set_priority(DB_MPOOLFILE *dbmfp , DB_CACHE_PRIORITY priority ) ;
int __memp_fcreate_pp(DB_ENV *dbenv___0 , DB_MPOOLFILE **retp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->memp_fcreate", flags, 0U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_fcreate(dbenv___0, retp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_fcreate(DB_ENV *dbenv___0 , DB_MPOOLFILE **retp ) 
{ DB_MPOOLFILE *dbmfp ;
  int ret ;

  {
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_MPOOLFILE ), (void *)(& dbmfp));
  if (ret != 0) {
    return (ret);
  }
  dbmfp->ref = 1U;
  dbmfp->lsn_offset = -1;
  dbmfp->dbenv = dbenv___0;
  dbmfp->mfp = (MPOOLFILE *)0;
  dbmfp->get_clear_len = & __memp_get_clear_len;
  dbmfp->set_clear_len = & __memp_set_clear_len;
  dbmfp->get_fileid = & __memp_get_fileid;
  dbmfp->set_fileid = & __memp_set_fileid;
  dbmfp->get_flags = & __memp_get_flags;
  dbmfp->set_flags = & __memp_set_flags;
  dbmfp->get_ftype = & __memp_get_ftype;
  dbmfp->set_ftype = & __memp_set_ftype;
  dbmfp->get_lsn_offset = & __memp_get_lsn_offset;
  dbmfp->set_lsn_offset = & __memp_set_lsn_offset;
  dbmfp->get_maxsize = & __memp_get_maxsize;
  dbmfp->set_maxsize = & __memp_set_maxsize;
  dbmfp->get_pgcookie = & __memp_get_pgcookie;
  dbmfp->set_pgcookie = & __memp_set_pgcookie;
  dbmfp->get_priority = & __memp_get_priority;
  dbmfp->set_priority = & __memp_set_priority;
  dbmfp->get = & __memp_fget_pp;
  dbmfp->open = & __memp_fopen_pp;
  dbmfp->put = & __memp_fput_pp;
  dbmfp->set = & __memp_fset_pp;
  dbmfp->sync = & __memp_fsync_pp;
  dbmfp->close = & __memp_fclose_pp;
  (*retp) = dbmfp;
  return (0);
}
}
static int __memp_get_clear_len(DB_MPOOLFILE *dbmfp , u_int32_t *clear_lenp ) 
{ 

  {
  (*clear_lenp) = dbmfp->clear_len;
  return (0);
}
}
int __memp_set_clear_len(DB_MPOOLFILE *dbmfp , u_int32_t clear_len ) 
{ int tmp ;

  {
  if (dbmfp->flags & 4U) {
    tmp = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->set_clear_len", 1);
    return (tmp);
  }
  dbmfp->clear_len = clear_len;
  return (0);
}
}
int __memp_get_fileid(DB_MPOOLFILE *dbmfp , u_int8_t *fileid ) 
{ 

  {
  if (! (dbmfp->flags & 1U)) {
    __db_err((DB_ENV const   *)dbmfp->dbenv, "get_fileid: file ID not set");
    return (22);
  }
  memcpy((void * __restrict  )fileid, (void const   * __restrict  )(dbmfp->fileid),
         20U);
  return (0);
}
}
int __memp_set_fileid(DB_MPOOLFILE *dbmfp , u_int8_t *fileid ) 
{ int tmp ;

  {
  if (dbmfp->flags & 4U) {
    tmp = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->set_fileid", 1);
    return (tmp);
  }
  memcpy((void * __restrict  )(dbmfp->fileid), (void const   * __restrict  )fileid,
         20U);
  dbmfp->flags = dbmfp->flags | 1U;
  return (0);
}
}
static int __memp_get_flags(DB_MPOOLFILE *dbmfp , u_int32_t *flagsp ) 
{ MPOOLFILE *mfp ;

  {
  mfp = dbmfp->mfp;
  (*flagsp) = 0U;
  if ((unsigned int )mfp == (unsigned int )((void *)0)) {
    (*flagsp) = dbmfp->config_flags & 1U;
  } else {
    if (mfp->no_backing_file) {
      (*flagsp) |= 1U;
    }
  }
  return (0);
}
}
int __memp_set_flags(DB_MPOOLFILE *dbmfp , u_int32_t flags , int onoff ) 
{ DB_ENV *dbenv___0 ;
  MPOOLFILE *mfp ;
  int ret ;

  {
  dbenv___0 = dbmfp->dbenv;
  mfp = dbmfp->mfp;
  ret = __db_fchk(dbenv___0, "DB_MPOOLFILE->set_flags", flags, 3U);
  if (ret != 0) {
    return (ret);
  }
  switch ((int )flags) {
  case 0: ;
  break;
  case 1: ;
  if ((unsigned int )mfp == (unsigned int )((void *)0)) {
    if (onoff) {
      dbmfp->config_flags = dbmfp->config_flags | 1U;
    } else {
      dbmfp->config_flags = dbmfp->config_flags & 4294967294U;
    }
  } else {
    mfp->no_backing_file = onoff;
  }
  break;
  case 2: ;
  if ((unsigned int )mfp == (unsigned int )((void *)0)) {
    if (onoff) {
      dbmfp->config_flags = dbmfp->config_flags | 2U;
    } else {
      dbmfp->config_flags = dbmfp->config_flags & 4294967293U;
    }
  } else {
    mfp->unlink_on_close = onoff;
  }
  break;
  }
  return (0);
}
}
int __memp_get_ftype(DB_MPOOLFILE *dbmfp , int *ftypep ) 
{ 

  {
  (*ftypep) = dbmfp->ftype;
  return (0);
}
}
int __memp_set_ftype(DB_MPOOLFILE *dbmfp , int ftype ) 
{ int tmp ;

  {
  if (dbmfp->flags & 4U) {
    tmp = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->set_ftype", 1);
    return (tmp);
  }
  dbmfp->ftype = ftype;
  return (0);
}
}
static int __memp_get_lsn_offset(DB_MPOOLFILE *dbmfp , int32_t *lsn_offsetp ) 
{ 

  {
  (*lsn_offsetp) = dbmfp->lsn_offset;
  return (0);
}
}
int __memp_set_lsn_offset(DB_MPOOLFILE *dbmfp , int32_t lsn_offset ) 
{ int tmp ;

  {
  if (dbmfp->flags & 4U) {
    tmp = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->set_lsn_offset", 1);
    return (tmp);
  }
  dbmfp->lsn_offset = lsn_offset;
  return (0);
}
}
static int __memp_get_maxsize(DB_MPOOLFILE *dbmfp , u_int32_t *gbytesp , u_int32_t *bytesp ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  MPOOLFILE *mfp ;

  {
  mfp = dbmfp->mfp;
  if ((unsigned int )mfp == (unsigned int )((void *)0)) {
    (*gbytesp) = dbmfp->gbytes;
    (*bytesp) = dbmfp->bytes;
  } else {
    dbenv___0 = dbmfp->dbenv;
    dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    (*gbytesp) = mfp->maxpgno / (1073741824U / mfp->stat.st_pagesize);
    (*bytesp) = (mfp->maxpgno % (1073741824U / mfp->stat.st_pagesize)) * mfp->stat.st_pagesize;
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  return (0);
}
}
static int __memp_set_maxsize(DB_MPOOLFILE *dbmfp , u_int32_t gbytes , u_int32_t bytes ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  MPOOLFILE *mfp ;

  {
  mfp = dbmfp->mfp;
  if ((unsigned int )mfp == (unsigned int )((void *)0)) {
    dbmfp->gbytes = gbytes;
    dbmfp->bytes = bytes;
  } else {
    dbenv___0 = dbmfp->dbenv;
    dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    mfp->maxpgno = gbytes * (1073741824U / mfp->stat.st_pagesize);
    mfp->maxpgno = mfp->maxpgno + ((bytes + mfp->stat.st_pagesize) - 1U) / mfp->stat.st_pagesize;
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  return (0);
}
}
static int __memp_get_pgcookie(DB_MPOOLFILE *dbmfp , DBT *pgcookie ) 
{ 

  {
  if ((unsigned int )dbmfp->pgcookie == (unsigned int )((void *)0)) {
    pgcookie->size = 0U;
    pgcookie->data = (void *)"";
  } else {
    memcpy((void * __restrict  )pgcookie, (void const   * __restrict  )dbmfp->pgcookie,
           sizeof(DBT ));
  }
  return (0);
}
}
int __memp_set_pgcookie(DB_MPOOLFILE *dbmfp , DBT *pgcookie ) 
{ DB_ENV *dbenv___0 ;
  DBT *cookie ;
  int ret ;
  int tmp ;

  {
  if (dbmfp->flags & 4U) {
    tmp = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->set_pgcookie", 1);
    return (tmp);
  }
  dbenv___0 = dbmfp->dbenv;
  ret = __os_calloc(dbenv___0, 1U, sizeof((*cookie)), (void *)(& cookie));
  if (ret != 0) {
    return (ret);
  }
  ret = __os_malloc(dbenv___0, pgcookie->size, (void *)(& cookie->data));
  if (ret != 0) {
    __os_free(dbenv___0, (void *)cookie);
    return (ret);
  }
  memcpy((void * __restrict  )cookie->data, (void const   * __restrict  )pgcookie->data,
         pgcookie->size);
  cookie->size = pgcookie->size;
  dbmfp->pgcookie = cookie;
  return (0);
}
}
static int __memp_get_priority(DB_MPOOLFILE *dbmfp , DB_CACHE_PRIORITY *priorityp ) 
{ 

  {
  switch ((int )dbmfp->priority) {
  case -1: 
  (*priorityp) = (enum __anonenum_DB_CACHE_PRIORITY_53 )1;
  break;
  case -2: 
  (*priorityp) = (enum __anonenum_DB_CACHE_PRIORITY_53 )2;
  break;
  case 0: 
  (*priorityp) = (enum __anonenum_DB_CACHE_PRIORITY_53 )3;
  break;
  case 10: 
  (*priorityp) = (enum __anonenum_DB_CACHE_PRIORITY_53 )4;
  break;
  case 1: 
  (*priorityp) = (enum __anonenum_DB_CACHE_PRIORITY_53 )5;
  break;
  default: 
  __db_err((DB_ENV const   *)dbmfp->dbenv, "DB_MPOOLFILE->get_priority: unknown priority value: %d",
           dbmfp->priority);
  return (22);
  }
  return (0);
}
}
static int __memp_set_priority(DB_MPOOLFILE *dbmfp , DB_CACHE_PRIORITY priority ) 
{ 

  {
  switch ((int )priority) {
  case 1: 
  dbmfp->priority = (enum __anonenum_DB_CACHE_PRIORITY_53 )-1;
  break;
  case 2: 
  dbmfp->priority = (enum __anonenum_DB_CACHE_PRIORITY_53 )-2;
  break;
  case 3: 
  dbmfp->priority = (enum __anonenum_DB_CACHE_PRIORITY_53 )0;
  break;
  case 4: 
  dbmfp->priority = (enum __anonenum_DB_CACHE_PRIORITY_53 )10;
  break;
  case 5: 
  dbmfp->priority = (enum __anonenum_DB_CACHE_PRIORITY_53 )1;
  break;
  default: 
  __db_err((DB_ENV const   *)dbmfp->dbenv, "DB_MPOOLFILE->set_priority: unknown priority value: %d",
           priority);
  return (22);
  }
  if ((unsigned int )dbmfp->mfp != (unsigned int )((void *)0)) {
    (dbmfp->mfp)->priority = (int )priority;
  }
  return (0);
}
}
static int __memp_fopen_pp(DB_MPOOLFILE *dbmfp , char const   *path , u_int32_t flags ,
                           int mode , size_t pagesize ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dbmfp->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __db_fchk(dbenv___0, "DB_MPOOLFILE->open", flags, 28825U);
  if (ret != 0) {
    return (ret);
  }
  if (pagesize == 0U) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_MPOOLFILE->open: page sizes must be a power-of-2");
    return (22);
  } else {
    if (! ((pagesize & (pagesize - 1U)) == 0U)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_MPOOLFILE->open: page sizes must be a power-of-2");
      return (22);
    }
  }
  if (dbmfp->clear_len > pagesize) {
    __db_err((DB_ENV const   *)dbenv___0, "DB_MPOOLFILE->open: clear length larger than page size");
    return (22);
  }
  if (flags & 16U) {
    if ((unsigned int )path == (unsigned int )((void *)0)) {
      __db_err((DB_ENV const   *)dbenv___0, "DB_MPOOLFILE->open: temporary files can\'t be readonly");
      return (22);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_fopen(dbmfp, (MPOOLFILE *)((void *)0), path, flags, mode, pagesize);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_fopen(DB_MPOOLFILE *dbmfp , MPOOLFILE *mfp , char const   *path , u_int32_t flags ,
                 int mode , size_t pagesize ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  DB_MPOOLFILE *tmp_dbmfp ;
  MPOOL *mp ;
  db_pgno_t last_pgno ;
  size_t maxmap ;
  u_int32_t mbytes ;
  u_int32_t bytes ;
  u_int32_t oflags ;
  int refinc ;
  int ret ;
  char *rpath ;
  void *p ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  ret = 0;
  refinc = ret;
  rpath = (char *)((void *)0);
  if ((unsigned int )path == (unsigned int )((void *)0)) {
    goto alloc;
  }
  if ((unsigned int )mfp != (unsigned int )((void *)0)) {
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
    }
    mfp->mpf_cnt = mfp->mpf_cnt + 1U;
    refinc = 1;
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
    }
  }
  oflags = 0U;
  if (flags & 1U) {
    oflags |= 1U;
  }
  if (flags & 4096U) {
    oflags |= 2U;
  }
  if (flags & 16U) {
    dbmfp->flags = dbmfp->flags | 8U;
    oflags |= 16U;
  }
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, path, 0U, (DB_FH **)((void *)0),
                     & rpath);
  if (ret != 0) {
    goto err;
  }
  ret = __os_open_extend(dbenv___0, (char const   *)rpath, 0U, pagesize, oflags, mode,
                         & dbmfp->fhp);
  if (ret != 0) {
    if (! (flags & 8192U)) {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", rpath, tmp);
    }
    goto err;
  }
  (dbmfp->fhp)->ref = 1;
  if (dbenv___0->flags & 1048576U) {
    ret = __db_mutex_setup(dbenv___0, dbmp->reginfo, (void *)(& (dbmfp->fhp)->mutexp),
                           257U);
    if (ret != 0) {
      goto err;
    }
  }
  ret = __os_ioinfo(dbenv___0, (char const   *)rpath, dbmfp->fhp, & mbytes, & bytes,
                    (u_int32_t *)((void *)0));
  if (ret != 0) {
    tmp___0 = db_strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", rpath, tmp___0);
    goto err;
  }
  if (! (dbmfp->flags & 1U)) {
    ret = __os_fileid(dbenv___0, (char const   *)rpath, 0, dbmfp->fileid);
    if (ret != 0) {
      goto err;
    }
  }
  if ((unsigned int )mfp != (unsigned int )((void *)0)) {
    goto check_map;
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if (mp->mpfq.stqh_first == -1) {
    mfp = (MPOOLFILE *)((void *)0);
  } else {
    mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
  }
  while ((unsigned int )mfp != (unsigned int )((void *)0)) {
    if (mfp->deadfile) {
      goto __Cont;
    } else {
      if (mfp->flags & 256U) {
        goto __Cont;
      }
    }
    tmp___1 = memcmp((void const   *)(dbmfp->fileid), (void const   *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                                                mfp->fileid_off)),
                     20U);
    if (tmp___1 != 0) {
      goto __Cont;
    }
    if (flags & 128U) {
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
      }
      mfp->deadfile = 1;
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
      }
      goto __Cont;
    }
    if (dbmfp->clear_len != mfp->clear_len) {
      goto _L;
    } else {
      if (pagesize != mfp->stat.st_pagesize) {
        goto _L;
      } else {
        if (dbmfp->lsn_offset != mfp->lsn_off) {
          _L: 
          __db_err((DB_ENV const   *)dbenv___0, "%s: clear length, page size or LSN location changed",
                   path);
          if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
          }
          ret = 22;
          goto err;
        }
      }
    }
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
    }
    if (mfp->deadfile) {
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
      }
      goto __Cont;
    }
    mfp->mpf_cnt = mfp->mpf_cnt + 1U;
    refinc = 1;
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
    }
    if (dbmfp->ftype != 0) {
      mfp->ftype = dbmfp->ftype;
    }
    break;
    __Cont: 
    if (mfp->q.stqe_next == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
    }
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if ((unsigned int )mfp != (unsigned int )((void *)0)) {
    goto check_map;
  }
  alloc: 
  ret = __memp_alloc(dbmp, dbmp->reginfo, (MPOOLFILE *)((void *)0), sizeof(MPOOLFILE ),
                     (roff_t *)((void *)0), (void *)(& mfp));
  if (ret != 0) {
    goto err;
  }
  memset((void *)mfp, 0, sizeof(MPOOLFILE ));
  mfp->mpf_cnt = 1U;
  mfp->ftype = dbmfp->ftype;
  mfp->stat.st_pagesize = pagesize;
  mfp->lsn_off = dbmfp->lsn_offset;
  mfp->clear_len = dbmfp->clear_len;
  mfp->priority = (int )dbmfp->priority;
  if (dbmfp->gbytes != 0U) {
    mfp->maxpgno = dbmfp->gbytes * (1073741824U / mfp->stat.st_pagesize);
    mfp->maxpgno = mfp->maxpgno + ((dbmfp->bytes + mfp->stat.st_pagesize) - 1U) /
                                  mfp->stat.st_pagesize;
  } else {
    if (dbmfp->bytes != 0U) {
      mfp->maxpgno = dbmfp->gbytes * (1073741824U / mfp->stat.st_pagesize);
      mfp->maxpgno = mfp->maxpgno + ((dbmfp->bytes + mfp->stat.st_pagesize) - 1U) /
                                    mfp->stat.st_pagesize;
    }
  }
  if (dbmfp->config_flags & 1U) {
    mfp->no_backing_file = 1;
  }
  if (dbmfp->config_flags & 2U) {
    mfp->unlink_on_close = 1;
  }
  if (flags & 512U) {
    mfp->flags = mfp->flags | 128U;
  }
  if (flags & 4096U) {
    mfp->flags = mfp->flags | 2U;
  }
  if (flags & 8192U) {
    mfp->flags = mfp->flags | 4U;
  }
  mfp->flags = mfp->flags | 1U;
  if ((unsigned int )path == (unsigned int )((void *)0)) {
    mfp->flags = mfp->flags | 256U;
  } else {
    if (bytes % pagesize != 0U) {
      if (flags & 16384U) {
        bytes -= bytes % pagesize;
      } else {
        __db_err((DB_ENV const   *)dbenv___0, "%s: file size not a multiple of the pagesize",
                 rpath);
        ret = 22;
        goto err;
      }
    }
    last_pgno = mbytes * (1048576U / pagesize);
    last_pgno += bytes / pagesize;
    if (last_pgno != 0U) {
      last_pgno --;
    }
    mfp->last_pgno = last_pgno;
    mfp->orig_last_pgno = mfp->last_pgno;
    tmp___2 = strlen(path);
    ret = __memp_alloc(dbmp, dbmp->reginfo, (MPOOLFILE *)((void *)0), tmp___2 + 1U,
                       & mfp->path_off, (void *)(& p));
    if (ret != 0) {
      goto err;
    }
    tmp___3 = strlen(path);
    memcpy((void * __restrict  )p, (void const   * __restrict  )path, tmp___3 + 1U);
    ret = __memp_alloc(dbmp, dbmp->reginfo, (MPOOLFILE *)((void *)0), 20U, & mfp->fileid_off,
                       (void *)(& p));
    if (ret != 0) {
      goto err;
    }
    memcpy((void * __restrict  )p, (void const   * __restrict  )(dbmfp->fileid), 20U);
  }
  if ((unsigned int )dbmfp->pgcookie == (unsigned int )((void *)0)) {
    mfp->pgcookie_len = 0U;
    mfp->pgcookie_off = 0U;
  } else {
    if ((dbmfp->pgcookie)->size == 0U) {
      mfp->pgcookie_len = 0U;
      mfp->pgcookie_off = 0U;
    } else {
      ret = __memp_alloc(dbmp, dbmp->reginfo, (MPOOLFILE *)((void *)0), (dbmfp->pgcookie)->size,
                         & mfp->pgcookie_off, (void *)(& p));
      if (ret != 0) {
        goto err;
      }
      memcpy((void * __restrict  )p, (void const   * __restrict  )(dbmfp->pgcookie)->data,
             (dbmfp->pgcookie)->size);
      mfp->pgcookie_len = (dbmfp->pgcookie)->size;
    }
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  ret = __db_mutex_setup(dbenv___0, dbmp->reginfo, (void *)(& mfp->mutex), 64U);
  if (ret == 0) {
    while (1) {
      if (mp->mpfq.stqh_first != -1) {
        mfp->q.stqe_next = mp->mpfq.stqh_first - ((u_int8_t *)mfp - (u_int8_t *)(& mp->mpfq));
        if (mfp->q.stqe_next == -1) {
          ((struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first))->q.stqe_prev = 0;
        } else {
          ((struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first))->q.stqe_prev = - mfp->q.stqe_next +
                                                                                                  ((u_int8_t *)(& mfp->q.stqe_next) -
                                                                                                   (u_int8_t *)mfp);
        }
      } else {
        mp->mpfq.stqh_last = (u_int8_t *)(& mfp->q.stqe_next) - (u_int8_t *)(& mp->mpfq);
        mfp->q.stqe_next = -1;
      }
      mp->mpfq.stqh_first = (u_int8_t *)mfp - (u_int8_t *)(& mp->mpfq);
      mfp->q.stqe_prev = (u_int8_t *)(& mp->mpfq.stqh_first) - (u_int8_t *)mfp;
      break;
    }
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if (ret != 0) {
    goto err;
  }
  check_map: 
  if (! (flags & 16U)) {
    if (((! (flags & 512U) != 0) != 0) != ((! (mfp->flags & 128U) != 0) != 0)) {
      __db_err((DB_ENV const   *)dbenv___0, "Cannot open DURABLE and NOT DURABLE handles in the same file");
      ret = 22;
      goto err;
    }
  }
  dbmfp->mfp = mfp;
  if (mfp->flags & 1U) {
    if (dbenv___0->mp_mmapsize == 0U) {
      maxmap = 10485760U;
    } else {
      maxmap = dbenv___0->mp_mmapsize;
    }
    if ((unsigned int )path == (unsigned int )((void *)0)) {
      mfp->flags = mfp->flags & 4294967294U;
    } else {
      if (! (dbmfp->flags & 8U)) {
        mfp->flags = mfp->flags & 4294967294U;
      } else {
        if (dbmfp->ftype != 0) {
          mfp->flags = mfp->flags & 4294967294U;
        } else {
          if (flags & 8U) {
            mfp->flags = mfp->flags & 4294967294U;
          } else {
            if (dbenv___0->flags & 2048U) {
              mfp->flags = mfp->flags & 4294967294U;
            } else {
              if (mbytes > maxmap / 1048576U) {
                mfp->flags = mfp->flags & 4294967294U;
              } else {
                if (mbytes == maxmap / 1048576U) {
                  if (bytes >= maxmap % 1048576U) {
                    mfp->flags = mfp->flags & 4294967294U;
                  }
                }
              }
            }
          }
        }
      }
    }
    dbmfp->addr = (void *)0;
    if (mfp->flags & 1U) {
      dbmfp->len = mbytes * 1048576U + bytes;
      tmp___4 = __os_mapfile(dbenv___0, rpath, dbmfp->fhp, dbmfp->len, 1, & dbmfp->addr);
      if (tmp___4 != 0) {
        dbmfp->addr = (void *)0;
        mfp->flags = mfp->flags & 4294967294U;
      }
    }
  }
  dbmfp->flags = dbmfp->flags | 4U;
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  tmp_dbmfp = dbmp->dbmfq.tqh_first;
  while ((unsigned int )tmp_dbmfp != (unsigned int )((void *)0)) {
    if ((unsigned int )dbmfp->mfp == (unsigned int )tmp_dbmfp->mfp) {
      if (dbmfp->flags & 8U) {
        goto _L___0;
      } else {
        if (! (tmp_dbmfp->flags & 8U)) {
          _L___0: 
          if ((unsigned int )(dbmfp->fhp)->mutexp != (unsigned int )((void *)0)) {
            __db_mutex_free(dbenv___0, dbmp->reginfo, (dbmfp->fhp)->mutexp);
          }
          __os_closehandle(dbenv___0, dbmfp->fhp);
          (tmp_dbmfp->fhp)->ref = (tmp_dbmfp->fhp)->ref + 1;
          dbmfp->fhp = tmp_dbmfp->fhp;
          break;
        }
      }
    }
    tmp_dbmfp = tmp_dbmfp->q.tqe_next;
  }
  while (1) {
    dbmfp->q.tqe_next = (struct __db_mpoolfile *)((void *)0);
    dbmfp->q.tqe_prev = dbmp->dbmfq.tqh_last;
    (*(dbmp->dbmfq.tqh_last)) = dbmfp;
    dbmp->dbmfq.tqh_last = & dbmfp->q.tqe_next;
    break;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if (0) {
    err: 
    if (refinc) {
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
      }
      mfp->mpf_cnt = mfp->mpf_cnt - 1U;
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
      }
    }
  }
  if ((unsigned int )rpath != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)rpath);
  }
  return (ret);
}
}
void __memp_last_pgno(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;

  {
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  (*pgnoaddr) = (dbmfp->mfp)->last_pgno;
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  return;
}
}
static int __memp_fclose_pp(DB_MPOOLFILE *dbmfp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int t_ret ;

  {
  dbenv___0 = dbmfp->dbenv;
  ret = __db_fchk(dbenv___0, "DB_MPOOLFILE->close", flags, 4U);
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  t_ret = __memp_fclose(dbmfp, flags);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_fclose(DB_MPOOLFILE *dbmfp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  MPOOLFILE *mfp ;
  char *rpath ;
  u_int32_t ref ;
  int deleted ;
  int ret ;
  int t_ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  ret = 0;
  if ((unsigned int )dbmp == (unsigned int )((void *)0)) {
    goto done;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  dbmfp->ref = dbmfp->ref - 1U;
  ref = dbmfp->ref;
  if (ref == 0U) {
    if (dbmfp->flags & 4U) {
      while (1) {
        if ((unsigned int )dbmfp->q.tqe_next != (unsigned int )((void *)0)) {
          (dbmfp->q.tqe_next)->q.tqe_prev = dbmfp->q.tqe_prev;
        } else {
          dbmp->dbmfq.tqh_last = dbmfp->q.tqe_prev;
        }
        (*(dbmfp->q.tqe_prev)) = dbmfp->q.tqe_next;
        break;
      }
    }
  }
  if (ref == 0U) {
    if ((unsigned int )dbmfp->fhp != (unsigned int )((void *)0)) {
      (dbmfp->fhp)->ref = (dbmfp->fhp)->ref - 1;
      if ((dbmfp->fhp)->ref > 0) {
        dbmfp->fhp = (DB_FH *)((void *)0);
      }
    }
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if (ref != 0U) {
    return (0);
  }
  if (dbmfp->pinref != 0U) {
    tmp = __memp_fn(dbmfp);
    __db_err((DB_ENV const   *)dbenv___0, "%s: close: %lu blocks left pinned", tmp,
             (unsigned long )dbmfp->pinref);
    ret = __db_panic(dbenv___0, -30978);
  }
  if ((unsigned int )dbmfp->addr != (unsigned int )((void *)0)) {
    ret = __os_unmapfile(dbenv___0, dbmfp->addr, dbmfp->len);
    if (ret != 0) {
      tmp___0 = db_strerror(ret);
      tmp___1 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", tmp___1, tmp___0);
    }
  }
  if ((unsigned int )dbmfp->fhp != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbmfp->fhp)->mutexp != (unsigned int )((void *)0)) {
      __db_mutex_free(dbenv___0, dbmp->reginfo, (dbmfp->fhp)->mutexp);
      (dbmfp->fhp)->mutexp = (DB_MUTEX *)((void *)0);
    }
    t_ret = __os_closehandle(dbenv___0, dbmfp->fhp);
    if (t_ret != 0) {
      tmp___2 = db_strerror(t_ret);
      tmp___3 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", tmp___3, tmp___2);
      if (ret == 0) {
        ret = t_ret;
      }
    }
    dbmfp->fhp = (DB_FH *)((void *)0);
  }
  mfp = dbmfp->mfp;
  if (! (dbmfp->flags & 4U)) {
    goto done;
  }
  deleted = 0;
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
  }
  mfp->mpf_cnt = mfp->mpf_cnt - 1U;
  if (mfp->mpf_cnt == 0U) {
    goto _L;
  } else {
    if (flags & 4U) {
      _L: 
      if (flags & 4U) {
        mfp->deadfile = 1;
      } else {
        if (mfp->flags & 256U) {
          mfp->deadfile = 1;
        } else {
          if (mfp->unlink_on_close) {
            mfp->deadfile = 1;
          }
        }
      }
      if (mfp->unlink_on_close) {
        t_ret = __db_appname(dbmp->dbenv, (enum __anonenum_APPNAME_39 )1, (char const   *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                                                                    mfp->path_off)),
                             0U, (DB_FH **)((void *)0), & rpath);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
        if (t_ret == 0) {
          tmp___4 = __os_unlink(dbmp->dbenv, (char const   *)rpath);
          t_ret = tmp___4 != 0;
          if (t_ret) {
            if (ret == 0) {
              ret = t_ret;
            }
          }
          __os_free(dbenv___0, (void *)rpath);
        }
      }
      if (mfp->block_cnt == 0U) {
        t_ret = __memp_mf_discard(dbmp, mfp);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
        deleted = 1;
      }
    }
  }
  if (deleted == 0) {
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
    }
  }
  done: 
  if ((unsigned int )dbmfp->pgcookie != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (dbmfp->pgcookie)->data);
    __os_free(dbenv___0, (void *)dbmfp->pgcookie);
  }
  __os_free(dbenv___0, (void *)dbmfp);
  return (ret);
}
}
int __memp_mf_sync(DB_MPOOL *dbmp , MPOOLFILE *mfp ) 
{ DB_ENV *dbenv___0 ;
  DB_FH *fhp ;
  int ret ;
  int t_ret ;
  char *rpath ;

  {
  dbenv___0 = dbmp->dbenv;
  ret = __db_appname(dbenv___0, (enum __anonenum_APPNAME_39 )1, (char const   *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                                                          mfp->path_off)),
                     0U, (DB_FH **)((void *)0), & rpath);
  if (ret == 0) {
    ret = __os_open(dbenv___0, (char const   *)rpath, 0U, 0, & fhp);
    if (ret == 0) {
      ret = __os_fsync(dbenv___0, fhp);
      t_ret = __os_closehandle(dbenv___0, fhp);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    __os_free(dbenv___0, (void *)rpath);
  }
  return (ret);
}
}
int __memp_mf_discard(DB_MPOOL *dbmp , MPOOLFILE *mfp ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL_STAT *sp ;
  MPOOL *mp ;
  int ret ;

  {
  dbenv___0 = dbmp->dbenv;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  ret = 0;
  if (mfp->file_written) {
    if (! mfp->deadfile) {
      ret = __memp_mf_sync(dbmp, mfp);
    }
  }
  mfp->deadfile = 1;
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  while (1) {
    if (mfp->q.stqe_next != -1) {
      ((struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next))->q.stqe_prev = mfp->q.stqe_prev +
                                                                                  ((u_int8_t *)mfp -
                                                                                   (u_int8_t *)((struct __mpoolfile *)((u_int8_t *)mfp +
                                                                                                                       mfp->q.stqe_next)));
      (*((ssize_t *)((u_int8_t *)mfp + mfp->q.stqe_prev))) = (*((ssize_t *)((u_int8_t *)mfp +
                                                                            mfp->q.stqe_prev))) +
                                                             mfp->q.stqe_next;
    } else {
      mp->mpfq.stqh_last = mfp->q.stqe_prev + ((u_int8_t *)mfp - (u_int8_t *)(& mp->mpfq));
      (*((ssize_t *)((u_int8_t *)mfp + mfp->q.stqe_prev))) = -1;
    }
    break;
  }
  sp = & mp->stat;
  sp->st_cache_hit = sp->st_cache_hit + mfp->stat.st_cache_hit;
  sp->st_cache_miss = sp->st_cache_miss + mfp->stat.st_cache_miss;
  sp->st_map = sp->st_map + mfp->stat.st_map;
  sp->st_page_create = sp->st_page_create + mfp->stat.st_page_create;
  sp->st_page_in = sp->st_page_in + mfp->stat.st_page_in;
  sp->st_page_out = sp->st_page_out + mfp->stat.st_page_out;
  if (mfp->path_off != 0U) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                          mfp->path_off));
  }
  if (mfp->fileid_off != 0U) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                          mfp->fileid_off));
  }
  if (mfp->pgcookie_off != 0U) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                          mfp->pgcookie_off));
  }
  __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)mfp);
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  return (ret);
}
}
char *__memp_fn(DB_MPOOLFILE *dbmfp ) 
{ char *tmp ;

  {
  tmp = __memp_fns((DB_MPOOL *)(dbmfp->dbenv)->mp_handle, dbmfp->mfp);
  return (tmp);
}
}
char *__memp_fns(DB_MPOOL *dbmp , MPOOLFILE *mfp ) 
{ 

  {
  if (mfp->path_off == 0U) {
    return ((char *)"temporary");
  }
  return ((char *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + mfp->path_off)));
}
}
#pragma merger(0,"/tmp/cil-yHp6S1ex.i","-O2")
static void __memp_reset_lru(DB_ENV *dbenv___0 , REGINFO *memreg ) ;
int __memp_fput_pp(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int ret ;
  int tmp ;

  {
  dbenv___0 = dbmfp->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __memp_fput(dbmfp, pgaddr, flags);
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          __op_rep_exit(dbenv___0);
        }
      }
    }
  }
  return (ret);
}
}
int __memp_fput(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) 
{ BH *fbhp ;
  BH *bhp ;
  BH *prev ;
  DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  DB_MPOOL_HASH *hp ;
  MPOOL *c_mp ;
  u_int32_t n_cache ;
  int adjust ;
  int ret ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct __bh *tmp___4 ;
  struct __bh *tmp___5 ;
  struct __bh *tmp___6 ;
  struct __bh *tmp___7 ;

  {
  dbenv___0 = dbmfp->dbenv;
  if (! (dbmfp->flags & 4U)) {
    tmp = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->put", 0);
    return (tmp);
  }
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  if (flags) {
    ret = __db_fchk(dbenv___0, "memp_fput", flags, 7U);
    if (ret != 0) {
      return (ret);
    }
    ret = __db_fcchk(dbenv___0, "memp_fput", flags, 1U, 2U);
    if (ret != 0) {
      return (ret);
    }
    if (flags & 2U) {
      if (dbmfp->flags & 8U) {
        tmp___0 = __memp_fn(dbmfp);
        __db_err((DB_ENV const   *)dbenv___0, "%s: dirty flag set for readonly file page",
                 tmp___0);
        return (13);
      }
    }
  }
  if ((unsigned int )dbmfp->addr != (unsigned int )((void *)0)) {
    if ((unsigned int )pgaddr >= (unsigned int )dbmfp->addr) {
      if ((unsigned int )((u_int8_t *)pgaddr) <= (unsigned int )((u_int8_t *)dbmfp->addr +
                                                                 dbmfp->len)) {
        return (0);
      }
    }
  }
  bhp = (BH *)((u_int8_t *)pgaddr - (int )((unsigned short )((unsigned int )(& ((BH *)0)->buf[0]))));
  n_cache = (bhp->pgno ^ (bhp->mf_offset >> 3)) % ((MPOOL *)(dbmp->reginfo + 0)->primary)->nreg;
  c_mp = (MPOOL *)(dbmp->reginfo + n_cache)->primary;
  hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)(dbmp->reginfo + n_cache)->addr + c_mp->htab));
  hp = hp + (bhp->pgno ^ (bhp->mf_offset << 9)) % (unsigned int )c_mp->htab_buckets;
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
  }
  if (flags & 1U) {
    if ((int )bhp->flags & 2) {
      if (! ((int )bhp->flags & 4)) {
        hp->hash_page_dirty = hp->hash_page_dirty - 1U;
        bhp->flags = (unsigned short )((int )bhp->flags & -3);
      }
    }
  }
  if (flags & 2U) {
    if (! ((int )bhp->flags & 2)) {
      hp->hash_page_dirty = hp->hash_page_dirty + 1U;
      bhp->flags = (unsigned short )((int )bhp->flags | 2);
    }
  }
  if (flags & 4U) {
    bhp->flags = (unsigned short )((int )bhp->flags | 8);
  }
  if ((int )bhp->ref == 0) {
    tmp___1 = __memp_fn(dbmfp);
    __db_err((DB_ENV const   *)dbenv___0, "%s: page %lu: unpinned page returned",
             tmp___1, (unsigned long )bhp->pgno);
    if (! (hp->hash_mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
    }
    return (22);
  }
  c_mp->put_counter = c_mp->put_counter + 1U;
  bhp->ref = (unsigned short )((int )bhp->ref - 1);
  if ((int )bhp->ref > 1) {
    goto _L;
  } else {
    if ((int )bhp->ref == 1) {
      if (! ((int )bhp->flags & 16)) {
        _L: 
        if (! (hp->hash_mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
        }
        return (0);
      }
    }
  }
  if ((int )bhp->flags & 8) {
    bhp->priority = 0U;
  } else {
    if ((dbmfp->mfp)->priority == -1) {
      bhp->priority = 0U;
    } else {
      bhp->priority = c_mp->lru_count;
      adjust = 0;
      if ((dbmfp->mfp)->priority != 0) {
        adjust = (int )c_mp->stat.st_pages / (dbmfp->mfp)->priority;
      }
      if ((int )bhp->flags & 2) {
        adjust = (int )((unsigned int )adjust + c_mp->stat.st_pages / 10U);
      }
      if (adjust > 0) {
        if (4294967295U - bhp->priority >= (unsigned int )adjust) {
          bhp->priority = bhp->priority + (unsigned int )adjust;
        }
      } else {
        if (adjust < 0) {
          if (bhp->priority > (unsigned int )(- adjust)) {
            bhp->priority = bhp->priority + (unsigned int )adjust;
          }
        }
      }
    }
  }
  if (hp->hash_bucket.stqh_first == -1) {
    fbhp = (BH *)((void *)0);
  } else {
    fbhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
  }
  if (hp->hash_bucket.stqh_first == -1) {
    tmp___4 = (struct __bh *)((void *)0);
  } else {
    if (hp->hash_bucket.stqh_first == -1) {
      tmp___5 = (struct __bh *)((void *)0);
    } else {
      tmp___5 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    if (hp->hash_bucket.stqh_first == -1) {
      tmp___6 = (struct __bh *)((void *)0);
    } else {
      tmp___6 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    tmp___4 = (struct __bh *)((int )(& hp->hash_bucket) + (hp->hash_bucket.stqh_last -
                                                           ((u_int8_t *)(& tmp___5->hq.stqe_next) -
                                                            (u_int8_t *)tmp___6)));
  }
  if ((unsigned int )fbhp == (unsigned int )tmp___4) {
    goto done;
  }
  if ((unsigned int )fbhp == (unsigned int )bhp) {
    if (fbhp->hq.stqe_next == -1) {
      fbhp = (BH *)((void *)0);
    } else {
      fbhp = (struct __bh *)((u_int8_t *)fbhp + fbhp->hq.stqe_next);
    }
  }
  while (1) {
    if (bhp->hq.stqe_next != -1) {
      ((struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next))->hq.stqe_prev = bhp->hq.stqe_prev +
                                                                             ((u_int8_t *)bhp -
                                                                              (u_int8_t *)((struct __bh *)((u_int8_t *)bhp +
                                                                                                           bhp->hq.stqe_next)));
      (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = (*((ssize_t *)((u_int8_t *)bhp +
                                                                             bhp->hq.stqe_prev))) +
                                                              bhp->hq.stqe_next;
    } else {
      hp->hash_bucket.stqh_last = bhp->hq.stqe_prev + ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket));
      (*((ssize_t *)((u_int8_t *)bhp + bhp->hq.stqe_prev))) = -1;
    }
    break;
  }
  prev = (BH *)((void *)0);
  while ((unsigned int )fbhp != (unsigned int )((void *)0)) {
    if (fbhp->priority > bhp->priority) {
      break;
    }
    prev = fbhp;
    if (fbhp->hq.stqe_next == -1) {
      fbhp = (BH *)((void *)0);
    } else {
      fbhp = (struct __bh *)((u_int8_t *)fbhp + fbhp->hq.stqe_next);
    }
  }
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
    while (1) {
      if (hp->hash_bucket.stqh_first != -1) {
        bhp->hq.stqe_next = hp->hash_bucket.stqh_first - ((u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket));
        if (bhp->hq.stqe_next == -1) {
          ((struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first))->hq.stqe_prev = 0;
        } else {
          ((struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first))->hq.stqe_prev = - bhp->hq.stqe_next +
                                                                                                          ((u_int8_t *)(& bhp->hq.stqe_next) -
                                                                                                           (u_int8_t *)bhp);
        }
      } else {
        hp->hash_bucket.stqh_last = (u_int8_t *)(& bhp->hq.stqe_next) - (u_int8_t *)(& hp->hash_bucket);
        bhp->hq.stqe_next = -1;
      }
      hp->hash_bucket.stqh_first = (u_int8_t *)bhp - (u_int8_t *)(& hp->hash_bucket);
      bhp->hq.stqe_prev = (u_int8_t *)(& hp->hash_bucket.stqh_first) - (u_int8_t *)bhp;
      break;
    }
  } else {
    while (1) {
      if (prev->hq.stqe_next != -1) {
        bhp->hq.stqe_next = prev->hq.stqe_next - ((u_int8_t *)bhp - (u_int8_t *)prev);
        if (bhp->hq.stqe_next == -1) {
          ((struct __bh *)((u_int8_t *)prev + prev->hq.stqe_next))->hq.stqe_prev = 0;
        } else {
          ((struct __bh *)((u_int8_t *)prev + prev->hq.stqe_next))->hq.stqe_prev = - bhp->hq.stqe_next +
                                                                                   ((u_int8_t *)(& bhp->hq.stqe_next) -
                                                                                    (u_int8_t *)bhp);
        }
      } else {
        bhp->hq.stqe_next = -1;
        hp->hash_bucket.stqh_last = (u_int8_t *)(& bhp->hq.stqe_next) - (u_int8_t *)(& hp->hash_bucket);
      }
      prev->hq.stqe_next = (u_int8_t *)bhp - (u_int8_t *)prev;
      if (prev->hq.stqe_next == -1) {
        bhp->hq.stqe_prev = 0;
      } else {
        bhp->hq.stqe_prev = - prev->hq.stqe_next + ((u_int8_t *)(& prev->hq.stqe_next) -
                                                    (u_int8_t *)prev);
      }
      break;
    }
  }
  done: 
  if (hp->hash_bucket.stqh_first == -1) {
    tmp___7 = (struct __bh *)((void *)0);
  } else {
    tmp___7 = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
  }
  hp->hash_priority = tmp___7->priority;
  if ((int )bhp->flags & 16) {
    if ((int )bhp->ref_sync != 0) {
      bhp->ref_sync = (unsigned short )((int )bhp->ref_sync - 1);
    }
  }
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
  }
  c_mp->lru_count = c_mp->lru_count + 1U;
  if (c_mp->lru_count == 4294967295U) {
    __memp_reset_lru(dbenv___0, dbmp->reginfo);
  }
  return (0);
}
}
static void __memp_reset_lru(DB_ENV *dbenv___0 , REGINFO *memreg ) 
{ BH *bhp ;
  DB_MPOOL_HASH *hp ;
  MPOOL *c_mp ;
  int bucket ;
  struct __bh *tmp ;

  {
  c_mp = (MPOOL *)memreg->primary;
  c_mp->lru_count = c_mp->lru_count - 3221225472U;
  hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)memreg->addr + c_mp->htab));
  bucket = 0;
  while (bucket < c_mp->htab_buckets) {
    if (hp->hash_bucket.stqh_first == -1) {
      tmp = (struct __bh *)((void *)0);
    } else {
      tmp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
      goto __Cont;
    }
    if (! (hp->hash_mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
    }
    if (hp->hash_bucket.stqh_first == -1) {
      bhp = (BH *)((void *)0);
    } else {
      bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    while ((unsigned int )bhp != (unsigned int )((void *)0)) {
      if (bhp->priority != 4294967295U) {
        if (bhp->priority > 3221225472U) {
          if (! (hp->hash_mutex.flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
          }
        }
      }
      if (bhp->hq.stqe_next == -1) {
        bhp = (BH *)((void *)0);
      } else {
        bhp = (struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next);
      }
    }
    __Cont: 
    hp ++;
    bucket ++;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-JW2Kj7as.i","-O2")
int __memp_fset_pp(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  dbenv___0 = dbmfp->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbmfp->flags & 4U)) {
    tmp___0 = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->set", 0);
    return (tmp___0);
  }
  if (flags == 0U) {
    tmp___1 = __db_ferr((DB_ENV const   *)dbenv___0, "memp_fset", 1);
    return (tmp___1);
  }
  ret = __db_fchk(dbenv___0, "memp_fset", flags, 7U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fcchk(dbenv___0, "memp_fset", flags, 1U, 2U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 2U) {
    if (dbmfp->flags & 8U) {
      tmp___2 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: dirty flag set for readonly file page",
               tmp___2);
      return (13);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_fset(dbmfp, pgaddr, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_fset(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t flags ) 
{ BH *bhp ;
  DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  DB_MPOOL_HASH *hp ;
  MPOOL *c_mp ;
  u_int32_t n_cache ;

  {
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  bhp = (BH *)((u_int8_t *)pgaddr - (int )((unsigned short )((unsigned int )(& ((BH *)0)->buf[0]))));
  n_cache = (bhp->pgno ^ (bhp->mf_offset >> 3)) % ((MPOOL *)(dbmp->reginfo + 0)->primary)->nreg;
  c_mp = (MPOOL *)(dbmp->reginfo + n_cache)->primary;
  hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)(dbmp->reginfo + n_cache)->addr + c_mp->htab));
  hp = hp + (bhp->pgno ^ (bhp->mf_offset << 9)) % (unsigned int )c_mp->htab_buckets;
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
  }
  if (flags & 1U) {
    if ((int )bhp->flags & 2) {
      if (! ((int )bhp->flags & 4)) {
        hp->hash_page_dirty = hp->hash_page_dirty - 1U;
        bhp->flags = (unsigned short )((int )bhp->flags & -3);
      }
    }
  }
  if (flags & 2U) {
    if (! ((int )bhp->flags & 2)) {
      hp->hash_page_dirty = hp->hash_page_dirty + 1U;
      bhp->flags = (unsigned short )((int )bhp->flags | 2);
    }
  }
  if (flags & 4U) {
    bhp->flags = (unsigned short )((int )bhp->flags | 8);
  }
  if (! (hp->hash_mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-xscsOQZc.i","-O2")
int __os_rename(DB_ENV *dbenv___0 , char const   *old , char const   *new , u_int32_t flags ) ;
int __memp_register_pp(DB_ENV *dbenv___0 , int ftype , int (*pgin)(DB_ENV * , db_pgno_t  ,
                                                                   void * , DBT * ) ,
                       int (*pgout)(DB_ENV * , db_pgno_t  , void * , DBT * ) ) ;
int __memp_stat_pp(DB_ENV *dbenv___0 , DB_MPOOL_STAT **gspp , DB_MPOOL_FSTAT ***fspp ,
                   u_int32_t flags ) ;
int __memp_dump_region(DB_ENV *dbenv___0 , char const   *area , FILE *fp ) ;
int __memp_sync_pp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) ;
int __memp_trickle_pp(DB_ENV *dbenv___0 , int pct , int *nwrotep ) ;
static int __memp_get_mp_maxwrite(DB_ENV *dbenv___0 , int *maxwritep , int *maxwrite_sleepp ) ;
static int __memp_set_mp_maxwrite(DB_ENV *dbenv___0 , int maxwrite , int maxwrite_sleep ) ;
static int __memp_get_mp_mmapsize(DB_ENV *dbenv___0 , size_t *mp_mmapsizep ) ;
void __memp_dbenv_create(DB_ENV *dbenv___0 ) 
{ 

  {
  dbenv___0->mp_bytes = 32U * (8192U + sizeof(BH )) + 37U * sizeof(DB_MPOOL_HASH );
  dbenv___0->mp_ncache = 1;
  dbenv___0->get_cachesize = & __memp_get_cachesize;
  dbenv___0->set_cachesize = & __memp_set_cachesize;
  dbenv___0->get_mp_maxwrite = & __memp_get_mp_maxwrite;
  dbenv___0->set_mp_maxwrite = & __memp_set_mp_maxwrite;
  dbenv___0->get_mp_mmapsize = & __memp_get_mp_mmapsize;
  dbenv___0->set_mp_mmapsize = & __memp_set_mp_mmapsize;
  dbenv___0->memp_dump_region = & __memp_dump_region;
  dbenv___0->memp_register = & __memp_register_pp;
  dbenv___0->memp_stat = & __memp_stat_pp;
  dbenv___0->memp_sync = & __memp_sync_pp;
  dbenv___0->memp_trickle = & __memp_trickle_pp;
  dbenv___0->memp_fcreate = & __memp_fcreate_pp;
  return;
}
}
int __memp_get_cachesize(DB_ENV *dbenv___0 , u_int32_t *gbytesp , u_int32_t *bytesp ,
                         int *ncachep ) 
{ 

  {
  if ((unsigned int )gbytesp != (unsigned int )((void *)0)) {
    (*gbytesp) = dbenv___0->mp_gbytes;
  }
  if ((unsigned int )bytesp != (unsigned int )((void *)0)) {
    (*bytesp) = dbenv___0->mp_bytes;
  }
  if ((unsigned int )ncachep != (unsigned int )((void *)0)) {
    (*ncachep) = dbenv___0->mp_ncache;
  }
  return (0);
}
}
int __memp_set_cachesize(DB_ENV *dbenv___0 , u_int32_t gbytes , u_int32_t bytes ,
                         int ncache ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_cachesize", 1);
    return (tmp);
  }
  if (ncache == 0) {
    ncache = 1;
  }
  if (gbytes / (unsigned int )ncache == 4U) {
    if (bytes == 0U) {
      gbytes --;
      bytes = 1073741823U;
    } else {
      gbytes += bytes / 1073741824U;
      bytes %= 1073741824U;
    }
  } else {
    gbytes += bytes / 1073741824U;
    bytes %= 1073741824U;
  }
  if (gbytes / (unsigned int )ncache > 4U) {
    __db_err((DB_ENV const   *)dbenv___0, "individual cache size too large");
    return (22);
  } else {
    if (gbytes / (unsigned int )ncache == 4U) {
      if (bytes != 0U) {
        __db_err((DB_ENV const   *)dbenv___0, "individual cache size too large");
        return (22);
      }
    }
  }
  if (gbytes == 0U) {
    if (bytes < 524288000U) {
      bytes += bytes / 4U + 37U * sizeof(DB_MPOOL_HASH );
    }
    if (bytes / (unsigned int )ncache < 20480U) {
      bytes = (unsigned int )(ncache * 20480);
    }
  }
  dbenv___0->mp_gbytes = gbytes;
  dbenv___0->mp_bytes = bytes;
  dbenv___0->mp_ncache = ncache;
  return (0);
}
}
static int __memp_get_mp_maxwrite(DB_ENV *dbenv___0 , int *maxwritep , int *maxwrite_sleepp ) 
{ 

  {
  (*maxwritep) = dbenv___0->mp_maxwrite;
  (*maxwrite_sleepp) = dbenv___0->mp_maxwrite_sleep;
  return (0);
}
}
static int __memp_set_mp_maxwrite(DB_ENV *dbenv___0 , int maxwrite , int maxwrite_sleep ) 
{ 

  {
  dbenv___0->mp_maxwrite = maxwrite;
  dbenv___0->mp_maxwrite_sleep = maxwrite_sleep;
  return (0);
}
}
static int __memp_get_mp_mmapsize(DB_ENV *dbenv___0 , size_t *mp_mmapsizep ) 
{ 

  {
  (*mp_mmapsizep) = dbenv___0->mp_mmapsize;
  return (0);
}
}
int __memp_set_mp_mmapsize(DB_ENV *dbenv___0 , size_t mp_mmapsize ) 
{ 

  {
  dbenv___0->mp_mmapsize = mp_mmapsize;
  return (0);
}
}
int __memp_nameop(DB_ENV *dbenv___0 , u_int8_t *fileid , char const   *newname , char const   *fullold ,
                  char const   *fullnew ) 
{ DB_MPOOL *dbmp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  roff_t newname_off ;
  int locked ;
  int ret ;
  void *p ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  locked = 0;
  dbmp = (DB_MPOOL *)((void *)0);
  if (! ((unsigned int )dbenv___0->mp_handle != (unsigned int )((void *)0))) {
    goto fsop;
  }
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  if ((unsigned int )newname == (unsigned int )((void *)0)) {
    p = (void *)0;
  } else {
    tmp = strlen(newname);
    ret = __memp_alloc(dbmp, dbmp->reginfo, (MPOOLFILE *)((void *)0), tmp + 1U, & newname_off,
                       (void *)(& p));
    if (ret != 0) {
      return (ret);
    }
    tmp___0 = strlen(newname);
    memcpy((void * __restrict  )p, (void const   * __restrict  )newname, tmp___0 +
                                                                         1U);
  }
  locked = 1;
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if (mp->mpfq.stqh_first == -1) {
    mfp = (MPOOLFILE *)((void *)0);
  } else {
    mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
  }
  while ((unsigned int )mfp != (unsigned int )((void *)0)) {
    if (mfp->deadfile) {
      goto __Cont;
    } else {
      if (mfp->flags & 256U) {
        goto __Cont;
      }
    }
    tmp___1 = memcmp((void const   *)fileid, (void const   *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                                       mfp->fileid_off)),
                     20U);
    if (tmp___1 != 0) {
      goto __Cont;
    }
    if ((unsigned int )newname == (unsigned int )((void *)0)) {
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
      }
      mfp->deadfile = 1;
      if (! (mfp->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
      }
    } else {
      p = (void *)((u_int8_t *)(dbmp->reginfo)->addr + mfp->path_off);
      mfp->path_off = newname_off;
    }
    break;
    __Cont: 
    if (mfp->q.stqe_next == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
    }
  }
  if ((unsigned int )p != (unsigned int )((void *)0)) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, p);
  }
  fsop: 
  if ((unsigned int )newname == (unsigned int )((void *)0)) {
    ret = __os_unlink(dbenv___0, fullold);
  } else {
    ret = __os_rename(dbenv___0, fullold, fullnew, 1U);
  }
  if (locked) {
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  return (ret);
}
}
int __memp_get_refcnt(DB_ENV *dbenv___0 , u_int8_t *fileid , int *refp ) 
{ DB_MPOOL *dbmp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  int tmp ;

  {
  (*refp) = 0;
  if (! ((unsigned int )dbenv___0->mp_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if (mp->mpfq.stqh_first == -1) {
    mfp = (MPOOLFILE *)((void *)0);
  } else {
    mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
  }
  while ((unsigned int )mfp != (unsigned int )((void *)0)) {
    if (mfp->deadfile) {
      goto __Cont;
    } else {
      if (mfp->flags & 256U) {
        goto __Cont;
      }
    }
    tmp = memcmp((void const   *)fileid, (void const   *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                                   mfp->fileid_off)),
                 20U);
    if (tmp != 0) {
      goto __Cont;
    }
    (*refp) = (int )mfp->mpf_cnt;
    break;
    __Cont: 
    if (mfp->q.stqe_next == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
    }
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-4148VxCh.i","-O2")
static int __mpool_init(DB_ENV *dbenv___0 , DB_MPOOL *dbmp , int reginfo_off , int htab_buckets ) ;
int __memp_open(DB_ENV *dbenv___0 ) 
{ DB_MPOOL *dbmp ;
  MPOOL *mp ;
  REGINFO reginfo ;
  roff_t reg_size ;
  roff_t *regids ;
  u_int32_t i ;
  int htab_buckets ;
  int ret ;

  {
  reg_size = (dbenv___0->mp_gbytes / (unsigned int )dbenv___0->mp_ncache) * 1073741824U;
  reg_size += ((dbenv___0->mp_gbytes % (unsigned int )dbenv___0->mp_ncache) * 1073741824U) /
              (unsigned int )dbenv___0->mp_ncache;
  reg_size += dbenv___0->mp_bytes / (unsigned int )dbenv___0->mp_ncache;
  htab_buckets = __db_tablesize((reg_size / 1024U) / 10U);
  ret = __os_calloc(dbenv___0, 1U, sizeof((*dbmp)), (void *)(& dbmp));
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    dbmp->dbregq.lh_first = (struct __db_mpreg *)((void *)0);
    break;
  }
  while (1) {
    dbmp->dbmfq.tqh_first = (struct __db_mpoolfile *)((void *)0);
    dbmp->dbmfq.tqh_last = & dbmp->dbmfq.tqh_first;
    break;
  }
  dbmp->dbenv = dbenv___0;
  memset((void *)(& reginfo), 0, sizeof(REGINFO ));
  reginfo.type = (enum __anonenum_reg_type_50 )4;
  reginfo.id = 0U;
  reginfo.mode = dbenv___0->db_mode;
  reginfo.flags = 4U;
  if (dbenv___0->flags & 8U) {
    reginfo.flags = reginfo.flags | 2U;
  }
  ret = __db_r_attach(dbenv___0, & reginfo, reg_size);
  if (ret != 0) {
    goto err;
  }
  if (reginfo.flags & 1U) {
    dbmp->nreg = (unsigned int )dbenv___0->mp_ncache;
    ret = __os_calloc(dbenv___0, dbmp->nreg, sizeof(REGINFO ), (void *)(& dbmp->reginfo));
    if (ret != 0) {
      goto err;
    }
    i = 0U;
    while (i < dbmp->nreg) {
      (dbmp->reginfo + i)->id = 0U;
      i ++;
    }
    (*(dbmp->reginfo + 0)) = reginfo;
    ret = __mpool_init(dbenv___0, dbmp, 0, htab_buckets);
    if (ret != 0) {
      goto err;
    }
    mp = (MPOOL *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + ((dbmp->reginfo +
                                                                  0)->rp)->primary));
    regids = (roff_t *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + mp->regids));
    i = 1U;
    while (i < dbmp->nreg) {
      (dbmp->reginfo + i)->type = (enum __anonenum_reg_type_50 )4;
      (dbmp->reginfo + i)->id = 0U;
      (dbmp->reginfo + i)->mode = dbenv___0->db_mode;
      (dbmp->reginfo + i)->flags = 2U;
      ret = __db_r_attach(dbenv___0, dbmp->reginfo + i, reg_size);
      if (ret != 0) {
        goto err;
      }
      ret = __mpool_init(dbenv___0, dbmp, (int )i, htab_buckets);
      if (ret != 0) {
        goto err;
      }
      if (! (((dbmp->reginfo + i)->rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo + i)->rp)->mutex);
      }
      (*(regids + i)) = (dbmp->reginfo + i)->id;
      i ++;
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  } else {
    mp = (MPOOL *)((void *)((u_int8_t *)reginfo.addr + (reginfo.rp)->primary));
    dbmp->nreg = mp->nreg;
    ret = __os_calloc(dbenv___0, dbmp->nreg, sizeof(REGINFO ), (void *)(& dbmp->reginfo));
    if (ret != 0) {
      goto err;
    }
    i = 0U;
    while (i < dbmp->nreg) {
      (dbmp->reginfo + i)->id = 0U;
      i ++;
    }
    (*(dbmp->reginfo + 0)) = reginfo;
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    regids = (roff_t *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + mp->regids));
    i = 1U;
    while (i < dbmp->nreg) {
      (dbmp->reginfo + i)->type = (enum __anonenum_reg_type_50 )4;
      (dbmp->reginfo + i)->id = (*(regids + i));
      (dbmp->reginfo + i)->mode = 0;
      (dbmp->reginfo + i)->flags = 4U;
      ret = __db_r_attach(dbenv___0, dbmp->reginfo + i, 0U);
      if (ret != 0) {
        goto err;
      }
      if (! (((dbmp->reginfo + i)->rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo + i)->rp)->mutex);
      }
      i ++;
    }
  }
  i = 0U;
  while (i < dbmp->nreg) {
    (dbmp->reginfo + i)->primary = (void *)((u_int8_t *)(dbmp->reginfo + i)->addr +
                                            ((dbmp->reginfo + i)->rp)->primary);
    i ++;
  }
  if (dbenv___0->flags & 1048576U) {
    ret = __db_mutex_setup(dbenv___0, dbmp->reginfo, (void *)(& dbmp->mutexp), 257U);
    if (ret != 0) {
      goto err;
    }
  }
  dbenv___0->mp_handle = (void *)dbmp;
  return (0);
  err: 
  if ((unsigned int )dbmp->reginfo != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbmp->reginfo + 0)->addr != (unsigned int )((void *)0)) {
      if ((dbmp->reginfo)->flags & 1U) {
        ret = __db_panic(dbenv___0, ret);
      }
      if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
      }
      i = 0U;
      while (i < dbmp->nreg) {
        if ((dbmp->reginfo + i)->id != 0U) {
          __db_r_detach(dbenv___0, dbmp->reginfo + i, 0);
        }
        i ++;
      }
      __os_free(dbenv___0, (void *)dbmp->reginfo);
    }
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    __db_mutex_free(dbenv___0, dbmp->reginfo, dbmp->mutexp);
  }
  __os_free(dbenv___0, (void *)dbmp);
  return (ret);
}
}
static int __mpool_init(DB_ENV *dbenv___0 , DB_MPOOL *dbmp , int reginfo_off , int htab_buckets ) 
{ DB_MPOOL_HASH *htab ;
  MPOOL *mp ;
  REGINFO *reginfo ;
  int i ;
  int ret ;
  void *p ;

  {
  mp = (MPOOL *)((void *)0);
  reginfo = dbmp->reginfo + reginfo_off;
  ret = __db_shalloc(reginfo->addr, sizeof(MPOOL ), 1U, (void *)(& reginfo->primary));
  if (ret != 0) {
    goto mem_err;
  }
  (reginfo->rp)->primary = (unsigned int )((u_int8_t *)reginfo->primary - (u_int8_t *)reginfo->addr);
  mp = (MPOOL *)reginfo->primary;
  memset((void *)mp, 0, sizeof((*mp)));
  if (reginfo_off == 0) {
    mp->mpfq.stqh_first = -1;
    mp->mpfq.stqh_last = (u_int8_t *)(& mp->mpfq.stqh_first) - (u_int8_t *)(& mp->mpfq);
    while (1) {
      mp->lsn.file = 0U;
      mp->lsn.offset = 0U;
      break;
    }
    mp->nreg = dbmp->nreg;
    ret = __db_shalloc((dbmp->reginfo + 0)->addr, dbmp->nreg * sizeof(int ), 0U, (void *)(& p));
    if (ret != 0) {
      goto mem_err;
    }
    mp->regids = (unsigned int )((u_int8_t *)p - (u_int8_t *)(dbmp->reginfo)->addr);
  }
  ret = __db_shalloc(reginfo->addr, (unsigned int )htab_buckets * sizeof(DB_MPOOL_HASH ),
                     0U, (void *)(& htab));
  if (ret != 0) {
    goto mem_err;
  }
  mp->htab = (unsigned int )((u_int8_t *)htab - (u_int8_t *)reginfo->addr);
  i = 0;
  while (i < htab_buckets) {
    ret = __db_mutex_setup(dbenv___0, reginfo, (void *)(& (htab + i)->hash_mutex),
                           64U);
    if (ret != 0) {
      return (ret);
    }
    (htab + i)->hash_bucket.stqh_first = -1;
    (htab + i)->hash_bucket.stqh_last = (u_int8_t *)(& (htab + i)->hash_bucket.stqh_first) -
                                        (u_int8_t *)(& (htab + i)->hash_bucket);
    (htab + i)->hash_priority = 0U;
    (htab + i)->hash_page_dirty = (htab + i)->hash_priority;
    i ++;
  }
  mp->stat.st_hash_buckets = (unsigned int )htab_buckets;
  mp->htab_buckets = (int )mp->stat.st_hash_buckets;
  mp->stat.st_gbytes = dbenv___0->mp_gbytes;
  mp->stat.st_bytes = dbenv___0->mp_bytes;
  return (0);
  mem_err: 
  __db_err((DB_ENV const   *)dbenv___0, "Unable to allocate memory for mpool region");
  return (ret);
}
}
int __memp_dbenv_refresh(DB_ENV *dbenv___0 ) 
{ DB_MPOOL *dbmp ;
  DB_MPOOLFILE *dbmfp ;
  DB_MPREG *mpreg ;
  u_int32_t i ;
  int ret ;
  int t_ret ;

  {
  ret = 0;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  while (1) {
    mpreg = dbmp->dbregq.lh_first;
    if (! ((unsigned int )mpreg != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      if ((unsigned int )mpreg->q.le_next != (unsigned int )((void *)0)) {
        (mpreg->q.le_next)->q.le_prev = mpreg->q.le_prev;
      }
      (*(mpreg->q.le_prev)) = mpreg->q.le_next;
      break;
    }
    __os_free(dbenv___0, (void *)mpreg);
  }
  while (1) {
    dbmfp = dbmp->dbmfq.tqh_first;
    if (! ((unsigned int )dbmfp != (unsigned int )((void *)0))) {
      break;
    }
    t_ret = __memp_fclose(dbmfp, 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    __db_mutex_free(dbenv___0, dbmp->reginfo, dbmp->mutexp);
  }
  i = 0U;
  while (i < dbmp->nreg) {
    t_ret = __db_r_detach(dbenv___0, dbmp->reginfo + i, 0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    i ++;
  }
  __os_free(dbenv___0, (void *)dbmp->reginfo);
  __os_free(dbenv___0, (void *)dbmp);
  dbenv___0->mp_handle = (void *)0;
  return (ret);
}
}
void __mpool_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  return;
}
}
#pragma merger(0,"/tmp/cil-6vzRZaoo.i","-O2")
int __memp_register_pp(DB_ENV *dbenv___0 , int ftype , int (*pgin)(DB_ENV * , db_pgno_t  ,
                                                                   void * , DBT * ) ,
                       int (*pgout)(DB_ENV * , db_pgno_t  , void * , DBT * ) ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->mp_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"DB_ENV->memp_register", 32768U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_register(dbenv___0, ftype, pgin, pgout);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_register(DB_ENV *dbenv___0 , int ftype , int (*pgin)(DB_ENV * , db_pgno_t  ,
                                                                void * , DBT * ) ,
                    int (*pgout)(DB_ENV * , db_pgno_t  , void * , DBT * ) ) 
{ DB_MPOOL *dbmp ;
  DB_MPREG *mpreg ;
  int ret ;

  {
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  mpreg = dbmp->dbregq.lh_first;
  while ((unsigned int )mpreg != (unsigned int )((void *)0)) {
    if (mpreg->ftype == ftype) {
      mpreg->pgin = pgin;
      mpreg->pgout = pgout;
      break;
    }
    mpreg = mpreg->q.le_next;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if ((unsigned int )mpreg != (unsigned int )((void *)0)) {
    return (0);
  }
  ret = __os_malloc(dbenv___0, sizeof(DB_MPREG ), (void *)(& mpreg));
  if (ret != 0) {
    return (ret);
  }
  mpreg->ftype = ftype;
  mpreg->pgin = pgin;
  mpreg->pgout = pgout;
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  while (1) {
    mpreg->q.le_next = dbmp->dbregq.lh_first;
    if ((unsigned int )mpreg->q.le_next != (unsigned int )((void *)0)) {
      (dbmp->dbregq.lh_first)->q.le_prev = & mpreg->q.le_next;
    }
    dbmp->dbregq.lh_first = mpreg;
    mpreg->q.le_prev = & dbmp->dbregq.lh_first;
    break;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-S84E4N0k.i","-O2")
void __memp_stat_hash(REGINFO *reginfo , MPOOL *mp , u_int32_t *dirtyp ) ;
static void __memp_dumpcache(DB_ENV *dbenv___0 , DB_MPOOL *dbmp , REGINFO *reginfo ,
                             size_t *fmap , FILE *fp , u_int32_t flags ) ;
static void __memp_pbh(DB_MPOOL *dbmp , BH *bhp , size_t *fmap , FILE *fp ) ;
static int __memp_stat(DB_ENV *dbenv___0 , DB_MPOOL_STAT **gspp , DB_MPOOL_FSTAT ***fspp ,
                       u_int32_t flags ) ;
static void __memp_stat_wait(REGINFO *reginfo , MPOOL *mp , DB_MPOOL_STAT *mstat ,
                             int flags ) ;
int __memp_stat_pp(DB_ENV *dbenv___0 , DB_MPOOL_STAT **gspp , DB_MPOOL_FSTAT ***fspp ,
                   u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->mp_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"memp_stat", 32768U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->memp_stat", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_stat(dbenv___0, gspp, fspp, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __memp_stat(DB_ENV *dbenv___0 , DB_MPOOL_STAT **gspp , DB_MPOOL_FSTAT ***fspp ,
                       u_int32_t flags ) 
{ DB_MPOOL *dbmp ;
  DB_MPOOL_FSTAT **tfsp ;
  DB_MPOOL_FSTAT *tstruct ;
  DB_MPOOL_STAT *sp ;
  MPOOL *c_mp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  size_t len ;
  size_t nlen ;
  size_t pagesize ;
  u_int32_t pages ;
  u_int32_t i ;
  int ret ;
  char *name ;
  char *tname ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  u_int32_t tmp___2 ;

  {
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  if ((unsigned int )gspp != (unsigned int )((void *)0)) {
    (*gspp) = (DB_MPOOL_STAT *)((void *)0);
    ret = __os_umalloc(dbenv___0, sizeof((*((*gspp)))), (void *)gspp);
    if (ret != 0) {
      return (ret);
    }
    memset((void *)(*gspp), 0, sizeof((*((*gspp)))));
    sp = (*gspp);
    c_mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
    sp->st_gbytes = c_mp->stat.st_gbytes;
    sp->st_bytes = c_mp->stat.st_bytes;
    sp->st_ncache = dbmp->nreg;
    sp->st_regsize = ((dbmp->reginfo + 0)->rp)->size;
    i = 0U;
    while (i < mp->nreg) {
      c_mp = (MPOOL *)(dbmp->reginfo + i)->primary;
      sp->st_map = sp->st_map + c_mp->stat.st_map;
      sp->st_cache_hit = sp->st_cache_hit + c_mp->stat.st_cache_hit;
      sp->st_cache_miss = sp->st_cache_miss + c_mp->stat.st_cache_miss;
      sp->st_page_create = sp->st_page_create + c_mp->stat.st_page_create;
      sp->st_page_in = sp->st_page_in + c_mp->stat.st_page_in;
      sp->st_page_out = sp->st_page_out + c_mp->stat.st_page_out;
      sp->st_ro_evict = sp->st_ro_evict + c_mp->stat.st_ro_evict;
      sp->st_rw_evict = sp->st_rw_evict + c_mp->stat.st_rw_evict;
      sp->st_page_trickle = sp->st_page_trickle + c_mp->stat.st_page_trickle;
      sp->st_pages = sp->st_pages + c_mp->stat.st_pages;
      __memp_stat_hash(dbmp->reginfo + i, c_mp, & sp->st_page_dirty);
      sp->st_page_clean = sp->st_pages - sp->st_page_dirty;
      sp->st_hash_buckets = sp->st_hash_buckets + c_mp->stat.st_hash_buckets;
      sp->st_hash_searches = sp->st_hash_searches + c_mp->stat.st_hash_searches;
      sp->st_hash_longest = sp->st_hash_longest + c_mp->stat.st_hash_longest;
      sp->st_hash_examined = sp->st_hash_examined + c_mp->stat.st_hash_examined;
      __memp_stat_wait(dbmp->reginfo + i, c_mp, sp, (int )flags);
      sp->st_region_nowait = sp->st_region_nowait + ((dbmp->reginfo + i)->rp)->mutex.mutex_set_nowait;
      sp->st_region_wait = sp->st_region_wait + ((dbmp->reginfo + i)->rp)->mutex.mutex_set_wait;
      sp->st_alloc = sp->st_alloc + c_mp->stat.st_alloc;
      sp->st_alloc_buckets = sp->st_alloc_buckets + c_mp->stat.st_alloc_buckets;
      if (sp->st_alloc_max_buckets < c_mp->stat.st_alloc_max_buckets) {
        sp->st_alloc_max_buckets = c_mp->stat.st_alloc_max_buckets;
      }
      sp->st_alloc_pages = sp->st_alloc_pages + c_mp->stat.st_alloc_pages;
      if (sp->st_alloc_max_pages < c_mp->stat.st_alloc_max_pages) {
        sp->st_alloc_max_pages = c_mp->stat.st_alloc_max_pages;
      }
      if (flags & 1U) {
        ((dbmp->reginfo + i)->rp)->mutex.mutex_set_wait = 0U;
        ((dbmp->reginfo + i)->rp)->mutex.mutex_set_nowait = 0U;
        if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
        }
        pages = c_mp->stat.st_pages;
        memset((void *)(& c_mp->stat), 0, sizeof(c_mp->stat));
        c_mp->stat.st_hash_buckets = (unsigned int )c_mp->htab_buckets;
        c_mp->stat.st_pages = pages;
        if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
        }
      }
      i ++;
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    if (mp->mpfq.stqh_first == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
    }
    while ((unsigned int )mfp != (unsigned int )((void *)0)) {
      sp->st_map = sp->st_map + mfp->stat.st_map;
      sp->st_cache_hit = sp->st_cache_hit + mfp->stat.st_cache_hit;
      sp->st_cache_miss = sp->st_cache_miss + mfp->stat.st_cache_miss;
      sp->st_page_create = sp->st_page_create + mfp->stat.st_page_create;
      sp->st_page_in = sp->st_page_in + mfp->stat.st_page_in;
      sp->st_page_out = sp->st_page_out + mfp->stat.st_page_out;
      if ((unsigned int )fspp == (unsigned int )((void *)0)) {
        if (flags & 1U) {
          pagesize = mfp->stat.st_pagesize;
          memset((void *)(& mfp->stat), 0, sizeof(mfp->stat));
          mfp->stat.st_pagesize = pagesize;
        }
      }
      if (mfp->q.stqe_next == -1) {
        mfp = (MPOOLFILE *)((void *)0);
      } else {
        mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
      }
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  if ((unsigned int )fspp != (unsigned int )((void *)0)) {
    (*fspp) = (DB_MPOOL_FSTAT **)((void *)0);
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    i = 0U;
    len = 0U;
    if (mp->mpfq.stqh_first == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
    }
    while ((unsigned int )mfp != (unsigned int )((void *)0)) {
      tmp = __memp_fns(dbmp, mfp);
      tmp___0 = strlen(tmp);
      len += ((sizeof(DB_MPOOL_FSTAT *) + sizeof(DB_MPOOL_FSTAT )) + tmp___0) + 1U;
      i ++;
      if (mfp->q.stqe_next == -1) {
        mfp = (MPOOLFILE *)((void *)0);
      } else {
        mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
      }
    }
    len += sizeof(DB_MPOOL_FSTAT *);
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    if (i == 0U) {
      return (0);
    }
    ret = __os_umalloc(dbenv___0, len, (void *)fspp);
    if (ret != 0) {
      return (ret);
    }
    tfsp = (*fspp);
    tstruct = (DB_MPOOL_FSTAT *)((tfsp + i) + 1);
    tname = (char *)(tstruct + i);
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    if (mp->mpfq.stqh_first == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
    }
    while (1) {
      if ((unsigned int )mfp != (unsigned int )((void *)0)) {
        tmp___2 = i;
        i --;
        if (! (tmp___2 > 0U)) {
          break;
        }
      } else {
        break;
      }
      name = __memp_fns(dbmp, mfp);
      tmp___1 = strlen((char const   *)name);
      nlen = tmp___1 + 1U;
      (*tfsp) = tstruct;
      (*tstruct) = mfp->stat;
      if (flags & 1U) {
        pagesize = mfp->stat.st_pagesize;
        memset((void *)(& mfp->stat), 0, sizeof(mfp->stat));
        mfp->stat.st_pagesize = pagesize;
      }
      tstruct->file_name = tname;
      memcpy((void * __restrict  )tname, (void const   * __restrict  )name, nlen);
      tfsp ++;
      tstruct ++;
      tname += nlen;
      if (mfp->q.stqe_next == -1) {
        mfp = (MPOOLFILE *)((void *)0);
      } else {
        mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
      }
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    (*tfsp) = (DB_MPOOL_FSTAT *)((void *)0);
  }
  return (0);
}
}
static FN const   fn___0[9]  = 
  {      {1U, "mmapped"}, 
        {2U, "no buffer"}, 
        {4U, "extent"}, 
        {8U, "deadfile"}, 
        {16U, "file written"}, 
        {32U, "no backing file"}, 
        {64U, "unlink on close"}, 
        {256U, "temporary"}, 
        {0U, (char const   *)((void *)0)}};
int __memp_dump_region(DB_ENV *dbenv___0 , char const   *area , FILE *fp ) 
{ DB_MPOOL *dbmp ;
  DB_MPOOLFILE *dbmfp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  size_t fmap[201] ;
  u_int32_t i ;
  u_int32_t flags ;
  u_int32_t mfp_flags ;
  int cnt ;
  u_int8_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->mp_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"memp_dump_region", 32768U);
    return (tmp___0);
  }
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    fp = stderr;
  }
  flags = 0U;
  while ((int const   )(*area) != 0) {
    switch ((int )(*area)) {
    case 65: 
    flags |= 7U;
    break;
    case 104: 
    flags |= 1U;
    break;
    case 109: 
    flags |= 4U;
    break;
    }
    area ++;
  }
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nPool (region addr 0x%lx)\n",
          "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=", (unsigned long )((unsigned int )(dbmp->reginfo +
                                                                                                0)->addr));
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  cnt = 0;
  if (mp->mpfq.stqh_first == -1) {
    mfp = (MPOOLFILE *)((void *)0);
  } else {
    mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
  }
  while ((unsigned int )mfp != (unsigned int )((void *)0)) {
    tmp___1 = __memp_fns(dbmp, mfp);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"File #%d: %s: pagesize %lu\n",
            cnt + 1, tmp___1, (unsigned long )mfp->stat.st_pagesize);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t type %ld; ref %lu; blocks %lu; last %lu;",
            (long )mfp->ftype, (unsigned long )mfp->mpf_cnt, (unsigned long )mfp->block_cnt,
            (unsigned long )mfp->last_pgno);
    mfp_flags = 0U;
    if (mfp->deadfile) {
      mfp_flags |= 8U;
    }
    if (mfp->file_written) {
      mfp_flags |= 16U;
    }
    if (mfp->no_backing_file) {
      mfp_flags |= 32U;
    }
    if (mfp->unlink_on_close) {
      mfp_flags |= 64U;
    }
    __db_prflags(mfp_flags, fn___0, (void *)fp);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n\t UID: ");
    p = (u_int8_t *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + mfp->fileid_off));
    i = 0U;
    while (i < 20U) {
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%x", (unsigned int )(*p));
      if (i < 19U) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" ");
      }
      i ++;
      p ++;
    }
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    if (cnt < 200) {
      fmap[cnt] = (unsigned int )((u_int8_t *)mfp - (u_int8_t *)(dbmp->reginfo)->addr);
    }
    if (mfp->q.stqe_next == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
    }
    cnt ++;
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  dbmfp = dbmp->dbmfq.tqh_first;
  while ((unsigned int )dbmfp != (unsigned int )((void *)0)) {
    if (dbmfp->flags & 8U) {
      tmp___2 = "readonly";
    } else {
      tmp___2 = "read/write";
    }
    tmp___3 = __memp_fn(dbmfp);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"File #%d: %s: per-process, %s\n",
            cnt + 1, tmp___3, tmp___2);
    if (cnt < 200) {
      fmap[cnt] = (unsigned int )((u_int8_t *)mfp - (u_int8_t *)(dbmp->reginfo)->addr);
    }
    dbmfp = dbmfp->q.tqe_next;
    cnt ++;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if (cnt < 200) {
    fmap[cnt] = 0U;
  } else {
    fmap[200] = 0U;
  }
  i = 0U;
  while (i < mp->nreg) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nCache #%d:\n",
            "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=", i + 1U);
    __memp_dumpcache(dbenv___0, dbmp, dbmp->reginfo + i, fmap, fp, flags);
    i ++;
  }
  fflush(fp);
  return (0);
}
}
static void __memp_dumpcache(DB_ENV *dbenv___0 , DB_MPOOL *dbmp , REGINFO *reginfo ,
                             size_t *fmap , FILE *fp , u_int32_t flags ) 
{ BH *bhp ;
  DB_MPOOL_HASH *hp ;
  MPOOL *c_mp ;
  int bucket ;

  {
  c_mp = (MPOOL *)reginfo->primary;
  if (flags & 1U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s\nBH hash table (%lu hash slots)\nbucket (priority):\n",
            "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=", (unsigned long )c_mp->htab_buckets);
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\tpageno, file, ref, address [LSN] priority\n");
    hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)reginfo->addr + c_mp->htab));
    bucket = 0;
    while (bucket < c_mp->htab_buckets) {
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
      }
      if (hp->hash_bucket.stqh_first == -1) {
        bhp = (BH *)((void *)0);
      } else {
        bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      if ((unsigned int )bhp != (unsigned int )((void *)0)) {
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%lu (%u):\n",
                (unsigned long )bucket, hp->hash_priority);
      }
      while ((unsigned int )bhp != (unsigned int )((void *)0)) {
        __memp_pbh(dbmp, bhp, fmap, fp);
        if (bhp->hq.stqe_next == -1) {
          bhp = (BH *)((void *)0);
        } else {
          bhp = (struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next);
        }
      }
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
      }
      hp ++;
      bucket ++;
    }
  }
  if (flags & 4U) {
    __db_shalloc_dump(reginfo->addr, fp);
  }
  return;
}
}
static FN const   fn___1[7]  = {      {1U, "callpgin"}, 
        {2U, "dirty"}, 
        {4U, "created"}, 
        {8U, "discard"}, 
        {16U, "locked"}, 
        {32U, "trash"}, 
        {0U, (char const   *)((void *)0)}};
static void __memp_pbh(DB_MPOOL *dbmp , BH *bhp , size_t *fmap , FILE *fp ) 
{ int i ;

  {
  i = 0;
  while (i < 200) {
    if ((*(fmap + i)) == 0U) {
      break;
    } else {
      if ((*(fmap + i)) == bhp->mf_offset) {
        break;
      }
    }
    i ++;
  }
  if ((*(fmap + i)) == 0U) {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t%5lu, %lu, %2lu, %8lu [%lu,%lu] %lu",
            (unsigned long )bhp->pgno, (unsigned long )bhp->mf_offset, (unsigned long )bhp->ref,
            (unsigned long )((unsigned int )((u_int8_t *)bhp - (u_int8_t *)(dbmp->reginfo)->addr)),
            (unsigned long )((PAGE *)(bhp->buf))->lsn.file, (unsigned long )((PAGE *)(bhp->buf))->lsn.offset,
            (unsigned long )bhp->priority);
  } else {
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t%5lu,   #%d,  %2lu, %8lu [%lu,%lu] %lu",
            (unsigned long )bhp->pgno, i + 1, (unsigned long )bhp->ref, (unsigned long )((unsigned int )((u_int8_t *)bhp -
                                                                                                         (u_int8_t *)(dbmp->reginfo)->addr)),
            (unsigned long )((PAGE *)(bhp->buf))->lsn.file, (unsigned long )((PAGE *)(bhp->buf))->lsn.offset,
            (unsigned long )bhp->priority);
  }
  __db_prflags((unsigned int )bhp->flags, fn___1, (void *)fp);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  return;
}
}
void __memp_stat_hash(REGINFO *reginfo , MPOOL *mp , u_int32_t *dirtyp ) 
{ DB_MPOOL_HASH *hp ;
  u_int32_t dirty ;
  int i ;

  {
  hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)reginfo->addr + mp->htab));
  i = 0;
  dirty = 0U;
  while (i < mp->htab_buckets) {
    dirty += hp->hash_page_dirty;
    i ++;
    hp ++;
  }
  (*dirtyp) = dirty;
  return;
}
}
static void __memp_stat_wait(REGINFO *reginfo , MPOOL *mp , DB_MPOOL_STAT *mstat ,
                             int flags ) 
{ DB_MPOOL_HASH *hp ;
  DB_MUTEX *mutexp ;
  int i ;

  {
  mstat->st_hash_max_wait = 0U;
  hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)reginfo->addr + mp->htab));
  i = 0;
  while (i < mp->htab_buckets) {
    mutexp = & hp->hash_mutex;
    mstat->st_hash_nowait = mstat->st_hash_nowait + mutexp->mutex_set_nowait;
    mstat->st_hash_wait = mstat->st_hash_wait + mutexp->mutex_set_wait;
    if (mutexp->mutex_set_wait > mstat->st_hash_max_wait) {
      mstat->st_hash_max_wait = mutexp->mutex_set_wait;
    }
    if (flags & 1) {
      mutexp->mutex_set_wait = 0U;
      mutexp->mutex_set_nowait = 0U;
    }
    i ++;
    hp ++;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-yoZqL0Wf.i","-O2")
static int __bhcmp(void const   *p1 , void const   *p2 ) ;
static int __memp_close_flush_files(DB_ENV *dbenv___0 , DB_MPOOL *dbmp ) ;
static int __memp_sync_files(DB_ENV *dbenv___0 , DB_MPOOL *dbmp ) ;
int __memp_sync_pp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->mp_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"memp_sync", 32768U);
    return (tmp___0);
  }
  if ((unsigned int )lsnp != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->lg_handle == (unsigned int )((void *)0)) {
      tmp___1 = __db_env_config(dbenv___0, (char *)"memp_sync", 16384U);
      return (tmp___1);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_sync(dbenv___0, lsnp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_sync(DB_ENV *dbenv___0 , DB_LSN *lsnp ) 
{ DB_MPOOL *dbmp ;
  MPOOL *mp ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  if ((unsigned int )lsnp != (unsigned int )((void *)0)) {
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    tmp = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& mp->lsn));
    if (tmp <= 0) {
      (*lsnp) = mp->lsn;
      if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
      }
      return (0);
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  ret = __memp_sync_int(dbenv___0, (DB_MPOOLFILE *)((void *)0), 0, (enum __anonenum_db_sync_op_53 )1,
                        (int *)((void *)0));
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )lsnp != (unsigned int )((void *)0)) {
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
    tmp___0 = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& mp->lsn));
    if (tmp___0 > 0) {
      mp->lsn = (*lsnp);
    }
    if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
    }
  }
  return (0);
}
}
int __memp_fsync_pp(DB_MPOOLFILE *dbmfp ) 
{ DB_ENV *dbenv___0 ;
  int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dbenv___0 = dbmfp->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if (! (dbmfp->flags & 4U)) {
    tmp___0 = __db_mi_open(dbmfp->dbenv, "DB_MPOOLFILE->sync", 0);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      tmp___1 = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
  }
  rep_check = tmp___1;
  if (rep_check != 0) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_fsync(dbmfp);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __memp_fsync(DB_MPOOLFILE *dbmfp ) 
{ int tmp ;

  {
  if (dbmfp->flags & 8U) {
    return (0);
  }
  if ((dbmfp->mfp)->flags & 256U) {
    return (0);
  }
  tmp = __memp_sync_int(dbmfp->dbenv, dbmfp, 0, (enum __anonenum_db_sync_op_53 )2,
                        (int *)((void *)0));
  return (tmp);
}
}
int __mp_xxx_fh(DB_MPOOLFILE *dbmfp , DB_FH **fhp ) 
{ int tmp ;

  {
  (*fhp) = dbmfp->fhp;
  if ((unsigned int )(*fhp) != (unsigned int )((void *)0)) {
    return (0);
  }
  tmp = __memp_sync_int(dbmfp->dbenv, dbmfp, 0, (enum __anonenum_db_sync_op_53 )2,
                        (int *)((void *)0));
  return (tmp);
}
}
int __memp_sync_int(DB_ENV *dbenv___0 , DB_MPOOLFILE *dbmfp , int trickle_max , db_sync_op op ,
                    int *wrotep ) 
{ BH *bhp ;
  BH_TRACK *bharray ;
  DB_MPOOL *dbmp ;
  DB_MPOOL_HASH *hp ;
  DB_MUTEX *mutexp ;
  MPOOL *c_mp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  u_int32_t n_cache ;
  int ar_cnt ;
  int ar_max ;
  int hb_lock ;
  int i ;
  int pass ;
  int remaining ;
  int ret ;
  int t_ret ;
  int wait_cnt ;
  int write_cnt ;
  int wrote ;
  struct __bh *tmp ;
  char *tmp___0 ;

  {
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  wrote = 0;
  pass = wrote;
  ar_max = (int )(mp->nreg * (unsigned int )mp->htab_buckets);
  ret = __os_malloc(dbenv___0, (unsigned int )ar_max * sizeof(BH_TRACK ), (void *)(& bharray));
  if (ret != 0) {
    return (ret);
  }
  ar_cnt = 0;
  n_cache = 0U;
  while (n_cache < mp->nreg) {
    c_mp = (MPOOL *)(dbmp->reginfo + n_cache)->primary;
    hp = (DB_MPOOL_HASH *)((void *)((u_int8_t *)(dbmp->reginfo + n_cache)->addr +
                                    c_mp->htab));
    i = 0;
    while (i < c_mp->htab_buckets) {
      if (hp->hash_bucket.stqh_first == -1) {
        tmp = (struct __bh *)((void *)0);
      } else {
        tmp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      if ((unsigned int )tmp == (unsigned int )((void *)0)) {
        goto __Cont;
      }
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & hp->hash_mutex);
      }
      if (hp->hash_bucket.stqh_first == -1) {
        bhp = (BH *)((void *)0);
      } else {
        bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
      }
      while ((unsigned int )bhp != (unsigned int )((void *)0)) {
        if ((int )bhp->ref == 0) {
          if (! ((int )bhp->flags & 2)) {
            goto __Cont___0;
          }
        }
        if ((int )op == 2) {
          if (! ((int )bhp->flags & 2)) {
            goto __Cont___0;
          }
        }
        mfp = (MPOOLFILE *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + bhp->mf_offset));
        if (mfp->flags & 256U) {
          goto __Cont___0;
        }
        if ((unsigned int )dbmfp != (unsigned int )((void *)0)) {
          if ((unsigned int )mfp != (unsigned int )dbmfp->mfp) {
            goto __Cont___0;
          }
        }
        if ((unsigned int )dbmfp == (unsigned int )((void *)0)) {
          if (mfp->lsn_off == -1) {
            goto __Cont___0;
          }
        }
        (bharray + ar_cnt)->track_hp = hp;
        (bharray + ar_cnt)->track_pgno = bhp->pgno;
        (bharray + ar_cnt)->track_off = bhp->mf_offset;
        ar_cnt ++;
        if (ar_cnt >= ar_max) {
          ret = __os_realloc(dbenv___0, (unsigned int )(ar_max * 2) * sizeof(BH_TRACK ),
                             (void *)(& bharray));
          if (ret != 0) {
            break;
          }
          ar_max *= 2;
        }
        __Cont___0: 
        if (bhp->hq.stqe_next == -1) {
          bhp = (BH *)((void *)0);
        } else {
          bhp = (struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next);
        }
      }
      if (! (hp->hash_mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & hp->hash_mutex);
      }
      if (ret != 0) {
        goto err;
      }
      __Cont: 
      i ++;
      hp ++;
    }
    n_cache ++;
  }
  if (ar_cnt == 0) {
    goto done;
  }
  if (ar_cnt > 1) {
    qsort((void *)bharray, (unsigned int )ar_cnt, sizeof(BH_TRACK ), & __bhcmp);
  }
  if ((int )op == 3) {
    if (ar_cnt > trickle_max) {
      ar_cnt = trickle_max;
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    ret = __log_flush(dbenv___0, (DB_LSN const   *)((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  write_cnt = 0;
  pass = write_cnt;
  i = pass;
  remaining = ar_cnt;
  while (remaining > 0) {
    if (i >= ar_cnt) {
      i = 0;
      pass ++;
      __os_sleep(dbenv___0, 1UL, 0UL);
    }
    hp = (bharray + i)->track_hp;
    if ((unsigned int )hp == (unsigned int )((void *)0)) {
      goto __Cont___1;
    }
    mutexp = & hp->hash_mutex;
    if (! (mutexp->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, mutexp);
    }
    if (hp->hash_bucket.stqh_first == -1) {
      bhp = (BH *)((void *)0);
    } else {
      bhp = (struct __bh *)((u_int8_t *)(& hp->hash_bucket) + hp->hash_bucket.stqh_first);
    }
    while ((unsigned int )bhp != (unsigned int )((void *)0)) {
      if (bhp->pgno == (bharray + i)->track_pgno) {
        if (bhp->mf_offset == (bharray + i)->track_off) {
          break;
        }
      }
      if (bhp->hq.stqe_next == -1) {
        bhp = (BH *)((void *)0);
      } else {
        bhp = (struct __bh *)((u_int8_t *)bhp + bhp->hq.stqe_next);
      }
    }
    if ((unsigned int )bhp == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((int )bhp->ref == 0) {
        if (! ((int )bhp->flags & 2)) {
          _L: 
          if (! (mutexp->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, mutexp);
          }
          remaining --;
          (bharray + i)->track_hp = (DB_MPOOL_HASH *)((void *)0);
          goto __Cont___1;
        }
      }
    }
    if ((int )bhp->flags & 16) {
      goto _L___0;
    } else {
      if ((int )bhp->ref != 0) {
        if (pass < 2) {
          _L___0: 
          if (! (mutexp->flags & 2U)) {
            __db_pthread_mutex_unlock(dbenv___0, mutexp);
          }
          if ((int )op != 1) {
            if ((int )op != 2) {
              remaining --;
              (bharray + i)->track_hp = (DB_MPOOL_HASH *)((void *)0);
            }
          }
          goto __Cont___1;
        }
      }
    }
    bhp->ref_sync = bhp->ref;
    bhp->ref = (unsigned short )((int )bhp->ref + 1);
    bhp->flags = (unsigned short )((int )bhp->flags | 16);
    if (! (bhp->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & bhp->mutex);
    }
    if (! (mutexp->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, mutexp);
    }
    wait_cnt = 1;
    while (1) {
      if ((int )bhp->ref_sync != 0) {
        if (! (wait_cnt < 4)) {
          break;
        }
      } else {
        break;
      }
      __os_sleep(dbenv___0, 1UL, 0UL);
      wait_cnt ++;
    }
    if (! (mutexp->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, mutexp);
    }
    hb_lock = 1;
    if ((int )bhp->ref_sync == 0) {
      remaining --;
      (bharray + i)->track_hp = (DB_MPOOL_HASH *)((void *)0);
    }
    if ((int )bhp->ref_sync == 0) {
      if ((int )bhp->flags & 2) {
        hb_lock = 0;
        if (! (mutexp->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, mutexp);
        }
        mfp = (MPOOLFILE *)((void *)((u_int8_t *)(dbmp->reginfo)->addr + bhp->mf_offset));
        ret = __memp_bhwrite(dbmp, hp, mfp, bhp, 1);
        if (ret == 0) {
          wrote ++;
        } else {
          if ((int )op == 1) {
            tmp___0 = __memp_fns(dbmp, mfp);
            __db_err((DB_ENV const   *)dbenv___0, "%s: unable to flush page: %lu",
                     tmp___0, (unsigned long )bhp->pgno);
          } else {
            if ((int )op == 3) {
              tmp___0 = __memp_fns(dbmp, mfp);
              __db_err((DB_ENV const   *)dbenv___0, "%s: unable to flush page: %lu",
                       tmp___0, (unsigned long )bhp->pgno);
            } else {
              ret = 0;
            }
          }
        }
        if (dbenv___0->mp_maxwrite != 0) {
          write_cnt ++;
          if (write_cnt >= dbenv___0->mp_maxwrite) {
            write_cnt = 0;
            __os_sleep(dbenv___0, 0UL, (unsigned long )dbenv___0->mp_maxwrite_sleep);
          }
        }
      }
    }
    if ((int )bhp->flags & 16) {
      bhp->flags = (unsigned short )((int )bhp->flags & -17);
      if (! (bhp->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & bhp->mutex);
      }
      if (! hb_lock) {
        if (! (mutexp->flags & 2U)) {
          __db_pthread_mutex_lock(dbenv___0, mutexp);
        }
      }
    }
    bhp->ref_sync = (unsigned short)0;
    bhp->ref = (unsigned short )((int )bhp->ref - 1);
    if (! (mutexp->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, mutexp);
    }
    if (ret != 0) {
      break;
    }
    __Cont___1: 
    i ++;
  }
  done: 
  if (ret == 0) {
    if ((int )op == 1) {
      goto _L___1;
    } else {
      if ((int )op == 2) {
        _L___1: 
        if ((unsigned int )dbmfp == (unsigned int )((void *)0)) {
          ret = __memp_sync_files(dbenv___0, dbmp);
        } else {
          ret = __os_fsync(dbenv___0, dbmfp->fhp);
        }
      }
    }
  }
  t_ret = __memp_close_flush_files(dbenv___0, dbmp);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  err: 
  __os_free(dbenv___0, (void *)bharray);
  if ((unsigned int )wrotep != (unsigned int )((void *)0)) {
    (*wrotep) = wrote;
  }
  return (ret);
}
}
static int __memp_sync_files(DB_ENV *dbenv___0 , DB_MPOOL *dbmp ) 
{ DB_MPOOLFILE *dbmfp ;
  MPOOL *mp ;
  MPOOLFILE *mfp ;
  int final_ret ;
  int ret ;
  char *tmp ;

  {
  final_ret = 0;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  if (mp->mpfq.stqh_first == -1) {
    mfp = (MPOOLFILE *)((void *)0);
  } else {
    mfp = (struct __mpoolfile *)((u_int8_t *)(& mp->mpfq) + mp->mpfq.stqh_first);
  }
  while ((unsigned int )mfp != (unsigned int )((void *)0)) {
    if (! mfp->file_written) {
      goto __Cont;
    } else {
      if (mfp->deadfile) {
        goto __Cont;
      } else {
        if (mfp->flags & 256U) {
          goto __Cont;
        }
      }
    }
    ret = 0;
    if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbmp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
      }
    }
    dbmfp = dbmp->dbmfq.tqh_first;
    while ((unsigned int )dbmfp != (unsigned int )((void *)0)) {
      if ((unsigned int )dbmfp->mfp != (unsigned int )mfp) {
        goto __Cont___0;
      } else {
        if (dbmfp->flags & 8U) {
          goto __Cont___0;
        }
      }
      ret = __os_fsync(dbenv___0, dbmfp->fhp);
      break;
      __Cont___0: 
      dbmfp = dbmfp->q.tqe_next;
    }
    if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
      if (! ((dbmp->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
      }
    }
    if ((unsigned int )dbmfp == (unsigned int )((void *)0)) {
      ret = __memp_mf_sync(dbmp, mfp);
    }
    if (ret != 0) {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "%s: unable to flush: %s", (char *)((void *)((u_int8_t *)(dbmp->reginfo)->addr +
                                                                                         mfp->path_off)),
               tmp);
      if (final_ret == 0) {
        final_ret = ret;
      }
    }
    __Cont: 
    if (mfp->q.stqe_next == -1) {
      mfp = (MPOOLFILE *)((void *)0);
    } else {
      mfp = (struct __mpoolfile *)((u_int8_t *)mfp + mfp->q.stqe_next);
    }
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  return (final_ret);
}
}
static int __memp_close_flush_files(DB_ENV *dbenv___0 , DB_MPOOL *dbmp ) 
{ DB_MPOOLFILE *dbmfp ;
  int ret ;

  {
  retry: 
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  dbmfp = dbmp->dbmfq.tqh_first;
  while ((unsigned int )dbmfp != (unsigned int )((void *)0)) {
    if (dbmfp->flags & 2U) {
      dbmfp->flags = dbmfp->flags & 4294967293U;
      if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
        if (! ((dbmp->mutexp)->flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
        }
      }
      ret = __memp_fclose(dbmfp, 0U);
      if (ret != 0) {
        return (ret);
      }
      goto retry;
    }
    dbmfp = dbmfp->q.tqe_next;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  return (0);
}
}
static int __bhcmp(void const   *p1 , void const   *p2 ) 
{ BH_TRACK *bhp1 ;
  BH_TRACK *bhp2 ;

  {
  bhp1 = (BH_TRACK *)p1;
  bhp2 = (BH_TRACK *)p2;
  if (bhp1->track_off < bhp2->track_off) {
    return (-1);
  }
  if (bhp1->track_off > bhp2->track_off) {
    return (1);
  }
  if (bhp1->track_pgno < bhp2->track_pgno) {
    return (-1);
  }
  if (bhp1->track_pgno > bhp2->track_pgno) {
    return (1);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-fejadcp5.i","-O2")
static int __memp_trickle(DB_ENV *dbenv___0 , int pct , int *nwrotep ) ;
int __memp_trickle_pp(DB_ENV *dbenv___0 , int pct , int *nwrotep ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->mp_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"memp_trickle", 32768U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __memp_trickle(dbenv___0, pct, nwrotep);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __memp_trickle(DB_ENV *dbenv___0 , int pct , int *nwrotep ) 
{ DB_MPOOL *dbmp ;
  MPOOL *c_mp ;
  MPOOL *mp ;
  u_int32_t dirty ;
  u_int32_t i ;
  u_int32_t total ;
  u_int32_t dtmp ;
  int n ;
  int ret ;
  int wrote ;

  {
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  if ((unsigned int )nwrotep != (unsigned int )((void *)0)) {
    (*nwrotep) = 0;
  }
  if (pct < 1) {
    return (22);
  } else {
    if (pct > 100) {
      return (22);
    }
  }
  ret = 0;
  total = 0U;
  dirty = total;
  i = dirty;
  while (i < mp->nreg) {
    c_mp = (MPOOL *)(dbmp->reginfo + i)->primary;
    total += c_mp->stat.st_pages;
    __memp_stat_hash(dbmp->reginfo + i, c_mp, & dtmp);
    dirty += dtmp;
    i ++;
  }
  n = (int )((total * (unsigned int )pct) / 100U - (total - dirty));
  if (dirty == 0U) {
    return (0);
  } else {
    if (n <= 0) {
      return (0);
    }
  }
  if ((unsigned int )nwrotep == (unsigned int )((void *)0)) {
    nwrotep = & wrote;
  }
  ret = __memp_sync_int(dbenv___0, (DB_MPOOLFILE *)((void *)0), n, (enum __anonenum_db_sync_op_53 )3,
                        nwrotep);
  mp->stat.st_page_trickle = mp->stat.st_page_trickle + (unsigned int )(*nwrotep);
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-Uezg5ong.i","-O2")
static int __db_mutex_alloc_int(DB_ENV *dbenv___0 , REGINFO *infop , DB_MUTEX **storep ) ;
int __db_mutex_setup(DB_ENV *dbenv___0 , REGINFO *infop , void *ptr , u_int32_t flags ) 
{ DB_MUTEX *mutex ;
  REGMAINT *maint ;
  u_int32_t iflags ;
  u_int32_t offset ;
  int ret ;

  {
  ret = 0;
  mutex = (DB_MUTEX *)((void *)0);
  if (flags & 1U) {
    ret = __db_mutex_alloc_int(dbenv___0, infop, (DB_MUTEX **)ptr);
    if (ret != 0) {
      goto err;
    }
    mutex = (*((DB_MUTEX **)ptr));
  } else {
    mutex = (DB_MUTEX *)ptr;
  }
  iflags = flags & 392U;
  switch ((int )infop->type) {
  case 2: 
  offset = (unsigned int )mutex + 1U;
  break;
  case 4: 
  offset = (unsigned int )mutex + 2U;
  break;
  default: 
  offset = (unsigned int )mutex;
  break;
  }
  maint = (REGMAINT *)((void *)0);
  ret = __db_pthread_mutex_init(dbenv___0, mutex, iflags);
  err: 
  if (ret != 0) {
    if (flags & 1U) {
      if ((unsigned int )mutex != (unsigned int )((void *)0)) {
        __db_mutex_free(dbenv___0, infop, mutex);
        (*((DB_MUTEX **)ptr)) = (DB_MUTEX *)((void *)0);
      }
    }
  }
  return (ret);
}
}
static int __db_mutex_alloc_int(DB_ENV *dbenv___0 , REGINFO *infop , DB_MUTEX **storep ) 
{ int ret ;

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_MUTEX ), (void *)storep);
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Unable to allocate memory for mutex");
  }
  return (ret);
}
}
void __db_mutex_free(DB_ENV *dbenv___0 , REGINFO *infop , DB_MUTEX *mutexp ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  __os_free(dbenv___0, (void *)mutexp);
  return;
}
}
#pragma merger(0,"/tmp/cil-x3TrmOPW.i","-O2")
int __os_abspath(char const   *path ) 
{ 

  {
  return ((int const   )(*(path + 0)) == 47);
}
}
#pragma merger(0,"/tmp/cil-dNkffxtW.i","-O2")
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
int __os_umalloc(DB_ENV *dbenv___0 , size_t size , void *storep ) 
{ int ret ;
  char *tmp ;

  {
  if (size == 0U) {
    size ++;
  }
  if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((unsigned int )dbenv___0->db_malloc == (unsigned int )((void *)0)) {
      _L: 
      if ((unsigned int )__db_global_values.j_malloc != (unsigned int )((void *)0)) {
        (*((void **)storep)) = ((*(__db_global_values.j_malloc)))(size);
      } else {
        (*((void **)storep)) = malloc(size);
      }
      if ((unsigned int )(*((void **)storep)) == (unsigned int )((void *)0)) {
        ret = __os_get_errno();
        if (ret == 0) {
          ret = 12;
          __os_set_errno(12);
        }
        tmp = strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "malloc: %s: %lu", tmp, (unsigned long )size);
        return (ret);
      }
      return (0);
    }
  }
  (*((void **)storep)) = ((*(dbenv___0->db_malloc)))(size);
  if ((unsigned int )(*((void **)storep)) == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "User-specified malloc function returned NULL");
    return (12);
  }
  return (0);
}
}
int __os_urealloc(DB_ENV *dbenv___0 , size_t size , void *storep ) 
{ int ret ;
  void *ptr ;
  int tmp ;
  char *tmp___0 ;

  {
  ptr = (*((void **)storep));
  if (size == 0U) {
    size ++;
  }
  if ((unsigned int )dbenv___0 == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((unsigned int )dbenv___0->db_realloc == (unsigned int )((void *)0)) {
      _L: 
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
        tmp = __os_umalloc(dbenv___0, size, storep);
        return (tmp);
      }
      if ((unsigned int )__db_global_values.j_realloc != (unsigned int )((void *)0)) {
        (*((void **)storep)) = ((*(__db_global_values.j_realloc)))(ptr, size);
      } else {
        (*((void **)storep)) = realloc(ptr, size);
      }
      if ((unsigned int )(*((void **)storep)) == (unsigned int )((void *)0)) {
        ret = __os_get_errno();
        if (ret == 0) {
          ret = 12;
          __os_set_errno(12);
        }
        tmp___0 = strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "realloc: %s: %lu", tmp___0, (unsigned long )size);
        return (ret);
      }
      return (0);
    }
  }
  (*((void **)storep)) = ((*(dbenv___0->db_realloc)))(ptr, size);
  if ((unsigned int )(*((void **)storep)) == (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "User-specified realloc function returned NULL");
    return (12);
  }
  return (0);
}
}
void __os_ufree(DB_ENV *dbenv___0 , void *ptr ) 
{ 

  {
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_free != (unsigned int )((void *)0)) {
      ((*(dbenv___0->db_free)))(ptr);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )__db_global_values.j_free != (unsigned int )((void *)0)) {
      ((*(__db_global_values.j_free)))(ptr);
    } else {
      free(ptr);
    }
  }
  return;
}
}
int __os_strdup(DB_ENV *dbenv___0 , char const   *str , void *storep ) 
{ size_t size ;
  int ret ;
  void *p ;
  size_t tmp ;

  {
  (*((void **)storep)) = (void *)0;
  tmp = strlen(str);
  size = tmp + 1U;
  ret = __os_malloc(dbenv___0, size, (void *)(& p));
  if (ret != 0) {
    return (ret);
  }
  memcpy((void * __restrict  )p, (void const   * __restrict  )str, size);
  (*((void **)storep)) = p;
  return (0);
}
}
int __os_calloc(DB_ENV *dbenv___0 , size_t num , size_t size , void *storep ) 
{ void *p ;
  int ret ;

  {
  size *= num;
  ret = __os_malloc(dbenv___0, size, (void *)(& p));
  if (ret != 0) {
    return (ret);
  }
  memset(p, 0, size);
  (*((void **)storep)) = p;
  return (0);
}
}
int __os_malloc(DB_ENV *dbenv___0 , size_t size , void *storep ) 
{ int ret ;
  void *p ;
  char *tmp ;

  {
  (*((void **)storep)) = (void *)0;
  if (size == 0U) {
    size ++;
  }
  if ((unsigned int )__db_global_values.j_malloc != (unsigned int )((void *)0)) {
    p = ((*(__db_global_values.j_malloc)))(size);
  } else {
    p = malloc(size);
  }
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    ret = __os_get_errno();
    if (ret == 0) {
      ret = 12;
      __os_set_errno(12);
    }
    tmp = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "malloc: %s: %lu", tmp, (unsigned long )size);
    return (ret);
  }
  (*((void **)storep)) = p;
  return (0);
}
}
int __os_realloc(DB_ENV *dbenv___0 , size_t size , void *storep ) 
{ int ret ;
  void *p ;
  void *ptr ;
  int tmp ;
  char *tmp___0 ;

  {
  ptr = (*((void **)storep));
  if (size == 0U) {
    size ++;
  }
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
    tmp = __os_malloc(dbenv___0, size, storep);
    return (tmp);
  }
  if ((unsigned int )__db_global_values.j_realloc != (unsigned int )((void *)0)) {
    p = ((*(__db_global_values.j_realloc)))(ptr, size);
  } else {
    p = realloc(ptr, size);
  }
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    ret = __os_get_errno();
    if (ret == 0) {
      ret = 12;
      __os_set_errno(12);
    }
    tmp___0 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "realloc: %s: %lu", tmp___0, (unsigned long )size);
    return (ret);
  }
  (*((void **)storep)) = p;
  return (0);
}
}
void __os_free(DB_ENV *dbenv___0 , void *ptr ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  if ((unsigned int )__db_global_values.j_free != (unsigned int )((void *)0)) {
    ((*(__db_global_values.j_free)))(ptr);
  } else {
    free(ptr);
  }
  return;
}
}
void *__ua_memcpy(void *dst , void const   *src , size_t len ) 
{ void *tmp ;

  {
  tmp = memcpy((void * __restrict  )dst, (void const   * __restrict  )src, len);
  return (tmp);
}
}
#pragma merger(0,"/tmp/cil-Fx5OtBJL.i","-O2")
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz ) ;
int __os_clock(DB_ENV *dbenv___0 , u_int32_t *secsp , u_int32_t *usecsp ) 
{ struct timeval tp ;
  int ret ;
  char *tmp ;
  int tmp___0 ;

  {
  retry: 
  tmp___0 = gettimeofday((struct timeval * __restrict  )(& tp), (struct timezone * __restrict  )((void *)0));
  if (tmp___0 != 0) {
    ret = __os_get_errno();
    if (ret == 4) {
      goto retry;
    }
    tmp = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "gettimeofday: %s", tmp);
    return (ret);
  }
  if ((unsigned int )secsp != (unsigned int )((void *)0)) {
    (*secsp) = (unsigned int )tp.tv_sec;
  }
  if ((unsigned int )usecsp != (unsigned int )((void *)0)) {
    (*usecsp) = (unsigned int )tp.tv_usec;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-mvstUsPM.i","-O2")
int __os_fs_notzero(void) ;
int __os_fs_notzero(void) 
{ 

  {
  return (0);
}
}
#pragma merger(0,"/tmp/cil-hYtmzHIA.i","-O2")
extern DIR *opendir(char const   *__name ) ;
extern int closedir(DIR *__dirp ) ;
extern struct dirent *readdir(DIR *__dirp ) ;
int __os_dirlist(DB_ENV *dbenv___0 , char const   *dir , char ***namesp , int *cntp ) 
{ struct dirent *dp ;
  DIR *dirp ;
  int arraysz ;
  int cnt ;
  int ret ;
  char **names ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )__db_global_values.j_dirlist != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_dirlist)))(dir, namesp, cntp);
    return (tmp);
  }
  dirp = opendir(dir);
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
    tmp___0 = __os_get_errno();
    return (tmp___0);
  }
  names = (char **)((void *)0);
  cnt = 0;
  arraysz = cnt;
  while (1) {
    dp = readdir(dirp);
    if (! ((unsigned int )dp != (unsigned int )((void *)0))) {
      break;
    }
    if (cnt >= arraysz) {
      arraysz += 100;
      ret = __os_realloc(dbenv___0, (unsigned int )arraysz * sizeof((*(names + 0))),
                         (void *)(& names));
      if (ret != 0) {
        goto nomem;
      }
    }
    ret = __os_strdup(dbenv___0, (char const   *)(dp->d_name), (void *)(names + cnt));
    if (ret != 0) {
      goto nomem;
    }
    cnt ++;
  }
  closedir(dirp);
  (*namesp) = names;
  (*cntp) = cnt;
  return (0);
  nomem: 
  if ((unsigned int )names != (unsigned int )((void *)0)) {
    __os_dirfree(dbenv___0, names, cnt);
  }
  if ((unsigned int )dirp != (unsigned int )((void *)0)) {
    closedir(dirp);
  }
  return (ret);
}
}
void __os_dirfree(DB_ENV *dbenv___0 , char **names , int cnt ) 
{ 

  {
  if ((unsigned int )__db_global_values.j_dirfree != (unsigned int )((void *)0)) {
    ((*(__db_global_values.j_dirfree)))(names, cnt);
  } else {
    while (cnt > 0) {
      cnt --;
      __os_free(dbenv___0, (void *)(*(names + cnt)));
    }
    __os_free(dbenv___0, (void *)names);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-UTtnT2ab.i","-O2")
int __os_get_errno_ret_zero(void) ;
int __os_get_errno_ret_zero(void) 
{ int *tmp ;

  {
  tmp = __errno_location();
  return ((*tmp));
}
}
int __os_get_errno(void) 
{ int *tmp ;
  int *tmp___0 ;

  {
  tmp = __errno_location();
  if ((*tmp) == 0) {
    __os_set_errno(11);
  }
  tmp___0 = __errno_location();
  return ((*tmp___0));
}
}
void __os_set_errno(int evalue ) 
{ int *tmp ;

  {
  tmp = __errno_location();
  if (evalue >= 0) {
    (*tmp) = evalue;
  } else {
    if (evalue == -30978) {
      (*tmp) = 14;
    } else {
      (*tmp) = 22;
    }
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-dnD9nstx.i","-O2")
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
__inline static  __attribute__((__nothrow__)) int stat__extinline(char const   *__path ,
                                                                  struct stat *__statbuf ) ;
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, __path, __statbuf);
  return (tmp);
}
}
static unsigned int fid_serial  =    0U;
int __os_fileid(DB_ENV *dbenv___0 , char const   *fname , int unique_okay , u_int8_t *fidp ) 
{ struct stat sb ;
  size_t i ;
  int ret ;
  int retries ;
  u_int32_t tmp ;
  u_int8_t *p ;
  char *tmp___0 ;
  int tmp___1 ;
  u_int8_t *tmp___2 ;
  u_int8_t *tmp___3 ;
  u_int8_t *tmp___4 ;
  u_int8_t *tmp___5 ;
  u_int8_t *tmp___7 ;
  u_int8_t *tmp___8 ;
  u_int8_t *tmp___9 ;
  u_int8_t *tmp___10 ;

  {
  retries = 0;
  memset((void *)fidp, 0, 20U);
  retry: 
  tmp___1 = stat__extinline(fname, & sb);
  if (tmp___1 != 0) {
    ret = __os_get_errno();
    if (ret == 4) {
      goto _L;
    } else {
      if (ret == 16) {
        _L: 
        retries ++;
        if (retries < 100) {
          goto retry;
        }
      }
    }
    tmp___0 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", fname, tmp___0);
    return (ret);
  }
  if (fid_serial == 0U) {
    __os_id(& fid_serial);
  } else {
    fid_serial += 100000U;
  }
  tmp = (unsigned int )sb.st_ino;
  p = (u_int8_t *)(& tmp);
  i = sizeof(u_int32_t );
  while (i > 0U) {
    tmp___2 = fidp;
    fidp ++;
    tmp___3 = p;
    p ++;
    (*tmp___2) = (*tmp___3);
    i --;
  }
  tmp = (unsigned int )sb.st_dev;
  p = (u_int8_t *)(& tmp);
  i = sizeof(u_int32_t );
  while (i > 0U) {
    tmp___4 = fidp;
    fidp ++;
    tmp___5 = p;
    p ++;
    (*tmp___4) = (*tmp___5);
    i --;
  }
  if (unique_okay) {
    tmp = (u_int32_t )time((time_t *)((void *)0));
    p = (u_int8_t *)(& tmp);
    i = sizeof(u_int32_t );
    while (i > 0U) {
      tmp___7 = fidp;
      fidp ++;
      tmp___8 = p;
      p ++;
      (*tmp___7) = (*tmp___8);
      i --;
    }
    p = (u_int8_t *)(& fid_serial);
    i = sizeof(u_int32_t );
    while (i > 0U) {
      tmp___9 = fidp;
      fidp ++;
      tmp___10 = p;
      p ++;
      (*tmp___9) = (*tmp___10);
      i --;
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-8TB59eGV.i","-O2")
extern int fsync(int __fd ) ;
int __os_fsync(DB_ENV *dbenv___0 , DB_FH *fhp ) 
{ int ret ;
  int retries ;
  char *tmp___1 ;

  {
  if ((int )fhp->flags & 1) {
    return (0);
  }
  retries = 0;
  while (1) {
    if ((unsigned int )__db_global_values.j_fsync != (unsigned int )((void *)0)) {
      ret = ((*(__db_global_values.j_fsync)))(fhp->fd);
    } else {
      ret = fsync(fhp->fd);
    }
    if (ret != 0) {
      ret = __os_get_errno();
      if (ret == 4) {
        goto _L;
      } else {
        if (ret == 16) {
          _L: 
          retries ++;
          if (! (retries < 100)) {
            break;
          }
        } else {
          break;
        }
      }
    } else {
      break;
    }
  }
  if (ret != 0) {
    tmp___1 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "fsync %s", tmp___1);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-UTAhHlyU.i","-O2")
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
extern int close(int __fd ) ;
int __os_openhandle(DB_ENV *dbenv___0 , char const   *name , int flags , int mode ,
                    DB_FH **fhpp ) ;
int __os_openhandle(DB_ENV *dbenv___0 , char const   *name , int flags , int mode ,
                    DB_FH **fhpp ) 
{ DB_FH *fhp ;
  int ret ;
  int nrepeat ;
  int retries ;
  char *tmp ;
  int tmp___0 ;

  {
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_FH ), (void *)fhpp);
  if (ret != 0) {
    return (ret);
  }
  fhp = (*fhpp);
  if ((unsigned int )__db_global_values.j_open != (unsigned int )((void *)0)) {
    fhp->fd = ((*(__db_global_values.j_open)))(name, flags, mode);
    if (fhp->fd == -1) {
      ret = __os_get_errno();
      goto err;
    }
    fhp->flags = (unsigned char )((int )fhp->flags | 2);
    return (0);
  }
  retries = 0;
  nrepeat = 1;
  while (nrepeat < 4) {
    ret = 0;
    fhp->fd = open(name, flags, mode);
    if (fhp->fd != -1) {
      fhp->flags = (unsigned char )((int )fhp->flags | 2);
      tmp___0 = fcntl(fhp->fd, 2, 1);
      if (tmp___0 == -1) {
        ret = __os_get_errno();
        tmp = strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "fcntl(F_SETFD): %s", tmp);
        goto err;
      }
      break;
    }
    ret = __os_get_errno();
    switch (ret) {
    case 24: ;
    case 23: ;
    case 28: 
    __os_sleep(dbenv___0, (unsigned long )(nrepeat * 2), 0UL);
    break;
    case 16: ;
    case 4: 
    retries ++;
    if (retries < 100) {
      nrepeat --;
    }
    break;
    }
    nrepeat ++;
  }
  err: 
  if (ret != 0) {
    __os_closehandle(dbenv___0, fhp);
    (*fhpp) = (DB_FH *)((void *)0);
  }
  return (ret);
}
}
int __os_closehandle(DB_ENV *dbenv___0 , DB_FH *fhp ) 
{ int ret ;
  int retries ;
  char *tmp___1 ;

  {
  ret = 0;
  if ((int )fhp->flags & 2) {
    retries = 0;
    while (1) {
      if ((unsigned int )__db_global_values.j_close != (unsigned int )((void *)0)) {
        ret = ((*(__db_global_values.j_close)))(fhp->fd);
      } else {
        ret = close(fhp->fd);
      }
      if (ret != 0) {
        ret = __os_get_errno();
        if (ret == 4) {
          goto _L;
        } else {
          if (ret == 16) {
            _L: 
            retries ++;
            if (! (retries < 100)) {
              break;
            }
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    if (ret != 0) {
      tmp___1 = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "close: %s", tmp___1);
    }
    if ((int )fhp->flags & 4) {
      __os_unlink(dbenv___0, (char const   *)fhp->name);
      __os_free(dbenv___0, (void *)fhp->name);
    }
  }
  __os_free(dbenv___0, (void *)fhp);
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-Zsge3xA4.i","-O2")
void __os_id(u_int32_t *idp ) 
{ 

  {
  (*idp) = (u_int32_t )getpid();
  return;
}
}
#pragma merger(0,"/tmp/cil-gzICU6VP.i","-O2")
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int mlock(void const   *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int munlock(void const   *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int shmctl(int __shmid , int __cmd , struct shmid_ds *__buf ) ;
extern  __attribute__((__nothrow__)) int shmget(key_t __key , size_t __size , int __shmflg ) ;
extern  __attribute__((__nothrow__)) void *shmat(int __shmid , void const   *__shmaddr ,
                                                 int __shmflg ) ;
extern  __attribute__((__nothrow__)) int shmdt(void const   *__shmaddr ) ;
int __os_r_sysattach(DB_ENV *dbenv___0 , REGINFO *infop , REGION *rp ) ;
int __os_r_sysdetach(DB_ENV *dbenv___0 , REGINFO *infop , int destroy ) ;
int __os_region_unlink(DB_ENV *dbenv___0 , char const   *path ) ;
static int __os_map(DB_ENV *dbenv___0 , char *path , DB_FH *fhp , size_t len , int is_region ,
                    int is_rdonly , void **addrp ) ;
int __os_r_sysattach(DB_ENV *dbenv___0 , REGINFO *infop , REGION *rp ) 
{ key_t segid ;
  int id ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  DB_FH *fhp ;
  int ret___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (dbenv___0->flags & 524288U) {
    if (infop->flags & 1U) {
      if (dbenv___0->shm_key == -1L) {
        __db_err((DB_ENV const   *)dbenv___0, "no base system shared memory ID specified");
        return (22);
      }
      segid = (int )((unsigned long )dbenv___0->shm_key + (unsigned long )(infop->id -
                                                                           1U));
      id = shmget(segid, 0U, 0);
      if (id != -1) {
        shmctl(id, 0, (struct shmid_ds *)((void *)0));
        id = shmget(segid, 0U, 0);
        if (id != -1) {
          __db_err((DB_ENV const   *)dbenv___0, "shmget: key: %ld: shared system memory region already exists",
                   (long )segid);
          return (11);
        }
      }
      id = shmget(segid, rp->size, 896);
      if (id == -1) {
        ret = __os_get_errno();
        tmp = strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "shmget: key: %ld: unable to create shared system memory region: %s",
                 (long )segid, tmp);
        return (ret);
      }
      rp->segid = (long )id;
    } else {
      id = (int )rp->segid;
    }
    infop->addr = shmat(id, (void const   *)((void *)0), 0);
    if ((unsigned int )infop->addr == (unsigned int )((void *)-1)) {
      infop->addr = (void *)0;
      ret = __os_get_errno();
      tmp___0 = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "shmat: id %d: unable to attach to shared system memory region: %s",
               id, tmp___0);
      return (ret);
    }
    return (0);
  }
  fhp = (DB_FH *)((void *)0);
  if (infop->flags & 2U) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  ret___0 = __os_open(dbenv___0, (char const   *)infop->name, (unsigned int )(34 |
                                                                              tmp___2),
                      infop->mode, & fhp);
  if (ret___0 != 0) {
    tmp___1 = db_strerror(ret___0);
    __db_err((DB_ENV const   *)dbenv___0, "%s: %s", infop->name, tmp___1);
  }
  if (ret___0 == 0) {
    if (infop->flags & 1U) {
      if (dbenv___0->flags & 65536U) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
      ret___0 = __db_fileinit(dbenv___0, fhp, rp->size, tmp___3);
    }
  }
  if (ret___0 == 0) {
    ret___0 = __os_map(dbenv___0, infop->name, fhp, rp->size, 1, 0, & infop->addr);
  }
  if ((unsigned int )fhp != (unsigned int )((void *)0)) {
    __os_closehandle(dbenv___0, fhp);
  }
  return (ret___0);
}
}
int __os_r_sysdetach(DB_ENV *dbenv___0 , REGINFO *infop , int destroy ) 
{ REGION *rp ;
  int ret ;
  int segid ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int ret___0 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  rp = infop->rp;
  if (dbenv___0->flags & 524288U) {
    segid = (int )rp->segid;
    if (destroy) {
      rp->segid = -1L;
    }
    tmp___0 = shmdt((void const   *)infop->addr);
    if (tmp___0 != 0) {
      ret = __os_get_errno();
      tmp = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "shmdt: %s", tmp);
      return (ret);
    }
    if (destroy) {
      tmp___2 = shmctl(segid, 0, (struct shmid_ds *)((void *)0));
      if (tmp___2 != 0) {
        ret = __os_get_errno();
        if (ret != 22) {
          tmp___1 = strerror(ret);
          __db_err((DB_ENV const   *)dbenv___0, "shmctl: id %d: unable to delete system shared memory region: %s",
                   segid, tmp___1);
          return (ret);
        }
      }
    }
    return (0);
  }
  if (dbenv___0->flags & 256U) {
    munlock((void const   *)infop->addr, rp->size);
  }
  tmp___4 = munmap(infop->addr, rp->size);
  if (tmp___4 != 0) {
    ret___0 = __os_get_errno();
    tmp___3 = strerror(ret___0);
    __db_err((DB_ENV const   *)dbenv___0, "munmap: %s", tmp___3);
    return (ret___0);
  }
  if (destroy) {
    tmp___6 = __os_region_unlink(dbenv___0, (char const   *)infop->name);
    if (tmp___6 != 0) {
      tmp___5 = __os_get_errno();
      return (tmp___5);
    }
  }
  return (0);
}
}
int __os_mapfile(DB_ENV *dbenv___0 , char *path , DB_FH *fhp , size_t len , int is_rdonly ,
                 void **addrp ) 
{ int tmp ;

  {
  tmp = __os_map(dbenv___0, path, fhp, len, 0, is_rdonly, addrp);
  return (tmp);
}
}
int __os_unmapfile(DB_ENV *dbenv___0 , void *addr , size_t len ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int err ;
  int ret ;
  int retries ;
  int tmp___2 ;

  {
  if ((unsigned int )__db_global_values.j_unmap != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_unmap)))(addr, len);
    return (tmp);
  }
  if (dbenv___0->flags & 256U) {
    while (1) {
      tmp___0 = munlock((void const   *)addr, len);
      if (tmp___0 != 0) {
        tmp___1 = __os_get_errno();
        if (! (tmp___1 == 4)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  retries = 0;
  err = retries;
  while (1) {
    ret = munmap(addr, len);
    if (ret != 0) {
      err = __os_get_errno();
      if (err == 4) {
        goto _L;
      } else {
        if (err == 16) {
          _L: 
          retries ++;
          if (! (retries < 100)) {
            break;
          }
        } else {
          break;
        }
      }
    } else {
      break;
    }
  }
  if (ret) {
    tmp___2 = err;
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
static int __os_map(DB_ENV *dbenv___0 , char *path , DB_FH *fhp , size_t len , int is_region ,
                    int is_rdonly , void **addrp ) 
{ void *p ;
  int flags ;
  int prot ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned int )__db_global_values.j_map != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_map)))(path, len, is_region, is_rdonly, addrp);
    return (tmp);
  }
  if (is_rdonly) {
    flags = 2;
  } else {
    flags = 1;
  }
  flags |= 0;
  is_region = 0;
  is_region = is_region;
  if (is_rdonly) {
    tmp___0 = 0;
  } else {
    tmp___0 = 2;
  }
  prot = 1 | tmp___0;
  p = mmap((void *)0, len, prot, flags, fhp->fd, 0L);
  if ((unsigned int )p == (unsigned int )((void *)-1)) {
    ret = __os_get_errno();
    tmp___1 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "mmap: %s", tmp___1);
    return (ret);
  }
  if (dbenv___0->flags & 256U) {
    tmp___3 = mlock((void const   *)p, len);
    if (tmp___3 != 0) {
      ret = __os_get_errno();
      munmap(p, len);
      tmp___2 = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "mlock: %s", tmp___2);
      return (ret);
    }
  }
  (*addrp) = p;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-Ph57fPHM.i","-O2")
int db_env_set_func_close(int (*func_close)(int  ) ) ;
int db_env_set_func_dirfree(void (*func_dirfree)(char ** , int  ) ) ;
int db_env_set_func_dirlist(int (*func_dirlist)(char const   * , char *** , int * ) ) ;
int db_env_set_func_exists(int (*func_exists)(char const   * , int * ) ) ;
int db_env_set_func_free(void (*func_free)(void * ) ) ;
int db_env_set_func_fsync(int (*func_fsync)(int  ) ) ;
int db_env_set_func_ioinfo(int (*func_ioinfo)(char const   * , int  , u_int32_t * ,
                                              u_int32_t * , u_int32_t * ) ) ;
int db_env_set_func_malloc(void *(*func_malloc)(size_t  ) ) ;
int db_env_set_func_map(int (*func_map)(char * , size_t  , int  , int  , void ** ) ) ;
int db_env_set_func_open(int (*func_open)(char const   * , int   , ...) ) ;
int db_env_set_func_read(ssize_t (*func_read)(int  , void * , size_t  ) ) ;
int db_env_set_func_realloc(void *(*func_realloc)(void * , size_t  ) ) ;
int db_env_set_func_rename(int (*func_rename)(char const   * , char const   * ) ) ;
int db_env_set_func_seek(int (*func_seek)(int  , size_t  , db_pgno_t  , u_int32_t  ,
                                          int  , int  ) ) ;
int db_env_set_func_sleep(int (*func_sleep)(u_long  , u_long  ) ) ;
int db_env_set_func_unlink(int (*func_unlink)(char const   * ) ) ;
int db_env_set_func_unmap(int (*func_unmap)(void * , size_t  ) ) ;
int db_env_set_func_write(ssize_t (*func_write)(int  , void const   * , size_t  ) ) ;
int db_env_set_func_close(int (*func_close)(int  ) ) 
{ 

  {
  __db_global_values.j_close = func_close;
  return (0);
}
}
int db_env_set_func_dirfree(void (*func_dirfree)(char ** , int  ) ) 
{ 

  {
  __db_global_values.j_dirfree = func_dirfree;
  return (0);
}
}
int db_env_set_func_dirlist(int (*func_dirlist)(char const   * , char *** , int * ) ) 
{ 

  {
  __db_global_values.j_dirlist = func_dirlist;
  return (0);
}
}
int db_env_set_func_exists(int (*func_exists)(char const   * , int * ) ) 
{ 

  {
  __db_global_values.j_exists = func_exists;
  return (0);
}
}
int db_env_set_func_free(void (*func_free)(void * ) ) 
{ 

  {
  __db_global_values.j_free = func_free;
  return (0);
}
}
int db_env_set_func_fsync(int (*func_fsync)(int  ) ) 
{ 

  {
  __db_global_values.j_fsync = func_fsync;
  return (0);
}
}
int db_env_set_func_ioinfo(int (*func_ioinfo)(char const   * , int  , u_int32_t * ,
                                              u_int32_t * , u_int32_t * ) ) 
{ 

  {
  __db_global_values.j_ioinfo = func_ioinfo;
  return (0);
}
}
int db_env_set_func_malloc(void *(*func_malloc)(size_t  ) ) 
{ 

  {
  __db_global_values.j_malloc = func_malloc;
  return (0);
}
}
int db_env_set_func_map(int (*func_map)(char * , size_t  , int  , int  , void ** ) ) 
{ 

  {
  __db_global_values.j_map = func_map;
  return (0);
}
}
int db_env_set_func_open(int (*func_open)(char const   * , int   , ...) ) 
{ 

  {
  __db_global_values.j_open = func_open;
  return (0);
}
}
int db_env_set_func_read(ssize_t (*func_read)(int  , void * , size_t  ) ) 
{ 

  {
  __db_global_values.j_read = func_read;
  return (0);
}
}
int db_env_set_func_realloc(void *(*func_realloc)(void * , size_t  ) ) 
{ 

  {
  __db_global_values.j_realloc = func_realloc;
  return (0);
}
}
int db_env_set_func_rename(int (*func_rename)(char const   * , char const   * ) ) 
{ 

  {
  __db_global_values.j_rename = func_rename;
  return (0);
}
}
int db_env_set_func_seek(int (*func_seek)(int  , size_t  , db_pgno_t  , u_int32_t  ,
                                          int  , int  ) ) 
{ 

  {
  __db_global_values.j_seek = func_seek;
  return (0);
}
}
int db_env_set_func_sleep(int (*func_sleep)(u_long  , u_long  ) ) 
{ 

  {
  __db_global_values.j_sleep = func_sleep;
  return (0);
}
}
int db_env_set_func_unlink(int (*func_unlink)(char const   * ) ) 
{ 

  {
  __db_global_values.j_unlink = func_unlink;
  return (0);
}
}
int db_env_set_func_unmap(int (*func_unmap)(void * , size_t  ) ) 
{ 

  {
  __db_global_values.j_unmap = func_unmap;
  return (0);
}
}
int db_env_set_func_write(ssize_t (*func_write)(int  , void const   * , size_t  ) ) 
{ 

  {
  __db_global_values.j_write = func_write;
  return (0);
}
}
int db_env_set_func_yield(int (*func_yield)(void) ) 
{ 

  {
  __db_global_values.j_yield = func_yield;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-tOWBceQl.i","-O2")
u_int32_t __db_oflags(int oflags ) 
{ u_int32_t dbflags ;

  {
  dbflags = 0U;
  if (oflags & 64) {
    dbflags |= 1U;
  }
  if (oflags & 512) {
    dbflags |= 128U;
  }
  switch (oflags & 3) {
  case 2: ;
  case 1: ;
  break;
  default: 
  dbflags |= 16U;
  break;
  }
  return (dbflags);
}
}
int __db_omode(char const   *perm ) 
{ int mode ;

  {
  mode = 0;
  if ((int const   )(*(perm + 0)) == 114) {
    mode |= 256;
  }
  if ((int const   )(*(perm + 1)) == 119) {
    mode |= 128;
  }
  if ((int const   )(*(perm + 2)) == 114) {
    mode |= 32;
  }
  if ((int const   )(*(perm + 3)) == 119) {
    mode |= 16;
  }
  if ((int const   )(*(perm + 4)) == 114) {
    mode |= 4;
  }
  if ((int const   )(*(perm + 5)) == 119) {
    mode |= 2;
  }
  return (mode);
}
}
#pragma merger(0,"/tmp/cil-6e6JWtL7.i","-O2")
int __os_have_direct(void) 
{ int ret ;

  {
  ret = 0;
  return (ret);
}
}
int __os_open(DB_ENV *dbenv___0 , char const   *name , u_int32_t flags , int mode ,
              DB_FH **fhpp ) 
{ int tmp ;

  {
  tmp = __os_open_extend(dbenv___0, name, 0U, 0U, flags, mode, fhpp);
  return (tmp);
}
}
int __os_open_extend(DB_ENV *dbenv___0 , char const   *name , u_int32_t log_size ,
                     u_int32_t page_size , u_int32_t flags , int mode , DB_FH **fhpp ) 
{ DB_FH *fhp ;
  int oflags ;
  int ret ;

  {
  log_size = 0U;
  log_size = log_size;
  page_size = 0U;
  page_size = page_size;
  (*fhpp) = (DB_FH *)((void *)0);
  oflags = 0;
  ret = __db_fchk(dbenv___0, "__os_open", flags, 511U);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 1U) {
    oflags |= 64;
  }
  if (flags & 4U) {
    oflags |= 128;
  }
  if (flags & 16U) {
    oflags |= 0;
  } else {
    oflags |= 2;
  }
  if (flags & 256U) {
    oflags |= 512;
  }
  ret = __os_openhandle(dbenv___0, name, oflags, mode, & fhp);
  if (ret != 0) {
    return (ret);
  }
  if (flags & 128U) {
    __os_unlink(dbenv___0, name);
  }
  (*fhpp) = fhp;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-2mE8t3yd.i","-O2")
int __os_r_attach(DB_ENV *dbenv___0 , REGINFO *infop , REGION *rp ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (rp->size < 4294959104U) {
    rp->size = rp->size + 8191U;
  } else {
    if (rp->size < 8192U) {
      rp->size = rp->size + 8191U;
    }
  }
  rp->size = rp->size - rp->size % 8192U;
  if (dbenv___0->flags & 32768U) {
    ret = __os_malloc(dbenv___0, rp->size, (void *)(& infop->addr));
    if (ret != 0) {
      return (ret);
    }
    return (0);
  }
  if ((unsigned int )__db_global_values.j_map != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_map)))(infop->name, rp->size, 1, 0, & infop->addr);
    return (tmp);
  }
  tmp___0 = __os_r_sysattach(dbenv___0, infop, rp);
  return (tmp___0);
}
}
int __os_r_detach(DB_ENV *dbenv___0 , REGINFO *infop , int destroy ) 
{ REGION *rp ;
  int tmp ;
  int tmp___0 ;

  {
  rp = infop->rp;
  if (dbenv___0->flags & 32768U) {
    __os_free(dbenv___0, infop->addr);
    return (0);
  }
  if ((unsigned int )__db_global_values.j_unmap != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_unmap)))(infop->addr, rp->size);
    return (tmp);
  }
  tmp___0 = __os_r_sysdetach(dbenv___0, infop, destroy);
  return (tmp___0);
}
}
#pragma merger(0,"/tmp/cil-QwqatVFW.i","-O2")
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
int __os_rename(DB_ENV *dbenv___0 , char const   *old , char const   *new , u_int32_t flags ) 
{ int ret ;
  int retries ;
  char *tmp___1 ;

  {
  retries = 0;
  while (1) {
    if ((unsigned int )__db_global_values.j_rename != (unsigned int )((void *)0)) {
      ret = ((*(__db_global_values.j_rename)))(old, new);
    } else {
      ret = rename(old, new);
    }
    if (ret != 0) {
      ret = __os_get_errno();
      if (ret == 4) {
        goto _L;
      } else {
        if (ret == 16) {
          _L: 
          retries ++;
          if (! (retries < 100)) {
            break;
          }
        } else {
          break;
        }
      }
    } else {
      break;
    }
  }
  if (ret != 0) {
    if (flags == 0U) {
      tmp___1 = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "rename %s %s: %s", old, new, tmp___1);
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-6JetXEmU.i","-O2")
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
int __os_isroot(void) 
{ __uid_t tmp ;

  {
  tmp = getuid();
  return (tmp == 0U);
}
}
#pragma merger(0,"/tmp/cil-OsY9sQCg.i","-O2")
char *__db_rpath(char const   *path ) 
{ char const   *s ;
  char const   *last ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  s = path;
  last = (char const   *)((void *)0);
  if ((int const   )(*("/" + 1)) != 0) {
    while ((int const   )(*(s + 0)) != 0) {
      tmp___5 = __builtin_constant_p((int )(*(s + 0)));
      if (tmp___5) {
        tmp___6 = __builtin_constant_p((int )"/");
        if (tmp___6) {
          tmp___3 = (char *)__builtin_strchr("/", (*(s + 0)));
        } else {
          if ((int const   )(*(s + 0)) == 0) {
            tmp___3 = (char *)__rawmemchr((void const   *)"/", (int )(*(s + 0)));
          } else {
            tmp___3 = (char *)__builtin_strchr("/", (*(s + 0)));
          }
        }
      } else {
        tmp___3 = (char *)__builtin_strchr("/", (*(s + 0)));
      }
      if ((unsigned int )tmp___3 != (unsigned int )((void *)0)) {
        last = s;
      }
      s ++;
    }
  } else {
    while ((int const   )(*(s + 0)) != 0) {
      if ((int const   )(*(s + 0)) == (int const   )(*("/" + 0))) {
        last = s;
      }
      s ++;
    }
  }
  return ((char *)last);
}
}
#pragma merger(0,"/tmp/cil-frrYXzqu.i","-O2")
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
static int __os_physwrite(DB_ENV *dbenv___0 , DB_FH *fhp , void *addr , size_t len ,
                          size_t *nwp ) ;
int __os_io(DB_ENV *dbenv___0 , int op , DB_FH *fhp , db_pgno_t pgno , size_t pagesize ,
            u_int8_t *buf , size_t *niop ) 
{ int ret ;

  {
  switch (op) {
  case 1: ;
  if ((unsigned int )__db_global_values.j_read != (unsigned int )((void *)0)) {
    goto slow;
  }
  (*niop) = (size_t )pread(fhp->fd, (void *)buf, pagesize, (long )((unsigned long )((long )pgno) *
                                                                   (unsigned long )pagesize));
  break;
  case 2: ;
  if ((unsigned int )__db_global_values.j_write != (unsigned int )((void *)0)) {
    goto slow;
  }
  (*niop) = (size_t )pwrite(fhp->fd, (void const   *)buf, pagesize, (long )((unsigned long )((long )pgno) *
                                                                            (unsigned long )pagesize));
  break;
  }
  if ((*niop) == pagesize) {
    return (0);
  }
  slow: 
  if ((unsigned int )fhp->mutexp != (unsigned int )((void *)0)) {
    if (! ((fhp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, fhp->mutexp);
    }
  }
  ret = __os_seek(dbenv___0, fhp, pagesize, pgno, 0U, 0, (enum __anonenum_DB_OS_SEEK_52 )2);
  if (ret != 0) {
    goto err;
  }
  switch (op) {
  case 1: 
  ret = __os_read(dbenv___0, fhp, (void *)buf, pagesize, niop);
  break;
  case 2: 
  ret = __os_write(dbenv___0, fhp, (void *)buf, pagesize, niop);
  break;
  }
  err: 
  if ((unsigned int )fhp->mutexp != (unsigned int )((void *)0)) {
    if (! ((fhp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, fhp->mutexp);
    }
  }
  return (ret);
}
}
int __os_read(DB_ENV *dbenv___0 , DB_FH *fhp , void *addr , size_t len , size_t *nrp ) 
{ size_t offset ;
  ssize_t nr ;
  int ret ;
  int retries ;
  u_int8_t *taddr ;
  char *tmp ;

  {
  retries = 0;
  taddr = (u_int8_t *)addr;
  offset = 0U;
  while (offset < len) {
    retry: 
    if ((unsigned int )__db_global_values.j_read != (unsigned int )((void *)0)) {
      nr = ((*(__db_global_values.j_read)))(fhp->fd, (void *)taddr, len - offset);
    } else {
      nr = read(fhp->fd, (void *)taddr, len - offset);
    }
    if (nr < 0) {
      ret = __os_get_errno();
      if (ret == 4) {
        goto _L;
      } else {
        if (ret == 16) {
          _L: 
          retries ++;
          if (retries < 100) {
            goto retry;
          }
        }
      }
      tmp = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "read: 0x%x, %lu: %s", (unsigned int )taddr,
               (unsigned long )len - (unsigned long )offset, tmp);
      return (ret);
    }
    if (nr == 0) {
      break;
    }
    taddr += nr;
    offset += (unsigned int )nr;
  }
  (*nrp) = (unsigned int )(taddr - (u_int8_t *)addr);
  return (0);
}
}
int __os_write(DB_ENV *dbenv___0 , DB_FH *fhp , void *addr , size_t len , size_t *nwp ) 
{ int tmp ;

  {
  tmp = __os_physwrite(dbenv___0, fhp, addr, len, nwp);
  return (tmp);
}
}
static int __os_physwrite(DB_ENV *dbenv___0 , DB_FH *fhp , void *addr , size_t len ,
                          size_t *nwp ) 
{ size_t offset ;
  ssize_t nw ;
  int ret ;
  int retries ;
  u_int8_t *taddr ;
  char *tmp ;

  {
  retries = 0;
  taddr = (u_int8_t *)addr;
  offset = 0U;
  while (offset < len) {
    retry: 
    if ((unsigned int )__db_global_values.j_write != (unsigned int )((void *)0)) {
      nw = ((*(__db_global_values.j_write)))(fhp->fd, (void const   *)taddr, len -
                                                                             offset);
    } else {
      nw = write(fhp->fd, (void const   *)taddr, len - offset);
    }
    if (nw < 0) {
      ret = __os_get_errno();
      if (ret == 4) {
        goto _L;
      } else {
        if (ret == 16) {
          _L: 
          retries ++;
          if (retries < 100) {
            goto retry;
          }
        }
      }
      tmp = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "write: 0x%x, %lu: %s", (unsigned int )taddr,
               (unsigned long )len - (unsigned long )offset, tmp);
      return (ret);
    }
    taddr += nw;
    offset += (unsigned int )nw;
  }
  (*nwp) = len;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-f6Qvf3VM.i","-O2")
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
int __os_seek(DB_ENV *dbenv___0 , DB_FH *fhp , size_t pgsize , db_pgno_t pageno ,
              u_int32_t relative , int isrewind , DB_OS_SEEK db_whence ) 
{ off_t offset ;
  int ret ;
  int retries ;
  int whence ;
  __off_t tmp___1 ;
  char *tmp___2 ;

  {
  switch ((int )db_whence) {
  case 0: 
  whence = 1;
  break;
  case 1: 
  whence = 2;
  break;
  case 2: 
  whence = 0;
  break;
  default: ;
  return (22);
  }
  if ((unsigned int )__db_global_values.j_seek != (unsigned int )((void *)0)) {
    ret = ((*(__db_global_values.j_seek)))(fhp->fd, pgsize, pageno, relative, isrewind,
                                           whence);
  } else {
    offset = (long )((unsigned long )((long )pgsize) * (unsigned long )pageno + (unsigned long )relative);
    if (isrewind) {
      offset = - offset;
    }
    retries = 0;
    while (1) {
      tmp___1 = lseek(fhp->fd, offset, whence);
      if (tmp___1 == -1L) {
        ret = __os_get_errno();
      } else {
        ret = 0;
      }
      if (ret == 4) {
        goto _L;
      } else {
        if (ret == 16) {
          _L: 
          retries ++;
          if (! (retries < 100)) {
            break;
          }
        } else {
          break;
        }
      }
    }
  }
  if (ret == 0) {
    fhp->pgsize = pgsize;
    fhp->pgno = pageno;
    fhp->offset = relative;
  } else {
    tmp___2 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "seek: %lu %d %d: %s", (unsigned long )pgsize *
                                                                 (unsigned long )pageno +
                                                                 (unsigned long )relative,
             isrewind, db_whence, tmp___2);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-db0riWHc.i","-O2")
int __os_sleep(DB_ENV *dbenv___0 , u_long secs , u_long usecs ) 
{ struct timeval t ;
  int ret ;
  int tmp ;
  char *tmp___0 ;

  {
  while (usecs >= 1000000UL) {
    secs ++;
    usecs -= 1000000UL;
  }
  if ((unsigned int )__db_global_values.j_sleep != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_sleep)))(secs, usecs);
    return (tmp);
  }
  t.tv_sec = (long )secs;
  if (secs == 0UL) {
    if (usecs == 0UL) {
      t.tv_usec = 1L;
    } else {
      t.tv_usec = (long )usecs;
    }
  } else {
    t.tv_usec = (long )usecs;
  }
  ret = select(0, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& t));
  if (ret != 0) {
    ret = __os_get_errno();
    if (ret == 4) {
      ret = 0;
    }
  }
  if (ret != 0) {
    tmp___0 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "select: %s", tmp___0);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-SqstDI5u.i","-O2")
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
static int __os_sysconf(void) ;
static int __os_sysconf(void) 
{ long nproc ;
  int tmp ;

  {
  nproc = sysconf(84);
  if (nproc > 1L) {
    tmp = (int )nproc;
  } else {
    tmp = 1;
  }
  return (tmp);
}
}
void __os_spin(DB_ENV *dbenv___0 ) 
{ 

  {
  if (dbenv___0->tas_spins != 0U) {
    return;
  }
  dbenv___0->tas_spins = 1U;
  dbenv___0->tas_spins = (u_int32_t )__os_sysconf();
  if (dbenv___0->tas_spins != 1U) {
    dbenv___0->tas_spins = dbenv___0->tas_spins * 50U;
  }
  return;
}
}
void __os_yield(DB_ENV *dbenv___0 , u_long usecs ) 
{ int tmp ;

  {
  if ((unsigned int )__db_global_values.j_yield != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_yield)))();
    if (tmp == 0) {
      return;
    }
  }
  __os_sleep(dbenv___0, 0UL, usecs);
  return;
}
}
#pragma merger(0,"/tmp/cil-iUQRoen2.i","-O2")
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
__inline static  __attribute__((__nothrow__)) int fstat__extinline(int __fd , struct stat *__statbuf ) ;
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
int __os_exists(char const   *path , int *isdirp ) 
{ int ret ;
  int retries ;
  struct stat sb ;
  int tmp ;

  {
  if ((unsigned int )__db_global_values.j_exists != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_exists)))(path, isdirp);
    return (tmp);
  }
  retries = 0;
  while (1) {
    ret = stat__extinline(path, & sb);
    if (ret != 0) {
      ret = __os_get_errno();
    }
    if (ret == 4) {
      goto _L;
    } else {
      if (ret == 16) {
        _L: 
        retries ++;
        if (! (retries < 100)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )isdirp != (unsigned int )((void *)0)) {
    (*isdirp) = (sb.st_mode & 61440U) == 16384U;
  }
  return (0);
}
}
int __os_ioinfo(DB_ENV *dbenv___0 , char const   *path , DB_FH *fhp , u_int32_t *mbytesp ,
                u_int32_t *bytesp , u_int32_t *iosizep ) 
{ int ret ;
  int retries ;
  struct stat sb ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned int )__db_global_values.j_ioinfo != (unsigned int )((void *)0)) {
    tmp = ((*(__db_global_values.j_ioinfo)))(path, fhp->fd, mbytesp, bytesp, iosizep);
    return (tmp);
  }
  retries = 0;
  retry: 
  tmp___1 = fstat__extinline(fhp->fd, & sb);
  if (tmp___1 == -1) {
    ret = __os_get_errno();
    if (ret == 4) {
      goto _L;
    } else {
      if (ret == 16) {
        _L: 
        retries ++;
        if (retries < 100) {
          goto retry;
        }
      }
    }
    tmp___0 = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "fstat: %s", tmp___0);
    return (ret);
  }
  if ((unsigned int )mbytesp != (unsigned int )((void *)0)) {
    (*mbytesp) = (unsigned int )(sb.st_size / 1048576L);
  }
  if ((unsigned int )bytesp != (unsigned int )((void *)0)) {
    (*bytesp) = (unsigned int )(sb.st_size % 1048576L);
  }
  if ((unsigned int )iosizep != (unsigned int )((void *)0)) {
    (*iosizep) = (unsigned int )sb.st_blksize;
    if ((*iosizep) == 0U) {
      (*iosizep) = 8192U;
    }
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-cd7WzgvB.i","-O2")
static char const   *list___1[7]  = {      "/var/tmp",      "/usr/tmp",      "/temp",      "/tmp", 
        "C:/temp",      "C:/tmp",      (char const   *)((void *)0)};
int __os_tmpdir(DB_ENV *dbenv___0 , u_int32_t flags ) 
{ int isdir ;
  char const   * const  *lp ;
  char const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (flags & 1024U) {
    goto _L;
  } else {
    if (flags & 2048U) {
      tmp___0 = __os_isroot();
      if (tmp___0) {
        _L: 
        p = getenv("TMPDIR");
        if ((unsigned int )p != (unsigned int )((void *)0)) {
          if ((int const   )(*(p + 0)) == 0) {
            __db_err((DB_ENV const   *)dbenv___0, "illegal TMPDIR environment variable");
            return (22);
          }
        }
        if ((unsigned int )p == (unsigned int )((void *)0)) {
          p = getenv("TEMP");
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            if ((int const   )(*(p + 0)) == 0) {
              __db_err((DB_ENV const   *)dbenv___0, "illegal TEMP environment variable");
              return (22);
            }
          }
        }
        if ((unsigned int )p == (unsigned int )((void *)0)) {
          p = getenv("TMP");
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            if ((int const   )(*(p + 0)) == 0) {
              __db_err((DB_ENV const   *)dbenv___0, "illegal TMP environment variable");
              return (22);
            }
          }
        }
        if ((unsigned int )p == (unsigned int )((void *)0)) {
          p = getenv("TempFolder");
          if ((unsigned int )p != (unsigned int )((void *)0)) {
            if ((int const   )(*(p + 0)) == 0) {
              __db_err((DB_ENV const   *)dbenv___0, "illegal TempFolder environment variable");
              return (22);
            }
          }
        }
        if ((unsigned int )p != (unsigned int )((void *)0)) {
          tmp = __os_strdup(dbenv___0, p, (void *)(& dbenv___0->db_tmp_dir));
          return (tmp);
        }
      }
    }
  }
  lp = (char const   * const  *)(list___1);
  while ((unsigned int )(*lp) != (unsigned int )((void *)0)) {
    tmp___2 = __os_exists((char const   *)(*lp), & isdir);
    if (tmp___2 == 0) {
      if (isdir != 0) {
        tmp___1 = __os_strdup(dbenv___0, (char const   *)(*lp), (void *)(& dbenv___0->db_tmp_dir));
        return (tmp___1);
      }
    }
    lp ++;
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-43SsLMke.i","-O2")
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
int __os_region_unlink(DB_ENV *dbenv___0 , char const   *path ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 16384U) {
    __db_overwrite(dbenv___0, path);
  }
  tmp = __os_unlink(dbenv___0, path);
  return (tmp);
}
}
int __os_unlink(DB_ENV *dbenv___0 , char const   *path ) 
{ int ret ;
  int retries ;
  char *tmp___1 ;

  {
  retries = 0;
  retry: 
  if ((unsigned int )__db_global_values.j_unlink != (unsigned int )((void *)0)) {
    ret = ((*(__db_global_values.j_unlink)))(path);
  } else {
    ret = unlink(path);
  }
  if (ret == -1) {
    ret = __os_get_errno();
    if (ret == 4) {
      goto _L;
    } else {
      if (ret == 16) {
        _L: 
        retries ++;
        if (retries < 100) {
          goto retry;
        }
      }
    }
    if (ret != 2) {
      tmp___1 = strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "unlink: %s: %s", path, tmp___1);
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-6xiRDiYG.i","-O2")
void __db_SHA1Transform(u_int32_t *state , unsigned char *buffer ) ;
static int is_bigendian  =    -1;
void __db_SHA1Transform(u_int32_t *state , unsigned char *buffer ) 
{ u_int32_t a ;
  u_int32_t b ;
  u_int32_t c ;
  u_int32_t d ;
  u_int32_t e ;
  CHAR64LONG16 *block ;
  unsigned char workspace[64] ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___2 ;
  u_int32_t tmp___3 ;
  u_int32_t tmp___4 ;
  u_int32_t tmp___5 ;
  u_int32_t tmp___6 ;
  u_int32_t tmp___7 ;
  u_int32_t tmp___8 ;
  u_int32_t tmp___9 ;
  u_int32_t tmp___10 ;
  u_int32_t tmp___11 ;
  u_int32_t tmp___12 ;
  u_int32_t tmp___13 ;
  u_int32_t tmp___14 ;

  {
  block = (CHAR64LONG16 *)(workspace);
  memcpy((void * __restrict  )block, (void const   * __restrict  )buffer, 64U);
  if (is_bigendian == -1) {
    is_bigendian = __db_isbigendian();
  }
  a = (*(state + 0));
  b = (*(state + 1));
  c = (*(state + 2));
  d = (*(state + 3));
  e = (*(state + 4));
  if (((b & (c ^ d)) ^ d) + (unsigned int )is_bigendian) {
    tmp = block->l[0];
  } else {
    block->l[0] = (((block->l[0] << 24) | (block->l[0] >> 8)) & 4278255360U) | (((block->l[0] <<
                                                                                  8) |
                                                                                 (block->l[0] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp = (block->l[0] + 1518500249U) + ((a << 5) | (a >> 27));
  }
  e += tmp;
  b = (b << 30) | (b >> 2);
  if (((a & (b ^ c)) ^ c) + (unsigned int )is_bigendian) {
    tmp___0 = block->l[1];
  } else {
    block->l[1] = (((block->l[1] << 24) | (block->l[1] >> 8)) & 4278255360U) | (((block->l[1] <<
                                                                                  8) |
                                                                                 (block->l[1] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___0 = (block->l[1] + 1518500249U) + ((e << 5) | (e >> 27));
  }
  d += tmp___0;
  a = (a << 30) | (a >> 2);
  if (((e & (a ^ b)) ^ b) + (unsigned int )is_bigendian) {
    tmp___1 = block->l[2];
  } else {
    block->l[2] = (((block->l[2] << 24) | (block->l[2] >> 8)) & 4278255360U) | (((block->l[2] <<
                                                                                  8) |
                                                                                 (block->l[2] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___1 = (block->l[2] + 1518500249U) + ((d << 5) | (d >> 27));
  }
  c += tmp___1;
  e = (e << 30) | (e >> 2);
  if (((d & (e ^ a)) ^ a) + (unsigned int )is_bigendian) {
    tmp___2 = block->l[3];
  } else {
    block->l[3] = (((block->l[3] << 24) | (block->l[3] >> 8)) & 4278255360U) | (((block->l[3] <<
                                                                                  8) |
                                                                                 (block->l[3] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___2 = (block->l[3] + 1518500249U) + ((c << 5) | (c >> 27));
  }
  b += tmp___2;
  d = (d << 30) | (d >> 2);
  if (((c & (d ^ e)) ^ e) + (unsigned int )is_bigendian) {
    tmp___3 = block->l[4];
  } else {
    block->l[4] = (((block->l[4] << 24) | (block->l[4] >> 8)) & 4278255360U) | (((block->l[4] <<
                                                                                  8) |
                                                                                 (block->l[4] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___3 = (block->l[4] + 1518500249U) + ((b << 5) | (b >> 27));
  }
  a += tmp___3;
  c = (c << 30) | (c >> 2);
  if (((b & (c ^ d)) ^ d) + (unsigned int )is_bigendian) {
    tmp___4 = block->l[5];
  } else {
    block->l[5] = (((block->l[5] << 24) | (block->l[5] >> 8)) & 4278255360U) | (((block->l[5] <<
                                                                                  8) |
                                                                                 (block->l[5] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___4 = (block->l[5] + 1518500249U) + ((a << 5) | (a >> 27));
  }
  e += tmp___4;
  b = (b << 30) | (b >> 2);
  if (((a & (b ^ c)) ^ c) + (unsigned int )is_bigendian) {
    tmp___5 = block->l[6];
  } else {
    block->l[6] = (((block->l[6] << 24) | (block->l[6] >> 8)) & 4278255360U) | (((block->l[6] <<
                                                                                  8) |
                                                                                 (block->l[6] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___5 = (block->l[6] + 1518500249U) + ((e << 5) | (e >> 27));
  }
  d += tmp___5;
  a = (a << 30) | (a >> 2);
  if (((e & (a ^ b)) ^ b) + (unsigned int )is_bigendian) {
    tmp___6 = block->l[7];
  } else {
    block->l[7] = (((block->l[7] << 24) | (block->l[7] >> 8)) & 4278255360U) | (((block->l[7] <<
                                                                                  8) |
                                                                                 (block->l[7] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___6 = (block->l[7] + 1518500249U) + ((d << 5) | (d >> 27));
  }
  c += tmp___6;
  e = (e << 30) | (e >> 2);
  if (((d & (e ^ a)) ^ a) + (unsigned int )is_bigendian) {
    tmp___7 = block->l[8];
  } else {
    block->l[8] = (((block->l[8] << 24) | (block->l[8] >> 8)) & 4278255360U) | (((block->l[8] <<
                                                                                  8) |
                                                                                 (block->l[8] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___7 = (block->l[8] + 1518500249U) + ((c << 5) | (c >> 27));
  }
  b += tmp___7;
  d = (d << 30) | (d >> 2);
  if (((c & (d ^ e)) ^ e) + (unsigned int )is_bigendian) {
    tmp___8 = block->l[9];
  } else {
    block->l[9] = (((block->l[9] << 24) | (block->l[9] >> 8)) & 4278255360U) | (((block->l[9] <<
                                                                                  8) |
                                                                                 (block->l[9] >>
                                                                                  24)) &
                                                                                16711935U);
    tmp___8 = (block->l[9] + 1518500249U) + ((b << 5) | (b >> 27));
  }
  a += tmp___8;
  c = (c << 30) | (c >> 2);
  if (((b & (c ^ d)) ^ d) + (unsigned int )is_bigendian) {
    tmp___9 = block->l[10];
  } else {
    block->l[10] = (((block->l[10] << 24) | (block->l[10] >> 8)) & 4278255360U) |
                   (((block->l[10] << 8) | (block->l[10] >> 24)) & 16711935U);
    tmp___9 = (block->l[10] + 1518500249U) + ((a << 5) | (a >> 27));
  }
  e += tmp___9;
  b = (b << 30) | (b >> 2);
  if (((a & (b ^ c)) ^ c) + (unsigned int )is_bigendian) {
    tmp___10 = block->l[11];
  } else {
    block->l[11] = (((block->l[11] << 24) | (block->l[11] >> 8)) & 4278255360U) |
                   (((block->l[11] << 8) | (block->l[11] >> 24)) & 16711935U);
    tmp___10 = (block->l[11] + 1518500249U) + ((e << 5) | (e >> 27));
  }
  d += tmp___10;
  a = (a << 30) | (a >> 2);
  if (((e & (a ^ b)) ^ b) + (unsigned int )is_bigendian) {
    tmp___11 = block->l[12];
  } else {
    block->l[12] = (((block->l[12] << 24) | (block->l[12] >> 8)) & 4278255360U) |
                   (((block->l[12] << 8) | (block->l[12] >> 24)) & 16711935U);
    tmp___11 = (block->l[12] + 1518500249U) + ((d << 5) | (d >> 27));
  }
  c += tmp___11;
  e = (e << 30) | (e >> 2);
  if (((d & (e ^ a)) ^ a) + (unsigned int )is_bigendian) {
    tmp___12 = block->l[13];
  } else {
    block->l[13] = (((block->l[13] << 24) | (block->l[13] >> 8)) & 4278255360U) |
                   (((block->l[13] << 8) | (block->l[13] >> 24)) & 16711935U);
    tmp___12 = (block->l[13] + 1518500249U) + ((c << 5) | (c >> 27));
  }
  b += tmp___12;
  d = (d << 30) | (d >> 2);
  if (((c & (d ^ e)) ^ e) + (unsigned int )is_bigendian) {
    tmp___13 = block->l[14];
  } else {
    block->l[14] = (((block->l[14] << 24) | (block->l[14] >> 8)) & 4278255360U) |
                   (((block->l[14] << 8) | (block->l[14] >> 24)) & 16711935U);
    tmp___13 = (block->l[14] + 1518500249U) + ((b << 5) | (b >> 27));
  }
  a += tmp___13;
  c = (c << 30) | (c >> 2);
  if (((b & (c ^ d)) ^ d) + (unsigned int )is_bigendian) {
    tmp___14 = block->l[15];
  } else {
    block->l[15] = (((block->l[15] << 24) | (block->l[15] >> 8)) & 4278255360U) |
                   (((block->l[15] << 8) | (block->l[15] >> 24)) & 16711935U);
    tmp___14 = (block->l[15] + 1518500249U) + ((a << 5) | (a >> 27));
  }
  e += tmp___14;
  b = (b << 30) | (b >> 2);
  block->l[0] = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) |
                ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
  d += ((((a & (b ^ c)) ^ c) + block->l[0]) + 1518500249U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[1] = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) |
                ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
  c += ((((e & (a ^ b)) ^ b) + block->l[1]) + 1518500249U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[2] = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) <<
                 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >>
                       31);
  b += ((((d & (e ^ a)) ^ a) + block->l[2]) + 1518500249U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[3] = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) |
                ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
  a += ((((c & (d ^ e)) ^ e) + block->l[3]) + 1518500249U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[4] = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) |
                ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
  e += ((((b ^ c) ^ d) + block->l[4]) + 1859775393U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[5] = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) |
                ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
  d += ((((a ^ b) ^ c) + block->l[5]) + 1859775393U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[6] = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) |
                ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
  c += ((((e ^ a) ^ b) + block->l[6]) + 1859775393U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[7] = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) |
                ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
  b += ((((d ^ e) ^ a) + block->l[7]) + 1859775393U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[8] = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) |
                ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
  a += ((((c ^ d) ^ e) + block->l[8]) + 1859775393U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[9] = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) |
                ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
  e += ((((b ^ c) ^ d) + block->l[9]) + 1859775393U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[10] = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) <<
                  1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >>
                        31);
  d += ((((a ^ b) ^ c) + block->l[10]) + 1859775393U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[11] = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) <<
                  1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >>
                        31);
  c += ((((e ^ a) ^ b) + block->l[11]) + 1859775393U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[12] = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) <<
                  1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >>
                        31);
  b += ((((d ^ e) ^ a) + block->l[12]) + 1859775393U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[13] = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) <<
                  1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >>
                        31);
  a += ((((c ^ d) ^ e) + block->l[13]) + 1859775393U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[14] = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) <<
                  1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >>
                        31);
  e += ((((b ^ c) ^ d) + block->l[14]) + 1859775393U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[15] = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) <<
                  1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >>
                        31);
  d += ((((a ^ b) ^ c) + block->l[15]) + 1859775393U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[0] = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) |
                ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
  c += ((((e ^ a) ^ b) + block->l[0]) + 1859775393U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[1] = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) |
                ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
  b += ((((d ^ e) ^ a) + block->l[1]) + 1859775393U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[2] = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) <<
                 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >>
                       31);
  a += ((((c ^ d) ^ e) + block->l[2]) + 1859775393U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[3] = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) |
                ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
  e += ((((b ^ c) ^ d) + block->l[3]) + 1859775393U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[4] = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) |
                ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
  d += ((((a ^ b) ^ c) + block->l[4]) + 1859775393U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[5] = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) |
                ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
  c += ((((e ^ a) ^ b) + block->l[5]) + 1859775393U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[6] = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) |
                ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
  b += ((((d ^ e) ^ a) + block->l[6]) + 1859775393U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[7] = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) |
                ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
  a += ((((c ^ d) ^ e) + block->l[7]) + 1859775393U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[8] = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) |
                ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
  e += (((((b | c) & d) | (b & c)) + block->l[8]) + 2400959708U) + ((a << 5) | (a >>
                                                                                27));
  b = (b << 30) | (b >> 2);
  block->l[9] = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) |
                ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
  d += (((((a | b) & c) | (a & b)) + block->l[9]) + 2400959708U) + ((e << 5) | (e >>
                                                                                27));
  a = (a << 30) | (a >> 2);
  block->l[10] = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) <<
                  1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >>
                        31);
  c += (((((e | a) & b) | (e & a)) + block->l[10]) + 2400959708U) + ((d << 5) | (d >>
                                                                                 27));
  e = (e << 30) | (e >> 2);
  block->l[11] = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) <<
                  1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >>
                        31);
  b += (((((d | e) & a) | (d & e)) + block->l[11]) + 2400959708U) + ((c << 5) | (c >>
                                                                                 27));
  d = (d << 30) | (d >> 2);
  block->l[12] = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) <<
                  1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >>
                        31);
  a += (((((c | d) & e) | (c & d)) + block->l[12]) + 2400959708U) + ((b << 5) | (b >>
                                                                                 27));
  c = (c << 30) | (c >> 2);
  block->l[13] = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) <<
                  1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >>
                        31);
  e += (((((b | c) & d) | (b & c)) + block->l[13]) + 2400959708U) + ((a << 5) | (a >>
                                                                                 27));
  b = (b << 30) | (b >> 2);
  block->l[14] = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) <<
                  1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >>
                        31);
  d += (((((a | b) & c) | (a & b)) + block->l[14]) + 2400959708U) + ((e << 5) | (e >>
                                                                                 27));
  a = (a << 30) | (a >> 2);
  block->l[15] = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) <<
                  1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >>
                        31);
  c += (((((e | a) & b) | (e & a)) + block->l[15]) + 2400959708U) + ((d << 5) | (d >>
                                                                                 27));
  e = (e << 30) | (e >> 2);
  block->l[0] = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) |
                ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
  b += (((((d | e) & a) | (d & e)) + block->l[0]) + 2400959708U) + ((c << 5) | (c >>
                                                                                27));
  d = (d << 30) | (d >> 2);
  block->l[1] = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) |
                ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
  a += (((((c | d) & e) | (c & d)) + block->l[1]) + 2400959708U) + ((b << 5) | (b >>
                                                                                27));
  c = (c << 30) | (c >> 2);
  block->l[2] = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) <<
                 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >>
                       31);
  e += (((((b | c) & d) | (b & c)) + block->l[2]) + 2400959708U) + ((a << 5) | (a >>
                                                                                27));
  b = (b << 30) | (b >> 2);
  block->l[3] = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) |
                ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
  d += (((((a | b) & c) | (a & b)) + block->l[3]) + 2400959708U) + ((e << 5) | (e >>
                                                                                27));
  a = (a << 30) | (a >> 2);
  block->l[4] = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) |
                ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
  c += (((((e | a) & b) | (e & a)) + block->l[4]) + 2400959708U) + ((d << 5) | (d >>
                                                                                27));
  e = (e << 30) | (e >> 2);
  block->l[5] = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) |
                ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
  b += (((((d | e) & a) | (d & e)) + block->l[5]) + 2400959708U) + ((c << 5) | (c >>
                                                                                27));
  d = (d << 30) | (d >> 2);
  block->l[6] = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) |
                ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
  a += (((((c | d) & e) | (c & d)) + block->l[6]) + 2400959708U) + ((b << 5) | (b >>
                                                                                27));
  c = (c << 30) | (c >> 2);
  block->l[7] = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) |
                ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
  e += (((((b | c) & d) | (b & c)) + block->l[7]) + 2400959708U) + ((a << 5) | (a >>
                                                                                27));
  b = (b << 30) | (b >> 2);
  block->l[8] = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) |
                ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
  d += (((((a | b) & c) | (a & b)) + block->l[8]) + 2400959708U) + ((e << 5) | (e >>
                                                                                27));
  a = (a << 30) | (a >> 2);
  block->l[9] = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) |
                ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
  c += (((((e | a) & b) | (e & a)) + block->l[9]) + 2400959708U) + ((d << 5) | (d >>
                                                                                27));
  e = (e << 30) | (e >> 2);
  block->l[10] = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) <<
                  1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >>
                        31);
  b += (((((d | e) & a) | (d & e)) + block->l[10]) + 2400959708U) + ((c << 5) | (c >>
                                                                                 27));
  d = (d << 30) | (d >> 2);
  block->l[11] = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) <<
                  1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >>
                        31);
  a += (((((c | d) & e) | (c & d)) + block->l[11]) + 2400959708U) + ((b << 5) | (b >>
                                                                                 27));
  c = (c << 30) | (c >> 2);
  block->l[12] = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) <<
                  1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >>
                        31);
  e += ((((b ^ c) ^ d) + block->l[12]) + 3395469782U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[13] = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) <<
                  1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >>
                        31);
  d += ((((a ^ b) ^ c) + block->l[13]) + 3395469782U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[14] = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) <<
                  1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >>
                        31);
  c += ((((e ^ a) ^ b) + block->l[14]) + 3395469782U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[15] = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) <<
                  1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >>
                        31);
  b += ((((d ^ e) ^ a) + block->l[15]) + 3395469782U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[0] = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) |
                ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
  a += ((((c ^ d) ^ e) + block->l[0]) + 3395469782U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[1] = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) |
                ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
  e += ((((b ^ c) ^ d) + block->l[1]) + 3395469782U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[2] = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) <<
                 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >>
                       31);
  d += ((((a ^ b) ^ c) + block->l[2]) + 3395469782U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[3] = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) |
                ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
  c += ((((e ^ a) ^ b) + block->l[3]) + 3395469782U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[4] = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) |
                ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
  b += ((((d ^ e) ^ a) + block->l[4]) + 3395469782U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[5] = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) |
                ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
  a += ((((c ^ d) ^ e) + block->l[5]) + 3395469782U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[6] = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) |
                ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
  e += ((((b ^ c) ^ d) + block->l[6]) + 3395469782U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[7] = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) |
                ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
  d += ((((a ^ b) ^ c) + block->l[7]) + 3395469782U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[8] = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) |
                ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
  c += ((((e ^ a) ^ b) + block->l[8]) + 3395469782U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[9] = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) |
                ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
  b += ((((d ^ e) ^ a) + block->l[9]) + 3395469782U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[10] = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) <<
                  1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >>
                        31);
  a += ((((c ^ d) ^ e) + block->l[10]) + 3395469782U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  block->l[11] = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) <<
                  1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >>
                        31);
  e += ((((b ^ c) ^ d) + block->l[11]) + 3395469782U) + ((a << 5) | (a >> 27));
  b = (b << 30) | (b >> 2);
  block->l[12] = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) <<
                  1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >>
                        31);
  d += ((((a ^ b) ^ c) + block->l[12]) + 3395469782U) + ((e << 5) | (e >> 27));
  a = (a << 30) | (a >> 2);
  block->l[13] = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) <<
                  1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >>
                        31);
  c += ((((e ^ a) ^ b) + block->l[13]) + 3395469782U) + ((d << 5) | (d >> 27));
  e = (e << 30) | (e >> 2);
  block->l[14] = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) <<
                  1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >>
                        31);
  b += ((((d ^ e) ^ a) + block->l[14]) + 3395469782U) + ((c << 5) | (c >> 27));
  d = (d << 30) | (d >> 2);
  block->l[15] = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) <<
                  1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >>
                        31);
  a += ((((c ^ d) ^ e) + block->l[15]) + 3395469782U) + ((b << 5) | (b >> 27));
  c = (c << 30) | (c >> 2);
  (*(state + 0)) = (*(state + 0)) + a;
  (*(state + 1)) = (*(state + 1)) + b;
  (*(state + 2)) = (*(state + 2)) + c;
  (*(state + 3)) = (*(state + 3)) + d;
  (*(state + 4)) = (*(state + 4)) + e;
  e = 0U;
  d = e;
  c = d;
  b = c;
  a = b;
  return;
}
}
void __db_SHA1Init(SHA1_CTX *context ) 
{ 

  {
  context->state[0] = 1732584193U;
  context->state[1] = 4023233417U;
  context->state[2] = 2562383102U;
  context->state[3] = 271733878U;
  context->state[4] = 3285377520U;
  context->count[1] = 0U;
  context->count[0] = context->count[1];
  return;
}
}
void __db_SHA1Update(SHA1_CTX *context , unsigned char *data , size_t len ) 
{ u_int32_t i ;
  u_int32_t j ;

  {
  j = (context->count[0] >> 3) & 63U;
  context->count[0] = context->count[0] + (len << 3);
  if (context->count[0] < len << 3) {
    context->count[1] = context->count[1] + 1U;
  }
  context->count[1] = context->count[1] + (len >> 29);
  if (j + len > 63U) {
    i = 64U - j;
    memcpy((void * __restrict  )(& context->buffer[j]), (void const   * __restrict  )data,
           i);
    __db_SHA1Transform(context->state, context->buffer);
    while (i + 63U < len) {
      __db_SHA1Transform(context->state, data + i);
      i += 64U;
    }
    j = 0U;
  } else {
    i = 0U;
  }
  memcpy((void * __restrict  )(& context->buffer[j]), (void const   * __restrict  )(data +
                                                                                    i),
         len - i);
  return;
}
}
void __db_SHA1Final(unsigned char *digest , SHA1_CTX *context ) 
{ u_int32_t i ;
  unsigned char finalcount[8] ;
  int tmp ;

  {
  i = 0U;
  while (i < 8U) {
    if (i >= 4U) {
      tmp = 0;
    } else {
      tmp = 1;
    }
    finalcount[i] = (unsigned char )((context->count[tmp] >> (3U - (i & 3U)) * 8U) &
                                     255U);
    i ++;
  }
  __db_SHA1Update(context, (unsigned char *)"\200", 1U);
  while ((context->count[0] & 504U) != 448U) {
    __db_SHA1Update(context, (unsigned char *)"\000", 1U);
  }
  __db_SHA1Update(context, finalcount, 8U);
  i = 0U;
  while (i < 20U) {
    (*(digest + i)) = (unsigned char )((context->state[i >> 2] >> (3U - (i & 3U)) *
                                                                  8U) & 255U);
    i ++;
  }
  i = 0U;
  memset((void *)(context->buffer), 0, 64U);
  memset((void *)(context->state), 0, 20U);
  memset((void *)(context->count), 0, 8U);
  memset((void *)(finalcount), 0, 8U);
  __db_SHA1Transform(context->state, context->buffer);
  return;
}
}
#pragma merger(0,"/tmp/cil-KV0QJvHm.i","-O2")
int __txn_begin_pp(DB_ENV *dbenv___0 , DB_TXN *parent , DB_TXN **txnpp , u_int32_t flags ) ;
int __txn_xa_begin(DB_ENV *dbenv___0 , DB_TXN *txn ) ;
int __txn_discard(DB_TXN *txnp , u_int32_t flags ) ;
int __txn_prepare(DB_TXN *txnp , u_int8_t *gid ) ;
u_int32_t __txn_id(DB_TXN *txnp ) ;
int __txn_set_timeout(DB_TXN *txnp , db_timeout_t timeout , u_int32_t op ) ;
int __txn_checkpoint_pp(DB_ENV *dbenv___0 , u_int32_t kbytes , u_int32_t minutes ,
                        u_int32_t flags ) ;
int __txn_regop_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , int32_t timestamp , DBT const   *locks ) ;
int __txn_ckp_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  DB_LSN *ckp_lsn , DB_LSN *last_ckp , int32_t timestamp , u_int32_t rep_gen ) ;
int __txn_child_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t child , DB_LSN *c_lsn ) ;
int __txn_xa_regop_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                       u_int32_t opcode , DBT const   *xid , int32_t formatID , u_int32_t gtrid ,
                       u_int32_t bqual , DB_LSN *begin_lsn , DBT const   *locks ) ;
int __txn_recycle_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      u_int32_t min , u_int32_t max ) ;
int __txn_doevents(DB_ENV *dbenv___0 , DB_TXN *txn , int opcode , int preprocess ) ;
static int __txn_abort_pp(DB_TXN *txnp ) ;
static int __txn_begin_int(DB_TXN *txn , int internal ) ;
static int __txn_commit_pp(DB_TXN *txnp , u_int32_t flags ) ;
static int __txn_discard_pp(DB_TXN *txnp , u_int32_t flags ) ;
static int __txn_end(DB_TXN *txnp , int is_commit ) ;
static int __txn_isvalid(DB_TXN const   *txnp , TXN_DETAIL **tdp , txnop_t op ) ;
static int __txn_undo(DB_TXN *txnp ) ;
static int __txn_dispatch_undo(DB_ENV *dbenv___0 , DB_TXN *txnp , DBT *rdbt , DB_LSN *key_lsn ,
                               void *txnlist ) ;
int __txn_begin_pp(DB_ENV *dbenv___0 , DB_TXN *parent , DB_TXN **txnpp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"txn_begin", 131072U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "txn_begin", flags, 33566976U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_fcchk(dbenv___0, "txn_begin", flags, 256U, 8192U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )parent == (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
        rep_check = 0;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
          if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
            rep_check = 1;
          } else {
            rep_check = 0;
          }
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    }
    if (rep_check) {
      __op_rep_enter(dbenv___0);
    }
  } else {
    rep_check = 0;
  }
  ret = __txn_begin(dbenv___0, parent, txnpp, flags);
  if (ret != 0) {
    if (rep_check) {
      __op_rep_exit(dbenv___0);
    }
  }
  return (ret);
}
}
int __txn_begin(DB_ENV *dbenv___0 , DB_TXN *parent , DB_TXN **txnpp , u_int32_t flags ) 
{ DB_LOCKREGION *region ;
  DB_TXN *txn ;
  int ret ;

  {
  (*txnpp) = (DB_TXN *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_TXN ), (void *)(& txn));
  if (ret != 0) {
    return (ret);
  }
  txn->mgrp = (DB_TXNMGR *)dbenv___0->tx_handle;
  txn->parent = parent;
  while (1) {
    txn->kids.tqh_first = (struct __db_txn *)((void *)0);
    txn->kids.tqh_last = & txn->kids.tqh_first;
    break;
  }
  while (1) {
    txn->events.tqh_first = (struct __txn_event *)((void *)0);
    txn->events.tqh_last = & txn->events.tqh_first;
    break;
  }
  while (1) {
    txn->logs.stqh_first = (struct __txn_logrec *)((void *)0);
    txn->logs.stqh_last = & txn->logs.stqh_first;
    break;
  }
  txn->flags = 16U;
  if (flags & 33554432U) {
    txn->flags = txn->flags | 4U;
  }
  if (flags & 256U) {
    txn->flags = txn->flags | 32U;
  }
  if (flags & 8192U) {
    txn->flags = txn->flags | 256U;
  }
  if (flags & 4096U) {
    txn->flags = txn->flags | 64U;
  }
  ret = __txn_begin_int(txn, 0);
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )parent != (unsigned int )((void *)0)) {
    while (1) {
      txn->klinks.tqe_next = parent->kids.tqh_first;
      if ((unsigned int )txn->klinks.tqe_next != (unsigned int )((void *)0)) {
        (parent->kids.tqh_first)->klinks.tqe_prev = & txn->klinks.tqe_next;
      } else {
        parent->kids.tqh_last = & txn->klinks.tqe_next;
      }
      parent->kids.tqh_first = txn;
      txn->klinks.tqe_prev = & parent->kids.tqh_first;
      break;
    }
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    region = (DB_LOCKREGION *)((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.primary;
    if ((unsigned int )parent != (unsigned int )((void *)0)) {
      ret = __lock_inherit_timeout(dbenv___0, parent->txnid, txn->txnid);
      if (ret == 22) {
        parent = (DB_TXN *)((void *)0);
        ret = 0;
      }
      if (ret != 0) {
        goto err;
      }
    }
    if ((unsigned int )parent == (unsigned int )((void *)0)) {
      if (region->tx_timeout != 0U) {
        ret = __lock_set_timeout(dbenv___0, txn->txnid, region->tx_timeout, 33U);
        if (ret != 0) {
          goto err;
        }
      }
    }
  }
  (*txnpp) = txn;
  return (0);
  err: 
  __os_free(dbenv___0, (void *)txn);
  return (ret);
}
}
int __txn_xa_begin(DB_ENV *dbenv___0 , DB_TXN *txn ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  txn->mgrp = (DB_TXNMGR *)dbenv___0->tx_handle;
  while (1) {
    txn->kids.tqh_first = (struct __db_txn *)((void *)0);
    txn->kids.tqh_last = & txn->kids.tqh_first;
    break;
  }
  while (1) {
    txn->events.tqh_first = (struct __txn_event *)((void *)0);
    txn->events.tqh_last = & txn->events.tqh_first;
    break;
  }
  while (1) {
    txn->logs.stqh_first = (struct __txn_logrec *)((void *)0);
    txn->logs.stqh_last = & txn->logs.stqh_first;
    break;
  }
  txn->parent = (DB_TXN *)((void *)0);
  while (1) {
    txn->last_lsn.file = 0U;
    txn->last_lsn.offset = 0U;
    break;
  }
  txn->txnid = 0U;
  txn->tid = 0U;
  txn->cursors = 0U;
  memset((void *)(& txn->lock_timeout), 0, sizeof(db_timeout_t ));
  memset((void *)(& txn->expire), 0, sizeof(db_timeout_t ));
  tmp___0 = __txn_begin_int(txn, 0);
  return (tmp___0);
}
}
int __txn_compensate_begin(DB_ENV *dbenv___0 , DB_TXN **txnpp ) 
{ DB_TXN *txn ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_TXN ), (void *)(& txn));
  if (ret != 0) {
    return (ret);
  }
  txn->mgrp = (DB_TXNMGR *)dbenv___0->tx_handle;
  while (1) {
    txn->kids.tqh_first = (struct __db_txn *)((void *)0);
    txn->kids.tqh_last = & txn->kids.tqh_first;
    break;
  }
  while (1) {
    txn->events.tqh_first = (struct __txn_event *)((void *)0);
    txn->events.tqh_last = & txn->events.tqh_first;
    break;
  }
  while (1) {
    txn->logs.stqh_first = (struct __txn_logrec *)((void *)0);
    txn->logs.stqh_last = & txn->logs.stqh_first;
    break;
  }
  txn->flags = 18U;
  (*txnpp) = txn;
  tmp___0 = __txn_begin_int(txn, 1);
  return (tmp___0);
}
}
static int __txn_begin_int(DB_TXN *txn , int internal ) 
{ DB_ENV *dbenv___0 ;
  DB_LSN begin_lsn ;
  DB_LSN null_lsn ;
  DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  TXN_DETAIL *td ;
  size_t off ;
  u_int32_t id ;
  u_int32_t *ids ;
  int nids ;
  int ret ;
  int tmp ;

  {
  mgr = txn->mgrp;
  dbenv___0 = mgr->dbenv;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
          goto _L___0;
        } else {
          __log_txn_lsn(dbenv___0, & begin_lsn, (u_int32_t *)((void *)0), (u_int32_t *)((void *)0));
        }
      } else {
        __log_txn_lsn(dbenv___0, & begin_lsn, (u_int32_t *)((void *)0), (u_int32_t *)((void *)0));
      }
    }
  } else {
    _L___0: 
    while (1) {
      begin_lsn.file = 0U;
      begin_lsn.offset = 0U;
      break;
    }
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (! (txn->flags & 2U)) {
    if (region->flags & 1U) {
      __db_err((DB_ENV const   *)dbenv___0, "operation not permitted during recovery");
      ret = 22;
      goto err;
    }
  }
  if (! internal) {
    if (region->stat.st_nrestores != 0U) {
      __db_err((DB_ENV const   *)dbenv___0, "recovery of prepared but not yet committed transactions is incomplete");
      ret = 22;
      goto err;
    }
  }
  if (region->last_txnid == 4294967295U) {
    if (region->cur_maxid != 4294967295U) {
      region->last_txnid = 2147483647U;
    }
  }
  if (region->last_txnid == region->cur_maxid) {
    ret = __os_malloc(dbenv___0, sizeof(u_int32_t ) * region->maxtxns, (void *)(& ids));
    if (ret != 0) {
      goto err;
    }
    nids = 0;
    if (region->active_txn.stqh_first == -1) {
      td = (TXN_DETAIL *)((void *)0);
    } else {
      td = (struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first);
    }
    while ((unsigned int )td != (unsigned int )((void *)0)) {
      tmp = nids;
      nids ++;
      (*(ids + tmp)) = td->txnid;
      if (td->links.stqe_next == -1) {
        td = (TXN_DETAIL *)((void *)0);
      } else {
        td = (struct __txn_detail *)((u_int8_t *)td + td->links.stqe_next);
      }
    }
    region->last_txnid = 2147483647U;
    region->cur_maxid = 4294967295U;
    if (nids != 0) {
      __db_idspace(ids, nids, & region->last_txnid, & region->cur_maxid);
    }
    __os_free(dbenv___0, (void *)ids);
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if (((DB_REP *)dbenv___0->rep_handle)->region) {
          if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
            goto _L___5;
          }
        } else {
          goto _L___5;
        }
      } else {
        _L___5: 
        if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
          if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
            goto _L___3;
          }
        } else {
          _L___3: 
          ret = __txn_recycle_log(dbenv___0, (DB_TXN *)((void *)0), & null_lsn, 0U,
                                  region->last_txnid, region->cur_maxid);
          if (ret != 0) {
            goto err;
          }
        }
      }
    }
  }
  ret = __db_shalloc(mgr->reginfo.addr, sizeof(TXN_DETAIL ), 0U, (void *)(& td));
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Unable to allocate memory for transaction detail");
    goto err;
  }
  while (1) {
    if (region->active_txn.stqh_first != -1) {
      td->links.stqe_next = region->active_txn.stqh_first - ((u_int8_t *)td - (u_int8_t *)(& region->active_txn));
      if (td->links.stqe_next == -1) {
        ((struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first))->links.stqe_prev = 0;
      } else {
        ((struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first))->links.stqe_prev = - td->links.stqe_next +
                                                                                                                         ((u_int8_t *)(& td->links.stqe_next) -
                                                                                                                          (u_int8_t *)td);
      }
    } else {
      region->active_txn.stqh_last = (u_int8_t *)(& td->links.stqe_next) - (u_int8_t *)(& region->active_txn);
      td->links.stqe_next = -1;
    }
    region->active_txn.stqh_first = (u_int8_t *)td - (u_int8_t *)(& region->active_txn);
    td->links.stqe_prev = (u_int8_t *)(& region->active_txn.stqh_first) - (u_int8_t *)td;
    break;
  }
  region->last_txnid = region->last_txnid + 1U;
  id = region->last_txnid;
  region->stat.st_nbegins = region->stat.st_nbegins + 1U;
  region->stat.st_nactive = region->stat.st_nactive + 1U;
  if (region->stat.st_nactive > region->stat.st_maxnactive) {
    region->stat.st_maxnactive = region->stat.st_nactive;
  }
  td->txnid = id;
  while (1) {
    td->last_lsn.file = 0U;
    td->last_lsn.offset = 0U;
    break;
  }
  td->begin_lsn = begin_lsn;
  if ((unsigned int )txn->parent != (unsigned int )((void *)0)) {
    td->parent = (txn->parent)->off;
  } else {
    td->parent = 0U;
  }
  td->status = 1U;
  td->flags = 0U;
  td->xa_status = 0U;
  off = (unsigned int )((u_int8_t *)td - (u_int8_t *)mgr->reginfo.addr);
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  while (1) {
    txn->last_lsn.file = 0U;
    txn->last_lsn.offset = 0U;
    break;
  }
  txn->txnid = id;
  txn->off = off;
  txn->abort = & __txn_abort_pp;
  txn->commit = & __txn_commit_pp;
  txn->discard = & __txn_discard_pp;
  txn->id = & __txn_id;
  txn->prepare = & __txn_prepare;
  txn->set_timeout = & __txn_set_timeout;
  if ((unsigned int )txn->parent != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
      ret = __lock_addfamilylocker(dbenv___0, (txn->parent)->txnid, txn->txnid);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if (txn->flags & 16U) {
    if ((unsigned int )mgr->mutexp != (unsigned int )((void *)0)) {
      if (! ((mgr->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, mgr->mutexp);
      }
    }
    while (1) {
      txn->links.tqe_next = (struct __db_txn *)((void *)0);
      txn->links.tqe_prev = mgr->txn_chain.tqh_last;
      (*(mgr->txn_chain.tqh_last)) = txn;
      mgr->txn_chain.tqh_last = & txn->links.tqe_next;
      break;
    }
    if ((unsigned int )mgr->mutexp != (unsigned int )((void *)0)) {
      if (! ((mgr->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, mgr->mutexp);
      }
    }
  }
  return (0);
  err: 
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  return (ret);
}
}
static int __txn_commit_pp(DB_TXN *txnp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int not_child ;
  int ret ;

  {
  dbenv___0 = (txnp->mgrp)->dbenv;
  not_child = (unsigned int )txnp->parent == (unsigned int )((void *)0);
  ret = __txn_commit(txnp, flags);
  if (not_child) {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
        goto _L;
      }
    } else {
      _L: 
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
          if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
            __op_rep_exit(dbenv___0);
          }
        }
      }
    }
  }
  return (ret);
}
}
int __txn_commit(DB_TXN *txnp , u_int32_t flags ) 
{ DBT list_dbt ;
  DB_ENV *dbenv___0 ;
  DB_LOCKREQ request ;
  DB_TXN *kid ;
  TXN_DETAIL *td ;
  u_int32_t lflags ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  dbenv___0 = (txnp->mgrp)->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __txn_isvalid((DB_TXN const   *)txnp, & td, (enum __anonenum_txnop_t_90 )1);
  if (ret != 0) {
    return (ret);
  }
  tmp___0 = __db_fchk(dbenv___0, "DB_TXN->commit", flags, 8448U);
  if (tmp___0 != 0) {
    flags = 8192U;
  }
  tmp___1 = __db_fcchk(dbenv___0, "DB_TXN->commit", flags, 256U, 8192U);
  if (tmp___1 != 0) {
    flags = 8192U;
  }
  if (flags & 256U) {
    txnp->flags = txnp->flags & 4294967039U;
    txnp->flags = txnp->flags | 32U;
  }
  if (flags & 8192U) {
    txnp->flags = txnp->flags & 4294967263U;
    txnp->flags = txnp->flags | 256U;
  }
  while (1) {
    kid = txnp->kids.tqh_first;
    if (! ((unsigned int )kid != (unsigned int )((void *)0))) {
      break;
    }
    ret = __txn_commit(kid, flags);
    if (ret != 0) {
      while (1) {
        kid = txnp->kids.tqh_first;
        if (! ((unsigned int )kid != (unsigned int )((void *)0))) {
          break;
        }
        t_ret = __txn_abort(kid);
        if (t_ret != 0) {
          tmp___2 = __db_panic(dbenv___0, t_ret);
          return (tmp___2);
        }
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L___0;
        }
      } else {
        _L___0: 
        if (! (txnp->last_lsn.file == 0U)) {
          goto _L;
        } else {
          if ((unsigned int )txnp->logs.stqh_first != (unsigned int )((void *)0)) {
            _L: 
            if ((unsigned int )txnp->parent == (unsigned int )((void *)0)) {
              ret = __txn_doevents(dbenv___0, txnp, 2, 1);
              if (ret != 0) {
                goto err;
              }
              memset((void *)(& request), 0, sizeof(request));
              if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
                request.op = (enum __anonenum_db_lockop_t_51 )7;
                if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
                  if (((DB_REP *)dbenv___0->rep_handle)->region) {
                    if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 8U) {
                      if (! (txnp->last_lsn.file == 0U)) {
                        memset((void *)(& list_dbt), 0, sizeof(list_dbt));
                        request.obj = & list_dbt;
                      }
                    }
                  }
                }
                ret = __lock_vec(dbenv___0, txnp->txnid, 0U, & request, 1, (DB_LOCKREQ **)((void *)0));
              }
              if (ret == 0) {
                if (! (txnp->last_lsn.file == 0U)) {
                  while (1) {
                    lflags = 36U;
                    if (txnp->flags & 256U) {
                      lflags |= 1U;
                    } else {
                      if (! (txnp->flags & 32U)) {
                        if (! (dbenv___0->flags & 4194304U)) {
                          if (dbenv___0->flags & 16777216U) {
                            lflags |= 64U;
                          } else {
                            lflags |= 1U;
                          }
                        }
                      }
                    }
                    break;
                  }
                  tmp___3 = (int32_t )time((time_t *)((void *)0));
                  ret = __txn_regop_log(dbenv___0, txnp, & txnp->last_lsn, lflags,
                                        1U, tmp___3, (DBT const   *)request.obj);
                }
              }
              if ((unsigned int )request.obj != (unsigned int )((void *)0)) {
                if ((unsigned int )(request.obj)->data != (unsigned int )((void *)0)) {
                  __os_free(dbenv___0, (request.obj)->data);
                }
              }
              if (ret != 0) {
                goto err;
              }
            } else {
              if (! (txnp->last_lsn.file == 0U)) {
                ret = __txn_child_log(dbenv___0, txnp->parent, & (txnp->parent)->last_lsn,
                                      0U, txnp->txnid, & txnp->last_lsn);
                if (ret != 0) {
                  goto err;
                }
              }
              if ((unsigned int )txnp->logs.stqh_first != (unsigned int )((void *)0)) {
                while (1) {
                  if (! ((unsigned int )(txnp->parent)->logs.stqh_first == (unsigned int )((void *)0))) {
                    (*(txnp->logs.stqh_last)) = (txnp->parent)->logs.stqh_first;
                    txnp->logs.stqh_last = (txnp->parent)->logs.stqh_last;
                    while (1) {
                      (txnp->parent)->logs.stqh_first = (struct __txn_logrec *)((void *)0);
                      (txnp->parent)->logs.stqh_last = & (txnp->parent)->logs.stqh_first;
                      break;
                    }
                  }
                  break;
                }
                (txnp->parent)->logs = txnp->logs;
                while (1) {
                  txnp->logs.stqh_first = (struct __txn_logrec *)((void *)0);
                  txnp->logs.stqh_last = & txnp->logs.stqh_first;
                  break;
                }
              }
              (txnp->parent)->flags = (txnp->parent)->flags | 1U;
            }
          }
        }
      }
    }
  }
  if ((unsigned int )txnp->txn_list != (unsigned int )((void *)0)) {
    t_ret = __db_do_the_limbo(dbenv___0, (DB_TXN *)((void *)0), txnp, (DB_TXNHEAD *)txnp->txn_list,
                              (enum __anonenum_db_limbo_state_68 )0);
    __db_txnlist_end(dbenv___0, txnp->txn_list);
    txnp->txn_list = (void *)0;
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if (ret != 0) {
    goto err;
  }
  tmp___4 = __txn_end(txnp, 1);
  return (tmp___4);
  err: 
  if (td->status == 3U) {
    tmp___5 = __db_panic(dbenv___0, ret);
    return (tmp___5);
  }
  t_ret = __txn_abort(txnp);
  if (t_ret != 0) {
    ret = t_ret;
  }
  return (ret);
}
}
static int __txn_abort_pp(DB_TXN *txnp ) 
{ DB_ENV *dbenv___0 ;
  int not_child ;
  int ret ;

  {
  dbenv___0 = (txnp->mgrp)->dbenv;
  not_child = (unsigned int )txnp->parent == (unsigned int )((void *)0);
  ret = __txn_abort(txnp);
  if (not_child) {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
        goto _L;
      }
    } else {
      _L: 
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
          if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
            __op_rep_exit(dbenv___0);
          }
        }
      }
    }
  }
  return (ret);
}
}
int __txn_abort(DB_TXN *txnp ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKREQ request ;
  DB_TXN *kid ;
  TXN_DETAIL *td ;
  u_int32_t lflags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int32_t tmp___7 ;
  int tmp___8 ;

  {
  dbenv___0 = (txnp->mgrp)->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __txn_isvalid((DB_TXN const   *)txnp, & td, (enum __anonenum_txnop_t_90 )0);
  if (ret != 0) {
    tmp___0 = __db_panic(dbenv___0, ret);
    return (tmp___0);
  }
  while (1) {
    kid = txnp->kids.tqh_first;
    if (! ((unsigned int )kid != (unsigned int )((void *)0))) {
      break;
    }
    ret = __txn_abort(kid);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    ret = __txn_doevents(dbenv___0, txnp, 3, 1);
    if (ret != 0) {
      tmp___1 = __db_panic(dbenv___0, ret);
      return (tmp___1);
    }
    ret = __lock_set_timeout(dbenv___0, txnp->txnid, 0U, 33U);
    if (ret != 0) {
      tmp___2 = __db_panic(dbenv___0, ret);
      return (tmp___2);
    }
    ret = __lock_set_timeout(dbenv___0, txnp->txnid, 0U, 29U);
    if (ret != 0) {
      tmp___3 = __db_panic(dbenv___0, ret);
      return (tmp___3);
    }
    request.op = (enum __anonenum_db_lockop_t_51 )10;
    request.obj = (DBT *)((void *)0);
    ret = __lock_vec(dbenv___0, txnp->txnid, 0U, & request, 1, (DB_LOCKREQ **)((void *)0));
    if (ret != 0) {
      tmp___4 = __db_panic(dbenv___0, ret);
      return (tmp___4);
    }
  }
  ret = __txn_undo(txnp);
  if (ret != 0) {
    tmp___5 = __db_panic(dbenv___0, ret);
    return (tmp___5);
  }
  while (1) {
    lflags = 36U;
    if (txnp->flags & 256U) {
      lflags |= 1U;
    } else {
      if (! (txnp->flags & 32U)) {
        if (! (dbenv___0->flags & 4194304U)) {
          if (dbenv___0->flags & 16777216U) {
            lflags |= 64U;
          } else {
            lflags |= 1U;
          }
        }
      }
    }
    break;
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        if (td->status == 3U) {
          tmp___7 = (int32_t )time((time_t *)((void *)0));
          ret = __txn_regop_log(dbenv___0, txnp, & txnp->last_lsn, lflags, 3U, tmp___7,
                                (DBT const   *)((void *)0));
          if (ret != 0) {
            tmp___6 = __db_panic(dbenv___0, ret);
            return (tmp___6);
          }
        }
      }
    }
  }
  tmp___8 = __txn_end(txnp, 0);
  return (tmp___8);
}
}
static int __txn_discard_pp(DB_TXN *txnp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  int not_child ;
  int ret ;

  {
  dbenv___0 = (txnp->mgrp)->dbenv;
  not_child = (unsigned int )txnp->parent == (unsigned int )((void *)0);
  ret = __txn_discard(txnp, flags);
  if (not_child) {
    if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
      if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
        goto _L;
      }
    } else {
      _L: 
      if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
        if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
          if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
            __op_rep_exit(dbenv___0);
          }
        }
      }
    }
  }
  return (ret);
}
}
int __txn_discard(DB_TXN *txnp , u_int32_t flags ) 
{ DB_ENV *dbenv___0 ;
  DB_TXN *freep ;
  TXN_DETAIL *td ;
  int ret ;
  int tmp ;

  {
  flags = 0U;
  flags = flags;
  dbenv___0 = (txnp->mgrp)->dbenv;
  freep = (DB_TXN *)((void *)0);
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __txn_isvalid((DB_TXN const   *)txnp, & td, (enum __anonenum_txnop_t_90 )2);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )(txnp->mgrp)->mutexp != (unsigned int )((void *)0)) {
    if (! (((txnp->mgrp)->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, (txnp->mgrp)->mutexp);
    }
  }
  (txnp->mgrp)->n_discards = (txnp->mgrp)->n_discards + 1U;
  if (txnp->flags & 16U) {
    while (1) {
      if ((unsigned int )txnp->links.tqe_next != (unsigned int )((void *)0)) {
        (txnp->links.tqe_next)->links.tqe_prev = txnp->links.tqe_prev;
      } else {
        (txnp->mgrp)->txn_chain.tqh_last = txnp->links.tqe_prev;
      }
      (*(txnp->links.tqe_prev)) = txnp->links.tqe_next;
      break;
    }
    freep = txnp;
  }
  if ((unsigned int )(txnp->mgrp)->mutexp != (unsigned int )((void *)0)) {
    if (! (((txnp->mgrp)->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, (txnp->mgrp)->mutexp);
    }
  }
  if ((unsigned int )freep != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)freep);
  }
  return (0);
}
}
int __txn_prepare(DB_TXN *txnp , u_int8_t *gid ) 
{ DBT list_dbt ;
  DBT xid ;
  DB_ENV *dbenv___0 ;
  DB_LOCKREQ request ;
  DB_TXN *kid ;
  TXN_DETAIL *td ;
  u_int32_t lflags ;
  int ret ;
  int tmp ;
  char *tmp___0 ;

  {
  dbenv___0 = (txnp->mgrp)->dbenv;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  ret = __txn_isvalid((DB_TXN const   *)txnp, & td, (enum __anonenum_txnop_t_90 )3);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    kid = txnp->kids.tqh_first;
    if (! ((unsigned int )kid != (unsigned int )((void *)0))) {
      break;
    }
    ret = __txn_commit(kid, 256U);
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )txnp->txn_list != (unsigned int )((void *)0)) {
    ret = __db_do_the_limbo(dbenv___0, (DB_TXN *)((void *)0), txnp, (DB_TXNHEAD *)txnp->txn_list,
                            (enum __anonenum_db_limbo_state_68 )1);
    if (ret != 0) {
      return (ret);
    }
  }
  ret = __txn_doevents(dbenv___0, txnp, 2, 1);
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& request), 0, sizeof(request));
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    request.op = (enum __anonenum_db_lockop_t_51 )7;
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 8U) {
          if (txnp->last_lsn.file == 0U) {
            memset((void *)(& list_dbt), 0, sizeof(list_dbt));
            request.obj = & list_dbt;
          }
        }
      }
    }
    ret = __lock_vec(dbenv___0, txnp->txnid, 0U, & request, 1, (DB_LOCKREQ **)((void *)0));
    if (ret != 0) {
      return (ret);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if (! ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U)) {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (! (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U)) {
          goto _L;
        }
      } else {
        _L: 
        memset((void *)(& xid), 0, sizeof(xid));
        if (td->xa_status != 3U) {
          if (td->xa_status != 6U) {
            memcpy((void * __restrict  )(td->xid), (void const   * __restrict  )gid,
                   sizeof(td->xid));
          }
        }
        xid.size = sizeof(td->xid);
        xid.data = (void *)(td->xid);
        lflags = 37U;
        ret = __txn_xa_regop_log(dbenv___0, txnp, & txnp->last_lsn, lflags, 2U, (DBT const   *)(& xid),
                                 td->format, td->gtrid, td->bqual, & td->begin_lsn,
                                 (DBT const   *)request.obj);
        if (ret != 0) {
          tmp___0 = db_strerror(ret);
          __db_err((DB_ENV const   *)dbenv___0, "DB_TXN->prepare: log_write failed %s",
                   tmp___0);
        }
        if ((unsigned int )request.obj != (unsigned int )((void *)0)) {
          if ((unsigned int )(request.obj)->data != (unsigned int )((void *)0)) {
            __os_free(dbenv___0, (request.obj)->data);
          }
        }
        if (ret != 0) {
          return (ret);
        }
      }
    }
  }
  if ((unsigned int )(txnp->mgrp)->mutexp != (unsigned int )((void *)0)) {
    if (! (((txnp->mgrp)->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, (txnp->mgrp)->mutexp);
    }
  }
  td->status = 3U;
  if ((unsigned int )(txnp->mgrp)->mutexp != (unsigned int )((void *)0)) {
    if (! (((txnp->mgrp)->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, (txnp->mgrp)->mutexp);
    }
  }
  return (0);
}
}
u_int32_t __txn_id(DB_TXN *txnp ) 
{ 

  {
  return (txnp->txnid);
}
}
int __txn_set_timeout(DB_TXN *txnp , db_timeout_t timeout , u_int32_t op ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (op != 33U) {
    if (op != 29U) {
      tmp = __db_ferr((DB_ENV const   *)(txnp->mgrp)->dbenv, "DB_TXN->set_timeout",
                      0);
      return (tmp);
    }
  }
  tmp___0 = __lock_set_timeout((txnp->mgrp)->dbenv, txnp->txnid, timeout, op);
  return (tmp___0);
}
}
static int __txn_isvalid(DB_TXN const   *txnp , TXN_DETAIL **tdp , txnop_t op ) 
{ DB_TXNMGR *mgrp ;
  DB_TXNREGION *region ;
  TXN_DETAIL *tp ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  mgrp = txnp->mgrp;
  region = (DB_TXNREGION *)mgrp->reginfo.primary;
  if (! (txnp->flags & 2U)) {
    if (region->flags & 1U) {
      __db_err((DB_ENV const   *)mgrp->dbenv, "operation not permitted during recovery");
      goto err;
    }
  }
  if (txnp->cursors != 0U) {
    __db_err((DB_ENV const   *)mgrp->dbenv, "transaction has active cursors");
    goto err;
  }
  tp = (TXN_DETAIL *)((void *)((u_int8_t *)mgrp->reginfo.addr + txnp->off));
  if ((unsigned int )tdp != (unsigned int )((void *)0)) {
    (*tdp) = tp;
  }
  switch ((int )op) {
  case 2: ;
  if (txnp->txnid != tp->txnid) {
    return (0);
  }
  if (tp->status != 3U) {
    if (! (tp->flags & 2U)) {
      __db_err((DB_ENV const   *)mgrp->dbenv, "not a restored transaction");
      tmp = __db_panic(mgrp->dbenv, 22);
      return (tmp);
    }
  }
  return (0);
  case 3: ;
  if ((unsigned int )txnp->parent != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)mgrp->dbenv, "Prepare disallowed on child transactions");
    return (22);
  }
  break;
  case 0: ;
  case 1: ;
  default: ;
  break;
  }
  switch ((int )tp->status) {
  case 3: ;
  if ((int )op == 3) {
    __db_err((DB_ENV const   *)mgrp->dbenv, "transaction already prepared");
    return (22);
  }
  break;
  case 1: ;
  break;
  case 2: ;
  case 4: ;
  default: ;
  if (tp->status == 4U) {
    tmp___0 = "committed";
  } else {
    tmp___0 = "aborted";
  }
  __db_err((DB_ENV const   *)mgrp->dbenv, "transaction already %s", tmp___0);
  goto err;
  }
  return (0);
  err: 
  tmp___1 = __db_panic(mgrp->dbenv, 22);
  return (tmp___1);
}
}
static int __txn_end(DB_TXN *txnp , int is_commit ) 
{ DB_ENV *dbenv___0 ;
  DB_LOCKREQ request ;
  DB_TXNLOGREC *lr ;
  DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  TXN_DETAIL *tp ;
  int do_closefiles ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct __txn_logrec *curelm ;

  {
  mgr = txnp->mgrp;
  dbenv___0 = mgr->dbenv;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  do_closefiles = 0;
  if (is_commit) {
    tmp___0 = 1;
  } else {
    tmp___0 = 3;
  }
  ret = __txn_doevents(dbenv___0, txnp, tmp___0, 0);
  if (ret != 0) {
    tmp = __db_panic(dbenv___0, ret);
    return (tmp);
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )txnp->parent == (unsigned int )((void *)0)) {
      request.op = (enum __anonenum_db_lockop_t_51 )5;
    } else {
      if (is_commit == 0) {
        request.op = (enum __anonenum_db_lockop_t_51 )5;
      } else {
        request.op = (enum __anonenum_db_lockop_t_51 )3;
      }
    }
    request.obj = (DBT *)((void *)0);
    ret = __lock_vec(dbenv___0, txnp->txnid, 0U, & request, 1, (DB_LOCKREQ **)((void *)0));
    if (ret != 0) {
      tmp___1 = __db_panic(dbenv___0, ret);
      return (tmp___1);
    }
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  tp = (TXN_DETAIL *)((void *)((u_int8_t *)mgr->reginfo.addr + txnp->off));
  while (1) {
    if (tp->links.stqe_next != -1) {
      ((struct __txn_detail *)((u_int8_t *)tp + tp->links.stqe_next))->links.stqe_prev = tp->links.stqe_prev +
                                                                                         ((u_int8_t *)tp -
                                                                                          (u_int8_t *)((struct __txn_detail *)((u_int8_t *)tp +
                                                                                                                               tp->links.stqe_next)));
      (*((ssize_t *)((u_int8_t *)tp + tp->links.stqe_prev))) = (*((ssize_t *)((u_int8_t *)tp +
                                                                              tp->links.stqe_prev))) +
                                                               tp->links.stqe_next;
    } else {
      region->active_txn.stqh_last = tp->links.stqe_prev + ((u_int8_t *)tp - (u_int8_t *)(& region->active_txn));
      (*((ssize_t *)((u_int8_t *)tp + tp->links.stqe_prev))) = -1;
    }
    break;
  }
  if (tp->flags & 2U) {
    region->stat.st_nrestores = region->stat.st_nrestores - 1U;
    do_closefiles = region->stat.st_nrestores == 0U;
  }
  __db_shalloc_free(mgr->reginfo.addr, (void *)tp);
  if (is_commit) {
    region->stat.st_ncommits = region->stat.st_ncommits + 1U;
  } else {
    region->stat.st_naborts = region->stat.st_naborts + 1U;
  }
  region->stat.st_nactive = region->stat.st_nactive - 1U;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0)) {
    ret = __lock_freefamilylocker((DB_LOCKTAB *)dbenv___0->lk_handle, txnp->txnid);
    if (ret != 0) {
      tmp___2 = __db_panic(dbenv___0, ret);
      return (tmp___2);
    }
  }
  if ((unsigned int )txnp->parent != (unsigned int )((void *)0)) {
    while (1) {
      if ((unsigned int )txnp->klinks.tqe_next != (unsigned int )((void *)0)) {
        (txnp->klinks.tqe_next)->klinks.tqe_prev = txnp->klinks.tqe_prev;
      } else {
        (txnp->parent)->kids.tqh_last = txnp->klinks.tqe_prev;
      }
      (*(txnp->klinks.tqe_prev)) = txnp->klinks.tqe_next;
      break;
    }
  }
  while (1) {
    lr = txnp->logs.stqh_first;
    if (! ((unsigned int )lr != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      if ((unsigned int )txnp->logs.stqh_first == (unsigned int )lr) {
        while (1) {
          txnp->logs.stqh_first = (txnp->logs.stqh_first)->links.stqe_next;
          if ((unsigned int )txnp->logs.stqh_first == (unsigned int )((void *)0)) {
            txnp->logs.stqh_last = & txnp->logs.stqh_first;
          }
          break;
        }
      } else {
        curelm = txnp->logs.stqh_first;
        while ((unsigned int )curelm->links.stqe_next != (unsigned int )lr) {
          curelm = curelm->links.stqe_next;
        }
        curelm->links.stqe_next = (curelm->links.stqe_next)->links.stqe_next;
        if ((unsigned int )curelm->links.stqe_next == (unsigned int )((void *)0)) {
          txnp->logs.stqh_last = & curelm->links.stqe_next;
        }
      }
      break;
    }
    __os_free(dbenv___0, (void *)lr);
  }
  if (txnp->flags & 16U) {
    if ((unsigned int )mgr->mutexp != (unsigned int )((void *)0)) {
      if (! ((mgr->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, mgr->mutexp);
      }
    }
    while (1) {
      if ((unsigned int )txnp->links.tqe_next != (unsigned int )((void *)0)) {
        (txnp->links.tqe_next)->links.tqe_prev = txnp->links.tqe_prev;
      } else {
        mgr->txn_chain.tqh_last = txnp->links.tqe_prev;
      }
      (*(txnp->links.tqe_prev)) = txnp->links.tqe_next;
      break;
    }
    if ((unsigned int )mgr->mutexp != (unsigned int )((void *)0)) {
      if (! ((mgr->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, mgr->mutexp);
      }
    }
    __os_free(dbenv___0, (void *)txnp);
  }
  if (do_closefiles) {
    ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags |
                                              1U;
    __dbreg_close_files(dbenv___0);
    ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags &
                                              4294967294U;
    mgr->n_discards = 0U;
    __txn_checkpoint(dbenv___0, 0U, 0U, 4U);
  }
  return (0);
}
}
static int __txn_dispatch_undo(DB_ENV *dbenv___0 , DB_TXN *txnp , DBT *rdbt , DB_LSN *key_lsn ,
                               void *txnlist ) 
{ int ret ;

  {
  ret = __db_dispatch(dbenv___0, dbenv___0->recover_dtab, dbenv___0->recover_dtab_size,
                      rdbt, key_lsn, (enum __anonenum_db_recops_55 )0, txnlist);
  if (txnp->flags & 1U) {
    __db_txnlist_lsnadd(dbenv___0, txnlist, key_lsn, 0U);
  }
  if (ret == -30895) {
    ret = __db_txnlist_lsninit(dbenv___0, (DB_TXNHEAD *)txnlist, key_lsn);
    if (ret == 0) {
      txnp->flags = txnp->flags | 1U;
    }
  }
  return (ret);
}
}
static int __txn_undo(DB_TXN *txnp ) 
{ DBT rdbt ;
  DB_ENV *dbenv___0 ;
  DB_LOGC *logc ;
  DB_LSN key_lsn ;
  DB_TXN *ptxn ;
  DB_TXNLOGREC *lr ;
  DB_TXNMGR *mgr ;
  int ret ;
  int t_ret ;
  void *txnlist ;
  char *tmp ;
  char *tmp___0 ;

  {
  mgr = txnp->mgrp;
  dbenv___0 = mgr->dbenv;
  logc = (DB_LOGC *)((void *)0);
  txnlist = (void *)0;
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if (((DB_REP *)dbenv___0->rep_handle)->region) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
          return (0);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
        if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
          return (0);
        }
      }
    }
  } else {
    return (0);
  }
  memset((void *)(& rdbt), 0, sizeof(rdbt));
  ptxn = txnp->parent;
  while (1) {
    if ((unsigned int )ptxn != (unsigned int )((void *)0)) {
      if (! ((unsigned int )ptxn->parent != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    ptxn = ptxn->parent;
  }
  if ((unsigned int )ptxn != (unsigned int )((void *)0)) {
    if ((unsigned int )ptxn->txn_list != (unsigned int )((void *)0)) {
      txnlist = ptxn->txn_list;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    if ((unsigned int )txnp->txn_list != (unsigned int )((void *)0)) {
      txnlist = txnp->txn_list;
    } else {
      ret = __db_txnlist_init(dbenv___0, 0U, 0U, (DB_LSN *)((void *)0), (void *)(& txnlist));
      if (ret != 0) {
        return (ret);
      } else {
        if ((unsigned int )ptxn != (unsigned int )((void *)0)) {
          ptxn->txn_list = txnlist;
        }
      }
    }
  }
  if (txnp->flags & 1U) {
    ret = __db_txnlist_lsninit(dbenv___0, (DB_TXNHEAD *)txnlist, & txnp->last_lsn);
    if (ret != 0) {
      return (ret);
    }
  }
  lr = txnp->logs.stqh_first;
  while ((unsigned int )lr != (unsigned int )((void *)0)) {
    rdbt.data = (void *)(lr->data);
    rdbt.size = 0U;
    while (1) {
      key_lsn.file = 0U;
      key_lsn.offset = 1U;
      break;
    }
    ret = __txn_dispatch_undo(dbenv___0, txnp, & rdbt, & key_lsn, txnlist);
    if (ret != 0) {
      tmp = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "DB_TXN->abort: In-memory log undo failed: %s",
               tmp);
      goto err;
    }
    lr = lr->links.stqe_next;
  }
  key_lsn = txnp->last_lsn;
  if (! (key_lsn.file == 0U)) {
    ret = __log_cursor(dbenv___0, & logc);
    if (ret != 0) {
      goto err;
    }
  }
  while (! (key_lsn.file == 0U)) {
    ret = __log_c_get(logc, & key_lsn, & rdbt, 28U);
    if (ret == 0) {
      ret = __txn_dispatch_undo(dbenv___0, txnp, & rdbt, & key_lsn, txnlist);
    }
    if (ret != 0) {
      tmp___0 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "DB_TXN->abort: Log undo failed for LSN: %lu %lu: %s",
               (unsigned long )key_lsn.file, (unsigned long )key_lsn.offset, tmp___0);
      goto err;
    }
  }
  ret = __db_do_the_limbo(dbenv___0, ptxn, txnp, (DB_TXNHEAD *)txnlist, (enum __anonenum_db_limbo_state_68 )0);
  err: 
  if ((unsigned int )logc != (unsigned int )((void *)0)) {
    t_ret = __log_c_close(logc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )ptxn == (unsigned int )((void *)0)) {
    if ((unsigned int )txnlist != (unsigned int )((void *)0)) {
      __db_txnlist_end(dbenv___0, txnlist);
    }
  }
  return (ret);
}
}
int __txn_checkpoint_pp(DB_ENV *dbenv___0 , u_int32_t kbytes , u_int32_t minutes ,
                        u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"txn_checkpoint", 131072U);
    return (tmp___0);
  }
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    if (((DB_REP *)dbenv___0->rep_handle)->region) {
      if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
        return (0);
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __txn_checkpoint(dbenv___0, kbytes, minutes, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __txn_checkpoint(DB_ENV *dbenv___0 , u_int32_t kbytes , u_int32_t minutes , u_int32_t flags ) 
{ DB_LSN ckp_lsn ;
  DB_LSN last_ckp ;
  DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  TXN_DETAIL *txnp ;
  time_t last_ckp_time ;
  time_t now ;
  u_int32_t bytes ;
  u_int32_t gen ;
  u_int32_t mbytes ;
  int ret ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int32_t tmp___3 ;

  {
  gen = 0U;
  ret = (int )gen;
  if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
    if (((DB_REP *)dbenv___0->rep_handle)->region) {
      if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags & 516U) {
        if ((unsigned int )dbenv___0->mp_handle != (unsigned int )((void *)0)) {
          ret = __memp_sync(dbenv___0, (DB_LSN *)((void *)0));
          if (ret != 0) {
            tmp = db_strerror(ret);
            __db_err((DB_ENV const   *)dbenv___0, "txn_checkpoint: failed to flush the buffer cache %s",
                     tmp);
            return (ret);
          } else {
            return (0);
          }
        } else {
          return (0);
        }
      }
    }
  }
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  __log_txn_lsn(dbenv___0, & ckp_lsn, & mbytes, & bytes);
  if (! (flags & 4U)) {
    if (bytes == 0U) {
      if (mbytes == 0U) {
        return (0);
      }
    }
    if (kbytes != 0U) {
      if (mbytes * 1024U + bytes / 1024U >= kbytes) {
        goto do_ckp;
      }
    }
    if (minutes != 0U) {
      time(& now);
      if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
      }
      last_ckp_time = region->time_ckp;
      if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
      }
      if (now - last_ckp_time >= (long )(minutes * 60U)) {
        goto do_ckp;
      }
    }
    if (minutes != 0U) {
      return (0);
    } else {
      if (kbytes != 0U) {
        return (0);
      }
    }
  }
  do_ckp: 
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (region->active_txn.stqh_first == -1) {
    txnp = (TXN_DETAIL *)((void *)0);
  } else {
    txnp = (struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first);
  }
  while ((unsigned int )txnp != (unsigned int )((void *)0)) {
    if (! (txnp->begin_lsn.file == 0U)) {
      tmp___0 = log_compare((DB_LSN const   *)(& txnp->begin_lsn), (DB_LSN const   *)(& ckp_lsn));
      if (tmp___0 < 0) {
        ckp_lsn = txnp->begin_lsn;
      }
    }
    if (txnp->links.stqe_next == -1) {
      txnp = (TXN_DETAIL *)((void *)0);
    } else {
      txnp = (struct __txn_detail *)((u_int8_t *)txnp + txnp->links.stqe_next);
    }
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if ((unsigned int )dbenv___0->mp_handle != (unsigned int )((void *)0)) {
    ret = __memp_sync(dbenv___0, (DB_LSN *)((void *)0));
    if (ret != 0) {
      tmp___1 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "txn_checkpoint: failed to flush the buffer cache %s",
               tmp___1);
      return (ret);
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
    }
    last_ckp = region->last_ckp;
    if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
    }
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      __rep_get_gen(dbenv___0, & gen);
    }
    ret = __dbreg_open_files(dbenv___0);
    if (ret != 0) {
      tmp___2 = db_strerror(ret);
      __db_err((DB_ENV const   *)dbenv___0, "txn_checkpoint: log failed at LSN [%ld %ld] %s",
               (long )ckp_lsn.file, (long )ckp_lsn.offset, tmp___2);
      return (ret);
    } else {
      tmp___3 = (int32_t )time((time_t *)((void *)0));
      ret = __txn_ckp_log(dbenv___0, (DB_TXN *)((void *)0), & ckp_lsn, 35U, & ckp_lsn,
                          & last_ckp, tmp___3, gen);
      if (ret != 0) {
        tmp___2 = db_strerror(ret);
        __db_err((DB_ENV const   *)dbenv___0, "txn_checkpoint: log failed at LSN [%ld %ld] %s",
                 (long )ckp_lsn.file, (long )ckp_lsn.offset, tmp___2);
        return (ret);
      }
    }
    __txn_updateckp(dbenv___0, & ckp_lsn);
  }
  return (ret);
}
}
int __txn_getckp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) 
{ DB_LSN lsn ;
  DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;

  {
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  lsn = region->last_ckp;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (lsn.file == 0U) {
    return (-30990);
  }
  (*lsnp) = lsn;
  return (0);
}
}
int __txn_activekids(DB_ENV *dbenv___0 , u_int32_t rectype , DB_TXN *txnp ) 
{ 

  {
  if (txnp->flags & 2U) {
    return (0);
  } else {
    if (rectype == 12U) {
      return (0);
    }
  }
  if ((unsigned int )txnp->kids.tqh_first != (unsigned int )((void *)0)) {
    __db_err((DB_ENV const   *)dbenv___0, "Child transaction is active");
    return (1);
  }
  return (0);
}
}
int __txn_force_abort(DB_ENV *dbenv___0 , u_int8_t *buffer ) 
{ DB_CIPHER *db_cipher ;
  HDR *hdr ;
  u_int32_t hdrlen ;
  u_int32_t offset ;
  u_int32_t opcode ;
  u_int32_t rec_len ;
  u_int32_t sum_len ;
  u_int8_t *bp ;
  u_int8_t *key ;
  u_int8_t chksum[20] ;
  size_t hdrsize ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  db_cipher = (DB_CIPHER *)dbenv___0->crypto_handle;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    hdrsize = 48U;
  } else {
    hdrsize = 12U;
  }
  hdr = (HDR *)buffer;
  memcpy((void * __restrict  )(& hdrlen), (void const   * __restrict  )(buffer + (int )((unsigned short )((unsigned int )(& ((HDR *)0)->len)))),
         sizeof(hdr->len));
  rec_len = hdrlen - hdrsize;
  offset = (sizeof(u_int32_t ) + sizeof(u_int32_t )) + sizeof(DB_LSN );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    key = db_cipher->mac_key;
    sum_len = 20U;
    ret = ((*(db_cipher->decrypt)))(dbenv___0, db_cipher->data, (void *)(& hdr->iv[0]),
                                    buffer + hdrsize, rec_len);
    if (ret != 0) {
      tmp = __db_panic(dbenv___0, ret);
      return (tmp);
    }
  } else {
    key = (u_int8_t *)((void *)0);
    sum_len = sizeof(u_int32_t );
  }
  bp = (buffer + hdrsize) + offset;
  opcode = 3U;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& opcode), sizeof(opcode));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    ret = ((*(db_cipher->encrypt)))(dbenv___0, db_cipher->data, (void *)(& hdr->iv[0]),
                                    buffer + hdrsize, rec_len);
    if (ret != 0) {
      tmp___0 = __db_panic(dbenv___0, ret);
      return (tmp___0);
    }
  }
  __db_chksum(buffer + hdrsize, rec_len, key, chksum);
  memcpy((void * __restrict  )(buffer + (int )((unsigned short )((unsigned int )(& ((HDR *)0)->chksum)))),
         (void const   * __restrict  )(& chksum), sum_len);
  return (0);
}
}
int __txn_preclose(DB_ENV *dbenv___0 ) 
{ DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  int do_closefiles ;
  int ret ;

  {
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  do_closefiles = 0;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if ((unsigned int )region != (unsigned int )((void *)0)) {
    if (region->stat.st_nrestores <= mgr->n_discards) {
      if (mgr->n_discards != 0U) {
        do_closefiles = 1;
      }
    }
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (do_closefiles) {
    ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags |
                                              1U;
    ret = __dbreg_close_files(dbenv___0);
    ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags &
                                              4294967294U;
  } else {
    ret = 0;
  }
  return (ret);
}
}
int __txn_reset(DB_ENV *dbenv___0 ) 
{ DB_LSN scrap ;
  DB_TXNREGION *region ;
  int tmp ;

  {
  region = (DB_TXNREGION *)((DB_TXNMGR *)dbenv___0->tx_handle)->reginfo.primary;
  region->last_txnid = 2147483648U;
  tmp = __txn_recycle_log(dbenv___0, (DB_TXN *)((void *)0), & scrap, 0U, 2147483648U,
                          4294967295U);
  return (tmp);
}
}
void __txn_updateckp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) 
{ DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  int tmp ;

  {
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  tmp = log_compare((DB_LSN const   *)(& region->last_ckp), (DB_LSN const   *)lsnp);
  if (tmp < 0) {
    region->last_ckp = (*lsnp);
    time(& region->time_ckp);
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-NYO49L2m.i","-O2")
int __txn_regop_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __txn_regop_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __txn_ckp_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) ;
int __txn_ckp_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) ;
int __txn_child_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) ;
int __txn_child_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) ;
int __txn_xa_regop_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                            void *summary ) ;
int __txn_xa_regop_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                         void *notused3 ) ;
int __txn_recycle_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) ;
int __txn_recycle_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) ;
int __txn_recycle_read(DB_ENV *dbenv___0 , void *recbuf , __txn_recycle_args **argpp ) ;
int __txn_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) ;
int __txn_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) ;
int __txn_regop_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __txn_xa_regop_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                           void *info ) ;
int __txn_ckp_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) ;
int __txn_child_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) ;
int __txn_recycle_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) ;
int __txn_regop_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t opcode , int32_t timestamp , DBT const   *locks ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;

  {
  rectype = 10U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )locks == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = locks->size;
  }
  logrec.size = (((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                  sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = (unsigned int )timestamp;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )locks == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& locks->size),
           sizeof(locks->size));
    bp += sizeof(locks->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )locks->data, locks->size);
    bp += locks->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __txn_regop_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __txn_regop_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __txn_regop_args *argp ;
  struct tm *lt ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __txn_regop_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__txn_regop%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  lt = localtime((time_t const   *)((time_t *)(& argp->timestamp)));
  tmp___0 = ctime((time_t const   *)((time_t *)(& argp->timestamp)));
  printf((char const   * __restrict  )"\ttimestamp: %ld (%.24s, 20%02lu%02lu%02lu%02lu%02lu.%02lu)\n",
         (long )argp->timestamp, tmp___0, (unsigned long )lt->tm_year - 100UL, (unsigned long )lt->tm_mon +
                                                                               1UL,
         (unsigned long )lt->tm_mday, (unsigned long )lt->tm_hour, (unsigned long )lt->tm_min,
         (unsigned long )lt->tm_sec);
  printf((char const   * __restrict  )"\tlocks: ");
  i = 0U;
  while (i < argp->locks.size) {
    ch = (int )(*((u_int8_t *)argp->locks.data + i));
    tmp___3 = __ctype_b_loc();
    if ((int const   )(*((*tmp___3) + ch)) & 16384) {
      tmp___2 = "%c";
    } else {
      if (ch == 10) {
        tmp___2 = "%c";
      } else {
        tmp___2 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___2, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __txn_regop_read(DB_ENV *dbenv___0 , void *recbuf , __txn_regop_args **argpp ) 
{ __txn_regop_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__txn_regop_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->timestamp = (int )uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->locks), 0, sizeof(argp->locks));
  memcpy((void * __restrict  )(& argp->locks.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->locks.data = (void *)bp;
  bp += argp->locks.size;
  (*argpp) = argp;
  return (0);
}
}
int __txn_ckp_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                  DB_LSN *ckp_lsn , DB_LSN *last_ckp , int32_t timestamp , u_int32_t rep_gen ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  rectype = 11U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof((*ckp_lsn))) +
                  sizeof((*last_ckp))) + sizeof(u_int32_t )) + sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  if ((unsigned int )ckp_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )ckp_lsn, sizeof((*ckp_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*ckp_lsn)));
  }
  bp += sizeof((*ckp_lsn));
  if ((unsigned int )last_ckp != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )last_ckp, sizeof((*last_ckp)));
  } else {
    memset((void *)bp, 0, sizeof((*last_ckp)));
  }
  bp += sizeof((*last_ckp));
  uinttmp = (unsigned int )timestamp;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = rep_gen;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __txn_ckp_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                       void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __txn_ckp_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                    void *notused3 ) 
{ __txn_ckp_args *argp ;
  struct tm *lt ;
  int ret ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __txn_ckp_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__txn_ckp%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tckp_lsn: [%lu][%lu]\n", (unsigned long )argp->ckp_lsn.file,
         (unsigned long )argp->ckp_lsn.offset);
  printf((char const   * __restrict  )"\tlast_ckp: [%lu][%lu]\n", (unsigned long )argp->last_ckp.file,
         (unsigned long )argp->last_ckp.offset);
  lt = localtime((time_t const   *)((time_t *)(& argp->timestamp)));
  tmp___0 = ctime((time_t const   *)((time_t *)(& argp->timestamp)));
  printf((char const   * __restrict  )"\ttimestamp: %ld (%.24s, 20%02lu%02lu%02lu%02lu%02lu.%02lu)\n",
         (long )argp->timestamp, tmp___0, (unsigned long )lt->tm_year - 100UL, (unsigned long )lt->tm_mon +
                                                                               1UL,
         (unsigned long )lt->tm_mday, (unsigned long )lt->tm_hour, (unsigned long )lt->tm_min,
         (unsigned long )lt->tm_sec);
  printf((char const   * __restrict  )"\trep_gen: %ld\n", (long )argp->rep_gen);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __txn_ckp_read(DB_ENV *dbenv___0 , void *recbuf , __txn_ckp_args **argpp ) 
{ __txn_ckp_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__txn_ckp_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& argp->ckp_lsn), (void const   * __restrict  )bp,
         sizeof(argp->ckp_lsn));
  bp += sizeof(argp->ckp_lsn);
  memcpy((void * __restrict  )(& argp->last_ckp), (void const   * __restrict  )bp,
         sizeof(argp->last_ckp));
  bp += sizeof(argp->last_ckp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->timestamp = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->rep_gen = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __txn_child_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                    u_int32_t child , DB_LSN *c_lsn ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  rectype = 12U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                sizeof((*c_lsn));
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = child;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )c_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )c_lsn, sizeof((*c_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*c_lsn)));
  }
  bp += sizeof((*c_lsn));
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __txn_child_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                         void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __txn_child_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                      void *notused3 ) 
{ __txn_child_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __txn_child_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__txn_child%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tchild: 0x%lx\n", (unsigned long )argp->child);
  printf((char const   * __restrict  )"\tc_lsn: [%lu][%lu]\n", (unsigned long )argp->c_lsn.file,
         (unsigned long )argp->c_lsn.offset);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __txn_child_read(DB_ENV *dbenv___0 , void *recbuf , __txn_child_args **argpp ) 
{ __txn_child_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__txn_child_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->child = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->c_lsn), (void const   * __restrict  )bp, sizeof(argp->c_lsn));
  bp += sizeof(argp->c_lsn);
  (*argpp) = argp;
  return (0);
}
}
int __txn_xa_regop_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                       u_int32_t opcode , DBT const   *xid , int32_t formatID , u_int32_t gtrid ,
                       u_int32_t bqual , DB_LSN *begin_lsn , DBT const   *locks ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t zero ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;
  u_int32_t tmp ;
  u_int32_t tmp___0 ;

  {
  rectype = 13U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  if ((unsigned int )xid == (unsigned int )((void *)0)) {
    tmp = 0U;
  } else {
    tmp = xid->size;
  }
  if ((unsigned int )locks == (unsigned int )((void *)0)) {
    tmp___0 = 0U;
  } else {
    tmp___0 = locks->size;
  }
  logrec.size = ((((((((((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) +
                        sizeof(u_int32_t )) + sizeof(u_int32_t )) + tmp) + sizeof(u_int32_t )) +
                    sizeof(u_int32_t )) + sizeof(u_int32_t )) + sizeof((*begin_lsn))) +
                 sizeof(u_int32_t )) + tmp___0;
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = opcode;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )xid == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& xid->size), sizeof(xid->size));
    bp += sizeof(xid->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )xid->data, xid->size);
    bp += xid->size;
  }
  uinttmp = (unsigned int )formatID;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = gtrid;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = bqual;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if ((unsigned int )begin_lsn != (unsigned int )((void *)0)) {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )begin_lsn, sizeof((*begin_lsn)));
  } else {
    memset((void *)bp, 0, sizeof((*begin_lsn)));
  }
  bp += sizeof((*begin_lsn));
  if ((unsigned int )locks == (unsigned int )((void *)0)) {
    zero = 0U;
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& zero), sizeof(u_int32_t ));
    bp += sizeof(u_int32_t );
  } else {
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(& locks->size),
           sizeof(locks->size));
    bp += sizeof(locks->size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )locks->data, locks->size);
    bp += locks->size;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __txn_xa_regop_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                            void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __txn_xa_regop_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                         void *notused3 ) 
{ __txn_xa_regop_args *argp ;
  u_int32_t i ;
  int ch ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __txn_xa_regop_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__txn_xa_regop%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\topcode: %lu\n", (unsigned long )argp->opcode);
  printf((char const   * __restrict  )"\txid: ");
  i = 0U;
  while (i < argp->xid.size) {
    ch = (int )(*((u_int8_t *)argp->xid.data + i));
    tmp___2 = __ctype_b_loc();
    if ((int const   )(*((*tmp___2) + ch)) & 16384) {
      tmp___1 = "%c";
    } else {
      if (ch == 10) {
        tmp___1 = "%c";
      } else {
        tmp___1 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___1, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\tformatID: %ld\n", (long )argp->formatID);
  printf((char const   * __restrict  )"\tgtrid: %u\n", argp->gtrid);
  printf((char const   * __restrict  )"\tbqual: %u\n", argp->bqual);
  printf((char const   * __restrict  )"\tbegin_lsn: [%lu][%lu]\n", (unsigned long )argp->begin_lsn.file,
         (unsigned long )argp->begin_lsn.offset);
  printf((char const   * __restrict  )"\tlocks: ");
  i = 0U;
  while (i < argp->locks.size) {
    ch = (int )(*((u_int8_t *)argp->locks.data + i));
    tmp___5 = __ctype_b_loc();
    if ((int const   )(*((*tmp___5) + ch)) & 16384) {
      tmp___4 = "%c";
    } else {
      if (ch == 10) {
        tmp___4 = "%c";
      } else {
        tmp___4 = "%#x ";
      }
    }
    printf((char const   * __restrict  )tmp___4, ch);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __txn_xa_regop_read(DB_ENV *dbenv___0 , void *recbuf , __txn_xa_regop_args **argpp ) 
{ __txn_xa_regop_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__txn_xa_regop_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->opcode = uinttmp;
  bp += sizeof(uinttmp);
  memset((void *)(& argp->xid), 0, sizeof(argp->xid));
  memcpy((void * __restrict  )(& argp->xid.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->xid.data = (void *)bp;
  bp += argp->xid.size;
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->formatID = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->gtrid = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->bqual = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->begin_lsn), (void const   * __restrict  )bp,
         sizeof(argp->begin_lsn));
  bp += sizeof(argp->begin_lsn);
  memset((void *)(& argp->locks), 0, sizeof(argp->locks));
  memcpy((void * __restrict  )(& argp->locks.size), (void const   * __restrict  )bp,
         sizeof(u_int32_t ));
  bp += sizeof(u_int32_t );
  argp->locks.data = (void *)bp;
  bp += argp->locks.size;
  (*argpp) = argp;
  return (0);
}
}
int __txn_recycle_log(DB_ENV *dbenv___0 , DB_TXN *txnid , DB_LSN *ret_lsnp , u_int32_t flags ,
                      u_int32_t min , u_int32_t max ) 
{ DBT logrec ;
  DB_TXNLOGREC *lr ;
  DB_LSN *lsnp ;
  DB_LSN null_lsn ;
  u_int32_t uinttmp ;
  u_int32_t rectype ;
  u_int32_t txn_num ;
  u_int npad ;
  u_int8_t *bp ;
  int is_durable ;
  int ret ;

  {
  rectype = 14U;
  npad = 0U;
  is_durable = 1;
  if (flags & 16U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 8388608U) {
      _L: 
      if ((unsigned int )txnid == (unsigned int )((void *)0)) {
        return (0);
      }
      is_durable = 0;
    }
  }
  if ((unsigned int )txnid == (unsigned int )((void *)0)) {
    txn_num = 0U;
    null_lsn.file = 0U;
    null_lsn.offset = 0U;
    lsnp = & null_lsn;
  } else {
    if ((unsigned int )txnid->kids.tqh_first != (unsigned int )((void *)0)) {
      ret = __txn_activekids(dbenv___0, rectype, txnid);
      if (ret != 0) {
        return (ret);
      }
    }
    txn_num = txnid->txnid;
    lsnp = & txnid->last_lsn;
  }
  logrec.size = (((sizeof(rectype) + sizeof(txn_num)) + sizeof(DB_LSN )) + sizeof(u_int32_t )) +
                sizeof(u_int32_t );
  if ((unsigned int )dbenv___0->crypto_handle != (unsigned int )((void *)0)) {
    npad = ((*(((DB_CIPHER *)dbenv___0->crypto_handle)->adj_size)))(logrec.size);
    logrec.size = logrec.size + npad;
  }
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = __os_malloc(dbenv___0, logrec.size + sizeof(DB_TXNLOGREC ), (void *)(& lr));
      if (ret != 0) {
        return (ret);
      }
      logrec.data = (void *)(& lr->data);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    ret = __os_malloc(dbenv___0, logrec.size, (void *)(& logrec.data));
    if (ret != 0) {
      return (ret);
    }
  }
  if (npad > 0U) {
    memset((void *)(((u_int8_t *)logrec.data + logrec.size) - npad), 0, npad);
  }
  bp = (u_int8_t *)logrec.data;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& rectype), sizeof(rectype));
  bp += sizeof(rectype);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& txn_num), sizeof(txn_num));
  bp += sizeof(txn_num);
  memcpy((void * __restrict  )bp, (void const   * __restrict  )lsnp, sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  uinttmp = min;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  uinttmp = max;
  memcpy((void * __restrict  )bp, (void const   * __restrict  )(& uinttmp), sizeof(uinttmp));
  bp += sizeof(uinttmp);
  if (! is_durable) {
    if ((unsigned int )txnid != (unsigned int )((void *)0)) {
      ret = 0;
      while (1) {
        lr->links.stqe_next = txnid->logs.stqh_first;
        if ((unsigned int )lr->links.stqe_next == (unsigned int )((void *)0)) {
          txnid->logs.stqh_last = & lr->links.stqe_next;
        }
        txnid->logs.stqh_first = lr;
        break;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
    ret = __log_put(dbenv___0, ret_lsnp, (DBT const   *)(& logrec), flags | 8U);
    if (ret == 0) {
      if ((unsigned int )txnid != (unsigned int )((void *)0)) {
        txnid->last_lsn = (*ret_lsnp);
      }
    }
  }
  if (! is_durable) {
    while (1) {
      ret_lsnp->file = 0U;
      ret_lsnp->offset = 1U;
      break;
    }
  }
  if (is_durable) {
    __os_free(dbenv___0, logrec.data);
  } else {
    if ((unsigned int )txnid == (unsigned int )((void *)0)) {
      __os_free(dbenv___0, logrec.data);
    }
  }
  return (ret);
}
}
int __txn_recycle_getpgnos(DB_ENV *dbenv___0 , DBT *rec , DB_LSN *lsnp , db_recops notused1 ,
                           void *summary ) 
{ TXN_RECS *t ;
  int ret ;

  {
  rec = (DBT *)((void *)0);
  rec = rec;
  notused1 = (enum __anonenum_db_recops_55 )0;
  notused1 = notused1;
  t = (TXN_RECS *)summary;
  ret = __rep_check_alloc(dbenv___0, t, 1);
  if (ret != 0) {
    return (ret);
  }
  (t->array + t->npages)->flags = 1U;
  (t->array + t->npages)->lsn = (*lsnp);
  (t->array + t->npages)->fid = -1;
  memset((void *)(& (t->array + t->npages)->pgdesc), 0, sizeof((t->array + t->npages)->pgdesc));
  t->npages = t->npages + 1;
  return (0);
}
}
int __txn_recycle_print(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops notused2 ,
                        void *notused3 ) 
{ __txn_recycle_args *argp ;
  int ret ;
  char const   *tmp ;

  {
  notused2 = (enum __anonenum_db_recops_55 )0;
  notused3 = (void *)0;
  ret = __txn_recycle_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->type & 2147483648U) {
    tmp = "_debug";
  } else {
    tmp = "";
  }
  printf((char const   * __restrict  )"[%lu][%lu]__txn_recycle%s: rec: %lu txnid %lx prevlsn [%lu][%lu]\n",
         (unsigned long )lsnp->file, (unsigned long )lsnp->offset, tmp, (unsigned long )argp->type,
         (unsigned long )(argp->txnid)->txnid, (unsigned long )argp->prev_lsn.file,
         (unsigned long )argp->prev_lsn.offset);
  printf((char const   * __restrict  )"\tmin: %u\n", argp->min);
  printf((char const   * __restrict  )"\tmax: %u\n", argp->max);
  printf((char const   * __restrict  )"\n");
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
int __txn_recycle_read(DB_ENV *dbenv___0 , void *recbuf , __txn_recycle_args **argpp ) 
{ __txn_recycle_args *argp ;
  u_int32_t uinttmp ;
  u_int8_t *bp ;
  int ret ;

  {
  ret = __os_malloc(dbenv___0, sizeof(__txn_recycle_args ) + sizeof(DB_TXN ), (void *)(& argp));
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->min = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->max = uinttmp;
  bp += sizeof(uinttmp);
  (*argpp) = argp;
  return (0);
}
}
int __txn_init_print(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                        db_recops  , void * ) , size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_regop_print, 10U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_ckp_print, 11U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_child_print, 12U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_xa_regop_print, 13U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_recycle_print, 14U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __txn_init_getpgnos(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                           db_recops  , void * ) ,
                        size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_regop_getpgnos, 10U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_ckp_getpgnos, 11U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_child_getpgnos, 12U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_xa_regop_getpgnos,
                          13U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_recycle_getpgnos, 14U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
int __txn_init_recover(DB_ENV *dbenv___0 , int (***dtabp)(DB_ENV * , DBT * , DB_LSN * ,
                                                          db_recops  , void * ) ,
                       size_t *dtabsizep ) 
{ int ret ;

  {
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_regop_recover, 10U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_ckp_recover, 11U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_child_recover, 12U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_xa_regop_recover, 13U);
  if (ret != 0) {
    return (ret);
  }
  ret = __db_add_recovery(dbenv___0, dtabp, dtabsizep, & __txn_recycle_recover, 14U);
  if (ret != 0) {
    return (ret);
  }
  return (0);
}
}
#pragma merger(0,"/tmp/cil-kUaxKmrX.i","-O2")
int __txn_recover_pp(DB_ENV *dbenv___0 , DB_PREPLIST *preplist , long count , long *retp ,
                     u_int32_t flags ) ;
int __txn_stat_pp(DB_ENV *dbenv___0 , DB_TXN_STAT **statp , u_int32_t flags ) ;
static int __txn_get_tx_max(DB_ENV *dbenv___0 , u_int32_t *tx_maxp ) ;
static int __txn_get_tx_timestamp(DB_ENV *dbenv___0 , time_t *timestamp ) ;
static int __txn_set_tx_timestamp(DB_ENV *dbenv___0 , time_t *timestamp ) ;
void __txn_dbenv_create(DB_ENV *dbenv___0 ) 
{ 

  {
  dbenv___0->tx_max = 20U;
  dbenv___0->get_tx_max = & __txn_get_tx_max;
  dbenv___0->set_tx_max = & __txn_set_tx_max;
  dbenv___0->get_tx_timestamp = & __txn_get_tx_timestamp;
  dbenv___0->set_tx_timestamp = & __txn_set_tx_timestamp;
  dbenv___0->txn_checkpoint = & __txn_checkpoint_pp;
  dbenv___0->txn_recover = & __txn_recover_pp;
  dbenv___0->txn_stat = & __txn_stat_pp;
  dbenv___0->txn_begin = & __txn_begin_pp;
  return;
}
}
static int __txn_get_tx_max(DB_ENV *dbenv___0 , u_int32_t *tx_maxp ) 
{ 

  {
  (*tx_maxp) = dbenv___0->tx_max;
  return (0);
}
}
int __txn_set_tx_max(DB_ENV *dbenv___0 , u_int32_t tx_max ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_tx_max", 1);
    return (tmp);
  }
  dbenv___0->tx_max = tx_max;
  return (0);
}
}
static int __txn_get_tx_timestamp(DB_ENV *dbenv___0 , time_t *timestamp ) 
{ 

  {
  (*timestamp) = dbenv___0->tx_timestamp;
  return (0);
}
}
static int __txn_set_tx_timestamp(DB_ENV *dbenv___0 , time_t *timestamp ) 
{ int tmp ;

  {
  if (dbenv___0->flags & 8192U) {
    tmp = __db_mi_open(dbenv___0, "DB_ENV->set_tx_timestamp", 1);
    return (tmp);
  }
  dbenv___0->tx_timestamp = (*timestamp);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-J12xXG4V.i","-O2")
int __txn_regop_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ DB_TXNHEAD *headp ;
  __txn_regop_args *argp ;
  int ret ;
  u_int32_t tmp ;
  int tmp___0 ;

  {
  ret = __txn_regop_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  headp = (DB_TXNHEAD *)info;
  if ((int )op == 4) {
    __db_txnlist_remove(dbenv___0, info, (argp->txnid)->txnid);
  } else {
    if (dbenv___0->tx_timestamp != 0L) {
      if (argp->timestamp > (int )dbenv___0->tx_timestamp) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (! (headp->trunc_lsn.file == 0U)) {
        tmp___0 = log_compare((DB_LSN const   *)(& headp->trunc_lsn), (DB_LSN const   *)lsnp);
        if (tmp___0 < 0) {
          _L: 
          ret = __db_txnlist_update(dbenv___0, info, (argp->txnid)->txnid, 3, (DB_LSN *)((void *)0));
          if (ret == 5) {
            ret = 0;
          } else {
            if (ret == 4) {
              ret = __db_txnlist_add(dbenv___0, info, (argp->txnid)->txnid, 5, (DB_LSN *)((void *)0));
            } else {
              if (ret != 0) {
                goto err;
              }
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        ret = __db_txnlist_update(dbenv___0, info, (argp->txnid)->txnid, (int )argp->opcode,
                                  lsnp);
        if (ret == 5) {
          ret = 0;
        } else {
          if (ret == 4) {
            if (argp->opcode == 3U) {
              tmp = 5U;
            } else {
              tmp = argp->opcode;
            }
            ret = __db_txnlist_add(dbenv___0, info, (argp->txnid)->txnid, (int )tmp,
                                   lsnp);
          } else {
            if (ret != 0) {
              goto err;
            }
          }
        }
      }
    }
  }
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  if (0) {
    err: 
    __db_err((DB_ENV const   *)dbenv___0, "txnid %lx commit record found, already on commit list",
             (unsigned long )(argp->txnid)->txnid);
    ret = 22;
  }
  __os_free(dbenv___0, (void *)argp);
  return (ret);
}
}
int __txn_xa_regop_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                           void *info ) 
{ __txn_xa_regop_args *argp ;
  int ret ;

  {
  ret = __txn_xa_regop_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if (argp->opcode != 2U) {
    if (argp->opcode != 3U) {
      ret = 22;
      goto err;
    }
  }
  ret = __db_txnlist_find(dbenv___0, info, (argp->txnid)->txnid);
  if ((int )op == 4) {
    ret = __db_txnlist_remove(dbenv___0, info, (argp->txnid)->txnid);
    if (ret != 0) {
      goto txn_err;
    }
  } else {
    if ((int )op == 3) {
      if (ret == 2) {
        if (argp->opcode == 3U) {
          ret = __db_txnlist_update(dbenv___0, info, (argp->txnid)->txnid, 3, (DB_LSN *)((void *)0));
          if (ret != 2) {
            goto txn_err;
          }
          ret = 0;
        } else {
          ret = __db_txnlist_remove(dbenv___0, info, (argp->txnid)->txnid);
          if (ret != 0) {
            txn_err: 
            __db_err((DB_ENV const   *)dbenv___0, "Transaction not in list %x", (argp->txnid)->txnid);
            ret = -30990;
          } else {
            ret = __db_txnlist_add(dbenv___0, info, (argp->txnid)->txnid, 1, lsnp);
            if (ret == 0) {
              ret = __txn_restore_txn(dbenv___0, lsnp, argp);
            }
          }
        }
      } else {
        ret = 0;
      }
    } else {
      ret = 0;
    }
  }
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  err: 
  __os_free(dbenv___0, (void *)argp);
  return (ret);
}
}
int __txn_ckp_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                      void *info ) 
{ DB_REP *db_rep ;
  REP *rep ;
  __txn_ckp_args *argp ;
  int ret ;

  {
  ret = __txn_ckp_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if ((int )op == 3) {
    __db_txnlist_ckp(dbenv___0, info, lsnp);
  }
  if ((int )op == 4) {
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      db_rep = (DB_REP *)dbenv___0->rep_handle;
      rep = db_rep->region;
      if (argp->rep_gen > rep->recover_gen) {
        rep->recover_gen = argp->rep_gen;
      }
    }
  }
  (*lsnp) = argp->last_ckp;
  __os_free(dbenv___0, (void *)argp);
  return (-30892);
}
}
int __txn_child_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                        void *info ) 
{ __txn_child_args *argp ;
  int c_stat ;
  int p_stat ;
  int ret ;
  int tmp ;

  {
  ret = __txn_child_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  if ((int )op == 0) {
    ret = __db_txnlist_lsnadd(dbenv___0, info, & argp->c_lsn, 1U);
  } else {
    if ((int )op == 3) {
      c_stat = __db_txnlist_find(dbenv___0, info, argp->child);
      p_stat = __db_txnlist_find(dbenv___0, info, (argp->txnid)->txnid);
      if (c_stat == 6) {
        switch (p_stat) {
        case 1: ;
        case 5: 
        c_stat = 5;
        break;
        default: 
        c_stat = 3;
        }
        ret = __db_txnlist_update(dbenv___0, info, argp->child, c_stat, (DB_LSN *)((void *)0));
        if (ret > 0) {
          ret = 0;
        }
      } else {
        if (c_stat == 7) {
          if (p_stat == 1) {
            tmp = 1;
          } else {
            tmp = 5;
          }
          ret = __db_txnlist_update(dbenv___0, info, argp->child, tmp, (DB_LSN *)((void *)0));
          if (ret > 0) {
            ret = 0;
          }
        } else {
          if (c_stat != 5) {
            switch (p_stat) {
            case 1: 
            c_stat = 1;
            break;
            case 5: 
            c_stat = 5;
            break;
            default: 
            c_stat = 3;
            }
            ret = __db_txnlist_add(dbenv___0, info, argp->child, c_stat, (DB_LSN *)((void *)0));
          }
        }
      }
    } else {
      if ((int )op == 6) {
        c_stat = __db_txnlist_find(dbenv___0, info, argp->child);
        if (c_stat == 4) {
          p_stat = __db_txnlist_find(dbenv___0, info, (argp->txnid)->txnid);
          if (p_stat == 4) {
            ret = __db_txnlist_add(dbenv___0, info, (argp->txnid)->txnid, 5, (DB_LSN *)((void *)0));
          } else {
            ret = __db_txnlist_update(dbenv___0, info, (argp->txnid)->txnid, 5, (DB_LSN *)((void *)0));
          }
        }
      } else {
        if ((int )op == 4) {
          goto _L;
        } else {
          if ((int )op == 1) {
            _L: 
            ret = __db_txnlist_remove(dbenv___0, info, argp->child);
            if (ret != 0) {
              __db_err((DB_ENV const   *)dbenv___0, "Transaction not in list %x",
                       argp->child);
              ret = -30990;
            }
          }
        }
      }
    }
  }
  if (ret == 0) {
    (*lsnp) = argp->prev_lsn;
  }
  __os_free(dbenv___0, (void *)argp);
  return (ret);
}
}
int __txn_restore_txn(DB_ENV *dbenv___0 , DB_LSN *lsnp , __txn_xa_regop_args *argp ) 
{ DB_TXNMGR *mgr ;
  TXN_DETAIL *td ;
  DB_TXNREGION *region ;
  int ret ;

  {
  if (argp->xid.size == 0U) {
    return (0);
  }
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  ret = __db_shalloc(mgr->reginfo.addr, sizeof(TXN_DETAIL ), 0U, (void *)(& td));
  if (ret != 0) {
    if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
    }
    return (ret);
  }
  while (1) {
    if (region->active_txn.stqh_first != -1) {
      td->links.stqe_next = region->active_txn.stqh_first - ((u_int8_t *)td - (u_int8_t *)(& region->active_txn));
      if (td->links.stqe_next == -1) {
        ((struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first))->links.stqe_prev = 0;
      } else {
        ((struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first))->links.stqe_prev = - td->links.stqe_next +
                                                                                                                         ((u_int8_t *)(& td->links.stqe_next) -
                                                                                                                          (u_int8_t *)td);
      }
    } else {
      region->active_txn.stqh_last = (u_int8_t *)(& td->links.stqe_next) - (u_int8_t *)(& region->active_txn);
      td->links.stqe_next = -1;
    }
    region->active_txn.stqh_first = (u_int8_t *)td - (u_int8_t *)(& region->active_txn);
    td->links.stqe_prev = (u_int8_t *)(& region->active_txn.stqh_first) - (u_int8_t *)td;
    break;
  }
  td->txnid = (argp->txnid)->txnid;
  td->begin_lsn = argp->begin_lsn;
  td->last_lsn = (*lsnp);
  td->parent = 0U;
  td->status = 3U;
  td->xa_status = 4U;
  memcpy((void * __restrict  )(td->xid), (void const   * __restrict  )argp->xid.data,
         argp->xid.size);
  td->bqual = argp->bqual;
  td->gtrid = argp->gtrid;
  td->format = argp->formatID;
  td->flags = 0U;
  td->flags = td->flags | 2U;
  region->stat.st_nrestores = region->stat.st_nrestores + 1U;
  region->stat.st_nactive = region->stat.st_nactive + 1U;
  if (region->stat.st_nactive > region->stat.st_maxnactive) {
    region->stat.st_maxnactive = region->stat.st_nactive;
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  return (0);
}
}
int __txn_recycle_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __txn_recycle_args *argp ;
  int ret ;
  int tmp ;

  {
  ret = __txn_recycle_read(dbenv___0, dbtp->data, & argp);
  if (ret != 0) {
    return (ret);
  }
  lsnp = (DB_LSN *)((void *)0);
  lsnp = lsnp;
  if ((int )op == 0) {
    tmp = -1;
  } else {
    if ((int )op == 3) {
      tmp = -1;
    } else {
      if ((int )op == 2) {
        tmp = -1;
      } else {
        tmp = 1;
      }
    }
  }
  ret = __db_txnlist_gen(dbenv___0, info, tmp, argp->min, argp->max);
  if (ret != 0) {
    return (ret);
  }
  __os_free(dbenv___0, (void *)argp);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-PxycjBfU.i","-O2")
void __txn_continue(DB_ENV *env , DB_TXN *txnp , TXN_DETAIL *td , size_t off ) ;
int __txn_map_gid(DB_ENV *dbenv___0 , u_int8_t *gid , TXN_DETAIL **tdp , size_t *offp ) ;
int __txn_get_prepared(DB_ENV *dbenv___0 , XID *xids , DB_PREPLIST *txns , long count ,
                       long *retp , u_int32_t flags ) ;
void __txn_continue(DB_ENV *env , DB_TXN *txnp , TXN_DETAIL *td , size_t off ) 
{ 

  {
  txnp->mgrp = (DB_TXNMGR *)env->tx_handle;
  txnp->parent = (DB_TXN *)((void *)0);
  txnp->last_lsn = td->last_lsn;
  txnp->txnid = td->txnid;
  txnp->off = off;
  txnp->abort = & __txn_abort;
  txnp->commit = & __txn_commit;
  txnp->discard = & __txn_discard;
  txnp->id = & __txn_id;
  txnp->prepare = & __txn_prepare;
  txnp->flags = 0U;
  if (td->flags & 2U) {
    txnp->flags = txnp->flags | 128U;
  }
  return;
}
}
int __txn_map_gid(DB_ENV *dbenv___0 , u_int8_t *gid , TXN_DETAIL **tdp , size_t *offp ) 
{ DB_TXNMGR *mgr ;
  DB_TXNREGION *tmr ;
  int tmp ;

  {
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  tmr = (DB_TXNREGION *)mgr->reginfo.primary;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (tmr->active_txn.stqh_first == -1) {
    (*tdp) = (TXN_DETAIL *)((void *)0);
  } else {
    (*tdp) = (struct __txn_detail *)((u_int8_t *)(& tmr->active_txn) + tmr->active_txn.stqh_first);
  }
  while ((unsigned int )(*tdp) != (unsigned int )((void *)0)) {
    tmp = memcmp((void const   *)gid, (void const   *)(((*tdp))->xid), sizeof(((*tdp))->xid));
    if (tmp == 0) {
      break;
    }
    if (((*tdp))->links.stqe_next == -1) {
      (*tdp) = (TXN_DETAIL *)((void *)0);
    } else {
      (*tdp) = (struct __txn_detail *)((u_int8_t *)(*tdp) + ((*tdp))->links.stqe_next);
    }
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if ((unsigned int )(*tdp) == (unsigned int )((void *)0)) {
    return (22);
  }
  (*offp) = (unsigned int )((u_int8_t *)(*tdp) - (u_int8_t *)mgr->reginfo.addr);
  return (0);
}
}
int __txn_recover_pp(DB_ENV *dbenv___0 , DB_PREPLIST *preplist , long count , long *retp ,
                     u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"txn_recover", 131072U);
    return (tmp___0);
  }
  if (((DB_TXNREGION *)((DB_TXNMGR *)dbenv___0->tx_handle)->reginfo.primary)->flags &
      1U) {
    __db_err((DB_ENV const   *)dbenv___0, "operation not permitted while in recovery");
    return (22);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __txn_recover(dbenv___0, preplist, count, retp, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
int __txn_recover(DB_ENV *dbenv___0 , DB_PREPLIST *preplist , long count , long *retp ,
                  u_int32_t flags ) 
{ int tmp ;

  {
  tmp = __txn_get_prepared(dbenv___0, (XID *)((void *)0), preplist, count, retp, flags);
  return (tmp);
}
}
int __txn_get_prepared(DB_ENV *dbenv___0 , XID *xids , DB_PREPLIST *txns , long count ,
                       long *retp , u_int32_t flags ) 
{ DBT data ;
  DB_LOGC *logc ;
  DB_LSN min ;
  DB_LSN open_lsn ;
  DB_PREPLIST *prepp ;
  DB_TXNMGR *mgr ;
  DB_TXNREGION *tmr ;
  TXN_DETAIL *td ;
  XID *xidp ;
  __txn_ckp_args *ckp_args ;
  long i ;
  int nrestores ;
  int open_files ;
  int ret ;
  int t_ret ;
  void *txninfo ;
  int tmp ;
  int tmp___0 ;

  {
  (*retp) = 0L;
  logc = (DB_LOGC *)((void *)0);
  while (1) {
    min.file = 4294967295U;
    min.offset = 4294967295U;
    break;
  }
  prepp = txns;
  xidp = xids;
  ret = 0;
  nrestores = ret;
  open_files = 1;
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  tmr = (DB_TXNREGION *)mgr->reginfo.primary;
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if (flags == 9U) {
    if (tmr->active_txn.stqh_first == -1) {
      td = (TXN_DETAIL *)((void *)0);
    } else {
      td = (struct __txn_detail *)((u_int8_t *)(& tmr->active_txn) + tmr->active_txn.stqh_first);
    }
    while ((unsigned int )td != (unsigned int )((void *)0)) {
      if (td->flags & 2U) {
        nrestores ++;
      }
      if (td->flags & 1U) {
        open_files = 0;
      }
      td->flags = td->flags & 4294967294U;
      if (td->links.stqe_next == -1) {
        td = (TXN_DETAIL *)((void *)0);
      } else {
        td = (struct __txn_detail *)((u_int8_t *)td + td->links.stqe_next);
      }
    }
    mgr->n_discards = 0U;
  } else {
    open_files = 0;
  }
  if (tmr->active_txn.stqh_first == -1) {
    td = (TXN_DETAIL *)((void *)0);
  } else {
    td = (struct __txn_detail *)((u_int8_t *)(& tmr->active_txn) + tmr->active_txn.stqh_first);
  }
  while (1) {
    if ((unsigned int )td != (unsigned int )((void *)0)) {
      if (! ((*retp) < count)) {
        break;
      }
    } else {
      break;
    }
    if (td->status != 3U) {
      goto __Cont;
    } else {
      if (td->flags & 1U) {
        goto __Cont;
      }
    }
    if ((unsigned int )xids != (unsigned int )((void *)0)) {
      xidp->formatID = (long )td->format;
      xidp->gtrid_length = (long )td->gtrid;
      xidp->bqual_length = (long )td->bqual;
      memcpy((void * __restrict  )(xidp->data), (void const   * __restrict  )(td->xid),
             sizeof(td->xid));
      xidp ++;
    }
    if ((unsigned int )txns != (unsigned int )((void *)0)) {
      ret = __os_calloc(dbenv___0, 1U, sizeof(DB_TXN ), (void *)(& prepp->txn));
      if (ret != 0) {
        if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
          __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
        }
        goto err;
      }
      __txn_continue(dbenv___0, prepp->txn, td, (unsigned int )((u_int8_t *)td - (u_int8_t *)mgr->reginfo.addr));
      (prepp->txn)->flags = (prepp->txn)->flags | 16U;
      memcpy((void * __restrict  )(prepp->gid), (void const   * __restrict  )(td->xid),
             sizeof(td->xid));
      prepp ++;
    }
    tmp = log_compare((DB_LSN const   *)(& td->begin_lsn), (DB_LSN const   *)(& min));
    if (tmp < 0) {
      min = td->begin_lsn;
    }
    (*retp) ++;
    td->flags = td->flags | 1U;
    __Cont: 
    if (td->links.stqe_next == -1) {
      td = (TXN_DETAIL *)((void *)0);
    } else {
      td = (struct __txn_detail *)((u_int8_t *)td + td->links.stqe_next);
    }
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  if ((unsigned int )txns != (unsigned int )((void *)0)) {
    if ((unsigned int )mgr->mutexp != (unsigned int )((void *)0)) {
      if (! ((mgr->mutexp)->flags & 2U)) {
        __db_pthread_mutex_lock(dbenv___0, mgr->mutexp);
      }
    }
    i = 0L;
    while (i < (*retp)) {
      while (1) {
        ((txns + i)->txn)->links.tqe_next = (struct __db_txn *)((void *)0);
        ((txns + i)->txn)->links.tqe_prev = mgr->txn_chain.tqh_last;
        (*(mgr->txn_chain.tqh_last)) = (txns + i)->txn;
        mgr->txn_chain.tqh_last = & ((txns + i)->txn)->links.tqe_next;
        break;
      }
      i ++;
    }
    if ((unsigned int )mgr->mutexp != (unsigned int )((void *)0)) {
      if (! ((mgr->mutexp)->flags & 2U)) {
        __db_pthread_mutex_unlock(dbenv___0, mgr->mutexp);
      }
    }
  }
  if (open_files) {
    if (nrestores) {
      if ((*retp) != 0L) {
        if (min.file == 4294967295U) {
          if (! (min.offset == 4294967295U)) {
            goto _L___0;
          }
        } else {
          _L___0: 
          ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags |
                                                    1U;
          ret = __log_cursor(dbenv___0, & logc);
          if (ret != 0) {
            goto err;
          }
          memset((void *)(& data), 0, sizeof(data));
          ret = __txn_getckp(dbenv___0, & open_lsn);
          if (ret == 0) {
            while (1) {
              if (! (open_lsn.file == 0U)) {
                ret = __log_c_get(logc, & open_lsn, & data, 28U);
                if (ret == 0) {
                  tmp___0 = log_compare((DB_LSN const   *)(& min), (DB_LSN const   *)(& open_lsn));
                  if (! (tmp___0 < 0)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              ret = __txn_ckp_read(dbenv___0, data.data, & ckp_args);
              if (ret != 0) {
                __db_err((DB_ENV const   *)dbenv___0, "Invalid checkpoint record at [%lu][%lu]",
                         (unsigned long )open_lsn.file, (unsigned long )open_lsn.offset);
                goto err;
              }
              open_lsn = ckp_args->last_ckp;
              __os_free(dbenv___0, (void *)ckp_args);
            }
          }
          if (ret == -30990) {
            goto _L;
          } else {
            if (open_lsn.file == 0U) {
              _L: 
              ret = __log_c_get(logc, & open_lsn, & data, 9U);
              if (ret != 0) {
                __db_err((DB_ENV const   *)dbenv___0, "No log records");
                goto err;
              }
            }
          }
          ret = __db_txnlist_init(dbenv___0, 0U, 0U, (DB_LSN *)((void *)0), (void *)(& txninfo));
          if (ret != 0) {
            goto err;
          }
          ret = __env_openfiles(dbenv___0, logc, txninfo, & data, & open_lsn, (DB_LSN *)((void *)0),
                                (double )0, 0);
          if ((unsigned int )txninfo != (unsigned int )((void *)0)) {
            __db_txnlist_end(dbenv___0, txninfo);
          }
        }
      }
    }
  }
  err: 
  ((DB_LOG *)dbenv___0->lg_handle)->flags = ((DB_LOG *)dbenv___0->lg_handle)->flags &
                                            4294967294U;
  if ((unsigned int )logc != (unsigned int )((void *)0)) {
    t_ret = __log_c_close(logc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-97WQXY3F.i","-O2")
int __txn_id_set(DB_ENV *dbenv___0 , u_int32_t cur_txnid , u_int32_t max_txnid ) ;
static int __txn_findlastckp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) ;
static int __txn_init(DB_ENV *dbenv___0 , DB_TXNMGR *tmgrp ) ;
static size_t __txn_region_size(DB_ENV *dbenv___0 ) ;
int __txn_open(DB_ENV *dbenv___0 ) 
{ DB_TXNMGR *tmgrp ;
  int ret ;
  size_t tmp ;

  {
  ret = __os_calloc(dbenv___0, 1U, sizeof(DB_TXNMGR ), (void *)(& tmgrp));
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    tmgrp->txn_chain.tqh_first = (struct __db_txn *)((void *)0);
    tmgrp->txn_chain.tqh_last = & tmgrp->txn_chain.tqh_first;
    break;
  }
  tmgrp->dbenv = dbenv___0;
  tmgrp->reginfo.type = (enum __anonenum_reg_type_50 )6;
  tmgrp->reginfo.id = 0U;
  tmgrp->reginfo.mode = dbenv___0->db_mode;
  tmgrp->reginfo.flags = 4U;
  if (dbenv___0->flags & 8U) {
    tmgrp->reginfo.flags = tmgrp->reginfo.flags | 2U;
  }
  tmp = __txn_region_size(dbenv___0);
  ret = __db_r_attach(dbenv___0, & tmgrp->reginfo, tmp);
  if (ret != 0) {
    goto err;
  }
  if (tmgrp->reginfo.flags & 1U) {
    ret = __txn_init(dbenv___0, tmgrp);
    if (ret != 0) {
      goto err;
    }
  }
  tmgrp->reginfo.primary = (void *)((u_int8_t *)tmgrp->reginfo.addr + (tmgrp->reginfo.rp)->primary);
  if (dbenv___0->flags & 1048576U) {
    ret = __db_mutex_setup(dbenv___0, & tmgrp->reginfo, (void *)(& tmgrp->mutexp),
                           321U);
    if (ret != 0) {
      goto err;
    }
  }
  if (! ((tmgrp->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (tmgrp->reginfo.rp)->mutex);
  }
  dbenv___0->tx_handle = (void *)tmgrp;
  return (0);
  err: 
  if ((unsigned int )tmgrp->reginfo.addr != (unsigned int )((void *)0)) {
    if (tmgrp->reginfo.flags & 1U) {
      ret = __db_panic(dbenv___0, ret);
    }
    if (! ((tmgrp->reginfo.rp)->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & (tmgrp->reginfo.rp)->mutex);
    }
    __db_r_detach(dbenv___0, & tmgrp->reginfo, 0);
  }
  if ((unsigned int )tmgrp->mutexp != (unsigned int )((void *)0)) {
    __db_mutex_free(dbenv___0, & tmgrp->reginfo, tmgrp->mutexp);
  }
  __os_free(dbenv___0, (void *)tmgrp);
  return (ret);
}
}
static int __txn_init(DB_ENV *dbenv___0 , DB_TXNMGR *tmgrp ) 
{ DB_LSN last_ckp ;
  DB_TXNREGION *region ;
  int ret ;

  {
  while (1) {
    last_ckp.file = 0U;
    last_ckp.offset = 0U;
    break;
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    __log_get_cached_ckp_lsn(dbenv___0, & last_ckp);
    if (last_ckp.file == 0U) {
      ret = __txn_findlastckp(dbenv___0, & last_ckp);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  ret = __db_shalloc(tmgrp->reginfo.addr, sizeof(DB_TXNREGION ), 0U, (void *)(& tmgrp->reginfo.primary));
  if (ret != 0) {
    __db_err((DB_ENV const   *)dbenv___0, "Unable to allocate memory for the transaction region");
    return (ret);
  }
  (tmgrp->reginfo.rp)->primary = (unsigned int )((u_int8_t *)tmgrp->reginfo.primary -
                                                 (u_int8_t *)tmgrp->reginfo.addr);
  region = (DB_TXNREGION *)tmgrp->reginfo.primary;
  memset((void *)region, 0, sizeof((*region)));
  region->maxtxns = dbenv___0->tx_max;
  region->last_txnid = 2147483648U;
  region->cur_maxid = 4294967295U;
  region->last_ckp = last_ckp;
  region->time_ckp = time((time_t *)((void *)0));
  memset((void *)(& region->stat), 0, sizeof(region->stat));
  region->stat.st_maxtxns = region->maxtxns;
  region->active_txn.stqh_first = -1;
  region->active_txn.stqh_last = (u_int8_t *)(& region->active_txn.stqh_first) - (u_int8_t *)(& region->active_txn);
  return (0);
}
}
static int __txn_findlastckp(DB_ENV *dbenv___0 , DB_LSN *lsnp ) 
{ DB_LOGC *logc ;
  DB_LSN lsn ;
  DBT dbt ;
  int ret ;
  int t_ret ;
  u_int32_t rectype ;
  int tmp ;

  {
  ret = __log_cursor(dbenv___0, & logc);
  if (ret != 0) {
    return (ret);
  }
  memset((void *)(& dbt), 0, sizeof(dbt));
  ret = __log_c_get(logc, & lsn, & dbt, 17U);
  if (ret != 0) {
    goto err;
  }
  lsn.offset = 0U;
  while (1) {
    ret = __log_c_get(logc, & lsn, & dbt, 25U);
    if (! (ret == 0)) {
      break;
    }
    if (dbt.size < sizeof(u_int32_t )) {
      continue;
    }
    memcpy((void * __restrict  )(& rectype), (void const   * __restrict  )dbt.data,
           sizeof(u_int32_t ));
    if (rectype == 11U) {
      (*lsnp) = lsn;
      break;
    }
  }
  err: 
  t_ret = __log_c_close(logc);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    tmp = 0;
  } else {
    if (ret == -30990) {
      tmp = 0;
    } else {
      tmp = ret;
    }
  }
  return (tmp);
}
}
int __txn_dbenv_refresh(DB_ENV *dbenv___0 ) 
{ DB_TXN *txnp ;
  DB_TXNMGR *tmgrp ;
  TXN_DETAIL *td ;
  u_int32_t txnid ;
  int aborted ;
  int ret ;
  int t_ret ;
  char *tmp ;
  char *tmp___0 ;

  {
  ret = 0;
  tmgrp = (DB_TXNMGR *)dbenv___0->tx_handle;
  aborted = 0;
  if ((unsigned int )tmgrp->txn_chain.tqh_first != (unsigned int )((void *)0)) {
    while (1) {
      txnp = tmgrp->txn_chain.tqh_first;
      if (! ((unsigned int )txnp != (unsigned int )((void *)0))) {
        break;
      }
      td = (TXN_DETAIL *)((void *)((u_int8_t *)tmgrp->reginfo.addr + txnp->off));
      txnid = txnp->txnid;
      if (td->status == 3U) {
        ret = __txn_discard(txnp, 0U);
        if (ret != 0) {
          tmp = db_strerror(ret);
          __db_err((DB_ENV const   *)dbenv___0, "Unable to discard txn 0x%x: %s",
                   txnid, tmp);
          break;
        }
        continue;
      }
      aborted = 1;
      t_ret = __txn_abort(txnp);
      if (t_ret != 0) {
        tmp___0 = db_strerror(t_ret);
        __db_err((DB_ENV const   *)dbenv___0, "Unable to abort transaction 0x%x: %s",
                 txnid, tmp___0);
        ret = __db_panic(dbenv___0, t_ret);
        break;
      }
    }
    if (aborted) {
      __db_err((DB_ENV const   *)dbenv___0, "Error: closing the transaction region with active transactions");
      if (ret == 0) {
        ret = 22;
      }
    }
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    t_ret = __log_flush(dbenv___0, (DB_LSN const   *)((void *)0));
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )tmgrp->mutexp != (unsigned int )((void *)0)) {
    __db_mutex_free(dbenv___0, & tmgrp->reginfo, tmgrp->mutexp);
  }
  t_ret = __db_r_detach(dbenv___0, & tmgrp->reginfo, 0);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  __os_free(dbenv___0, (void *)tmgrp);
  dbenv___0->tx_handle = (void *)0;
  return (ret);
}
}
static size_t __txn_region_size(DB_ENV *dbenv___0 ) 
{ size_t s ;

  {
  s = (sizeof(DB_TXNREGION ) + dbenv___0->tx_max * sizeof(TXN_DETAIL )) + 10240U;
  return (s);
}
}
void __txn_region_destroy(DB_ENV *dbenv___0 , REGINFO *infop ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  return;
}
}
int __txn_id_set(DB_ENV *dbenv___0 , u_int32_t cur_txnid , u_int32_t max_txnid ) 
{ DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  int ret ;
  int tmp ;

  {
  if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
    tmp = __db_env_config(dbenv___0, (char *)"txn_id_set", 131072U);
    return (tmp);
  }
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  region->last_txnid = cur_txnid;
  region->cur_maxid = max_txnid;
  ret = 0;
  if (cur_txnid < 2147483648U) {
    __db_err((DB_ENV const   *)dbenv___0, "Current ID value %lu below minimum", (unsigned long )cur_txnid);
    ret = 22;
  }
  if (max_txnid < 2147483648U) {
    __db_err((DB_ENV const   *)dbenv___0, "Maximum ID value %lu below minimum", (unsigned long )max_txnid);
    ret = 22;
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-aGDXX6Fc.i","-O2")
static int __txn_stat(DB_ENV *dbenv___0 , DB_TXN_STAT **statp , u_int32_t flags ) ;
int __txn_stat_pp(DB_ENV *dbenv___0 , DB_TXN_STAT **statp , u_int32_t flags ) 
{ int rep_check ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = __db_panic_msg(dbenv___0);
        return (tmp);
      }
    }
  }
  if ((unsigned int )dbenv___0->tx_handle == (unsigned int )((void *)0)) {
    tmp___0 = __db_env_config(dbenv___0, (char *)"txn_stat", 131072U);
    return (tmp___0);
  }
  ret = __db_fchk(dbenv___0, "DB_ENV->txn_stat", flags, 1U);
  if (ret != 0) {
    return (ret);
  }
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      rep_check = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )dbenv___0->rep_handle != (unsigned int )((void *)0)) {
      if ((unsigned int )((DB_REP *)dbenv___0->rep_handle)->region != (unsigned int )((void *)0)) {
        if ((((DB_REP *)dbenv___0->rep_handle)->region)->flags != 0U) {
          rep_check = 1;
        } else {
          rep_check = 0;
        }
      } else {
        rep_check = 0;
      }
    } else {
      rep_check = 0;
    }
  }
  if (rep_check) {
    __env_rep_enter(dbenv___0);
  }
  ret = __txn_stat(dbenv___0, statp, flags);
  if (rep_check) {
    __env_rep_exit(dbenv___0);
  }
  return (ret);
}
}
static int __txn_stat(DB_ENV *dbenv___0 , DB_TXN_STAT **statp , u_int32_t flags ) 
{ DB_TXNMGR *mgr ;
  DB_TXNREGION *region ;
  DB_TXN_STAT *stats___0 ;
  TXN_DETAIL *txnp ;
  size_t nbytes ;
  u_int32_t maxtxn ;
  u_int32_t ndx ;
  int ret ;

  {
  (*statp) = (DB_TXN_STAT *)((void *)0);
  mgr = (DB_TXNMGR *)dbenv___0->tx_handle;
  region = (DB_TXNREGION *)mgr->reginfo.primary;
  maxtxn = (region->maxtxns + region->maxtxns / 10U) + 10U;
  nbytes = sizeof(DB_TXN_STAT ) + sizeof(DB_TXN_ACTIVE ) * maxtxn;
  ret = __os_umalloc(dbenv___0, nbytes, (void *)(& stats___0));
  if (ret != 0) {
    return (ret);
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  memcpy((void * __restrict  )stats___0, (void const   * __restrict  )(& region->stat),
         sizeof((*stats___0)));
  stats___0->st_last_txnid = region->last_txnid;
  stats___0->st_last_ckp = region->last_ckp;
  stats___0->st_time_ckp = region->time_ckp;
  stats___0->st_txnarray = (DB_TXN_ACTIVE *)(stats___0 + 1);
  ndx = 0U;
  if (region->active_txn.stqh_first == -1) {
    txnp = (TXN_DETAIL *)((void *)0);
  } else {
    txnp = (struct __txn_detail *)((u_int8_t *)(& region->active_txn) + region->active_txn.stqh_first);
  }
  while (1) {
    if ((unsigned int )txnp != (unsigned int )((void *)0)) {
      if (! (ndx < maxtxn)) {
        break;
      }
    } else {
      break;
    }
    (stats___0->st_txnarray + ndx)->txnid = txnp->txnid;
    if (txnp->parent == 0U) {
      (stats___0->st_txnarray + ndx)->parentid = 0U;
    } else {
      (stats___0->st_txnarray + ndx)->parentid = ((TXN_DETAIL *)((void *)((u_int8_t *)mgr->reginfo.addr +
                                                                          txnp->parent)))->txnid;
    }
    (stats___0->st_txnarray + ndx)->lsn = txnp->begin_lsn;
    (stats___0->st_txnarray + ndx)->xa_status = txnp->xa_status;
    if ((stats___0->st_txnarray + ndx)->xa_status != 0U) {
      memcpy((void * __restrict  )((stats___0->st_txnarray + ndx)->xid), (void const   * __restrict  )(txnp->xid),
             128U);
    }
    if (txnp->links.stqe_next == -1) {
      txnp = (TXN_DETAIL *)((void *)0);
    } else {
      txnp = (struct __txn_detail *)((u_int8_t *)txnp + txnp->links.stqe_next);
    }
    ndx ++;
  }
  stats___0->st_region_wait = (mgr->reginfo.rp)->mutex.mutex_set_wait;
  stats___0->st_region_nowait = (mgr->reginfo.rp)->mutex.mutex_set_nowait;
  stats___0->st_regsize = (mgr->reginfo.rp)->size;
  if (flags & 1U) {
    (mgr->reginfo.rp)->mutex.mutex_set_wait = 0U;
    (mgr->reginfo.rp)->mutex.mutex_set_nowait = 0U;
    memset((void *)(& region->stat), 0, sizeof(region->stat));
    region->stat.st_maxtxns = region->maxtxns;
    region->stat.st_nactive = stats___0->st_nactive;
    region->stat.st_maxnactive = region->stat.st_nactive;
  }
  if (! ((mgr->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (mgr->reginfo.rp)->mutex);
  }
  (*statp) = stats___0;
  return (0);
}
}
#pragma merger(0,"/tmp/cil-WY2HdBVs.i","-O2")
int __txn_closeevent(DB_ENV *dbenv___0 , DB_TXN *txn , DB *dbp___1 ) 
{ int ret ;
  TXN_EVENT *e ;

  {
  e = (TXN_EVENT *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(TXN_EVENT ), (void *)(& e));
  if (ret != 0) {
    return (ret);
  }
  e->u.c.dbp = dbp___1;
  e->op = (enum __anonenum_TXN_EVENT_T_65 )0;
  while (1) {
    e->links.tqe_next = (struct __txn_event *)((void *)0);
    e->links.tqe_prev = txn->events.tqh_last;
    (*(txn->events.tqh_last)) = e;
    txn->events.tqh_last = & e->links.tqe_next;
    break;
  }
  return (0);
}
}
int __txn_remevent(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name , u_int8_t *fileid ) 
{ int ret ;
  TXN_EVENT *e ;

  {
  e = (TXN_EVENT *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(TXN_EVENT ), (void *)(& e));
  if (ret != 0) {
    return (ret);
  }
  ret = __os_strdup(dbenv___0, name, (void *)(& e->u.r.name));
  if (ret != 0) {
    goto err;
  }
  if ((unsigned int )fileid != (unsigned int )((void *)0)) {
    ret = __os_calloc(dbenv___0, 1U, 20U, (void *)(& e->u.r.fileid));
    if (ret != 0) {
      return (ret);
    }
    memcpy((void * __restrict  )e->u.r.fileid, (void const   * __restrict  )fileid,
           20U);
  }
  e->op = (enum __anonenum_TXN_EVENT_T_65 )1;
  while (1) {
    e->links.tqe_next = (struct __txn_event *)((void *)0);
    e->links.tqe_prev = txn->events.tqh_last;
    (*(txn->events.tqh_last)) = e;
    txn->events.tqh_last = & e->links.tqe_next;
    break;
  }
  return (0);
  err: 
  if ((unsigned int )e != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (void *)e);
  }
  return (ret);
}
}
void __txn_remrem(DB_ENV *dbenv___0 , DB_TXN *txn , char const   *name ) 
{ TXN_EVENT *e ;
  TXN_EVENT *next_e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___34 ;
  unsigned char const   *__s2___6 ;
  register int __result___18 ;
  int tmp___53 ;
  unsigned char const   *__s1___14 ;
  register int __result___22 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  e = txn->events.tqh_first;
  while ((unsigned int )e != (unsigned int )((void *)0)) {
    next_e = e->links.tqe_next;
    if ((int )e->op != 1) {
      goto __Cont;
    } else {
      tmp___65 = __builtin_constant_p((int )name);
      if (tmp___65) {
        tmp___66 = __builtin_constant_p((int )e->u.r.name);
        if (tmp___66) {
          __s1_len = strlen(name);
          __s2_len = strlen((char const   *)e->u.r.name);
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                 1U)) {
            goto _L___16;
          } else {
            if (__s1_len >= 4U) {
              _L___16: 
              if (! ((unsigned int )((void const   *)(e->u.r.name + 1)) - (unsigned int )((void const   *)e->u.r.name) ==
                     1U)) {
                tmp___67 = 1;
              } else {
                if (__s2_len >= 4U) {
                  tmp___67 = 1;
                } else {
                  tmp___67 = 0;
                }
              }
            } else {
              tmp___67 = 0;
            }
          }
          if (tmp___67) {
            tmp___34 = __builtin_strcmp(name, e->u.r.name);
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        _L___18: 
        tmp___64 = __builtin_constant_p((int )name);
        if (tmp___64) {
          if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
              1U) {
            __s1_len = strlen(name);
            if (__s1_len < 4U) {
              tmp___53 = __builtin_constant_p((int )e->u.r.name);
              if (tmp___53) {
                if ((unsigned int )((void const   *)(e->u.r.name + 1)) - (unsigned int )((void const   *)e->u.r.name) ==
                    1U) {
                  tmp___34 = __builtin_strcmp(name, e->u.r.name);
                } else {
                  goto _L___11;
                }
              } else {
                _L___11: 
                __s2___6 = (unsigned char const   *)((char const   *)e->u.r.name);
                __result___18 = (int )((int const   )(*((unsigned char const   *)name +
                                                        0)) - (int const   )(*(__s2___6 +
                                                                               0)));
                if (__s1_len > 0U) {
                  if (__result___18 == 0) {
                    __result___18 = (int )((int const   )(*((unsigned char const   *)name +
                                                            1)) - (int const   )(*(__s2___6 +
                                                                                   1)));
                    if (__s1_len > 1U) {
                      if (__result___18 == 0) {
                        __result___18 = (int )((int const   )(*((unsigned char const   *)name +
                                                                2)) - (int const   )(*(__s2___6 +
                                                                                       2)));
                        if (__s1_len > 2U) {
                          if (__result___18 == 0) {
                            __result___18 = (int )((int const   )(*((unsigned char const   *)name +
                                                                    3)) - (int const   )(*(__s2___6 +
                                                                                           3)));
                          }
                        }
                      }
                    }
                  }
                }
                tmp___34 = __result___18;
              }
            } else {
              goto _L___15;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          tmp___63 = __builtin_constant_p((int )e->u.r.name);
          if (tmp___63) {
            if ((unsigned int )((void const   *)(e->u.r.name + 1)) - (unsigned int )((void const   *)e->u.r.name) ==
                1U) {
              __s2_len = strlen((char const   *)e->u.r.name);
              if (__s2_len < 4U) {
                tmp___62 = __builtin_constant_p((int )name);
                if (tmp___62) {
                  if ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) ==
                      1U) {
                    tmp___34 = __builtin_strcmp(name, e->u.r.name);
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: 
                  __s1___14 = (unsigned char const   *)name;
                  __result___22 = (int )((int const   )(*(__s1___14 + 0)) - (int const   )(*((unsigned char const   *)((char const   *)e->u.r.name) +
                                                                                             0)));
                  if (__s2_len > 0U) {
                    if (__result___22 == 0) {
                      __result___22 = (int )((int const   )(*(__s1___14 + 1)) - (int const   )(*((unsigned char const   *)((char const   *)e->u.r.name) +
                                                                                                 1)));
                      if (__s2_len > 1U) {
                        if (__result___22 == 0) {
                          __result___22 = (int )((int const   )(*(__s1___14 + 2)) -
                                                 (int const   )(*((unsigned char const   *)((char const   *)e->u.r.name) +
                                                                  2)));
                          if (__s2_len > 2U) {
                            if (__result___22 == 0) {
                              __result___22 = (int )((int const   )(*(__s1___14 +
                                                                      3)) - (int const   )(*((unsigned char const   *)((char const   *)e->u.r.name) +
                                                                                             3)));
                            }
                          }
                        }
                      }
                    }
                  }
                  tmp___34 = __result___22;
                }
              } else {
                tmp___34 = __builtin_strcmp(name, e->u.r.name);
              }
            } else {
              tmp___34 = __builtin_strcmp(name, e->u.r.name);
            }
          } else {
            tmp___34 = __builtin_strcmp(name, e->u.r.name);
          }
        }
      }
      if (tmp___34 != 0) {
        goto __Cont;
      }
    }
    while (1) {
      if ((unsigned int )e->links.tqe_next != (unsigned int )((void *)0)) {
        (e->links.tqe_next)->links.tqe_prev = e->links.tqe_prev;
      } else {
        txn->events.tqh_last = e->links.tqe_prev;
      }
      (*(e->links.tqe_prev)) = e->links.tqe_next;
      break;
    }
    __os_free(dbenv___0, (void *)e->u.r.name);
    if ((unsigned int )e->u.r.fileid != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)e->u.r.fileid);
    }
    __os_free(dbenv___0, (void *)e);
    __Cont: 
    e = next_e;
  }
  return;
}
}
int __txn_lockevent(DB_ENV *dbenv___0 , DB_TXN *txn , DB *dbp___1 , DB_LOCK *lock ,
                    u_int32_t locker ) 
{ int ret ;
  TXN_EVENT *e ;

  {
  if (! ((unsigned int )dbenv___0->lk_handle != (unsigned int )((void *)0))) {
    return (0);
  }
  e = (TXN_EVENT *)((void *)0);
  ret = __os_calloc(dbenv___0, 1U, sizeof(TXN_EVENT ), (void *)(& e));
  if (ret != 0) {
    return (ret);
  }
  e->u.t.locker = locker;
  e->u.t.lock = (*lock);
  e->u.t.dbp = dbp___1;
  e->op = (enum __anonenum_TXN_EVENT_T_65 )2;
  while (1) {
    e->links.tqe_next = (struct __txn_event *)((void *)0);
    e->links.tqe_prev = txn->events.tqh_last;
    (*(txn->events.tqh_last)) = e;
    txn->events.tqh_last = & e->links.tqe_next;
    break;
  }
  return (0);
}
}
void __txn_remlock(DB_ENV *dbenv___0 , DB_TXN *txn , DB_LOCK *lock , u_int32_t locker ) 
{ TXN_EVENT *e ;
  TXN_EVENT *next_e ;

  {
  e = txn->events.tqh_first;
  while ((unsigned int )e != (unsigned int )((void *)0)) {
    next_e = e->links.tqe_next;
    if ((int )e->op != 2) {
      if ((int )e->op != 3) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (e->u.t.lock.off != lock->off) {
        if (e->u.t.locker != locker) {
          goto __Cont;
        }
      }
    }
    while (1) {
      if ((unsigned int )e->links.tqe_next != (unsigned int )((void *)0)) {
        (e->links.tqe_next)->links.tqe_prev = e->links.tqe_prev;
      } else {
        txn->events.tqh_last = e->links.tqe_prev;
      }
      (*(e->links.tqe_prev)) = e->links.tqe_next;
      break;
    }
    __os_free(dbenv___0, (void *)e);
    __Cont: 
    e = next_e;
  }
  return;
}
}
int __txn_doevents(DB_ENV *dbenv___0 , DB_TXN *txn , int opcode , int preprocess ) 
{ DB_LOCKREQ req ;
  TXN_EVENT *e ;
  int ret ;
  int t_ret ;

  {
  ret = 0;
  if (preprocess) {
    e = txn->events.tqh_first;
    while ((unsigned int )e != (unsigned int )((void *)0)) {
      if ((int )e->op != 2) {
        goto __Cont;
      }
      while (1) {
        memset((void *)(& req), 0, sizeof(req));
        req.lock = e->u.t.lock;
        req.op = (enum __anonenum_db_lockop_t_51 )9;
        t_ret = __lock_vec(dbenv___0, e->u.t.locker, 0U, & req, 1, (DB_LOCKREQ **)((void *)0));
        if (t_ret == 0) {
          (e->u.t.dbp)->cur_lid = e->u.t.locker;
        } else {
          if (t_ret == -30990) {
            t_ret = 0;
          }
        }
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
        e->op = (enum __anonenum_TXN_EVENT_T_65 )3;
        break;
      }
      __Cont: 
      e = e->links.tqe_next;
    }
    return (ret);
  }
  while (1) {
    e = txn->events.tqh_first;
    if (! ((unsigned int )e != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      if ((unsigned int )e->links.tqe_next != (unsigned int )((void *)0)) {
        (e->links.tqe_next)->links.tqe_prev = e->links.tqe_prev;
      } else {
        txn->events.tqh_last = e->links.tqe_prev;
      }
      (*(e->links.tqe_prev)) = e->links.tqe_next;
      break;
    }
    if (opcode == 3) {
      if ((int )e->op != 0) {
        goto dofree;
      }
    }
    switch ((int )e->op) {
    case 0: 
    t_ret = __db_close(e->u.c.dbp, (DB_TXN *)((void *)0), 0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    break;
    case 1: ;
    if ((unsigned int )e->u.r.fileid != (unsigned int )((void *)0)) {
      t_ret = __memp_nameop(dbenv___0, e->u.r.fileid, (char const   *)((void *)0),
                            (char const   *)e->u.r.name, (char const   *)((void *)0));
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    } else {
      t_ret = __os_unlink(dbenv___0, (char const   *)e->u.r.name);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    break;
    case 2: ;
    while (1) {
      memset((void *)(& req), 0, sizeof(req));
      req.lock = e->u.t.lock;
      req.op = (enum __anonenum_db_lockop_t_51 )9;
      t_ret = __lock_vec(dbenv___0, e->u.t.locker, 0U, & req, 1, (DB_LOCKREQ **)((void *)0));
      if (t_ret == 0) {
        (e->u.t.dbp)->cur_lid = e->u.t.locker;
      } else {
        if (t_ret == -30990) {
          t_ret = 0;
        }
      }
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
      e->op = (enum __anonenum_TXN_EVENT_T_65 )3;
      break;
    }
    case 3: 
    t_ret = __lock_downgrade(dbenv___0, & e->u.t.lock, (enum __anonenum_db_lockmode_t_50 )1,
                             0U);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    break;
    default: ;
    }
    dofree: 
    switch ((int )e->op) {
    case 1: ;
    if ((unsigned int )e->u.r.fileid != (unsigned int )((void *)0)) {
      __os_free(dbenv___0, (void *)e->u.r.fileid);
    }
    __os_free(dbenv___0, (void *)e->u.r.name);
    break;
    default: ;
    break;
    }
    __os_free(dbenv___0, (void *)e);
  }
  return (ret);
}
}
#pragma merger(0,"/tmp/cil-tgtHhcq3.i","-O2")
int __xa_get_txn(DB_ENV *env , DB_TXN **txnp , int do_init ) ;
int __db_rmid_to_env(int rmid , DB_ENV **envp ) ;
int __db_xid_to_txn(DB_ENV *dbenv___0 , XID *xid , size_t *offp ) ;
int __db_map_rmid(int rmid , DB_ENV *env ) ;
int __db_unmap_rmid(int rmid ) ;
int __db_map_xid(DB_ENV *env , XID *xid , size_t off ) ;
void __db_unmap_xid(DB_ENV *env , XID *xid , size_t off ) ;
static int __db_xa_close(char *xa_info , int rmid , long flags ) ;
static int __db_xa_commit(XID *xid , int rmid , long flags ) ;
static int __db_xa_complete(int *handle , int *retval___0 , int rmid , long flags ) ;
static int __db_xa_end(XID *xid , int rmid , long flags ) ;
static int __db_xa_forget(XID *xid , int rmid , long flags ) ;
static int __db_xa_open(char *xa_info , int rmid , long flags ) ;
static int __db_xa_prepare(XID *xid , int rmid , long flags ) ;
static int __db_xa_recover(XID *xids , long count , int rmid , long flags ) ;
static int __db_xa_rollback(XID *xid , int rmid , long flags ) ;
static int __db_xa_start(XID *xid , int rmid , long flags ) ;
static void __xa_put_txn(DB_ENV *env , DB_TXN *txnp ) ;
struct xa_switch_t  const  db_xa_switch  = 
     {{(char )'B', (char )'e', (char )'r', (char )'k', (char )'e', (char )'l', (char )'e',
     (char )'y', (char )' ', (char )'D', (char )'B', (char )'\000'}, 2L, 0L, & __db_xa_open,
    & __db_xa_close, & __db_xa_start, & __db_xa_end, & __db_xa_rollback, & __db_xa_prepare,
    & __db_xa_commit, & __db_xa_recover, & __db_xa_forget, & __db_xa_complete};
int __xa_get_txn(DB_ENV *env , DB_TXN **txnp , int do_init ) 
{ int ret ;

  {
  do_init = 0;
  do_init = do_init;
  ret = 0;
  (*txnp) = env->xa_txn.tqh_first;
  if ((unsigned int )(*txnp) == (unsigned int )((void *)0)) {
    ret = __os_calloc(env, 1U, sizeof(DB_TXN ), (void *)txnp);
    if (ret == 0) {
      ((*txnp))->txnid = 0U;
      while (1) {
        ((*txnp))->xalinks.tqe_next = env->xa_txn.tqh_first;
        if ((unsigned int )((*txnp))->xalinks.tqe_next != (unsigned int )((void *)0)) {
          (env->xa_txn.tqh_first)->xalinks.tqe_prev = & ((*txnp))->xalinks.tqe_next;
        } else {
          env->xa_txn.tqh_last = & ((*txnp))->xalinks.tqe_next;
        }
        env->xa_txn.tqh_first = (*txnp);
        ((*txnp))->xalinks.tqe_prev = & env->xa_txn.tqh_first;
        break;
      }
    }
  }
  return (ret);
}
}
static void __xa_put_txn(DB_ENV *env , DB_TXN *txnp ) 
{ 

  {
  env = (DB_ENV *)((void *)0);
  env = env;
  txnp->txnid = 0U;
  return;
}
}
static int __db_xa_open(char *xa_info , int rmid , long flags ) 
{ DB_ENV *env ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  if (flags != 0L) {
    return (-5);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp == 0) {
    return (0);
  }
  tmp___0 = __os_calloc(env, 1U, sizeof(DB_ENV ), (void *)(& env));
  if (tmp___0 != 0) {
    return (-3);
  }
  tmp___1 = db_env_create(& env, 0U);
  if (tmp___1 != 0) {
    return (-3);
  }
  tmp___2 = ((*(env->open)))(env, (char const   *)xa_info, 188417U, 0);
  if (tmp___2 != 0) {
    goto err;
  }
  tmp___3 = __db_map_rmid(rmid, env);
  if (tmp___3 != 0) {
    goto err;
  }
  while (1) {
    env->xa_txn.tqh_first = (struct __db_txn *)((void *)0);
    env->xa_txn.tqh_last = & env->xa_txn.tqh_first;
    break;
  }
  return (0);
  err: 
  ((*(env->close)))(env, 0U);
  return (-3);
}
}
static int __db_xa_close(char *xa_info , int rmid , long flags ) 
{ DB_ENV *env ;
  DB_TXN *t ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___0 ;

  {
  xa_info = (char *)((void *)0);
  xa_info = xa_info;
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  if (flags != 0L) {
    return (-5);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (0);
  }
  t = env->xa_txn.tqh_first;
  if ((unsigned int )t != (unsigned int )((void *)0)) {
    if (t->txnid != 0U) {
      return (-6);
    }
  }
  ret = __db_unmap_rmid(rmid);
  while (1) {
    t = env->xa_txn.tqh_first;
    if (! ((unsigned int )t != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      if ((unsigned int )t->xalinks.tqe_next != (unsigned int )((void *)0)) {
        (t->xalinks.tqe_next)->xalinks.tqe_prev = t->xalinks.tqe_prev;
      } else {
        env->xa_txn.tqh_last = t->xalinks.tqe_prev;
      }
      (*(t->xalinks.tqe_prev)) = t->xalinks.tqe_next;
      break;
    }
    __os_free(env, (void *)t);
  }
  t_ret = ((*(env->close)))(env, 0U);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (ret == 0) {
    tmp___0 = 0;
  } else {
    tmp___0 = -3;
  }
  return (tmp___0);
}
}
static int __db_xa_start(XID *xid , int rmid , long flags ) 
{ DB_ENV *env ;
  DB_TXN *txnp ;
  TXN_DETAIL *td ;
  size_t off ;
  int is_known ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned long )flags & 1742733311UL) {
    return (-5);
  }
  if (flags & 2097152L) {
    if (flags & 134217728L) {
      return (-5);
    }
  }
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  tmp___0 = __db_xid_to_txn(env, xid, & off);
  is_known = tmp___0 == 0;
  if (is_known) {
    if (! (flags & 134217728L)) {
      if (! (flags & 2097152L)) {
        return (-8);
      }
    }
  }
  if (! is_known) {
    if (flags & 136314880L) {
      return (-4);
    }
  }
  if (is_known) {
    td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                                 off));
    if (td->xa_status == 6U) {
      if (! (flags & 136314880L)) {
        return (-6);
      }
    }
    if (td->xa_status == 2U) {
      return (102);
    }
    if (td->xa_status == 1U) {
      return (104);
    }
    tmp___1 = __xa_get_txn(env, & txnp, 1);
    if (tmp___1 != 0) {
      return (-3);
    }
    __txn_continue(env, txnp, td, off);
    td->xa_status = 5U;
  } else {
    tmp___2 = __xa_get_txn(env, & txnp, 1);
    if (tmp___2 != 0) {
      return (-3);
    }
    tmp___3 = __txn_xa_begin(env, txnp);
    if (tmp___3) {
      return (-3);
    }
    __db_map_xid(env, xid, txnp->off);
    td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                                 txnp->off));
    td->xa_status = 5U;
  }
  return (0);
}
}
static int __db_xa_end(XID *xid , int rmid , long flags ) 
{ DB_ENV *env ;
  DB_TXN *txn ;
  TXN_DETAIL *td ;
  size_t off ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (flags != 0L) {
    if (! (flags & 637534208L)) {
      return (-5);
    }
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  tmp___0 = __db_xid_to_txn(env, xid, & off);
  if (tmp___0 != 0) {
    return (-4);
  }
  tmp___1 = __xa_get_txn(env, & txn, 0);
  if (tmp___1 != 0) {
    return (-3);
  }
  if (off != txn->off) {
    return (-6);
  }
  td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                               off));
  if (td->xa_status == 2U) {
    return (102);
  }
  if (td->status == 2U) {
    return (104);
  }
  if (td->xa_status != 5U) {
    return (-6);
  }
  td->last_lsn = txn->last_lsn;
  if (flags & 33554432L) {
    td->xa_status = 6U;
  } else {
    td->xa_status = 3U;
  }
  __xa_put_txn(env, txn);
  return (0);
}
}
static int __db_xa_prepare(XID *xid , int rmid , long flags ) 
{ DB_ENV *env ;
  DB_TXN *txnp ;
  TXN_DETAIL *td ;
  size_t off ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  if (flags != 0L) {
    return (-5);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  tmp___0 = __db_xid_to_txn(env, xid, & off);
  if (tmp___0 != 0) {
    return (-4);
  }
  td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                               off));
  if (td->xa_status == 2U) {
    return (102);
  }
  if (td->xa_status != 3U) {
    if (td->xa_status != 6U) {
      return (-6);
    }
  }
  tmp___1 = __xa_get_txn(env, & txnp, 0);
  if (tmp___1 != 0) {
    return (-6);
  }
  __txn_continue(env, txnp, td, off);
  tmp___2 = ((*(txnp->prepare)))(txnp, (u_int8_t *)(xid->data));
  if (tmp___2 != 0) {
    return (-3);
  }
  td->xa_status = 4U;
  __xa_put_txn(env, txnp);
  return (0);
}
}
static int __db_xa_commit(XID *xid , int rmid , long flags ) 
{ DB_ENV *env ;
  DB_TXN *txnp ;
  TXN_DETAIL *td ;
  size_t off ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  if (flags & -1342177281L) {
    return (-5);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  tmp___0 = __db_xid_to_txn(env, xid, & off);
  if (tmp___0 != 0) {
    return (-4);
  }
  td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                               off));
  if (td->xa_status == 2U) {
    return (102);
  }
  if (td->xa_status == 1U) {
    return (104);
  }
  if (flags & 1073741824L) {
    if (td->xa_status != 3U) {
      if (td->xa_status != 6U) {
        return (-6);
      }
    }
  }
  if (! (flags & 1073741824L)) {
    if (td->xa_status != 4U) {
      return (-6);
    }
  }
  tmp___1 = __xa_get_txn(env, & txnp, 0);
  if (tmp___1 != 0) {
    return (-3);
  }
  __txn_continue(env, txnp, td, off);
  tmp___2 = ((*(txnp->commit)))(txnp, 0U);
  if (tmp___2 != 0) {
    return (-3);
  }
  __xa_put_txn(env, txnp);
  return (0);
}
}
static int __db_xa_recover(XID *xids , long count , int rmid , long flags ) 
{ DB_ENV *env ;
  u_int32_t newflags ;
  long rval ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  if (flags & 16777216L) {
    newflags = 9U;
  } else {
    if (flags & 8388608L) {
      newflags = 17U;
    } else {
      newflags = 18U;
    }
  }
  rval = 0L;
  tmp___0 = __txn_get_prepared(env, xids, (DB_PREPLIST *)((void *)0), count, & rval,
                               newflags);
  if (tmp___0 != 0) {
    return (-3);
  } else {
    return ((int )rval);
  }
}
}
static int __db_xa_rollback(XID *xid , int rmid , long flags ) 
{ DB_ENV *env ;
  DB_TXN *txnp ;
  TXN_DETAIL *td ;
  size_t off ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  if (flags != 0L) {
    return (-5);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  tmp___0 = __db_xid_to_txn(env, xid, & off);
  if (tmp___0 != 0) {
    return (-4);
  }
  td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                               off));
  if (td->xa_status == 2U) {
    return (102);
  }
  if (td->xa_status == 1U) {
    return (104);
  }
  if (td->xa_status != 3U) {
    if (td->xa_status != 6U) {
      if (td->xa_status != 4U) {
        return (-6);
      }
    }
  }
  tmp___1 = __xa_get_txn(env, & txnp, 0);
  if (tmp___1 != 0) {
    return (-3);
  }
  __txn_continue(env, txnp, td, off);
  tmp___2 = ((*(txnp->abort)))(txnp);
  if (tmp___2 != 0) {
    return (-3);
  }
  __xa_put_txn(env, txnp);
  return (0);
}
}
static int __db_xa_forget(XID *xid , int rmid , long flags ) 
{ DB_ENV *env ;
  size_t off ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )flags & 2147483648UL) {
    return (-2);
  }
  if (flags != 0L) {
    return (-5);
  }
  tmp = __db_rmid_to_env(rmid, & env);
  if (tmp != 0) {
    return (-6);
  }
  tmp___0 = __db_xid_to_txn(env, xid, & off);
  if (tmp___0 != 0) {
    return (0);
  }
  __db_unmap_xid(env, xid, off);
  return (0);
}
}
static int __db_xa_complete(int *handle , int *retval___0 , int rmid , long flags ) 
{ 

  {
  handle = (int *)((void *)0);
  handle = handle;
  retval___0 = (int *)((void *)0);
  retval___0 = retval___0;
  rmid = 0;
  rmid = rmid;
  flags = 0L;
  flags = flags;
  return (-5);
}
}
#pragma merger(0,"/tmp/cil-gPnkduAu.i","-O2")
static int __xa_close(DB *dbp___1 , u_int32_t flags ) ;
static int __xa_cursor(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t flags ) ;
static int __xa_del(DB *dbp___1 , DB_TXN *txn , DBT *key , u_int32_t flags ) ;
static int __xa_get(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) ;
static int __xa_open(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                     DBTYPE type , u_int32_t flags , int mode ) ;
static int __xa_put(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) ;
int __db_xa_create(DB *dbp___1 ) 
{ XA_METHODS *xam ;
  int ret ;

  {
  ret = __os_calloc(dbp___1->dbenv, 1U, sizeof(XA_METHODS ), (void *)(& xam));
  if (ret != 0) {
    return (ret);
  }
  dbp___1->xa_internal = (void *)xam;
  xam->open = dbp___1->open;
  dbp___1->open = & __xa_open;
  xam->close = dbp___1->close;
  dbp___1->close = & __xa_close;
  return (0);
}
}
static int __xa_open(DB *dbp___1 , DB_TXN *txn , char const   *name , char const   *subdb ,
                     DBTYPE type , u_int32_t flags , int mode ) 
{ DB_TXN *t ;
  XA_METHODS *xam ;
  int ret ;
  int tmp ;

  {
  xam = (XA_METHODS *)dbp___1->xa_internal;
  t = (DB_TXN *)((void *)0);
  if (! (flags & 16777216U)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      t = txn;
    } else {
      tmp = __xa_get_txn(dbp___1->dbenv, & t, 0);
      if (tmp != 0) {
        t = (DB_TXN *)((void *)0);
      } else {
        if ((unsigned int )t != (unsigned int )((void *)0)) {
          if (t->txnid == 0U) {
            t = (DB_TXN *)((void *)0);
          }
        }
      }
    }
  }
  ret = ((*(xam->open)))(dbp___1, t, name, subdb, type, flags, mode);
  if (ret != 0) {
    return (ret);
  }
  xam->cursor = dbp___1->cursor;
  xam->del = dbp___1->del;
  xam->get = dbp___1->get;
  xam->put = dbp___1->put;
  dbp___1->cursor = & __xa_cursor;
  dbp___1->del = & __xa_del;
  dbp___1->get = & __xa_get;
  dbp___1->put = & __xa_put;
  return (0);
}
}
static int __xa_cursor(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t flags ) 
{ DB_TXN *t ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    t = txn;
  } else {
    tmp = __xa_get_txn(dbp___1->dbenv, & t, 0);
    if (tmp != 0) {
      t = (DB_TXN *)((void *)0);
    } else {
      if (t->txnid == 0U) {
        t = (DB_TXN *)((void *)0);
      }
    }
  }
  tmp___0 = ((*(((XA_METHODS *)dbp___1->xa_internal)->cursor)))(dbp___1, t, dbcp,
                                                                flags);
  return (tmp___0);
}
}
static int __xa_del(DB *dbp___1 , DB_TXN *txn , DBT *key , u_int32_t flags ) 
{ DB_TXN *t ;
  int tmp ;
  int tmp___0 ;

  {
  t = (DB_TXN *)((void *)0);
  if (! (flags & 16777216U)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      t = txn;
    } else {
      tmp = __xa_get_txn(dbp___1->dbenv, & t, 0);
      if (tmp != 0) {
        t = (DB_TXN *)((void *)0);
      } else {
        if ((unsigned int )t != (unsigned int )((void *)0)) {
          if (t->txnid == 0U) {
            t = (DB_TXN *)((void *)0);
          }
        }
      }
    }
  }
  tmp___0 = ((*(((XA_METHODS *)dbp___1->xa_internal)->del)))(dbp___1, t, key, flags);
  return (tmp___0);
}
}
static int __xa_close(DB *dbp___1 , u_int32_t flags ) 
{ int (*real_close)(DB * , u_int32_t  ) ;
  int tmp ;

  {
  real_close = ((XA_METHODS *)dbp___1->xa_internal)->close;
  __os_free(dbp___1->dbenv, dbp___1->xa_internal);
  dbp___1->xa_internal = (void *)0;
  tmp = ((*real_close))(dbp___1, flags);
  return (tmp);
}
}
static int __xa_get(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) 
{ DB_TXN *t ;
  int tmp ;
  int tmp___0 ;

  {
  t = (DB_TXN *)((void *)0);
  if (! (flags & 16777216U)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      t = txn;
    } else {
      tmp = __xa_get_txn(dbp___1->dbenv, & t, 0);
      if (tmp != 0) {
        t = (DB_TXN *)((void *)0);
      } else {
        if ((unsigned int )t != (unsigned int )((void *)0)) {
          if (t->txnid == 0U) {
            t = (DB_TXN *)((void *)0);
          }
        }
      }
    }
  }
  tmp___0 = ((*(((XA_METHODS *)dbp___1->xa_internal)->get)))(dbp___1, t, key, data,
                                                             flags);
  return (tmp___0);
}
}
static int __xa_put(DB *dbp___1 , DB_TXN *txn , DBT *key , DBT *data , u_int32_t flags ) 
{ DB_TXN *t ;
  int tmp ;
  int tmp___0 ;

  {
  t = (DB_TXN *)((void *)0);
  if (! (flags & 16777216U)) {
    if ((unsigned int )txn != (unsigned int )((void *)0)) {
      t = txn;
    } else {
      tmp = __xa_get_txn(dbp___1->dbenv, & t, 0);
      if (tmp != 0) {
        t = (DB_TXN *)((void *)0);
      } else {
        if ((unsigned int )t != (unsigned int )((void *)0)) {
          if (t->txnid == 0U) {
            t = (DB_TXN *)((void *)0);
          }
        }
      }
    }
  }
  tmp___0 = ((*(((XA_METHODS *)dbp___1->xa_internal)->put)))(dbp___1, t, key, data,
                                                             flags);
  return (tmp___0);
}
}
#pragma merger(0,"/tmp/cil-r9GquqPp.i","-O2")
int __db_rmid_to_env(int rmid , DB_ENV **envp ) 
{ DB_ENV *env ;

  {
  env = __db_global_values.db_envq.tqh_first;
  if ((unsigned int )env != (unsigned int )((void *)0)) {
    if (env->xa_rmid == rmid) {
      (*envp) = env;
      return (0);
    }
  }
  while ((unsigned int )env != (unsigned int )((void *)0)) {
    if (env->xa_rmid == rmid) {
      while (1) {
        if ((unsigned int )env->links.tqe_next != (unsigned int )((void *)0)) {
          (env->links.tqe_next)->links.tqe_prev = env->links.tqe_prev;
        } else {
          __db_global_values.db_envq.tqh_last = env->links.tqe_prev;
        }
        (*(env->links.tqe_prev)) = env->links.tqe_next;
        break;
      }
      while (1) {
        env->links.tqe_next = __db_global_values.db_envq.tqh_first;
        if ((unsigned int )env->links.tqe_next != (unsigned int )((void *)0)) {
          (__db_global_values.db_envq.tqh_first)->links.tqe_prev = & env->links.tqe_next;
        } else {
          __db_global_values.db_envq.tqh_last = & env->links.tqe_next;
        }
        __db_global_values.db_envq.tqh_first = env;
        env->links.tqe_prev = & __db_global_values.db_envq.tqh_first;
        break;
      }
      (*envp) = env;
      return (0);
    }
    env = env->links.tqe_next;
  }
  return (1);
}
}
int __db_xid_to_txn(DB_ENV *dbenv___0 , XID *xid , size_t *offp ) 
{ struct __txn_detail *td ;
  int tmp ;

  {
  tmp = __txn_map_gid(dbenv___0, (u_int8_t *)(xid->data), & td, offp);
  return (tmp);
}
}
int __db_map_rmid(int rmid , DB_ENV *env ) 
{ 

  {
  env->xa_rmid = rmid;
  while (1) {
    env->links.tqe_next = (struct __db_env *)((void *)0);
    env->links.tqe_prev = __db_global_values.db_envq.tqh_last;
    (*(__db_global_values.db_envq.tqh_last)) = env;
    __db_global_values.db_envq.tqh_last = & env->links.tqe_next;
    break;
  }
  return (0);
}
}
int __db_unmap_rmid(int rmid ) 
{ DB_ENV *e ;

  {
  e = __db_global_values.db_envq.tqh_first;
  while (e->xa_rmid != rmid) {
    e = e->links.tqe_next;
  }
  if ((unsigned int )e == (unsigned int )((void *)0)) {
    return (22);
  }
  while (1) {
    if ((unsigned int )e->links.tqe_next != (unsigned int )((void *)0)) {
      (e->links.tqe_next)->links.tqe_prev = e->links.tqe_prev;
    } else {
      __db_global_values.db_envq.tqh_last = e->links.tqe_prev;
    }
    (*(e->links.tqe_prev)) = e->links.tqe_next;
    break;
  }
  return (0);
}
}
int __db_map_xid(DB_ENV *env , XID *xid , size_t off ) 
{ REGINFO *infop ;
  TXN_DETAIL *td ;

  {
  infop = & ((DB_TXNMGR *)env->tx_handle)->reginfo;
  td = (TXN_DETAIL *)((void *)((u_int8_t *)infop->addr + off));
  if (! ((infop->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(env, & (infop->rp)->mutex);
  }
  memcpy((void * __restrict  )(td->xid), (void const   * __restrict  )(xid->data),
         128U);
  td->bqual = (unsigned int )xid->bqual_length;
  td->gtrid = (unsigned int )xid->gtrid_length;
  td->format = (int )xid->formatID;
  if (! ((infop->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(env, & (infop->rp)->mutex);
  }
  return (0);
}
}
void __db_unmap_xid(DB_ENV *env , XID *xid , size_t off ) 
{ TXN_DETAIL *td ;

  {
  xid = (XID *)((void *)0);
  xid = xid;
  td = (TXN_DETAIL *)((void *)((u_int8_t *)((DB_TXNMGR *)env->tx_handle)->reginfo.addr +
                               off));
  memset((void *)(td->xid), 0, sizeof(td->xid));
  return;
}
}
