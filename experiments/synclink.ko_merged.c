/* Generated by CIL v. 1.3.4 */
/* print_CIL_Input is true */

struct __anonstruct___kernel_fd_set_1 {
   unsigned long fds_bits[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
typedef struct __anonstruct___kernel_fd_set_1 __kernel_fd_set;
typedef void (*__kernel_sighandler_t)(int  );
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;
typedef long long __kernel_loff_t;
struct __anonstruct___kernel_fsid_t_2 {
   int val[2] ;
};
typedef struct __anonstruct___kernel_fsid_t_2 __kernel_fsid_t;
typedef unsigned short umode_t;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef u64 dma_addr_t;
typedef u64 dma64_addr_t;
typedef unsigned short kmem_bufctl_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
typedef __kernel_old_uid_t old_uid_t;
typedef __kernel_old_gid_t old_gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_ptrdiff_t ptrdiff_t;
typedef __kernel_time_t time_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_caddr_t caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
typedef unsigned long sector_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
typedef struct __user_cap_header_struct *cap_user_header_t;
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
typedef struct __user_cap_data_struct *cap_user_data_t;
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
struct __anonstruct_pte_t_3 {
   unsigned long pte_low ;
   unsigned long pte_high ;
};
typedef struct __anonstruct_pte_t_3 pte_t;
struct __anonstruct_pmd_t_4 {
   unsigned long long pmd ;
};
typedef struct __anonstruct_pmd_t_4 pmd_t;
struct __anonstruct_pgd_t_5 {
   unsigned long long pgd ;
};
typedef struct __anonstruct_pgd_t_5 pgd_t;
struct __anonstruct_pgprot_t_6 {
   unsigned long long pgprot ;
};
typedef struct __anonstruct_pgprot_t_6 pgprot_t;
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct revectored_struct {
   unsigned long __map[8] ;
};
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
struct kernel_vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct pt_regs;
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
struct _xmmreg {
   unsigned long element[4] ;
};
struct _fpstate {
   unsigned long cw ;
   unsigned long sw ;
   unsigned long tag ;
   unsigned long ipoff ;
   unsigned long cssel ;
   unsigned long dataoff ;
   unsigned long datasel ;
   struct _fpreg _st[8] ;
   unsigned short status ;
   unsigned short magic ;
   unsigned long _fxsr_env[6] ;
   unsigned long mxcsr ;
   unsigned long reserved ;
   struct _fpxreg _fxsr_st[8] ;
   struct _xmmreg _xmm[8] ;
   unsigned long padding[56] ;
};
struct sigcontext {
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned long edi ;
   unsigned long esi ;
   unsigned long ebp ;
   unsigned long esp ;
   unsigned long ebx ;
   unsigned long edx ;
   unsigned long ecx ;
   unsigned long eax ;
   unsigned long trapno ;
   unsigned long err ;
   unsigned long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned long eflags ;
   unsigned long esp_at_signal ;
   unsigned short ss ;
   unsigned short __ssh ;
   struct _fpstate *fpstate ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
struct info {
   long ___orig_eip ;
   long ___ebx ;
   long ___ecx ;
   long ___edx ;
   long ___esi ;
   long ___edi ;
   long ___ebp ;
   long ___eax ;
   long ___ds ;
   long ___es ;
   long ___orig_eax ;
   long ___eip ;
   long ___cs ;
   long ___eflags ;
   long ___esp ;
   long ___ss ;
   long ___vm86_es ;
   long ___vm86_ds ;
   long ___vm86_fs ;
   long ___vm86_gs ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct __anonstruct_s_8 {
   __u32 a ;
   __u32 b ;
};
union __anonunion_v_7 {
   struct __anonstruct_s_8 s ;
   __u64 u ;
};
struct completion;
struct notifier_block;
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
};
struct sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(int )((20U - 2U * sizeof(long )) - sizeof(int ))] ;
};
struct task_struct;
struct __xchg_dummy {
   unsigned long a[100] ;
};
struct alt_instr {
   __u8 *instr ;
   __u8 *replacement ;
   __u8 cpuid ;
   __u8 instrlen ;
   __u8 replacementlen ;
   __u8 pad ;
};
struct desc_struct {
   unsigned long a ;
   unsigned long b ;
};
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   int cpuid_level ;
   unsigned long x86_capability[7] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int fdiv_bug ;
   int f00f_bug ;
   int coma_bug ;
   unsigned long loops_per_jiffy ;
   unsigned char x86_num_cores ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct tss_struct;
struct i387_fsave_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
   long status ;
};
struct i387_fxsave_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long mxcsr_mask ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
   unsigned char ftop ;
   unsigned char changed ;
   unsigned char lookahead ;
   unsigned char no_update ;
   unsigned char rm ;
   unsigned char alimit ;
   struct info *info ;
   unsigned long entry_eip ;
};
union i387_union {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
};
struct __anonstruct_mm_segment_t_9 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_9 mm_segment_t;
struct thread_struct;
struct tss_struct {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long esp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long esp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long esp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long eip ;
   unsigned long eflags ;
   unsigned long eax ;
   unsigned long ecx ;
   unsigned long edx ;
   unsigned long ebx ;
   unsigned long esp ;
   unsigned long ebp ;
   unsigned long esi ;
   unsigned long edi ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
   unsigned long io_bitmap[(int )(8192U / sizeof(long ) + 1U)] ;
   unsigned long io_bitmap_max ;
   struct thread_struct *io_bitmap_owner ;
   unsigned long __cacheline_filler[35] ;
   unsigned long stack[64] ;
} __attribute__((__packed__)) ;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long esp0 ;
   unsigned long sysenter_cs ;
   unsigned long eip ;
   unsigned long esp ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg[8] ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union i387_union i387 ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_esp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long io_bitmap_max ;
};
struct mm_struct;
struct microcode_header {
   unsigned int hdrver ;
   unsigned int rev ;
   unsigned int date ;
   unsigned int sig ;
   unsigned int cksum ;
   unsigned int ldrver ;
   unsigned int pf ;
   unsigned int datasize ;
   unsigned int totalsize ;
   unsigned int reserved[3] ;
};
struct microcode {
   struct microcode_header hdr ;
   unsigned int bits[0] ;
};
typedef struct microcode microcode_t;
typedef struct microcode_header microcode_header_t;
struct extended_signature {
   unsigned int sig ;
   unsigned int pf ;
   unsigned int cksum ;
};
struct extended_sigtable {
   unsigned int count ;
   unsigned int cksum ;
   unsigned int reserved[3] ;
   struct extended_signature sigs[0] ;
};
struct exec_domain;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   unsigned long flags ;
   unsigned long status ;
   __u32 cpu ;
   __s32 preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
};
struct __anonstruct_atomic_t_10 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_10 atomic_t;
struct __anonstruct_spinlock_t_11 {
   unsigned int volatile   slock ;
};
typedef struct __anonstruct_spinlock_t_11 spinlock_t;
struct __anonstruct_rwlock_t_12 {
   unsigned int volatile   lock ;
};
typedef struct __anonstruct_rwlock_t_12 rwlock_t;
typedef __u32 kernel_cap_t;
struct __anonstruct_seqlock_t_13 {
   unsigned int sequence ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_13 seqlock_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct itimerval;
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
typedef unsigned long long cycles_t;
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
struct rb_node {
   struct rb_node *rb_parent ;
   int rb_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct __anonstruct_cpumask_t_14 {
   unsigned long bits[1] ;
};
typedef struct __anonstruct_cpumask_t_14 cpumask_t;
struct __anonstruct_nodemask_t_15 {
   unsigned long bits[1] ;
};
typedef struct __anonstruct_nodemask_t_15 nodemask_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key );
struct __wait_queue {
   unsigned int flags ;
   struct task_struct *task ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
};
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct rw_semaphore;
struct rwsem_waiter;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct semaphore {
   atomic_t count ;
   int sleepers ;
   wait_queue_head_t wait ;
};
struct pt_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   int xds ;
   int xes ;
   long orig_eax ;
   long eip ;
   int xcs ;
   long eflags ;
   long esp ;
   int xss ;
};
struct __anonstruct_mm_context_t_16 {
   int size ;
   struct semaphore sem ;
   void *ldt ;
};
typedef struct __anonstruct_mm_context_t_16 mm_context_t;
typedef unsigned long cputime_t;
typedef u64 cputime64_t;
struct __anonstruct___reserved_01_17 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_02_18 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_id_19 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_version_20 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_03_21 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_04_22 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_05_23 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_06_24 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_tpr_25 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_apr_26 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_ppr_27 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_eoi_28 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_07_29 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_ldr_30 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_dfr_31 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_svr_32 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_isr_33 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_tmr_34 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_irr_35 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_error_bits_37 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_all_errors_38 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
union __anonunion_esr_36 {
   struct __anonstruct_error_bits_37 error_bits ;
   struct __anonstruct_all_errors_38 all_errors ;
};
struct __anonstruct___reserved_08_39 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_09_40 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_10_41 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_11_42 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_12_43 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_13_44 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_14_45 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_icr1_46 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
union __anonunion_dest_48 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
struct __anonstruct_icr2_47 {
   union __anonunion_dest_48 dest ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_timer_49 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_thermal_50 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_pc_51 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_lint0_52 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_lint1_53 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_error_54 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_timer_icr_55 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_timer_ccr_56 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_16_57 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_17_58 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_18_59 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_19_60 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_timer_dcr_61 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_20_62 {
   unsigned int __reserved[4] ;
};
struct local_apic {
   struct __anonstruct___reserved_01_17 __reserved_01 ;
   struct __anonstruct___reserved_02_18 __reserved_02 ;
   struct __anonstruct_id_19 id ;
   struct __anonstruct_version_20  const  version ;
   struct __anonstruct___reserved_03_21 __reserved_03 ;
   struct __anonstruct___reserved_04_22 __reserved_04 ;
   struct __anonstruct___reserved_05_23 __reserved_05 ;
   struct __anonstruct___reserved_06_24 __reserved_06 ;
   struct __anonstruct_tpr_25 tpr ;
   struct __anonstruct_apr_26  const  apr ;
   struct __anonstruct_ppr_27  const  ppr ;
   struct __anonstruct_eoi_28 eoi ;
   struct __anonstruct___reserved_07_29 __reserved_07 ;
   struct __anonstruct_ldr_30 ldr ;
   struct __anonstruct_dfr_31 dfr ;
   struct __anonstruct_svr_32 svr ;
   struct __anonstruct_isr_33 isr[8] ;
   struct __anonstruct_tmr_34 tmr[8] ;
   struct __anonstruct_irr_35 irr[8] ;
   union __anonunion_esr_36 esr ;
   struct __anonstruct___reserved_08_39 __reserved_08 ;
   struct __anonstruct___reserved_09_40 __reserved_09 ;
   struct __anonstruct___reserved_10_41 __reserved_10 ;
   struct __anonstruct___reserved_11_42 __reserved_11 ;
   struct __anonstruct___reserved_12_43 __reserved_12 ;
   struct __anonstruct___reserved_13_44 __reserved_13 ;
   struct __anonstruct___reserved_14_45 __reserved_14 ;
   struct __anonstruct_icr1_46 icr1 ;
   struct __anonstruct_icr2_47 icr2 ;
   struct __anonstruct_lvt_timer_49 lvt_timer ;
   struct __anonstruct_lvt_thermal_50 lvt_thermal ;
   struct __anonstruct_lvt_pc_51 lvt_pc ;
   struct __anonstruct_lvt_lint0_52 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_53 lvt_lint1 ;
   struct __anonstruct_lvt_error_54 lvt_error ;
   struct __anonstruct_timer_icr_55 timer_icr ;
   struct __anonstruct_timer_ccr_56  const  timer_ccr ;
   struct __anonstruct___reserved_16_57 __reserved_16 ;
   struct __anonstruct___reserved_17_58 __reserved_17 ;
   struct __anonstruct___reserved_18_59 __reserved_18 ;
   struct __anonstruct___reserved_19_60 __reserved_19 ;
   struct __anonstruct_timer_dcr_61 timer_dcr ;
   struct __anonstruct___reserved_20_62 __reserved_20 ;
} __attribute__((__packed__)) ;
enum km_type {
    __KM_FENCE_0 = 0,
    KM_BOUNCE_READ = 1,
    __KM_FENCE_1 = 2,
    KM_SKB_SUNRPC_DATA = 3,
    __KM_FENCE_2 = 4,
    KM_SKB_DATA_SOFTIRQ = 5,
    __KM_FENCE_3 = 6,
    KM_USER0 = 7,
    __KM_FENCE_4 = 8,
    KM_USER1 = 9,
    __KM_FENCE_5 = 10,
    KM_BIO_SRC_IRQ = 11,
    __KM_FENCE_6 = 12,
    KM_BIO_DST_IRQ = 13,
    __KM_FENCE_7 = 14,
    KM_PTE0 = 15,
    __KM_FENCE_8 = 16,
    KM_PTE1 = 17,
    __KM_FENCE_9 = 18,
    KM_IRQ0 = 19,
    __KM_FENCE_10 = 20,
    KM_IRQ1 = 21,
    __KM_FENCE_11 = 22,
    KM_SOFTIRQ0 = 23,
    __KM_FENCE_12 = 24,
    KM_SOFTIRQ1 = 25,
    __KM_FENCE_13 = 26,
    KM_TYPE_NR = 27
};
enum fixed_addresses {
    FIX_HOLE = 0,
    FIX_VSYSCALL = 1,
    FIX_APIC_BASE = 2,
    FIX_IO_APIC_BASE_0 = 3,
    FIX_IO_APIC_BASE_END = 10,
    FIX_CYCLONE_TIMER = 11,
    FIX_KMAP_BEGIN = 12,
    FIX_KMAP_END = 227,
    __end_of_permanent_fixed_addresses = 228,
    FIX_BTMAP_END = 228,
    FIX_BTMAP_BEGIN = 243,
    FIX_WP_TEST = 244,
    __end_of_fixed_addresses = 245
};
struct intel_mp_floating {
   char mpf_signature[4] ;
   unsigned long mpf_physptr ;
   unsigned char mpf_length ;
   unsigned char mpf_specification ;
   unsigned char mpf_checksum ;
   unsigned char mpf_feature1 ;
   unsigned char mpf_feature2 ;
   unsigned char mpf_feature3 ;
   unsigned char mpf_feature4 ;
   unsigned char mpf_feature5 ;
};
struct mp_config_table {
   char mpc_signature[4] ;
   unsigned short mpc_length ;
   char mpc_spec ;
   char mpc_checksum ;
   char mpc_oem[8] ;
   char mpc_productid[12] ;
   unsigned long mpc_oemptr ;
   unsigned short mpc_oemsize ;
   unsigned short mpc_oemcount ;
   unsigned long mpc_lapic ;
   unsigned long reserved ;
};
struct mpc_config_processor {
   unsigned char mpc_type ;
   unsigned char mpc_apicid ;
   unsigned char mpc_apicver ;
   unsigned char mpc_cpuflag ;
   unsigned long mpc_cpufeature ;
   unsigned long mpc_featureflag ;
   unsigned long mpc_reserved[2] ;
};
struct mpc_config_bus {
   unsigned char mpc_type ;
   unsigned char mpc_busid ;
   unsigned char mpc_bustype[6]  __attribute__((__packed__)) ;
};
struct mpc_config_ioapic {
   unsigned char mpc_type ;
   unsigned char mpc_apicid ;
   unsigned char mpc_apicver ;
   unsigned char mpc_flags ;
   unsigned long mpc_apicaddr ;
};
struct mpc_config_intsrc {
   unsigned char mpc_type ;
   unsigned char mpc_irqtype ;
   unsigned short mpc_irqflag ;
   unsigned char mpc_srcbus ;
   unsigned char mpc_srcbusirq ;
   unsigned char mpc_dstapic ;
   unsigned char mpc_dstirq ;
};
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
};
struct mpc_config_lintsrc {
   unsigned char mpc_type ;
   unsigned char mpc_irqtype ;
   unsigned short mpc_irqflag ;
   unsigned char mpc_srcbusid ;
   unsigned char mpc_srcbusirq ;
   unsigned char mpc_destapic ;
   unsigned char mpc_destapiclint ;
};
struct mp_config_oemtable {
   char oem_signature[4] ;
   unsigned short oem_length ;
   char oem_rev ;
   char oem_checksum ;
   char mpc_oem[8] ;
};
struct mpc_config_translation {
   unsigned char mpc_type ;
   unsigned char trans_len ;
   unsigned char trans_type ;
   unsigned char trans_quad ;
   unsigned char trans_global ;
   unsigned char trans_local ;
   unsigned short trans_reserved ;
};
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3,
    MP_BUS_MCA = 4,
    MP_BUS_NEC98 = 5
};
struct physid_mask {
   unsigned long mask[8] ;
};
typedef struct physid_mask physid_mask_t;
struct __anonstruct_bits_63 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_63 bits ;
};
struct __anonstruct_bits_64 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_64 bits ;
};
struct __anonstruct_bits_65 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_65 bits ;
};
struct __anonstruct_bits_66 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_66 bits ;
};
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
};
struct __anonstruct_physical_68 {
   __u32 __reserved_1 : 24 ;
   __u32 physical_dest : 4 ;
   __u32 __reserved_2 : 4 ;
};
struct __anonstruct_logical_69 {
   __u32 __reserved_1 : 24 ;
   __u32 logical_dest : 8 ;
};
union __anonunion_dest_67 {
   struct __anonstruct_physical_68 physical ;
   struct __anonstruct_logical_69 logical ;
};
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   union __anonunion_dest_67 dest ;
} __attribute__((__packed__)) ;
typedef int pm_request_t;
typedef int pm_dev_t;
enum __anonenum_70 {
    PM_SYS_UNKNOWN = 0,
    PM_SYS_KBC = 1104151299,
    PM_SYS_COM = 1104151808,
    PM_SYS_IRDA = 1104151824,
    PM_SYS_FDC = 1104152320,
    PM_SYS_VGA = 1104152832,
    PM_SYS_PCMCIA = 1104154112
};
struct pm_dev;
typedef int (*pm_callback)(struct pm_dev *dev , pm_request_t rqst , void *data );
struct pm_dev {
   pm_dev_t type ;
   unsigned long id ;
   int (*callback)(struct pm_dev *dev , pm_request_t rqst , void *data ) ;
   void *data ;
   unsigned long flags ;
   unsigned long state ;
   unsigned long prev_state ;
   struct list_head entry ;
};
typedef int suspend_state_t;
typedef int suspend_disk_method_t;
struct pm_ops {
   suspend_disk_method_t pm_disk_mode ;
   int (*prepare)(suspend_state_t state ) ;
   int (*enter)(suspend_state_t state ) ;
   int (*finish)(suspend_state_t state ) ;
};
struct device;
typedef u32 pm_message_t;
struct dev_pm_info {
   pm_message_t power_state ;
   pm_message_t prev_state ;
   void *saved_state ;
   atomic_t pm_users ;
   struct device *pm_parent ;
   struct list_head entry ;
};
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
struct kern_ipc_perm {
   spinlock_t lock ;
   int deleted ;
   key_t key ;
   uid_t uid ;
   gid_t gid ;
   uid_t cuid ;
   gid_t cgid ;
   mode_t mode ;
   unsigned long seq ;
   void *security ;
};
struct sem;
struct sem_queue;
struct sem_undo;
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
struct seminfo;
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
struct sem {
   int semval ;
   int sempid ;
};
struct sem_array {
   struct kern_ipc_perm sem_perm ;
   time_t sem_otime ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned long sem_nsems ;
};
struct sem_queue {
   struct sem_queue *next ;
   struct sem_queue **prev ;
   struct task_struct *sleeper ;
   struct sem_undo *undo ;
   int pid ;
   int status ;
   struct sem_array *sma ;
   int id ;
   struct sembuf *sops ;
   int nsops ;
   int alter ;
};
struct sem_undo {
   struct sem_undo *proc_next ;
   struct sem_undo *id_next ;
   int semid ;
   short *semadj ;
};
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct sem_undo *proc_list ;
};
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct siginfo;
typedef unsigned long old_sigset_t;
struct __anonstruct_sigset_t_71 {
   unsigned long sig[2] ;
};
typedef struct __anonstruct_sigset_t_71 sigset_t;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct old_sigaction {
   __sighandler_t sa_handler ;
   old_sigset_t sa_mask ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
typedef struct sigaltstack stack_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_73 {
   pid_t _pid ;
   uid_t _uid ;
};
struct __anonstruct__timer_74 {
   timer_t _tid ;
   int _overrun ;
   char _pad[(int )(sizeof(uid_t ) - sizeof(int ))] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_75 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_76 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
struct __anonstruct__sigfault_77 {
   void *_addr ;
};
struct __anonstruct__sigpoll_78 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_72 {
   int _pad[(int )((128U - 3U * sizeof(int )) / sizeof(int ))] ;
   struct __anonstruct__kill_73 _kill ;
   struct __anonstruct__timer_74 _timer ;
   struct __anonstruct__rt_75 _rt ;
   struct __anonstruct__sigchld_76 _sigchld ;
   struct __anonstruct__sigfault_77 _sigfault ;
   struct __anonstruct__sigpoll_78 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_72 _sifields ;
};
typedef struct siginfo siginfo_t;
struct __anonstruct__sigev_thread_80 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
union __anonunion__sigev_un_79 {
   int _pad[(int )((64U - (sizeof(int ) * 2U + sizeof(sigval_t ))) / sizeof(int ))] ;
   int _tid ;
   struct __anonstruct__sigev_thread_80 _sigev_thread ;
};
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_79 _sigev_un ;
};
typedef struct sigevent sigevent_t;
struct user_struct;
struct sigqueue {
   struct list_head list ;
   spinlock_t *lock ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct dentry;
struct vfsmount;
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct dentry *root ;
   struct dentry *pwd ;
   struct dentry *altroot ;
   struct vfsmount *rootmnt ;
   struct vfsmount *pwdmnt ;
   struct vfsmount *altrootmnt ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_TGID = 1,
    PIDTYPE_PGID = 2,
    PIDTYPE_SID = 3,
    PIDTYPE_MAX = 4
};
struct pid {
   int nr ;
   struct hlist_node pid_chain ;
   struct list_head pid_list ;
};
struct kmem_cache_s;
typedef struct kmem_cache_s kmem_cache_t;
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
struct free_area {
   struct list_head free_list ;
   unsigned long nr_free ;
};
struct pglist_data;
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct per_cpu_pages {
   int count ;
   int low ;
   int high ;
   int batch ;
   struct list_head list ;
};
struct per_cpu_pageset {
   struct per_cpu_pages pcp[2] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct page;
struct zone {
   unsigned long free_pages ;
   unsigned long pages_min ;
   unsigned long pages_low ;
   unsigned long pages_high ;
   unsigned long lowmem_reserve[3] ;
   struct per_cpu_pageset pageset[8] ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct list_head active_list ;
   struct list_head inactive_list ;
   unsigned long nr_scan_active ;
   unsigned long nr_scan_inactive ;
   unsigned long nr_active ;
   unsigned long nr_inactive ;
   unsigned long pages_scanned ;
   int all_unreclaimable ;
   int temp_priority ;
   int prev_priority ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_size ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   struct page *zone_mem_map ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char *name ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct zonelist {
   struct zone *zones[4] ;
};
struct bootmem_data;
struct pglist_data {
   struct zone node_zones[3] ;
   struct zonelist node_zonelists[3] ;
   int nr_zones ;
   struct page *node_mem_map ;
   struct bootmem_data *bdata ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   struct pglist_data *pgdat_next ;
   wait_queue_head_t kswapd_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
};
typedef struct pglist_data pg_data_t;
struct ctl_table;
struct file;
struct vm_area_struct;
struct cache_sizes {
   size_t cs_size ;
   kmem_cache_t *cs_cachep ;
   kmem_cache_t *cs_dmacachep ;
};
struct percpu_data {
   void *ptrs[8] ;
   void *blkp ;
};
struct __anonstruct_seccomp_t_81 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_81 seccomp_t;
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct tvec_t_base_s;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   spinlock_t lock ;
   unsigned long magic ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_t_base_s *base ;
};
struct sched_param {
   int sched_priority ;
};
typedef struct task_struct task_t;
struct namespace;
struct workqueue_struct;
struct work_struct {
   unsigned long pending ;
   struct list_head entry ;
   void (*func)(void * ) ;
   void *data ;
   void *wq_data ;
   struct timer_list timer ;
};
typedef unsigned long aio_context_t;
enum __anonenum_82 {
    IOCB_CMD_PREAD = 0,
    IOCB_CMD_PWRITE = 1,
    IOCB_CMD_FSYNC = 2,
    IOCB_CMD_FDSYNC = 3,
    IOCB_CMD_NOOP = 6
};
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
struct iocb {
   __u64 aio_data ;
   __u32 aio_key ;
   __u32 aio_reserved1 ;
   __u16 aio_lio_opcode ;
   __s16 aio_reqprio ;
   __u32 aio_fildes ;
   __u64 aio_buf ;
   __u64 aio_nbytes ;
   __s64 aio_offset ;
   __u64 aio_reserved2 ;
   __u64 aio_reserved3 ;
};
struct kioctx;
union __anonunion_ki_obj_83 {
   void *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   struct list_head ki_list ;
   union __anonunion_ki_obj_83 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   wait_queue_t ki_wait ;
   long ki_retried ;
   long ki_kicked ;
   long ki_queued ;
   void *private ;
};
struct aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct io_event io_events[0] ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct kioctx *next ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct work_struct wq ;
};
typedef unsigned long mm_counter_t;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct vm_area_struct *area ) ;
   unsigned long mmap_base ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   mm_counter_t _rss ;
   mm_counter_t _anon_rss ;
   unsigned long saved_auxv[42] ;
   unsigned int dumpable : 1 ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned long swap_token_time ;
   char recent_pagein ;
   int core_waiters ;
   struct completion *core_startup_done ;
   struct completion core_done ;
   rwlock_t ioctx_list_lock ;
   struct kioctx *ioctx_list ;
   struct kioctx default_kioctx ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
};
struct tty_struct;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   task_t *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   struct task_struct *group_exit_task ;
   int notify_count ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct timer_list real_timer ;
   unsigned long it_real_value ;
   unsigned long it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   pid_t pgrp ;
   pid_t tty_old_pgrp ;
   pid_t session ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long long sched_time ;
   struct rlimit rlim[15] ;
   struct list_head cpu_timers[3] ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct list_head uidhash_list ;
   uid_t uid ;
};
struct prio_array;
typedef struct prio_array prio_array_t;
struct backing_dev_info;
struct reclaim_state;
enum idle_type {
    SCHED_IDLE = 0,
    NOT_IDLE = 1,
    NEWLY_IDLE = 2,
    MAX_IDLE_TYPES = 3
};
struct sched_group {
   struct sched_group *next ;
   cpumask_t cpumask ;
   unsigned long cpu_power ;
};
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_group *groups ;
   cpumask_t span ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned long long cache_hot_time ;
   unsigned int cache_nice_tries ;
   unsigned int per_cpu_gain ;
   int flags ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
};
struct io_context;
struct cpuset;
struct group_info {
   int ngroups ;
   atomic_t usage ;
   gid_t small_block[32] ;
   int nblocks ;
   gid_t *blocks[0] ;
};
struct audit_context;
struct mempolicy;
struct linux_binfmt;
struct files_struct;
struct task_struct {
   long volatile   state ;
   struct thread_info *thread_info ;
   atomic_t usage ;
   unsigned long flags ;
   unsigned long ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   struct list_head run_list ;
   prio_array_t *array ;
   unsigned long sleep_avg ;
   unsigned long long timestamp ;
   unsigned long long last_ran ;
   unsigned long long sched_time ;
   int activated ;
   unsigned long policy ;
   cpumask_t cpus_allowed ;
   unsigned int time_slice ;
   unsigned int first_time_slice ;
   struct list_head tasks ;
   struct list_head ptrace_children ;
   struct list_head ptrace_list ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   long exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct pid pids[4] ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   unsigned long rt_priority ;
   cputime_t utime ;
   cputime_t stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   unsigned long long it_sched_expires ;
   struct list_head cpu_timers[3] ;
   uid_t uid ;
   uid_t euid ;
   uid_t suid ;
   uid_t fsuid ;
   gid_t gid ;
   gid_t egid ;
   gid_t sgid ;
   gid_t fsgid ;
   struct group_info *group_info ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   unsigned int keep_capabilities : 1 ;
   struct user_struct *user ;
   int oomkilladj ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct namespace *namespace ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   void *security ;
   struct audit_context *audit_context ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t proc_lock ;
   spinlock_t switch_lock ;
   void *journal_info ;
   struct reclaim_state *reclaim_state ;
   struct dentry *proc_dentry ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   wait_queue_t *io_wait ;
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   clock_t acct_stimexpd ;
};
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[(int )(8192U / sizeof(long ))] ;
};
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned long st_size ;
   unsigned long st_atime ;
   unsigned long st_mtime ;
   unsigned long st_ctime ;
};
struct stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned long st_rdev ;
   unsigned long st_size ;
   unsigned long st_blksize ;
   unsigned long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct stat64 {
   unsigned long long st_dev ;
   unsigned char __pad0[4] ;
   unsigned long __st_ino ;
   unsigned int st_mode ;
   unsigned int st_nlink ;
   unsigned long st_uid ;
   unsigned long st_gid ;
   unsigned long long st_rdev ;
   unsigned char __pad3[4] ;
   long long st_size ;
   unsigned long st_blksize ;
   unsigned long st_blocks ;
   unsigned long __pad4 ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned int st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   unsigned long long st_ino ;
};
struct kstat {
   unsigned long ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long blocks ;
};
struct user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
struct user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
struct user_regs_struct {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   unsigned short ds ;
   unsigned short __ds ;
   unsigned short es ;
   unsigned short __es ;
   unsigned short fs ;
   unsigned short __fs ;
   unsigned short gs ;
   unsigned short __gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __cs ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ss ;
};
struct user_pt_regs;
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   struct user_pt_regs *u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   int u_debugreg[8] ;
};
struct oldold_utsname {
   char sysname[9] ;
   char nodename[9] ;
   char release[9] ;
   char version[9] ;
   char machine[9] ;
};
struct old_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
};
struct new_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
typedef unsigned long elf_greg_t;
typedef elf_greg_t elf_gregset_t[(int )(sizeof(struct user_regs_struct ) / sizeof(elf_greg_t ))];
typedef struct user_i387_struct elf_fpregset_t;
typedef struct user_fxsr_struct elf_fpxregset_t;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Off;
typedef __s32 Elf32_Sword;
typedef __u32 Elf32_Word;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s16 Elf64_SHalf;
typedef __u64 Elf64_Off;
typedef __s32 Elf64_Sword;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef __s64 Elf64_Sxword;
union __anonunion_d_un_84 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_84 d_un ;
};
typedef struct dynamic Elf32_Dyn;
union __anonunion_d_un_86 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
struct __anonstruct_Elf64_Dyn_85 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_86 d_un ;
};
typedef struct __anonstruct_Elf64_Dyn_85 Elf64_Dyn;
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
typedef struct elf32_rel Elf32_Rel;
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
typedef struct elf64_rel Elf64_Rel;
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
typedef struct elf32_rela Elf32_Rela;
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
typedef struct elf64_rela Elf64_Rela;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
typedef struct elf32_hdr Elf32_Ehdr;
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
typedef struct elf64_hdr Elf64_Ehdr;
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
typedef struct elf32_phdr Elf32_Phdr;
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
typedef struct elf64_phdr Elf64_Phdr;
struct __anonstruct_Elf32_Shdr_87 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
typedef struct __anonstruct_Elf32_Shdr_87 Elf32_Shdr;
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
typedef struct elf64_shdr Elf64_Shdr;
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
typedef struct elf32_note Elf32_Nhdr;
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
typedef struct elf64_note Elf64_Nhdr;
struct kobject;
struct module;
struct attribute {
   char *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char *name ;
   struct attribute **attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , char * , loff_t  , size_t  ) ;
   ssize_t (*write)(struct kobject * , char * , loff_t  , size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct sysfs_dirent {
   atomic_t s_count ;
   struct list_head s_sibling ;
   struct list_head s_children ;
   void *s_element ;
   int s_type ;
   umode_t s_mode ;
   struct dentry *s_dentry ;
};
struct kref {
   atomic_t refcount ;
};
typedef int kobject_action_t;
enum kobject_action {
    KOBJ_ADD = 1,
    KOBJ_REMOVE = 2,
    KOBJ_CHANGE = 3,
    KOBJ_MOUNT = 4,
    KOBJ_UMOUNT = 5,
    KOBJ_OFFLINE = 6,
    KOBJ_ONLINE = 7
};
struct kset;
struct kobj_type;
struct kobject {
   char *k_name ;
   char name[20] ;
   struct kref kref ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct dentry *dentry ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kset_hotplug_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*hotplug)(struct kset *kset , struct kobject *kobj , char **envp , int num_envp ,
                  char *buffer , int buffer_size ) ;
};
struct subsystem;
struct kset {
   struct subsystem *subsys ;
   struct kobj_type *ktype ;
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_hotplug_ops *hotplug_ops ;
};
struct subsystem {
   struct kset kset ;
   struct rw_semaphore rwsem ;
};
struct subsys_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct subsystem * , char * ) ;
   ssize_t (*store)(struct subsystem * , char const   * , size_t  ) ;
};
struct kernel_param;
typedef int (*param_set_fn)(char const   *val , struct kernel_param *kp );
typedef int (*param_get_fn)(char *buffer , struct kernel_param *kp );
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   void *arg ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
struct __anonstruct_local_t_88 {
   unsigned long volatile   counter ;
};
typedef struct __anonstruct_local_t_88 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct modversion_info {
   unsigned long crc ;
   char name[(int )(64U - sizeof(unsigned long ))] ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
};
struct exception_table_entry;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
};
struct module_sect_attr {
   struct module_attribute mattr ;
   char name[32] ;
   unsigned long address ;
};
struct module_sect_attrs {
   struct attribute_group grp ;
   struct module_sect_attr attrs[0] ;
};
struct module_param_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[(int )(64U - sizeof(unsigned long ))] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct kernel_symbol  const  *syms ;
   unsigned int num_syms ;
   unsigned long const   *crcs ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned int num_gpl_syms ;
   unsigned long const   *gpl_crcs ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned long init_size ;
   unsigned long core_size ;
   unsigned long init_text_size ;
   unsigned long core_text_size ;
   struct mod_arch_specific arch ;
   int unsafe ;
   int license_gplok ;
   Elf32_Sym *symtab ;
   unsigned long num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   void *percpu ;
   char *args ;
};
struct device_driver;
struct obsolete_modparm {
   char name[64] ;
   char type[(int )(64U - sizeof(void *))] ;
   void *addr ;
};
struct hw_interrupt_type {
   char const   *typename ;
   unsigned int (*startup)(unsigned int irq ) ;
   void (*shutdown)(unsigned int irq ) ;
   void (*enable)(unsigned int irq ) ;
   void (*disable)(unsigned int irq ) ;
   void (*ack)(unsigned int irq ) ;
   void (*end)(unsigned int irq ) ;
   void (*set_affinity)(unsigned int irq , cpumask_t dest ) ;
};
typedef struct hw_interrupt_type hw_irq_controller;
struct irqaction;
struct irq_desc {
   hw_irq_controller *handler ;
   void *handler_data ;
   struct irqaction *action ;
   unsigned int status ;
   unsigned int depth ;
   unsigned int irq_count ;
   unsigned int irqs_unhandled ;
   spinlock_t lock ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct irq_desc irq_desc_t;
struct proc_dir_entry;
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
};
struct __anonstruct_irq_cpustat_t_89 {
   unsigned int __softirq_pending ;
   unsigned long idle_timestamp ;
   unsigned int __nmi_count ;
   unsigned int apic_timer_irqs ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct __anonstruct_irq_cpustat_t_89 irq_cpustat_t;
typedef int irqreturn_t;
struct irqaction {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   unsigned long flags ;
   cpumask_t mask ;
   char const   *name ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   struct proc_dir_entry *dir ;
};
enum __anonenum_90 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    SCSI_SOFTIRQ = 4,
    TASKLET_SOFTIRQ = 5
};
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
   void *data ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
enum __anonenum_91 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
};
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct ieee1394_device_id {
   __u32 match_flags ;
   __u32 vendor_id ;
   __u32 model_id ;
   __u32 specifier_id ;
   __u32 version ;
   kernel_ulong_t driver_data ;
};
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   kernel_ulong_t driver_info ;
};
struct ccw_device_id {
   __u16 match_flags ;
   __u16 cu_type ;
   __u16 dev_type ;
   __u8 cu_model ;
   __u8 dev_model ;
   kernel_ulong_t driver_info ;
};
struct pnp_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
};
struct __anonstruct_devs_92 {
   __u8 id[8] ;
};
struct pnp_card_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
   struct __anonstruct_devs_92 devs[8] ;
};
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
enum __anonenum_93 {
    SUSPEND_NOTIFY = 0,
    SUSPEND_SAVE_STATE = 1,
    SUSPEND_DISABLE = 2,
    SUSPEND_POWER_DOWN = 3
};
enum __anonenum_94 {
    RESUME_POWER_ON = 0,
    RESUME_RESTORE_STATE = 1,
    RESUME_ENABLE = 2
};
struct class;
struct class_device;
struct class_simple;
struct bus_attribute;
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char *name ;
   struct subsystem subsys ;
   struct kset drivers ;
   struct kset devices ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*hotplug)(struct device *dev , char **envp , int num_envp , char *buffer ,
                  int buffer_size ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
};
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char *buf ) ;
   ssize_t (*store)(struct bus_type * , char const   *buf , size_t count ) ;
};
struct device_driver {
   char *name ;
   struct bus_type *bus ;
   struct completion unloaded ;
   struct kobject kobj ;
   struct list_head devices ;
   struct module *owner ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state , u32 level ) ;
   int (*resume)(struct device *dev , u32 level ) ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char *buf ) ;
   ssize_t (*store)(struct device_driver * , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class_device_attribute;
struct class {
   char *name ;
   struct subsystem subsys ;
   struct list_head children ;
   struct list_head interfaces ;
   struct semaphore sem ;
   struct class_attribute *class_attrs ;
   struct class_device_attribute *class_dev_attrs ;
   int (*hotplug)(struct class_device *dev , char **envp , int num_envp , char *buffer ,
                  int buffer_size ) ;
   void (*release)(struct class_device *dev ) ;
   void (*class_release)(struct class *class ) ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , char *buf ) ;
   ssize_t (*store)(struct class * , char const   *buf , size_t count ) ;
};
struct class_device {
   struct list_head node ;
   struct kobject kobj ;
   struct class *class ;
   dev_t devt ;
   struct device *dev ;
   void *class_data ;
   char class_id[20] ;
};
struct class_device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class_device * , char *buf ) ;
   ssize_t (*store)(struct class_device * , char const   *buf , size_t count ) ;
};
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add)(struct class_device * ) ;
   void (*remove)(struct class_device * ) ;
};
struct dma_coherent_mem;
struct device {
   struct list_head node ;
   struct list_head bus_list ;
   struct list_head driver_list ;
   struct list_head children ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   void (*release)(struct device *dev ) ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , char *buf ) ;
   ssize_t (*store)(struct device *dev , char const   *buf , size_t count ) ;
};
struct platform_device {
   char *name ;
   u32 id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
};
enum pci_mmap_state {
    pci_mmap_io = 0,
    pci_mmap_mem = 1
};
typedef int pci_power_t;
struct pci_bus;
struct pci_driver;
struct pci_dev {
   struct list_head global_list ;
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 hdr_type ;
   u8 rom_base_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   pci_power_t current_state ;
   struct device dev ;
   unsigned short vendor_compatible[4] ;
   unsigned short device_compatible[4] ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_enabled : 1 ;
   unsigned int is_busmaster : 1 ;
   u32 saved_config_space[16] ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   char pretty_name[255] ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct resource *resource[4] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   unsigned short pad2 ;
   struct device *bridge ;
   struct class_device class_dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
};
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
struct pci_raw_ops {
   int (*read)(unsigned int domain , unsigned int bus , unsigned int devfn , int reg ,
               int len , u32 *val ) ;
   int (*write)(unsigned int domain , unsigned int bus , unsigned int devfn , int reg ,
                int len , u32 val ) ;
};
struct pci_bus_region {
   unsigned long start ;
   unsigned long end ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
   unsigned int use_driver_data : 1 ;
};
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct module *owner ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct vm_struct {
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   unsigned long phys_addr ;
   struct vm_struct *next ;
};
struct scatterlist {
   struct page *page ;
   unsigned int offset ;
   dma_addr_t dma_address ;
   unsigned int length ;
};
struct dma_pool;
struct msix_entry {
   u16 vector ;
   u16 entry ;
};
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
struct prio_tree_iter {
   struct prio_tree_node *cur ;
   unsigned long mask ;
   unsigned long value ;
   int size_level ;
   struct prio_tree_root *root ;
   unsigned long r_index ;
   unsigned long h_index ;
};
struct files_stat_struct {
   int nr_files ;
   int nr_free_files ;
   int max_files ;
};
struct inodes_stat_t {
   int nr_inodes ;
   int nr_unused ;
   int dummy[5] ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
struct rcu_ctrlblk {
   long cur ;
   long completed ;
   int next_pending ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
struct rcu_data {
   long quiescbatch ;
   int passed_quiesc ;
   int qs_pending ;
   long batch ;
   struct rcu_head *nxtlist ;
   struct rcu_head **nxttail ;
   struct rcu_head *curlist ;
   struct rcu_head **curtail ;
   struct rcu_head *donelist ;
   struct rcu_head **donetail ;
   int cpu ;
};
struct nameidata;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
struct dentry_stat_t {
   int nr_dentry ;
   int nr_unused ;
   int age_limit ;
   int want_pages ;
   int dummy[2] ;
};
struct dcookie_struct;
struct inode;
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   struct inode *d_inode ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   struct rcu_head d_rcu ;
   struct dcookie_struct *d_cookie ;
   struct hlist_node d_hash ;
   int d_mounted ;
   unsigned char d_iname[36] ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   int gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct iovec;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct buffer_head;
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
typedef int get_blocks_t(struct inode *inode , sector_t iblock , unsigned long max_blocks ,
                         struct buffer_head *bh_result , int create );
typedef void dio_iodone_t(struct inode *inode , loff_t offset , ssize_t bytes , void *private );
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   unsigned int ia_attr_flags ;
};
typedef __kernel_uid32_t qid_t;
typedef __u64 qsize_t;
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
typedef struct fs_disk_quota fs_disk_quota_t;
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
typedef struct fs_quota_stat fs_quota_stat_t;
struct v1_mem_dqinfo {

};
struct v2_mem_dqinfo {
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
};
struct mem_dqblk {
   __u32 dqb_bhardlimit ;
   __u32 dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   __u32 dqb_ihardlimit ;
   __u32 dqb_isoftlimit ;
   __u32 dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
union __anonunion_u_95 {
   struct v1_mem_dqinfo v1_i ;
   struct v2_mem_dqinfo v2_i ;
};
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   union __anonunion_u_95 u ;
};
struct dqstats {
   int lookups ;
   int drops ;
   int reads ;
   int writes ;
   int cache_hits ;
   int allocated_dquots ;
   int free_dquots ;
   int syncs ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct semaphore dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , unsigned long  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , unsigned long  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct semaphore dqio_sem ;
   struct semaphore dqonoff_sem ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct vfsmount *mnt[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
struct address_space;
struct writeback_control;
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*prepare_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   int (*commit_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   int (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , int  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   rwlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   int bd_openers ;
   struct semaphore bd_sem ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
};
struct inode_operations;
struct file_operations;
struct file_lock;
struct cdev;
struct dnotify_struct;
union __anonunion_u_96 {
   void *generic_ip ;
};
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   umode_t i_mode ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   unsigned long i_blksize ;
   unsigned long i_version ;
   unsigned long i_blocks ;
   unsigned short i_bytes ;
   spinlock_t i_lock ;
   struct semaphore i_sem ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations *i_op ;
   struct file_operations *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   union __anonunion_u_96 u ;
   seqcount_t i_size_seqcount ;
};
struct fown_struct {
   rwlock_t lock ;
   int pid ;
   uid_t uid ;
   uid_t euid ;
   void *security ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned long size ;
   unsigned long flags ;
   unsigned long cache_hit ;
   unsigned long prev_page ;
   unsigned long ahead_start ;
   unsigned long ahead_size ;
   unsigned long ra_pages ;
   unsigned long mmap_hit ;
   unsigned long mmap_miss ;
};
struct file {
   struct list_head f_list ;
   struct dentry *f_dentry ;
   struct vfsmount *f_vfsmnt ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   int f_error ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   unsigned int f_uid ;
   unsigned int f_gid ;
   struct file_ra_state f_ra ;
   size_t f_maxcount ;
   unsigned long f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_insert)(struct file_lock * ) ;
   void (*fl_remove)(struct file_lock * ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
typedef u32 rpc_authflavor_t;
enum rpc_auth_flavors {
    RPC_AUTH_NULL = 0,
    RPC_AUTH_UNIX = 1,
    RPC_AUTH_SHORT = 2,
    RPC_AUTH_DES = 3,
    RPC_AUTH_KRB = 4,
    RPC_AUTH_GSS = 6,
    RPC_AUTH_MAXFLAVOR = 8,
    RPC_AUTH_GSS_KRB5 = 390003,
    RPC_AUTH_GSS_KRB5I = 390004,
    RPC_AUTH_GSS_KRB5P = 390005,
    RPC_AUTH_GSS_LKEY = 390006,
    RPC_AUTH_GSS_LKEYI = 390007,
    RPC_AUTH_GSS_LKEYP = 390008,
    RPC_AUTH_GSS_SPKM = 390009,
    RPC_AUTH_GSS_SPKMI = 390010,
    RPC_AUTH_GSS_SPKMP = 390011
};
enum rpc_msg_type {
    RPC_CALL = 0,
    RPC_REPLY = 1
};
enum rpc_reply_stat {
    RPC_MSG_ACCEPTED = 0,
    RPC_MSG_DENIED = 1
};
enum rpc_accept_stat {
    RPC_SUCCESS = 0,
    RPC_PROG_UNAVAIL = 1,
    RPC_PROG_MISMATCH = 2,
    RPC_PROC_UNAVAIL = 3,
    RPC_GARBAGE_ARGS = 4,
    RPC_SYSTEM_ERR = 5
};
enum rpc_reject_stat {
    RPC_MISMATCH = 0,
    RPC_AUTH_ERROR = 1
};
enum rpc_auth_stat {
    RPC_AUTH_OK = 0,
    RPC_AUTH_BADCRED = 1,
    RPC_AUTH_REJECTEDCRED = 2,
    RPC_AUTH_BADVERF = 3,
    RPC_AUTH_REJECTEDVERF = 4,
    RPC_AUTH_TOOWEAK = 5,
    RPCSEC_GSS_CREDPROBLEM = 13,
    RPCSEC_GSS_CTXPROBLEM = 14
};
enum nfs_stat {
    NFS_OK = 0,
    NFSERR_PERM = 1,
    NFSERR_NOENT = 2,
    NFSERR_IO = 5,
    NFSERR_NXIO = 6,
    NFSERR_EAGAIN = 11,
    NFSERR_ACCES = 13,
    NFSERR_EXIST = 17,
    NFSERR_XDEV = 18,
    NFSERR_NODEV = 19,
    NFSERR_NOTDIR = 20,
    NFSERR_ISDIR = 21,
    NFSERR_INVAL = 22,
    NFSERR_FBIG = 27,
    NFSERR_NOSPC = 28,
    NFSERR_ROFS = 30,
    NFSERR_MLINK = 31,
    NFSERR_OPNOTSUPP = 45,
    NFSERR_NAMETOOLONG = 63,
    NFSERR_NOTEMPTY = 66,
    NFSERR_DQUOT = 69,
    NFSERR_STALE = 70,
    NFSERR_REMOTE = 71,
    NFSERR_WFLUSH = 99,
    NFSERR_BADHANDLE = 10001,
    NFSERR_NOT_SYNC = 10002,
    NFSERR_BAD_COOKIE = 10003,
    NFSERR_NOTSUPP = 10004,
    NFSERR_TOOSMALL = 10005,
    NFSERR_SERVERFAULT = 10006,
    NFSERR_BADTYPE = 10007,
    NFSERR_JUKEBOX = 10008,
    NFSERR_SAME = 10009,
    NFSERR_DENIED = 10010,
    NFSERR_EXPIRED = 10011,
    NFSERR_LOCKED = 10012,
    NFSERR_GRACE = 10013,
    NFSERR_FHEXPIRED = 10014,
    NFSERR_SHARE_DENIED = 10015,
    NFSERR_WRONGSEC = 10016,
    NFSERR_CLID_INUSE = 10017,
    NFSERR_RESOURCE = 10018,
    NFSERR_MOVED = 10019,
    NFSERR_NOFILEHANDLE = 10020,
    NFSERR_MINOR_VERS_MISMATCH = 10021,
    NFSERR_STALE_CLIENTID = 10022,
    NFSERR_STALE_STATEID = 10023,
    NFSERR_OLD_STATEID = 10024,
    NFSERR_BAD_STATEID = 10025,
    NFSERR_BAD_SEQID = 10026,
    NFSERR_NOT_SAME = 10027,
    NFSERR_LOCK_RANGE = 10028,
    NFSERR_SYMLINK = 10029,
    NFSERR_RESTOREFH = 10030,
    NFSERR_LEASE_MOVED = 10031,
    NFSERR_ATTRNOTSUPP = 10032,
    NFSERR_NO_GRACE = 10033,
    NFSERR_RECLAIM_BAD = 10034,
    NFSERR_RECLAIM_CONFLICT = 10035,
    NFSERR_BAD_XDR = 10036,
    NFSERR_LOCKS_HELD = 10037,
    NFSERR_OPENMODE = 10038,
    NFSERR_BADOWNER = 10039,
    NFSERR_BADCHAR = 10040,
    NFSERR_BADNAME = 10041,
    NFSERR_BAD_RANGE = 10042,
    NFSERR_LOCK_NOTSUPP = 10043,
    NFSERR_OP_ILLEGAL = 10044,
    NFSERR_DEADLOCK = 10045,
    NFSERR_FILE_OPEN = 10046,
    NFSERR_ADMIN_REVOKED = 10047,
    NFSERR_CB_PATH_DOWN = 10048,
    NFSERR_REPLAY_ME = 10049
};
enum nfs_ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5,
    NFSOCK = 6,
    NFBAD = 7,
    NFFIFO = 8
};
struct nfs_fh {
   unsigned short size ;
   unsigned char data[128] ;
};
enum nfs3_stable_how {
    NFS_UNSTABLE = 0,
    NFS_DATA_SYNC = 1,
    NFS_FILE_SYNC = 2
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   u32 flags ;
   struct nlm_lockowner *owner ;
};
struct fasync_struct;
union __anonunion_fl_u_97 {
   struct nfs_lock_info nfs_fl ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_pid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_97 fl_u ;
};
struct flock {
   short l_type ;
   short l_whence ;
   off_t l_start ;
   off_t l_len ;
   pid_t l_pid ;
};
struct flock64 {
   short l_type ;
   short l_whence ;
   loff_t l_start ;
   loff_t l_len ;
   pid_t l_pid ;
};
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
struct file_system_type;
struct super_operations;
struct export_operations;
struct xattr_handler;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned long s_old_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct semaphore s_lock ;
   int s_count ;
   int s_syncing ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct block_device *s_bdev ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   struct semaphore s_vfs_rename_sem ;
   u32 s_time_gran ;
};
enum __anonenum_98 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_TRANS = 2
};
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , ino_t  , unsigned int  );
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   struct module *owner ;
};
union __anonunion_arg_100 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_99 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_100 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_99 read_descriptor_t;
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , char * , size_t  , loff_t  ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_write)(struct kiocb * , char const   * , size_t  , loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
};
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   int (*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  , struct nameidata * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
};
struct seq_file;
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*read_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*put_inode)(struct inode * ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   void (*write_super_lockfs)(struct super_block * ) ;
   void (*unlockfs)(struct super_block * ) ;
   int (*statfs)(struct super_block * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
};
struct export_operations {
   struct dentry *(*decode_fh)(struct super_block *sb , __u32 *fh , int fh_len , int fh_type ,
                               int (*acceptable)(void *context , struct dentry *de ) ,
                               void *context ) ;
   int (*encode_fh)(struct dentry *de , __u32 *fh , int *max_len , int connectable ) ;
   int (*get_name)(struct dentry *parent , char *name , struct dentry *child ) ;
   struct dentry *(*get_parent)(struct dentry *child ) ;
   struct dentry *(*get_dentry)(struct super_block *sb , void *inump ) ;
   struct dentry *(*find_exported_dentry)(struct super_block *sb , void *obj , void *parent ,
                                          int (*acceptable)(void *context , struct dentry *de ) ,
                                          void *context ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct super_block *(*get_sb)(struct file_system_type * , int  , char const   * ,
                                 void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
};
struct bio;
enum __anonenum_101 {
    DIO_LOCKING = 1,
    DIO_NO_LOCKING = 2,
    DIO_OWN_LOCKING = 3
};
struct tree_descr {
   char *name ;
   struct file_operations *ops ;
   int mode ;
};
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
struct anon_vma;
struct __anonstruct_pud_t_102 {
   pgd_t pgd ;
};
typedef struct __anonstruct_pud_t_102 pud_t;
struct __anonstruct_vm_set_104 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_103 {
   struct __anonstruct_vm_set_104 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct vm_operations_struct;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_103 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
struct vm_list_struct {
   struct vm_list_struct *next ;
   struct vm_area_struct *vma ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   struct page *(*nopage)(struct vm_area_struct *area , unsigned long address , int *type ) ;
   int (*populate)(struct vm_area_struct *area , unsigned long address , unsigned long len ,
                   pgprot_t prot , unsigned long pgoff , int nonblock ) ;
};
struct mmu_gather;
typedef unsigned long page_flags_t;
struct page {
   page_flags_t flags ;
   atomic_t _count ;
   atomic_t _mapcount ;
   unsigned long private ;
   struct address_space *mapping ;
   unsigned long index ;
   struct list_head lru ;
};
struct page_state {
   unsigned long nr_dirty ;
   unsigned long nr_writeback ;
   unsigned long nr_unstable ;
   unsigned long nr_page_table_pages ;
   unsigned long nr_mapped ;
   unsigned long nr_slab ;
   unsigned long pgpgin ;
   unsigned long pgpgout ;
   unsigned long pswpin ;
   unsigned long pswpout ;
   unsigned long pgalloc_high ;
   unsigned long pgalloc_normal ;
   unsigned long pgalloc_dma ;
   unsigned long pgfree ;
   unsigned long pgactivate ;
   unsigned long pgdeactivate ;
   unsigned long pgfault ;
   unsigned long pgmajfault ;
   unsigned long pgrefill_high ;
   unsigned long pgrefill_normal ;
   unsigned long pgrefill_dma ;
   unsigned long pgsteal_high ;
   unsigned long pgsteal_normal ;
   unsigned long pgsteal_dma ;
   unsigned long pgscan_kswapd_high ;
   unsigned long pgscan_kswapd_normal ;
   unsigned long pgscan_kswapd_dma ;
   unsigned long pgscan_direct_high ;
   unsigned long pgscan_direct_normal ;
   unsigned long pgscan_direct_dma ;
   unsigned long pginodesteal ;
   unsigned long slabs_scanned ;
   unsigned long kswapd_steal ;
   unsigned long kswapd_inodesteal ;
   unsigned long pageoutrun ;
   unsigned long allocstall ;
   unsigned long pgrotated ;
   unsigned long nr_bounce ;
};
struct zap_details {
   struct vm_area_struct *nonlinear_vma ;
   struct address_space *check_mapping ;
   unsigned long first_index ;
   unsigned long last_index ;
   spinlock_t *i_mmap_lock ;
   unsigned long truncate_count ;
};
typedef int (*shrinker_t)(int nr_to_scan , unsigned int gfp_mask );
struct shrinker;
struct irq_routing_table;
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
};
struct pci_fixup {
   u16 vendor ;
   u16 device ;
   void (*hook)(struct pci_dev *dev ) ;
};
enum pci_fixup_pass {
    pci_fixup_early = 0,
    pci_fixup_header = 1,
    pci_fixup_final = 2,
    pci_fixup_enable = 3
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *devfs_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct termios **termios ;
   struct termios **termios_locked ;
   void *driver_state ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
   struct list_head tty_drivers ;
};
struct tty_ldisc {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct *tty ) ;
   ssize_t (*read)(struct tty_struct *tty , struct file *file , unsigned char *buf ,
                   size_t nr ) ;
   ssize_t (*write)(struct tty_struct *tty , struct file *file , unsigned char const   *buf ,
                    size_t nr ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct *tty ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   *cp , char *fp ,
                       int count ) ;
   int (*receive_room)(struct tty_struct * ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   struct module *owner ;
   int refcount ;
};
struct screen_info {
   u8 orig_x ;
   u8 orig_y ;
   u16 dontuse1 ;
   u16 orig_video_page ;
   u8 orig_video_mode ;
   u8 orig_video_cols ;
   u16 unused2 ;
   u16 orig_video_ega_bx ;
   u16 unused3 ;
   u8 orig_video_lines ;
   u8 orig_video_isVGA ;
   u16 orig_video_points ;
   u16 lfb_width ;
   u16 lfb_height ;
   u16 lfb_depth ;
   u32 lfb_base ;
   u32 lfb_size ;
   u16 dontuse2 ;
   u16 dontuse3 ;
   u16 lfb_linelength ;
   u8 red_size ;
   u8 red_pos ;
   u8 green_size ;
   u8 green_pos ;
   u8 blue_size ;
   u8 blue_pos ;
   u8 rsvd_size ;
   u8 rsvd_pos ;
   u16 vesapm_seg ;
   u16 vesapm_off ;
   u16 pages ;
   u16 vesa_attributes ;
};
struct tty_flip_buffer {
   struct work_struct work ;
   struct semaphore pty_sem ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int count ;
   int buf_num ;
   unsigned char char_buf[1024] ;
   char flag_buf[1024] ;
   unsigned char slop[4] ;
};
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct tty_ldisc ldisc ;
   struct semaphore termios_sem ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   int pgrp ;
   int session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_flip_buffer flip ;
   int max_flip_cnt ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[(int )(256U / (8U * sizeof(unsigned long )))] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[(int )(4096U / (8U * sizeof(unsigned long )))] ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct semaphore atomic_read ;
   struct semaphore atomic_write ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
};
struct async_icount {
   __u32 cts ;
   __u32 dsr ;
   __u32 rng ;
   __u32 dcd ;
   __u32 tx ;
   __u32 rx ;
   __u32 frame ;
   __u32 parity ;
   __u32 overrun ;
   __u32 brk ;
   __u32 buf_overrun ;
};
struct serial_struct {
   int type ;
   int line ;
   unsigned int port ;
   int irq ;
   int flags ;
   int xmit_fifo_size ;
   int custom_divisor ;
   int baud_base ;
   unsigned short close_delay ;
   char io_type ;
   char reserved_char[1] ;
   int hub6 ;
   unsigned short closing_wait ;
   unsigned short closing_wait2 ;
   unsigned char *iomem_base ;
   unsigned short iomem_reg_shift ;
   unsigned int port_high ;
   unsigned long iomap_base ;
};
struct serial_uart_config {
   char *name ;
   int dfl_xmit_fifo_size ;
   int flags ;
};
struct serial_multiport_struct {
   int irq ;
   int port1 ;
   unsigned char mask1 ;
   unsigned char match1 ;
   int port2 ;
   unsigned char mask2 ;
   unsigned char match2 ;
   int port3 ;
   unsigned char mask3 ;
   unsigned char match3 ;
   int port4 ;
   unsigned char mask4 ;
   unsigned char match4 ;
   int port_monitor ;
   int reserved[32] ;
};
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9] ;
};
struct uart_port;
struct sockaddr;
struct __kernel_sockaddr_storage {
   unsigned short ss_family ;
   char __data[(int )(128U - sizeof(unsigned short ))] ;
} __attribute__((__aligned__(__alignof__(struct sockaddr *)))) ;
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct linger {
   int l_onoff ;
   int l_linger ;
};
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
struct cmsghdr {
   __kernel_size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
};
struct ucred {
   __u32 pid ;
   __u32 uid ;
   __u32 gid ;
};
struct __anonstruct_sync_serial_settings_105 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_105 sync_serial_settings;
struct __anonstruct_te1_settings_106 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_106 te1_settings;
struct __anonstruct_raw_hdlc_proto_107 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_107 raw_hdlc_proto;
struct __anonstruct_fr_proto_108 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_108 fr_proto;
struct __anonstruct_fr_proto_pvc_109 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_109 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_110 {
   unsigned int dlci ;
   char master[16] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_110 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_111 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_111 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_112 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_112 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_113 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_114 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_113 ifr_ifrn ;
   union __anonunion_ifr_ifru_114 ifr_ifru ;
};
union __anonunion_ifc_ifcu_115 {
   char *ifcu_buf ;
   struct ifreq *ifcu_req ;
};
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_115 ifc_ifcu ;
};
struct ethhdr {
   unsigned char h_dest[6] ;
   unsigned char h_source[6] ;
   unsigned short h_proto ;
} __attribute__((__packed__)) ;
struct tlb_state {
   struct mm_struct *active_mm ;
   int state ;
   char __cacheline_padding[24] ;
};
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
struct __large_struct {
   unsigned long buf[100] ;
};
typedef void (*poll_queue_proc)(struct file * , wait_queue_head_t * , struct poll_table_struct * );
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
typedef struct poll_table_struct poll_table;
struct poll_table_page;
struct poll_wqueues {
   poll_table pt ;
   struct poll_table_page *table ;
   int error ;
};
struct __anonstruct_fd_set_bits_116 {
   unsigned long *in ;
   unsigned long *out ;
   unsigned long *ex ;
   unsigned long *res_in ;
   unsigned long *res_out ;
   unsigned long *res_ex ;
};
typedef struct __anonstruct_fd_set_bits_116 fd_set_bits;
enum __anonenum_socket_state_117 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
};
typedef enum __anonenum_socket_state_117 socket_state;
enum sock_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_PACKET = 10
};
struct proto_ops;
struct sock;
struct socket {
   socket_state state ;
   unsigned long flags ;
   struct proto_ops *ops ;
   struct fasync_struct *fasync_list ;
   struct file *file ;
   struct sock *sk ;
   wait_queue_head_t wait ;
   short type ;
};
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket *sock ) ;
   int (*bind)(struct socket *sock , struct sockaddr *myaddr , int sockaddr_len ) ;
   int (*connect)(struct socket *sock , struct sockaddr *vaddr , int sockaddr_len ,
                  int flags ) ;
   int (*socketpair)(struct socket *sock1 , struct socket *sock2 ) ;
   int (*accept)(struct socket *sock , struct socket *newsock , int flags ) ;
   int (*getname)(struct socket *sock , struct sockaddr *addr , int *sockaddr_len ,
                  int peer ) ;
   unsigned int (*poll)(struct file *file , struct socket *sock , struct poll_table_struct *wait ) ;
   int (*ioctl)(struct socket *sock , unsigned int cmd , unsigned long arg ) ;
   int (*listen)(struct socket *sock , int len ) ;
   int (*shutdown)(struct socket *sock , int flags ) ;
   int (*setsockopt)(struct socket *sock , int level , int optname , char *optval ,
                     int optlen ) ;
   int (*getsockopt)(struct socket *sock , int level , int optname , char *optval ,
                     int *optlen ) ;
   int (*sendmsg)(struct kiocb *iocb , struct socket *sock , struct msghdr *m , size_t total_len ) ;
   int (*recvmsg)(struct kiocb *iocb , struct socket *sock , struct msghdr *m , size_t total_len ,
                  int flags ) ;
   int (*mmap)(struct file *file , struct socket *sock , struct vm_area_struct *vma ) ;
   ssize_t (*sendpage)(struct socket *sock , struct page *page , int offset , size_t size ,
                       int flags ) ;
};
struct net_proto_family {
   int family ;
   int (*create)(struct socket *sock , int protocol ) ;
   short authentication ;
   short encryption ;
   short encrypt_net ;
   struct module *owner ;
};
union __anonunion_in6_u_118 {
   __u8 u6_addr8[16] ;
   __u16 u6_addr16[8] ;
   __u32 u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion_in6_u_118 in6_u ;
};
struct sockaddr_in6 {
   unsigned short sin6_family ;
   __u16 sin6_port ;
   __u32 sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   __u32 sin6_scope_id ;
};
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   int ipv6mr_ifindex ;
};
struct in6_flowlabel_req {
   struct in6_addr flr_dst ;
   __u32 flr_label ;
   __u8 flr_action ;
   __u8 flr_share ;
   __u16 flr_flags ;
   __u16 flr_expires ;
   __u16 flr_linger ;
   __u32 __flr_pad ;
};
struct net_device;
struct nf_conntrack {
   atomic_t use ;
   void (*destroy)(struct nf_conntrack * ) ;
};
struct nf_bridge_info {
   atomic_t use ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   struct net_device *netoutdev ;
   unsigned int mask ;
   unsigned long data[(int )(32U / sizeof(unsigned long ))] ;
};
struct sk_buff;
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
struct skb_frag_struct;
typedef struct skb_frag_struct skb_frag_t;
struct skb_frag_struct {
   struct page *page ;
   __u16 page_offset ;
   __u16 size ;
};
struct skb_shared_info {
   atomic_t dataref ;
   unsigned int nr_frags ;
   unsigned short tso_size ;
   unsigned short tso_segs ;
   struct sk_buff *frag_list ;
   skb_frag_t frags[18] ;
};
struct tcphdr;
struct udphdr;
struct icmphdr;
struct igmphdr;
struct iphdr;
struct ipv6hdr;
union __anonunion_h_119 {
   struct tcphdr *th ;
   struct udphdr *uh ;
   struct icmphdr *icmph ;
   struct igmphdr *igmph ;
   struct iphdr *ipiph ;
   struct ipv6hdr *ipv6h ;
   unsigned char *raw ;
};
struct arphdr;
union __anonunion_nh_120 {
   struct iphdr *iph ;
   struct ipv6hdr *ipv6h ;
   struct arphdr *arph ;
   unsigned char *raw ;
};
union __anonunion_mac_121 {
   unsigned char *raw ;
};
struct dst_entry;
struct sec_path;
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   struct sk_buff_head *list ;
   struct sock *sk ;
   struct timeval stamp ;
   struct net_device *dev ;
   struct net_device *input_dev ;
   struct net_device *real_dev ;
   union __anonunion_h_119 h ;
   union __anonunion_nh_120 nh ;
   union __anonunion_mac_121 mac ;
   struct dst_entry *dst ;
   struct sec_path *sp ;
   char cb[40] ;
   unsigned int len ;
   unsigned int data_len ;
   unsigned int mac_len ;
   unsigned int csum ;
   unsigned char local_df ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char pkt_type ;
   unsigned char ip_summed ;
   __u32 priority ;
   unsigned short protocol ;
   unsigned short security ;
   void (*destructor)(struct sk_buff *skb ) ;
   unsigned long nfmark ;
   __u32 nfcache ;
   __u32 nfctinfo ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   __u32 tc_index ;
   unsigned int truesize ;
   atomic_t users ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned char *tail ;
   unsigned char *end ;
};
struct sockaddr_pkt {
   unsigned short spkt_family ;
   unsigned char spkt_device[14] ;
   unsigned short spkt_protocol ;
};
struct sockaddr_ll {
   unsigned short sll_family ;
   unsigned short sll_protocol ;
   int sll_ifindex ;
   unsigned short sll_hatype ;
   unsigned char sll_pkttype ;
   unsigned char sll_halen ;
   unsigned char sll_addr[8] ;
};
struct tpacket_stats {
   unsigned int tp_packets ;
   unsigned int tp_drops ;
};
struct tpacket_hdr {
   unsigned long tp_status ;
   unsigned int tp_len ;
   unsigned int tp_snaplen ;
   unsigned short tp_mac ;
   unsigned short tp_net ;
   unsigned int tp_sec ;
   unsigned int tp_usec ;
};
struct tpacket_req {
   unsigned int tp_block_size ;
   unsigned int tp_block_nr ;
   unsigned int tp_frame_size ;
   unsigned int tp_frame_nr ;
};
struct packet_mreq {
   int mr_ifindex ;
   unsigned short mr_type ;
   unsigned short mr_alen ;
   unsigned char mr_address[8] ;
};
struct divert_blk;
struct vlan_group;
struct ethtool_ops;
struct netpoll;
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
enum __anonenum_122 {
    IF_PORT_UNKNOWN = 0,
    IF_PORT_10BASE2 = 1,
    IF_PORT_10BASET = 2,
    IF_PORT_AUI = 3,
    IF_PORT_100BASET = 4,
    IF_PORT_100BASETX = 5,
    IF_PORT_100BASEFX = 6
};
struct neighbour;
struct neigh_parms;
struct netif_rx_stats {
   unsigned int total ;
   unsigned int dropped ;
   unsigned int time_squeeze ;
   unsigned int throttled ;
   unsigned int fastroute_hit ;
   unsigned int fastroute_success ;
   unsigned int fastroute_defer ;
   unsigned int fastroute_deferred_out ;
   unsigned int fastroute_latency_reduction ;
   unsigned int cpu_collision ;
};
struct dev_mc_list {
   struct dev_mc_list *next ;
   __u8 dmi_addr[32] ;
   unsigned char dmi_addrlen ;
   int dmi_users ;
   int dmi_gusers ;
};
struct hh_cache {
   struct hh_cache *hh_next ;
   atomic_t hh_refcnt ;
   unsigned short hh_type ;
   int hh_len ;
   int (*hh_output)(struct sk_buff *skb ) ;
   rwlock_t hh_lock ;
   unsigned long hh_data[(int )(48U / sizeof(long ))] ;
};
enum netdev_state_t {
    __LINK_STATE_XOFF = 0,
    __LINK_STATE_START = 1,
    __LINK_STATE_PRESENT = 2,
    __LINK_STATE_SCHED = 3,
    __LINK_STATE_NOCARRIER = 4,
    __LINK_STATE_RX_SCHED = 5,
    __LINK_STATE_LINKWATCH_PENDING = 6
};
struct netdev_boot_setup {
   char name[16] ;
   struct ifmap map ;
};
struct iw_statistics;
struct iw_handler_def;
struct iw_public_data;
struct Qdisc;
enum __anonenum_reg_state_123 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERING = 1,
    NETREG_REGISTERED = 2,
    NETREG_UNREGISTERING = 3,
    NETREG_UNREGISTERED = 4,
    NETREG_RELEASED = 5
};
struct net_bridge_port;
struct net_device {
   char name[16] ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned long state ;
   struct net_device *next ;
   int (*init)(struct net_device *dev ) ;
   struct net_device *next_sched ;
   int ifindex ;
   int iflink ;
   struct net_device_stats *(*get_stats)(struct net_device *dev ) ;
   struct iw_statistics *(*get_wireless_stats)(struct net_device *dev ) ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct ethtool_ops *ethtool_ops ;
   unsigned long trans_start ;
   unsigned long last_rx ;
   unsigned short flags ;
   unsigned short gflags ;
   unsigned short priv_flags ;
   unsigned short padded ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   void *priv ;
   struct net_device *master ;
   unsigned char broadcast[32] ;
   unsigned char dev_addr[32] ;
   unsigned char addr_len ;
   unsigned short dev_id ;
   struct dev_mc_list *mc_list ;
   int mc_count ;
   int promiscuity ;
   int allmulti ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   void *atalk_ptr ;
   void *ip_ptr ;
   void *dn_ptr ;
   void *ip6_ptr ;
   void *ec_ptr ;
   void *ax25_ptr ;
   struct list_head poll_list ;
   int quota ;
   int weight ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct Qdisc *qdisc_ingress ;
   struct list_head qdisc_list ;
   unsigned long tx_queue_len ;
   spinlock_t ingress_lock ;
   spinlock_t xmit_lock ;
   int xmit_lock_owner ;
   spinlock_t queue_lock ;
   atomic_t refcnt ;
   struct list_head todo_list ;
   struct hlist_node name_hlist ;
   struct hlist_node index_hlist ;
   enum __anonenum_reg_state_123 reg_state ;
   unsigned long features ;
   void (*uninit)(struct net_device *dev ) ;
   void (*destructor)(struct net_device *dev ) ;
   int (*open)(struct net_device *dev ) ;
   int (*stop)(struct net_device *dev ) ;
   int (*hard_start_xmit)(struct sk_buff *skb , struct net_device *dev ) ;
   int (*poll)(struct net_device *dev , int *quota ) ;
   int (*hard_header)(struct sk_buff *skb , struct net_device *dev , unsigned short type ,
                      void *daddr , void *saddr , unsigned int len ) ;
   int (*rebuild_header)(struct sk_buff *skb ) ;
   void (*set_multicast_list)(struct net_device *dev ) ;
   int (*set_mac_address)(struct net_device *dev , void *addr ) ;
   int (*do_ioctl)(struct net_device *dev , struct ifreq *ifr , int cmd ) ;
   int (*set_config)(struct net_device *dev , struct ifmap *map ) ;
   int (*hard_header_cache)(struct neighbour *neigh , struct hh_cache *hh ) ;
   void (*header_cache_update)(struct hh_cache *hh , struct net_device *dev , unsigned char *haddr ) ;
   int (*change_mtu)(struct net_device *dev , int new_mtu ) ;
   void (*tx_timeout)(struct net_device *dev ) ;
   void (*vlan_rx_register)(struct net_device *dev , struct vlan_group *grp ) ;
   void (*vlan_rx_add_vid)(struct net_device *dev , unsigned short vid ) ;
   void (*vlan_rx_kill_vid)(struct net_device *dev , unsigned short vid ) ;
   int (*hard_header_parse)(struct sk_buff *skb , unsigned char *haddr ) ;
   int (*neigh_setup)(struct net_device *dev , struct neigh_parms * ) ;
   struct netpoll *np ;
   void (*poll_controller)(struct net_device *dev ) ;
   struct net_bridge_port *br_port ;
   struct divert_blk *divert ;
   struct class_device class_dev ;
};
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block *self , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
typedef int gifconf_func_t(struct net_device *dev , char *bufptr , int len );
struct softnet_data {
   int throttle ;
   int cng_level ;
   int avg_blog ;
   struct sk_buff_head input_pkt_queue ;
   struct list_head poll_list ;
   struct net_device *output_queue ;
   struct sk_buff *completion_queue ;
   struct net_device backlog_dev ;
};
enum __anonenum_124 {
    NETIF_MSG_DRV = 1,
    NETIF_MSG_PROBE = 2,
    NETIF_MSG_LINK = 4,
    NETIF_MSG_TIMER = 8,
    NETIF_MSG_IFDOWN = 16,
    NETIF_MSG_IFUP = 32,
    NETIF_MSG_RX_ERR = 64,
    NETIF_MSG_TX_ERR = 128,
    NETIF_MSG_TX_QUEUED = 256,
    NETIF_MSG_INTR = 512,
    NETIF_MSG_TX_DONE = 1024,
    NETIF_MSG_RX_STATUS = 2048,
    NETIF_MSG_PKTDATA = 4096,
    NETIF_MSG_HW = 8192,
    NETIF_MSG_WOL = 16384
};
struct slcp {
   u16 state ;
   u32 magic ;
   u_char echoid ;
   u_char confid ;
};
struct sipcp {
   u16 state ;
   u_char confid ;
};
struct sppp {
   struct sppp *pp_next ;
   u32 pp_flags ;
   u16 pp_alivecnt ;
   u16 pp_loopcnt ;
   u32 pp_seq ;
   u32 pp_rseq ;
   struct slcp lcp ;
   struct sipcp ipcp ;
   u32 ibytes ;
   u32 obytes ;
   u32 ipkts ;
   u32 opkts ;
   struct timer_list pp_timer ;
   struct net_device *pp_if ;
   char pp_link_state ;
   spinlock_t lock ;
};
struct ppp_device {
   struct net_device *dev ;
   struct sppp sppp ;
};
struct __anonstruct_hdlc_header_125 {
   u8 address ;
   u8 control ;
   u16 protocol ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_hdlc_header_125 hdlc_header;
struct __anonstruct_cisco_packet_126 {
   u32 type ;
   u32 par1 ;
   u32 par2 ;
   u16 rel ;
   u32 time ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_cisco_packet_126 cisco_packet;
struct __anonstruct_state_127 {
   unsigned int new : 1 ;
   unsigned int active : 1 ;
   unsigned int exist : 1 ;
   unsigned int deleted : 1 ;
   unsigned int fecn : 1 ;
   unsigned int becn : 1 ;
};
struct pvc_device_struct {
   struct net_device *master ;
   struct net_device *main ;
   struct net_device *ether ;
   struct pvc_device_struct *next ;
   int dlci ;
   int open_count ;
   struct __anonstruct_state_127 state ;
};
typedef struct pvc_device_struct pvc_device;
struct __anonstruct_proto_128 {
   int (*open)(struct net_device *dev ) ;
   void (*close)(struct net_device *dev ) ;
   void (*start)(struct net_device *dev ) ;
   void (*stop)(struct net_device *dev ) ;
   void (*detach)(struct hdlc_device_struct *hdlc ) ;
   int (*netif_rx)(struct sk_buff *skb ) ;
   unsigned short (*type_trans)(struct sk_buff *skb , struct net_device *dev ) ;
   int id ;
};
struct __anonstruct_fr_130 {
   fr_proto settings ;
   pvc_device *first_pvc ;
   int dce_pvc_count ;
   struct timer_list timer ;
   unsigned long last_poll ;
   int reliable ;
   int dce_changed ;
   int request ;
   int fullrep_sent ;
   u32 last_errors ;
   u8 n391cnt ;
   u8 txseq ;
   u8 rxseq ;
};
struct __anonstruct_cisco_131 {
   cisco_proto settings ;
   struct timer_list timer ;
   unsigned long last_poll ;
   int up ;
   int request_sent ;
   u32 txseq ;
   u32 rxseq ;
};
struct __anonstruct_raw_hdlc_132 {
   raw_hdlc_proto settings ;
};
struct __anonstruct_ppp_133 {
   struct ppp_device pppdev ;
   struct ppp_device *syncppp_ptr ;
   int (*old_change_mtu)(struct net_device *dev , int new_mtu ) ;
};
union __anonunion_state_129 {
   struct __anonstruct_fr_130 fr ;
   struct __anonstruct_cisco_131 cisco ;
   struct __anonstruct_raw_hdlc_132 raw_hdlc ;
   struct __anonstruct_ppp_133 ppp ;
};
struct hdlc_device_struct {
   struct net_device_stats stats ;
   int (*attach)(struct net_device *dev , unsigned short encoding , unsigned short parity ) ;
   int (*xmit)(struct sk_buff *skb , struct net_device *dev ) ;
   struct __anonstruct_proto_128 proto ;
   int carrier ;
   int open ;
   spinlock_t state_lock ;
   union __anonunion_state_129 state ;
   void *priv ;
};
typedef struct hdlc_device_struct hdlc_device;
struct _MGSL_PARAMS {
   unsigned long mode ;
   unsigned char loopback ;
   unsigned short flags ;
   unsigned char encoding ;
   unsigned long clock_speed ;
   unsigned char addr_filter ;
   unsigned short crc_type ;
   unsigned char preamble_length ;
   unsigned char preamble ;
   unsigned long data_rate ;
   unsigned char data_bits ;
   unsigned char stop_bits ;
   unsigned char parity ;
};
typedef struct _MGSL_PARAMS MGSL_PARAMS;
typedef struct _MGSL_PARAMS *PMGSL_PARAMS;
struct mgsl_icount {
   __u32 cts ;
   __u32 dsr ;
   __u32 rng ;
   __u32 dcd ;
   __u32 tx ;
   __u32 rx ;
   __u32 frame ;
   __u32 parity ;
   __u32 overrun ;
   __u32 brk ;
   __u32 buf_overrun ;
   __u32 txok ;
   __u32 txunder ;
   __u32 txabort ;
   __u32 txtimeout ;
   __u32 rxshort ;
   __u32 rxlong ;
   __u32 rxabort ;
   __u32 rxover ;
   __u32 rxcrc ;
   __u32 rxok ;
   __u32 exithunt ;
   __u32 rxidle ;
};
struct _DMABUFFERENTRY {
   u32 phys_addr ;
   u16 count ;
   u16 status ;
   u16 rcc ;
   u16 reserved ;
   u32 link ;
   char *virt_addr ;
   u32 phys_entry ;
};
typedef struct _DMABUFFERENTRY DMABUFFERENTRY;
typedef struct _DMABUFFERENTRY *DMAPBUFFERENTRY;
struct _input_signal_events {
   int ri_up ;
   int ri_down ;
   int dsr_up ;
   int dsr_down ;
   int dcd_up ;
   int dcd_down ;
   int cts_up ;
   int cts_down ;
};
struct tx_holding_buffer {
   int buffer_size ;
   unsigned char *buffer ;
};
struct mgsl_struct {
   int magic ;
   int flags ;
   int count ;
   int line ;
   int hw_version ;
   unsigned short close_delay ;
   unsigned short closing_wait ;
   struct mgsl_icount icount ;
   struct tty_struct *tty ;
   int timeout ;
   int x_char ;
   int blocked_open ;
   u16 read_status_mask ;
   u16 ignore_status_mask ;
   unsigned char *xmit_buf ;
   int xmit_head ;
   int xmit_tail ;
   int xmit_cnt ;
   wait_queue_head_t open_wait ;
   wait_queue_head_t close_wait ;
   wait_queue_head_t status_event_wait_q ;
   wait_queue_head_t event_wait_q ;
   struct timer_list tx_timer ;
   struct mgsl_struct *next_device ;
   spinlock_t irq_spinlock ;
   struct work_struct task ;
   u32 EventMask ;
   u32 RecordedEvents ;
   u32 max_frame_size ;
   u32 pending_bh ;
   int bh_running ;
   int isr_overflow ;
   int bh_requested ;
   int dcd_chkcount ;
   int cts_chkcount ;
   int dsr_chkcount ;
   int ri_chkcount ;
   char *buffer_list ;
   unsigned long buffer_list_phys ;
   unsigned int rx_buffer_count ;
   DMABUFFERENTRY *rx_buffer_list ;
   unsigned int current_rx_buffer ;
   int num_tx_dma_buffers ;
   int tx_dma_buffers_used ;
   unsigned int tx_buffer_count ;
   DMABUFFERENTRY *tx_buffer_list ;
   int start_tx_dma_buffer ;
   int current_tx_buffer ;
   unsigned char *intermediate_rxbuffer ;
   int num_tx_holding_buffers ;
   int get_tx_holding_index ;
   int put_tx_holding_index ;
   int tx_holding_count ;
   struct tx_holding_buffer tx_holding_buffers[5] ;
   int rx_enabled ;
   int rx_overflow ;
   int rx_rcc_underrun ;
   int tx_enabled ;
   int tx_active ;
   u32 idle_mode ;
   u16 cmr_value ;
   u16 tcsr_value ;
   char device_name[25] ;
   unsigned int bus_type ;
   unsigned char bus ;
   unsigned char function ;
   unsigned int io_base ;
   unsigned int io_addr_size ;
   int io_addr_requested ;
   unsigned int irq_level ;
   unsigned long irq_flags ;
   int irq_requested ;
   unsigned int dma_level ;
   int dma_requested ;
   u16 mbre_bit ;
   u16 loopback_bits ;
   u16 usc_idle_mode ;
   MGSL_PARAMS params ;
   unsigned char serial_signals ;
   int irq_occurred ;
   unsigned int init_error ;
   int fDiagnosticsmode ;
   u32 last_mem_alloc ;
   unsigned char *memory_base ;
   u32 phys_memory_base ;
   int shared_mem_requested ;
   unsigned char *lcr_base ;
   u32 phys_lcr_base ;
   u32 lcr_offset ;
   int lcr_mem_requested ;
   u32 misc_ctrl_value ;
   char flag_buf[4096] ;
   char char_buf[4096] ;
   int drop_rts_on_tx_done ;
   int loopmode_insert_requested ;
   int loopmode_send_done_requested ;
   struct _input_signal_events input_signal_events ;
   int netcount ;
   int dosyncppp ;
   spinlock_t netlock ;
};
typedef void (*isr_dispatch_func)(struct mgsl_struct * );
struct __anonstruct_s_8___0 {
   __u32 a ;
   __u32 b ;
};
union __anonunion_v_7___0 {
   struct __anonstruct_s_8___0 s ;
   __u64 u ;
};
enum __anonenum_70___0 {
    PM_SYS_UNKNOWN___0 = 0,
    PM_SYS_KBC___0 = 1104151299,
    PM_SYS_COM___0 = 1104151808,
    PM_SYS_IRDA___0 = 1104151824,
    PM_SYS_FDC___0 = 1104152320,
    PM_SYS_VGA___0 = 1104152832,
    PM_SYS_PCMCIA___0 = 1104154112
};
enum __anonenum_82___0 {
    IOCB_CMD_PREAD___0 = 0,
    IOCB_CMD_PWRITE___0 = 1,
    IOCB_CMD_FSYNC___0 = 2,
    IOCB_CMD_FDSYNC___0 = 3,
    IOCB_CMD_NOOP___0 = 6
};
#pragma merger(0,"/tmp/cil-Y786q6zD.i","")
extern long do_no_restart_syscall(struct restart_block *parm ) ;
__inline static int __attribute__((__always_inline__))  generic_ffs(int x ) 
{ int r ;

  {
  r = 1;
  if (! x) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  if (! (x & 65535)) {
    x >>= 16;
    r += 16;
  }
  if (! (x & 255)) {
    x >>= 8;
    r += 8;
  }
  if (! (x & 15)) {
    x >>= 4;
    r += 4;
  }
  if (! (x & 3)) {
    x >>= 2;
    r += 2;
  }
  if (! (x & 1)) {
    x >>= 1;
    r ++;
  }
  return ((int __attribute__((__always_inline__))  )r);
}
}
__inline static int __attribute__((__always_inline__))  generic_fls(int x ) 
{ int r ;

  {
  r = 32;
  if (! x) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  if (! ((unsigned int )x & 4294901760U)) {
    x <<= 16;
    r -= 16;
  }
  if (! ((unsigned int )x & 4278190080U)) {
    x <<= 8;
    r -= 8;
  }
  if (! ((unsigned int )x & 4026531840U)) {
    x <<= 4;
    r -= 4;
  }
  if (! ((unsigned int )x & 3221225472U)) {
    x <<= 2;
    r -= 2;
  }
  if (! ((unsigned int )x & 2147483648U)) {
    x <<= 1;
    r --;
  }
  return ((int __attribute__((__always_inline__))  )r);
}
}
__inline static void __attribute__((__always_inline__))  set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "btsl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  __set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  ("btsl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "btrl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  __clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("btrl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  __change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("btcl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static void __attribute__((__always_inline__))  change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "btcl %1,%0": "=m" ((*((long volatile   *)addr))): "Ir" (nr));
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_bit(int nr ,
                                                                         unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("lock ; "
                       "btsl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  __test_and_set_bit(int nr ,
                                                                           unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  ("btsl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr));
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_bit(int nr ,
                                                                           unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("lock ; "
                       "btrl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  __test_and_clear_bit(int nr ,
                                                                             unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  ("btrl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr));
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  __test_and_change_bit(int nr ,
                                                                              unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("btcl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  test_and_change_bit(int nr ,
                                                                            unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("lock ; "
                       "btcl %2,%1\n\tsbbl %0,%0": "=r" (oldbit), "=m" ((*((long volatile   *)addr))): "Ir" (nr): "memory");
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  constant_test_bit(int nr ,
                                                                          unsigned long const volatile   *addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(((1UL << (nr & 31)) & (unsigned long )(*(addr +
                                                                                              (nr >>
                                                                                               5)))) !=
                                                     0UL));
}
}
__inline static int __attribute__((__always_inline__))  variable_test_bit(int nr ,
                                                                          unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  __asm__  volatile   ("btl %2,%1\n\tsbbl %0,%0": "=r" (oldbit): "m" ((*((long volatile   *)addr))),
                       "Ir" (nr));
  return ((int __attribute__((__always_inline__))  )oldbit);
}
}
__inline static int __attribute__((__always_inline__))  find_first_zero_bit(unsigned long const   *addr ,
                                                                            unsigned int size ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int res ;

  {
  if (! size) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  __asm__  volatile   ("movl $-1,%%eax\n\t"
                       "xorl %%edx,%%edx\n\t"
                       "repe; scasl\n\t"
                       "je 1f\n\t"
                       "xorl -4(%%edi),%%eax\n\t"
                       "subl $4,%%edi\n\t"
                       "bsfl %%eax,%%edx\n"
                       "1:\tsubl %%ebx,%%edi\n\t"
                       "shll $3,%%edi\n\t"
                       "addl %%edi,%%edx": "=d" (res), "=&c" (d0), "=&D" (d1), "=&a" (d2): "1" ((size +
                                                                                                 31U) >>
                                                                                                5),
                       "2" (addr), "b" (addr): "memory");
  return ((int __attribute__((__always_inline__))  )res);
}
}
extern int find_next_zero_bit(unsigned long const   *addr , int size , int offset ) ;
__inline static int __attribute__((__always_inline__))  find_first_bit(unsigned long const   *addr ,
                                                                       unsigned int size ) 
{ int d0 ;
  int d1 ;
  int res ;

  {
  __asm__  volatile   ("xorl %%eax,%%eax\n\t"
                       "repe; scasl\n\t"
                       "jz 1f\n\t"
                       "leal -4(%%edi),%%edi\n\t"
                       "bsfl (%%edi),%%eax\n"
                       "1:\tsubl %%ebx,%%edi\n\t"
                       "shll $3,%%edi\n\t"
                       "addl %%edi,%%eax": "=a" (res), "=&c" (d0), "=&D" (d1): "1" ((size +
                                                                                     31U) >>
                                                                                    5),
                       "2" (addr), "b" (addr): "memory");
  return ((int __attribute__((__always_inline__))  )res);
}
}
extern int find_next_bit(unsigned long const   *addr , int size , int offset ) ;
__inline static unsigned long __attribute__((__always_inline__))  ffz(unsigned long word ) 
{ 

  {
  __asm__  ("bsfl %1,%0": "=r" (word): "r" (~ word));
  return ((unsigned long __attribute__((__always_inline__))  )word);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __ffs(unsigned long word ) 
{ 

  {
  __asm__  ("bsfl %1,%0": "=r" (word): "rm" (word));
  return ((unsigned long __attribute__((__always_inline__))  )word);
}
}
__inline static int __attribute__((__always_inline__))  sched_find_first_bit(unsigned long const   *b ) 
{ int __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;
  long tmp___2 ;
  unsigned long __attribute__((__always_inline__))  tmp___3 ;
  long tmp___4 ;
  unsigned long __attribute__((__always_inline__))  tmp___5 ;
  unsigned long __attribute__((__always_inline__))  tmp___6 ;

  {
  tmp___0 = __builtin_expect((long )(! (! (*(b + 0))) != 0), 0L);
  if (tmp___0) {
    tmp = (int __attribute__((__always_inline__))  )__ffs((unsigned long )(*(b + 0)));
    return (tmp);
  }
  tmp___2 = __builtin_expect((long )(! (! (*(b + 1))) != 0), 0L);
  if (tmp___2) {
    tmp___1 = __ffs((unsigned long )(*(b + 1)));
    return ((int __attribute__((__always_inline__))  )(tmp___1 + 32UL));
  }
  tmp___4 = __builtin_expect((long )(! (! (*(b + 2))) != 0), 0L);
  if (tmp___4) {
    tmp___3 = __ffs((unsigned long )(*(b + 2)));
    return ((int __attribute__((__always_inline__))  )(tmp___3 + 64UL));
  }
  if ((*(b + 3))) {
    tmp___5 = __ffs((unsigned long )(*(b + 3)));
    return ((int __attribute__((__always_inline__))  )(tmp___5 + 96UL));
  }
  tmp___6 = __ffs((unsigned long )(*(b + 4)));
  return ((int __attribute__((__always_inline__))  )(tmp___6 + 128UL));
}
}
__inline static int __attribute__((__always_inline__))  ffs(int x ) 
{ int r ;

  {
  __asm__  ("bsfl %1,%0\n\t"
            "jnz 1f\n\t"
            "movl $-1,%0\n"
            "1:": "=r" (r): "rm" (x));
  return ((int __attribute__((__always_inline__))  )(r + 1));
}
}
__inline static int __attribute__((__always_inline__))  get_bitmask_order(unsigned int count ) 
{ int order ;

  {
  order = (int )generic_fls((int )count);
  return ((int __attribute__((__always_inline__))  )order);
}
}
__inline static unsigned int __attribute__((__always_inline__))  generic_hweight32(unsigned int w ) 
{ unsigned int res ;

  {
  res = (w & 1431655765U) + ((w >> 1) & 1431655765U);
  res = (res & 858993459U) + ((res >> 2) & 858993459U);
  res = (res & 252645135U) + ((res >> 4) & 252645135U);
  res = (res & 16711935U) + ((res >> 8) & 16711935U);
  return ((unsigned int __attribute__((__always_inline__))  )((res & 65535U) + ((res >>
                                                                                 16) &
                                                                                65535U)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  generic_hweight16(unsigned int w ) 
{ unsigned int res ;

  {
  res = (w & 21845U) + ((w >> 1) & 21845U);
  res = (res & 13107U) + ((res >> 2) & 13107U);
  res = (res & 3855U) + ((res >> 4) & 3855U);
  return ((unsigned int __attribute__((__always_inline__))  )((res & 255U) + ((res >>
                                                                               8) &
                                                                              255U)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  generic_hweight8(unsigned int w ) 
{ unsigned int res ;

  {
  res = (w & 85U) + ((w >> 1) & 85U);
  res = (res & 51U) + ((res >> 2) & 51U);
  return ((unsigned int __attribute__((__always_inline__))  )((res & 15U) + ((res >>
                                                                              4) &
                                                                             15U)));
}
}
__inline static unsigned long __attribute__((__always_inline__))  generic_hweight64(__u64 w ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = generic_hweight32((unsigned int )(w >> 32));
  tmp___0 = generic_hweight32((unsigned int )w);
  return ((unsigned long __attribute__((__always_inline__))  )(tmp + tmp___0));
}
}
__inline static unsigned long __attribute__((__always_inline__))  hweight_long(unsigned long w ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned long __attribute__((__always_inline__))  tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;

  {
  if (sizeof(w) == 4U) {
    tmp___1 = (unsigned long __attribute__((__always_inline__))  )generic_hweight32((unsigned int )w);
  } else {
    tmp___1 = generic_hweight64((unsigned long long )w);
  }
  return (tmp___1);
}
}
__inline static __u32 __attribute__((__always_inline__))  rol32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word << shift) | (word >> (32U - shift)));
}
}
__inline static __u32 __attribute__((__always_inline__))  ror32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word >> shift) | (word << (32U - shift)));
}
}
extern int nx_enabled ;
extern unsigned long long __supported_pte_mask ;
extern unsigned int __VMALLOC_RESERVE ;
__inline static int __attribute__((__always_inline__))  get_order(unsigned long size ) 
{ int order ;

  {
  size = (size - 1UL) >> 11;
  order = -1;
  while (1) {
    size >>= 1;
    order ++;
    if (! size) {
      break;
    }
  }
  return ((int __attribute__((__always_inline__))  )order);
}
}
extern int sysctl_legacy_va_layout ;
extern void handle_vm86_fault(struct kernel_vm86_regs * , long  ) ;
extern int handle_vm86_trap(struct kernel_vm86_regs * , long  , int  ) ;
extern int restore_i387_soft(void *s387 , struct _fpstate *buf ) ;
extern int save_i387_soft(void *s387 , struct _fpstate *buf ) ;
__inline static void __attribute__((__always_inline__))  wrmsrl(unsigned long msr ,
                                                                unsigned long long val ) 
{ unsigned long lo ;
  unsigned long hi ;

  {
  lo = (unsigned long )val;
  hi = (unsigned long )(val >> 32);
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (lo), "d" (hi));
}
}
__inline static __u32 __attribute__((__always_inline__))  ___arch__swab32(__u32 x )  __attribute__((__const__)) ;
__inline static __u32 __attribute__((__always_inline__))  ___arch__swab32(__u32 x ) 
{ 

  {
  __asm__  ("bswap %0": "=r" (x): "0" (x));
  return (x);
}
}
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64(__u64 val ) 
{ union __anonunion_v_7 v ;

  {
  v.u = val;
  __asm__  ("bswapl %0 ; bswapl %1 ; xchgl %0,%1": "=r" (v.s.a), "=r" (v.s.b): "0" (v.s.a),
            "1" (v.s.b));
  return (v.u);
}
}
__inline static __u16 __attribute__((__always_inline__))  __fswab16(__u16 x )  __attribute__((__const__)) ;
__inline static __u16 __attribute__((__always_inline__))  __fswab16(__u16 x ) 
{ __u16 __tmp ;
  __u16 __x ;

  {
  __tmp = x;
  __x = __tmp;
  return ((unsigned short )((((int )__x & 255) << 8) | (((int )__x & 65280) >> 8)));
}
}
__inline static __u16 __attribute__((__always_inline__))  __swab16p(__u16 const   *x ) 
{ __u16 __tmp ;
  __u16 __x ;

  {
  __tmp = (__u16 )(*x);
  __x = __tmp;
  return ((unsigned short )((((int )__x & 255) << 8) | (((int )__x & 65280) >> 8)));
}
}
__inline static void __attribute__((__always_inline__))  __swab16s(__u16 *addr ) 
{ __u16 __tmp ;
  __u16 __x ;

  {
  while (1) {
    __tmp = (*addr);
    __x = __tmp;
    (*addr) = (unsigned short )((((int )__x & 255) << 8) | (((int )__x & 65280) >>
                                                            8));
    break;
  }
  return;
}
}
__inline static __u32 __attribute__((__always_inline__))  __fswab32(__u32 x )  __attribute__((__const__)) ;
__inline static __u32 __attribute__((__always_inline__))  __fswab32(__u32 x ) 
{ __u32 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab32(x);
  return (tmp);
}
}
__inline static __u32 __attribute__((__always_inline__))  __swab32p(__u32 const   *x ) 
{ __u32 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab32((*x));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __swab32s(__u32 *addr ) 
{ 

  {
  while (1) {
    (*addr) = (__u32 )___arch__swab32((*addr));
    break;
  }
  return;
}
}
__inline static __u64 __attribute__((__always_inline__))  __fswab64(__u64 x )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  __fswab64(__u64 x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64(x);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __swab64p(__u64 const   *x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64((*x));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __swab64s(__u64 *addr ) 
{ 

  {
  while (1) {
    (*addr) = (__u64 )___arch__swab64((*addr));
    break;
  }
  return;
}
}
__inline static __le64 __attribute__((__always_inline__))  __cpu_to_le64p(__u64 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __u64 __attribute__((__always_inline__))  __le64_to_cpup(__le64 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __le32 __attribute__((__always_inline__))  __cpu_to_le32p(__u32 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __u32 __attribute__((__always_inline__))  __le32_to_cpup(__le32 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __le16 __attribute__((__always_inline__))  __cpu_to_le16p(__u16 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __u16 __attribute__((__always_inline__))  __le16_to_cpup(__le16 const   *p ) 
{ 

  {
  return ((*p));
}
}
__inline static __be64 __attribute__((__always_inline__))  __cpu_to_be64p(__u64 const   *p ) 
{ __be64 tmp ;

  {
  tmp = (__be64 )__swab64p(p);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __be64_to_cpup(__be64 const   *p ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  return (tmp);
}
}
__inline static __be32 __attribute__((__always_inline__))  __cpu_to_be32p(__u32 const   *p ) 
{ __be32 tmp ;

  {
  tmp = (__be32 )__swab32p(p);
  return (tmp);
}
}
__inline static __u32 __attribute__((__always_inline__))  __be32_to_cpup(__be32 const   *p ) 
{ __u32 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  return (tmp);
}
}
__inline static __be16 __attribute__((__always_inline__))  __cpu_to_be16p(__u16 const   *p ) 
{ __be16 tmp ;

  {
  tmp = (__be16 )__swab16p(p);
  return (tmp);
}
}
__inline static __u16 __attribute__((__always_inline__))  __be16_to_cpup(__be16 const   *p ) 
{ __u16 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  return (tmp);
}
}
extern __u32 ntohl(__be32  ) ;
extern __be32 htonl(__u32  ) ;
extern __u16 ntohs(__be16  ) ;
extern __be16 htons(__u16  ) ;
extern char const   linux_banner[] ;
extern int console_printk[] ;
extern struct notifier_block *panic_notifier_list ;
extern long (*panic_blink)(long time ) ;
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...) ;
extern  __attribute__((__noreturn__)) void ( __attribute__((__regparm__(3))) do_exit)(long error_code ) ;
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
extern int get_option(char **str , int *pint ) ;
extern char *get_options(char const   *str , int nints , int *ints ) ;
extern unsigned long long memparse(char *ptr , char **retptr ) ;
extern int __kernel_text_address(unsigned long addr ) ;
extern int kernel_text_address(unsigned long addr ) ;
extern int session_of_pgrp(int pgrp ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) vprintk)(char const   *fmt ,
                                                                             va_list args ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...) ;
extern unsigned long int_sqrt(unsigned long  ) ;
__inline static int __attribute__((__pure__, __always_inline__))  long_log2(unsigned long x ) 
{ int r ;

  {
  r = 0;
  x >>= 1;
  while (x > 0UL) {
    r ++;
    x >>= 1;
  }
  return ((int __attribute__((__pure__, __always_inline__))  )r);
}
}
__inline static unsigned long __attribute__((__always_inline__))  roundup_pow_of_two(unsigned long x )  __attribute__((__const__)) ;
__inline static unsigned long __attribute__((__always_inline__))  roundup_pow_of_two(unsigned long x ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = generic_fls((int )(x - 1UL));
  return ((unsigned long __attribute__((__always_inline__))  )(1UL << tmp));
}
}
extern int printk_ratelimit(void) ;
extern int __printk_ratelimit(int ratelimit_jiffies , int ratelimit_burst ) ;
__inline static void __attribute__((__always_inline__))  console_silent(void) 
{ 

  {
  console_printk[0] = 0;
  return;
}
}
__inline static void __attribute__((__always_inline__))  console_verbose(void) 
{ 

  {
  if (console_printk[0]) {
    console_printk[0] = 15;
  }
  return;
}
}
extern void bust_spinlocks(int yes ) ;
extern int oops_in_progress ;
extern int panic_timeout ;
extern int panic_on_oops ;
extern int tainted ;
extern char const   *print_tainted(void) ;
extern void add_taint(unsigned int  ) ;
extern enum system_states system_state ;
extern void dump_stack(void) ;
extern void BUILD_BUG(void) ;
extern int randomize_va_space ;
extern struct task_struct *( __attribute__((__regparm__(3))) __switch_to)(struct task_struct *prev ,
                                                                          struct task_struct *next ) ;
__inline static unsigned long __attribute__((__always_inline__))  _get_base(char *addr ) 
{ unsigned long __base ;

  {
  __asm__  ("movb %3,%%dh\n\t"
            "movb %2,%%dl\n\t"
            "shll $16,%%edx\n\t"
            "movw %1,%%dx": "=&d" (__base): "m" ((*(addr + 2))), "m" ((*(addr + 4))),
            "m" ((*(addr + 7))));
  return ((unsigned long __attribute__((__always_inline__))  )__base);
}
}
__inline static unsigned long __attribute__((__always_inline__))  get_limit(unsigned long segment ) 
{ unsigned long __limit ;

  {
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  return ((unsigned long __attribute__((__always_inline__))  )(__limit + 1UL));
}
}
__inline static void __attribute__((__always_inline__))  __set_64bit(unsigned long long *ptr ,
                                                                     unsigned int low ,
                                                                     unsigned int high ) 
{ 

  {
  __asm__  volatile   ("\n1:\t"
                       "movl (%0), %%eax\n\t"
                       "movl 4(%0), %%edx\n\t"
                       "lock cmpxchg8b (%0)\n\t"
                       "jnz 1b": : "D" (ptr), "b" (low), "c" (high): "ax", "dx", "memory");
}
}
__inline static void __attribute__((__always_inline__))  __set_64bit_constant(unsigned long long *ptr ,
                                                                              unsigned long long value ) 
{ 

  {
  __set_64bit(ptr, (unsigned int )value, (unsigned int )(value >> 32ULL));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __set_64bit_var(unsigned long long *ptr ,
                                                                         unsigned long long value ) 
{ 

  {
  __set_64bit(ptr, (*((unsigned int *)(& value) + 0)), (*((unsigned int *)(& value) +
                                                          1)));
  return;
}
}
__inline static unsigned long __attribute__((__always_inline__))  __xchg(unsigned long x ,
                                                                         void volatile   *ptr ,
                                                                         int size ) 
{ 

  {
  switch (size) {
  case 1: 
  __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (x): "memory");
  break;
  case 2: 
  __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (x): "memory");
  break;
  case 4: 
  __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (x): "memory");
  break;
  }
  return ((unsigned long __attribute__((__always_inline__))  )x);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __cmpxchg(void volatile   *ptr ,
                                                                            unsigned long old ,
                                                                            unsigned long new ,
                                                                            int size ) 
{ unsigned long prev ;

  {
  switch (size) {
  case 1: 
  __asm__  volatile   ("lock ; "
                       "cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (old): "memory");
  return ((unsigned long __attribute__((__always_inline__))  )prev);
  case 2: 
  __asm__  volatile   ("lock ; "
                       "cmpxchgw %w1,%2": "=a" (prev): "q" (new), "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (old): "memory");
  return ((unsigned long __attribute__((__always_inline__))  )prev);
  case 4: 
  __asm__  volatile   ("lock ; "
                       "cmpxchgl %1,%2": "=a" (prev): "q" (new), "m" ((*((struct __xchg_dummy *)ptr))),
                       "0" (old): "memory");
  return ((unsigned long __attribute__((__always_inline__))  )prev);
  }
  return ((unsigned long __attribute__((__always_inline__))  )old);
}
}
extern void disable_hlt(void) ;
extern void enable_hlt(void) ;
extern int es7000_plat ;
extern void cpu_idle_wait(void) ;
extern unsigned long arch_align_stack(unsigned long sp ) ;
extern unsigned long __per_cpu_offset[8] ;
extern int tsc_disable ;
extern struct cpuinfo_x86 boot_cpu_data ;
extern struct cpuinfo_x86 new_cpu_data ;
extern struct tss_struct doublefault_tss ;
extern struct tss_struct per_cpu__init_tss ;
extern struct cpuinfo_x86 cpu_data[] ;
extern int phys_proc_id[8] ;
extern int cpu_core_id[8] ;
extern char ignore_fpu_irq ;
extern void identify_cpu(struct cpuinfo_x86 * ) ;
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
extern void detect_ht(struct cpuinfo_x86 *c ) ;
__inline static void __attribute__((__always_inline__))  cpuid(unsigned int op , unsigned int *eax ,
                                                               unsigned int *ebx ,
                                                               unsigned int *ecx ,
                                                               unsigned int *edx ) 
{ 

  {
  __asm__  ("cpuid": "=a" ((*eax)), "=b" ((*ebx)), "=c" ((*ecx)), "=d" ((*edx)): "0" (op),
            "c" (0));
}
}
__inline static void __attribute__((__always_inline__))  cpuid_count(int op , int count ,
                                                                     int *eax , int *ebx ,
                                                                     int *ecx , int *edx ) 
{ 

  {
  __asm__  ("cpuid": "=a" ((*eax)), "=b" ((*ebx)), "=c" ((*ecx)), "=d" ((*edx)): "0" (op),
            "c" (count));
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_eax(unsigned int op ) 
{ unsigned int eax ;

  {
  __asm__  ("cpuid": "=a" (eax): "0" (op): "bx", "cx", "dx");
  return ((unsigned int __attribute__((__always_inline__))  )eax);
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_ebx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;

  {
  __asm__  ("cpuid": "=a" (eax), "=b" (ebx): "0" (op): "cx", "dx");
  return ((unsigned int __attribute__((__always_inline__))  )ebx);
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_ecx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ecx ;

  {
  __asm__  ("cpuid": "=a" (eax), "=c" (ecx): "0" (op): "bx", "dx");
  return ((unsigned int __attribute__((__always_inline__))  )ecx);
}
}
__inline static unsigned int __attribute__((__always_inline__))  cpuid_edx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int edx ;

  {
  __asm__  ("cpuid": "=a" (eax), "=d" (edx): "0" (op): "bx", "cx");
  return ((unsigned int __attribute__((__always_inline__))  )edx);
}
}
extern unsigned long mmu_cr4_features ;
__inline static void __attribute__((__always_inline__))  set_in_cr4(unsigned long mask ) 
{ 

  {
  mmu_cr4_features |= mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "orl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  clear_in_cr4(unsigned long mask ) 
{ 

  {
  mmu_cr4_features &= ~ mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "andl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (~ mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  __monitor(void const   *eax ,
                                                                   unsigned long ecx ,
                                                                   unsigned long edx ) 
{ 

  {
  __asm__  volatile   (".byte 0x0f,0x01,0xc8;": : "a" (eax), "c" (ecx), "d" (edx));
}
}
__inline static void __attribute__((__always_inline__))  __mwait(unsigned long eax ,
                                                                 unsigned long ecx ) 
{ 

  {
  __asm__  volatile   (".byte 0x0f,0x01,0xc9;": : "a" (eax), "c" (ecx));
}
}
extern unsigned int machine_id ;
extern unsigned int machine_submodel_id ;
extern unsigned int BIOS_revision ;
extern unsigned int mca_pentium_flag ;
extern int bootloader_type ;
__inline static void __attribute__((__always_inline__))  load_esp0(struct tss_struct *tss ,
                                                                   struct thread_struct *thread ) 
{ long tmp ;

  {
  tss->esp0 = thread->esp0;
  tmp = __builtin_expect((long )(! (! ((unsigned long )tss->ss1 != thread->sysenter_cs)) !=
                                 0), 0L);
  if (tmp) {
    tss->ss1 = (unsigned short )thread->sysenter_cs;
    __asm__  volatile   ("wrmsr": : "c" (372), "a" (thread->sysenter_cs), "d" (0));
  }
  return;
}
}
extern void release_thread(struct task_struct * ) ;
extern void prepare_to_copy(struct task_struct *tsk ) ;
extern int kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
extern unsigned long thread_saved_pc(struct task_struct *tsk ) ;
extern void show_trace(struct task_struct *task , unsigned long *stack ) ;
extern unsigned long get_wchan(struct task_struct *p ) ;
__inline static void __attribute__((__always_inline__))  rep_nop(void) 
{ 

  {
  __asm__  volatile   ("rep;nop": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  prefetch__extinline(void const   *x ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
}
}
__inline static void __attribute__((__always_inline__))  prefetchw__extinline(void const   *x ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchw (%1)"
                       "\n664:\n"
                       ".previous": : "i" (63), "r" (x));
}
}
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
extern unsigned long boot_option_idle_override ;
__inline static struct thread_info  __attribute__((__always_inline__)) *current_thread_info(void) 
{ struct thread_info *ti ;

  {
  __asm__  ("andl %%esp,%0; ": "=r" (ti): "0" (~ 8191));
  return ((struct thread_info  __attribute__((__always_inline__)) *)ti);
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__unused__))  ;
__inline static void __attribute__((__always_inline__))  set_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = current_thread_info();
  set_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = current_thread_info();
  clear_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return;
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = current_thread_info();
  tmp___0 = test_and_set_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = current_thread_info();
  tmp___0 = test_and_clear_bit(flag, (unsigned long volatile   *)(& tmp->flags));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  test_thread_flag(int flag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;

  {
  tmp___1 = current_thread_info();
  tmp___2 = variable_test_bit(flag, (unsigned long const volatile   *)(& tmp___1->flags));
  return (tmp___2);
}
}
__inline static void __attribute__((__always_inline__))  set_ti_thread_flag(struct thread_info *ti ,
                                                                            int flag ) 
{ 

  {
  set_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_ti_thread_flag(struct thread_info *ti ,
                                                                              int flag ) 
{ 

  {
  clear_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return;
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_ti_thread_flag(struct thread_info *ti ,
                                                                                    int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_ti_thread_flag(struct thread_info *ti ,
                                                                                      int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_clear_bit(flag, (unsigned long volatile   *)(& ti->flags));
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_ti_thread_flag(struct thread_info *ti ,
                                                                            int flag ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  set_need_resched(void) 
{ 

  {
  set_thread_flag(3);
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_need_resched(void) 
{ 

  {
  clear_thread_flag(3);
  return;
}
}
__inline static void __attribute__((__always_inline__))  atomic_add(int i , atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "addl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  atomic_sub(int i , atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "subl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
__inline static int __attribute__((__always_inline__))  atomic_sub_and_test(int i ,
                                                                            atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "subl %2,%0; sete %1": "=m" (v->counter), "=qm" (c): "ir" (i),
                       "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )c);
}
}
__inline static void __attribute__((__always_inline__))  atomic_inc(atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "incl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  atomic_dec(atomic_t *v ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "decl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static int __attribute__((__always_inline__))  atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "decl %0; sete %1": "=m" (v->counter), "=qm" (c): "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )((int )c != 0));
}
}
__inline static int __attribute__((__always_inline__))  atomic_inc_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "incl %0; sete %1": "=m" (v->counter), "=qm" (c): "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )((int )c != 0));
}
}
__inline static int __attribute__((__always_inline__))  atomic_add_negative(int i ,
                                                                            atomic_t *v ) 
{ unsigned char c ;

  {
  __asm__  volatile   ("lock ; "
                       "addl %2,%0; sets %1": "=m" (v->counter), "=qm" (c): "ir" (i),
                       "m" (v->counter): "memory");
  return ((int __attribute__((__always_inline__))  )c);
}
}
__inline static int __attribute__((__always_inline__))  atomic_add_return(int i ,
                                                                          atomic_t *v ) 
{ int __i ;

  {
  __i = i;
  __asm__  volatile   ("lock ; "
                       "xaddl %0, %1;": "=r" (i): "m" (v->counter), "0" (i));
  return ((int __attribute__((__always_inline__))  )(i + __i));
}
}
__inline static int __attribute__((__always_inline__))  atomic_sub_return(int i ,
                                                                          atomic_t *v ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = atomic_add_return(- i, v);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  _raw_spin_unlock(spinlock_t *lock ) 
{ char oldval ;

  {
  oldval = (char)1;
  __asm__  volatile   ("xchgb %b0, %1": "=q" (oldval), "=m" (lock->slock): "0" (oldval): "memory");
}
}
__inline static int __attribute__((__always_inline__))  _raw_spin_trylock(spinlock_t *lock ) 
{ char oldval ;

  {
  __asm__  volatile   ("xchgb %b0,%1": "=q" (oldval), "=m" (lock->slock): "0" (0): "memory");
  return ((int __attribute__((__always_inline__))  )((int )oldval > 0));
}
}
__inline static void __attribute__((__always_inline__))  _raw_spin_lock(spinlock_t *lock ) 
{ 

  {
  __asm__  volatile   ("\n1:\t"
                       "lock ; decb %0\n\t"
                       "jns 3f\n"
                       "2:\t"
                       "rep;nop\n\t"
                       "cmpb $0,%0\n\t"
                       "jle 2b\n\t"
                       "jmp 1b\n"
                       "3:\n\t": "=m" (lock->slock): : "memory");
}
}
__inline static void __attribute__((__always_inline__))  _raw_spin_lock_flags(spinlock_t *lock ,
                                                                              unsigned long flags ) 
{ 

  {
  __asm__  volatile   ("\n1:\t"
                       "lock ; decb %0\n\t"
                       "jns 4f\n\t"
                       "2:\t"
                       "testl $0x200, %1\n\t"
                       "jz 3f\n\t"
                       "sti\n\t"
                       "3:\t"
                       "rep;nop\n\t"
                       "cmpb $0, %0\n\t"
                       "jle 3b\n\t"
                       "cli\n\t"
                       "jmp 1b\n"
                       "4:\n\t": "=m" (lock->slock): "r" (flags): "memory");
}
}
__inline static void __attribute__((__always_inline__))  _raw_read_lock(rwlock_t *rw ) 
{ 

  {
  while (1) {
    __asm__  volatile   ("lock ; "
                         "subl $1,(%0)\n\t"
                         "jns 1f\n"
                         "call "
                         "__read_lock_failed"
                         "\n\t"
                         "1:\n": : "a" (rw): "memory");
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  _raw_write_lock(rwlock_t *rw ) 
{ 

  {
  while (1) {
    __asm__  volatile   ("lock ; "
                         "subl $"
                         "0x01000000"
                         ",(%0)\n\t"
                         "jz 1f\n"
                         "call "
                         "__write_lock_failed"
                         "\n\t"
                         "1:\n": : "a" (rw): "memory");
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  _raw_read_trylock(rwlock_t *lock ) 
{ atomic_t *count ;

  {
  count = (atomic_t *)lock;
  atomic_dec(count);
  if (count->counter >= 0) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  atomic_inc(count);
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  _raw_write_trylock(rwlock_t *lock ) 
{ atomic_t *count ;
  int __attribute__((__always_inline__))  tmp ;

  {
  count = (atomic_t *)lock;
  tmp = atomic_sub_and_test(16777216, count);
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  atomic_add(16777216, count);
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int ( __attribute__((__regparm__(3))) _spin_trylock)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) _read_trylock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) _write_trylock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_lock)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_lock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_lock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _spin_lock_irqsave)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _read_lock_irqsave)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _write_lock_irqsave)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_lock_irq)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_lock_bh)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_lock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_lock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_lock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_lock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock_irqrestore)(spinlock_t *lock ,
                                                                       unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock_irq)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _spin_unlock_bh)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_irqrestore)(rwlock_t *lock ,
                                                                       unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_irqrestore)(rwlock_t *lock ,
                                                                        unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_irq)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_bh)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) _spin_trylock_bh)(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int ( __attribute__((__regparm__(3))) generic_raw_read_trylock)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int in_lock_functions(unsigned long addr ) ;
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
__inline static void __attribute__((__always_inline__))  bit_spin_lock(int bitnum ,
                                                                       unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  while (1) {
    break;
  }
  while (1) {
    tmp___1 = test_and_set_bit(bitnum, (unsigned long volatile   *)addr);
    if (! tmp___1) {
      break;
    }
    while (1) {
      tmp___0 = variable_test_bit(bitnum, (unsigned long const volatile   *)addr);
      if (! tmp___0) {
        break;
      }
      while (1) {
        break;
      }
      rep_nop();
      while (1) {
        break;
      }
    }
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  bit_spin_trylock(int bitnum ,
                                                                         unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = test_and_set_bit(bitnum, (unsigned long volatile   *)addr);
  if (tmp) {
    while (1) {
      break;
    }
    return ((int __attribute__((__always_inline__))  )0);
  }
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static void __attribute__((__always_inline__))  bit_spin_unlock(int bitnum ,
                                                                         unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  while (1) {
    tmp___0 = variable_test_bit(bitnum, (unsigned long const volatile   *)addr);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1 != 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    if (tmp___3) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (575), "i" ("include/linux/spinlock.h"));
    }
    break;
  }
  __asm__  volatile   ("": : : "memory");
  clear_bit(bitnum, (unsigned long volatile   *)addr);
  while (1) {
    break;
  }
}
}
__inline static int __attribute__((__always_inline__))  bit_spin_is_locked(int bitnum ,
                                                                           unsigned long *addr ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = variable_test_bit(bitnum, (unsigned long const volatile   *)addr);
  return (tmp___0);
}
}
extern kernel_cap_t cap_bset ;
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_combine(kernel_cap_t a ,
                                                                             kernel_cap_t b ) 
{ kernel_cap_t dest ;

  {
  dest = a | b;
  return (dest);
}
}
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_intersect(kernel_cap_t a ,
                                                                               kernel_cap_t b ) 
{ kernel_cap_t dest ;

  {
  dest = a & b;
  return (dest);
}
}
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_drop(kernel_cap_t a ,
                                                                          kernel_cap_t drop ) 
{ kernel_cap_t dest ;

  {
  dest = a & ~ drop;
  return (dest);
}
}
__inline static kernel_cap_t __attribute__((__always_inline__))  cap_invert(kernel_cap_t c ) 
{ kernel_cap_t dest ;

  {
  dest = ~ c;
  return (dest);
}
}
__inline static void __attribute__((__always_inline__))  write_seqlock(seqlock_t *sl ) 
{ 

  {
  _spin_lock(& sl->lock);
  sl->sequence ++;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_sequnlock(seqlock_t *sl ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  sl->sequence ++;
  _spin_unlock(& sl->lock);
}
}
__inline static int __attribute__((__always_inline__))  write_tryseqlock(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  tmp = _spin_trylock(& sl->lock);
  ret = tmp;
  if (ret) {
    sl->sequence ++;
    __asm__  volatile   ("": : : "memory");
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static unsigned int __attribute__((__always_inline__))  read_seqbegin(seqlock_t const   *sl ) 
{ unsigned int ret ;

  {
  ret = (unsigned int )sl->sequence;
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((unsigned int __attribute__((__always_inline__))  )ret);
}
}
__inline static int __attribute__((__always_inline__))  read_seqretry(seqlock_t const   *sl ,
                                                                      unsigned int iv ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((int __attribute__((__always_inline__))  )((iv & 1U) | (unsigned int )(sl->sequence ^
                                                                                 (unsigned int const   )iv)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  read_seqcount_begin(seqcount_t const   *s ) 
{ unsigned int ret ;

  {
  ret = (unsigned int )s->sequence;
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((unsigned int __attribute__((__always_inline__))  )ret);
}
}
__inline static int __attribute__((__always_inline__))  read_seqcount_retry(seqcount_t const   *s ,
                                                                            unsigned int iv ) 
{ 

  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  return ((int __attribute__((__always_inline__))  )((iv & 1U) | (unsigned int )(s->sequence ^
                                                                                 (unsigned int const   )iv)));
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_begin(seqcount_t *s ) 
{ 

  {
  s->sequence ++;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_end(seqcount_t *s ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  s->sequence ++;
}
}
__inline static int __attribute__((__always_inline__))  timespec_equal(struct timespec *a ,
                                                                       struct timespec *b ) 
{ int tmp ;

  {
  if (a->tv_sec == b->tv_sec) {
    if (a->tv_nsec == b->tv_nsec) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  mktime(unsigned int year ,
                                                                         unsigned int mon ,
                                                                         unsigned int day ,
                                                                         unsigned int hour ,
                                                                         unsigned int min ,
                                                                         unsigned int sec ) 
{ 

  {
  mon -= 2U;
  if (0 >= (int )mon) {
    mon += 12U;
    year --;
  }
  return ((unsigned long __attribute__((__always_inline__))  )((((((unsigned long )((((year /
                                                                                       4U -
                                                                                       year /
                                                                                       100U) +
                                                                                      year /
                                                                                      400U) +
                                                                                     (367U *
                                                                                      mon) /
                                                                                     12U) +
                                                                                    day) +
                                                                   (unsigned long )(year *
                                                                                    365U)) -
                                                                  719499UL) * 24UL +
                                                                 (unsigned long )hour) *
                                                                60UL + (unsigned long )min) *
                                                               60UL + (unsigned long )sec));
}
}
extern struct timespec xtime ;
extern struct timespec wall_to_monotonic ;
extern seqlock_t xtime_lock ;
__inline static unsigned long __attribute__((__always_inline__))  get_seconds(void) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )xtime.tv_sec);
}
}
extern struct timespec current_kernel_time(void) ;
extern void do_gettimeofday(struct timeval *tv ) ;
extern int do_settimeofday(struct timespec *tv ) ;
extern int do_sys_settimeofday(struct timespec *tv , struct timezone *tz ) ;
extern void clock_was_set(void) ;
extern int do_posix_clock_monotonic_gettime(struct timespec *tp ) ;
extern long do_nanosleep(struct timespec *t ) ;
extern long do_utimes(char *filename , struct timeval *times ) ;
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
extern int do_getitimer(int which , struct itimerval *value ) ;
extern void getnstimeofday(struct timespec *tv ) ;
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
__inline static void __attribute__((__always_inline__))  set_normalized_timespec(struct timespec *ts ,
                                                                                 time_t sec ,
                                                                                 long nsec ) 
{ 

  {
  while (nsec > 1000000000L) {
    nsec -= 1000000000L;
    sec ++;
  }
  while (nsec < 0L) {
    nsec += 1000000000L;
    sec --;
  }
  ts->tv_sec = sec;
  ts->tv_nsec = nsec;
  return;
}
}
__inline static cycles_t __attribute__((__always_inline__))  get_cycles(void) 
{ unsigned long long ret ;

  {
  ret = 0ULL;
  __asm__  volatile   ("rdtsc": "=A" (ret));
  return (ret);
}
}
extern unsigned long cpu_khz ;
extern unsigned long tick_usec ;
extern unsigned long tick_nsec ;
extern int tickadj ;
extern int time_state ;
extern int time_status ;
extern long time_offset ;
extern long time_constant ;
extern long time_tolerance ;
extern long time_precision ;
extern long time_maxerror ;
extern long time_esterror ;
extern long time_freq ;
extern long time_reftime ;
extern long time_adjust ;
extern long time_next_adjust ;
extern long pps_offset ;
extern long pps_jitter ;
extern long pps_freq ;
extern long pps_stabil ;
extern long pps_valid ;
extern int pps_shift ;
extern long pps_jitcnt ;
extern long pps_calcnt ;
extern long pps_errcnt ;
extern long pps_stbcnt ;
__inline static void __attribute__((__always_inline__))  time_interpolator_reset(void) 
{ 

  {
  return;
}
}
__inline static long __attribute__((__always_inline__))  div_ll_X_l_rem__extinline(long long divs ,
                                                                                   long div ,
                                                                                   long *rem ) 
{ long dum2 ;

  {
  __asm__  ("divl %2": "=a" (dum2), "=d" ((*rem)): "rm" (div), "A" (divs));
  return ((long __attribute__((__always_inline__))  )dum2);
}
}
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
extern u64 get_jiffies_64(void) ;
__inline static unsigned int __attribute__((__always_inline__))  jiffies_to_msecs(unsigned long j ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )j);
}
}
__inline static unsigned int __attribute__((__always_inline__))  jiffies_to_usecs(unsigned long j ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(1000UL * j));
}
}
__inline static unsigned long __attribute__((__always_inline__))  msecs_to_jiffies(unsigned int m ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = jiffies_to_msecs(2147483646UL);
  if (m > (unsigned int )tmp) {
    return ((unsigned long __attribute__((__always_inline__))  )2147483646UL);
  }
  return ((unsigned long __attribute__((__always_inline__))  )((m + 1U) - 1U));
}
}
__inline static unsigned long __attribute__((__always_inline__))  usecs_to_jiffies(unsigned int u ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = jiffies_to_usecs(2147483646UL);
  if (u > (unsigned int )tmp) {
    return ((unsigned long __attribute__((__always_inline__))  )2147483646UL);
  }
  return ((unsigned long __attribute__((__always_inline__))  )(((u + 1000U) - 1U) /
                                                               1000U));
}
}
__inline static unsigned long __attribute__((__always_inline__))  timespec_to_jiffies(struct timespec  const  *value ) 
{ unsigned long sec ;
  long nsec ;

  {
  sec = (unsigned long )value->tv_sec;
  nsec = (long )(((unsigned long )value->tv_nsec + 999848UL) - 1UL);
  if (sec >= 2147157UL) {
    sec = 2147157UL;
    nsec = 0L;
  }
  return ((unsigned long __attribute__((__always_inline__))  )(((unsigned long long )sec *
                                                                4194941632ULL + ((unsigned long long )nsec *
                                                                                 2252142140ULL >>
                                                                                 29)) >>
                                                               22));
}
}
__inline static void __attribute__((__always_inline__))  jiffies_to_timespec(unsigned long jiffies___0 ,
                                                                             struct timespec *value ) 
{ u64 nsec ;

  {
  nsec = (unsigned long long )jiffies___0 * 999848ULL;
  value->tv_sec = (time_t )div_ll_X_l_rem__extinline((long long )nsec, 1000000000L,
                                                     & value->tv_nsec);
  return;
}
}
__inline static unsigned long __attribute__((__always_inline__))  timeval_to_jiffies(struct timeval  const  *value ) 
{ unsigned long sec ;
  long usec ;

  {
  sec = (unsigned long )value->tv_sec;
  usec = (long )value->tv_usec;
  if (sec >= 2147157UL) {
    sec = 2147157UL;
    usec = 0L;
  }
  return ((unsigned long __attribute__((__always_inline__))  )(((unsigned long long )sec *
                                                                4194941632ULL + (((unsigned long long )usec *
                                                                                  2199357558ULL +
                                                                                  2199023255551ULL) >>
                                                                                 19)) >>
                                                               22));
}
}
__inline static void __attribute__((__always_inline__))  jiffies_to_timeval(unsigned long jiffies___0 ,
                                                                            struct timeval *value ) 
{ u64 nsec ;

  {
  nsec = (unsigned long long )jiffies___0 * 999848ULL;
  value->tv_sec = (time_t )div_ll_X_l_rem__extinline((long long )nsec, 1000000000L,
                                                     & value->tv_usec);
  value->tv_usec /= 1000L;
  return;
}
}
__inline static clock_t __attribute__((__always_inline__))  jiffies_to_clock_t(long x ) 
{ u64 tmp ;
  unsigned long __upper ;
  unsigned long __low ;
  unsigned long __high ;
  unsigned long __mod ;
  unsigned long __base ;

  {
  tmp = (unsigned long long )x * 999848ULL;
  __base = 10000000UL;
  __asm__  ("": "=a" (__low), "=d" (__high): "A" (tmp));
  __upper = __high;
  if (__high) {
    __upper = __high % __base;
    __high = __high / __base;
  }
  __asm__  ("divl %2": "=a" (__low), "=d" (__mod): "rm" (__base), "0" (__low), "1" (__upper));
  __asm__  ("": "=A" (tmp): "a" (__low), "d" (__high));
  return ((long )tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  clock_t_to_jiffies(unsigned long x ) 
{ 

  {
  if (x >= 429496729UL) {
    return ((unsigned long __attribute__((__always_inline__))  )(~ 0UL));
  }
  return ((unsigned long __attribute__((__always_inline__))  )(x * 10UL));
}
}
__inline static u64 __attribute__((__always_inline__))  jiffies_64_to_clock_t(u64 x ) 
{ unsigned long __upper ;
  unsigned long __low ;
  unsigned long __high ;
  unsigned long __mod ;
  unsigned long __base ;

  {
  x *= 999848ULL;
  __base = 10000000UL;
  __asm__  ("": "=a" (__low), "=d" (__high): "A" (x));
  __upper = __high;
  if (__high) {
    __upper = __high % __base;
    __high = __high / __base;
  }
  __asm__  ("divl %2": "=a" (__low), "=d" (__mod): "rm" (__base), "0" (__low), "1" (__upper));
  __asm__  ("": "=A" (x): "a" (__low), "d" (__high));
  return (x);
}
}
__inline static u64 __attribute__((__always_inline__))  nsec_to_clock_t(u64 x ) 
{ unsigned long __upper ;
  unsigned long __low ;
  unsigned long __high ;
  unsigned long __mod ;
  unsigned long __base ;

  {
  __base = 10000000UL;
  __asm__  ("": "=a" (__low), "=d" (__high): "A" (x));
  __upper = __high;
  if (__high) {
    __upper = __high % __base;
    __high = __high / __base;
  }
  __asm__  ("divl %2": "=a" (__low), "=d" (__mod): "rm" (__base), "0" (__low), "1" (__upper));
  __asm__  ("": "=A" (x): "a" (__low), "d" (__high));
  return (x);
}
}
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
extern struct rb_node *rb_next(struct rb_node * ) ;
extern struct rb_node *rb_prev(struct rb_node * ) ;
extern struct rb_node *rb_first(struct rb_root * ) ;
extern struct rb_node *rb_last(struct rb_root * ) ;
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
__inline static void __attribute__((__always_inline__))  rb_link_node(struct rb_node *node ,
                                                                      struct rb_node *parent ,
                                                                      struct rb_node **rb_link ) 
{ 

  {
  node->rb_parent = parent;
  node->rb_color = 0;
  node->rb_right = (struct rb_node *)((void *)0);
  node->rb_left = node->rb_right;
  (*rb_link) = node;
  return;
}
}
extern char *strpbrk(char const   * , char const   * ) ;
extern char *strsep(char ** , char const   * ) ;
extern __kernel_size_t strspn(char const   * , char const   * ) ;
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
__inline static char __attribute__((__always_inline__))  *strcpy(char *dest , char const   *src ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  __asm__  volatile   ("1:\tlodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b": "=&S" (d0), "=&D" (d1), "=&a" (d2): "0" (src), "1" (dest): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static char __attribute__((__always_inline__))  *strncpy(char *dest , char const   *src ,
                                                                  size_t count ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;

  {
  __asm__  volatile   ("1:\tdecl %2\n\t"
                       "js 2f\n\t"
                       "lodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n\t"
                       "rep\n\t"
                       "stosb\n"
                       "2:": "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3): "0" (src),
                       "1" (dest), "2" (count): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static char __attribute__((__always_inline__))  *strcat(char *dest , char const   *src ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;

  {
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "decl %1\n"
                       "1:\tlodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b": "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3): "0" (src),
                       "1" (dest), "2" (0), "3" (4294967295U): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static char __attribute__((__always_inline__))  *strncat(char *dest , char const   *src ,
                                                                  size_t count ) 
{ int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;

  {
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "decl %1\n\t"
                       "movl %8,%3\n"
                       "1:\tdecl %3\n\t"
                       "js 2f\n\t"
                       "lodsb\n\t"
                       "stosb\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n"
                       "2:\txorl %2,%2\n\t"
                       "stosb": "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3): "0" (src),
                       "1" (dest), "2" (0), "3" (4294967295U), "g" (count): "memory");
  return ((char __attribute__((__always_inline__))  *)dest);
}
}
__inline static int __attribute__((__always_inline__))  strcmp(char const   *cs ,
                                                               char const   *ct ) 
{ int d0 ;
  int d1 ;
  register int __res ;

  {
  __asm__  volatile   ("1:\tlodsb\n\t"
                       "scasb\n\t"
                       "jne 2f\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n\t"
                       "xorl %%eax,%%eax\n\t"
                       "jmp 3f\n"
                       "2:\tsbbl %%eax,%%eax\n\t"
                       "orb $1,%%al\n"
                       "3:": "=a" (__res), "=&S" (d0), "=&D" (d1): "1" (cs), "2" (ct));
  return ((int __attribute__((__always_inline__))  )__res);
}
}
__inline static int __attribute__((__always_inline__))  strncmp(char const   *cs ,
                                                                char const   *ct ,
                                                                size_t count ) 
{ register int __res ;
  int d0 ;
  int d1 ;
  int d2 ;

  {
  __asm__  volatile   ("1:\tdecl %3\n\t"
                       "js 2f\n\t"
                       "lodsb\n\t"
                       "scasb\n\t"
                       "jne 3f\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n"
                       "2:\txorl %%eax,%%eax\n\t"
                       "jmp 4f\n"
                       "3:\tsbbl %%eax,%%eax\n\t"
                       "orb $1,%%al\n"
                       "4:": "=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2): "1" (cs),
                       "2" (ct), "3" (count));
  return ((int __attribute__((__always_inline__))  )__res);
}
}
__inline static char __attribute__((__always_inline__))  *strchr(char const   *s ,
                                                                 int c ) 
{ int d0 ;
  register char *__res ;

  {
  __asm__  volatile   ("movb %%al,%%ah\n"
                       "1:\tlodsb\n\t"
                       "cmpb %%ah,%%al\n\t"
                       "je 2f\n\t"
                       "testb %%al,%%al\n\t"
                       "jne 1b\n\t"
                       "movl $1,%1\n"
                       "2:\tmovl %1,%0\n\t"
                       "decl %0": "=a" (__res), "=&S" (d0): "1" (s), "0" (c));
  return ((char __attribute__((__always_inline__))  *)__res);
}
}
__inline static char __attribute__((__always_inline__))  *strrchr(char const   *s ,
                                                                  int c ) 
{ int d0 ;
  int d1 ;
  register char *__res ;

  {
  __asm__  volatile   ("movb %%al,%%ah\n"
                       "1:\tlodsb\n\t"
                       "cmpb %%ah,%%al\n\t"
                       "jne 2f\n\t"
                       "leal -1(%%esi),%0\n"
                       "2:\ttestb %%al,%%al\n\t"
                       "jne 1b": "=g" (__res), "=&S" (d0), "=&a" (d1): "0" (0), "1" (s),
                       "2" (c));
  return ((char __attribute__((__always_inline__))  *)__res);
}
}
__inline static size_t __attribute__((__always_inline__))  strlen(char const   *s ) 
{ int d0 ;
  register int __res ;

  {
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "notl %0\n\t"
                       "decl %0": "=c" (__res), "=&D" (d0): "1" (s), "a" (0), "0" (4294967295U));
  return ((unsigned int )__res);
}
}
__inline static void __attribute__((__always_inline__))  *__memcpy(void *to , void const   *from ,
                                                                   size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
}
}
__inline static void __attribute__((__always_inline__))  *__constant_memcpy(void *to ,
                                                                            void const   *from ,
                                                                            size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
  if (! n) {
    return ((void __attribute__((__always_inline__))  *)to);
  }
  switch ((int )n) {
  case 1: 
  (*((char *)to)) = (*((char *)from));
  return ((void __attribute__((__always_inline__))  *)to);
  case 2: 
  (*((short *)to)) = (*((short *)from));
  return ((void __attribute__((__always_inline__))  *)to);
  case 4: 
  (*((int *)to)) = (*((int *)from));
  return ((void __attribute__((__always_inline__))  *)to);
  case 3: 
  (*((short *)to)) = (*((short *)from));
  (*((char *)to + 2)) = (*((char *)from + 2));
  return ((void __attribute__((__always_inline__))  *)to);
  case 5: 
  (*((int *)to)) = (*((int *)from));
  (*((char *)to + 4)) = (*((char *)from + 4));
  return ((void __attribute__((__always_inline__))  *)to);
  case 6: 
  (*((int *)to)) = (*((int *)from));
  (*((short *)to + 2)) = (*((short *)from + 2));
  return ((void __attribute__((__always_inline__))  *)to);
  case 8: 
  (*((int *)to)) = (*((int *)from));
  (*((int *)to + 1)) = (*((int *)from + 1));
  return ((void __attribute__((__always_inline__))  *)to);
  }
  esi = (long )from;
  edi = (long )to;
  if (n >= 20U) {
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n /
                                                                                    4U),
                         "1" (edi), "2" (esi): "memory");
  } else {
    if (n >= 16U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
    if (n >= 12U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
    if (n >= 8U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
    if (n >= 4U) {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
    }
  }
  switch ((int )(n % 4U)) {
  case 0: ;
  return ((void __attribute__((__always_inline__))  *)to);
  case 1: 
  __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
  case 2: 
  __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
  default: 
  __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
  return ((void __attribute__((__always_inline__))  *)to);
  }
}
}
extern void *memmove(void *dest , void const   *src , size_t n ) ;
__inline static void __attribute__((__always_inline__))  *memchr(void const   *cs ,
                                                                 int c , size_t count ) 
{ int d0 ;
  register void *__res ;

  {
  if (! count) {
    return ((void __attribute__((__always_inline__))  *)((void *)0));
  }
  __asm__  volatile   ("repne\n\t"
                       "scasb\n\t"
                       "je 1f\n\t"
                       "movl $1,%0\n"
                       "1:\tdecl %0": "=D" (__res), "=&c" (d0): "a" (c), "0" (cs),
                       "1" (count));
  return ((void __attribute__((__always_inline__))  *)__res);
}
}
__inline static void __attribute__((__always_inline__))  *__memset_generic(void *s ,
                                                                           char c ,
                                                                           size_t count ) 
{ int d0 ;
  int d1 ;

  {
  __asm__  volatile   ("rep\n\t"
                       "stosb": "=&c" (d0), "=&D" (d1): "a" (c), "1" (s), "0" (count): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
}
}
__inline static void __attribute__((__always_inline__))  *__constant_c_memset(void *s ,
                                                                              unsigned long c ,
                                                                              size_t count ) 
{ int d0 ;
  int d1 ;

  {
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count /
                                                                                4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
}
}
__inline static size_t __attribute__((__always_inline__))  strnlen(char const   *s ,
                                                                   size_t count ) 
{ int d0 ;
  register int __res ;

  {
  __asm__  volatile   ("movl %2,%0\n\t"
                       "jmp 2f\n"
                       "1:\tcmpb $0,(%0)\n\t"
                       "je 3f\n\t"
                       "incl %0\n"
                       "2:\tdecl %1\n\t"
                       "cmpl $-1,%1\n\t"
                       "jne 1b\n"
                       "3:\tsubl %2,%0": "=a" (__res), "=&d" (d0): "c" (s), "1" (count));
  return ((unsigned int )__res);
}
}
extern char *strstr(char const   *cs , char const   *ct ) ;
__inline static void __attribute__((__always_inline__))  *__constant_c_and_count_memset(void *s ,
                                                                                        unsigned long pattern ,
                                                                                        size_t count ) 
{ int d0 ;
  int d1 ;

  {
  switch ((int )count) {
  case 0: ;
  return ((void __attribute__((__always_inline__))  *)s);
  case 1: 
  (*((unsigned char *)s)) = (unsigned char )pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  case 2: 
  (*((unsigned short *)s)) = (unsigned short )pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  case 3: 
  (*((unsigned short *)s)) = (unsigned short )pattern;
  (*((unsigned char *)s + 2)) = (unsigned char )pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  case 4: 
  (*((unsigned long *)s)) = pattern;
  return ((void __attribute__((__always_inline__))  *)s);
  }
  switch ((int )(count % 4U)) {
  case 0: 
  __asm__  volatile   ("rep ; stosl"
                       "": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count / 4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  case 1: 
  __asm__  volatile   ("rep ; stosl"
                       "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count /
                                                                                4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  case 2: 
  __asm__  volatile   ("rep ; stosl"
                       "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count /
                                                                                4U),
                       "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  default: 
  __asm__  volatile   ("rep ; stosl"
                       "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (pattern),
                       "0" (count / 4U), "1" ((long )s): "memory");
  return ((void __attribute__((__always_inline__))  *)s);
  }
}
}
__inline static void __attribute__((__always_inline__))  *memscan(void *addr , int c ,
                                                                  size_t size ) 
{ 

  {
  if (! size) {
    return ((void __attribute__((__always_inline__))  *)addr);
  }
  __asm__  ("repnz; scasb\n\t"
            "jnz 1f\n\t"
            "dec %%edi\n"
            "1:": "=D" (addr), "=c" (size): "0" (addr), "1" (size), "a" (c));
  return ((void __attribute__((__always_inline__))  *)addr);
}
}
extern size_t strlcpy(char * , char const   * , size_t  ) ;
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
extern char *strnchr(char const   * , size_t  , int  ) ;
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
extern int __bitmap_empty(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_full(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          int bits ) ;
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                int bits ) ;
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
extern void __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 ,
                            unsigned long const   *bitmap2 , int bits ) ;
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               int bits ) ;
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
extern int __bitmap_weight(unsigned long const   *bitmap , int bits ) ;
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
extern int bitmap_parse(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                        int nbits ) ;
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
extern int bitmap_find_free_region(unsigned long *bitmap , int bits , int order ) ;
extern void bitmap_release_region(unsigned long *bitmap , int pos , int order ) ;
extern int bitmap_allocate_region(unsigned long *bitmap , int pos , int order ) ;
__inline static void __attribute__((__always_inline__))  bitmap_zero(unsigned long *dst ,
                                                                     int nbits ) 
{ int len ;

  {
  if (nbits <= 32) {
    (*dst) = 0UL;
  } else {
    len = (int )((unsigned int )(((nbits + 32) - 1) / 32) * sizeof(unsigned long ));
    __constant_c_memset((void *)dst, 0UL, (unsigned int )len);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_fill(unsigned long *dst ,
                                                                     int nbits ) 
{ size_t nlongs ;
  int len ;

  {
  nlongs = (size_t )(((nbits + 32) - 1) / 32);
  if (nlongs > 1U) {
    len = (int )((nlongs - 1U) * sizeof(unsigned long ));
    __constant_c_memset((void *)dst, 4294967295UL, (unsigned int )len);
  }
  if (nbits % 32) {
    (*(dst + (nlongs - 1U))) = (1UL << nbits % 32) - 1UL;
  } else {
    (*(dst + (nlongs - 1U))) = ~ 0UL;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_copy(unsigned long *dst ,
                                                                     unsigned long const   *src ,
                                                                     int nbits ) 
{ int len ;

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )(*src);
  } else {
    len = (int )((unsigned int )(((nbits + 32) - 1) / 32) * sizeof(unsigned long ));
    __memcpy((void *)dst, (void const   *)src, (unsigned int )len);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_and(unsigned long *dst ,
                                                                    unsigned long const   *src1 ,
                                                                    unsigned long const   *src2 ,
                                                                    int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) & (*src2));
  } else {
    __bitmap_and(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_or(unsigned long *dst ,
                                                                   unsigned long const   *src1 ,
                                                                   unsigned long const   *src2 ,
                                                                   int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) | (*src2));
  } else {
    __bitmap_or(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_xor(unsigned long *dst ,
                                                                    unsigned long const   *src1 ,
                                                                    unsigned long const   *src2 ,
                                                                    int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) ^ (*src2));
  } else {
    __bitmap_xor(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_andnot(unsigned long *dst ,
                                                                       unsigned long const   *src1 ,
                                                                       unsigned long const   *src2 ,
                                                                       int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src1) & ~ (*src2));
  } else {
    __bitmap_andnot(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_complement(unsigned long *dst ,
                                                                           unsigned long const   *src ,
                                                                           int nbits ) 
{ unsigned long tmp ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    (*dst) = (unsigned long )(~ (*src) & (unsigned long const   )tmp);
  } else {
    __bitmap_complement(dst, src, nbits);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  bitmap_equal(unsigned long const   *src1 ,
                                                                     unsigned long const   *src2 ,
                                                                     int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if (((*src1) ^ (*src2)) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_equal(src1, src2,
                                                                       nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_intersects(unsigned long const   *src1 ,
                                                                          unsigned long const   *src2 ,
                                                                          int nbits ) 
{ unsigned long tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    return ((int __attribute__((__always_inline__))  )((((*src1) & (*src2)) & (unsigned long const   )tmp) !=
                                                       0UL));
  } else {
    tmp___0 = (int __attribute__((__always_inline__))  )__bitmap_intersects(src1,
                                                                            src2,
                                                                            nbits);
    return (tmp___0);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_subset(unsigned long const   *src1 ,
                                                                      unsigned long const   *src2 ,
                                                                      int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if (((*src1) & ~ (*src2)) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_subset(src1, src2,
                                                                        nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_empty(unsigned long const   *src ,
                                                                     int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if ((*src) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_empty(src, nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_full(unsigned long const   *src ,
                                                                    int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    if (~ (*src) & (unsigned long const   )tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  } else {
    tmp___1 = (int __attribute__((__always_inline__))  )__bitmap_full(src, nbits);
    return (tmp___1);
  }
}
}
__inline static int __attribute__((__always_inline__))  bitmap_weight(unsigned long const   *src ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )__bitmap_weight(src, nbits);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  bitmap_shift_right(unsigned long *dst ,
                                                                            unsigned long const   *src ,
                                                                            int n ,
                                                                            int nbits ) 
{ 

  {
  if (nbits <= 32) {
    (*dst) = (unsigned long )((*src) >> n);
  } else {
    __bitmap_shift_right(dst, src, n, nbits);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  bitmap_shift_left(unsigned long *dst ,
                                                                           unsigned long const   *src ,
                                                                           int n ,
                                                                           int nbits ) 
{ unsigned long tmp ;

  {
  if (nbits <= 32) {
    if (nbits % 32) {
      tmp = (1UL << nbits % 32) - 1UL;
    } else {
      tmp = ~ 0UL;
    }
    (*dst) = (unsigned long )(((*src) << n) & (unsigned long const   )tmp);
  } else {
    __bitmap_shift_left(dst, src, n, nbits);
  }
  return;
}
}
extern cpumask_t _unused_cpumask_arg_ ;
__inline static void __attribute__((__always_inline__))  __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  set_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  clear_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_setall(cpumask_t *dstp ,
                                                                       int nbits ) 
{ 

  {
  bitmap_fill(dstp->bits, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_clear(cpumask_t *dstp ,
                                                                      int nbits ) 
{ 

  {
  bitmap_zero(dstp->bits, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __cpu_test_and_set(int cpu ,
                                                                           cpumask_t *addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(cpu, (unsigned long volatile   *)(addr->bits));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __cpus_and(cpumask_t *dstp ,
                                                                    cpumask_t const   *src1p ,
                                                                    cpumask_t const   *src2p ,
                                                                    int nbits ) 
{ 

  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_or(cpumask_t *dstp ,
                                                                   cpumask_t const   *src1p ,
                                                                   cpumask_t const   *src2p ,
                                                                   int nbits ) 
{ 

  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_xor(cpumask_t *dstp ,
                                                                    cpumask_t const   *src1p ,
                                                                    cpumask_t const   *src2p ,
                                                                    int nbits ) 
{ 

  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_andnot(cpumask_t *dstp ,
                                                                       cpumask_t const   *src1p ,
                                                                       cpumask_t const   *src2p ,
                                                                       int nbits ) 
{ 

  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_complement(cpumask_t *dstp ,
                                                                           cpumask_t const   *srcp ,
                                                                           int nbits ) 
{ 

  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __cpus_equal(cpumask_t const   *src1p ,
                                                                     cpumask_t const   *src2p ,
                                                                     int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_intersects(cpumask_t const   *src1p ,
                                                                          cpumask_t const   *src2p ,
                                                                          int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_subset(cpumask_t const   *src1p ,
                                                                      cpumask_t const   *src2p ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_empty(cpumask_t const   *srcp ,
                                                                     int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_full(cpumask_t const   *srcp ,
                                                                    int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpus_weight(cpumask_t const   *srcp ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __cpus_shift_right(cpumask_t *dstp ,
                                                                            cpumask_t const   *srcp ,
                                                                            int n ,
                                                                            int nbits ) 
{ 

  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __cpus_shift_left(cpumask_t *dstp ,
                                                                           cpumask_t const   *srcp ,
                                                                           int n ,
                                                                           int nbits ) 
{ 

  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __first_cpu(cpumask_t const   *srcp ,
                                                                    int nbits ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = nbits;
  tmp = (int )find_first_bit((unsigned long const   *)(srcp->bits), (unsigned int )nbits);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __next_cpu(int n , cpumask_t const   *srcp ,
                                                                   int nbits ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = nbits;
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), nbits, n + 1);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __cpumask_scnprintf(char *buf ,
                                                                            int len ,
                                                                            cpumask_t const   *srcp ,
                                                                            int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnprintf(buf, (unsigned int )len,
                                                                   (unsigned long const   *)(srcp->bits),
                                                                   nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpumask_parse(char const   *buf ,
                                                                        int len ,
                                                                        cpumask_t *dstp ,
                                                                        int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parse(buf, (unsigned int )len,
                                                               dstp->bits, nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpulist_scnprintf(char *buf ,
                                                                            int len ,
                                                                            cpumask_t const   *srcp ,
                                                                            int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnlistprintf(buf, (unsigned int )len,
                                                                       (unsigned long const   *)(srcp->bits),
                                                                       nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __cpulist_parse(char const   *buf ,
                                                                        cpumask_t *dstp ,
                                                                        int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parselist(buf, dstp->bits,
                                                                   nbits);
  return (tmp);
}
}
extern cpumask_t cpu_possible_map ;
extern cpumask_t cpu_online_map ;
extern cpumask_t cpu_present_map ;
extern nodemask_t _unused_nodemask_arg_ ;
__inline static void __attribute__((__always_inline__))  __node_set(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  set_bit(node, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  clear_bit(node, (unsigned long volatile   *)(dstp->bits));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_setall(nodemask_t *dstp ,
                                                                        int nbits ) 
{ 

  {
  bitmap_fill(dstp->bits, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_clear(nodemask_t *dstp ,
                                                                       int nbits ) 
{ 

  {
  bitmap_zero(dstp->bits, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __node_test_and_set(int node ,
                                                                            nodemask_t *addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(node, (unsigned long volatile   *)(addr->bits));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __nodes_and(nodemask_t *dstp ,
                                                                     nodemask_t const   *src1p ,
                                                                     nodemask_t const   *src2p ,
                                                                     int nbits ) 
{ 

  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_or(nodemask_t *dstp ,
                                                                    nodemask_t const   *src1p ,
                                                                    nodemask_t const   *src2p ,
                                                                    int nbits ) 
{ 

  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_xor(nodemask_t *dstp ,
                                                                     nodemask_t const   *src1p ,
                                                                     nodemask_t const   *src2p ,
                                                                     int nbits ) 
{ 

  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_andnot(nodemask_t *dstp ,
                                                                        nodemask_t const   *src1p ,
                                                                        nodemask_t const   *src2p ,
                                                                        int nbits ) 
{ 

  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_complement(nodemask_t *dstp ,
                                                                            nodemask_t const   *srcp ,
                                                                            int nbits ) 
{ 

  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __nodes_equal(nodemask_t const   *src1p ,
                                                                      nodemask_t const   *src2p ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_intersects(nodemask_t const   *src1p ,
                                                                           nodemask_t const   *src2p ,
                                                                           int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_subset(nodemask_t const   *src1p ,
                                                                       nodemask_t const   *src2p ,
                                                                       int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_empty(nodemask_t const   *srcp ,
                                                                      int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_full(nodemask_t const   *srcp ,
                                                                     int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodes_weight(nodemask_t const   *srcp ,
                                                                       int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __nodes_shift_right(nodemask_t *dstp ,
                                                                             nodemask_t const   *srcp ,
                                                                             int n ,
                                                                             int nbits ) 
{ 

  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __nodes_shift_left(nodemask_t *dstp ,
                                                                            nodemask_t const   *srcp ,
                                                                            int n ,
                                                                            int nbits ) 
{ 

  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  return;
}
}
__inline static int __attribute__((__always_inline__))  __first_node(nodemask_t const   *srcp ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = 1;
  tmp = (int )find_first_bit((unsigned long const   *)(srcp->bits), 1U);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __next_node(int n , nodemask_t const   *srcp ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = 1;
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 1, n + 1);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __first_unset_node(nodemask_t const   *maskp ) 
{ int __x ;
  int __y ;
  int tmp ;
  int tmp___0 ;

  {
  __x = 1;
  tmp = (int )find_first_zero_bit((unsigned long const   *)(maskp->bits), 1U);
  __y = tmp;
  if (__x < __y) {
    tmp___0 = __x;
  } else {
    tmp___0 = __y;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  __nodemask_scnprintf(char *buf ,
                                                                             int len ,
                                                                             nodemask_t const   *srcp ,
                                                                             int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnprintf(buf, (unsigned int )len,
                                                                   (unsigned long const   *)(srcp->bits),
                                                                   nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodemask_parse(char const   *buf ,
                                                                         int len ,
                                                                         nodemask_t *dstp ,
                                                                         int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parse(buf, (unsigned int )len,
                                                               dstp->bits, nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodelist_scnprintf(char *buf ,
                                                                             int len ,
                                                                             nodemask_t const   *srcp ,
                                                                             int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_scnlistprintf(buf, (unsigned int )len,
                                                                       (unsigned long const   *)(srcp->bits),
                                                                       nbits);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  __nodelist_parse(char const   *buf ,
                                                                         nodemask_t *dstp ,
                                                                         int nbits ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )bitmap_parselist(buf, dstp->bits,
                                                                   nbits);
  return (tmp);
}
}
extern nodemask_t node_online_map ;
extern nodemask_t node_possible_map ;
__inline static void __attribute__((__always_inline__))  prefetch_range(void *addr ,
                                                                        size_t len ) 
{ char *cp ;
  char *end ;

  {
  end = (char *)(addr + len);
  cp = (char *)addr;
  while ((unsigned int )cp < (unsigned int )end) {
    prefetch__extinline((void const   *)cp);
    cp += 128;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  __list_add(struct list_head *new ,
                                                                    struct list_head *prev ,
                                                                    struct list_head *next ) 
{ 

  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_add(struct list_head *new ,
                                                                  struct list_head *head ) 
{ 

  {
  __list_add(new, head, head->next);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_add_tail(struct list_head *new ,
                                                                       struct list_head *head ) 
{ 

  {
  __list_add(new, head->prev, head);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __list_add_rcu(struct list_head *new ,
                                                                        struct list_head *prev ,
                                                                        struct list_head *next ) 
{ 

  {
  new->next = next;
  new->prev = prev;
  __asm__  volatile   ("": : : "memory");
  next->prev = new;
  prev->next = new;
}
}
__inline static void __attribute__((__always_inline__))  list_add_rcu(struct list_head *new ,
                                                                      struct list_head *head ) 
{ 

  {
  __list_add_rcu(new, head, head->next);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_add_tail_rcu(struct list_head *new ,
                                                                           struct list_head *head ) 
{ 

  {
  __list_add_rcu(new, head->prev, head);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __list_del(struct list_head *prev ,
                                                                    struct list_head *next ) 
{ 

  {
  next->prev = prev;
  prev->next = next;
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_del(struct list_head *entry ) 
{ 

  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_del_rcu(struct list_head *entry ) 
{ 

  {
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_head *)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_replace_rcu(struct list_head *old ,
                                                                          struct list_head *new ) 
{ 

  {
  new->next = old->next;
  new->prev = old->prev;
  __asm__  volatile   ("": : : "memory");
  (new->next)->prev = new;
  (new->prev)->next = new;
}
}
__inline static void __attribute__((__always_inline__))  list_del_init(struct list_head *entry ) 
{ 

  {
  __list_del(entry->prev, entry->next);
  while (1) {
    entry->next = entry;
    entry->prev = entry;
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_move(struct list_head *list ,
                                                                   struct list_head *head ) 
{ 

  {
  __list_del(list->prev, list->next);
  list_add(list, head);
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_move_tail(struct list_head *list ,
                                                                        struct list_head *head ) 
{ 

  {
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
  return;
}
}
__inline static int __attribute__((__always_inline__))  list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )head->next ==
                                                     (unsigned int )head));
}
}
__inline static int __attribute__((__always_inline__))  list_empty_careful(struct list_head  const  *head ) 
{ struct list_head *next ;
  int tmp ;

  {
  next = (struct list_head *)head->next;
  if ((unsigned int )next == (unsigned int )head) {
    if ((unsigned int )next == (unsigned int )head->prev) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static void __attribute__((__always_inline__))  __list_splice(struct list_head *list ,
                                                                       struct list_head *head ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;

  {
  first = list->next;
  last = list->prev;
  at = head->next;
  first->prev = head;
  head->next = first;
  last->next = at;
  at->prev = last;
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_splice(struct list_head *list ,
                                                                     struct list_head *head ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = list_empty((struct list_head  const  *)list);
  if (! tmp) {
    __list_splice(list, head);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  list_splice_init(struct list_head *list ,
                                                                          struct list_head *head ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = list_empty((struct list_head  const  *)list);
  if (! tmp) {
    __list_splice(list, head);
    while (1) {
      list->next = list;
      list->prev = list;
      break;
    }
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  hlist_unhashed(struct hlist_node  const  *h ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! h->pprev != 0));
}
}
__inline static int __attribute__((__always_inline__))  hlist_empty(struct hlist_head  const  *h ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! h->first != 0));
}
}
__inline static void __attribute__((__always_inline__))  __hlist_del(struct hlist_node *n ) 
{ struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  next = n->next;
  pprev = n->pprev;
  (*pprev) = next;
  if (next) {
    next->pprev = pprev;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_del(struct hlist_node *n ) 
{ 

  {
  __hlist_del(n);
  n->next = (struct hlist_node *)((void *)1048832);
  n->pprev = (struct hlist_node **)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_del_rcu(struct hlist_node *n ) 
{ 

  {
  __hlist_del(n);
  n->pprev = (struct hlist_node **)((void *)2097664);
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_del_init(struct hlist_node *n ) 
{ 

  {
  if (n->pprev) {
    __hlist_del(n);
    n->next = (struct hlist_node *)((void *)0);
    n->pprev = (struct hlist_node **)((void *)0);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_head(struct hlist_node *n ,
                                                                        struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  first = h->first;
  n->next = first;
  if (first) {
    first->pprev = & n->next;
  }
  h->first = n;
  n->pprev = & h->first;
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_head_rcu(struct hlist_node *n ,
                                                                            struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  first = h->first;
  n->next = first;
  n->pprev = & h->first;
  __asm__  volatile   ("": : : "memory");
  if (first) {
    first->pprev = & n->next;
  }
  h->first = n;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_before(struct hlist_node *n ,
                                                                          struct hlist_node *next ) 
{ 

  {
  n->pprev = next->pprev;
  n->next = next;
  next->pprev = & n->next;
  (*(n->pprev)) = n;
  return;
}
}
__inline static void __attribute__((__always_inline__))  hlist_add_after(struct hlist_node *n ,
                                                                         struct hlist_node *next ) 
{ 

  {
  next->next = n->next;
  n->next = next;
  next->pprev = & n->next;
  if (next->next) {
    (next->next)->pprev = & next->next;
  }
  return;
}
}
__inline static struct task_struct  __attribute__((__always_inline__)) *get_current(void) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = current_thread_info();
  return ((struct task_struct  __attribute__((__always_inline__)) *)tmp->task);
}
}
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
__inline static void __attribute__((__always_inline__))  init_waitqueue_head(wait_queue_head_t *q ) 
{ spinlock_t __constr_expr_0 ;

  {
  while (1) {
    spin_lock_init(&__constr_expr_0);
    q->lock = __constr_expr_0;
    break;
  }
  while (1) {
    q->task_list.next = & q->task_list;
    q->task_list.prev = & q->task_list;
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_waitqueue_entry(wait_queue_t *q ,
                                                                              struct task_struct *p ) 
{ 

  {
  q->flags = 0U;
  q->task = p;
  q->func = & default_wake_function;
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_waitqueue_func_entry(wait_queue_t *q ,
                                                                                   int (*func)(wait_queue_t *wait ,
                                                                                               unsigned int mode ,
                                                                                               int sync ,
                                                                                               void *key ) ) 
{ 

  {
  q->flags = 0U;
  q->task = (struct task_struct *)((void *)0);
  q->func = func;
  return;
}
}
__inline static int __attribute__((__always_inline__))  waitqueue_active(wait_queue_head_t *q ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
extern void ( __attribute__((__regparm__(3))) add_wait_queue)(wait_queue_head_t *q ,
                                                              wait_queue_t *wait ) ;
extern void ( __attribute__((__regparm__(3))) add_wait_queue_exclusive)(wait_queue_head_t *q ,
                                                                        wait_queue_t *wait ) ;
extern void ( __attribute__((__regparm__(3))) remove_wait_queue)(wait_queue_head_t *q ,
                                                                 wait_queue_t *wait ) ;
__inline static void __attribute__((__always_inline__))  __add_wait_queue(wait_queue_head_t *head ,
                                                                          wait_queue_t *new ) 
{ 

  {
  list_add(& new->task_list, & head->task_list);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __add_wait_queue_tail(wait_queue_head_t *head ,
                                                                               wait_queue_t *new ) 
{ 

  {
  list_add_tail(& new->task_list, & head->task_list);
  return;
}
}
__inline static void __attribute__((__always_inline__))  __remove_wait_queue(wait_queue_head_t *head ,
                                                                             wait_queue_t *old ) 
{ 

  {
  list_del(& old->task_list);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __wake_up)(wait_queue_head_t *q , unsigned int mode ,
                                                         int nr , void *key ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up_locked)(wait_queue_head_t *q ,
                                                                unsigned int mode ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up_sync)(wait_queue_head_t *q ,
                                                              unsigned int mode ,
                                                              int nr ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up_bit)(wait_queue_head_t * ,
                                                             void * , int  ) ;
extern int ( __attribute__((__regparm__(3))) __wait_on_bit)(wait_queue_head_t * ,
                                                            struct wait_bit_queue * ,
                                                            int (*)(void * ) , unsigned int  ) ;
extern int ( __attribute__((__regparm__(3))) __wait_on_bit_lock)(wait_queue_head_t * ,
                                                                 struct wait_bit_queue * ,
                                                                 int (*)(void * ) ,
                                                                 unsigned int  ) ;
extern void ( __attribute__((__regparm__(3))) wake_up_bit)(void * , int  ) ;
extern int ( __attribute__((__regparm__(3))) out_of_line_wait_on_bit)(void * , int  ,
                                                                      int (*)(void * ) ,
                                                                      unsigned int  ) ;
extern int ( __attribute__((__regparm__(3))) out_of_line_wait_on_bit_lock)(void * ,
                                                                           int  ,
                                                                           int (*)(void * ) ,
                                                                           unsigned int  ) ;
extern wait_queue_head_t *( __attribute__((__regparm__(3))) bit_waitqueue)(void * ,
                                                                           int  ) ;
__inline static void __attribute__((__always_inline__))  add_wait_queue_exclusive_locked(wait_queue_head_t *q ,
                                                                                         wait_queue_t *wait ) 
{ 

  {
  wait->flags |= 1U;
  __add_wait_queue_tail(q, wait);
  return;
}
}
__inline static void __attribute__((__always_inline__))  remove_wait_queue_locked(wait_queue_head_t *q ,
                                                                                  wait_queue_t *wait ) 
{ 

  {
  __remove_wait_queue(q, wait);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) sleep_on)(wait_queue_head_t *q ) ;
extern long ( __attribute__((__regparm__(3))) sleep_on_timeout)(wait_queue_head_t *q ,
                                                                long timeout ) ;
extern void ( __attribute__((__regparm__(3))) interruptible_sleep_on)(wait_queue_head_t *q ) ;
extern long ( __attribute__((__regparm__(3))) interruptible_sleep_on_timeout)(wait_queue_head_t *q ,
                                                                              long timeout ) ;
extern void ( __attribute__((__regparm__(3))) prepare_to_wait)(wait_queue_head_t *q ,
                                                               wait_queue_t *wait ,
                                                               int state ) ;
extern void ( __attribute__((__regparm__(3))) prepare_to_wait_exclusive)(wait_queue_head_t *q ,
                                                                         wait_queue_t *wait ,
                                                                         int state ) ;
extern void ( __attribute__((__regparm__(3))) finish_wait)(wait_queue_head_t *q ,
                                                           wait_queue_t *wait ) ;
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
__inline static int __attribute__((__always_inline__))  wait_on_bit(void *word , int bit ,
                                                                    int (*action)(void * ) ,
                                                                    unsigned int mode ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)word);
  if (! tmp___0) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___1 = (int __attribute__((__always_inline__))  )out_of_line_wait_on_bit(word,
                                                                              bit,
                                                                              action,
                                                                              mode);
  return (tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  wait_on_bit_lock(void *word ,
                                                                         int bit ,
                                                                         int (*action)(void * ) ,
                                                                         unsigned int mode ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_set_bit(bit, (unsigned long volatile   *)word);
  if (! tmp) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___0 = (int __attribute__((__always_inline__))  )out_of_line_wait_on_bit_lock(word,
                                                                                   bit,
                                                                                   action,
                                                                                   mode);
  return (tmp___0);
}
}
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_read_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_write_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_wake)(struct rw_semaphore * ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_downgrade_wake)(struct rw_semaphore *sem ) ;
__inline static void __attribute__((__always_inline__))  init_rwsem(struct rw_semaphore *sem ) 
{ spinlock_t __constr_expr_0 ;

  {
  sem->count = 0L;
  while (1) {
    spin_lock_init(&__constr_expr_0);
    sem->wait_lock = __constr_expr_0;
    break;
  }
  while (1) {
    sem->wait_list.next = & sem->wait_list;
    sem->wait_list.prev = & sem->wait_list;
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  __down_read(struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# beginning down_read\n\t"
                       "lock ; "
                       "  incl      (%%eax)\n\t"
                       "  js        2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  pushl     %%ecx\n\t"
                       "  pushl     %%edx\n\t"
                       "  call      rwsem_down_read_failed\n\t"
                       "  popl      %%edx\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending down_read\n\t": "=m" (sem->count): "a" (sem), "m" (sem->count): "memory",
                       "cc");
}
}
__inline static int __attribute__((__always_inline__))  __down_read_trylock(struct rw_semaphore *sem ) 
{ __s32 result ;
  __s32 tmp ;
  int tmp___0 ;

  {
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  movl      %0,%1\n\t"
                       "1:\n\t"
                       "  movl\t     %1,%2\n\t"
                       "  addl      %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       "lock ; "
                       "  cmpxchgl  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1): "memory", "cc");
  if (result >= 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  __down_write(struct rw_semaphore *sem ) 
{ int tmp ;

  {
  tmp = -65535;
  __asm__  volatile   ("# beginning down_write\n\t"
                       "lock ; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  testl     %%edx,%%edx\n\t"
                       "  jnz       2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  pushl     %%ecx\n\t"
                       "  call      rwsem_down_write_failed\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending down_write": "=m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp), "m" (sem->count): "memory", "cc");
}
}
__inline static int __attribute__((__always_inline__))  __down_write_trylock(struct rw_semaphore *sem ) 
{ long ret ;
  long tmp ;

  {
  tmp = (long )__cmpxchg((void volatile   *)(& sem->count), 0UL, 4294901761UL, (int )sizeof(sem->count));
  ret = tmp;
  if (ret == 0L) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  __up_read(struct rw_semaphore *sem ) 
{ __s32 tmp ;

  {
  tmp = -1;
  __asm__  volatile   ("# beginning __up_read\n\t"
                       "lock ; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  js        2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  decw      %%dx\n\t"
                       "  jnz       1b\n\t"
                       "  pushl     %%ecx\n\t"
                       "  call      rwsem_wake\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending __up_read\n": "=m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp), "m" (sem->count): "memory", "cc");
}
}
__inline static void __attribute__((__always_inline__))  __up_write(struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# beginning __up_write\n\t"
                       "  movl      %2,%%edx\n\t"
                       "lock ; "
                       "  xaddl     %%edx,(%%eax)\n\t"
                       "  jnz       2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  decw      %%dx\n\t"
                       "  jnz       1b\n\t"
                       "  pushl     %%ecx\n\t"
                       "  call      rwsem_wake\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending __up_write\n": "=m" (sem->count): "a" (sem), "i" (65535),
                       "m" (sem->count): "memory", "cc", "edx");
}
}
__inline static void __attribute__((__always_inline__))  __downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       "lock ; "
                       "  addl      %2,(%%eax)\n\t"
                       "  js        2f\n\t"
                       "1:\n\t"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\n\t"
                       "  pushl     %%ecx\n\t"
                       "  pushl     %%edx\n\t"
                       "  call      rwsem_downgrade_wake\n\t"
                       "  popl      %%edx\n\t"
                       "  popl      %%ecx\n\t"
                       "  jmp       1b\n"
                       ".previous\n\t"
                       "# ending __downgrade_write\n": "=m" (sem->count): "a" (sem),
                       "i" (65536), "m" (sem->count): "memory", "cc");
}
}
__inline static void __attribute__((__always_inline__))  rwsem_atomic_add(int delta ,
                                                                          struct rw_semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("lock ; "
                       "addl %1,%0": "=m" (sem->count): "ir" (delta), "m" (sem->count));
}
}
__inline static int __attribute__((__always_inline__))  rwsem_atomic_update(int delta ,
                                                                            struct rw_semaphore *sem ) 
{ int tmp ;

  {
  tmp = delta;
  __asm__  volatile   ("lock ; "
                       "xadd %0,(%2)": "+r" (tmp), "=m" (sem->count): "r" (sem), "m" (sem->count): "memory");
  return ((int __attribute__((__always_inline__))  )(tmp + delta));
}
}
__inline static void __attribute__((__always_inline__))  down_read(struct rw_semaphore *sem ) 
{ 

  {
  while (1) {
    break;
  }
  __down_read(sem);
  return;
}
}
__inline static int __attribute__((__always_inline__))  down_read_trylock(struct rw_semaphore *sem ) 
{ int ret ;

  {
  ret = (int )__down_read_trylock(sem);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static void __attribute__((__always_inline__))  down_write(struct rw_semaphore *sem ) 
{ 

  {
  while (1) {
    break;
  }
  __down_write(sem);
  return;
}
}
__inline static int __attribute__((__always_inline__))  down_write_trylock(struct rw_semaphore *sem ) 
{ int ret ;

  {
  ret = (int )__down_write_trylock(sem);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static void __attribute__((__always_inline__))  up_read(struct rw_semaphore *sem ) 
{ 

  {
  __up_read(sem);
  return;
}
}
__inline static void __attribute__((__always_inline__))  up_write(struct rw_semaphore *sem ) 
{ 

  {
  __up_write(sem);
  return;
}
}
__inline static void __attribute__((__always_inline__))  downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  __downgrade_write(sem);
  return;
}
}
__inline static void __attribute__((__always_inline__))  sema_init(struct semaphore *sem ,
                                                                   int val ) 
{ 

  {
  sem->count.counter = (int volatile   )val;
  sem->sleepers = 0;
  init_waitqueue_head(& sem->wait);
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_MUTEX(struct semaphore *sem ) 
{ 

  {
  sema_init(sem, 1);
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 

  {
  sema_init(sem, 0);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __down_failed)(void) ;
extern int ( __attribute__((__regparm__(3))) __down_failed_interruptible)(void) ;
extern int ( __attribute__((__regparm__(3))) __down_failed_trylock)(void) ;
extern void ( __attribute__((__regparm__(3))) __up_wakeup)(void) ;
__inline static void __attribute__((__always_inline__))  down(struct semaphore *sem ) 
{ 

  {
  while (1) {
    break;
  }
  __asm__  volatile   ("# atomic down operation\n\t"
                       "lock ; "
                       "decl %0\n\t"
                       "js 2f\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %0,%%eax\n\t"
                       "call __down_failed\n\t"
                       "jmp 1b\n"
                       ".previous\n\t": "=m" (sem->count): : "memory", "ax");
}
}
__inline static int __attribute__((__always_inline__))  down_interruptible(struct semaphore *sem ) 
{ int result ;

  {
  while (1) {
    break;
  }
  __asm__  volatile   ("# atomic interruptible down operation\n\t"
                       "lock ; "
                       "decl %1\n\t"
                       "js 2f\n\t"
                       "xorl %0,%0\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %1,%%eax\n\t"
                       "call __down_failed_interruptible\n\t"
                       "jmp 1b\n"
                       ".previous\n\t": "=a" (result), "=m" (sem->count): : "memory");
  return ((int __attribute__((__always_inline__))  )result);
}
}
__inline static int __attribute__((__always_inline__))  down_trylock(struct semaphore *sem ) 
{ int result ;

  {
  __asm__  volatile   ("# atomic interruptible down operation\n\t"
                       "lock ; "
                       "decl %1\n\t"
                       "js 2f\n\t"
                       "xorl %0,%0\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %1,%%eax\n\t"
                       "call __down_failed_trylock\n\t"
                       "jmp 1b\n"
                       ".previous\n\t": "=a" (result), "=m" (sem->count): : "memory");
  return ((int __attribute__((__always_inline__))  )result);
}
}
__inline static void __attribute__((__always_inline__))  up(struct semaphore *sem ) 
{ 

  {
  __asm__  volatile   ("# atomic up operation\n\t"
                       "lock ; "
                       "incl %0\n\t"
                       "jle 2f\n"
                       "1:\n"
                       ".subsection 1\n\t"
                       ""
                       ".ifndef "
                       ".text.lock."
                       "synclink"
                       "\n\t"
                       ".text.lock."
                       "synclink"
                       ":\n\t"
                       ".endif\n"
                       "2:\tlea %0,%%eax\n\t"
                       "call __up_wakeup\n\t"
                       "jmp 1b\n"
                       ".previous\n\t"
                       ".subsection 0\n": "=m" (sem->count): : "memory", "ax");
}
}
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ) ;
extern void cpu_idle(void) ;
__inline static int __attribute__((__always_inline__))  __acpi_acquire_global_lock(unsigned int *lock ) 
{ unsigned int old ;
  unsigned int new ;
  unsigned int val ;
  unsigned long __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    old = (*lock);
    new = ((old & 4294967292U) + 2U) + ((old >> 1) & 1U);
    val = (unsigned int )__cmpxchg((void volatile   *)lock, (unsigned long )old, (unsigned long )new,
                                   (int )sizeof((*lock)));
    tmp___0 = __builtin_expect((long )(! (! (val != old)) != 0), 0L);
    if (! tmp___0) {
      break;
    }
  }
  if (new < 3U) {
    tmp___1 = -1;
  } else {
    tmp___1 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  __acpi_release_global_lock(unsigned int *lock ) 
{ unsigned int old ;
  unsigned int new ;
  unsigned int val ;
  unsigned long __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;

  {
  while (1) {
    old = (*lock);
    new = old & 4294967292U;
    val = (unsigned int )__cmpxchg((void volatile   *)lock, (unsigned long )old, (unsigned long )new,
                                   (int )sizeof((*lock)));
    tmp___0 = __builtin_expect((long )(! (! (val != old)) != 0), 0L);
    if (! tmp___0) {
      break;
    }
  }
  return ((int __attribute__((__always_inline__))  )(old & 1U));
}
}
__inline static int __attribute__((__always_inline__))  acpi_irq_balance_set(char *str ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern u8 x86_acpiid_to_apicid[] ;
extern void __set_fixmap(enum fixed_addresses idx , unsigned long phys , pgprot_t flags ) ;
extern void __this_fixmap_does_not_exist(void) ;
__inline static unsigned long __attribute__((__always_inline__))  fix_to_virt(unsigned int idx ) 
{ 

  {
  if (idx >= 245U) {
    __this_fixmap_does_not_exist();
  }
  return ((unsigned long __attribute__((__always_inline__))  )(4294963200UL - (unsigned long )(idx <<
                                                                                               12)));
}
}
__inline static unsigned long __attribute__((__always_inline__))  virt_to_fix(unsigned long vaddr ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  while (1) {
    if (vaddr >= 4294963200UL) {
      tmp = 1;
    } else {
      if (vaddr < 4294029312UL) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    }
    if (tmp != 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    if (tmp___1) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (153), "i" ("include/asm/fixmap.h"));
    }
    break;
  }
  return ((unsigned long __attribute__((__always_inline__))  )((4294963200UL - (vaddr &
                                                                                4294963200UL)) >>
                                                               12));
}
}
extern int mp_bus_id_to_type[260] ;
extern int mp_bus_id_to_node[260] ;
extern int mp_bus_id_to_local[260] ;
extern int quad_local_to_mp_bus_id[2][4] ;
extern int mp_bus_id_to_pci_bus[260] ;
extern unsigned int boot_cpu_physical_apicid ;
extern int smp_found_config ;
extern void find_smp_config(void) ;
extern void get_smp_config(void) ;
extern int nr_ioapics ;
extern int apic_version[256] ;
extern int mp_irq_entries ;
extern struct mpc_config_intsrc mp_irqs[256] ;
extern int mpc_default_type ;
extern unsigned long mp_lapic_addr ;
extern int pic_mode ;
extern int using_apic_timer ;
extern physid_mask_t phys_cpu_present_map ;
__inline static int __attribute__((__always_inline__))  use_pci_vector(void) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  disable_edge_ioapic_irq(unsigned int irq___0 ) 
{ 

  {
  return;
}
}
extern int nr_ioapic_registers[8] ;
extern struct mpc_config_ioapic mp_ioapics[8] ;
__inline static unsigned int __attribute__((__always_inline__))  io_apic_read(unsigned int apic ,
                                                                              unsigned int reg ) 
{ 

  {
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)))) = (int volatile   )reg;
  return ((unsigned int __attribute__((__always_inline__))  )(*((int volatile   *)((4294963200UL -
                                                                                    (unsigned long )((3U +
                                                                                                      apic) <<
                                                                                                     12)) +
                                                                                   (mp_ioapics[apic].mpc_apicaddr &
                                                                                    4095UL)) +
                                                                4)));
}
}
__inline static void __attribute__((__always_inline__))  io_apic_write(unsigned int apic ,
                                                                       unsigned int reg ,
                                                                       unsigned int value ) 
{ 

  {
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)))) = (int volatile   )reg;
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)) +
     4)) = (int volatile   )value;
  return;
}
}
extern int sis_apic_bug ;
__inline static void __attribute__((__always_inline__))  io_apic_modify(unsigned int apic ,
                                                                        unsigned int reg ,
                                                                        unsigned int value ) 
{ 

  {
  if (sis_apic_bug) {
    (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                  4095UL)))) = (int volatile   )reg;
  }
  (*((int volatile   *)((4294963200UL - (unsigned long )((3U + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr &
                                                                                4095UL)) +
     4)) = (int volatile   )value;
  return;
}
}
extern int skip_ioapic_setup ;
extern int (*ioapic_renumber_irq)(int ioapic , int irq ) ;
extern int assign_irq_vector(int irq ) ;
extern int pm_active ;
extern struct pm_dev  __attribute__((__deprecated__)) *pm_register(pm_dev_t type ,
                                                                   unsigned long id ,
                                                                   int (*callback)(struct pm_dev *dev ,
                                                                                   pm_request_t rqst ,
                                                                                   void *data ) ) ;
extern void __attribute__((__deprecated__))  pm_unregister(struct pm_dev *dev ) ;
extern void __attribute__((__deprecated__))  pm_unregister_all(int (*callback)(struct pm_dev *dev ,
                                                                               pm_request_t rqst ,
                                                                               void *data ) ) ;
extern int __attribute__((__deprecated__))  pm_send_all(pm_request_t rqst , void *data ) ;
extern void (*pm_idle)(void) ;
extern void (*pm_power_off)(void) ;
extern void pm_set_ops(struct pm_ops * ) ;
extern int pm_suspend(suspend_state_t state ) ;
extern void device_pm_set_parent(struct device *dev , struct device *parent ) ;
extern int device_suspend(pm_message_t state ) ;
extern int device_power_down(pm_message_t state ) ;
extern void device_power_up(void) ;
extern void device_resume(void) ;
extern int apic_verbosity ;
__inline static void __attribute__((__always_inline__))  apic_write(unsigned long reg ,
                                                                    unsigned long v ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = fix_to_virt(2U);
  (*((unsigned long volatile   *)(tmp + (unsigned long __attribute__((__always_inline__))  )reg))) = (unsigned long volatile   )v;
  return;
}
}
__inline static void __attribute__((__always_inline__))  apic_write_atomic(unsigned long reg ,
                                                                           unsigned long v ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;
  unsigned long __attribute__((__always_inline__))  tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;
  unsigned long __attribute__((__always_inline__))  tmp___2 ;

  {
  tmp___2 = fix_to_virt(2U);
  __xchg(v, (void volatile   *)((unsigned long volatile   *)(tmp___2 + (unsigned long __attribute__((__always_inline__))  )reg)),
         (int )sizeof((*((unsigned long volatile   *)(tmp___1 + (unsigned long __attribute__((__always_inline__))  )reg)))));
  return;
}
}
__inline static unsigned long __attribute__((__always_inline__))  apic_read(unsigned long reg ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = fix_to_virt(2U);
  return ((unsigned long __attribute__((__always_inline__))  )(*((unsigned long volatile   *)(tmp +
                                                                                              (unsigned long __attribute__((__always_inline__))  )reg))));
}
}
__inline static void __attribute__((__always_inline__))  apic_wait_icr_idle(void) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    tmp = apic_read(768UL);
    if (! (tmp & 4096UL)) {
      break;
    }
    rep_nop();
  }
  return;
}
}
extern int get_physical_broadcast(void) ;
__inline static void __attribute__((__always_inline__))  ack_APIC_irq(void) 
{ 

  {
  apic_write(176UL, 0UL);
  return;
}
}
extern void (*wait_timer_tick)(void) ;
extern int get_maxlvt(void) ;
extern void clear_local_APIC(void) ;
extern void connect_bsp_APIC(void) ;
extern void disconnect_bsp_APIC(void) ;
extern void disable_local_APIC(void) ;
extern void lapic_shutdown(void) ;
extern int verify_local_APIC(void) ;
extern void cache_APIC_registers(void) ;
extern void sync_Arb_IDs(void) ;
extern void init_bsp_APIC(void) ;
extern void setup_local_APIC(void) ;
extern void init_apic_mappings(void) ;
extern void smp_local_timer_interrupt(struct pt_regs *regs ) ;
extern void setup_boot_APIC_clock(void) ;
extern void setup_secondary_APIC_clock(void) ;
extern void setup_apic_nmi_watchdog(void) ;
extern int reserve_lapic_nmi(void) ;
extern void release_lapic_nmi(void) ;
extern void disable_timer_nmi_watchdog(void) ;
extern void enable_timer_nmi_watchdog(void) ;
extern void nmi_watchdog_tick(struct pt_regs *regs ) ;
extern int APIC_init_uniprocessor(void) ;
extern void disable_APIC_timer(void) ;
extern void enable_APIC_timer(void) ;
extern void enable_NMI_through_LVT0(void *dummy ) ;
extern unsigned int nmi_watchdog ;
extern void smp_alloc_memory(void) ;
extern int smp_num_siblings ;
extern cpumask_t cpu_sibling_map[] ;
extern cpumask_t cpu_core_map[] ;
extern void smp_flush_tlb(void) ;
extern void smp_message_irq(int cpl , void *dev_id , struct pt_regs *regs ) ;
extern void smp_invalidate_rcv(void) ;
extern void (*mtrr_hook)(void) ;
extern void zap_low_mappings(void) ;
extern u8 x86_cpu_to_apicid[] ;
extern cpumask_t cpu_callout_map ;
extern cpumask_t cpu_callin_map ;
__inline static int __attribute__((__always_inline__))  num_booting_cpus(void) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = __cpus_weight((cpumask_t const   *)(& cpu_callout_map), 8);
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  get_apic_id(unsigned long x ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )((x >> 24) & 255UL));
}
}
__inline static int __attribute__((__always_inline__))  hard_smp_processor_id(void) 
{ unsigned long __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = fix_to_virt(2U);
  tmp___0 = (int __attribute__((__always_inline__))  )get_apic_id((*((unsigned long *)(tmp +
                                                                                       32UL))));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  logical_smp_processor_id(void) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = fix_to_virt(2U);
  return ((int __attribute__((__always_inline__))  )(((*((unsigned long *)(tmp + 208UL))) >>
                                                      24) & 255UL));
}
}
extern void smp_send_stop(void) ;
extern void smp_send_reschedule(int cpu ) ;
extern void smp_prepare_cpus(unsigned int max_cpus ) ;
extern int __cpu_up(unsigned int cpunum ) ;
extern void smp_cpus_done(unsigned int max_cpus ) ;
extern int smp_call_function(void (*func)(void *info ) , void *info , int retry ,
                             int wait ) ;
__inline static int __attribute__((__always_inline__))  on_each_cpu(void (*func)(void *info ) ,
                                                                    void *info , int retry ,
                                                                    int wait ) 
{ int ret ;

  {
  ret = 0;
  while (1) {
    break;
  }
  ret = smp_call_function(func, info, retry, wait);
  ((*func))(info);
  while (1) {
    break;
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
extern void smp_prepare_boot_cpu(void) ;
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
extern void exit_sem(struct task_struct *tsk ) ;
__inline static void __attribute__((__always_inline__))  sigaddset(sigset_t *set ,
                                                                   int _sig ) 
{ 

  {
  __asm__  ("btsl %1,%0": "=m" ((*set)): "Ir" (_sig - 1): "cc");
}
}
__inline static void __attribute__((__always_inline__))  sigdelset(sigset_t *set ,
                                                                   int _sig ) 
{ 

  {
  __asm__  ("btrl %1,%0": "=m" ((*set)): "Ir" (_sig - 1): "cc");
}
}
__inline static int __attribute__((__always_inline__))  __const_sigismember(sigset_t *set ,
                                                                            int _sig ) 
{ unsigned long sig ;

  {
  sig = (unsigned long )(_sig - 1);
  return ((int __attribute__((__always_inline__))  )(1UL & (set->sig[sig / 32UL] >>
                                                            sig % 32UL)));
}
}
__inline static int __attribute__((__always_inline__))  __gen_sigismember(sigset_t *set ,
                                                                          int _sig ) 
{ int ret ;

  {
  __asm__  ("btl %2,%1\n\tsbbl %0,%0": "=r" (ret): "m" ((*set)), "Ir" (_sig - 1): "cc");
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static int __attribute__((__always_inline__))  sigfindinword(unsigned long word ) 
{ 

  {
  __asm__  ("bsfl %1,%0": "=r" (word): "rm" (word): "cc");
  return ((int __attribute__((__always_inline__))  )word);
}
}
extern int ( __attribute__((__regparm__(3))) do_signal)(struct pt_regs *regs , sigset_t *oldset ) ;
extern void do_schedule_next_timer(struct siginfo *info ) ;
__inline static void __attribute__((__always_inline__))  copy_siginfo(struct siginfo *to ,
                                                                      struct siginfo *from ) 
{ 

  {
  if (from->si_code < 0) {
    __constant_memcpy((void *)to, (void const   *)from, sizeof((*to)));
  } else {
    __constant_memcpy((void *)to, (void const   *)from, 3U * sizeof(int ) + sizeof(from->_sifields._sigchld));
  }
  return;
}
}
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo *from ) ;
extern void _NSIG_WORDS_is_unsupported_size(void) ;
__inline static void __attribute__((__always_inline__))  sigorsets(sigset_t *r , sigset_t const   *a ,
                                                                   sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  switch (2) {
  case 4: 
  a3 = a->sig[3];
  a2 = a->sig[2];
  b3 = b->sig[3];
  b2 = b->sig[2];
  r->sig[3] = a3 | b3;
  r->sig[2] = a2 | b2;
  case 2: 
  a1 = a->sig[1];
  b1 = b->sig[1];
  r->sig[1] = a1 | b1;
  case 1: 
  a0 = a->sig[0];
  b0 = b->sig[0];
  r->sig[0] = a0 | b0;
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigandsets(sigset_t *r ,
                                                                    sigset_t const   *a ,
                                                                    sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  switch (2) {
  case 4: 
  a3 = a->sig[3];
  a2 = a->sig[2];
  b3 = b->sig[3];
  b2 = b->sig[2];
  r->sig[3] = a3 & b3;
  r->sig[2] = a2 & b2;
  case 2: 
  a1 = a->sig[1];
  b1 = b->sig[1];
  r->sig[1] = a1 & b1;
  case 1: 
  a0 = a->sig[0];
  b0 = b->sig[0];
  r->sig[0] = a0 & b0;
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  signandsets(sigset_t *r ,
                                                                     sigset_t const   *a ,
                                                                     sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  switch (2) {
  case 4: 
  a3 = a->sig[3];
  a2 = a->sig[2];
  b3 = b->sig[3];
  b2 = b->sig[2];
  r->sig[3] = a3 & ~ b3;
  r->sig[2] = a2 & ~ b2;
  case 2: 
  a1 = a->sig[1];
  b1 = b->sig[1];
  r->sig[1] = a1 & ~ b1;
  case 1: 
  a0 = a->sig[0];
  b0 = b->sig[0];
  r->sig[0] = a0 & ~ b0;
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  signotset(sigset_t *set ) 
{ 

  {
  switch (2) {
  case 4: 
  set->sig[3] = ~ set->sig[3];
  set->sig[2] = ~ set->sig[2];
  case 2: 
  set->sig[1] = ~ set->sig[1];
  case 1: 
  set->sig[0] = ~ set->sig[0];
  break;
  default: 
  _NSIG_WORDS_is_unsupported_size();
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigemptyset(sigset_t *set ) 
{ 

  {
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)set, 0UL, sizeof(sigset_t ));
  break;
  case 2: 
  set->sig[1] = 0UL;
  case 1: 
  set->sig[0] = 0UL;
  break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigfillset(sigset_t *set ) 
{ 

  {
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)set, 4294967295UL, sizeof(sigset_t ));
  break;
  case 2: 
  set->sig[1] = 4294967295UL;
  case 1: 
  set->sig[0] = 4294967295UL;
  break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigaddsetmask(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  set->sig[0] |= mask;
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigdelsetmask(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  set->sig[0] &= ~ mask;
  return;
}
}
__inline static int __attribute__((__always_inline__))  sigtestsetmask(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((set->sig[0] & mask) != 0UL));
}
}
__inline static void __attribute__((__always_inline__))  siginitset(sigset_t *set ,
                                                                    unsigned long mask ) 
{ 

  {
  set->sig[0] = mask;
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)(& set->sig[1]), 0UL, sizeof(long ));
  break;
  case 2: 
  set->sig[1] = 0UL;
  case 1: ;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  siginitsetinv(sigset_t *set ,
                                                                       unsigned long mask ) 
{ 

  {
  set->sig[0] = ~ mask;
  switch (2) {
  default: 
  __constant_c_and_count_memset((void *)(& set->sig[1]), 4294967295UL, sizeof(long ));
  break;
  case 2: 
  set->sig[1] = 4294967295UL;
  case 1: ;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_sigpending(struct sigpending *sig ) 
{ 

  {
  sigemptyset(& sig->signal);
  while (1) {
    sig->list.next = & sig->list;
    sig->list.prev = & sig->list;
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  valid_signal(unsigned long sig ) 
{ int tmp ;

  {
  if (sig <= 64UL) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern long do_sigpending(void * , unsigned long  ) ;
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
extern int get_signal_to_deliver(siginfo_t *info , struct k_sigaction *return_ka ,
                                 struct pt_regs *regs , void *cookie ) ;
extern unsigned int securebits ;
extern void exit_fs(struct task_struct * ) ;
extern void set_fs_altroot(void) ;
extern void set_fs_root(struct fs_struct * , struct vfsmount * , struct dentry * ) ;
extern void set_fs_pwd(struct fs_struct * , struct vfsmount * , struct dentry * ) ;
extern struct fs_struct *copy_fs_struct(struct fs_struct * ) ;
extern void put_fs_struct(struct fs_struct * ) ;
__inline static void __attribute__((__always_inline__))  init_completion(struct completion *x ) 
{ 

  {
  x->done = 0U;
  init_waitqueue_head(& x->wait);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) wait_for_completion)(struct completion * ) ;
extern int ( __attribute__((__regparm__(3))) wait_for_completion_interruptible)(struct completion *x ) ;
extern unsigned long ( __attribute__((__regparm__(3))) wait_for_completion_timeout)(struct completion *x ,
                                                                                    unsigned long timeout ) ;
extern unsigned long ( __attribute__((__regparm__(3))) wait_for_completion_interruptible_timeout)(struct completion *x ,
                                                                                                  unsigned long timeout ) ;
extern void ( __attribute__((__regparm__(3))) complete)(struct completion * ) ;
extern void ( __attribute__((__regparm__(3))) complete_all)(struct completion * ) ;
extern int ( __attribute__((__regparm__(3))) attach_pid)(struct task_struct *task ,
                                                         enum pid_type type , int nr ) ;
extern void ( __attribute__((__regparm__(3))) detach_pid)(struct task_struct *task ,
                                                          enum pid_type  ) ;
extern struct pid *( __attribute__((__regparm__(3))) find_pid)(enum pid_type  , int  ) ;
extern int alloc_pidmap(void) ;
extern void ( __attribute__((__regparm__(3))) free_pidmap)(int  ) ;
extern void switch_exec_pids(struct task_struct *leader , struct task_struct *thread ) ;
extern initcall_t __con_initcall_start[] ;
extern initcall_t __con_initcall_end[] ;
extern initcall_t __security_initcall_start[] ;
extern initcall_t __security_initcall_end[] ;
extern char saved_command_line[] ;
extern struct pglist_data *pgdat_list ;
extern void __get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ,
                              struct pglist_data *pgdat ) ;
extern void get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ) ;
extern void build_all_zonelists(void) ;
extern void wakeup_kswapd(struct zone *zone , int order ) ;
extern int zone_watermark_ok(struct zone *z , int order , unsigned long mark , int alloc_type ,
                             int can_try_harder , int gfp_high ) ;
__inline static void __attribute__((__always_inline__))  memory_present(int nid ,
                                                                        unsigned long start ,
                                                                        unsigned long end ) 
{ 

  {
  return;
}
}
__inline static struct zone  __attribute__((__always_inline__)) *next_zone(struct zone *zone ) 
{ pg_data_t *pgdat ;

  {
  pgdat = zone->zone_pgdat;
  if ((unsigned int )zone < (unsigned int )((pgdat->node_zones + 3) - 1)) {
    zone ++;
  } else {
    if (pgdat->pgdat_next) {
      pgdat = pgdat->pgdat_next;
      zone = pgdat->node_zones;
    } else {
      zone = (struct zone *)((void *)0);
    }
  }
  return ((struct zone  __attribute__((__always_inline__)) *)zone);
}
}
__inline static int __attribute__((__always_inline__))  is_highmem_idx(int idx ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(idx == 2));
}
}
__inline static int __attribute__((__always_inline__))  is_normal_idx(int idx ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(idx == 1));
}
}
__inline static int __attribute__((__always_inline__))  is_highmem(struct zone *zone ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )zone == (unsigned int )((zone->zone_pgdat)->node_zones +
                                                                                            2)));
}
}
__inline static int __attribute__((__always_inline__))  is_normal(struct zone *zone ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )zone == (unsigned int )((zone->zone_pgdat)->node_zones +
                                                                                            1)));
}
}
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                          void * , size_t * , loff_t * ) ;
extern int sysctl_lowmem_reserve_ratio[2] ;
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                               void * , size_t * , loff_t * ) ;
extern struct pglist_data contig_page_data ;
__inline static void __attribute__((__always_inline__))  arch_free_page(struct page *page ,
                                                                        int order ) 
{ 

  {
  return;
}
}
extern struct page *( __attribute__((__regparm__(3))) __alloc_pages)(unsigned int  ,
                                                                     unsigned int  ,
                                                                     struct zonelist * ) ;
__inline static struct page  __attribute__((__always_inline__)) *alloc_pages_node(int nid ,
                                                                                  unsigned int gfp_mask ,
                                                                                  unsigned int order ) 
{ long tmp ;
  struct page  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp = __builtin_expect((long )(! (! (order >= 11U)) != 0), 0L);
  if (tmp) {
    return ((struct page  __attribute__((__always_inline__)) *)((void *)0));
  }
  tmp___0 = (struct page  __attribute__((__always_inline__)) *)__alloc_pages(gfp_mask,
                                                                             order,
                                                                             contig_page_data.node_zonelists +
                                                                             (gfp_mask &
                                                                              3U));
  return (tmp___0);
}
}
extern unsigned long ( __attribute__((__regparm__(3))) __get_free_pages)(unsigned int gfp_mask ,
                                                                         unsigned int order ) ;
extern unsigned long ( __attribute__((__regparm__(3))) get_zeroed_page)(unsigned int gfp_mask ) ;
extern void ( __attribute__((__regparm__(3))) __free_pages)(struct page *page , unsigned int order ) ;
extern void ( __attribute__((__regparm__(3))) free_pages)(unsigned long addr , unsigned int order ) ;
extern void ( __attribute__((__regparm__(3))) free_hot_page)(struct page *page ) ;
extern void ( __attribute__((__regparm__(3))) free_cold_page)(struct page *page ) ;
extern void page_alloc_init(void) ;
extern void kmem_cache_init(void)  __attribute__((__section__(".init.text"))) ;
extern kmem_cache_t *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                       void (*)(void * , kmem_cache_t * , unsigned long  ) ,
                                       void (*)(void * , kmem_cache_t * , unsigned long  ) ) ;
extern int kmem_cache_destroy(kmem_cache_t * ) ;
extern int kmem_cache_shrink(kmem_cache_t * ) ;
extern void *kmem_cache_alloc(kmem_cache_t * , unsigned int  ) ;
extern void kmem_cache_free(kmem_cache_t * , void * ) ;
extern unsigned int kmem_cache_size(kmem_cache_t * ) ;
extern kmem_cache_t *kmem_find_general_cachep(size_t size , int gfpflags ) ;
extern struct cache_sizes malloc_sizes[] ;
extern void *__kmalloc(size_t  , unsigned int  ) ;
extern void __you_cannot_kmalloc_that_much(void) ;
__inline static void __attribute__((__always_inline__))  *kmalloc(size_t size , unsigned int flags ) 
{ int i ;
  kmem_cache_t *tmp ;
  void __attribute__((__always_inline__))  *tmp___0 ;
  void __attribute__((__always_inline__))  *tmp___1 ;

  {
  if (0) {
    i = 0;
    if (size <= 32U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 64U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 96U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 128U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 192U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 256U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 512U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 1024U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 2048U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 4096U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 8192U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 16384U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 32768U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 65536U) {
      goto found;
    } else {
      i ++;
    }
    if (size <= 131072U) {
      goto found;
    } else {
      i ++;
    }
    __you_cannot_kmalloc_that_much();
    found: 
    if (flags & 1U) {
      tmp = malloc_sizes[i].cs_dmacachep;
    } else {
      tmp = malloc_sizes[i].cs_cachep;
    }
    tmp___0 = (void __attribute__((__always_inline__))  *)kmem_cache_alloc(tmp, flags);
    return (tmp___0);
  }
  tmp___1 = (void __attribute__((__always_inline__))  *)__kmalloc(size, flags);
  return (tmp___1);
}
}
extern void *kcalloc(size_t  , size_t  , unsigned int  ) ;
extern void kfree(void const   * ) ;
extern unsigned int ksize(void const   * ) ;
__inline static void __attribute__((__always_inline__))  *kmem_cache_alloc_node(kmem_cache_t *cachep ,
                                                                                int flags ,
                                                                                int node ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = (void __attribute__((__always_inline__))  *)kmem_cache_alloc(cachep, (unsigned int )flags);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  *kmalloc_node(size_t size ,
                                                                       int flags ,
                                                                       int node ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = kmalloc(size, (unsigned int )flags);
  return (tmp);
}
}
extern int ( __attribute__((__regparm__(3))) kmem_cache_reap)(int  ) ;
extern int ( __attribute__((__regparm__(3))) kmem_ptr_validate)(kmem_cache_t *cachep ,
                                                                void *ptr ) ;
extern kmem_cache_t *vm_area_cachep ;
extern kmem_cache_t *names_cachep ;
extern kmem_cache_t *files_cachep ;
extern kmem_cache_t *filp_cachep ;
extern kmem_cache_t *fs_cachep ;
extern kmem_cache_t *signal_cachep ;
extern kmem_cache_t *sighand_cachep ;
extern kmem_cache_t *bio_cachep ;
extern atomic_t slab_reclaim_pages ;
extern void *__alloc_percpu(size_t size , size_t align ) ;
extern void free_percpu(void const   * ) ;
extern int errno ;
extern void __secure_computing(int  ) ;
__inline static void __attribute__((__always_inline__))  secure_computing(int this_syscall ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = test_thread_flag(8);
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  if (tmp___1) {
    __secure_computing(this_syscall);
  }
  return;
}
}
extern unsigned long avenrun[] ;
extern unsigned long total_forks ;
extern int nr_threads ;
extern int last_pid ;
extern unsigned long per_cpu__process_counts ;
extern int nr_processes(void) ;
extern unsigned long nr_running(void) ;
extern unsigned long nr_uninterruptible(void) ;
extern unsigned long nr_iowait(void) ;
__inline static void __attribute__((__always_inline__))  init_timer(struct timer_list *timer ) 
{ spinlock_t __constr_expr_0 ;

  {
  timer->base = (struct tvec_t_base_s *)((void *)0);
  timer->magic = 1267182958UL;
  while (1) {
    spin_lock_init(&__constr_expr_0);
    timer->lock = __constr_expr_0;
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  timer_pending(struct timer_list  const  *timer ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )timer->base !=
                                                     (unsigned int )((void *)0)));
}
}
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
extern int del_timer(struct timer_list *timer ) ;
extern int __mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern unsigned long next_timer_interrupt(void) ;
__inline static void __attribute__((__always_inline__))  add_timer(struct timer_list *timer ) 
{ 

  {
  __mod_timer(timer, timer->expires);
  return;
}
}
extern int del_timer_sync(struct timer_list *timer ) ;
extern int del_singleshot_timer_sync(struct timer_list *timer ) ;
extern void init_timers(void) ;
extern void run_local_timers(void) ;
extern void it_real_fn(unsigned long  ) ;
extern rwlock_t tasklist_lock ;
extern spinlock_t mmlist_lock ;
extern void sched_init(void) ;
extern void sched_init_smp(void) ;
extern void init_idle(task_t *idle , int cpu ) ;
extern cpumask_t nohz_cpu_mask ;
extern void show_state(void) ;
extern void show_regs(struct pt_regs * ) ;
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
extern void io_schedule(void) ;
extern long io_schedule_timeout(long timeout ) ;
extern void cpu_init(void) ;
extern void trap_init(void) ;
extern void update_process_times(int user ) ;
extern void scheduler_tick(void) ;
extern int in_sched_functions(unsigned long addr ) ;
extern long ( __attribute__((__regparm__(3))) schedule_timeout)(long timeout ) ;
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
extern int sysctl_max_map_count ;
extern struct workqueue_struct *__create_workqueue(char const   *name , int singlethread ) ;
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
extern int ( __attribute__((__regparm__(3))) queue_work)(struct workqueue_struct *wq ,
                                                         struct work_struct *work ) ;
extern int ( __attribute__((__regparm__(3))) queue_delayed_work)(struct workqueue_struct *wq ,
                                                                 struct work_struct *work ,
                                                                 unsigned long delay ) ;
extern void ( __attribute__((__regparm__(3))) flush_workqueue)(struct workqueue_struct *wq ) ;
extern int ( __attribute__((__regparm__(3))) schedule_work)(struct work_struct *work ) ;
extern int ( __attribute__((__regparm__(3))) schedule_delayed_work)(struct work_struct *work ,
                                                                    unsigned long delay ) ;
extern int schedule_delayed_work_on(int cpu , struct work_struct *work , unsigned long delay ) ;
extern void flush_scheduled_work(void) ;
extern int current_is_keventd(void) ;
extern int keventd_up(void) ;
extern void init_workqueues(void) ;
extern void cancel_rearming_delayed_work(struct work_struct *work ) ;
extern void cancel_rearming_delayed_workqueue(struct workqueue_struct * , struct work_struct * ) ;
__inline static int __attribute__((__always_inline__))  cancel_delayed_work(struct work_struct *work ) 
{ int ret ;

  {
  ret = del_timer_sync(& work->timer);
  if (ret) {
    clear_bit(0, (unsigned long volatile   *)(& work->pending));
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
extern unsigned int aio_max_size ;
extern ssize_t ( __attribute__((__regparm__(3))) wait_on_sync_kiocb)(struct kiocb *iocb ) ;
extern int ( __attribute__((__regparm__(3))) aio_put_req)(struct kiocb *iocb ) ;
extern void ( __attribute__((__regparm__(3))) kick_iocb)(struct kiocb *iocb ) ;
extern int ( __attribute__((__regparm__(3))) aio_complete)(struct kiocb *iocb , long res ,
                                                           long res2 ) ;
extern void ( __attribute__((__regparm__(3))) __put_ioctx)(struct kioctx *ctx ) ;
extern void ( __attribute__((__regparm__(3))) exit_aio)(struct mm_struct *mm ) ;
extern struct kioctx *lookup_ioctx(unsigned long ctx_id ) ;
extern int ( __attribute__((__regparm__(3))) io_submit_one)(struct kioctx *ctx , struct iocb *user_iocb ,
                                                            struct iocb *iocb ) ;
__inline static struct kiocb  __attribute__((__always_inline__)) *list_kiocb(struct list_head *h ) 
{ struct list_head  const  *__mptr ;

  {
  __mptr = (struct list_head  const  *)h;
  return ((struct kiocb  __attribute__((__always_inline__)) *)((struct kiocb *)((char *)__mptr -
                                                                                (unsigned int )(& ((struct kiocb *)0)->ki_list))));
}
}
extern atomic_t aio_nr ;
extern unsigned int aio_max_nr ;
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
extern void arch_unmap_area(struct vm_area_struct *area ) ;
extern void arch_unmap_area_topdown(struct vm_area_struct *area ) ;
extern struct user_struct *find_user(uid_t  ) ;
extern struct user_struct root_user ;
extern void exit_io_context(void) ;
extern struct group_info *groups_alloc(int gidsetsize ) ;
extern void groups_free(struct group_info *group_info ) ;
extern int set_current_groups(struct group_info *group_info ) ;
__inline static pid_t __attribute__((__always_inline__))  process_group(struct task_struct *tsk ) 
{ 

  {
  return ((tsk->signal)->pgrp);
}
}
__inline static int __attribute__((__always_inline__))  pid_alive(struct task_struct *p ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(p->pids[0].nr != 0));
}
}
extern void free_task(struct task_struct *tsk ) ;
extern void __put_task_struct(struct task_struct *tsk ) ;
extern int set_cpus_allowed(task_t *p , cpumask_t new_mask ) ;
extern unsigned long long sched_clock(void) ;
extern unsigned long long current_sched_time(task_t const   *current_task ) ;
extern void sched_exec(void) ;
extern void sched_idle_next(void) ;
extern void set_user_nice(task_t *p , long nice ) ;
extern int task_prio(task_t const   *p ) ;
extern int task_nice(task_t const   *p ) ;
extern int can_nice(task_t const   *p , int nice ) ;
extern int task_curr(task_t const   *p ) ;
extern int idle_cpu(int cpu ) ;
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param * ) ;
extern task_t *idle_task(int cpu ) ;
extern void yield(void) ;
extern struct exec_domain default_exec_domain ;
__inline static int __attribute__((__always_inline__))  kstack_end(void *addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! ((((unsigned long )addr + (unsigned long )sizeof(void *)) -
                                                         1UL) & (unsigned long )(8192U -
                                                                                 sizeof(void *))) !=
                                                     0));
}
}
extern union thread_union init_thread_union ;
extern struct task_struct init_task ;
extern struct mm_struct init_mm ;
extern struct task_struct *find_task_by_pid_type(int type , int pid ) ;
extern void set_special_pids(pid_t session , pid_t pgrp ) ;
extern void __set_special_pids(pid_t session , pid_t pgrp ) ;
extern struct user_struct *alloc_uid(uid_t  ) ;
__inline static struct user_struct  __attribute__((__always_inline__)) *get_uid(struct user_struct *u ) 
{ 

  {
  atomic_inc(& u->__count);
  return ((struct user_struct  __attribute__((__always_inline__)) *)u);
}
}
extern void free_uid(struct user_struct * ) ;
extern void switch_uid(struct user_struct * ) ;
extern void do_timer(struct pt_regs * ) ;
extern int ( __attribute__((__regparm__(3))) wake_up_state)(struct task_struct *tsk ,
                                                            unsigned int state ) ;
extern int ( __attribute__((__regparm__(3))) wake_up_process)(struct task_struct *tsk ) ;
extern void ( __attribute__((__regparm__(3))) wake_up_new_task)(struct task_struct *tsk ,
                                                                unsigned long clone_flags ) ;
extern void kick_process(struct task_struct *tsk ) ;
extern void ( __attribute__((__regparm__(3))) sched_fork)(task_t *p ) ;
extern void ( __attribute__((__regparm__(3))) sched_exit)(task_t *p ) ;
extern int in_group_p(gid_t  ) ;
extern int in_egroup_p(gid_t  ) ;
extern void proc_caches_init(void) ;
extern void flush_signals(struct task_struct * ) ;
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
__inline static int __attribute__((__always_inline__))  dequeue_signal_lock(struct task_struct *tsk ,
                                                                            sigset_t *mask ,
                                                                            siginfo_t *info ) 
{ unsigned long flags ;
  int ret ;

  {
  flags = _spin_lock_irqsave(& (tsk->sighand)->siglock);
  ret = dequeue_signal(tsk, mask, info);
  _spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
extern void unblock_all_signals(void) ;
extern void release_task(struct task_struct *p ) ;
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int send_group_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int force_sigsegv(int  , struct task_struct * ) ;
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int __kill_pg_info(int sig , struct siginfo *info , pid_t pgrp ) ;
extern int kill_pg_info(int  , struct siginfo * , pid_t  ) ;
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
extern void do_notify_parent(struct task_struct * , int  ) ;
extern void force_sig(int  , struct task_struct * ) ;
extern void force_sig_specific(int  , struct task_struct * ) ;
extern int send_sig(int  , struct task_struct * , int  ) ;
extern void zap_other_threads(struct task_struct *p ) ;
extern int kill_pg(pid_t  , int  , int  ) ;
extern int kill_sl(pid_t  , int  , int  ) ;
extern int kill_proc(pid_t  , int  , int  ) ;
extern struct sigqueue *sigqueue_alloc(void) ;
extern void sigqueue_free(struct sigqueue * ) ;
extern int send_sigqueue(int  , struct sigqueue * , struct task_struct * ) ;
extern int send_group_sigqueue(int  , struct sigqueue * , struct task_struct * ) ;
extern int do_sigaction(int  , struct k_sigaction  const  * , struct k_sigaction * ) ;
extern int do_sigaltstack(stack_t const   * , stack_t * , unsigned long  ) ;
__inline static int __attribute__((__always_inline__))  on_sig_stack(unsigned long sp ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp = get_current();
  tmp___0 = get_current();
  return ((int __attribute__((__always_inline__))  )(sp - tmp->sas_ss_sp < (unsigned long )tmp___0->sas_ss_size));
}
}
__inline static int __attribute__((__always_inline__))  sas_ss_flags(unsigned long sp ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;
  int tmp___3 ;
  int __attribute__((__always_inline__))  tmp___4 ;
  int __attribute__((__always_inline__))  tmp___5 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___6 ;

  {
  tmp___6 = get_current();
  if (tmp___6->sas_ss_size == 0U) {
    tmp___3 = 2;
  } else {
    tmp___5 = on_sig_stack(sp);
    if (tmp___5) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___3);
}
}
__inline static int __attribute__((__always_inline__))  capable(int cap ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp___0 = get_current();
  if (tmp___0->cap_effective & (unsigned int )(1 << cap)) {
    tmp = get_current();
    tmp->flags |= 256UL;
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern struct mm_struct *mm_alloc(void) ;
extern void ( __attribute__((__regparm__(3))) __mmdrop)(struct mm_struct * ) ;
__inline static void __attribute__((__always_inline__))  mmdrop(struct mm_struct *mm ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = atomic_dec_and_test(& mm->mm_count);
  if (tmp) {
    __mmdrop(mm);
  }
  return;
}
}
extern void mmput(struct mm_struct * ) ;
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
extern int copy_thread(int  , unsigned long  , unsigned long  , unsigned long  , struct task_struct * ,
                       struct pt_regs * ) ;
extern void flush_thread(void) ;
extern void exit_thread(void) ;
extern void exit_files(struct task_struct * ) ;
extern void exit_signal(struct task_struct * ) ;
extern void __exit_signal(struct task_struct * ) ;
extern void exit_sighand(struct task_struct * ) ;
extern void __exit_sighand(struct task_struct * ) ;
extern void exit_itimers(struct signal_struct * ) ;
extern void do_group_exit(int  ) ;
extern void daemonize(char const   *  , ...) ;
extern int allow_signal(int  ) ;
extern int disallow_signal(int  ) ;
extern task_t *child_reaper ;
extern int do_execve(char * , char ** , char ** , struct pt_regs * ) ;
extern long do_fork(unsigned long  , unsigned long  , struct pt_regs * , unsigned long  ,
                    int * , int * ) ;
extern task_t *fork_idle(int  ) ;
extern void set_task_comm(struct task_struct *tsk , char *from ) ;
extern void get_task_comm(char *to , struct task_struct *tsk ) ;
extern void wait_task_inactive(task_t *p ) ;
extern task_t *( __attribute__((__regparm__(3))) next_thread)(task_t const   *p ) ;
__inline static int __attribute__((__always_inline__))  thread_group_empty(task_t *p ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = list_empty((struct list_head  const  *)(& p->pids[1].pid_list));
  return (tmp);
}
}
extern void unhash_process(struct task_struct *p ) ;
__inline static void __attribute__((__always_inline__))  task_lock(struct task_struct *p ) 
{ 

  {
  _spin_lock(& p->alloc_lock);
  return;
}
}
__inline static void __attribute__((__always_inline__))  task_unlock(struct task_struct *p ) 
{ 

  {
  _spin_unlock(& p->alloc_lock);
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_tsk_thread_flag(struct task_struct *tsk ,
                                                                             int flag ) 
{ 

  {
  set_ti_thread_flag(tsk->thread_info, flag);
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_tsk_thread_flag(struct task_struct *tsk ,
                                                                               int flag ) 
{ 

  {
  clear_ti_thread_flag(tsk->thread_info, flag);
  return;
}
}
__inline static int __attribute__((__always_inline__))  test_and_set_tsk_thread_flag(struct task_struct *tsk ,
                                                                                     int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_ti_thread_flag(tsk->thread_info, flag);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_and_clear_tsk_thread_flag(struct task_struct *tsk ,
                                                                                       int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_clear_ti_thread_flag(tsk->thread_info, flag);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  test_tsk_thread_flag(struct task_struct *tsk ,
                                                                             int flag ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_ti_thread_flag(tsk->thread_info, flag);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  set_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  set_tsk_thread_flag(tsk, 3);
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  clear_tsk_thread_flag(tsk, 3);
  return;
}
}
__inline static int __attribute__((__always_inline__))  signal_pending(struct task_struct *p ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = test_tsk_thread_flag(p, 2);
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = (int __attribute__((__always_inline__))  )__builtin_expect((long )tmp___0,
                                                                       0L);
  return (tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  need_resched(void) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = test_thread_flag(3);
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = (int __attribute__((__always_inline__))  )__builtin_expect((long )tmp___0,
                                                                       0L);
  return (tmp___1);
}
}
extern int cond_resched(void) ;
extern int cond_resched_lock(spinlock_t *lock ) ;
extern int cond_resched_softirq(void) ;
__inline static int __attribute__((__always_inline__))  lock_need_resched(spinlock_t *lock ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = need_resched();
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern void ( __attribute__((__regparm__(3))) recalc_sigpending_tsk)(struct task_struct *t ) ;
extern void recalc_sigpending(void) ;
extern void signal_wake_up(struct task_struct *t , int resume_stopped ) ;
__inline static unsigned int __attribute__((__always_inline__))  task_cpu(struct task_struct  const  *p ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(p->thread_info)->cpu);
}
}
__inline static void __attribute__((__always_inline__))  set_task_cpu(struct task_struct *p ,
                                                                      unsigned int cpu ) 
{ 

  {
  (p->thread_info)->cpu = cpu;
  return;
}
}
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
extern long sched_setaffinity(pid_t pid , cpumask_t new_mask ) ;
extern long sched_getaffinity(pid_t pid , cpumask_t *mask ) ;
extern void normalize_rt_tasks(void) ;
extern void refrigerator(unsigned long  ) ;
extern int freeze_processes(void) ;
extern void thaw_processes(void) ;
__inline static int __attribute__((__always_inline__))  try_to_freeze(unsigned long refrigerator_flags ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = get_current();
  if (tmp->flags & 16384UL) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  if (tmp___1) {
    refrigerator(refrigerator_flags);
    return ((int __attribute__((__always_inline__))  )1);
  } else {
    return ((int __attribute__((__always_inline__))  )0);
  }
}
}
extern int ( /* format attribute */  request_module)(char const   *name  , ...) ;
extern int call_usermodehelper(char *path , char **argv , char **envp , int wait ) ;
extern void usermodehelper_init(void) ;
extern struct new_utsname system_utsname ;
extern struct rw_semaphore uts_sem ;
extern int dump_task_regs(struct task_struct * , elf_gregset_t * ) ;
extern int dump_task_fpu(struct task_struct * , elf_fpregset_t * ) ;
extern int dump_task_extended_fpu(struct task_struct * , struct user_fxsr_struct * ) ;
extern void __kernel_vsyscall ;
extern Elf32_Dyn _DYNAMIC[] ;
extern int sysfs_create_dir(struct kobject * ) ;
extern void sysfs_remove_dir(struct kobject * ) ;
extern int sysfs_rename_dir(struct kobject * , char const   *new_name ) ;
extern int sysfs_create_file(struct kobject * , struct attribute  const  * ) ;
extern int sysfs_update_file(struct kobject * , struct attribute  const  * ) ;
extern int sysfs_chmod_file(struct kobject *kobj , struct attribute *attr , mode_t mode ) ;
extern void sysfs_remove_file(struct kobject * , struct attribute  const  * ) ;
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char *name ) ;
extern void sysfs_remove_link(struct kobject * , char *name ) ;
extern int sysfs_create_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern int sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern int sysfs_create_group(struct kobject * , struct attribute_group  const  * ) ;
extern void sysfs_remove_group(struct kobject * , struct attribute_group  const  * ) ;
extern void kref_init(struct kref *kref ) ;
extern void kref_get(struct kref *kref ) ;
extern int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) ;
extern char hotplug_path[] ;
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action , struct attribute *attr ) ;
extern int kobject_uevent_atomic(struct kobject *kobj , enum kobject_action action ,
                                 struct attribute *attr ) ;
extern u64 hotplug_seqnum ;
extern int ( /* format attribute */  kobject_set_name)(struct kobject * , char const   * 
                                                       , ...) ;
__inline static char __attribute__((__always_inline__))  *kobject_name(struct kobject *kobj ) 
{ 

  {
  return ((char __attribute__((__always_inline__))  *)kobj->k_name);
}
}
extern void kobject_init(struct kobject * ) ;
extern void kobject_cleanup(struct kobject * ) ;
extern int kobject_add(struct kobject * ) ;
extern void kobject_del(struct kobject * ) ;
extern int kobject_rename(struct kobject * , char *new_name ) ;
extern int kobject_register(struct kobject * ) ;
extern void kobject_unregister(struct kobject * ) ;
extern struct kobject *kobject_get(struct kobject * ) ;
extern void kobject_put(struct kobject * ) ;
extern char *kobject_get_path(struct kobject * , int  ) ;
extern void kset_init(struct kset *k ) ;
extern int kset_add(struct kset *k ) ;
extern int kset_register(struct kset *k ) ;
extern void kset_unregister(struct kset *k ) ;
__inline static struct kset  __attribute__((__always_inline__)) *to_kset(struct kobject *kobj ) 
{ struct kobject  const  *__mptr ;
  struct kset *tmp ;
  struct kobject  const  *__mptr___0 ;

  {
  if (kobj) {
    __mptr___0 = (struct kobject  const  *)kobj;
    tmp = (struct kset *)((char *)__mptr___0 - (unsigned int )(& ((struct kset *)0)->kobj));
  } else {
    tmp = (struct kset *)((void *)0);
  }
  return ((struct kset  __attribute__((__always_inline__)) *)tmp);
}
}
__inline static struct kset  __attribute__((__always_inline__)) *kset_get(struct kset *k ) 
{ struct kobject *tmp ;
  struct kset  __attribute__((__always_inline__)) *tmp___0 ;
  struct kset  __attribute__((__always_inline__)) *tmp___1 ;
  struct kobject *tmp___2 ;

  {
  if (k) {
    tmp___2 = kobject_get(& k->kobj);
    tmp___1 = to_kset(tmp___2);
  } else {
    tmp___1 = (struct kset  __attribute__((__always_inline__)) *)((void *)0);
  }
  return (tmp___1);
}
}
__inline static void __attribute__((__always_inline__))  kset_put(struct kset *k ) 
{ 

  {
  kobject_put(& k->kobj);
  return;
}
}
__inline static struct kobj_type  __attribute__((__always_inline__)) *get_ktype(struct kobject *k ) 
{ 

  {
  if (k->kset) {
    if ((k->kset)->ktype) {
      return ((struct kobj_type  __attribute__((__always_inline__)) *)(k->kset)->ktype);
    } else {
      return ((struct kobj_type  __attribute__((__always_inline__)) *)k->ktype);
    }
  } else {
    return ((struct kobj_type  __attribute__((__always_inline__)) *)k->ktype);
  }
}
}
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
extern struct subsystem kernel_subsys ;
extern void subsystem_init(struct subsystem * ) ;
extern int subsystem_register(struct subsystem * ) ;
extern void subsystem_unregister(struct subsystem * ) ;
__inline static struct subsystem  __attribute__((__always_inline__)) *subsys_get(struct subsystem *s ) 
{ struct kset  const  *__mptr ;
  struct kset  const  *tmp ;
  struct subsystem *tmp___0 ;
  struct kset  const  *__mptr___0 ;
  struct kset  const  *tmp___1 ;

  {
  if (s) {
    tmp___1 = (struct kset  const  *)kset_get(& s->kset);
    __mptr___0 = tmp___1;
    tmp___0 = (struct subsystem *)((char *)__mptr___0 - (unsigned int )(& ((struct subsystem *)0)->kset));
  } else {
    tmp___0 = (struct subsystem *)((void *)0);
  }
  return ((struct subsystem  __attribute__((__always_inline__)) *)tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  subsys_put(struct subsystem *s ) 
{ 

  {
  kset_put(& s->kset);
  return;
}
}
extern int subsys_create_file(struct subsystem * , struct subsys_attribute * ) ;
extern void subsys_remove_file(struct subsystem * , struct subsys_attribute * ) ;
extern void kobject_hotplug(struct kobject *kobj , enum kobject_action action ) ;
extern int ( /* format attribute */  add_hotplug_env_var)(char **envp , int num_envp ,
                                                          int *cur_index , char *buffer ,
                                                          int buffer_size , int *cur_len ,
                                                          char const   *format  , ...) ;
extern int parse_args(char const   *name , char *args , struct kernel_param *params ,
                      unsigned int num , int (*unknown)(char *param , char *val ) ) ;
extern int param_set_byte(char const   *val , struct kernel_param *kp ) ;
extern int param_get_byte(char *buffer , struct kernel_param *kp ) ;
extern int param_set_short(char const   *val , struct kernel_param *kp ) ;
extern int param_get_short(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ushort(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ushort(char *buffer , struct kernel_param *kp ) ;
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ulong(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ulong(char *buffer , struct kernel_param *kp ) ;
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
extern int param_set_invbool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_invbool(char *buffer , struct kernel_param *kp ) ;
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
extern int param_set_copystring(char const   *val , struct kernel_param *kp ) ;
extern int param_get_string(char *buffer , struct kernel_param *kp ) ;
extern int param_array(char const   *name , char const   *val , unsigned int min ,
                       unsigned int max , void *elem , int elemsize , int (*set)(char const   * ,
                                                                                 struct kernel_param *kp ) ,
                       int *num ) ;
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param *kparam ,
                                    unsigned int num_params ) ;
extern void module_param_sysfs_remove(struct module *mod ) ;
__inline static void __attribute__((__always_inline__))  local_inc(local_t *v ) 
{ 

  {
  __asm__  volatile   ("incl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  local_dec(local_t *v ) 
{ 

  {
  __asm__  volatile   ("decl %0": "=m" (v->counter): "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  local_add(unsigned long i ,
                                                                   local_t *v ) 
{ 

  {
  __asm__  volatile   ("addl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
__inline static void __attribute__((__always_inline__))  local_sub(unsigned long i ,
                                                                   local_t *v ) 
{ 

  {
  __asm__  volatile   ("subl %1,%0": "=m" (v->counter): "ir" (i), "m" (v->counter));
}
}
extern int init_module(void)  __attribute__((__alias__("synclink_init"))) ;
extern void cleanup_module(void)  __attribute__((__alias__("synclink_exit"))) ;
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
extern void sort_main_extable(void) ;
extern struct subsystem module_subsys ;
struct module __this_module  __attribute__((__section__(".gnu.linkonce.this_module"))) ;
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
extern void *__symbol_get(char const   *symbol ) ;
extern void *__symbol_get_gpl(char const   *symbol ) ;
__inline static int __attribute__((__always_inline__))  module_is_live(struct module *mod ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((int )mod->state != 2));
}
}
extern struct module *module_text_address(unsigned long addr ) ;
extern struct module *__module_text_address(unsigned long addr ) ;
extern struct module *module_get_kallsym(unsigned int symnum , unsigned long *value ,
                                         char *type , char *namebuf ) ;
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
extern int is_exported(char const   *name , struct module  const  *mod ) ;
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
__inline static int __attribute__((__always_inline__))  try_module_get(struct module *module ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  if (! module) {
    tmp___0 = 1;
  } else {
    tmp = module_is_live(module);
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  module_put(struct module *module ) 
{ 

  {
  return;
}
}
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ) ;
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
extern int register_module_notifier(struct notifier_block *nb ) ;
extern int unregister_module_notifier(struct notifier_block *nb ) ;
extern void print_modules(void) ;
extern void module_add_driver(struct module * , struct device_driver * ) ;
extern void module_remove_driver(struct device_driver * ) ;
extern void __attribute__((__deprecated__))  inter_module_register(char const   * ,
                                                                   struct module * ,
                                                                   void const   * ) ;
extern void __attribute__((__deprecated__))  inter_module_unregister(char const   * ) ;
extern void const   * __attribute__((__deprecated__)) inter_module_get_request(char const   * ,
                                                                               char const   * ) ;
extern void __attribute__((__deprecated__))  inter_module_put(char const   * ) ;
extern int ( __attribute__((__regparm__(3))) __reacquire_kernel_lock)(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) __release_kernel_lock)(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static int __attribute__((__always_inline__))  reacquire_kernel_lock(struct task_struct *task ) 
{ int __attribute__((__always_inline__))  tmp ;
  long tmp___0 ;

  {
  tmp___0 = __builtin_expect((long )(! (! (task->lock_depth >= 0)) != 0), 0L);
  if (tmp___0) {
    tmp = (int __attribute__((__always_inline__))  )__reacquire_kernel_lock();
    return (tmp);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern void ( __attribute__((__regparm__(3))) lock_kernel)(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) unlock_kernel)(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static int __attribute__((__always_inline__))  irq_canonicalize(int irq___0 ) 
{ int tmp ;

  {
  if (irq___0 == 2) {
    tmp = 9;
  } else {
    tmp = irq___0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
extern void release_vm86_irqs(struct task_struct * ) ;
extern int irqbalance_disable(char *str ) ;
extern irq_desc_t irq_desc[224] ;
extern void profile_init(void)  __attribute__((__section__(".init.text"))) ;
extern void profile_tick(int  , struct pt_regs * ) ;
extern void profile_hit(int  , void * ) ;
extern void create_prof_cpu_mask(struct proc_dir_entry * ) ;
extern void profile_task_exit(struct task_struct *task ) ;
extern int profile_handoff_task(struct task_struct *task ) ;
extern void profile_munmap(unsigned long addr ) ;
extern int task_handoff_register(struct notifier_block *n ) ;
extern int task_handoff_unregister(struct notifier_block *n ) ;
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
extern int register_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern void unregister_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern int (*timer_hook)(struct pt_regs * ) ;
extern char _text[] ;
extern char _stext[] ;
extern char _etext[] ;
extern char _data[] ;
extern char _sdata[] ;
extern char _edata[] ;
extern char __bss_start[] ;
extern char __bss_stop[] ;
extern char __init_begin[] ;
extern char __init_end[] ;
extern char _sinittext[] ;
extern char _einittext[] ;
extern char _sextratext[]  __attribute__((__weak__)) ;
extern char _eextratext[]  __attribute__((__weak__)) ;
extern char _end[] ;
extern u8 irq_vector[256] ;
extern void (*interrupt[224])(void) ;
extern void ( __attribute__((__regparm__(3))) reschedule_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) invalidate_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) call_function_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) apic_timer_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) error_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) spurious_interrupt)(void) ;
extern void ( __attribute__((__regparm__(3))) thermal_interrupt)(struct pt_regs * ) ;
extern void disable_8259A_irq(unsigned int irq ) ;
extern void enable_8259A_irq(unsigned int irq ) ;
extern int i8259A_irq_pending(unsigned int irq ) ;
extern void make_8259A_irq(unsigned int irq ) ;
extern void init_8259A(int aeoi ) ;
extern void ( __attribute__((__regparm__(3))) send_IPI_self)(int vector ) ;
extern void init_VISWS_APIC_irqs(void) ;
extern void setup_IO_APIC(void) ;
extern void disable_IO_APIC(void) ;
extern void print_IO_APIC(void) ;
extern int IO_APIC_get_PCI_irq_vector(int bus , int slot , int fn ) ;
extern void send_IPI(int dest , int vector ) ;
extern void setup_ioapic_dest(void) ;
extern unsigned long io_apic_irqs ;
extern atomic_t irq_err_count ;
extern atomic_t irq_mis_count ;
__inline static void __attribute__((__always_inline__))  hw_resend_irq(struct hw_interrupt_type *h ,
                                                                       unsigned int i ) 
{ 

  {
  if (i >= 16U) {
    send_IPI_self((int )irq_vector[i]);
  } else {
    if ((unsigned long )(1 << i) & io_apic_irqs) {
      send_IPI_self((int )irq_vector[i]);
    }
  }
  return;
}
}
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
extern cpumask_t irq_affinity[224] ;
extern int no_irq_affinity ;
extern int noirqdebug_setup(char *str ) ;
extern int ( __attribute__((__regparm__(3))) handle_IRQ_event)(unsigned int irq ,
                                                               struct pt_regs *regs ,
                                                               struct irqaction *action ) ;
extern unsigned int ( __attribute__((__regparm__(3))) __do_IRQ)(unsigned int irq ,
                                                                struct pt_regs *regs ) ;
extern void note_interrupt(unsigned int irq , irq_desc_t *desc , int action_ret ) ;
extern void report_bad_irq(unsigned int irq , irq_desc_t *desc , int action_ret ) ;
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
extern void init_irq_proc(void) ;
extern hw_irq_controller no_irq_type ;
extern irq_cpustat_t per_cpu__irq_stat ;
extern irq_cpustat_t irq_stat[] ;
extern void ack_bad_irq(unsigned int irq ) ;
extern void synchronize_irq(unsigned int irq ) ;
__inline static void __attribute__((__always_inline__))  account_user_vtime(struct task_struct *tsk ) 
{ 

  {
  return;
}
}
extern void irq_exit(void) ;
extern irqreturn_t no_action(int cpl , void *dev_id , struct pt_regs *regs ) ;
extern int request_irq(unsigned int  , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                       unsigned long  , char const   * , void * ) ;
extern void free_irq(unsigned int  , void * ) ;
extern void disable_irq_nosync(unsigned int irq ) ;
extern void disable_irq(unsigned int irq ) ;
extern void enable_irq(unsigned int irq ) ;
extern void local_bh_enable(void) ;
extern void ( __attribute__((__regparm__(0))) do_softirq)(void) ;
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) , void *data ) ;
extern void softirq_init(void) ;
extern void ( __attribute__((__regparm__(3))) raise_softirq_irqoff)(unsigned int nr ) ;
extern void ( __attribute__((__regparm__(3))) raise_softirq)(unsigned int nr ) ;
__inline static int __attribute__((__always_inline__))  tasklet_trylock(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  tmp = test_and_set_bit(1, (unsigned long volatile   *)(& t->state));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  tasklet_unlock(struct tasklet_struct *t ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  clear_bit(1, (unsigned long volatile   *)(& t->state));
}
}
__inline static void __attribute__((__always_inline__))  tasklet_unlock_wait(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    tmp = constant_test_bit(1, (unsigned long const volatile   *)(& t->state));
    if (! tmp) {
      break;
    }
    __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __tasklet_schedule)(struct tasklet_struct *t ) ;
__inline static void __attribute__((__always_inline__))  tasklet_schedule(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  if (! tmp) {
    __tasklet_schedule(t);
  }
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __tasklet_hi_schedule)(struct tasklet_struct *t ) ;
__inline static void __attribute__((__always_inline__))  tasklet_hi_schedule(struct tasklet_struct *t ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  if (! tmp) {
    __tasklet_hi_schedule(t);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 

  {
  atomic_inc(& t->count);
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  tasklet_disable(struct tasklet_struct *t ) 
{ 

  {
  tasklet_disable_nosync(t);
  tasklet_unlock_wait(t);
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
}
}
__inline static void __attribute__((__always_inline__))  tasklet_enable(struct tasklet_struct *t ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  atomic_dec(& t->count);
}
}
extern void tasklet_kill(struct tasklet_struct *t ) ;
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
extern unsigned long probe_irq_on(void) ;
extern int probe_irq_off(unsigned long  ) ;
extern unsigned int probe_irq_mask(unsigned long  ) ;
extern struct resource ioport_resource ;
extern struct resource iomem_resource ;
extern int request_resource(struct resource *root , struct resource *new ) ;
extern struct resource *____request_resource(struct resource *root , struct resource *new ) ;
extern int release_resource(struct resource *new ) ;
extern int insert_resource(struct resource *parent , struct resource *new ) ;
extern int allocate_resource(struct resource *root , struct resource *new , unsigned long size ,
                             unsigned long min , unsigned long max , unsigned long align ,
                             void (*alignf)(void * , struct resource * , unsigned long  ,
                                            unsigned long  ) , void *alignf_data ) ;
extern int adjust_resource(struct resource *res , unsigned long start , unsigned long size ) ;
extern struct resource *__request_region(struct resource * , unsigned long start ,
                                         unsigned long n , char const   *name ) ;
extern int __check_region(struct resource * , unsigned long  , unsigned long  ) ;
extern void __release_region(struct resource * , unsigned long  , unsigned long  ) ;
__inline static int __attribute__((__deprecated__, __always_inline__))  check_region(unsigned long s ,
                                                                                     unsigned long n ) 
{ int __attribute__((__deprecated__, __always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__deprecated__, __always_inline__))  )__check_region(& ioport_resource,
                                                                                 s,
                                                                                 n);
  return (tmp);
}
}
extern int bus_register(struct bus_type *bus ) ;
extern void bus_unregister(struct bus_type *bus ) ;
extern int bus_rescan_devices(struct bus_type *bus ) ;
extern struct bus_type *get_bus(struct bus_type *bus ) ;
extern void put_bus(struct bus_type *bus ) ;
extern struct bus_type *find_bus(char *name ) ;
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device * , void * ) ) ;
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
extern int bus_create_file(struct bus_type * , struct bus_attribute * ) ;
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
extern int driver_register(struct device_driver *drv ) ;
extern void driver_unregister(struct device_driver *drv ) ;
extern struct device_driver *get_driver(struct device_driver *drv ) ;
extern void put_driver(struct device_driver *drv ) ;
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
extern int driver_create_file(struct device_driver * , struct driver_attribute * ) ;
extern void driver_remove_file(struct device_driver * , struct driver_attribute * ) ;
extern int class_register(struct class * ) ;
extern void class_unregister(struct class * ) ;
extern struct class *class_get(struct class * ) ;
extern void class_put(struct class * ) ;
extern int class_create_file(struct class * , struct class_attribute  const  * ) ;
extern void class_remove_file(struct class * , struct class_attribute  const  * ) ;
__inline static void __attribute__((__always_inline__))  *class_get_devdata(struct class_device *dev ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)dev->class_data);
}
}
__inline static void __attribute__((__always_inline__))  class_set_devdata(struct class_device *dev ,
                                                                           void *data ) 
{ 

  {
  dev->class_data = data;
  return;
}
}
extern int class_device_register(struct class_device * ) ;
extern void class_device_unregister(struct class_device * ) ;
extern void class_device_initialize(struct class_device * ) ;
extern int class_device_add(struct class_device * ) ;
extern void class_device_del(struct class_device * ) ;
extern int class_device_rename(struct class_device * , char * ) ;
extern struct class_device *class_device_get(struct class_device * ) ;
extern void class_device_put(struct class_device * ) ;
extern int class_device_create_file(struct class_device * , struct class_device_attribute  const  * ) ;
extern void class_device_remove_file(struct class_device * , struct class_device_attribute  const  * ) ;
extern int class_device_create_bin_file(struct class_device * , struct bin_attribute * ) ;
extern void class_device_remove_bin_file(struct class_device * , struct bin_attribute * ) ;
extern int class_interface_register(struct class_interface * ) ;
extern void class_interface_unregister(struct class_interface * ) ;
extern struct class_simple *class_simple_create(struct module *owner , char *name ) ;
extern void class_simple_destroy(struct class_simple *cs ) ;
extern struct class_device *( /* format attribute */  class_simple_device_add)(struct class_simple *cs ,
                                                                               dev_t dev ,
                                                                               struct device *device ,
                                                                               char const   *fmt 
                                                                               , ...) ;
extern int class_simple_set_hotplug(struct class_simple * , int (*hotplug)(struct class_device *dev ,
                                                                           char **envp ,
                                                                           int num_envp ,
                                                                           char *buffer ,
                                                                           int buffer_size ) ) ;
extern void class_simple_device_remove(dev_t dev ) ;
__inline static struct device  __attribute__((__always_inline__)) *list_to_dev(struct list_head *node ) 
{ struct list_head  const  *__mptr ;

  {
  __mptr = (struct list_head  const  *)node;
  return ((struct device  __attribute__((__always_inline__)) *)((struct device *)((char *)__mptr -
                                                                                  (unsigned int )(& ((struct device *)0)->node))));
}
}
__inline static void __attribute__((__always_inline__))  *dev_get_drvdata(struct device *dev ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)dev->driver_data);
}
}
__inline static void __attribute__((__always_inline__))  dev_set_drvdata(struct device *dev ,
                                                                         void *data ) 
{ 

  {
  dev->driver_data = data;
  return;
}
}
extern int device_register(struct device *dev ) ;
extern void device_unregister(struct device *dev ) ;
extern void device_initialize(struct device *dev ) ;
extern int device_add(struct device *dev ) ;
extern void device_del(struct device *dev ) ;
extern int device_for_each_child(struct device * , void * , int (*fn)(struct device * ,
                                                                      void * ) ) ;
extern int driver_probe_device(struct device_driver *drv , struct device *dev ) ;
extern void device_bind_driver(struct device *dev ) ;
extern void device_release_driver(struct device *dev ) ;
extern int device_attach(struct device *dev ) ;
extern void driver_attach(struct device_driver *drv ) ;
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
extern int (*platform_notify)(struct device *dev ) ;
extern int (*platform_notify_remove)(struct device *dev ) ;
extern struct device *get_device(struct device *dev ) ;
extern void put_device(struct device *dev ) ;
extern struct device *device_find(char const   *name , struct bus_type *bus ) ;
extern int platform_device_register(struct platform_device * ) ;
extern void platform_device_unregister(struct platform_device * ) ;
extern struct bus_type platform_bus_type ;
extern struct device platform_bus ;
extern struct resource *platform_get_resource(struct platform_device * , unsigned int  ,
                                              unsigned int  ) ;
extern int platform_get_irq(struct platform_device * , unsigned int  ) ;
extern struct resource *platform_get_resource_byname(struct platform_device * , unsigned int  ,
                                                     char * ) ;
extern int platform_get_irq_byname(struct platform_device * , char * ) ;
extern int platform_add_devices(struct platform_device ** , int  ) ;
extern struct platform_device *platform_device_register_simple(char * , unsigned int  ,
                                                               struct resource * ,
                                                               unsigned int  ) ;
extern void device_shutdown(void) ;
extern int firmware_register(struct subsystem * ) ;
extern void firmware_unregister(struct subsystem * ) ;
extern struct pci_raw_ops *raw_pci_ops ;
extern struct bus_type pci_bus_type ;
extern struct list_head pci_root_buses ;
extern struct list_head pci_devices ;
extern void pcibios_fixup_bus(struct pci_bus * ) ;
extern int pcibios_enable_device(struct pci_dev * , int mask ) ;
extern char *pcibios_setup(char *str ) ;
extern void pcibios_align_resource(void * , struct resource * , unsigned long  , unsigned long  ) ;
extern void pcibios_update_irq(struct pci_dev * , int irq ) ;
extern struct pci_bus *pci_find_bus(int domain , int busnr ) ;
extern struct pci_bus *pci_scan_bus_parented(struct device *parent , int bus , struct pci_ops *ops ,
                                             void *sysdata ) ;
__inline static struct pci_bus  __attribute__((__always_inline__)) *pci_scan_bus(int bus ,
                                                                                 struct pci_ops *ops ,
                                                                                 void *sysdata ) 
{ struct pci_bus  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = (struct pci_bus  __attribute__((__always_inline__)) *)pci_scan_bus_parented((struct device *)((void *)0),
                                                                                    bus,
                                                                                    ops,
                                                                                    sysdata);
  return (tmp);
}
}
extern int pci_scan_slot(struct pci_bus *bus , int devfn ) ;
extern struct pci_dev *pci_scan_single_device(struct pci_bus *bus , int devfn ) ;
extern unsigned int pci_scan_child_bus(struct pci_bus *bus ) ;
extern void pci_bus_add_device(struct pci_dev *dev ) ;
extern void pci_bus_add_devices(struct pci_bus *bus ) ;
extern void pci_name_device(struct pci_dev *dev ) ;
extern char *pci_class_name(u32 class ) ;
extern void pci_read_bridge_bases(struct pci_bus *child ) ;
extern struct resource *pci_find_parent_resource(struct pci_dev  const  *dev , struct resource *res ) ;
extern int pci_get_interrupt_pin(struct pci_dev *dev , struct pci_dev **bridge ) ;
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
extern void pci_dev_put(struct pci_dev *dev ) ;
extern void pci_remove_bus(struct pci_bus *b ) ;
extern void pci_remove_bus_device(struct pci_dev *dev ) ;
extern struct pci_dev *pci_find_device(unsigned int vendor , unsigned int device ,
                                       struct pci_dev  const  *from ) ;
extern struct pci_dev *pci_find_device_reverse(unsigned int vendor , unsigned int device ,
                                               struct pci_dev  const  *from ) ;
extern struct pci_dev *pci_find_slot(unsigned int bus , unsigned int devfn ) ;
extern int pci_find_capability(struct pci_dev *dev , int cap ) ;
extern int pci_find_ext_capability(struct pci_dev *dev , int cap ) ;
extern struct pci_bus *pci_find_next_bus(struct pci_bus  const  *from ) ;
extern struct pci_dev *pci_get_device(unsigned int vendor , unsigned int device ,
                                      struct pci_dev *from ) ;
extern struct pci_dev *pci_get_subsys(unsigned int vendor , unsigned int device ,
                                      unsigned int ss_vendor , unsigned int ss_device ,
                                      struct pci_dev *from ) ;
extern struct pci_dev *pci_get_slot(struct pci_bus *bus , unsigned int devfn ) ;
extern struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
extern int pci_dev_present(struct pci_device_id  const  *ids ) ;
extern int pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u8 *val ) ;
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
__inline static int __attribute__((__always_inline__))  pci_read_config_byte(struct pci_dev *dev ,
                                                                             int where ,
                                                                             u8 *val ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )pci_bus_read_config_byte(dev->bus,
                                                                           dev->devfn,
                                                                           where,
                                                                           val);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pci_read_config_word(struct pci_dev *dev ,
                                                                             int where ,
                                                                             u16 *val ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )pci_bus_read_config_word(dev->bus,
                                                                           dev->devfn,
                                                                           where,
                                                                           val);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pci_read_config_dword(struct pci_dev *dev ,
                                                                              int where ,
                                                                              u32 *val ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )pci_bus_read_config_dword(dev->bus,
                                                                            dev->devfn,
                                                                            where,
                                                                            val);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pci_write_config_byte(struct pci_dev *dev ,
                                                                              int where ,
                                                                              u8 val ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )pci_bus_write_config_byte(dev->bus,
                                                                            dev->devfn,
                                                                            where,
                                                                            val);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pci_write_config_word(struct pci_dev *dev ,
                                                                              int where ,
                                                                              u16 val ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )pci_bus_write_config_word(dev->bus,
                                                                            dev->devfn,
                                                                            where,
                                                                            val);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pci_write_config_dword(struct pci_dev *dev ,
                                                                               int where ,
                                                                               u32 val ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )pci_bus_write_config_dword(dev->bus,
                                                                             dev->devfn,
                                                                             where,
                                                                             val);
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev *dev ) ;
extern int pci_enable_device_bars(struct pci_dev *dev , int mask ) ;
extern void pci_disable_device(struct pci_dev *dev ) ;
extern void pci_set_master(struct pci_dev *dev ) ;
extern int pci_set_mwi(struct pci_dev *dev ) ;
extern void pci_clear_mwi(struct pci_dev *dev ) ;
extern int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) ;
extern int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) ;
extern int pci_assign_resource(struct pci_dev *dev , int i ) ;
extern void *pci_map_rom(struct pci_dev *pdev , size_t *size ) ;
extern void *pci_map_rom_copy(struct pci_dev *pdev , size_t *size ) ;
extern void pci_unmap_rom(struct pci_dev *pdev , void *rom ) ;
extern void pci_remove_rom(struct pci_dev *pdev ) ;
extern int pci_save_state(struct pci_dev *dev ) ;
extern int pci_restore_state(struct pci_dev *dev ) ;
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
extern pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
extern int pci_enable_wake(struct pci_dev *dev , pci_power_t state , int enable ) ;
extern void pci_bus_assign_resources(struct pci_bus *bus ) ;
extern void pci_bus_size_bridges(struct pci_bus *bus ) ;
extern int pci_claim_resource(struct pci_dev * , int  ) ;
extern void pci_assign_unassigned_resources(void) ;
extern void pdev_enable_device(struct pci_dev * ) ;
extern void pdev_sort_resources(struct pci_dev * , struct resource_list * ) ;
extern void pci_fixup_irqs(u8 (*)(struct pci_dev * , u8 * ) , int (*)(struct pci_dev * ,
                                                                      u8  , u8  ) ) ;
extern int pci_request_regions(struct pci_dev * , char * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int pci_request_region(struct pci_dev * , int  , char * ) ;
extern void pci_release_region(struct pci_dev * , int  ) ;
extern int pci_bus_alloc_resource(struct pci_bus *bus , struct resource *res , unsigned long size ,
                                  unsigned long align , unsigned long min , unsigned int type_mask ,
                                  void (*alignf)(void * , struct resource * , unsigned long  ,
                                                 unsigned long  ) , void *alignf_data ) ;
extern void pci_enable_bridges(struct pci_bus *bus ) ;
extern int pci_register_driver(struct pci_driver * ) ;
extern void pci_unregister_driver(struct pci_driver * ) ;
extern void pci_remove_behind_bridge(struct pci_dev * ) ;
extern struct pci_driver *pci_dev_driver(struct pci_dev  const  * ) ;
extern struct pci_device_id  const  *pci_match_device(struct pci_device_id  const  *ids ,
                                                      struct pci_dev  const  *dev ) ;
extern int pci_scan_bridge(struct pci_bus *bus , struct pci_dev *dev , int max , int pass ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread8)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread16)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread16be)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread32)(void * ) ;
extern unsigned int ( __attribute__((__regparm__(3))) ioread32be)(void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite8)(u8  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite16)(u16  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite16be)(u16  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite32)(u32  , void * ) ;
extern void ( __attribute__((__regparm__(3))) iowrite32be)(u32  , void * ) ;
extern void ( __attribute__((__regparm__(3))) ioread8_rep)(void *port , void *buf ,
                                                           unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) ioread16_rep)(void *port , void *buf ,
                                                            unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) ioread32_rep)(void *port , void *buf ,
                                                            unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) iowrite8_rep)(void *port , void const   *buf ,
                                                            unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) iowrite16_rep)(void *port , void const   *buf ,
                                                             unsigned long count ) ;
extern void ( __attribute__((__regparm__(3))) iowrite32_rep)(void *port , void const   *buf ,
                                                             unsigned long count ) ;
extern void *ioport_map(unsigned long port , unsigned int nr ) ;
extern void ioport_unmap(void * ) ;
extern void *pci_iomap(struct pci_dev *dev , int bar , unsigned long max ) ;
extern void pci_iounmap(struct pci_dev *dev , void * ) ;
extern void *vmalloc(unsigned long size ) ;
extern void *vmalloc_exec(unsigned long size ) ;
extern void *vmalloc_32(unsigned long size ) ;
extern void *__vmalloc(unsigned long size , unsigned int gfp_mask , pgprot_t prot ) ;
extern void *__vmalloc_area(struct vm_struct *area , unsigned int gfp_mask , pgprot_t prot ) ;
extern void vfree(void *addr ) ;
extern void *vmap(struct page **pages , unsigned int count , unsigned long flags ,
                  pgprot_t prot ) ;
extern void vunmap(void *addr ) ;
extern struct vm_struct *get_vm_area(unsigned long size , unsigned long flags ) ;
extern struct vm_struct *__get_vm_area(unsigned long size , unsigned long flags ,
                                       unsigned long start , unsigned long end ) ;
extern struct vm_struct *remove_vm_area(void *addr ) ;
extern struct vm_struct *__remove_vm_area(void *addr ) ;
extern int map_vm_area(struct vm_struct *area , pgprot_t prot , struct page ***pages ) ;
extern void unmap_vm_area(struct vm_struct *area ) ;
extern rwlock_t vmlist_lock ;
extern struct vm_struct *vmlist ;
__inline static unsigned long __attribute__((__always_inline__))  virt_to_phys(void volatile   *address ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((unsigned long )address -
                                                               3221225472UL));
}
}
__inline static void __attribute__((__always_inline__))  *phys_to_virt(unsigned long address ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((void *)(address + 3221225472UL)));
}
}
extern void *__ioremap(unsigned long offset , unsigned long size , unsigned long flags ) ;
__inline static void __attribute__((__always_inline__))  *ioremap(unsigned long offset ,
                                                                  unsigned long size ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = (void __attribute__((__always_inline__))  *)__ioremap(offset, size, 0UL);
  return (tmp);
}
}
extern void *ioremap_nocache(unsigned long offset , unsigned long size ) ;
extern void iounmap(void volatile   *addr ) ;
extern void *bt_ioremap(unsigned long offset , unsigned long size ) ;
extern void bt_iounmap(void *addr , unsigned long size ) ;
__inline static unsigned char __attribute__((__always_inline__))  readb(void const volatile   *addr ) 
{ 

  {
  return ((unsigned char __attribute__((__always_inline__))  )(*((unsigned char volatile   *)addr)));
}
}
__inline static unsigned short __attribute__((__always_inline__))  readw(void const volatile   *addr ) 
{ 

  {
  return ((unsigned short __attribute__((__always_inline__))  )(*((unsigned short volatile   *)addr)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  readl(void const volatile   *addr ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(*((unsigned int volatile   *)addr)));
}
}
__inline static void __attribute__((__always_inline__))  writeb(unsigned char b ,
                                                                void volatile   *addr ) 
{ 

  {
  (*((unsigned char volatile   *)addr)) = (unsigned char volatile   )b;
  return;
}
}
__inline static void __attribute__((__always_inline__))  writew(unsigned short b ,
                                                                void volatile   *addr ) 
{ 

  {
  (*((unsigned short volatile   *)addr)) = (unsigned short volatile   )b;
  return;
}
}
__inline static void __attribute__((__always_inline__))  writel(unsigned int b , void volatile   *addr ) 
{ 

  {
  (*((unsigned int volatile   *)addr)) = (unsigned int volatile   )b;
  return;
}
}
__inline static void __attribute__((__always_inline__))  memset_io(void volatile   *addr ,
                                                                   unsigned char val ,
                                                                   int count ) 
{ 

  {
  __memset_generic((void *)addr, (char )val, (unsigned int )count);
  return;
}
}
__inline static void __attribute__((__always_inline__))  memcpy_fromio(void *dst ,
                                                                       void const volatile   *src ,
                                                                       int count ) 
{ 

  {
  __memcpy(dst, (void const   *)((void *)src), (unsigned int )count);
  return;
}
}
__inline static void __attribute__((__always_inline__))  memcpy_toio(void volatile   *dst ,
                                                                     void const   *src ,
                                                                     int count ) 
{ 

  {
  __memcpy((void *)dst, src, (unsigned int )count);
  return;
}
}
__inline static int __attribute__((__always_inline__))  check_signature(void volatile   *io_addr ,
                                                                        unsigned char const   *signature ,
                                                                        int length ) 
{ int retval ;
  unsigned char __attribute__((__always_inline__))  tmp ;

  {
  retval = 0;
  while (1) {
    tmp = readb((void const volatile   *)io_addr);
    if ((int __attribute__((__always_inline__))  )tmp != (int __attribute__((__always_inline__))  )(*signature)) {
      goto out;
    }
    io_addr ++;
    signature ++;
    length --;
    if (! length) {
      break;
    }
  }
  retval = 1;
  out: 
  return ((int __attribute__((__always_inline__))  )retval);
}
}
__inline static void __attribute__((__always_inline__))  flush_write_buffers(void) 
{ 

  {
  __asm__  volatile   ("lock; addl $0,0(%%esp)": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  slow_down_io(void) 
{ 

  {
  __asm__  volatile   ("outb %%al,$0x80;":);
}
}
__inline static void __attribute__((__always_inline__))  outb_local(unsigned char value ,
                                                                    int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb_local(int port ) 
{ unsigned char value ;

  {
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  return ((unsigned char __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outb_local_p(unsigned char value ,
                                                                      int port ) 
{ 

  {
  outb_local(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb_local_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  tmp = (unsigned char )inb_local(port);
  value = tmp;
  slow_down_io();
  return ((unsigned char __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outb(unsigned char value ,
                                                              int port ) 
{ 

  {
  outb_local(value, port);
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb(int port ) 
{ unsigned char __attribute__((__always_inline__))  tmp ;

  {
  tmp = inb_local(port);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  outb_p(unsigned char value ,
                                                                int port ) 
{ 

  {
  outb(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  inb_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  tmp = (unsigned char )inb(port);
  value = tmp;
  slow_down_io();
  return ((unsigned char __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outsb(int port , void const   *addr ,
                                                               unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  insb(int port , void *addr ,
                                                              unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  outw_local(unsigned short value ,
                                                                    int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw_local(int port ) 
{ unsigned short value ;

  {
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  return ((unsigned short __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outw_local_p(unsigned short value ,
                                                                      int port ) 
{ 

  {
  outw_local(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw_local_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  tmp = (unsigned short )inw_local(port);
  value = tmp;
  slow_down_io();
  return ((unsigned short __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outw(unsigned short value ,
                                                              int port ) 
{ 

  {
  outw_local(value, port);
  return;
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw(int port ) 
{ unsigned short __attribute__((__always_inline__))  tmp ;

  {
  tmp = inw_local(port);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  outw_p(unsigned short value ,
                                                                int port ) 
{ 

  {
  outw(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned short __attribute__((__always_inline__))  inw_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  tmp = (unsigned short )inw(port);
  value = tmp;
  slow_down_io();
  return ((unsigned short __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outsw(int port , void const   *addr ,
                                                               unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  insw(int port , void *addr ,
                                                              unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  outl_local(unsigned int value ,
                                                                    int port ) 
{ 

  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl_local(int port ) 
{ unsigned int value ;

  {
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  return ((unsigned int __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outl_local_p(unsigned int value ,
                                                                      int port ) 
{ 

  {
  outl_local(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl_local_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  tmp = (unsigned int )inl_local(port);
  value = tmp;
  slow_down_io();
  return ((unsigned int __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outl(unsigned int value ,
                                                              int port ) 
{ 

  {
  outl_local(value, port);
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl(int port ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = inl_local(port);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  outl_p(unsigned int value ,
                                                                int port ) 
{ 

  {
  outl(value, port);
  slow_down_io();
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  inl_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  tmp = (unsigned int )inl(port);
  value = tmp;
  slow_down_io();
  return ((unsigned int __attribute__((__always_inline__))  )value);
}
}
__inline static void __attribute__((__always_inline__))  outsl(int port , void const   *addr ,
                                                               unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; outs"
                       "l": "+S" (addr), "+c" (count): "d" (port));
}
}
__inline static void __attribute__((__always_inline__))  insl(int port , void *addr ,
                                                              unsigned long count ) 
{ 

  {
  __asm__  volatile   ("rep; ins"
                       "l": "+D" (addr), "+c" (count): "d" (port));
}
}
extern struct dma_pool *dma_pool_create(char const   *name , struct device *dev ,
                                        size_t size , size_t align , size_t allocation ) ;
extern void dma_pool_destroy(struct dma_pool *pool ) ;
extern void *dma_pool_alloc(struct dma_pool *pool , int mem_flags , dma_addr_t *handle ) ;
extern void dma_pool_free(struct dma_pool *pool , void *vaddr , dma_addr_t addr ) ;
extern struct pci_dev *isa_bridge ;
__inline static void __attribute__((__always_inline__))  pci_scan_msi_device(struct pci_dev *dev ) 
{ 

  {
  return;
}
}
__inline static int __attribute__((__always_inline__))  pci_enable_msi(struct pci_dev *dev ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )-1);
}
}
__inline static int __attribute__((__always_inline__))  pci_enable_msix(struct pci_dev *dev ,
                                                                        struct msix_entry *entries ,
                                                                        int nvec ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )-1);
}
}
__inline static void __attribute__((__always_inline__))  prio_tree_iter_init(struct prio_tree_iter *iter ,
                                                                             struct prio_tree_root *root ,
                                                                             unsigned long r_index ,
                                                                             unsigned long h_index ) 
{ 

  {
  iter->root = root;
  iter->r_index = r_index;
  iter->h_index = h_index;
  iter->cur = (struct prio_tree_node *)((void *)0);
  return;
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_empty(struct prio_tree_root  const  *root ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )root->prio_tree_node ==
                                                     (unsigned int )((void *)0)));
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_root(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )node->parent ==
                                                     (unsigned int )node));
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_left_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )node->left ==
                                                     (unsigned int )node));
}
}
__inline static int __attribute__((__always_inline__))  prio_tree_right_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )node->right ==
                                                     (unsigned int )node));
}
}
extern struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root , struct prio_tree_node *old ,
                                                struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern void prio_tree_remove(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter ) ;
extern unsigned int __invalid_size_argument_for_IOC ;
extern struct files_stat_struct files_stat ;
extern struct inodes_stat_t inodes_stat ;
extern int leases_enable ;
extern int lease_break_time ;
extern int dir_notify_enable ;
__inline static int __attribute__((__always_inline__))  old_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < 256U) {
    if ((dev & 1048575U) < 256U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static u16 __attribute__((__always_inline__))  old_encode_dev(dev_t dev ) 
{ 

  {
  return ((unsigned short )(((dev >> 20) << 8) | (dev & 1048575U)));
}
}
__inline static dev_t __attribute__((__always_inline__))  old_decode_dev(u16 val ) 
{ 

  {
  return ((unsigned int )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
__inline static int __attribute__((__always_inline__))  new_valid_dev(dev_t dev ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static u32 __attribute__((__always_inline__))  new_encode_dev(dev_t dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  major = dev >> 20;
  minor = dev & 1048575U;
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
__inline static dev_t __attribute__((__always_inline__))  new_decode_dev(u32 dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  major = (dev & 1048320U) >> 8;
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  return ((major << 20) | minor);
}
}
__inline static u64 __attribute__((__always_inline__))  huge_encode_dev(dev_t dev ) 
{ u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = (u64 __attribute__((__always_inline__))  )new_encode_dev(dev);
  return (tmp);
}
}
__inline static dev_t __attribute__((__always_inline__))  huge_decode_dev(u64 dev ) 
{ dev_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = new_decode_dev((unsigned int )dev);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  sysv_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < 16384U) {
    if ((dev & 1048575U) < 262144U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static u32 __attribute__((__always_inline__))  sysv_encode_dev(dev_t dev ) 
{ 

  {
  return ((dev & 1048575U) | ((dev >> 20) << 18));
}
}
__inline static unsigned int __attribute__((__always_inline__))  sysv_major(u32 dev ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )((dev >> 18) & 16383U));
}
}
__inline static unsigned int __attribute__((__always_inline__))  sysv_minor(u32 dev ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(dev & 262143U));
}
}
__inline static int __attribute__((__always_inline__))  rcu_batch_before(long a ,
                                                                         long b ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(a - b < 0L));
}
}
__inline static int __attribute__((__always_inline__))  rcu_batch_after(long a , long b ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(a - b > 0L));
}
}
extern struct rcu_data per_cpu__rcu_data ;
extern struct rcu_data per_cpu__rcu_bh_data ;
extern struct rcu_ctrlblk rcu_ctrlblk ;
extern struct rcu_ctrlblk rcu_bh_ctrlblk ;
__inline static void __attribute__((__always_inline__))  rcu_qsctr_inc(int cpu ) 
{ struct rcu_data *rdp ;
  unsigned long __ptr ;

  {
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__rcu_data));
  rdp = (struct rcu_data *)(__ptr + __per_cpu_offset[cpu]);
  rdp->passed_quiesc = 1;
}
}
__inline static void __attribute__((__always_inline__))  rcu_bh_qsctr_inc(int cpu ) 
{ struct rcu_data *rdp ;
  unsigned long __ptr ;

  {
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__rcu_bh_data));
  rdp = (struct rcu_data *)(__ptr + __per_cpu_offset[cpu]);
  rdp->passed_quiesc = 1;
}
}
__inline static int __attribute__((__always_inline__))  __rcu_pending(struct rcu_ctrlblk *rcp ,
                                                                      struct rcu_data *rdp ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (rdp->curlist) {
    tmp = rcu_batch_before(rcp->completed, rdp->batch);
    if (! tmp) {
      return ((int __attribute__((__always_inline__))  )1);
    }
  }
  if (! rdp->curlist) {
    if (rdp->nxtlist) {
      return ((int __attribute__((__always_inline__))  )1);
    }
  }
  if (rdp->donelist) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  if (rdp->quiescbatch != rcp->cur) {
    return ((int __attribute__((__always_inline__))  )1);
  } else {
    if (rdp->qs_pending) {
      return ((int __attribute__((__always_inline__))  )1);
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  rcu_pending(int cpu ) 
{ unsigned long __ptr ;
  int __attribute__((__always_inline__))  tmp ;
  unsigned long __ptr___0 ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__rcu_data));
  tmp = __rcu_pending(& rcu_ctrlblk, (struct rcu_data *)(__ptr + __per_cpu_offset[cpu]));
  if (tmp) {
    tmp___1 = 1;
  } else {
    __asm__  ("": "=g" (__ptr___0): "0" (& per_cpu__rcu_bh_data));
    tmp___0 = __rcu_pending(& rcu_bh_ctrlblk, (struct rcu_data *)(__ptr___0 + __per_cpu_offset[cpu]));
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
extern void rcu_init(void) ;
extern void rcu_check_callbacks(int cpu , int user ) ;
extern void rcu_restart_cpu(int cpu ) ;
extern void ( __attribute__((__regparm__(3))) call_rcu)(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
extern void ( __attribute__((__regparm__(3))) call_rcu_bh)(struct rcu_head *head ,
                                                           void (*func)(struct rcu_head *head ) ) ;
extern void __attribute__((__deprecated__))  synchronize_kernel(void) ;
extern void synchronize_rcu(void) ;
extern void synchronize_idle(void) ;
extern struct dentry_stat_t dentry_stat ;
__inline static unsigned long __attribute__((__always_inline__))  partial_name_hash(unsigned long c ,
                                                                                    unsigned long prevhash ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )(((prevhash + (c <<
                                                                             4)) +
                                                                (c >> 4)) * 11UL));
}
}
__inline static unsigned long __attribute__((__always_inline__))  end_name_hash(unsigned long hash ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((unsigned int )hash));
}
}
__inline static unsigned int __attribute__((__always_inline__))  full_name_hash(unsigned char const   *name ,
                                                                                unsigned int len ) 
{ unsigned long hash ;
  unsigned char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned int __attribute__((__always_inline__))  tmp___1 ;

  {
  hash = 0UL;
  while (1) {
    tmp___0 = len;
    len --;
    if (! tmp___0) {
      break;
    }
    tmp = name;
    name ++;
    hash = (unsigned long )partial_name_hash((unsigned long )(*tmp), hash);
  }
  tmp___1 = (unsigned int __attribute__((__always_inline__))  )end_name_hash(hash);
  return (tmp___1);
}
}
extern spinlock_t dcache_lock ;
__inline static void __attribute__((__always_inline__))  __d_drop(struct dentry *dentry ) 
{ 

  {
  if (! (dentry->d_flags & 16U)) {
    dentry->d_flags |= 16U;
    hlist_del_rcu(& dentry->d_hash);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  d_drop(struct dentry *dentry ) 
{ 

  {
  _spin_lock(& dcache_lock);
  _spin_lock(& dentry->d_lock);
  __d_drop(dentry);
  _spin_unlock(& dentry->d_lock);
  _spin_unlock(& dcache_lock);
  return;
}
}
__inline static int __attribute__((__always_inline__))  dname_external(struct dentry *dentry ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )dentry->d_name.name !=
                                                     (unsigned int )(dentry->d_iname)));
}
}
extern void d_instantiate(struct dentry * , struct inode * ) ;
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
extern void d_delete(struct dentry * ) ;
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
extern struct dentry *d_alloc_anon(struct inode * ) ;
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
extern void shrink_dcache_sb(struct super_block * ) ;
extern void shrink_dcache_parent(struct dentry * ) ;
extern void shrink_dcache_anon(struct hlist_head * ) ;
extern int d_invalidate(struct dentry * ) ;
extern struct dentry *d_alloc_root(struct inode * ) ;
extern void d_genocide(struct dentry * ) ;
extern struct dentry *d_find_alias(struct inode * ) ;
extern void d_prune_aliases(struct inode * ) ;
extern int have_submounts(struct dentry * ) ;
extern void d_rehash(struct dentry * ) ;
__inline static void __attribute__((__always_inline__))  d_add(struct dentry *entry ,
                                                               struct inode *inode ) 
{ 

  {
  d_instantiate(entry, inode);
  d_rehash(entry);
  return;
}
}
__inline static struct dentry  __attribute__((__always_inline__)) *d_add_unique(struct dentry *entry ,
                                                                                struct inode *inode ) 
{ struct dentry *res ;
  struct dentry *tmp ;

  {
  res = d_instantiate_unique(entry, inode);
  if ((unsigned int )res != (unsigned int )((void *)0)) {
    tmp = res;
  } else {
    tmp = entry;
  }
  d_rehash(tmp);
  return ((struct dentry  __attribute__((__always_inline__)) *)res);
}
}
extern void d_move(struct dentry * , struct dentry * ) ;
extern struct dentry *d_lookup(struct dentry * , struct qstr * ) ;
extern struct dentry *__d_lookup(struct dentry * , struct qstr * ) ;
extern int d_validate(struct dentry * , struct dentry * ) ;
extern char *d_path(struct dentry * , struct vfsmount * , char * , int  ) ;
__inline static struct dentry  __attribute__((__always_inline__)) *dget(struct dentry *dentry ) 
{ long tmp ;

  {
  if (dentry) {
    while (1) {
      tmp = __builtin_expect((long )(! (! ((! dentry->d_count.counter != 0) != 0)) !=
                                     0), 0L);
      if (tmp) {
        __asm__  volatile   ("ud2\n"
                             "\t.word %c0\n"
                             "\t.long %c1\n": : "i" (294), "i" ("include/linux/dcache.h"));
      }
      break;
    }
    atomic_inc(& dentry->d_count);
  }
  return ((struct dentry  __attribute__((__always_inline__)) *)dentry);
}
}
extern struct dentry *dget_locked(struct dentry * ) ;
__inline static int __attribute__((__always_inline__))  d_unhashed(struct dentry *dentry ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(dentry->d_flags & 16U));
}
}
__inline static struct dentry  __attribute__((__always_inline__)) *dget_parent(struct dentry *dentry ) 
{ struct dentry *ret ;

  {
  _spin_lock(& dentry->d_lock);
  ret = (struct dentry *)dget(dentry->d_parent);
  _spin_unlock(& dentry->d_lock);
  return ((struct dentry  __attribute__((__always_inline__)) *)ret);
}
}
extern void dput(struct dentry * ) ;
__inline static int __attribute__((__always_inline__))  d_mountpoint(struct dentry *dentry ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )dentry->d_mounted);
}
}
extern struct vfsmount *lookup_mnt(struct vfsmount * , struct dentry * ) ;
extern struct dentry *lookup_create(struct nameidata *nd , int is_dir ) ;
extern int sysctl_vfs_cache_pressure ;
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
extern int radix_tree_preload(int gfp_mask ) ;
extern void radix_tree_init(void) ;
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                int tag ) ;
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  int tag ) ;
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              int tag ) ;
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               int tag ) ;
extern int radix_tree_tagged(struct radix_tree_root *root , int tag ) ;
__inline static void __attribute__((__always_inline__))  radix_tree_preload_end(void) 
{ 

  {
  while (1) {
    break;
  }
  return;
}
}
extern void update_atime(struct inode * ) ;
extern void inode_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern void inode_init_early(void)  __attribute__((__section__(".init.text"))) ;
extern void mnt_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern void files_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern spinlock_t dq_data_lock ;
extern void mark_info_dirty(struct super_block *sb , int type ) ;
extern struct dqstats dqstats ;
extern int mark_dquot_dirty(struct dquot *dquot ) ;
extern int register_quota_format(struct quota_format_type *fmt ) ;
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
__inline static int __attribute__((__always_inline__))  mapping_mapped(struct address_space *mapping ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = prio_tree_empty((struct prio_tree_root  const  *)(& mapping->i_mmap));
  if (tmp) {
    tmp___0 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  mapping_writably_mapped(struct address_space *mapping ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(mapping->i_mmap_writable != 0U));
}
}
__inline static loff_t __attribute__((__always_inline__))  i_size_read(struct inode *inode ) 
{ loff_t i_size ;
  unsigned int seq ;
  int __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    seq = (unsigned int )read_seqcount_begin((seqcount_t const   *)(& inode->i_size_seqcount));
    i_size = inode->i_size;
    tmp = read_seqcount_retry((seqcount_t const   *)(& inode->i_size_seqcount), seq);
    if (! tmp) {
      break;
    }
  }
  return (i_size);
}
}
__inline static void __attribute__((__always_inline__))  i_size_write(struct inode *inode ,
                                                                      loff_t i_size ) 
{ 

  {
  write_seqcount_begin(& inode->i_size_seqcount);
  inode->i_size = i_size;
  write_seqcount_end(& inode->i_size_seqcount);
  return;
}
}
__inline static unsigned int __attribute__((__always_inline__))  iminor(struct inode *inode ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(inode->i_rdev & 1048575U));
}
}
__inline static unsigned int __attribute__((__always_inline__))  imajor(struct inode *inode ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(inode->i_rdev >> 20));
}
}
extern struct block_device *I_BDEV(struct inode *inode ) ;
extern spinlock_t files_lock ;
__inline static int __attribute__((__always_inline__))  nfs_compare_fh(struct nfs_fh  const  *a ,
                                                                       struct nfs_fh  const  *b ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((int const   )a->size != (int const   )b->size) {
    tmp___0 = 1;
  } else {
    tmp = __builtin_memcmp((void const   *)(a->data), (void const   *)(b->data), (unsigned int )a->size);
    if (tmp != 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  nfs_copy_fh(struct nfs_fh *target ,
                                                                     struct nfs_fh  const  *source ) 
{ 

  {
  target->size = (unsigned short )source->size;
  __memcpy((void *)(target->data), (void const   *)(source->data), (unsigned int )source->size);
  return;
}
}
extern struct list_head file_lock_list ;
extern int fcntl_getlk(struct file * , struct flock * ) ;
extern int fcntl_setlk(struct file * , unsigned int  , struct flock * ) ;
extern int fcntl_getlk64(struct file * , struct flock64 * ) ;
extern int fcntl_setlk64(struct file * , unsigned int  , struct flock64 * ) ;
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
extern int fcntl_getlease(struct file *filp ) ;
extern void locks_init_lock(struct file_lock * ) ;
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
extern void locks_remove_flock(struct file * ) ;
extern struct file_lock *posix_test_lock(struct file * , struct file_lock * ) ;
extern int posix_lock_file(struct file * , struct file_lock * ) ;
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
extern void posix_block_lock(struct file_lock * , struct file_lock * ) ;
extern void posix_unblock_lock(struct file * , struct file_lock * ) ;
extern int posix_locks_deadlock(struct file_lock * , struct file_lock * ) ;
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
extern int __break_lease(struct inode *inode , unsigned int flags ) ;
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
extern int setlease(struct file * , long  , struct file_lock ** ) ;
extern int lease_modify(struct file_lock ** , int  ) ;
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
extern void steal_locks(fl_owner_t from ) ;
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
extern void __kill_fasync(struct fasync_struct * , int  , int  ) ;
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
extern void f_delown(struct file *filp ) ;
extern int send_sigurg(struct fown_struct *fown ) ;
extern struct list_head super_blocks ;
extern spinlock_t sb_lock ;
extern struct timespec current_fs_time(struct super_block *sb ) ;
__inline static void __attribute__((__always_inline__))  lock_super(struct super_block *sb ) 
{ 

  {
  down(& sb->s_lock);
  return;
}
}
__inline static void __attribute__((__always_inline__))  unlock_super(struct super_block *sb ) 
{ 

  {
  up(& sb->s_lock);
  return;
}
}
extern int vfs_create(struct inode * , struct dentry * , int  , struct nameidata * ) ;
extern int vfs_mkdir(struct inode * , struct dentry * , int  ) ;
extern int vfs_mknod(struct inode * , struct dentry * , int  , dev_t  ) ;
extern int vfs_symlink(struct inode * , struct dentry * , char const   * , int  ) ;
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
extern int vfs_unlink(struct inode * , struct dentry * ) ;
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern void dentry_unhash(struct dentry *dentry ) ;
extern int generic_osync_inode(struct inode * , struct address_space * , int  ) ;
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
extern void __mark_inode_dirty(struct inode * , int  ) ;
__inline static void __attribute__((__always_inline__))  mark_inode_dirty(struct inode *inode ) 
{ 

  {
  __mark_inode_dirty(inode, 7);
  return;
}
}
__inline static void __attribute__((__always_inline__))  mark_inode_dirty_sync(struct inode *inode ) 
{ 

  {
  __mark_inode_dirty(inode, 1);
  return;
}
}
__inline static void __attribute__((__always_inline__))  touch_atime(struct vfsmount *mnt ,
                                                                     struct dentry *dentry ) 
{ 

  {
  update_atime(dentry->d_inode);
  return;
}
}
__inline static void __attribute__((__always_inline__))  file_accessed(struct file *file ) 
{ 

  {
  if (! (file->f_flags & 262144U)) {
    touch_atime(file->f_vfsmnt, file->f_dentry);
  }
  return;
}
}
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
extern struct dentry *find_exported_dentry(struct super_block *sb , void *obj , void *parent ,
                                           int (*acceptable)(void *context , struct dentry *de ) ,
                                           void *context ) ;
extern struct super_block *get_sb_bdev(struct file_system_type *fs_type , int flags ,
                                       char const   *dev_name , void *data , int (*fill_super)(struct super_block * ,
                                                                                               void * ,
                                                                                               int  ) ) ;
extern struct super_block *get_sb_single(struct file_system_type *fs_type , int flags ,
                                         void *data , int (*fill_super)(struct super_block * ,
                                                                        void * , int  ) ) ;
extern struct super_block *get_sb_nodev(struct file_system_type *fs_type , int flags ,
                                        void *data , int (*fill_super)(struct super_block * ,
                                                                       void * , int  ) ) ;
extern void generic_shutdown_super(struct super_block *sb ) ;
extern void kill_block_super(struct super_block *sb ) ;
extern void kill_anon_super(struct super_block *sb ) ;
extern void kill_litter_super(struct super_block *sb ) ;
extern void deactivate_super(struct super_block *sb ) ;
extern int set_anon_super(struct super_block *s , void *data ) ;
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , void *data ) ;
extern struct super_block *get_sb_pseudo(struct file_system_type * , char * , struct super_operations *ops ,
                                         unsigned long  ) ;
extern int __put_super(struct super_block *sb ) ;
extern int __put_super_and_need_restart(struct super_block *sb ) ;
extern void unnamed_dev_init(void) ;
extern int register_filesystem(struct file_system_type * ) ;
extern int unregister_filesystem(struct file_system_type * ) ;
extern struct vfsmount *kern_mount(struct file_system_type * ) ;
extern int may_umount_tree(struct vfsmount * ) ;
extern int may_umount(struct vfsmount * ) ;
extern long do_mount(char * , char * , char * , unsigned long  , void * ) ;
extern int vfs_statfs(struct super_block * , struct kstatfs * ) ;
extern int locks_mandatory_locked(struct inode * ) ;
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
__inline static int __attribute__((__always_inline__))  locks_verify_locked(struct inode *inode ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if ((inode->i_sb)->s_flags & 64UL) {
    if (((int )inode->i_mode & 1032) == 1024) {
      tmp = (int __attribute__((__always_inline__))  )locks_mandatory_locked(inode);
      return (tmp);
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int rw_verify_area(int  , struct file * , loff_t * , size_t  ) ;
__inline static int __attribute__((__always_inline__))  locks_verify_truncate(struct inode *inode ,
                                                                              struct file *filp ,
                                                                              loff_t size ) 
{ loff_t tmp ;
  loff_t tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  if (inode->i_flock) {
    if ((inode->i_sb)->s_flags & 64UL) {
      if (((int )inode->i_mode & 1032) == 1024) {
        if (size < inode->i_size) {
          tmp = inode->i_size - size;
        } else {
          tmp = size - inode->i_size;
        }
        if (size < inode->i_size) {
          tmp___0 = size;
        } else {
          tmp___0 = inode->i_size;
        }
        tmp___1 = (int __attribute__((__always_inline__))  )locks_mandatory_area(2,
                                                                                 inode,
                                                                                 filp,
                                                                                 tmp___0,
                                                                                 (unsigned int )tmp);
        return (tmp___1);
      }
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  break_lease(struct inode *inode ,
                                                                    unsigned int mode ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (inode->i_flock) {
    tmp = (int __attribute__((__always_inline__))  )__break_lease(inode, mode);
    return (tmp);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int do_truncate(struct dentry * , loff_t start ) ;
extern struct file *filp_open(char const   * , int  , int  ) ;
extern struct file *dentry_open(struct dentry * , struct vfsmount * , int  ) ;
extern int filp_close(struct file * , fl_owner_t id ) ;
extern char *getname(char const   * ) ;
extern void vfs_caches_init_early(void)  __attribute__((__section__(".init.text"))) ;
extern void vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"))) ;
extern int register_blkdev(unsigned int  , char const   * ) ;
extern int unregister_blkdev(unsigned int  , char const   * ) ;
extern struct block_device *bdget(dev_t  ) ;
extern void bd_set_size(struct block_device * , loff_t size ) ;
extern void bd_forget(struct inode *inode ) ;
extern void bdput(struct block_device * ) ;
extern struct block_device *open_by_devnum(dev_t  , unsigned int  ) ;
extern struct file_operations def_blk_fops ;
extern struct address_space_operations def_blk_aops ;
extern struct file_operations def_chr_fops ;
extern struct file_operations bad_sock_fops ;
extern struct file_operations def_fifo_fops ;
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
extern int blkdev_ioctl(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
extern int blkdev_get(struct block_device * , mode_t  , unsigned int  ) ;
extern int blkdev_put(struct block_device * ) ;
extern int bd_claim(struct block_device * , void * ) ;
extern void bd_release(struct block_device * ) ;
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
extern int register_chrdev(unsigned int  , char const   * , struct file_operations * ) ;
extern int unregister_chrdev(unsigned int  , char const   * ) ;
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
extern int chrdev_open(struct inode * , struct file * ) ;
extern char const   *__bdevname(dev_t  , char *buffer ) ;
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
extern struct block_device *lookup_bdev(char const   * ) ;
extern struct block_device *open_bdev_excl(char const   * , int  , void * ) ;
extern void close_bdev_excl(struct block_device * ) ;
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
extern void make_bad_inode(struct inode * ) ;
extern int is_bad_inode(struct inode * ) ;
extern struct file_operations read_fifo_fops ;
extern struct file_operations write_fifo_fops ;
extern struct file_operations rdwr_fifo_fops ;
extern struct file_operations read_pipe_fops ;
extern struct file_operations write_pipe_fops ;
extern struct file_operations rdwr_pipe_fops ;
extern int fs_may_remount_ro(struct super_block * ) ;
extern int check_disk_change(struct block_device * ) ;
extern int invalidate_inodes(struct super_block * ) ;
extern int __invalidate_device(struct block_device * ) ;
extern int invalidate_partition(struct gendisk * , int  ) ;
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
extern unsigned long invalidate_inode_pages(struct address_space *mapping ) ;
__inline static void __attribute__((__always_inline__))  invalidate_remote_inode(struct inode *inode ) 
{ 

  {
  if (((int )inode->i_mode & 61440) == 32768) {
    invalidate_inode_pages(inode->i_mapping);
  } else {
    if (((int )inode->i_mode & 61440) == 16384) {
      invalidate_inode_pages(inode->i_mapping);
    } else {
      if (((int )inode->i_mode & 61440) == 40960) {
        invalidate_inode_pages(inode->i_mapping);
      }
    }
  }
  return;
}
}
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
extern int write_inode_now(struct inode * , int  ) ;
extern int filemap_fdatawrite(struct address_space * ) ;
extern int filemap_flush(struct address_space * ) ;
extern int filemap_fdatawait(struct address_space * ) ;
extern int filemap_write_and_wait(struct address_space *mapping ) ;
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
extern void sync_supers(void) ;
extern void sync_filesystems(int wait ) ;
extern void emergency_sync(void) ;
extern void emergency_remount(void) ;
extern int do_remount_sb(struct super_block *sb , int flags , void *data , int force ) ;
extern sector_t bmap(struct inode * , sector_t  ) ;
extern int setattr_mask(unsigned int  ) ;
extern int notify_change(struct dentry * , struct iattr * ) ;
extern int permission(struct inode * , int  , struct nameidata * ) ;
extern int generic_permission(struct inode * , int  , int (*check_acl)(struct inode * ,
                                                                       int  ) ) ;
extern int get_write_access(struct inode * ) ;
extern int deny_write_access(struct file * ) ;
__inline static void __attribute__((__always_inline__))  put_write_access(struct inode *inode ) 
{ 

  {
  atomic_dec(& inode->i_writecount);
  return;
}
}
__inline static void __attribute__((__always_inline__))  allow_write_access(struct file *file ) 
{ 

  {
  if (file) {
    atomic_inc(& ((file->f_dentry)->d_inode)->i_writecount);
  }
  return;
}
}
extern int do_pipe(int * ) ;
extern int open_namei(char const   * , int  , int  , struct nameidata * ) ;
extern int may_open(struct nameidata * , int  , int  ) ;
extern int kernel_read(struct file * , unsigned long  , char * , unsigned long  ) ;
extern struct file *open_exec(char const   * ) ;
extern int is_subdir(struct dentry * , struct dentry * ) ;
extern ino_t find_inode_number(struct dentry * , struct qstr * ) ;
__inline static void __attribute__((__always_inline__))  *ERR_PTR(long error ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((void *)error));
}
}
__inline static long __attribute__((__always_inline__))  PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long __attribute__((__always_inline__))  )((long )ptr));
}
}
__inline static long __attribute__((__always_inline__))  IS_ERR(void const   *ptr ) 
{ long __attribute__((__always_inline__))  tmp ;

  {
  tmp = (long __attribute__((__always_inline__))  )__builtin_expect((long )(! (! ((unsigned long )ptr >
                                                                                  4294966296UL)) !=
                                                                            0), 0L);
  return (tmp);
}
}
extern loff_t default_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t vfs_llseek(struct file *file , loff_t offset , int origin ) ;
extern void inode_init_once(struct inode * ) ;
extern void iput(struct inode * ) ;
extern struct inode *igrab(struct inode * ) ;
extern ino_t iunique(struct super_block * , ino_t  ) ;
extern int inode_needs_sync(struct inode *inode ) ;
extern void generic_delete_inode(struct inode *inode ) ;
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
extern void unlock_new_inode(struct inode * ) ;
__inline static struct inode  __attribute__((__always_inline__)) *iget(struct super_block *sb ,
                                                                       unsigned long ino ) 
{ struct inode *inode ;
  struct inode *tmp ;

  {
  tmp = iget_locked(sb, ino);
  inode = tmp;
  if (inode) {
    if (inode->i_state & 64UL) {
      ((*((sb->s_op)->read_inode)))(inode);
      unlock_new_inode(inode);
    }
  }
  return ((struct inode  __attribute__((__always_inline__)) *)inode);
}
}
extern void __iget(struct inode *inode ) ;
extern void clear_inode(struct inode * ) ;
extern void destroy_inode(struct inode * ) ;
extern struct inode *new_inode(struct super_block * ) ;
extern int remove_suid(struct dentry * ) ;
extern void remove_dquot_ref(struct super_block * , int  , struct list_head * ) ;
extern struct semaphore iprune_sem ;
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
extern void remove_inode_hash(struct inode * ) ;
__inline static void __attribute__((__always_inline__))  insert_inode_hash(struct inode *inode ) 
{ 

  {
  __insert_inode_hash(inode, inode->i_ino);
  return;
}
}
extern struct file *get_empty_filp(void) ;
extern void file_move(struct file *f , struct list_head *list ) ;
extern void file_kill(struct file *f ) ;
extern void submit_bio(int  , struct bio * ) ;
extern int bdev_read_only(struct block_device * ) ;
extern int set_blocksize(struct block_device * , int  ) ;
extern int sb_set_blocksize(struct super_block * , int  ) ;
extern int sb_min_blocksize(struct super_block * , int  ) ;
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
extern int file_read_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
extern int file_send_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
extern ssize_t generic_file_read(struct file * , char * , size_t  , loff_t * ) ;
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
extern ssize_t generic_file_write(struct file * , char const   * , size_t  , loff_t * ) ;
extern ssize_t generic_file_aio_read(struct kiocb * , char * , size_t  , loff_t  ) ;
extern ssize_t __generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                       loff_t * ) ;
extern ssize_t generic_file_aio_write(struct kiocb * , char const   * , size_t  ,
                                      loff_t  ) ;
extern ssize_t generic_file_aio_write_nolock(struct kiocb * , struct iovec  const  * ,
                                             unsigned long  , loff_t * ) ;
extern ssize_t generic_file_direct_write(struct kiocb * , struct iovec  const  * ,
                                         unsigned long * , loff_t  , loff_t * , size_t  ,
                                         size_t  ) ;
extern ssize_t generic_file_buffered_write(struct kiocb * , struct iovec  const  * ,
                                           unsigned long  , loff_t  , loff_t * , size_t  ,
                                           ssize_t  ) ;
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
extern ssize_t generic_file_write_nolock(struct file *file , struct iovec  const  *iov ,
                                         unsigned long nr_segs , loff_t *ppos ) ;
extern ssize_t generic_file_sendfile(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                                  struct page * ,
                                                                                  unsigned long  ,
                                                                                  unsigned long  ) ,
                                     void * ) ;
extern void do_generic_mapping_read(struct address_space *mapping , struct file_ra_state * ,
                                    struct file * , loff_t * , read_descriptor_t * ,
                                    int (*)(read_descriptor_t * , struct page * ,
                                            unsigned long  , unsigned long  ) ) ;
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
extern ssize_t generic_file_direct_IO(int rw , struct kiocb *iocb , struct iovec  const  *iov ,
                                      loff_t offset , unsigned long nr_segs ) ;
extern ssize_t generic_file_readv(struct file *filp , struct iovec  const  *iov ,
                                  unsigned long nr_segs , loff_t *ppos ) ;
extern ssize_t generic_file_writev(struct file *filp , struct iovec  const  *iov ,
                                   unsigned long nr_segs , loff_t *ppos ) ;
extern loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t remote_llseek(struct file *file , loff_t offset , int origin ) ;
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
__inline static void __attribute__((__always_inline__))  do_generic_file_read(struct file *filp ,
                                                                              loff_t *ppos ,
                                                                              read_descriptor_t *desc ,
                                                                              int (*actor)(read_descriptor_t * ,
                                                                                           struct page * ,
                                                                                           unsigned long  ,
                                                                                           unsigned long  ) ) 
{ 

  {
  do_generic_mapping_read(filp->f_mapping, & filp->f_ra, filp, ppos, desc, actor);
  return;
}
}
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iovec  const  *iov ,
                                    loff_t offset , unsigned long nr_segs , get_blocks_t *get_blocks ,
                                    dio_iodone_t *end_io , int lock_type ) ;
__inline static ssize_t __attribute__((__always_inline__))  blockdev_direct_IO(int rw ,
                                                                               struct kiocb *iocb ,
                                                                               struct inode *inode ,
                                                                               struct block_device *bdev ,
                                                                               struct iovec  const  *iov ,
                                                                               loff_t offset ,
                                                                               unsigned long nr_segs ,
                                                                               get_blocks_t *get_blocks ,
                                                                               dio_iodone_t *end_io ) 
{ ssize_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = (ssize_t __attribute__((__always_inline__))  )__blockdev_direct_IO(rw, iocb,
                                                                           inode,
                                                                           bdev, iov,
                                                                           offset,
                                                                           nr_segs,
                                                                           get_blocks,
                                                                           end_io,
                                                                           1);
  return (tmp);
}
}
__inline static ssize_t __attribute__((__always_inline__))  blockdev_direct_IO_no_locking(int rw ,
                                                                                          struct kiocb *iocb ,
                                                                                          struct inode *inode ,
                                                                                          struct block_device *bdev ,
                                                                                          struct iovec  const  *iov ,
                                                                                          loff_t offset ,
                                                                                          unsigned long nr_segs ,
                                                                                          get_blocks_t *get_blocks ,
                                                                                          dio_iodone_t *end_io ) 
{ ssize_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = (ssize_t __attribute__((__always_inline__))  )__blockdev_direct_IO(rw, iocb,
                                                                           inode,
                                                                           bdev, iov,
                                                                           offset,
                                                                           nr_segs,
                                                                           get_blocks,
                                                                           end_io,
                                                                           2);
  return (tmp);
}
}
__inline static ssize_t __attribute__((__always_inline__))  blockdev_direct_IO_own_locking(int rw ,
                                                                                           struct kiocb *iocb ,
                                                                                           struct inode *inode ,
                                                                                           struct block_device *bdev ,
                                                                                           struct iovec  const  *iov ,
                                                                                           loff_t offset ,
                                                                                           unsigned long nr_segs ,
                                                                                           get_blocks_t *get_blocks ,
                                                                                           dio_iodone_t *end_io ) 
{ ssize_t __attribute__((__always_inline__))  tmp ;

  {
  tmp = (ssize_t __attribute__((__always_inline__))  )__blockdev_direct_IO(rw, iocb,
                                                                           inode,
                                                                           bdev, iov,
                                                                           offset,
                                                                           nr_segs,
                                                                           get_blocks,
                                                                           end_io,
                                                                           3);
  return (tmp);
}
}
extern struct file_operations generic_ro_fops ;
extern int vfs_readlink(struct dentry * , char * , int  , char const   * ) ;
extern int vfs_follow_link(struct nameidata * , char const   * ) ;
extern int page_readlink(struct dentry * , char * , int  ) ;
extern int page_follow_link_light(struct dentry * , struct nameidata * ) ;
extern void page_put_link(struct dentry * , struct nameidata * ) ;
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
extern struct inode_operations page_symlink_inode_operations ;
extern int generic_readlink(struct dentry * , char * , int  ) ;
extern void generic_fillattr(struct inode * , struct kstat * ) ;
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
extern loff_t inode_get_bytes(struct inode *inode ) ;
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               ino_t  , unsigned int  ) , void * ) ;
extern int vfs_stat(char * , struct kstat * ) ;
extern int vfs_lstat(char * , struct kstat * ) ;
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
extern int vfs_ioctl(struct file * , unsigned int  , unsigned int  , unsigned long  ) ;
extern struct file_system_type *get_fs_type(char const   *name ) ;
extern struct super_block *get_super(struct block_device * ) ;
extern struct super_block *user_get_super(dev_t  ) ;
extern void drop_super(struct super_block *sb ) ;
extern int dcache_dir_open(struct inode * , struct file * ) ;
extern int dcache_dir_close(struct inode * , struct file * ) ;
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
extern int dcache_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                           int  , loff_t  , ino_t  ,
                                                           unsigned int  ) ) ;
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern int simple_statfs(struct super_block * , struct kstatfs * ) ;
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_unlink(struct inode * , struct dentry * ) ;
extern int simple_rmdir(struct inode * , struct dentry * ) ;
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_sync_file(struct file * , struct dentry * , int  ) ;
extern int simple_empty(struct dentry * ) ;
extern int simple_readpage(struct file *file , struct page *page ) ;
extern int simple_prepare_write(struct file *file , struct page *page , unsigned int offset ,
                                unsigned int to ) ;
extern int simple_commit_write(struct file *file , struct page *page , unsigned int offset ,
                               unsigned int to ) ;
extern struct dentry *simple_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
extern struct file_operations simple_dir_operations ;
extern struct inode_operations simple_dir_inode_operations ;
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
extern int simple_fill_super(struct super_block * , int  , struct tree_descr * ) ;
extern int simple_pin_fs(char *name , struct vfsmount **mount , int *count ) ;
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
extern int inode_change_ok(struct inode * , struct iattr * ) ;
extern int inode_setattr(struct inode * , struct iattr * ) ;
extern void inode_update_time(struct inode *inode , int ctime_too ) ;
__inline static ino_t __attribute__((__always_inline__))  parent_ino(struct dentry *dentry ) 
{ ino_t res ;

  {
  _spin_lock(& dentry->d_lock);
  res = ((dentry->d_parent)->d_inode)->i_ino;
  _spin_unlock(& dentry->d_lock);
  return (res);
}
}
extern int unshare_files(void) ;
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
__inline static void __attribute__((__always_inline__))  simple_transaction_set(struct file *file ,
                                                                                size_t n ) 
{ struct simple_transaction_argresp *ar ;
  long tmp ;

  {
  ar = (struct simple_transaction_argresp *)file->private_data;
  while (1) {
    tmp = __builtin_expect((long )(! (! (((unsigned long )n > 4096UL - (unsigned long )sizeof(struct simple_transaction_argresp )) !=
                                         0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (1650), "i" ("include/linux/fs.h"));
    }
    break;
  }
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       "  .align 4\n"
                       "  .long 661b\n"
                       "  .long 663f\n"
                       "  .byte %c0\n"
                       "  .byte 662b-661b\n"
                       "  .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  ar->size = (int )n;
}
}
__inline static char __attribute__((__always_inline__))  *alloc_secdata(void) 
{ 

  {
  return ((char __attribute__((__always_inline__))  *)((char *)1));
}
}
__inline static void __attribute__((__always_inline__))  free_secdata(void *secdata ) 
{ 

  {
  return;
}
}
extern unsigned long max_mapnr ;
extern unsigned long num_physpages ;
extern void *high_memory ;
extern unsigned long vmalloc_earlyreserve ;
extern int page_cluster ;
extern unsigned long empty_zero_page[1024] ;
extern pgd_t swapper_pg_dir[1024] ;
extern kmem_cache_t *pgd_cache ;
extern kmem_cache_t *pmd_cache ;
extern spinlock_t pgd_lock ;
extern struct page *pgd_list ;
extern void pmd_ctor(void * , kmem_cache_t * , unsigned long  ) ;
extern void pgd_ctor(void * , kmem_cache_t * , unsigned long  ) ;
extern void pgd_dtor(void * , kmem_cache_t * , unsigned long  ) ;
extern void pgtable_cache_init(void) ;
extern void paging_init(void) ;
extern unsigned long long __PAGE_KERNEL ;
extern unsigned long long __PAGE_KERNEL_EXEC ;
extern unsigned long pg0[] ;
__inline static int __attribute__((__always_inline__))  pte_user(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 4UL));
}
}
__inline static int __attribute__((__always_inline__))  pte_dirty(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 64UL));
}
}
__inline static int __attribute__((__always_inline__))  pte_young(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 32UL));
}
}
__inline static int __attribute__((__always_inline__))  pte_write(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(pte.pte_low & 2UL));
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_rdprotect(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967291UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkclean(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967231UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkold(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967263UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_wrprotect(pte_t pte ) 
{ 

  {
  pte.pte_low &= 4294967293UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkread(pte_t pte ) 
{ 

  {
  pte.pte_low |= 4UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkdirty(pte_t pte ) 
{ 

  {
  pte.pte_low |= 64UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkyoung(pte_t pte ) 
{ 

  {
  pte.pte_low |= 32UL;
  return (pte);
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_mkwrite(pte_t pte ) 
{ 

  {
  pte.pte_low |= 2UL;
  return (pte);
}
}
__inline static int __attribute__((__always_inline__))  pgd_none(pgd_t pgd ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  pgd_present(pgd_t pgd ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static void __attribute__((__always_inline__))  pgd_clear(pgd_t *pgd ) 
{ 

  {
  return;
}
}
__inline static pud_t __attribute__((__always_inline__))  *pud_offset(pgd_t *pgd ,
                                                                      unsigned long address ) 
{ 

  {
  return ((pud_t __attribute__((__always_inline__))  *)((pud_t *)pgd));
}
}
__inline static int __attribute__((__always_inline__))  pte_x(pte_t pte ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(! (((unsigned long long )pte.pte_low |
                                                         ((unsigned long long )pte.pte_high <<
                                                          32)) & 0x8000000000000000ULL) !=
                                                     0));
}
}
__inline static int __attribute__((__always_inline__))  pte_exec(pte_t pte ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = pte_user(pte);
  if (tmp) {
    tmp___0 = pte_x(pte);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  pte_exec_kernel(pte_t pte ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = pte_x(pte);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  set_pte(pte_t *ptep , pte_t pte ) 
{ 

  {
  ptep->pte_high = pte.pte_high;
  __asm__  volatile   ("": : : "memory");
  ptep->pte_low = pte.pte_low;
}
}
__inline static void __attribute__((__always_inline__))  pud_clear(pud_t *pud ) 
{ 

  {
  return;
}
}
__inline static pte_t __attribute__((__always_inline__))  ptep_get_and_clear(struct mm_struct *mm ,
                                                                             unsigned long addr ,
                                                                             pte_t *ptep ) 
{ pte_t res ;
  unsigned long __attribute__((__always_inline__))  tmp ;

  {
  res.pte_low = (unsigned long )__xchg(0UL, (void volatile   *)(& ptep->pte_low),
                                       (int )sizeof(ptep->pte_low));
  res.pte_high = ptep->pte_high;
  ptep->pte_high = 0UL;
  return (res);
}
}
__inline static int __attribute__((__always_inline__))  pte_same(pte_t a , pte_t b ) 
{ int tmp ;

  {
  if (a.pte_low == b.pte_low) {
    if (a.pte_high == b.pte_high) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static int __attribute__((__always_inline__))  pte_none(pte_t pte ) 
{ int tmp ;

  {
  if (! pte.pte_low) {
    if (! pte.pte_high) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  pte_pfn(pte_t pte ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((pte.pte_low >> 12) |
                                                               (pte.pte_high << 20)));
}
}
__inline static pte_t __attribute__((__always_inline__))  pfn_pte(unsigned long page_nr ,
                                                                  pgprot_t pgprot ) 
{ pte_t pte ;

  {
  pte.pte_high = (unsigned long )((unsigned long long )(page_nr >> 20) | (pgprot.pgprot >>
                                                                          32));
  pte.pte_high = (unsigned long )((unsigned long long )pte.pte_high & (__supported_pte_mask >>
                                                                       32));
  pte.pte_low = (unsigned long )(((unsigned long long )(page_nr << 12) | pgprot.pgprot) &
                                 __supported_pte_mask);
  return (pte);
}
}
__inline static pmd_t __attribute__((__always_inline__))  pfn_pmd(unsigned long page_nr ,
                                                                  pgprot_t pgprot ) 
{ pmd_t __constr_expr_0 ;

  {
  __constr_expr_0.pmd = (((unsigned long long )page_nr << 12) | pgprot.pgprot) & __supported_pte_mask;
  return (__constr_expr_0);
}
}
__inline static int __attribute__((__always_inline__))  ptep_test_and_clear_dirty(struct vm_area_struct *vma ,
                                                                                  unsigned long addr ,
                                                                                  pte_t *ptep ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = pte_dirty((*ptep));
  if (! tmp) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___0 = test_and_clear_bit(6, (unsigned long volatile   *)(& ptep->pte_low));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  ptep_test_and_clear_young(struct vm_area_struct *vma ,
                                                                                  unsigned long addr ,
                                                                                  pte_t *ptep ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = pte_young((*ptep));
  if (! tmp) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___0 = test_and_clear_bit(5, (unsigned long volatile   *)(& ptep->pte_low));
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  ptep_set_wrprotect(struct mm_struct *mm ,
                                                                            unsigned long addr ,
                                                                            pte_t *ptep ) 
{ 

  {
  clear_bit(1, (unsigned long volatile   *)(& ptep->pte_low));
  return;
}
}
__inline static pte_t __attribute__((__always_inline__))  pte_modify(pte_t pte , pgprot_t newprot ) 
{ 

  {
  pte.pte_low &= 4294963296UL;
  pte.pte_low = (unsigned long )((unsigned long long )pte.pte_low | newprot.pgprot);
  pte.pte_high &= 2147483647UL;
  pte.pte_high = (unsigned long )((unsigned long long )pte.pte_high | ((newprot.pgprot >>
                                                                        32) & (__supported_pte_mask >>
                                                                               32)));
  return (pte);
}
}
extern pte_t *lookup_address(unsigned long address ) ;
extern int set_kernel_exec(unsigned long vaddr , int enable ) ;
extern void noexec_setup(char const   *str ) ;
extern void pgd_clear_bad(pgd_t * ) ;
extern void pud_clear_bad(pud_t * ) ;
extern void pmd_clear_bad(pmd_t * ) ;
__inline static int __attribute__((__always_inline__))  pgd_none_or_clear_bad(pgd_t *pgd ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = pgd_none((*pgd));
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp___0 = pgd_none((*pgd));
  if (tmp___0) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  if (tmp___2) {
    pgd_clear_bad(pgd);
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  pud_none_or_clear_bad(pud_t *pud ) 
{ long tmp ;

  {
  tmp = __builtin_expect(0L, 0L);
  if (tmp) {
    pud_clear_bad(pud);
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  pmd_none_or_clear_bad(pmd_t *pmd ) 
{ long tmp ;

  {
  if (! pmd->pmd) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp = __builtin_expect((long )(! (! ((pmd->pmd & 4091ULL) != 99ULL)) != 0), 0L);
  if (tmp) {
    pmd_clear_bad(pmd);
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern pgprot_t protection_map[16] ;
extern void get_page_state(struct page_state *ret ) ;
extern void get_full_page_state(struct page_state *ret ) ;
extern unsigned long __read_page_state(unsigned int offset ) ;
extern void __mod_page_state(unsigned int offset , unsigned long delta ) ;
extern int test_clear_page_dirty(struct page *page ) ;
extern int test_clear_page_writeback(struct page *page ) ;
extern int test_set_page_writeback(struct page *page ) ;
__inline static void __attribute__((__always_inline__))  clear_page_dirty(struct page *page ) 
{ 

  {
  test_clear_page_dirty(page);
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_page_writeback(struct page *page ) 
{ 

  {
  test_set_page_writeback(page);
  return;
}
}
extern void ( __attribute__((__regparm__(3))) __page_cache_release)(struct page * ) ;
__inline static int __attribute__((__always_inline__))  page_count(struct page *p ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(15, (unsigned long const volatile   *)(& p->flags));
  if (tmp) {
    p = (struct page *)p->private;
  }
  return ((int __attribute__((__always_inline__))  )(p->_count.counter + 1));
}
}
__inline static void __attribute__((__always_inline__))  get_page(struct page *page ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = constant_test_bit(15, (unsigned long const volatile   *)(& page->flags));
  if (tmp) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  if (tmp___2) {
    page = (struct page *)page->private;
  }
  atomic_inc(& page->_count);
  return;
}
}
extern void put_page(struct page *page ) ;
__inline static unsigned long __attribute__((__always_inline__))  page_zonenum(struct page *page ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((page->flags >> ((sizeof(page_flags_t ) *
                                                                                 8U -
                                                                                 1U) -
                                                                                2U)) &
                                                               3UL));
}
}
__inline static unsigned long __attribute__((__always_inline__))  page_to_nid(struct page *page ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )(page->flags >> (((sizeof(page_flags_t ) *
                                                                                 8U -
                                                                                 1U) -
                                                                                2U) +
                                                                               2U)));
}
}
extern struct zone *zone_table[] ;
__inline static struct zone  __attribute__((__always_inline__)) *page_zone(struct page *page ) 
{ 

  {
  return ((struct zone  __attribute__((__always_inline__)) *)zone_table[page->flags >>
                                                                        ((sizeof(page_flags_t ) *
                                                                          8U - 1U) -
                                                                         2U)]);
}
}
__inline static void __attribute__((__always_inline__))  set_page_zone(struct page *page ,
                                                                       unsigned long nodezone_num ) 
{ 

  {
  page->flags &= ~ (4294967295UL << ((sizeof(page_flags_t ) * 8U - 1U) - 2U));
  page->flags |= nodezone_num << ((sizeof(page_flags_t ) * 8U - 1U) - 2U);
  return;
}
}
extern struct page *mem_map ;
__inline static void __attribute__((__always_inline__))  *lowmem_page_address(struct page *page ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((void *)(((unsigned long )(page -
                                                                                  mem_map) <<
                                                                 12) + 3221225472UL)));
}
}
extern void *page_address(struct page *page ) ;
extern void set_page_address(struct page *page , void *virtual ) ;
extern void page_address_init(void) ;
extern struct address_space swapper_space ;
__inline static struct address_space  __attribute__((__always_inline__)) *page_mapping(struct page *page ) 
{ struct address_space *mapping ;
  long tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  mapping = page->mapping;
  tmp___0 = constant_test_bit(16, (unsigned long const volatile   *)(& page->flags));
  if (tmp___0) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  if (tmp___3) {
    mapping = & swapper_space;
  } else {
    tmp = __builtin_expect((long )(! (! ((unsigned long )mapping & 1UL)) != 0), 0L);
    if (tmp) {
      mapping = (struct address_space *)((void *)0);
    }
  }
  return ((struct address_space  __attribute__((__always_inline__)) *)mapping);
}
}
__inline static int __attribute__((__always_inline__))  PageAnon(struct page *page ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(((unsigned long )page->mapping &
                                                      1UL) != 0UL));
}
}
__inline static unsigned long __attribute__((__always_inline__))  page_index(struct page *page ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = constant_test_bit(16, (unsigned long const volatile   *)(& page->flags));
  if (tmp) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  if (tmp___2) {
    return ((unsigned long __attribute__((__always_inline__))  )page->private);
  }
  return ((unsigned long __attribute__((__always_inline__))  )page->index);
}
}
__inline static void __attribute__((__always_inline__))  reset_page_mapcount(struct page *page ) 
{ 

  {
  page->_mapcount.counter = (int volatile   )-1;
  return;
}
}
__inline static int __attribute__((__always_inline__))  page_mapcount(struct page *page ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(page->_mapcount.counter + 1));
}
}
__inline static int __attribute__((__always_inline__))  page_mapped(struct page *page ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(page->_mapcount.counter >= 0));
}
}
extern void show_free_areas(void) ;
extern struct page *shmem_nopage(struct vm_area_struct *vma , unsigned long address ,
                                 int *type ) ;
extern int shmem_set_policy(struct vm_area_struct *vma , struct mempolicy *new ) ;
extern struct mempolicy *shmem_get_policy(struct vm_area_struct *vma , unsigned long addr ) ;
extern int shmem_lock(struct file *file , int lock , struct user_struct *user ) ;
extern struct file *shmem_file_setup(char *name , loff_t size , unsigned long flags ) ;
extern int shmem_zero_setup(struct vm_area_struct * ) ;
__inline static int __attribute__((__always_inline__))  can_do_mlock(void) 
{ int __attribute__((__always_inline__))  tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp = capable(14);
  if (tmp) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp___0 = get_current();
  if ((tmp___0->signal)->rlim[8].rlim_cur != 0UL) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int user_shm_lock(size_t  , struct user_struct * ) ;
extern void user_shm_unlock(size_t  , struct user_struct * ) ;
extern unsigned long zap_page_range(struct vm_area_struct *vma , unsigned long address ,
                                    unsigned long size , struct zap_details * ) ;
extern unsigned long unmap_vmas(struct mmu_gather **tlb , struct mm_struct *mm , struct vm_area_struct *start_vma ,
                                unsigned long start_addr , unsigned long end_addr ,
                                unsigned long *nr_accounted , struct zap_details * ) ;
extern void free_pgd_range(struct mmu_gather **tlb , unsigned long addr , unsigned long end ,
                           unsigned long floor , unsigned long ceiling ) ;
extern void free_pgtables(struct mmu_gather **tlb , struct vm_area_struct *start_vma ,
                          unsigned long floor , unsigned long ceiling ) ;
extern int copy_page_range(struct mm_struct *dst , struct mm_struct *src , struct vm_area_struct *vma ) ;
extern int zeromap_page_range(struct vm_area_struct *vma , unsigned long from , unsigned long size ,
                              pgprot_t prot ) ;
extern void unmap_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                loff_t holelen , int even_cows ) ;
__inline static void __attribute__((__always_inline__))  unmap_shared_mapping_range(struct address_space *mapping ,
                                                                                    loff_t holebegin ,
                                                                                    loff_t holelen ) 
{ 

  {
  unmap_mapping_range(mapping, holebegin, holelen, 0);
  return;
}
}
extern int vmtruncate(struct inode *inode , loff_t offset ) ;
extern pud_t *( __attribute__((__regparm__(3))) __pud_alloc)(struct mm_struct *mm ,
                                                             pgd_t *pgd , unsigned long address ) ;
extern pmd_t *( __attribute__((__regparm__(3))) __pmd_alloc)(struct mm_struct *mm ,
                                                             pud_t *pud , unsigned long address ) ;
extern pte_t *( __attribute__((__regparm__(3))) pte_alloc_kernel)(struct mm_struct *mm ,
                                                                  pmd_t *pmd , unsigned long address ) ;
extern pte_t *( __attribute__((__regparm__(3))) pte_alloc_map)(struct mm_struct *mm ,
                                                               pmd_t *pmd , unsigned long address ) ;
extern int install_page(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long addr ,
                        struct page *page , pgprot_t prot ) ;
extern int install_file_pte(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long addr ,
                            unsigned long pgoff , pgprot_t prot ) ;
extern int handle_mm_fault(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long address ,
                           int write_access ) ;
extern int make_pages_present(unsigned long addr , unsigned long end ) ;
extern int access_process_vm(struct task_struct *tsk , unsigned long addr , void *buf ,
                             int len , int write ) ;
extern void install_arg_page(struct vm_area_struct * , struct page * , unsigned long  ) ;
extern int get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                          int len , int write , int force , struct page **pages ,
                          struct vm_area_struct **vmas ) ;
extern int __set_page_dirty_buffers(struct page *page ) ;
extern int __set_page_dirty_nobuffers(struct page *page ) ;
extern int redirty_page_for_writepage(struct writeback_control *wbc , struct page *page ) ;
extern int ( __attribute__((__regparm__(3))) set_page_dirty)(struct page *page ) ;
extern int set_page_dirty_lock(struct page *page ) ;
extern int clear_page_dirty_for_io(struct page *page ) ;
extern unsigned long do_mremap(unsigned long addr , unsigned long old_len , unsigned long new_len ,
                               unsigned long flags , unsigned long new_addr ) ;
extern struct shrinker *set_shrinker(int  , int (*)(int nr_to_scan , unsigned int gfp_mask ) ) ;
extern void remove_shrinker(struct shrinker *shrinker ) ;
__inline static pud_t __attribute__((__always_inline__))  *pud_alloc(struct mm_struct *mm ,
                                                                     pgd_t *pgd ,
                                                                     unsigned long address ) 
{ pud_t __attribute__((__always_inline__))  *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  pud_t __attribute__((__always_inline__))  *tmp___1 ;

  {
  tmp___0 = pgd_none((*pgd));
  if (tmp___0) {
    tmp = (pud_t __attribute__((__always_inline__))  *)__pud_alloc(mm, pgd, address);
    return (tmp);
  }
  tmp___1 = pud_offset(pgd, address);
  return (tmp___1);
}
}
__inline static pmd_t __attribute__((__always_inline__))  *pmd_alloc(struct mm_struct *mm ,
                                                                     pud_t *pud ,
                                                                     unsigned long address ) 
{ pmd_t __attribute__((__always_inline__))  *tmp ;

  {
  return ((pmd_t __attribute__((__always_inline__))  *)((pmd_t *)((struct page *)((void *)((unsigned long )(pud->pgd.pgd &
                                                                                                            4294963200ULL) +
                                                                                           3221225472UL))) +
                                                        ((address >> 21) & 511UL)));
}
}
extern void free_area_init(unsigned long *zones_size ) ;
extern void free_area_init_node(int nid , pg_data_t *pgdat , unsigned long *zones_size ,
                                unsigned long zone_start_pfn , unsigned long *zholes_size ) ;
extern void memmap_init_zone(unsigned long  , int  , unsigned long  , unsigned long  ) ;
extern void mem_init(void) ;
extern void show_mem(void) ;
extern void si_meminfo(struct sysinfo *val ) ;
extern void si_meminfo_node(struct sysinfo *val , int nid ) ;
extern void vma_prio_tree_add(struct vm_area_struct * , struct vm_area_struct *old ) ;
extern void vma_prio_tree_insert(struct vm_area_struct * , struct prio_tree_root * ) ;
extern void vma_prio_tree_remove(struct vm_area_struct * , struct prio_tree_root * ) ;
extern struct vm_area_struct *vma_prio_tree_next(struct vm_area_struct *vma , struct prio_tree_iter *iter ) ;
__inline static void __attribute__((__always_inline__))  vma_nonlinear_insert(struct vm_area_struct *vma ,
                                                                              struct list_head *list ) 
{ 

  {
  vma->shared.vm_set.parent = (void *)0;
  list_add_tail(& vma->shared.vm_set.list, list);
  return;
}
}
extern int __vm_enough_memory(long pages , int cap_sys_admin ) ;
extern void vma_adjust(struct vm_area_struct *vma , unsigned long start , unsigned long end ,
                       unsigned long pgoff , struct vm_area_struct *insert ) ;
extern struct vm_area_struct *vma_merge(struct mm_struct * , struct vm_area_struct *prev ,
                                        unsigned long addr , unsigned long end , unsigned long vm_flags ,
                                        struct anon_vma * , struct file * , unsigned long  ,
                                        struct mempolicy * ) ;
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct * ) ;
extern int split_vma(struct mm_struct * , struct vm_area_struct * , unsigned long addr ,
                     int new_below ) ;
extern int insert_vm_struct(struct mm_struct * , struct vm_area_struct * ) ;
extern void __vma_link_rb(struct mm_struct * , struct vm_area_struct * , struct rb_node ** ,
                          struct rb_node * ) ;
extern struct vm_area_struct *copy_vma(struct vm_area_struct ** , unsigned long addr ,
                                       unsigned long len , unsigned long pgoff ) ;
extern void exit_mmap(struct mm_struct * ) ;
extern int may_expand_vm(struct mm_struct *mm , unsigned long npages ) ;
extern unsigned long get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                       unsigned long  , unsigned long  ) ;
extern unsigned long do_mmap_pgoff(struct file *file , unsigned long addr , unsigned long len ,
                                   unsigned long prot , unsigned long flag , unsigned long pgoff ) ;
__inline static unsigned long __attribute__((__always_inline__))  do_mmap(struct file *file ,
                                                                          unsigned long addr ,
                                                                          unsigned long len ,
                                                                          unsigned long prot ,
                                                                          unsigned long flag ,
                                                                          unsigned long offset ) 
{ unsigned long ret ;

  {
  ret = 4294967274UL;
  if (offset + (((len + 4096UL) - 1UL) & 4294963200UL) < offset) {
    goto out;
  }
  if (! (offset & 4095UL)) {
    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
  }
  out: 
  return ((unsigned long __attribute__((__always_inline__))  )ret);
}
}
extern int do_munmap(struct mm_struct * , unsigned long  , size_t  ) ;
extern unsigned long do_brk(unsigned long  , unsigned long  ) ;
extern unsigned long page_unuse(struct page * ) ;
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
extern struct page *filemap_nopage(struct vm_area_struct * , unsigned long  , int * ) ;
extern int filemap_populate(struct vm_area_struct * , unsigned long  , unsigned long  ,
                            pgprot_t  , unsigned long  , int  ) ;
extern int write_one_page(struct page *page , int wait ) ;
extern int do_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                   unsigned long offset , unsigned long nr_to_read ) ;
extern int force_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                      unsigned long offset , unsigned long nr_to_read ) ;
extern unsigned long page_cache_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                          struct file *filp , unsigned long offset ,
                                          unsigned long size ) ;
extern void handle_ra_miss(struct address_space *mapping , struct file_ra_state *ra ,
                           unsigned long offset ) ;
extern unsigned long max_sane_readahead(unsigned long nr ) ;
extern int expand_stack(struct vm_area_struct *vma , unsigned long address ) ;
extern struct vm_area_struct *find_vma(struct mm_struct *mm , unsigned long addr ) ;
extern struct vm_area_struct *find_vma_prev(struct mm_struct *mm , unsigned long addr ,
                                            struct vm_area_struct **pprev ) ;
__inline static struct vm_area_struct  __attribute__((__always_inline__)) *find_vma_intersection(struct mm_struct *mm ,
                                                                                                 unsigned long start_addr ,
                                                                                                 unsigned long end_addr ) 
{ struct vm_area_struct *vma ;
  struct vm_area_struct *tmp ;

  {
  tmp = find_vma(mm, start_addr);
  vma = tmp;
  if (vma) {
    if (end_addr <= vma->vm_start) {
      vma = (struct vm_area_struct *)((void *)0);
    }
  }
  return ((struct vm_area_struct  __attribute__((__always_inline__)) *)vma);
}
}
__inline static unsigned long __attribute__((__always_inline__))  vma_pages(struct vm_area_struct *vma ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )((vma->vm_end - vma->vm_start) >>
                                                               12));
}
}
extern struct vm_area_struct *find_extend_vma(struct mm_struct *mm , unsigned long addr ) ;
extern struct page *vmalloc_to_page(void *addr ) ;
extern unsigned long vmalloc_to_pfn(void *addr ) ;
extern struct page *follow_page(struct mm_struct *mm , unsigned long address , int write ) ;
extern int check_user_page_readable(struct mm_struct *mm , unsigned long address ) ;
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
extern void __vm_stat_account(struct mm_struct * , unsigned long  , struct file * ,
                              long  ) ;
__inline static void __attribute__((__always_inline__))  vm_stat_account(struct vm_area_struct *vma ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = vma_pages(vma);
  __vm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file, (long )tmp);
  return;
}
}
__inline static void __attribute__((__always_inline__))  vm_stat_unaccount(struct vm_area_struct *vma ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  tmp = vma_pages(vma);
  __vm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file, (long )(- tmp));
  return;
}
}
extern void update_mem_hiwater(struct task_struct *tsk ) ;
__inline static void __attribute__((__always_inline__))  kernel_map_pages(struct page *page ,
                                                                          int numpages ,
                                                                          int enable ) 
{ 

  {
  return;
}
}
extern struct vm_area_struct *get_gate_vma(struct task_struct *tsk ) ;
extern int in_gate_area_no_task(unsigned long addr ) ;
extern unsigned int pcibios_assign_all_busses(void) ;
extern unsigned long pci_mem_start ;
extern void pcibios_config_init(void) ;
extern struct pci_bus *pcibios_scan_root(int bus ) ;
extern void pcibios_set_master(struct pci_dev *dev ) ;
extern void pcibios_penalize_isa_irq(int irq ) ;
extern struct irq_routing_table *pcibios_get_irq_routing_table(void) ;
extern int pcibios_set_irq_routing(struct pci_dev *dev , int pin , int irq ) ;
__inline static dma64_addr_t __attribute__((__always_inline__))  pci_dac_page_to_dma(struct pci_dev *pdev ,
                                                                                     struct page *page ,
                                                                                     unsigned long offset ,
                                                                                     int direction ) 
{ 

  {
  return (((unsigned long long )((unsigned long )(page - mem_map)) << 12) + (unsigned long long )offset);
}
}
__inline static struct page  __attribute__((__always_inline__)) *pci_dac_dma_to_page(struct pci_dev *pdev ,
                                                                                     dma64_addr_t dma_addr ) 
{ 

  {
  return ((struct page  __attribute__((__always_inline__)) *)(mem_map + (dma_addr >>
                                                                         12)));
}
}
__inline static unsigned long __attribute__((__always_inline__))  pci_dac_dma_to_offset(struct pci_dev *pdev ,
                                                                                        dma64_addr_t dma_addr ) 
{ 

  {
  return ((unsigned long __attribute__((__always_inline__))  )(dma_addr & 4095ULL));
}
}
__inline static void __attribute__((__always_inline__))  pci_dac_dma_sync_single_for_cpu(struct pci_dev *pdev ,
                                                                                         dma64_addr_t dma_addr ,
                                                                                         size_t len ,
                                                                                         int direction ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  pci_dac_dma_sync_single_for_device(struct pci_dev *pdev ,
                                                                                            dma64_addr_t dma_addr ,
                                                                                            size_t len ,
                                                                                            int direction ) 
{ 

  {
  flush_write_buffers();
  return;
}
}
extern int pci_mmap_page_range(struct pci_dev *dev , struct vm_area_struct *vma ,
                               enum pci_mmap_state mmap_state , int write_combine ) ;
extern void *dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                unsigned int flag ) ;
extern void dma_free_coherent(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
__inline static dma_addr_t __attribute__((__always_inline__))  dma_map_single(struct device *dev ,
                                                                              void *ptr ,
                                                                              size_t size ,
                                                                              enum dma_data_direction direction ) 
{ long tmp ;
  dma_addr_t __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((int )direction == 3) != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (23), "i" ("include/asm/dma-mapping.h"));
    }
    break;
  }
  flush_write_buffers();
  tmp___0 = (dma_addr_t __attribute__((__always_inline__))  )virt_to_phys((void volatile   *)ptr);
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  dma_unmap_single(struct device *dev ,
                                                                          dma_addr_t dma_addr ,
                                                                          size_t size ,
                                                                          enum dma_data_direction direction ) 
{ long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((int )direction == 3) != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (32), "i" ("include/asm/dma-mapping.h"));
    }
    break;
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  dma_map_sg(struct device *dev ,
                                                                   struct scatterlist *sg ,
                                                                   int nents , enum dma_data_direction direction ) 
{ int i ;
  long tmp ;
  long tmp___0 ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((int )direction == 3) != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (41), "i" ("include/asm/dma-mapping.h"));
    }
    break;
  }
  i = 0;
  while (i < nents) {
    while (1) {
      tmp___0 = __builtin_expect((long )(! (! ((! (sg + i)->page != 0) != 0)) != 0),
                                 0L);
      if (tmp___0) {
        __asm__  volatile   ("ud2\n"
                             "\t.word %c0\n"
                             "\t.long %c1\n": : "i" (44), "i" ("include/asm/dma-mapping.h"));
      }
      break;
    }
    (sg + i)->dma_address = ((unsigned long long )((unsigned long )((sg + i)->page -
                                                                    mem_map)) << 12) +
                            (unsigned long long )(sg + i)->offset;
    i ++;
  }
  flush_write_buffers();
  return ((int __attribute__((__always_inline__))  )nents);
}
}
__inline static dma_addr_t __attribute__((__always_inline__))  dma_map_page(struct device *dev ,
                                                                            struct page *page ,
                                                                            unsigned long offset ,
                                                                            size_t size ,
                                                                            enum dma_data_direction direction ) 
{ long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((int )direction == 3) != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (57), "i" ("include/asm/dma-mapping.h"));
    }
    break;
  }
  return (((unsigned long long )((unsigned long )(page - mem_map)) << 12) + (unsigned long long )offset);
}
}
__inline static void __attribute__((__always_inline__))  dma_unmap_page(struct device *dev ,
                                                                        dma_addr_t dma_address ,
                                                                        size_t size ,
                                                                        enum dma_data_direction direction ) 
{ long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((int )direction == 3) != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (65), "i" ("include/asm/dma-mapping.h"));
    }
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_unmap_sg(struct device *dev ,
                                                                      struct scatterlist *sg ,
                                                                      int nhwentries ,
                                                                      enum dma_data_direction direction ) 
{ long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((int )direction == 3) != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (73), "i" ("include/asm/dma-mapping.h"));
    }
    break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_sync_single_for_cpu(struct device *dev ,
                                                                                 dma_addr_t dma_handle ,
                                                                                 size_t size ,
                                                                                 enum dma_data_direction direction ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_sync_single_for_device(struct device *dev ,
                                                                                    dma_addr_t dma_handle ,
                                                                                    size_t size ,
                                                                                    enum dma_data_direction direction ) 
{ 

  {
  flush_write_buffers();
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_sync_single_range_for_cpu(struct device *dev ,
                                                                                       dma_addr_t dma_handle ,
                                                                                       unsigned long offset ,
                                                                                       size_t size ,
                                                                                       enum dma_data_direction direction ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_sync_single_range_for_device(struct device *dev ,
                                                                                          dma_addr_t dma_handle ,
                                                                                          unsigned long offset ,
                                                                                          size_t size ,
                                                                                          enum dma_data_direction direction ) 
{ 

  {
  flush_write_buffers();
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_sync_sg_for_cpu(struct device *dev ,
                                                                             struct scatterlist *sg ,
                                                                             int nelems ,
                                                                             enum dma_data_direction direction ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  dma_sync_sg_for_device(struct device *dev ,
                                                                                struct scatterlist *sg ,
                                                                                int nelems ,
                                                                                enum dma_data_direction direction ) 
{ 

  {
  flush_write_buffers();
  return;
}
}
__inline static int __attribute__((__always_inline__))  dma_mapping_error(dma_addr_t dma_addr ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  dma_supported(struct device *dev ,
                                                                      u64 mask ) 
{ 

  {
  if (mask < 16777215ULL) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  return ((int __attribute__((__always_inline__))  )1);
}
}
__inline static int __attribute__((__always_inline__))  dma_set_mask(struct device *dev ,
                                                                     u64 mask ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (! dev->dma_mask) {
    return ((int __attribute__((__always_inline__))  )-5);
  } else {
    tmp = dma_supported(dev, mask);
    if (! tmp) {
      return ((int __attribute__((__always_inline__))  )-5);
    }
  }
  (*(dev->dma_mask)) = mask;
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static int __attribute__((__always_inline__))  dma_get_cache_alignment(void) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )128);
}
}
__inline static void __attribute__((__always_inline__))  dma_cache_sync(void *vaddr ,
                                                                        size_t size ,
                                                                        enum dma_data_direction direction ) 
{ 

  {
  flush_write_buffers();
  return;
}
}
extern int dma_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                       dma_addr_t device_addr , size_t size , int flags ) ;
extern void dma_release_declared_memory(struct device *dev ) ;
extern void *dma_mark_declared_memory_occupied(struct device *dev , dma_addr_t device_addr ,
                                               size_t size ) ;
extern u64 dma_get_required_mask(struct device *dev ) ;
__inline static int __attribute__((__always_inline__))  pci_dma_supported(struct pci_dev *hwdev ,
                                                                          u64 mask ) 
{ struct device *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  tmp___0 = dma_supported(tmp, mask);
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  *pci_alloc_consistent(struct pci_dev *hwdev ,
                                                                               size_t size ,
                                                                               dma_addr_t *dma_handle ) 
{ struct device *tmp ;
  void __attribute__((__always_inline__))  *tmp___0 ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  tmp___0 = (void __attribute__((__always_inline__))  *)dma_alloc_coherent(tmp, size,
                                                                           dma_handle,
                                                                           32U);
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  pci_free_consistent(struct pci_dev *hwdev ,
                                                                             size_t size ,
                                                                             void *vaddr ,
                                                                             dma_addr_t dma_handle ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_free_coherent(tmp, size, vaddr, dma_handle);
  return;
}
}
__inline static dma_addr_t __attribute__((__always_inline__))  pci_map_single(struct pci_dev *hwdev ,
                                                                              void *ptr ,
                                                                              size_t size ,
                                                                              int direction ) 
{ struct device *tmp ;
  dma_addr_t __attribute__((__always_inline__))  tmp___0 ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  tmp___0 = dma_map_single(tmp, ptr, size, (enum dma_data_direction )direction);
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  pci_unmap_single(struct pci_dev *hwdev ,
                                                                          dma_addr_t dma_addr ,
                                                                          size_t size ,
                                                                          int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_unmap_single(tmp, dma_addr, size, (enum dma_data_direction )direction);
  return;
}
}
__inline static dma_addr_t __attribute__((__always_inline__))  pci_map_page(struct pci_dev *hwdev ,
                                                                            struct page *page ,
                                                                            unsigned long offset ,
                                                                            size_t size ,
                                                                            int direction ) 
{ struct device *tmp ;
  dma_addr_t __attribute__((__always_inline__))  tmp___0 ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  tmp___0 = dma_map_page(tmp, page, offset, size, (enum dma_data_direction )direction);
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  pci_unmap_page(struct pci_dev *hwdev ,
                                                                        dma_addr_t dma_address ,
                                                                        size_t size ,
                                                                        int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_unmap_page(tmp, dma_address, size, (enum dma_data_direction )direction);
  return;
}
}
__inline static int __attribute__((__always_inline__))  pci_map_sg(struct pci_dev *hwdev ,
                                                                   struct scatterlist *sg ,
                                                                   int nents , int direction ) 
{ struct device *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  tmp___0 = dma_map_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  pci_unmap_sg(struct pci_dev *hwdev ,
                                                                      struct scatterlist *sg ,
                                                                      int nents ,
                                                                      int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_unmap_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  return;
}
}
__inline static void __attribute__((__always_inline__))  pci_dma_sync_single_for_cpu(struct pci_dev *hwdev ,
                                                                                     dma_addr_t dma_handle ,
                                                                                     size_t size ,
                                                                                     int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_sync_single_for_cpu(tmp, dma_handle, size, (enum dma_data_direction )direction);
  return;
}
}
__inline static void __attribute__((__always_inline__))  pci_dma_sync_single_for_device(struct pci_dev *hwdev ,
                                                                                        dma_addr_t dma_handle ,
                                                                                        size_t size ,
                                                                                        int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_sync_single_for_device(tmp, dma_handle, size, (enum dma_data_direction )direction);
  return;
}
}
__inline static void __attribute__((__always_inline__))  pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev ,
                                                                                 struct scatterlist *sg ,
                                                                                 int nelems ,
                                                                                 int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_sync_sg_for_cpu(tmp, sg, nelems, (enum dma_data_direction )direction);
  return;
}
}
__inline static void __attribute__((__always_inline__))  pci_dma_sync_sg_for_device(struct pci_dev *hwdev ,
                                                                                    struct scatterlist *sg ,
                                                                                    int nelems ,
                                                                                    int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned int )hwdev == (unsigned int )((void *)0)) {
    tmp = (struct device *)((void *)0);
  } else {
    tmp = & hwdev->dev;
  }
  dma_sync_sg_for_device(tmp, sg, nelems, (enum dma_data_direction )direction);
  return;
}
}
__inline static int __attribute__((__always_inline__))  pci_dma_mapping_error(dma_addr_t dma_addr ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = dma_mapping_error(dma_addr);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  pcibios_resource_to_bus(struct pci_dev *dev ,
                                                                                 struct pci_bus_region *region ,
                                                                                 struct resource *res ) 
{ 

  {
  region->start = res->start;
  region->end = res->end;
  return;
}
}
__inline static int __attribute__((__always_inline__))  pci_get_legacy_ide_irq(struct pci_dev *dev ,
                                                                               int channel ) 
{ int tmp ;

  {
  if (channel) {
    tmp = 15;
  } else {
    tmp = 14;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static int __attribute__((__always_inline__))  pci_domain_nr(struct pci_bus *bus ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  *pci_get_drvdata(struct pci_dev *pdev ) 
{ void __attribute__((__always_inline__))  *tmp ;

  {
  tmp = dev_get_drvdata(& pdev->dev);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  pci_set_drvdata(struct pci_dev *pdev ,
                                                                         void *data ) 
{ 

  {
  dev_set_drvdata(& pdev->dev, data);
  return;
}
}
__inline static char __attribute__((__always_inline__))  *pci_name(struct pci_dev *pdev ) 
{ 

  {
  return ((char __attribute__((__always_inline__))  *)(pdev->dev.bus_id));
}
}
extern void pci_fixup_device(enum pci_fixup_pass pass , struct pci_dev *dev ) ;
extern int pci_pci_problems ;
extern void cdev_init(struct cdev * , struct file_operations * ) ;
extern struct cdev *cdev_alloc(void) ;
extern void cdev_put(struct cdev *p ) ;
extern int cdev_add(struct cdev * , dev_t  , unsigned int  ) ;
extern void cdev_del(struct cdev * ) ;
extern void cd_forget(struct inode * ) ;
extern struct list_head tty_drivers ;
extern struct tty_driver *alloc_tty_driver(int lines ) ;
extern void put_tty_driver(struct tty_driver *driver ) ;
extern void tty_set_operations(struct tty_driver *driver , struct tty_operations *op ) ;
extern struct screen_info screen_info ;
extern void tty_write_flush(struct tty_struct * ) ;
extern struct termios tty_std_termios ;
extern int fg_console ;
extern int last_console ;
extern int want_console ;
extern int kmsg_redirect ;
extern void console_init(void) ;
extern int vcs_init(void) ;
extern int tty_paranoia_check(struct tty_struct *tty , struct inode *inode , char const   *routine ) ;
extern char *tty_name(struct tty_struct *tty , char *buf ) ;
extern void tty_wait_until_sent(struct tty_struct *tty , long timeout ) ;
extern int tty_check_change(struct tty_struct *tty ) ;
extern void stop_tty(struct tty_struct *tty ) ;
extern void start_tty(struct tty_struct *tty ) ;
extern int tty_register_ldisc(int disc , struct tty_ldisc *new_ldisc ) ;
extern int tty_register_driver(struct tty_driver *driver ) ;
extern int tty_unregister_driver(struct tty_driver *driver ) ;
extern void tty_register_device(struct tty_driver *driver , unsigned int index , struct device *dev ) ;
extern void tty_unregister_device(struct tty_driver *driver , unsigned int index ) ;
extern int tty_read_raw_data(struct tty_struct *tty , unsigned char *bufp , int buflen ) ;
extern void tty_write_message(struct tty_struct *tty , char *msg ) ;
extern int is_orphaned_pgrp(int pgrp ) ;
extern int is_ignored(int sig ) ;
extern int tty_signal(int sig , struct tty_struct *tty ) ;
extern void tty_hangup(struct tty_struct *tty ) ;
extern void tty_vhangup(struct tty_struct *tty ) ;
extern void tty_unhangup(struct file *filp ) ;
extern int tty_hung_up_p(struct file *filp ) ;
extern void do_SAK(struct tty_struct *tty ) ;
extern void disassociate_ctty(int priv ) ;
extern void tty_flip_buffer_push(struct tty_struct *tty ) ;
extern int tty_get_baud_rate(struct tty_struct *tty ) ;
extern int tty_termios_baud_rate(struct termios *termios ) ;
extern struct tty_ldisc *tty_ldisc_ref(struct tty_struct * ) ;
extern void tty_ldisc_deref(struct tty_ldisc * ) ;
extern struct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct * ) ;
extern struct tty_ldisc *tty_ldisc_get(int  ) ;
extern void tty_ldisc_put(int  ) ;
extern void tty_wakeup(struct tty_struct *tty ) ;
extern void tty_ldisc_flush(struct tty_struct *tty ) ;
extern struct semaphore tty_sem ;
extern struct tty_ldisc tty_ldisc_N_TTY ;
extern int n_tty_ioctl(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                       unsigned long arg ) ;
extern void serial_console_init(void) ;
extern int pcxe_open(struct tty_struct *tty , struct file *filp ) ;
extern void console_print(char const   * ) ;
extern int vt_ioctl(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                    unsigned long arg ) ;
__inline static dev_t __attribute__((__always_inline__))  tty_devnum(struct tty_struct *tty ) 
{ 

  {
  return ((unsigned int )((((tty->driver)->major << 20) | (tty->driver)->minor_start) +
                          tty->index));
}
}
__inline static void __attribute__((__always_inline__))  tty_insert_flip_char(struct tty_struct *tty ,
                                                                              unsigned char ch ,
                                                                              char flag ) 
{ unsigned char *tmp ;
  char *tmp___0 ;

  {
  if (tty->flip.count < 512) {
    tty->flip.count ++;
    tmp = tty->flip.flag_buf_ptr;
    tty->flip.flag_buf_ptr ++;
    (*tmp) = (unsigned char )flag;
    tmp___0 = tty->flip.char_buf_ptr;
    tty->flip.char_buf_ptr ++;
    (*tmp___0) = (char )ch;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  tty_schedule_flip(struct tty_struct *tty ) 
{ 

  {
  schedule_delayed_work(& tty->flip.work, 1UL);
  return;
}
}
extern int register_serial(struct serial_struct *req ) ;
extern void unregister_serial(int line ) ;
extern int early_serial_setup(struct uart_port *port ) ;
extern int early_serial_console_init(char *options ) ;
extern int serial8250_start_console(struct uart_port *port , char *options ) ;
extern int ptrace_readdata(struct task_struct *tsk , unsigned long src , char *dst ,
                           int len ) ;
extern int ptrace_writedata(struct task_struct *tsk , char *src , unsigned long dst ,
                            int len ) ;
extern int ptrace_attach(struct task_struct *tsk ) ;
extern int ptrace_detach(struct task_struct * , unsigned int  ) ;
extern void ptrace_disable(struct task_struct * ) ;
extern int ptrace_check_attach(struct task_struct *task , int kill ) ;
extern int ptrace_request(struct task_struct *child , long request , long addr , long data ) ;
extern void ptrace_notify(int exit_code ) ;
extern void __ptrace_link(struct task_struct *child , struct task_struct *new_parent ) ;
extern void __ptrace_unlink(struct task_struct *child ) ;
extern void ptrace_untrace(struct task_struct *child ) ;
__inline static void __attribute__((__always_inline__))  ptrace_link(struct task_struct *child ,
                                                                     struct task_struct *new_parent ) 
{ long tmp ;

  {
  tmp = __builtin_expect((long )(! (! child->ptrace) != 0), 0L);
  if (tmp) {
    __ptrace_link(child, new_parent);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  ptrace_unlink(struct task_struct *child ) 
{ long tmp ;

  {
  tmp = __builtin_expect((long )(! (! child->ptrace) != 0), 0L);
  if (tmp) {
    __ptrace_unlink(child);
  }
  return;
}
}
extern unsigned long loops_per_jiffy ;
extern void __bad_udelay(void) ;
extern void __bad_ndelay(void) ;
extern void __udelay(unsigned long usecs ) ;
extern void __ndelay(unsigned long nsecs ) ;
extern void __const_udelay(unsigned long usecs ) ;
extern void __delay(unsigned long loops ) ;
extern void calibrate_delay(void) ;
extern void msleep(unsigned int msecs ) ;
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
__inline static void __attribute__((__always_inline__))  ssleep(unsigned int seconds ) 
{ 

  {
  msleep(seconds * 1000U);
  return;
}
}
__inline static size_t __attribute__((__always_inline__))  iov_length(struct iovec  const  *iov ,
                                                                      unsigned long nr_segs ) 
{ unsigned long seg ;
  size_t ret ;

  {
  ret = (size_t )0;
  seg = 0UL;
  while (seg < nr_segs) {
    ret += (size_t )(iov + seg)->iov_len;
    seg ++;
  }
  return (ret);
}
}
extern unsigned long iov_shorten(struct iovec *iov , unsigned long nr_segs , size_t to ) ;
__inline static struct cmsghdr  __attribute__((__always_inline__)) *__cmsg_nxthdr(void *__ctl ,
                                                                                  __kernel_size_t __size ,
                                                                                  struct cmsghdr *__cmsg ) 
{ struct cmsghdr *__ptr ;

  {
  __ptr = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(long )) -
                                                         1U) & ~ (sizeof(long ) -
                                                                  1U)));
  if ((unsigned long )((char *)(__ptr + 1) - (char *)__ctl) > (unsigned long )__size) {
    return ((struct cmsghdr  __attribute__((__always_inline__)) *)((struct cmsghdr *)0));
  }
  return ((struct cmsghdr  __attribute__((__always_inline__)) *)__ptr);
}
}
__inline static struct cmsghdr  __attribute__((__always_inline__)) *cmsg_nxthdr(struct msghdr *__msg ,
                                                                                struct cmsghdr *__cmsg ) 
{ struct cmsghdr  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
  return (tmp);
}
}
extern int memcpy_fromiovec(unsigned char *kdata , struct iovec *iov , int len ) ;
extern int memcpy_fromiovecend(unsigned char *kdata , struct iovec *iov , int offset ,
                               int len ) ;
extern int csum_partial_copy_fromiovecend(unsigned char *kdata , struct iovec *iov ,
                                          int offset , unsigned int len , int *csump ) ;
extern int verify_iovec(struct msghdr *m , struct iovec *iov , char *address , int mode ) ;
extern int memcpy_toiovec(struct iovec *v , unsigned char *kdata , int len ) ;
extern int move_addr_to_user(void *kaddr , int klen , void *uaddr , int *ulen ) ;
extern int move_addr_to_kernel(void *uaddr , int ulen , void *kaddr ) ;
extern int put_cmsg(struct msghdr * , int level , int type , int len , void *data ) ;
extern void global_flush_tlb(void) ;
extern int change_page_attr(struct page *page , int numpages , pgprot_t prot ) ;
extern unsigned long pgkern_mask ;
extern void flush_tlb_all(void) ;
extern void flush_tlb_current_task(void) ;
extern void flush_tlb_mm(struct mm_struct * ) ;
extern void flush_tlb_page(struct vm_area_struct * , unsigned long  ) ;
__inline static void __attribute__((__always_inline__))  flush_tlb_range(struct vm_area_struct *vma ,
                                                                         unsigned long start ,
                                                                         unsigned long end ) 
{ 

  {
  flush_tlb_mm(vma->vm_mm);
  return;
}
}
extern struct tlb_state per_cpu__cpu_tlbstate ;
__inline static void __attribute__((__always_inline__))  flush_tlb_pgtables(struct mm_struct *mm ,
                                                                            unsigned long start ,
                                                                            unsigned long end ) 
{ 

  {
  return;
}
}
extern unsigned long highstart_pfn ;
extern unsigned long highend_pfn ;
extern pte_t *kmap_pte ;
extern pgprot_t kmap_prot ;
extern pte_t *pkmap_page_table ;
extern void *( __attribute__((__regparm__(3))) kmap_high)(struct page *page ) ;
extern void ( __attribute__((__regparm__(3))) kunmap_high)(struct page *page ) ;
extern void *kmap(struct page *page ) ;
extern void kunmap(struct page *page ) ;
extern void *kmap_atomic(struct page *page , enum km_type type ) ;
extern void kunmap_atomic(void *kvaddr , enum km_type type ) ;
extern struct page *kmap_atomic_to_page(void *ptr ) ;
extern unsigned int nr_free_highpages(void) ;
__inline static void __attribute__((__always_inline__))  clear_user_highpage(struct page *page ,
                                                                             unsigned long vaddr ) 
{ void *addr ;
  void *tmp ;

  {
  tmp = kmap_atomic(page, 7);
  addr = tmp;
  __constant_c_and_count_memset(addr, 0UL, 4096U);
  kunmap_atomic(addr, 7);
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  clear_highpage(struct page *page ) 
{ void *kaddr ;
  void *tmp ;

  {
  tmp = kmap_atomic(page, 7);
  kaddr = tmp;
  __constant_c_and_count_memset(kaddr, 0UL, 4096U);
  kunmap_atomic(kaddr, 7);
  return;
}
}
__inline static void __attribute__((__always_inline__))  memclear_highpage_flush(struct page *page ,
                                                                                 unsigned int offset ,
                                                                                 unsigned int size ) 
{ void *kaddr ;
  long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! (((unsigned long )(offset + size) > 4096UL) !=
                                         0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (72), "i" ("include/linux/highmem.h"));
    }
    break;
  }
  kaddr = kmap_atomic(page, 7);
  __constant_c_memset((void *)((char *)kaddr + offset), 0UL, size);
  while (1) {
    break;
  }
  kunmap_atomic(kaddr, 7);
  return;
}
}
__inline static void __attribute__((__always_inline__))  copy_user_highpage(struct page *to ,
                                                                            struct page *from ,
                                                                            unsigned long vaddr ) 
{ char *vfrom ;
  char *vto ;

  {
  vfrom = (char *)kmap_atomic(from, 7);
  vto = (char *)kmap_atomic(to, 9);
  __constant_memcpy((void *)vto, (void const   *)((void *)vfrom), 4096U);
  kunmap_atomic((void *)vfrom, 7);
  kunmap_atomic((void *)vto, 9);
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  copy_highpage(struct page *to ,
                                                                       struct page *from ) 
{ char *vfrom ;
  char *vto ;

  {
  vfrom = (char *)kmap_atomic(from, 7);
  vto = (char *)kmap_atomic(to, 9);
  __constant_memcpy((void *)vto, (void const   *)((void *)vfrom), 4096U);
  kunmap_atomic((void *)vfrom, 7);
  kunmap_atomic((void *)vto, 9);
  return;
}
}
__inline static int __attribute__((__deprecated__, __always_inline__))  verify_area(int type ,
                                                                                    void const   *addr ,
                                                                                    unsigned long size ) 
{ unsigned long flag ;
  unsigned long sum ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned long flag___0 ;
  unsigned long sum___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  tmp___3 = current_thread_info();
  __asm__  ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag___0), "=r" (sum___0): "1" (addr),
            "g" ((int )size), "g" (tmp___3->addr_limit.seg));
  if (flag___0 == 0UL) {
    tmp___4 = 1;
  } else {
    tmp___4 = 0;
  }
  tmp___5 = __builtin_expect((long )tmp___4, 1L);
  if (tmp___5) {
    tmp___2 = 0;
  } else {
    tmp___2 = -14;
  }
  return ((int __attribute__((__deprecated__, __always_inline__))  )tmp___2);
}
}
extern int fixup_exception(struct pt_regs *regs ) ;
extern void __get_user_1(void) ;
extern void __get_user_2(void) ;
extern void __get_user_4(void) ;
extern void __put_user_bad(void) ;
extern void __put_user_1(void) ;
extern void __put_user_2(void) ;
extern void __put_user_4(void) ;
extern void __put_user_8(void) ;
extern long __get_user_bad(void) ;
extern unsigned long __copy_to_user_ll(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll(void *to , void const   *from , unsigned long n ) ;
__inline static unsigned long __attribute__((__always_inline__))  __copy_to_user_inatomic(void *to ,
                                                                                          void const   *from ,
                                                                                          unsigned long n ) 
{ unsigned long ret ;
  unsigned long __attribute__((__always_inline__))  tmp ;

  {
  if (0) {
    switch ((int )n) {
    case 1: ;
    while (1) {
      ret = 0UL;
      switch (1) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %"
                           "b"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "iq" ((*((u8 *)from))), "m" ((*((struct __large_struct *)((u8 *)to)))),
                           "i" (1), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %"
                           "w"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u8 *)from))), "m" ((*((struct __large_struct *)((u8 *)to)))),
                           "i" (1), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %"
                           ""
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u8 *)from))), "m" ((*((struct __large_struct *)((u8 *)to)))),
                           "i" (1), "0" (ret));
      break;
      case 8: 
      __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                           "2:\tmovl %%edx,4(%2)\n"
                           "3:\n"
                           ".section .fixup,\"ax\"\n"
                           "4:\tmovl %3,%0\n"
                           "\tjmp 3b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,4b\n"
                           "\t.long 2b,4b\n"
                           ".previous": "=r" (ret): "A" ((*((u8 *)from))), "r" ((u8 *)to),
                           "i" (-14), "0" (ret));
      break;
      default: 
      __put_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 2: ;
    while (1) {
      ret = 0UL;
      switch (2) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %"
                           "b"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "iq" ((*((u16 *)from))), "m" ((*((struct __large_struct *)((u16 *)to)))),
                           "i" (2), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %"
                           "w"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u16 *)from))), "m" ((*((struct __large_struct *)((u16 *)to)))),
                           "i" (2), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %"
                           ""
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u16 *)from))), "m" ((*((struct __large_struct *)((u16 *)to)))),
                           "i" (2), "0" (ret));
      break;
      case 8: 
      __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                           "2:\tmovl %%edx,4(%2)\n"
                           "3:\n"
                           ".section .fixup,\"ax\"\n"
                           "4:\tmovl %3,%0\n"
                           "\tjmp 3b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,4b\n"
                           "\t.long 2b,4b\n"
                           ".previous": "=r" (ret): "A" ((*((u16 *)from))), "r" ((u16 *)to),
                           "i" (-14), "0" (ret));
      break;
      default: 
      __put_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 4: ;
    while (1) {
      ret = 0UL;
      switch (4) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %"
                           "b"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "iq" ((*((u32 *)from))), "m" ((*((struct __large_struct *)((u32 *)to)))),
                           "i" (4), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %"
                           "w"
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u32 *)from))), "m" ((*((struct __large_struct *)((u32 *)to)))),
                           "i" (4), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %"
                           ""
                           "1,%2\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret): "ir" ((*((u32 *)from))), "m" ((*((struct __large_struct *)((u32 *)to)))),
                           "i" (4), "0" (ret));
      break;
      case 8: 
      __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                           "2:\tmovl %%edx,4(%2)\n"
                           "3:\n"
                           ".section .fixup,\"ax\"\n"
                           "4:\tmovl %3,%0\n"
                           "\tjmp 3b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,4b\n"
                           "\t.long 2b,4b\n"
                           ".previous": "=r" (ret): "A" ((*((u32 *)from))), "r" ((u32 *)to),
                           "i" (-14), "0" (ret));
      break;
      default: 
      __put_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    }
  }
  tmp = (unsigned long __attribute__((__always_inline__))  )__copy_to_user_ll(to,
                                                                              from,
                                                                              n);
  return (tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __copy_to_user(void *to ,
                                                                                 void const   *from ,
                                                                                 unsigned long n ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = __copy_to_user_inatomic(to, from, n);
  return (tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __copy_from_user_inatomic(void *to ,
                                                                                            void const   *from ,
                                                                                            unsigned long n ) 
{ unsigned long ret ;
  unsigned long __attribute__((__always_inline__))  tmp ;

  {
  if (0) {
    switch ((int )n) {
    case 1: ;
    while (1) {
      ret = 0UL;
      switch (1) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %2,%"
                           "b"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "b"
                           " %"
                           "b"
                           "1,%"
                           "b"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=q" ((*((u8 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (1), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %2,%"
                           "w"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "w"
                           " %"
                           "w"
                           "1,%"
                           "w"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u8 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (1), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %2,%"
                           ""
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "l"
                           " %"
                           ""
                           "1,%"
                           ""
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u8 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (1), "0" (ret));
      break;
      default: 
      (*((u8 *)to)) = (u8 )__get_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 2: ;
    while (1) {
      ret = 0UL;
      switch (2) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %2,%"
                           "b"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "b"
                           " %"
                           "b"
                           "1,%"
                           "b"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=q" ((*((u16 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (2), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %2,%"
                           "w"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "w"
                           " %"
                           "w"
                           "1,%"
                           "w"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u16 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (2), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %2,%"
                           ""
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "l"
                           " %"
                           ""
                           "1,%"
                           ""
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u16 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (2), "0" (ret));
      break;
      default: 
      (*((u16 *)to)) = (u16 )__get_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    case 4: ;
    while (1) {
      ret = 0UL;
      switch (4) {
      case 1: 
      __asm__  volatile   ("1:\tmov"
                           "b"
                           " %2,%"
                           "b"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "b"
                           " %"
                           "b"
                           "1,%"
                           "b"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=q" ((*((u32 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (4), "0" (ret));
      break;
      case 2: 
      __asm__  volatile   ("1:\tmov"
                           "w"
                           " %2,%"
                           "w"
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "w"
                           " %"
                           "w"
                           "1,%"
                           "w"
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u32 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (4), "0" (ret));
      break;
      case 4: 
      __asm__  volatile   ("1:\tmov"
                           "l"
                           " %2,%"
                           ""
                           "1\n"
                           "2:\n"
                           ".section .fixup,\"ax\"\n"
                           "3:\tmovl %3,%0\n"
                           "\txor"
                           "l"
                           " %"
                           ""
                           "1,%"
                           ""
                           "1\n"
                           "\tjmp 2b\n"
                           ".previous\n"
                           ".section __ex_table,\"a\"\n"
                           "\t.align 4\n"
                           "\t.long 1b,3b\n"
                           ".previous": "=r" (ret), "=r" ((*((u32 *)to))): "m" ((*((struct __large_struct *)from))),
                           "i" (4), "0" (ret));
      break;
      default: 
      (*((u32 *)to)) = (u32 )__get_user_bad();
      }
      break;
    }
    return ((unsigned long __attribute__((__always_inline__))  )ret);
    }
  }
  tmp = (unsigned long __attribute__((__always_inline__))  )__copy_from_user_ll(to,
                                                                                from,
                                                                                n);
  return (tmp);
}
}
__inline static unsigned long __attribute__((__always_inline__))  __copy_from_user(void *to ,
                                                                                   void const   *from ,
                                                                                   unsigned long n ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = __copy_from_user_inatomic(to, from, n);
  return (tmp);
}
}
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
extern long strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long __strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long strnlen_user(char const   *str , long n ) ;
extern unsigned long clear_user(void *mem , unsigned long len ) ;
extern unsigned long __clear_user(void *mem , unsigned long len ) ;
__inline static void __attribute__((__always_inline__))  poll_wait(struct file *filp ,
                                                                   wait_queue_head_t *wait_address ,
                                                                   poll_table *p ) 
{ 

  {
  if (p) {
    if (wait_address) {
      ((*(p->qproc)))(filp, wait_address, p);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  init_poll_funcptr(poll_table *pt ,
                                                                           void (*qproc)(struct file * ,
                                                                                         wait_queue_head_t * ,
                                                                                         struct poll_table_struct * ) ) 
{ 

  {
  pt->qproc = qproc;
  return;
}
}
extern void poll_initwait(struct poll_wqueues *pwq ) ;
extern void poll_freewait(struct poll_wqueues *pwq ) ;
__inline static int __attribute__((__always_inline__))  get_fd_set(unsigned long nr ,
                                                                   void *ufdset ,
                                                                   unsigned long *fdset ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  nr = (((nr + (unsigned long )(8U * sizeof(long ))) - 1UL) / (unsigned long )(8U *
                                                                               sizeof(long ))) *
       (unsigned long )sizeof(long );
  if (ufdset) {
    tmp___1 = copy_from_user((void *)fdset, (void const   *)ufdset, nr);
    if (tmp___1) {
      tmp___0 = -14;
    } else {
      tmp___0 = 0;
    }
    return ((int __attribute__((__always_inline__))  )tmp___0);
  }
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )nr);
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static unsigned long __attribute__((__always_inline__))  set_fd_set(unsigned long nr ,
                                                                             void *ufdset ,
                                                                             unsigned long *fdset ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;

  {
  if (ufdset) {
    tmp = __copy_to_user(ufdset, (void const   *)fdset, (((nr + (unsigned long )(8U *
                                                                                 sizeof(long ))) -
                                                          1UL) / (unsigned long )(8U *
                                                                                  sizeof(long ))) *
                                                        (unsigned long )sizeof(long ));
    return (tmp);
  }
  return ((unsigned long __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  zero_fd_set(unsigned long nr ,
                                                                     unsigned long *fdset ) 
{ 

  {
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )((((nr + (unsigned long )(8U *
                                                                                   sizeof(long ))) -
                                                            1UL) / (unsigned long )(8U *
                                                                                    sizeof(long ))) *
                                                          (unsigned long )sizeof(long )));
  return;
}
}
extern int do_select(int n , fd_set_bits *fds , long *timeout ) ;
extern int sock_wake_async(struct socket *sk , int how , int band ) ;
extern int sock_register(struct net_proto_family *fam ) ;
extern int sock_unregister(int family ) ;
extern int sock_create(int family , int type , int proto , struct socket **res ) ;
extern int sock_create_kern(int family , int type , int proto , struct socket **res ) ;
extern int sock_create_lite(int family , int type , int proto , struct socket **res ) ;
extern void sock_release(struct socket *sock ) ;
extern int sock_sendmsg(struct socket *sock , struct msghdr *msg , size_t len ) ;
extern int sock_recvmsg(struct socket *sock , struct msghdr *msg , size_t size , int flags ) ;
extern int sock_map_fd(struct socket *sock ) ;
extern struct socket *sockfd_lookup(int fd , int *err ) ;
extern int net_ratelimit(void) ;
extern unsigned long net_random(void) ;
extern void net_srandom(unsigned long  ) ;
extern void net_random_init(void) ;
extern int kernel_sendmsg(struct socket *sock , struct msghdr *msg , struct kvec *vec ,
                          size_t num , size_t len ) ;
extern int kernel_recvmsg(struct socket *sock , struct msghdr *msg , struct kvec *vec ,
                          size_t num , size_t len , int flags ) ;
extern struct in6_addr  const  in6addr_loopback ;
extern unsigned int ( __attribute__((__regparm__(0))) csum_partial)(unsigned char const   *buff ,
                                                                    int len , unsigned int sum ) ;
extern unsigned int ( __attribute__((__regparm__(0))) csum_partial_copy_generic)(unsigned char const   *src ,
                                                                                 unsigned char *dst ,
                                                                                 int len ,
                                                                                 int sum ,
                                                                                 int *src_err_ptr ,
                                                                                 int *dst_err_ptr ) ;
__inline static unsigned int __attribute__((__always_inline__))  csum_partial_copy_nocheck(unsigned char const   *src ,
                                                                                           unsigned char *dst ,
                                                                                           int len ,
                                                                                           int sum ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (unsigned int __attribute__((__always_inline__))  )csum_partial_copy_generic(src,
                                                                                     dst,
                                                                                     len,
                                                                                     sum,
                                                                                     (int *)((void *)0),
                                                                                     (int *)((void *)0));
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_partial_copy_from_user(unsigned char const   *src ,
                                                                                             unsigned char *dst ,
                                                                                             int len ,
                                                                                             int sum ,
                                                                                             int *err_ptr ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  while (1) {
    break;
  }
  tmp = (unsigned int __attribute__((__always_inline__))  )csum_partial_copy_generic((unsigned char const   *)((unsigned char *)src),
                                                                                     dst,
                                                                                     len,
                                                                                     sum,
                                                                                     err_ptr,
                                                                                     (int *)((void *)0));
  return (tmp);
}
}
__inline static unsigned short __attribute__((__always_inline__))  ip_fast_csum(unsigned char *iph ,
                                                                                unsigned int ihl ) 
{ unsigned int sum ;

  {
  __asm__  volatile   ("movl (%1), %0\t;\n"
                       "subl $4, %2\t;\n"
                       "jbe 2f\t\t;\n"
                       "addl 4(%1), %0\t;\n"
                       "adcl 8(%1), %0\t;\n"
                       "adcl 12(%1), %0\t;\n"
                       "1:\t    adcl 16(%1), %0\t;\n"
                       "lea 4(%1), %1\t;\n"
                       "decl %2\t\t;\n"
                       "jne 1b\t\t;\n"
                       "adcl $0, %0\t;\n"
                       "movl %0, %2\t;\n"
                       "shrl $16, %0\t;\n"
                       "addw %w2, %w0\t;\n"
                       "adcl $0, %0\t;\n"
                       "notl %0\t\t;\n"
                       "2:\t\t\t\t;\n": "=r" (sum), "=r" (iph), "=r" (ihl): "1" (iph),
                       "2" (ihl): "memory");
  return ((unsigned short __attribute__((__always_inline__))  )sum);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_fold(unsigned int sum ) 
{ 

  {
  __asm__  ("addl %1, %0\t\t;\n"
            "adcl $0xffff, %0\t;\n": "=r" (sum): "r" (sum << 16), "0" (sum & 4294901760U));
  return ((unsigned int __attribute__((__always_inline__))  )(~ sum >> 16));
}
}
__inline static unsigned long __attribute__((__always_inline__))  csum_tcpudp_nofold(unsigned long saddr ,
                                                                                     unsigned long daddr ,
                                                                                     unsigned short len ,
                                                                                     unsigned short proto ,
                                                                                     unsigned int sum ) 
{ __u16 __x ;
  __u16 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __fswab16(len);
  __asm__  ("addl %1, %0\t;\n"
            "adcl %2, %0\t;\n"
            "adcl %3, %0\t;\n"
            "adcl $0, %0\t;\n": "=r" (sum): "g" (daddr), "g" (saddr), "g" (((int )tmp <<
                                                                            16) +
                                                                           (int )proto *
                                                                           256), "0" (sum));
  return ((unsigned long __attribute__((__always_inline__))  )sum);
}
}
__inline static unsigned short __attribute__((__always_inline__))  csum_tcpudp_magic(unsigned long saddr ,
                                                                                     unsigned long daddr ,
                                                                                     unsigned short len ,
                                                                                     unsigned short proto ,
                                                                                     unsigned int sum ) 
{ unsigned long __attribute__((__always_inline__))  tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = csum_tcpudp_nofold(saddr, daddr, len, proto, sum);
  tmp___0 = (unsigned short __attribute__((__always_inline__))  )csum_fold((unsigned int )tmp);
  return (tmp___0);
}
}
__inline static unsigned short __attribute__((__always_inline__))  ip_compute_csum(unsigned char *buff ,
                                                                                   int len ) 
{ unsigned int tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = csum_partial((unsigned char const   *)buff, len, 0U);
  tmp___0 = (unsigned short __attribute__((__always_inline__))  )csum_fold(tmp);
  return (tmp___0);
}
}
__inline static unsigned short __attribute__((__always_inline__))  csum_ipv6_magic(struct in6_addr *saddr ,
                                                                                   struct in6_addr *daddr ,
                                                                                   __u32 len ,
                                                                                   unsigned short proto ,
                                                                                   unsigned int sum ) 
{ __u32 __x ;
  __u32 __attribute__((__always_inline__))  tmp ;
  __u32 __x___0 ;
  __u32 __attribute__((__always_inline__))  tmp___0 ;
  unsigned short __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = __fswab32(len);
  tmp___0 = __fswab32((unsigned int )proto);
  __asm__  ("addl 0(%1), %0\t\t;\n"
            "adcl 4(%1), %0\t\t;\n"
            "adcl 8(%1), %0\t\t;\n"
            "adcl 12(%1), %0\t;\n"
            "adcl 0(%2), %0\t\t;\n"
            "adcl 4(%2), %0\t\t;\n"
            "adcl 8(%2), %0\t\t;\n"
            "adcl 12(%2), %0\t;\n"
            "adcl %3, %0\t\t;\n"
            "adcl %4, %0\t\t;\n"
            "adcl $0, %0\t\t;\n": "=&r" (sum): "r" (saddr), "r" (daddr), "r" (tmp),
            "r" (tmp___0), "0" (sum));
  tmp___1 = (unsigned short __attribute__((__always_inline__))  )csum_fold(sum);
  return (tmp___1);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_and_copy_to_user(unsigned char const   *src ,
                                                                                       unsigned char *dst ,
                                                                                       int len ,
                                                                                       int sum ,
                                                                                       int *err_ptr ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned long flag ;
  unsigned long sum___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  while (1) {
    break;
  }
  tmp___0 = current_thread_info();
  __asm__  ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum___0): "1" (dst),
            "g" (len), "g" (tmp___0->addr_limit.seg));
  if (flag == 0UL) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {
    tmp = (unsigned int __attribute__((__always_inline__))  )csum_partial_copy_generic(src,
                                                                                       dst,
                                                                                       len,
                                                                                       sum,
                                                                                       (int *)((void *)0),
                                                                                       err_ptr);
    return (tmp);
  }
  if (len) {
    (*err_ptr) = -14;
  }
  return ((unsigned int __attribute__((__always_inline__))  )-1);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_and_copy_from_user(unsigned char const   *src ,
                                                                                         unsigned char *dst ,
                                                                                         int len ,
                                                                                         int sum ,
                                                                                         int *err_ptr ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned long flag ;
  unsigned long sum___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp___0 = current_thread_info();
  __asm__  ("addl %3,%1 ; sbbl %0,%0; cmpl %1,%4; sbbl $0,%0": "=&r" (flag), "=r" (sum___0): "1" (src),
            "g" (len), "g" (tmp___0->addr_limit.seg));
  if (flag == 0UL) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {
    tmp = csum_partial_copy_from_user(src, dst, len, sum, err_ptr);
    return (tmp);
  }
  if (len) {
    (*err_ptr) = -14;
  }
  return ((unsigned int __attribute__((__always_inline__))  )sum);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_add(unsigned int csum ,
                                                                          unsigned int addend ) 
{ 

  {
  csum += addend;
  return ((unsigned int __attribute__((__always_inline__))  )(csum + (unsigned int )(csum <
                                                                                     addend)));
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_sub(unsigned int csum ,
                                                                          unsigned int addend ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  tmp = csum_add(csum, ~ addend);
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_block_add(unsigned int csum ,
                                                                                unsigned int csum2 ,
                                                                                int offset ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  if (offset & 1) {
    csum2 = ((csum2 & 16711935U) << 8) + ((csum2 >> 8) & 16711935U);
  }
  tmp = csum_add(csum, csum2);
  return (tmp);
}
}
__inline static unsigned int __attribute__((__always_inline__))  csum_block_sub(unsigned int csum ,
                                                                                unsigned int csum2 ,
                                                                                int offset ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;

  {
  if (offset & 1) {
    csum2 = ((csum2 & 16711935U) << 8) + ((csum2 >> 8) & 16711935U);
  }
  tmp = csum_sub(csum, csum2);
  return (tmp);
}
}
extern void __kfree_skb(struct sk_buff *skb ) ;
extern struct sk_buff *alloc_skb(unsigned int size , int priority ) ;
extern struct sk_buff *alloc_skb_from_cache(kmem_cache_t *cp , unsigned int size ,
                                            int priority ) ;
extern void kfree_skbmem(struct sk_buff *skb ) ;
extern struct sk_buff *skb_clone(struct sk_buff *skb , int priority ) ;
extern struct sk_buff *skb_copy(struct sk_buff  const  *skb , int priority ) ;
extern struct sk_buff *pskb_copy(struct sk_buff *skb , int gfp_mask ) ;
extern int pskb_expand_head(struct sk_buff *skb , int nhead , int ntail , int gfp_mask ) ;
extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb , unsigned int headroom ) ;
extern struct sk_buff *skb_copy_expand(struct sk_buff  const  *skb , int newheadroom ,
                                       int newtailroom , int priority ) ;
extern struct sk_buff *skb_pad(struct sk_buff *skb , int pad ) ;
extern void skb_over_panic(struct sk_buff *skb , int len , void *here ) ;
extern void skb_under_panic(struct sk_buff *skb , int len , void *here ) ;
__inline static int __attribute__((__always_inline__))  skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )((unsigned int )list->next ==
                                                     (unsigned int )((struct sk_buff *)list)));
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_get(struct sk_buff *skb ) 
{ 

  {
  atomic_inc(& skb->users);
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static void __attribute__((__always_inline__))  kfree_skb(struct sk_buff *skb ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  tmp___2 = __builtin_expect((long )(! (! (skb->users.counter == 1)) != 0), 1L);
  if (tmp___2) {
    __asm__  volatile   ("661:\n\t"
                         "lock; addl $0,0(%%esp)"
                         "\n662:\n"
                         ".section .altinstructions,\"a\"\n"
                         "  .align 4\n"
                         "  .long 661b\n"
                         "  .long 663f\n"
                         "  .byte %c0\n"
                         "  .byte 662b-661b\n"
                         "  .byte 664f-663f\n"
                         ".previous\n"
                         ".section .altinstr_replacement,\"ax\"\n"
                         "663:\n\t"
                         "lfence"
                         "\n664:\n"
                         ".previous": : "i" (26): "memory");
  } else {
    tmp = atomic_dec_and_test(& skb->users);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    tmp___1 = __builtin_expect((long )tmp___0, 1L);
    if (tmp___1) {
      return;
    }
  }
  __kfree_skb(skb);
  return;
}
}
__inline static int __attribute__((__always_inline__))  skb_cloned(struct sk_buff  const  *skb ) 
{ int tmp ;

  {
  if (skb->cloned) {
    if ((((struct skb_shared_info *)skb->end)->dataref.counter & 65535) != 1) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp);
}
}
__inline static int __attribute__((__always_inline__))  skb_header_cloned(struct sk_buff  const  *skb ) 
{ int dataref ;

  {
  if (! skb->cloned) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  dataref = (int )((struct skb_shared_info *)skb->end)->dataref.counter;
  dataref = (dataref & 65535) - (dataref >> 16);
  return ((int __attribute__((__always_inline__))  )(dataref != 1));
}
}
__inline static void __attribute__((__always_inline__))  skb_header_release(struct sk_buff *skb ) 
{ long tmp ;

  {
  while (1) {
    tmp = __builtin_expect((long )(! (! ((int )skb->nohdr != 0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (419), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->nohdr = (unsigned char)1;
  atomic_add(65536, & ((struct skb_shared_info *)skb->end)->dataref);
  return;
}
}
__inline static int __attribute__((__always_inline__))  skb_shared(struct sk_buff  const  *skb ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(skb->users.counter != 1));
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_share_check(struct sk_buff *skb ,
                                                                                    int pri ) 
{ struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    break;
  }
  tmp___0 = skb_shared((struct sk_buff  const  *)skb);
  if (tmp___0) {
    tmp = skb_clone(skb, pri);
    nskb = tmp;
    kfree_skb(skb);
    skb = nskb;
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_unshare(struct sk_buff *skb ,
                                                                                int pri ) 
{ struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    break;
  }
  tmp___0 = skb_cloned((struct sk_buff  const  *)skb);
  if (tmp___0) {
    tmp = skb_copy((struct sk_buff  const  *)skb, pri);
    nskb = tmp;
    kfree_skb(skb);
    skb = nskb;
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_peek(struct sk_buff_head *list_ ) 
{ struct sk_buff *list ;

  {
  list = ((struct sk_buff *)list_)->next;
  if ((unsigned int )list == (unsigned int )((struct sk_buff *)list_)) {
    list = (struct sk_buff *)((void *)0);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)list);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_peek_tail(struct sk_buff_head *list_ ) 
{ struct sk_buff *list ;

  {
  list = ((struct sk_buff *)list_)->prev;
  if ((unsigned int )list == (unsigned int )((struct sk_buff *)list_)) {
    list = (struct sk_buff *)((void *)0);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)list);
}
}
__inline static __u32 __attribute__((__always_inline__))  skb_queue_len(struct sk_buff_head  const  *list_ ) 
{ 

  {
  return (list_->qlen);
}
}
__inline static void __attribute__((__always_inline__))  skb_queue_head_init(struct sk_buff_head *list ) 
{ spinlock_t __constr_expr_0 ;

  {
  while (1) {
    spin_lock_init(&__constr_expr_0);
    list->lock = __constr_expr_0;
    break;
  }
  list->next = (struct sk_buff *)list;
  list->prev = list->next;
  list->qlen = 0U;
  return;
}
}
extern void skb_queue_head(struct sk_buff_head *list , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_queue_head(struct sk_buff_head *list ,
                                                                          struct sk_buff *newsk ) 
{ struct sk_buff *prev ;
  struct sk_buff *next ;

  {
  newsk->list = list;
  list->qlen ++;
  prev = (struct sk_buff *)list;
  next = prev->next;
  newsk->next = next;
  newsk->prev = prev;
  prev->next = newsk;
  next->prev = prev->next;
  return;
}
}
extern void skb_queue_tail(struct sk_buff_head *list , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_queue_tail(struct sk_buff_head *list ,
                                                                          struct sk_buff *newsk ) 
{ struct sk_buff *prev ;
  struct sk_buff *next ;

  {
  newsk->list = list;
  list->qlen ++;
  next = (struct sk_buff *)list;
  prev = next->prev;
  newsk->next = next;
  newsk->prev = prev;
  prev->next = newsk;
  next->prev = prev->next;
  return;
}
}
extern struct sk_buff *skb_dequeue(struct sk_buff_head *list ) ;
__inline static struct sk_buff  __attribute__((__always_inline__)) *__skb_dequeue(struct sk_buff_head *list ) 
{ struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *result ;

  {
  prev = (struct sk_buff *)list;
  next = prev->next;
  result = (struct sk_buff *)((void *)0);
  if ((unsigned int )next != (unsigned int )prev) {
    result = next;
    next = next->next;
    list->qlen --;
    next->prev = prev;
    prev->next = next;
    result->prev = (struct sk_buff *)((void *)0);
    result->next = result->prev;
    result->list = (struct sk_buff_head *)((void *)0);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)result);
}
}
extern void skb_insert(struct sk_buff *old , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_insert(struct sk_buff *newsk ,
                                                                      struct sk_buff *prev ,
                                                                      struct sk_buff *next ,
                                                                      struct sk_buff_head *list ) 
{ 

  {
  newsk->next = next;
  newsk->prev = prev;
  prev->next = newsk;
  next->prev = prev->next;
  newsk->list = list;
  list->qlen ++;
  return;
}
}
extern void skb_append(struct sk_buff *old , struct sk_buff *newsk ) ;
__inline static void __attribute__((__always_inline__))  __skb_append(struct sk_buff *old ,
                                                                      struct sk_buff *newsk ) 
{ 

  {
  __skb_insert(newsk, old, old->next, old->list);
  return;
}
}
extern void skb_unlink(struct sk_buff *skb ) ;
__inline static void __attribute__((__always_inline__))  __skb_unlink(struct sk_buff *skb ,
                                                                      struct sk_buff_head *list ) 
{ struct sk_buff *next ;
  struct sk_buff *prev ;

  {
  list->qlen --;
  next = skb->next;
  prev = skb->prev;
  skb->prev = (struct sk_buff *)((void *)0);
  skb->next = skb->prev;
  skb->list = (struct sk_buff_head *)((void *)0);
  next->prev = prev;
  prev->next = next;
  return;
}
}
extern struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list ) ;
__inline static struct sk_buff  __attribute__((__always_inline__)) *__skb_dequeue_tail(struct sk_buff_head *list ) 
{ struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  tmp = (struct sk_buff *)skb_peek_tail(list);
  skb = tmp;
  if (skb) {
    __skb_unlink(skb, list);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static int __attribute__((__always_inline__))  skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )skb->data_len);
}
}
__inline static unsigned int __attribute__((__always_inline__))  skb_headlen(struct sk_buff  const  *skb ) 
{ 

  {
  return ((unsigned int __attribute__((__always_inline__))  )(skb->len - skb->data_len));
}
}
__inline static int __attribute__((__always_inline__))  skb_pagelen(struct sk_buff  const  *skb ) 
{ int i ;
  int len ;
  unsigned int __attribute__((__always_inline__))  tmp ;

  {
  len = 0;
  i = (int )((struct skb_shared_info *)skb->end)->nr_frags - 1;
  while (i >= 0) {
    len += (int )((struct skb_shared_info *)skb->end)->frags[i].size;
    i --;
  }
  tmp = skb_headlen(skb);
  return ((int __attribute__((__always_inline__))  )((unsigned int __attribute__((__always_inline__))  )len +
                                                     tmp));
}
}
__inline static void __attribute__((__always_inline__))  skb_fill_page_desc(struct sk_buff *skb ,
                                                                            int i ,
                                                                            struct page *page ,
                                                                            int off ,
                                                                            int size ) 
{ skb_frag_t *frag ;

  {
  frag = & ((struct skb_shared_info *)skb->end)->frags[i];
  frag->page = page;
  frag->page_offset = (unsigned short )off;
  frag->size = (unsigned short )size;
  ((struct skb_shared_info *)skb->end)->nr_frags = (unsigned int )(i + 1);
  return;
}
}
__inline static unsigned char __attribute__((__always_inline__))  *__skb_put(struct sk_buff *skb ,
                                                                             unsigned int len ) 
{ unsigned char *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = skb->tail;
  while (1) {
    tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    if (tmp___2) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (741), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->tail += len;
  skb->len += len;
  return ((unsigned char __attribute__((__always_inline__))  *)tmp);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *skb_put(struct sk_buff *skb ,
                                                                           unsigned int len ) 
{ unsigned char *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  void *pc ;
  long tmp___3 ;

  {
  tmp = skb->tail;
  while (1) {
    tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    if (tmp___2) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (759), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->tail += len;
  skb->len += len;
  tmp___3 = __builtin_expect((long )(! (! ((unsigned int )skb->tail > (unsigned int )skb->end)) !=
                                     0), 0L);
  if (tmp___3) {
    __asm__  ("movl $1f,%0\n1:": "=g" (pc));
    skb_over_panic(skb, (int )len, pc);
  }
  return ((unsigned char __attribute__((__always_inline__))  *)tmp);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *__skb_push(struct sk_buff *skb ,
                                                                              unsigned int len ) 
{ 

  {
  skb->data -= len;
  skb->len += len;
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *skb_push(struct sk_buff *skb ,
                                                                            unsigned int len ) 
{ void *pc ;
  long tmp ;

  {
  skb->data -= len;
  skb->len += len;
  tmp = __builtin_expect((long )(! (! ((unsigned int )skb->data < (unsigned int )skb->head)) !=
                                 0), 0L);
  if (tmp) {
    __asm__  ("movl $1f,%0\n1:": "=g" (pc));
    skb_under_panic(skb, (int )len, pc);
  }
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *__skb_pull(struct sk_buff *skb ,
                                                                              unsigned int len ) 
{ long tmp ;

  {
  skb->len -= len;
  while (1) {
    tmp = __builtin_expect((long )(! (! ((skb->len < skb->data_len) != 0)) != 0),
                           0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (795), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  skb->data += len;
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *skb_pull(struct sk_buff *skb ,
                                                                            unsigned int len ) 
{ long tmp ;
  unsigned char __attribute__((__always_inline__))  *tmp___0 ;
  unsigned char __attribute__((__always_inline__))  *tmp___1 ;
  long tmp___2 ;

  {
  tmp___2 = __builtin_expect((long )(! (! (len > skb->len)) != 0), 0L);
  if (tmp___2) {
    tmp___1 = (unsigned char __attribute__((__always_inline__))  *)((void *)0);
  } else {
    tmp___1 = __skb_pull(skb, len);
  }
  return (tmp___1);
}
}
extern unsigned char *__pskb_pull_tail(struct sk_buff *skb , int delta ) ;
__inline static unsigned char __attribute__((__always_inline__))  *__pskb_pull(struct sk_buff *skb ,
                                                                               unsigned int len ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  unsigned int __attribute__((__always_inline__))  tmp___0 ;
  unsigned char *tmp___1 ;

  {
  tmp = skb_headlen((struct sk_buff  const  *)skb);
  if (len > (unsigned int )tmp) {
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
    tmp___1 = __pskb_pull_tail(skb, (int )(len - (unsigned int )tmp___0));
    if (! tmp___1) {
      return ((unsigned char __attribute__((__always_inline__))  *)((void *)0));
    }
  }
  skb->len -= len;
  skb->data += len;
  return ((unsigned char __attribute__((__always_inline__))  *)skb->data);
}
}
__inline static unsigned char __attribute__((__always_inline__))  *pskb_pull(struct sk_buff *skb ,
                                                                             unsigned int len ) 
{ long tmp ;
  unsigned char __attribute__((__always_inline__))  *tmp___0 ;
  unsigned char __attribute__((__always_inline__))  *tmp___1 ;
  long tmp___2 ;

  {
  tmp___2 = __builtin_expect((long )(! (! (len > skb->len)) != 0), 0L);
  if (tmp___2) {
    tmp___1 = (unsigned char __attribute__((__always_inline__))  *)((void *)0);
  } else {
    tmp___1 = __pskb_pull(skb, len);
  }
  return (tmp___1);
}
}
__inline static int __attribute__((__always_inline__))  pskb_may_pull(struct sk_buff *skb ,
                                                                      unsigned int len ) 
{ unsigned int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned int __attribute__((__always_inline__))  tmp___3 ;
  unsigned char *tmp___4 ;

  {
  tmp = skb_headlen((struct sk_buff  const  *)skb);
  if (len <= (unsigned int )tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  tmp___2 = __builtin_expect((long )(! (! (len > skb->len)) != 0), 0L);
  if (tmp___2) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp___3 = skb_headlen((struct sk_buff  const  *)skb);
  tmp___4 = __pskb_pull_tail(skb, (int )(len - (unsigned int )tmp___3));
  return ((int __attribute__((__always_inline__))  )((unsigned int )tmp___4 != (unsigned int )((void *)0)));
}
}
__inline static int __attribute__((__always_inline__))  skb_headroom(struct sk_buff  const  *skb ) 
{ 

  {
  return ((int __attribute__((__always_inline__))  )(skb->data - skb->head));
}
}
__inline static int __attribute__((__always_inline__))  skb_tailroom(struct sk_buff  const  *skb ) 
{ int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp___1 = skb_is_nonlinear(skb);
  if (tmp___1) {
    tmp___0 = 0;
  } else {
    tmp___0 = skb->end - skb->tail;
  }
  return ((int __attribute__((__always_inline__))  )tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  skb_reserve(struct sk_buff *skb ,
                                                                     unsigned int len ) 
{ 

  {
  skb->data += len;
  skb->tail += len;
  return;
}
}
extern int ___pskb_trim(struct sk_buff *skb , unsigned int len , int realloc ) ;
__inline static void __attribute__((__always_inline__))  __skb_trim(struct sk_buff *skb ,
                                                                    unsigned int len ) 
{ 

  {
  if (! skb->data_len) {
    skb->len = len;
    skb->tail = skb->data + len;
  } else {
    ___pskb_trim(skb, len, 0);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  skb_trim(struct sk_buff *skb ,
                                                                  unsigned int len ) 
{ 

  {
  if (skb->len > len) {
    __skb_trim(skb, len);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  __pskb_trim(struct sk_buff *skb ,
                                                                    unsigned int len ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (! skb->data_len) {
    skb->len = len;
    skb->tail = skb->data + len;
    return ((int __attribute__((__always_inline__))  )0);
  }
  tmp = (int __attribute__((__always_inline__))  )___pskb_trim(skb, len, 1);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  pskb_trim(struct sk_buff *skb ,
                                                                  unsigned int len ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  if (len < skb->len) {
    tmp___0 = __pskb_trim(skb, len);
  } else {
    tmp___0 = (int __attribute__((__always_inline__))  )0;
  }
  return (tmp___0);
}
}
__inline static void __attribute__((__always_inline__))  skb_orphan(struct sk_buff *skb ) 
{ 

  {
  if (skb->destructor) {
    ((*(skb->destructor)))(skb);
  }
  skb->destructor = (void (*)(struct sk_buff *skb ))((void *)0);
  skb->sk = (struct sock *)((void *)0);
  return;
}
}
extern void skb_queue_purge(struct sk_buff_head *list ) ;
__inline static void __attribute__((__always_inline__))  __skb_queue_purge(struct sk_buff_head *list ) 
{ struct sk_buff *skb ;

  {
  while (1) {
    skb = (struct sk_buff *)__skb_dequeue(list);
    if (! ((unsigned int )skb != (unsigned int )((void *)0))) {
      break;
    }
    kfree_skb(skb);
  }
  return;
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *__dev_alloc_skb(unsigned int length ,
                                                                                    int gfp_mask ) 
{ struct sk_buff *skb ;
  struct sk_buff *tmp ;
  long tmp___0 ;

  {
  tmp = alloc_skb(length + 16U, gfp_mask);
  skb = tmp;
  tmp___0 = __builtin_expect((long )(! (! skb) != 0), 1L);
  if (tmp___0) {
    skb_reserve(skb, 16U);
  }
  return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *dev_alloc_skb(unsigned int length ) 
{ struct sk_buff  __attribute__((__always_inline__)) *tmp ;

  {
  tmp = __dev_alloc_skb(length, 32);
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  skb_cow(struct sk_buff *skb ,
                                                                unsigned int headroom ) 
{ int delta ;
  unsigned int tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int __attribute__((__always_inline__))  tmp___1 ;
  int __attribute__((__always_inline__))  tmp___2 ;

  {
  if (headroom > 16U) {
    tmp = headroom;
  } else {
    tmp = 16U;
  }
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
  delta = (int )(tmp - (unsigned int )tmp___0);
  if (delta < 0) {
    delta = 0;
  }
  if (delta) {
    tmp___1 = (int __attribute__((__always_inline__))  )pskb_expand_head(skb, (delta +
                                                                               15) &
                                                                              -16,
                                                                         0, 32);
    return (tmp___1);
  } else {
    tmp___2 = skb_cloned((struct sk_buff  const  *)skb);
    if (tmp___2) {
      tmp___1 = (int __attribute__((__always_inline__))  )pskb_expand_head(skb, (delta +
                                                                                 15) &
                                                                                -16,
                                                                           0, 32);
      return (tmp___1);
    }
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static struct sk_buff  __attribute__((__always_inline__)) *skb_padto(struct sk_buff *skb ,
                                                                              unsigned int len ) 
{ unsigned int size ;
  long tmp ;
  struct sk_buff  __attribute__((__always_inline__)) *tmp___0 ;

  {
  size = skb->len;
  tmp = __builtin_expect((long )(! (! (size >= len)) != 0), 1L);
  if (tmp) {
    return ((struct sk_buff  __attribute__((__always_inline__)) *)skb);
  }
  tmp___0 = (struct sk_buff  __attribute__((__always_inline__)) *)skb_pad(skb, (int )(len -
                                                                                      size));
  return (tmp___0);
}
}
__inline static int __attribute__((__always_inline__))  skb_add_data(struct sk_buff *skb ,
                                                                     char *from ,
                                                                     int copy ) 
{ int off ;
  int err ;
  unsigned int csum ;
  unsigned char __attribute__((__always_inline__))  *tmp ;
  unsigned int tmp___0 ;
  unsigned char __attribute__((__always_inline__))  *tmp___1 ;
  unsigned long tmp___2 ;

  {
  off = (int )skb->len;
  if ((int )skb->ip_summed == 0) {
    err = 0;
    tmp = skb_put(skb, (unsigned int )copy);
    tmp___0 = (unsigned int )csum_and_copy_from_user((unsigned char const   *)from,
                                                     (unsigned char *)tmp, copy, 0,
                                                     & err);
    csum = tmp___0;
    if (! err) {
      skb->csum = (unsigned int )csum_block_add(skb->csum, csum, off);
      return ((int __attribute__((__always_inline__))  )0);
    }
  } else {
    tmp___1 = skb_put(skb, (unsigned int )copy);
    tmp___2 = copy_from_user((void *)tmp___1, (void const   *)from, (unsigned long )copy);
    if (! tmp___2) {
      return ((int __attribute__((__always_inline__))  )0);
    }
  }
  __skb_trim(skb, (unsigned int )off);
  return ((int __attribute__((__always_inline__))  )-14);
}
}
__inline static int __attribute__((__always_inline__))  skb_can_coalesce(struct sk_buff *skb ,
                                                                         int i , struct page *page ,
                                                                         int off ) 
{ struct skb_frag_struct *frag ;
  int tmp ;

  {
  if (i) {
    frag = & ((struct skb_shared_info *)skb->end)->frags[i - 1];
    if ((unsigned int )page == (unsigned int )frag->page) {
      if (off == (int )frag->page_offset + (int )frag->size) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    return ((int __attribute__((__always_inline__))  )tmp);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
extern int __skb_linearize(struct sk_buff *skb , int gfp ) ;
__inline static int __attribute__((__always_inline__))  skb_linearize(struct sk_buff *skb ,
                                                                      int gfp ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )__skb_linearize(skb, gfp);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  skb_postpull_rcsum(struct sk_buff *skb ,
                                                                            void const   *start ,
                                                                            int len ) 
{ unsigned int tmp ;

  {
  if ((int )skb->ip_summed == 1) {
    tmp = csum_partial((unsigned char const   *)start, len, 0U);
    skb->csum = (unsigned int )csum_sub(skb->csum, tmp);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  pskb_trim_rcsum(struct sk_buff *skb ,
                                                                        unsigned int len ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (len >= skb->len) {
    return ((int __attribute__((__always_inline__))  )0);
  }
  if ((int )skb->ip_summed == 1) {
    skb->ip_summed = (unsigned char)0;
  }
  tmp = __pskb_trim(skb, len);
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  *kmap_skb_frag(skb_frag_t const   *frag ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___2 ;
  void __attribute__((__always_inline__))  *tmp___3 ;

  {
  while (1) {
    tmp = current_thread_info();
    if (((unsigned long )tmp->preempt_count & 268369920UL) != 0UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    if (tmp___1) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (1144), "i" ("include/linux/skbuff.h"));
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___2 = current_thread_info();
      tmp___2->preempt_count = (int )((unsigned long )tmp___2->preempt_count + 256UL);
      break;
    }
    __asm__  volatile   ("": : : "memory");
    break;
  }
  tmp___3 = (void __attribute__((__always_inline__))  *)kmap_atomic((struct page *)frag->page,
                                                                    5);
  return (tmp___3);
}
}
__inline static void __attribute__((__always_inline__))  kunmap_skb_frag(void *vaddr ) 
{ 

  {
  kunmap_atomic(vaddr, 5);
  local_bh_enable();
  return;
}
}
extern struct sk_buff *skb_recv_datagram(struct sock *sk , unsigned int flags , int noblock ,
                                         int *err ) ;
extern unsigned int datagram_poll(struct file *file , struct socket *sock , struct poll_table_struct *wait ) ;
extern int skb_copy_datagram_iovec(struct sk_buff  const  *from , int offset , struct iovec *to ,
                                   int size ) ;
extern int skb_copy_and_csum_datagram_iovec(struct sk_buff  const  *skb , int hlen ,
                                            struct iovec *iov ) ;
extern void skb_free_datagram(struct sock *sk , struct sk_buff *skb ) ;
extern unsigned int skb_checksum(struct sk_buff  const  *skb , int offset , int len ,
                                 unsigned int csum ) ;
extern int skb_copy_bits(struct sk_buff  const  *skb , int offset , void *to , int len ) ;
extern int skb_store_bits(struct sk_buff  const  *skb , int offset , void *from ,
                          int len ) ;
extern unsigned int skb_copy_and_csum_bits(struct sk_buff  const  *skb , int offset ,
                                           u8 *to , int len , unsigned int csum ) ;
extern void skb_copy_and_csum_dev(struct sk_buff  const  *skb , u8 *to ) ;
extern void skb_split(struct sk_buff *skb , struct sk_buff *skb1 , u32 len ) ;
__inline static void __attribute__((__always_inline__))  *skb_header_pointer(struct sk_buff  const  *skb ,
                                                                             int offset ,
                                                                             int len ,
                                                                             void *buffer ) 
{ int hlen ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = (int )skb_headlen(skb);
  hlen = tmp;
  if (offset + len <= hlen) {
    return ((void __attribute__((__always_inline__))  *)(skb->data + offset));
  }
  tmp___0 = skb_copy_bits(skb, offset, buffer, len);
  if (tmp___0 < 0) {
    return ((void __attribute__((__always_inline__))  *)((void *)0));
  }
  return ((void __attribute__((__always_inline__))  *)buffer);
}
}
extern void skb_init(void) ;
extern void skb_add_mtu(int mtu ) ;
__inline static void __attribute__((__always_inline__))  nf_conntrack_put(struct nf_conntrack *nfct ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (nfct) {
    tmp = atomic_dec_and_test(& nfct->use);
    if (tmp) {
      ((*(nfct->destroy)))(nfct);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_conntrack_get(struct nf_conntrack *nfct ) 
{ 

  {
  if (nfct) {
    atomic_inc(& nfct->use);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_reset(struct sk_buff *skb ) 
{ 

  {
  nf_conntrack_put(skb->nfct);
  skb->nfct = (struct nf_conntrack *)((void *)0);
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_reset_debug(struct sk_buff *skb ) 
{ 

  {
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_bridge_put(struct nf_bridge_info *nf_bridge ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  if (nf_bridge) {
    tmp = atomic_dec_and_test(& nf_bridge->use);
    if (tmp) {
      kfree((void const   *)nf_bridge);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  nf_bridge_get(struct nf_bridge_info *nf_bridge ) 
{ 

  {
  if (nf_bridge) {
    atomic_inc(& nf_bridge->use);
  }
  return;
}
}
__inline static struct ethhdr  __attribute__((__always_inline__)) *eth_hdr(struct sk_buff  const  *skb ) 
{ 

  {
  return ((struct ethhdr  __attribute__((__always_inline__)) *)((struct ethhdr *)skb->mac.raw));
}
}
extern struct netif_rx_stats per_cpu__netdev_rx_stat ;
__inline static void __attribute__((__always_inline__))  *netdev_priv(struct net_device *dev ) 
{ 

  {
  return ((void __attribute__((__always_inline__))  *)((char *)dev + ((sizeof(struct net_device ) +
                                                                       31U) & 4294967264U)));
}
}
extern int notifier_chain_register(struct notifier_block **list , struct notifier_block *n ) ;
extern int notifier_chain_unregister(struct notifier_block **nl , struct notifier_block *n ) ;
extern int notifier_call_chain(struct notifier_block **n , unsigned long val , void *v ) ;
extern struct net_device loopback_dev ;
extern struct net_device *dev_base ;
extern rwlock_t dev_base_lock ;
extern int netdev_boot_setup_check(struct net_device *dev ) ;
extern unsigned long netdev_boot_base(char const   *prefix , int unit ) ;
extern struct net_device *dev_getbyhwaddr(unsigned short type , char *hwaddr ) ;
extern struct net_device *dev_getfirstbyhwtype(unsigned short type ) ;
extern void dev_add_pack(struct packet_type *pt ) ;
extern void dev_remove_pack(struct packet_type *pt ) ;
extern void __dev_remove_pack(struct packet_type *pt ) ;
extern struct net_device *dev_get_by_flags(unsigned short flags , unsigned short mask ) ;
extern struct net_device *dev_get_by_name(char const   *name ) ;
extern struct net_device *__dev_get_by_name(char const   *name ) ;
extern int dev_alloc_name(struct net_device *dev , char const   *name ) ;
extern int dev_open(struct net_device *dev ) ;
extern int dev_close(struct net_device *dev ) ;
extern int dev_queue_xmit(struct sk_buff *skb ) ;
extern int register_netdevice(struct net_device *dev ) ;
extern int unregister_netdevice(struct net_device *dev ) ;
extern void free_netdev(struct net_device *dev ) ;
extern void synchronize_net(void) ;
extern int register_netdevice_notifier(struct notifier_block *nb ) ;
extern int unregister_netdevice_notifier(struct notifier_block *nb ) ;
extern int call_netdevice_notifiers(unsigned long val , void *v ) ;
extern struct net_device *dev_get_by_index(int ifindex ) ;
extern struct net_device *__dev_get_by_index(int ifindex ) ;
extern int dev_restart(struct net_device *dev ) ;
extern int register_gifconf(unsigned int family , gifconf_func_t *gifconf ) ;
__inline static int __attribute__((__always_inline__))  unregister_gifconf(unsigned int family ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = (int __attribute__((__always_inline__))  )register_gifconf(family, (gifconf_func_t *)((void *)0));
  return (tmp);
}
}
extern struct softnet_data per_cpu__softnet_data ;
__inline static void __attribute__((__always_inline__))  __netif_schedule(struct net_device *dev ) 
{ unsigned long flags ;
  struct softnet_data *sd ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = test_and_set_bit(3, (unsigned long volatile   *)(& dev->state));
  if (! tmp___0) {
    __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
    __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
    tmp = current_thread_info();
    sd = (struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]);
    dev->next_sched = sd->output_queue;
    sd->output_queue = dev;
    raise_softirq_irqoff(2U);
    while (1) {
      __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
      break;
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_schedule(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(0, (unsigned long const volatile   *)(& dev->state));
  if (! tmp) {
    __netif_schedule(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_start_queue(struct net_device *dev ) 
{ 

  {
  clear_bit(0, (unsigned long volatile   *)(& dev->state));
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_wake_queue(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_clear_bit(0, (unsigned long volatile   *)(& dev->state));
  if (tmp) {
    __netif_schedule(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_stop_queue(struct net_device *dev ) 
{ 

  {
  set_bit(0, (unsigned long volatile   *)(& dev->state));
  return;
}
}
__inline static int __attribute__((__always_inline__))  netif_queue_stopped(struct net_device  const  *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(0, (unsigned long const volatile   *)(& dev->state));
  return (tmp);
}
}
__inline static int __attribute__((__always_inline__))  netif_running(struct net_device  const  *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(1, (unsigned long const volatile   *)(& dev->state));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  dev_kfree_skb_irq(struct sk_buff *skb ) 
{ struct softnet_data *sd ;
  unsigned long flags ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp___0 = atomic_dec_and_test(& skb->users);
  if (tmp___0) {
    __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
    __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
    tmp = current_thread_info();
    sd = (struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]);
    skb->next = sd->completion_queue;
    sd->completion_queue = skb;
    raise_softirq_irqoff(2U);
    while (1) {
      __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
      break;
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  dev_kfree_skb_any(struct sk_buff *skb ) 
{ struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  tmp = current_thread_info();
  if ((unsigned long )tmp->preempt_count & 268369920UL) {
    dev_kfree_skb_irq(skb);
  } else {
    while (1) {
      __asm__  volatile   ("pushfl ; popl %0": "=g" (flags));
      break;
    }
    if (! (flags & 512UL) != 0) {
      dev_kfree_skb_irq(skb);
    } else {
      kfree_skb(skb);
    }
  }
  return;
}
}
extern int netif_rx(struct sk_buff *skb ) ;
extern int netif_rx_ni(struct sk_buff *skb ) ;
extern int netif_receive_skb(struct sk_buff *skb ) ;
extern int dev_ioctl(unsigned int cmd , void * ) ;
extern int dev_ethtool(struct ifreq * ) ;
extern unsigned int dev_get_flags(struct net_device  const  * ) ;
extern int dev_change_flags(struct net_device * , unsigned int  ) ;
extern int dev_change_name(struct net_device * , char * ) ;
extern int dev_set_mtu(struct net_device * , int  ) ;
extern int dev_set_mac_address(struct net_device * , struct sockaddr * ) ;
extern void dev_queue_xmit_nit(struct sk_buff *skb , struct net_device *dev ) ;
extern void dev_init(void) ;
extern int netdev_nit ;
extern void netdev_run_todo(void) ;
__inline static void __attribute__((__always_inline__))  dev_put(struct net_device *dev ) 
{ 

  {
  atomic_dec(& dev->refcnt);
  return;
}
}
extern void linkwatch_fire_event(struct net_device *dev ) ;
__inline static int __attribute__((__always_inline__))  netif_carrier_ok(struct net_device  const  *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = constant_test_bit(4, (unsigned long const volatile   *)(& dev->state));
  if (tmp) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
extern void __netdev_watchdog_up(struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  netif_carrier_on(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_clear_bit(4, (unsigned long volatile   *)(& dev->state));
  if (tmp) {
    linkwatch_fire_event(dev);
  }
  tmp___0 = netif_running((struct net_device  const  *)dev);
  if (tmp___0) {
    __netdev_watchdog_up(dev);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_carrier_off(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = test_and_set_bit(4, (unsigned long volatile   *)(& dev->state));
  if (! tmp) {
    linkwatch_fire_event(dev);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  netif_device_present(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = constant_test_bit(2, (unsigned long const volatile   *)(& dev->state));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  netif_device_detach(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_clear_bit(2, (unsigned long volatile   *)(& dev->state));
  if (tmp) {
    tmp___0 = netif_running((struct net_device  const  *)dev);
    if (tmp___0) {
      netif_stop_queue(dev);
    }
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_device_attach(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  tmp = test_and_set_bit(2, (unsigned long volatile   *)(& dev->state));
  if (! tmp) {
    tmp___0 = netif_running((struct net_device  const  *)dev);
    if (tmp___0) {
      netif_wake_queue(dev);
      __netdev_watchdog_up(dev);
    }
  }
  return;
}
}
__inline static u32 __attribute__((__always_inline__))  netif_msg_init(int debug_value ,
                                                                       int default_msg_enable_bits ) 
{ 

  {
  if (debug_value < 0) {
    return ((unsigned int )default_msg_enable_bits);
  } else {
    if ((unsigned int )debug_value >= sizeof(u32 ) * 8U) {
      return ((unsigned int )default_msg_enable_bits);
    }
  }
  if (debug_value == 0) {
    return (0U);
  }
  return ((unsigned int )((1 << debug_value) - 1));
}
}
__inline static int __attribute__((__always_inline__))  netif_rx_schedule_prep(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;

  {
  tmp = netif_running((struct net_device  const  *)dev);
  if (tmp) {
    tmp___0 = test_and_set_bit(5, (unsigned long volatile   *)(& dev->state));
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
  } else {
    tmp___1 = 0;
  }
  return ((int __attribute__((__always_inline__))  )tmp___1);
}
}
__inline static void __attribute__((__always_inline__))  __netif_rx_schedule(struct net_device *dev ) 
{ unsigned long flags ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __ptr___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
  atomic_inc(& dev->refcnt);
  __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
  tmp = current_thread_info();
  list_add_tail(& dev->poll_list, & ((struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]))->poll_list);
  if (dev->quota < 0) {
    dev->quota += dev->weight;
  } else {
    dev->quota = dev->weight;
  }
  while (1) {
    __asm__  ("": "=g" (__ptr___0): "0" (& per_cpu__irq_stat));
    tmp___0 = current_thread_info();
    ((irq_cpustat_t *)(__ptr___0 + __per_cpu_offset[tmp___0->cpu]))->__softirq_pending = (unsigned int )((unsigned long )((irq_cpustat_t *)(__ptr___0 +
                                                                                                                                            __per_cpu_offset[tmp___0->cpu]))->__softirq_pending |
                                                                                                         8UL);
    break;
  }
  while (1) {
    __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
    break;
  }
}
}
__inline static void __attribute__((__always_inline__))  netif_rx_schedule(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;

  {
  tmp = netif_rx_schedule_prep(dev);
  if (tmp) {
    __netif_rx_schedule(dev);
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  netif_rx_reschedule(struct net_device *dev ,
                                                                            int undo ) 
{ unsigned long flags ;
  unsigned long __ptr ;
  struct thread_info  __attribute__((__always_inline__)) *tmp ;
  unsigned long __ptr___0 ;
  struct thread_info  __attribute__((__always_inline__)) *tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp___1 = netif_rx_schedule_prep(dev);
  if (tmp___1) {
    dev->quota += undo;
    __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
    __asm__  ("": "=g" (__ptr): "0" (& per_cpu__softnet_data));
    tmp = current_thread_info();
    list_add_tail(& dev->poll_list, & ((struct softnet_data *)(__ptr + __per_cpu_offset[tmp->cpu]))->poll_list);
    while (1) {
      __asm__  ("": "=g" (__ptr___0): "0" (& per_cpu__irq_stat));
      tmp___0 = current_thread_info();
      ((irq_cpustat_t *)(__ptr___0 + __per_cpu_offset[tmp___0->cpu]))->__softirq_pending = (unsigned int )((unsigned long )((irq_cpustat_t *)(__ptr___0 +
                                                                                                                                              __per_cpu_offset[tmp___0->cpu]))->__softirq_pending |
                                                                                                           8UL);
      break;
    }
    while (1) {
      __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
      break;
    }
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
__inline static void __attribute__((__always_inline__))  netif_rx_complete(struct net_device *dev ) 
{ unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  __asm__  volatile   ("pushfl ; popl %0 ; cli": "=g" (flags): : "memory");
  while (1) {
    tmp = constant_test_bit(5, (unsigned long const volatile   *)(& dev->state));
    if (tmp) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1 != 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    if (tmp___3) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (860), "i" ("include/linux/netdevice.h"));
    }
    break;
  }
  list_del(& dev->poll_list);
  __asm__  volatile   ("": : : "memory");
  clear_bit(5, (unsigned long volatile   *)(& dev->state));
  while (1) {
    __asm__  volatile   ("pushl %0 ; popfl": : "g" (flags): "memory", "cc");
    break;
  }
}
}
__inline static void __attribute__((__always_inline__))  netif_poll_disable(struct net_device *dev ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  while (1) {
    tmp___0 = test_and_set_bit(5, (unsigned long volatile   *)(& dev->state));
    if (! tmp___0) {
      break;
    }
    tmp = get_current();
    tmp->state = (long volatile   )1;
    schedule_timeout(1L);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  netif_poll_enable(struct net_device *dev ) 
{ 

  {
  clear_bit(5, (unsigned long volatile   *)(& dev->state));
  return;
}
}
__inline static void __attribute__((__always_inline__))  __netif_rx_complete(struct net_device *dev ) 
{ int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  while (1) {
    tmp = constant_test_bit(5, (unsigned long const volatile   *)(& dev->state));
    if (tmp) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1 != 0) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    if (tmp___3) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (886), "i" ("include/linux/netdevice.h"));
    }
    break;
  }
  list_del(& dev->poll_list);
  __asm__  volatile   ("": : : "memory");
  clear_bit(5, (unsigned long volatile   *)(& dev->state));
}
}
__inline static void __attribute__((__always_inline__))  netif_tx_disable(struct net_device *dev ) 
{ 

  {
  _spin_lock_bh(& dev->xmit_lock);
  netif_stop_queue(dev);
  _spin_unlock_bh(& dev->xmit_lock);
  return;
}
}
extern void ether_setup(struct net_device *dev ) ;
extern struct net_device *alloc_netdev(int sizeof_priv , char const   *name , void (*setup)(struct net_device * ) ) ;
extern int register_netdev(struct net_device *dev ) ;
extern void unregister_netdev(struct net_device *dev ) ;
extern void dev_mc_upload(struct net_device *dev ) ;
extern int dev_mc_delete(struct net_device *dev , void *addr , int alen , int all ) ;
extern int dev_mc_add(struct net_device *dev , void *addr , int alen , int newonly ) ;
extern void dev_mc_discard(struct net_device *dev ) ;
extern void dev_set_promiscuity(struct net_device *dev , int inc ) ;
extern void dev_set_allmulti(struct net_device *dev , int inc ) ;
extern void netdev_state_change(struct net_device *dev ) ;
extern void netdev_features_change(struct net_device *dev ) ;
extern void dev_load(char const   *name ) ;
extern void dev_mcast_init(void) ;
extern int netdev_max_backlog ;
extern int weight_p ;
extern int netdev_set_master(struct net_device *dev , struct net_device *master ) ;
extern int skb_checksum_help(struct sk_buff *skb , int inward ) ;
extern void net_enable_timestamp(void) ;
extern void net_disable_timestamp(void) ;
extern char *net_sysctl_strdup(char const   *s ) ;
extern spinlock_t dma_spin_lock ;
__inline static unsigned long __attribute__((__always_inline__))  claim_dma_lock(void) 
{ unsigned long flags ;

  {
  flags = _spin_lock_irqsave(& dma_spin_lock);
  return ((unsigned long __attribute__((__always_inline__))  )flags);
}
}
__inline static void __attribute__((__always_inline__))  release_dma_lock(unsigned long flags ) 
{ 

  {
  _spin_unlock_irqrestore(& dma_spin_lock, flags);
  return;
}
}
__inline static void __attribute__((__always_inline__))  enable_dma(unsigned int dmanr ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char )dmanr, 10);
  } else {
    outb((unsigned char )(dmanr & 3U), 212);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  disable_dma(unsigned int dmanr ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char )(dmanr | 4U), 10);
  } else {
    outb((unsigned char )((dmanr & 3U) | 4U), 212);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  clear_dma_ff(unsigned int dmanr ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char)0, 12);
  } else {
    outb((unsigned char)0, 216);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_mode(unsigned int dmanr ,
                                                                      char mode ) 
{ 

  {
  if (dmanr <= 3U) {
    outb((unsigned char )((unsigned int )mode | dmanr), 11);
  } else {
    outb((unsigned char )((unsigned int )mode | (dmanr & 3U)), 214);
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_page(unsigned int dmanr ,
                                                                      char pagenr ) 
{ 

  {
  switch ((int )dmanr) {
  case 0: 
  outb((unsigned char )pagenr, 135);
  break;
  case 1: 
  outb((unsigned char )pagenr, 131);
  break;
  case 2: 
  outb((unsigned char )pagenr, 129);
  break;
  case 3: 
  outb((unsigned char )pagenr, 130);
  break;
  case 5: 
  outb((unsigned char )((int )pagenr & 254), 139);
  break;
  case 6: 
  outb((unsigned char )((int )pagenr & 254), 137);
  break;
  case 7: 
  outb((unsigned char )((int )pagenr & 254), 138);
  break;
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_addr(unsigned int dmanr ,
                                                                      unsigned int a ) 
{ 

  {
  set_dma_page(dmanr, (char )(a >> 16));
  if (dmanr <= 3U) {
    outb((unsigned char )(a & 255U), (int )((dmanr & 3U) << 1));
    outb((unsigned char )((a >> 8) & 255U), (int )((dmanr & 3U) << 1));
  } else {
    outb((unsigned char )((a >> 1) & 255U), (int )(((dmanr & 3U) << 2) + 192U));
    outb((unsigned char )((a >> 9) & 255U), (int )(((dmanr & 3U) << 2) + 192U));
  }
  return;
}
}
__inline static void __attribute__((__always_inline__))  set_dma_count(unsigned int dmanr ,
                                                                       unsigned int count ) 
{ 

  {
  count --;
  if (dmanr <= 3U) {
    outb((unsigned char )(count & 255U), (int )(((dmanr & 3U) << 1) + 1U));
    outb((unsigned char )((count >> 8) & 255U), (int )(((dmanr & 3U) << 1) + 1U));
  } else {
    outb((unsigned char )((count >> 1) & 255U), (int )((((dmanr & 3U) << 2) + 2U) +
                                                       192U));
    outb((unsigned char )((count >> 9) & 255U), (int )((((dmanr & 3U) << 2) + 2U) +
                                                       192U));
  }
  return;
}
}
__inline static int __attribute__((__always_inline__))  get_dma_residue(unsigned int dmanr ) 
{ unsigned int io_port ;
  unsigned int tmp ;
  unsigned short count ;
  unsigned char __attribute__((__always_inline__))  tmp___0 ;
  unsigned char __attribute__((__always_inline__))  tmp___1 ;
  int tmp___2 ;

  {
  if (dmanr <= 3U) {
    tmp = ((dmanr & 3U) << 1) + 1U;
  } else {
    tmp = (((dmanr & 3U) << 2) + 2U) + 192U;
  }
  io_port = tmp;
  tmp___0 = inb((int )io_port);
  count = (unsigned short )(1 + (int )tmp___0);
  tmp___1 = inb((int )io_port);
  count = (unsigned short )((int )count + (int )((int __attribute__((__always_inline__))  )tmp___1 <<
                                                 8));
  if (dmanr <= 3U) {
    tmp___2 = (int )count;
  } else {
    tmp___2 = (int )count << 1;
  }
  return ((int __attribute__((__always_inline__))  )tmp___2);
}
}
extern int request_dma(unsigned int dmanr , char const   *device_id ) ;
extern void free_dma(unsigned int dmanr ) ;
extern int isa_dma_bridge_buggy ;
__inline static struct sppp  __attribute__((__always_inline__)) *sppp_of(struct net_device *dev ) 
{ struct ppp_device **ppp ;
  long tmp ;

  {
  ppp = (struct ppp_device **)dev->priv;
  while (1) {
    tmp = __builtin_expect((long )(! (! (((unsigned int )((*ppp))->dev != (unsigned int )dev) !=
                                         0)) != 0), 0L);
    if (tmp) {
      __asm__  volatile   ("ud2\n"
                           "\t.word %c0\n"
                           "\t.long %c1\n": : "i" (63), "i" ("include/net/syncppp.h"));
    }
    break;
  }
  return ((struct sppp  __attribute__((__always_inline__)) *)(& ((*ppp))->sppp));
}
}
extern void sppp_attach(struct ppp_device *pd ) ;
extern void sppp_detach(struct net_device *dev ) ;
extern void sppp_input(struct net_device *dev , struct sk_buff *m ) ;
extern int sppp_do_ioctl(struct net_device *dev , struct ifreq *ifr , int cmd ) ;
extern struct sk_buff *sppp_dequeue(struct net_device *dev ) ;
extern int sppp_isempty(struct net_device *dev ) ;
extern void sppp_flush(struct net_device *dev ) ;
extern int sppp_open(struct net_device *dev ) ;
extern int sppp_reopen(struct net_device *dev ) ;
extern int sppp_close(struct net_device *dev ) ;
extern int hdlc_raw_ioctl(struct net_device *dev , struct ifreq *ifr ) ;
extern int hdlc_raw_eth_ioctl(struct net_device *dev , struct ifreq *ifr ) ;
extern int hdlc_cisco_ioctl(struct net_device *dev , struct ifreq *ifr ) ;
extern int hdlc_ppp_ioctl(struct net_device *dev , struct ifreq *ifr ) ;
extern int hdlc_fr_ioctl(struct net_device *dev , struct ifreq *ifr ) ;
extern int hdlc_x25_ioctl(struct net_device *dev , struct ifreq *ifr ) ;
extern int hdlc_ioctl(struct net_device *dev , struct ifreq *ifr , int cmd ) ;
extern int register_hdlc_device(struct net_device *dev ) ;
extern void unregister_hdlc_device(struct net_device *dev ) ;
extern struct net_device *alloc_hdlcdev(void *priv ) ;
__inline static hdlc_device __attribute__((__always_inline__))  *dev_to_hdlc(struct net_device *dev ) 
{ hdlc_device __attribute__((__always_inline__))  *tmp ;

  {
  tmp = (hdlc_device __attribute__((__always_inline__))  *)netdev_priv(dev);
  return (tmp);
}
}
__inline static pvc_device __attribute__((__always_inline__))  *dev_to_pvc(struct net_device *dev ) 
{ 

  {
  return ((pvc_device __attribute__((__always_inline__))  *)((pvc_device *)dev->priv));
}
}
__inline static void __attribute__((__always_inline__))  debug_frame(struct sk_buff  const  *skb ) 
{ int i ;

  {
  i = 0;
  while ((unsigned int const   )i < skb->len) {
    if (i == 100) {
      printk("...\n");
      return;
    }
    printk(" %02X", (*(skb->data + i)));
    i ++;
  }
  printk("\n");
  return;
}
}
extern int hdlc_open(struct net_device *dev ) ;
extern void hdlc_close(struct net_device *dev ) ;
extern void hdlc_set_carrier(int on , struct net_device *dev ) ;
__inline static void __attribute__((__always_inline__))  hdlc_proto_detach(hdlc_device *hdlc ) 
{ 

  {
  if (hdlc->proto.detach) {
    ((*(hdlc->proto.detach)))(hdlc);
  }
  hdlc->proto.detach = (void (*)(struct hdlc_device_struct *hdlc ))((void *)0);
  return;
}
}
__inline static struct net_device_stats  __attribute__((__always_inline__)) *hdlc_stats(struct net_device *dev ) 
{ hdlc_device __attribute__((__always_inline__))  *tmp ;

  {
  tmp = dev_to_hdlc(dev);
  return ((struct net_device_stats  __attribute__((__always_inline__)) *)(& tmp->stats));
}
}
__inline static unsigned short __attribute__((__always_inline__))  hdlc_type_trans(struct sk_buff *skb ,
                                                                                   struct net_device *dev ) 
{ hdlc_device *hdlc ;
  hdlc_device *tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;
  __u16 __x ;
  __u16 __attribute__((__always_inline__))  tmp___1 ;

  {
  tmp = (hdlc_device *)dev_to_hdlc(dev);
  hdlc = tmp;
  skb->mac.raw = skb->data;
  skb->dev = dev;
  if (hdlc->proto.type_trans) {
    tmp___0 = (unsigned short __attribute__((__always_inline__))  )((*(hdlc->proto.type_trans)))(skb,
                                                                                                 dev);
    return (tmp___0);
  } else {
    __x = (__u16 )25;
    return ((unsigned short __attribute__((__always_inline__))  )((unsigned short )((int )((unsigned short )((((int )__x &
                                                                                                               255) <<
                                                                                                              8) |
                                                                                                             (((int )__x &
                                                                                                               65280) >>
                                                                                                              8))))));
  }
}
}
static struct _MGSL_PARAMS default_params  = 
     {2UL, (unsigned char)0, (unsigned short)1, (unsigned char)3, 0UL, (unsigned char)255,
    (unsigned short)1, (unsigned char)0, (unsigned char)0, 9600UL, (unsigned char)8,
    (unsigned char)1, (unsigned char)0};
extern void usc_DisableMasterIrqBit(struct mgsl_struct *info ) ;
extern void usc_EnableMasterIrqBit(struct mgsl_struct *info ) ;
extern void usc_EnableInterrupts(struct mgsl_struct *info , u16 IrqMask ) ;
extern void usc_DisableInterrupts(struct mgsl_struct *info , u16 IrqMask ) ;
extern void usc_ClearIrqPendingBits(struct mgsl_struct *info , u16 IrqMask ) ;
static u16 usc_InDmaReg(struct mgsl_struct *info , u16 RegAddr ) ;
static void usc_OutDmaReg(struct mgsl_struct *info , u16 RegAddr , u16 RegValue ) ;
static void usc_DmaCmd(struct mgsl_struct *info , u16 Cmd ) ;
static u16 usc_InReg(struct mgsl_struct *info , u16 RegAddr ) ;
static void usc_OutReg(struct mgsl_struct *info , u16 RegAddr , u16 RegValue ) ;
static void usc_RTCmd(struct mgsl_struct *info , u16 Cmd ) ;
extern void usc_RCmd(struct mgsl_struct *info , u16 Cmd ) ;
extern void usc_TCmd(struct mgsl_struct *info , u16 Cmd ) ;
static void usc_process_rxoverrun_sync(struct mgsl_struct *info ) ;
static void usc_start_receiver(struct mgsl_struct *info ) ;
static void usc_stop_receiver(struct mgsl_struct *info ) ;
static void usc_start_transmitter(struct mgsl_struct *info ) ;
static void usc_stop_transmitter(struct mgsl_struct *info ) ;
static void usc_set_txidle(struct mgsl_struct *info ) ;
static void usc_load_txfifo(struct mgsl_struct *info ) ;
static void usc_enable_aux_clock(struct mgsl_struct *info , u32 data_rate ) ;
static void usc_enable_loopback(struct mgsl_struct *info , int enable ) ;
static void usc_get_serial_signals(struct mgsl_struct *info ) ;
static void usc_set_serial_signals(struct mgsl_struct *info ) ;
static void usc_reset(struct mgsl_struct *info ) ;
static void usc_set_sync_mode(struct mgsl_struct *info ) ;
static void usc_set_sdlc_mode(struct mgsl_struct *info ) ;
static void usc_set_async_mode(struct mgsl_struct *info ) ;
static void usc_enable_async_clock(struct mgsl_struct *info , u32 data_rate ) ;
static void usc_loopback_frame(struct mgsl_struct *info ) ;
static void mgsl_tx_timeout(unsigned long context ) ;
static void usc_loopmode_cancel_transmit(struct mgsl_struct *info ) ;
static void usc_loopmode_insert_request(struct mgsl_struct *info ) ;
static int usc_loopmode_active(struct mgsl_struct *info ) ;
static void usc_loopmode_send_done(struct mgsl_struct *info ) ;
static int mgsl_ioctl_common(struct mgsl_struct *info , unsigned int cmd , unsigned long arg ) ;
static void mgsl_trace_block(struct mgsl_struct *info , char const   *data , int count ,
                             int xmit ) ;
static int mgsl_register_test(struct mgsl_struct *info ) ;
static int mgsl_irq_test(struct mgsl_struct *info ) ;
static int mgsl_dma_test(struct mgsl_struct *info ) ;
static int mgsl_memory_test(struct mgsl_struct *info ) ;
static int mgsl_adapter_test(struct mgsl_struct *info ) ;
static int mgsl_claim_resources(struct mgsl_struct *info ) ;
static void mgsl_release_resources(struct mgsl_struct *info ) ;
static void mgsl_add_device(struct mgsl_struct *info ) ;
static struct mgsl_struct *mgsl_allocate_device(void) ;
static void mgsl_free_rx_frame_buffers(struct mgsl_struct *info , unsigned int StartIndex ,
                                       unsigned int EndIndex ) ;
static int mgsl_get_rx_frame(struct mgsl_struct *info ) ;
static int mgsl_get_raw_rx_frame(struct mgsl_struct *info ) ;
static void mgsl_reset_rx_dma_buffers(struct mgsl_struct *info ) ;
static void mgsl_reset_tx_dma_buffers(struct mgsl_struct *info ) ;
static int num_free_tx_dma_buffers(struct mgsl_struct *info ) ;
static void mgsl_load_tx_dma_buffer(struct mgsl_struct *info , char const   *Buffer ,
                                    unsigned int BufferSize ) ;
static void mgsl_load_pci_memory(char *TargetPtr , char const   *SourcePtr , unsigned short count ) ;
static int mgsl_allocate_dma_buffers(struct mgsl_struct *info ) ;
static void mgsl_free_dma_buffers(struct mgsl_struct *info ) ;
static int mgsl_alloc_frame_memory(struct mgsl_struct *info , DMABUFFERENTRY *BufferList ,
                                   int Buffercount ) ;
static void mgsl_free_frame_memory(struct mgsl_struct *info , DMABUFFERENTRY *BufferList ,
                                   int Buffercount ) ;
static int mgsl_alloc_buffer_list_memory(struct mgsl_struct *info ) ;
static void mgsl_free_buffer_list_memory(struct mgsl_struct *info ) ;
static int mgsl_alloc_intermediate_rxbuffer_memory(struct mgsl_struct *info ) ;
static void mgsl_free_intermediate_rxbuffer_memory(struct mgsl_struct *info ) ;
static int mgsl_alloc_intermediate_txbuffer_memory(struct mgsl_struct *info ) ;
static void mgsl_free_intermediate_txbuffer_memory(struct mgsl_struct *info ) ;
static int load_next_tx_holding_buffer(struct mgsl_struct *info ) ;
static int save_tx_buffer_request(struct mgsl_struct *info , char const   *Buffer ,
                                  unsigned int BufferSize ) ;
static void mgsl_bh_handler(void *Context ) ;
static void mgsl_bh_receive(struct mgsl_struct *info ) ;
static void mgsl_bh_transmit(struct mgsl_struct *info ) ;
static void mgsl_bh_status(struct mgsl_struct *info ) ;
static void mgsl_isr_null(struct mgsl_struct *info ) ;
static void mgsl_isr_transmit_data(struct mgsl_struct *info ) ;
static void mgsl_isr_receive_data(struct mgsl_struct *info ) ;
static void mgsl_isr_receive_status(struct mgsl_struct *info ) ;
static void mgsl_isr_transmit_status(struct mgsl_struct *info ) ;
static void mgsl_isr_io_pin(struct mgsl_struct *info ) ;
static void mgsl_isr_misc(struct mgsl_struct *info ) ;
static void mgsl_isr_receive_dma(struct mgsl_struct *info ) ;
static void mgsl_isr_transmit_dma(struct mgsl_struct *info ) ;
static isr_dispatch_func UscIsrTable[7]  = {      & mgsl_isr_null,      & mgsl_isr_misc,      & mgsl_isr_io_pin,      & mgsl_isr_transmit_data, 
        & mgsl_isr_transmit_status,      & mgsl_isr_receive_data,      & mgsl_isr_receive_status};
static int tiocmget(struct tty_struct *tty , struct file *file ) ;
static int tiocmset(struct tty_struct *tty , struct file *file , unsigned int set ,
                    unsigned int clear ) ;
static int mgsl_get_stats(struct mgsl_struct *info , struct mgsl_icount *user_icount ) ;
static int mgsl_get_params(struct mgsl_struct *info , MGSL_PARAMS *user_params ) ;
static int mgsl_set_params(struct mgsl_struct *info , MGSL_PARAMS *new_params ) ;
static int mgsl_get_txidle(struct mgsl_struct *info , int *idle_mode ) ;
static int mgsl_set_txidle(struct mgsl_struct *info , int idle_mode ) ;
static int mgsl_txenable(struct mgsl_struct *info , int enable ) ;
static int mgsl_txabort(struct mgsl_struct *info ) ;
static int mgsl_rxenable(struct mgsl_struct *info , int enable ) ;
static int mgsl_wait_event(struct mgsl_struct *info , int *mask_ptr ) ;
static int mgsl_loopmode_send_done(struct mgsl_struct *info ) ;
static int pci_registered  ;
static struct mgsl_struct *mgsl_device_list  ;
static int mgsl_device_count  ;
static int break_on_load  ;
static int ttymajor  ;
static int io[10]  ;
static int irq[10]  ;
static int dma[10]  ;
static int debug_level  ;
static int maxframe[20]  ;
static int dosyncppp[20]  ;
static int txdmabufs[20]  ;
static int txholdbufs[20]  ;
__inline static int __attribute__((__always_inline__))  *__check_break_on_load(void) 
{ 

  {
  return ((int __attribute__((__always_inline__))  *)(& break_on_load));
}
}
static char __param_str_break_on_load[14]  = 
  {      (char )'b',      (char )'r',      (char )'e',      (char )'a', 
        (char )'k',      (char )'_',      (char )'o',      (char )'n', 
        (char )'_',      (char )'l',      (char )'o',      (char )'a', 
        (char )'d',      (char )'\000'};
static struct kernel_param  const  __param_break_on_load  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_break_on_load), 0U, & param_set_bool, & param_get_bool,
    (void *)(& break_on_load)};
static char const   __mod_break_on_loadtype887[28]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'b',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'k',      (char const   )'_',      (char const   )'o', 
        (char const   )'n',      (char const   )'_',      (char const   )'l',      (char const   )'o', 
        (char const   )'a',      (char const   )'d',      (char const   )':',      (char const   )'b', 
        (char const   )'o',      (char const   )'o',      (char const   )'l',      (char const   )'\000'};
__inline static int __attribute__((__always_inline__))  *__check_ttymajor(void) 
{ 

  {
  return ((int __attribute__((__always_inline__))  *)(& ttymajor));
}
}
static char __param_str_ttymajor[9]  = 
  {      (char )'t',      (char )'t',      (char )'y',      (char )'m', 
        (char )'a',      (char )'j',      (char )'o',      (char )'r', 
        (char )'\000'};
static struct kernel_param  const  __param_ttymajor  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_ttymajor), 0U, & param_set_int, & param_get_int,
    (void *)(& ttymajor)};
static char const   __mod_ttymajortype888[22]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'t',      (char const   )'t',      (char const   )'y', 
        (char const   )'m',      (char const   )'a',      (char const   )'j',      (char const   )'o', 
        (char const   )'r',      (char const   )':',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
static struct kparam_array __param_arr_io  =    {sizeof(io) / sizeof(io[0]), (unsigned int *)((void *)0), & param_set_int, & param_get_int,
    sizeof(io[0]), (void *)(io)};
static char __param_str_io[3]  = {      (char )'i',      (char )'o',      (char )'\000'};
static struct kernel_param  const  __param_io  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_io), 0U, & param_array_set, & param_array_get, (void *)(& __param_arr_io)};
static char const   __mod_iotype889[25]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'o',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static struct kparam_array __param_arr_irq  =    {sizeof(irq) / sizeof(irq[0]), (unsigned int *)((void *)0), & param_set_int, & param_get_int,
    sizeof(irq[0]), (void *)(irq)};
static char __param_str_irq[4]  = {      (char )'i',      (char )'r',      (char )'q',      (char )'\000'};
static struct kernel_param  const  __param_irq  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_irq), 0U, & param_array_set, & param_array_get, (void *)(& __param_arr_irq)};
static char const   __mod_irqtype890[26]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'r',      (char const   )'q', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
static struct kparam_array __param_arr_dma  =    {sizeof(dma) / sizeof(dma[0]), (unsigned int *)((void *)0), & param_set_int, & param_get_int,
    sizeof(dma[0]), (void *)(dma)};
static char __param_str_dma[4]  = {      (char )'d',      (char )'m',      (char )'a',      (char )'\000'};
static struct kernel_param  const  __param_dma  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_dma), 0U, & param_array_set, & param_array_get, (void *)(& __param_arr_dma)};
static char const   __mod_dmatype891[26]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'d',      (char const   )'m',      (char const   )'a', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
__inline static int __attribute__((__always_inline__))  *__check_debug_level(void) 
{ 

  {
  return ((int __attribute__((__always_inline__))  *)(& debug_level));
}
}
static char __param_str_debug_level[12]  = 
  {      (char )'d',      (char )'e',      (char )'b',      (char )'u', 
        (char )'g',      (char )'_',      (char )'l',      (char )'e', 
        (char )'v',      (char )'e',      (char )'l',      (char )'\000'};
static struct kernel_param  const  __param_debug_level  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_debug_level), 0U, & param_set_int, & param_get_int,
    (void *)(& debug_level)};
static char const   __mod_debug_leveltype892[25]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'u',      (char const   )'g',      (char const   )'_',      (char const   )'l', 
        (char const   )'e',      (char const   )'v',      (char const   )'e',      (char const   )'l', 
        (char const   )':',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static struct kparam_array __param_arr_maxframe  =    {sizeof(maxframe) / sizeof(maxframe[0]), (unsigned int *)((void *)0), & param_set_int,
    & param_get_int, sizeof(maxframe[0]), (void *)(maxframe)};
static char __param_str_maxframe[9]  = 
  {      (char )'m',      (char )'a',      (char )'x',      (char )'f', 
        (char )'r',      (char )'a',      (char )'m',      (char )'e', 
        (char )'\000'};
static struct kernel_param  const  __param_maxframe  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_maxframe), 0U, & param_array_set, & param_array_get,
    (void *)(& __param_arr_maxframe)};
static char const   __mod_maxframetype893[31]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'m',      (char const   )'a',      (char const   )'x', 
        (char const   )'f',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )'e',      (char const   )':',      (char const   )'a',      (char const   )'r', 
        (char const   )'r',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static struct kparam_array __param_arr_dosyncppp  =    {sizeof(dosyncppp) / sizeof(dosyncppp[0]), (unsigned int *)((void *)0), & param_set_int,
    & param_get_int, sizeof(dosyncppp[0]), (void *)(dosyncppp)};
static char __param_str_dosyncppp[10]  = 
  {      (char )'d',      (char )'o',      (char )'s',      (char )'y', 
        (char )'n',      (char )'c',      (char )'p',      (char )'p', 
        (char )'p',      (char )'\000'};
static struct kernel_param  const  __param_dosyncppp  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_dosyncppp), 0U, & param_array_set, & param_array_get,
    (void *)(& __param_arr_dosyncppp)};
static char const   __mod_dosyncppptype894[32]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'d',      (char const   )'o',      (char const   )'s', 
        (char const   )'y',      (char const   )'n',      (char const   )'c',      (char const   )'p', 
        (char const   )'p',      (char const   )'p',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static struct kparam_array __param_arr_txdmabufs  =    {sizeof(txdmabufs) / sizeof(txdmabufs[0]), (unsigned int *)((void *)0), & param_set_int,
    & param_get_int, sizeof(txdmabufs[0]), (void *)(txdmabufs)};
static char __param_str_txdmabufs[10]  = 
  {      (char )'t',      (char )'x',      (char )'d',      (char )'m', 
        (char )'a',      (char )'b',      (char )'u',      (char )'f', 
        (char )'s',      (char )'\000'};
static struct kernel_param  const  __param_txdmabufs  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_txdmabufs), 0U, & param_array_set, & param_array_get,
    (void *)(& __param_arr_txdmabufs)};
static char const   __mod_txdmabufstype895[32]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'t',      (char const   )'x',      (char const   )'d', 
        (char const   )'m',      (char const   )'a',      (char const   )'b',      (char const   )'u', 
        (char const   )'f',      (char const   )'s',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static struct kparam_array __param_arr_txholdbufs  =    {sizeof(txholdbufs) / sizeof(txholdbufs[0]), (unsigned int *)((void *)0), & param_set_int,
    & param_get_int, sizeof(txholdbufs[0]), (void *)(txholdbufs)};
static char __param_str_txholdbufs[11]  = 
  {      (char )'t',      (char )'x',      (char )'h',      (char )'o', 
        (char )'l',      (char )'d',      (char )'b',      (char )'u', 
        (char )'f',      (char )'s',      (char )'\000'};
static struct kernel_param  const  __param_txholdbufs  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {(char const   *)(__param_str_txholdbufs), 0U, & param_array_set, & param_array_get,
    (void *)(& __param_arr_txholdbufs)};
static char const   __mod_txholdbufstype896[33]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'t',      (char const   )'x',      (char const   )'h', 
        (char const   )'o',      (char const   )'l',      (char const   )'d',      (char const   )'b', 
        (char const   )'u',      (char const   )'f',      (char const   )'s',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static char *driver_name  =    (char *)"SyncLink serial driver";
static char *driver_version  =    (char *)"$Revision: 4.28 $";
static int synclink_init_one(struct pci_dev *dev , struct pci_device_id  const  *ent ) ;
static void synclink_remove_one(struct pci_dev *dev ) ;
static struct pci_device_id synclink_pci_tbl[3]  = {      {(__u32 )5056, (__u32 )16, (__u32 )(~ 0), (__u32 )(~ 0), 0U, 0U, 0UL}, 
        {(__u32 )5056, (__u32 )528, (__u32 )(~ 0), (__u32 )(~ 0), 0U, 0U, 0UL}, 
        {(__u32 )0, 0U, 0U, 0U, 0U, 0U, 0UL}};
extern struct pci_device_id  const  __mod_pci_device_table  __attribute__((__unused__,
__alias__("synclink_pci_tbl"))) ;
static char const   __mod_license912[12]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
static struct pci_driver synclink_pci_driver  = 
     {{(struct list_head *)0, (struct list_head *)0}, (char *)"synclink", (struct module *)0,
    (struct pci_device_id  const  *)(synclink_pci_tbl), & synclink_init_one, & synclink_remove_one,
    (int (*)(struct pci_dev *dev , pm_message_t state ))0, (int (*)(struct pci_dev *dev ))0,
    (int (*)(struct pci_dev *dev , pci_power_t state , int enable ))0, (void (*)(struct pci_dev *dev ))0,
    {(char *)0, (struct bus_type *)0, {0U, {{0U}, {(struct list_head *)0, (struct list_head *)0}}},
     {(char *)0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                  (char)0, (char)0, (char)0, (char)0}, {{0}}, {(struct list_head *)0,
                                                               (struct list_head *)0},
      (struct kobject *)0, (struct kset *)0, (struct kobj_type *)0, (struct dentry *)0},
     {(struct list_head *)0, (struct list_head *)0}, (struct module *)0, (int (*)(struct device *dev ))0,
     (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                                 pm_message_t state ,
                                                                                 u32 level ))0,
     (int (*)(struct device *dev , u32 level ))0}, {{0U}, {(struct list_head *)0,
                                                           (struct list_head *)0},
                                                    0U}};
static struct tty_driver *serial_driver  ;
static void mgsl_change_params(struct mgsl_struct *info ) ;
static void mgsl_wait_until_sent(struct tty_struct *tty , int timeout ) ;
static void *mgsl_get_text_ptr(void) 
{ 

  {
  return ((void *)(& mgsl_get_text_ptr));
}
}
static unsigned char *tmp_buf  ;
static struct semaphore tmp_buf_sem  =    {{(int volatile   )1}, 0, {{(unsigned int volatile   )1}, {& tmp_buf_sem.wait.task_list,
                                                              & tmp_buf_sem.wait.task_list}}};
__inline static int __attribute__((__always_inline__))  mgsl_paranoia_check(struct mgsl_struct *info ,
                                                                            char *name ,
                                                                            char const   *routine ) 
{ 

  {
  if (! info) {
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
static void ldisc_receive_buf(struct tty_struct *tty , __u8 const   *data , char *flags ,
                              int count ) 
{ struct tty_ldisc *ld ;

  {
  if (! tty) {
    return;
  }
  ld = tty_ldisc_ref(tty);
  if (ld) {
    if (ld->receive_buf) {
      ((*(ld->receive_buf)))(tty, data, flags, count);
    }
    tty_ldisc_deref(ld);
  }
  return;
}
}
static void mgsl_stop(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_stop");
  if (tmp) {
    return;
  }
  if (debug_level >= 3) {
    printk("mgsl_stop(%s)\n", info->device_name);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (info->tx_enabled) {
    usc_stop_transmitter(info);
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static void mgsl_start(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_start");
  if (tmp) {
    return;
  }
  if (debug_level >= 3) {
    printk("mgsl_start(%s)\n", info->device_name);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (! info->tx_enabled) {
    usc_start_transmitter(info);
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static int mgsl_bh_action(struct mgsl_struct *info ) 
{ unsigned long flags ;
  int rc ;

  {
  rc = 0;
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (info->pending_bh & 1U) {
    info->pending_bh &= 4294967294U;
    rc = 1;
  } else {
    if (info->pending_bh & 2U) {
      info->pending_bh &= 4294967293U;
      rc = 2;
    } else {
      if (info->pending_bh & 4U) {
        info->pending_bh &= 4294967291U;
        rc = 4;
      }
    }
  }
  if (! rc) {
    info->bh_running = 0;
    info->bh_requested = 0;
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (rc);
}
}
static void mgsl_bh_handler(void *Context ) 
{ struct mgsl_struct *info ;
  int action ;

  {
  info = (struct mgsl_struct *)Context;
  if (! info) {
    return;
  }
  if (debug_level >= 4) {
    printk("%s(%d):mgsl_bh_handler(%s) entry\n", "drivers/char/synclink.c", 1095,
           info->device_name);
  }
  info->bh_running = 1;
  while (1) {
    action = mgsl_bh_action(info);
    if (! (action != 0)) {
      break;
    }
    if (debug_level >= 4) {
      printk("%s(%d):mgsl_bh_handler() work item action=%d\n", "drivers/char/synclink.c",
             1104, action);
    }
    switch (action) {
    case 1: 
    mgsl_bh_receive(info);
    break;
    case 2: 
    mgsl_bh_transmit(info);
    break;
    case 4: 
    mgsl_bh_status(info);
    break;
    default: 
    printk("Unknown work item ID=%08X!\n", action);
    break;
    }
  }
  if (debug_level >= 4) {
    printk("%s(%d):mgsl_bh_handler(%s) exit\n", "drivers/char/synclink.c", 1126, info->device_name);
  }
  return;
}
}
static void mgsl_bh_receive(struct mgsl_struct *info ) 
{ int (*get_rx_frame)(struct mgsl_struct *info ) ;
  int (*tmp)(struct mgsl_struct *info ) ;
  unsigned long flags ;
  int tmp___0 ;

  {
  if (info->params.mode == 2UL) {
    tmp = & mgsl_get_rx_frame;
  } else {
    tmp = & mgsl_get_raw_rx_frame;
  }
  get_rx_frame = tmp;
  if (debug_level >= 4) {
    printk("%s(%d):mgsl_bh_receive(%s)\n", "drivers/char/synclink.c", 1136, info->device_name);
  }
  while (1) {
    if (info->rx_rcc_underrun) {
      flags = _spin_lock_irqsave(& info->irq_spinlock);
      usc_start_receiver(info);
      _spin_unlock_irqrestore(& info->irq_spinlock, flags);
      return;
    }
    tmp___0 = ((*get_rx_frame))(info);
    if (! tmp___0) {
      break;
    }
  }
  return;
}
}
static void mgsl_bh_transmit(struct mgsl_struct *info ) 
{ struct tty_struct *tty ;
  unsigned long flags ;

  {
  tty = info->tty;
  if (debug_level >= 4) {
    printk("%s(%d):mgsl_bh_transmit() entry on %s\n", "drivers/char/synclink.c", 1157,
           info->device_name);
  }
  if (tty) {
    tty_wakeup(tty);
    __wake_up(& tty->write_wait, 1U, 1, (void *)0);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (! info->tx_active) {
    if (info->loopmode_send_done_requested) {
      usc_loopmode_send_done(info);
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static void mgsl_bh_status(struct mgsl_struct *info ) 
{ 

  {
  if (debug_level >= 4) {
    printk("%s(%d):mgsl_bh_status() entry on %s\n", "drivers/char/synclink.c", 1177,
           info->device_name);
  }
  info->ri_chkcount = 0;
  info->dsr_chkcount = 0;
  info->dcd_chkcount = 0;
  info->cts_chkcount = 0;
  return;
}
}
static void mgsl_isr_receive_status(struct mgsl_struct *info ) 
{ u16 status ;
  u16 tmp ;
  u16 tmp___0 ;
  int tmp___1 ;

  {
  tmp = usc_InReg(info, (unsigned short)36);
  status = tmp;
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_receive_status status=%04X\n", "drivers/char/synclink.c",
           1200, status);
  }
  if ((int )status & 32) {
    if (info->loopmode_insert_requested) {
      tmp___1 = usc_loopmode_active(info);
      if (tmp___1) {
        info->icount.rxabort ++;
        info->loopmode_insert_requested = 0;
        info->cmr_value = (unsigned short )((int )info->cmr_value & -8193);
        usc_OutReg(info, (unsigned short)2, info->cmr_value);
        tmp___0 = usc_InReg(info, (unsigned short)38);
        usc_OutReg(info, (unsigned short)38, (unsigned short )((int )tmp___0 & -33));
      }
    }
  }
  if ((int )status & 192) {
    if ((int )status & 128) {
      info->icount.exithunt ++;
    }
    if ((int )status & 64) {
      info->icount.rxidle ++;
    }
    __wake_up(& info->event_wait_q, 1U, 1, (void *)0);
  }
  if ((int )status & 2) {
    info->icount.rxover ++;
    usc_process_rxoverrun_sync(info);
  }
  usc_OutReg(info, (unsigned short)26, (unsigned short)96);
  usc_OutReg(info, (unsigned short)36, (unsigned short )((int )status & 502));
  return;
}
}
static void mgsl_isr_transmit_status(struct mgsl_struct *info ) 
{ u16 status ;
  u16 tmp ;

  {
  tmp = usc_InReg(info, (unsigned short)52);
  status = tmp;
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_transmit_status status=%04X\n", "drivers/char/synclink.c",
           1252, status);
  }
  usc_OutReg(info, (unsigned short)26, (unsigned short)72);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         ((int )status & 255)));
  if ((int )status & 34) {
    usc_DmaCmd(info, (unsigned short)4096);
    usc_RTCmd(info, (unsigned short)20480);
  }
  if ((int )status & 16) {
    info->icount.txok ++;
  } else {
    if ((int )status & 2) {
      info->icount.txunder ++;
    } else {
      if ((int )status & 32) {
        info->icount.txabort ++;
      } else {
        info->icount.txunder ++;
      }
    }
  }
  info->tx_active = 0;
  info->xmit_tail = 0;
  info->xmit_head = info->xmit_tail;
  info->xmit_cnt = info->xmit_head;
  del_timer(& info->tx_timer);
  if (info->drop_rts_on_tx_done) {
    usc_get_serial_signals(info);
    if ((int )info->serial_signals & 32) {
      info->serial_signals = (unsigned char )((int )info->serial_signals & -33);
      usc_set_serial_signals(info);
    }
    info->drop_rts_on_tx_done = 0;
  }
  if ((info->tty)->stopped) {
    usc_stop_transmitter(info);
    return;
  } else {
    if ((info->tty)->hw_stopped) {
      usc_stop_transmitter(info);
      return;
    }
  }
  info->pending_bh |= 2U;
  return;
}
}
static void mgsl_isr_io_pin(struct mgsl_struct *info ) 
{ struct mgsl_icount *icount ;
  u16 status ;
  u16 tmp ;
  u16 tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  int tmp___3 ;
  u16 tmp___4 ;
  int tmp___5 ;
  u16 tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  u16 tmp___9 ;

  {
  tmp = usc_InReg(info, (unsigned short)28);
  status = tmp;
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_io_pin status=%04X\n", "drivers/char/synclink.c", 1320,
           status);
  }
  usc_OutReg(info, (unsigned short)26, (unsigned short)66);
  usc_OutReg(info, (unsigned short)28, (unsigned short )((int )status & 43680));
  if ((int )status & 2720) {
    icount = & info->icount;
    if ((int )status & 2048) {
      tmp___1 = info->ri_chkcount;
      info->ri_chkcount ++;
      if (tmp___1 >= 100) {
        tmp___0 = usc_InReg(info, (unsigned short)30);
        usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___0 & -3073));
      }
      icount->rng ++;
      if ((int )status & 1024) {
        info->input_signal_events.ri_up ++;
      } else {
        info->input_signal_events.ri_down ++;
      }
    }
    if ((int )status & 512) {
      tmp___3 = info->dsr_chkcount;
      info->dsr_chkcount ++;
      if (tmp___3 >= 100) {
        tmp___2 = usc_InReg(info, (unsigned short)30);
        usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___2 & -769));
      }
      icount->dsr ++;
      if ((int )status & 256) {
        info->input_signal_events.dsr_up ++;
      } else {
        info->input_signal_events.dsr_down ++;
      }
    }
    if ((int )status & 128) {
      tmp___5 = info->dcd_chkcount;
      info->dcd_chkcount ++;
      if (tmp___5 >= 100) {
        tmp___4 = usc_InReg(info, (unsigned short)30);
        usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___4 & -193));
      }
      icount->dcd ++;
      if ((int )status & 64) {
        info->input_signal_events.dcd_up ++;
      } else {
        info->input_signal_events.dcd_down ++;
      }
    }
    if ((int )status & 32) {
      tmp___7 = info->cts_chkcount;
      info->cts_chkcount ++;
      if (tmp___7 >= 100) {
        tmp___6 = usc_InReg(info, (unsigned short)30);
        usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___6 & -49));
      }
      icount->cts ++;
      if ((int )status & 16) {
        info->input_signal_events.cts_up ++;
      } else {
        info->input_signal_events.cts_down ++;
      }
    }
    __wake_up(& info->status_event_wait_q, 1U, 1, (void *)0);
    __wake_up(& info->event_wait_q, 1U, 1, (void *)0);
    if (info->flags & 33554432) {
      if ((int )status & 128) {
        if (debug_level >= 5) {
          if ((int )status & 64) {
            tmp___8 = "on";
          } else {
            tmp___8 = "off";
          }
          printk("%s CD now %s...", info->device_name, tmp___8);
        }
        if ((int )status & 64) {
          __wake_up(& info->open_wait, 1U, 1, (void *)0);
        } else {
          if (debug_level >= 5) {
            printk("doing serial hangup...");
          }
          if (info->tty) {
            tty_hangup(info->tty);
          }
        }
      }
    }
    if (info->flags & 67108864) {
      if ((int )status & 32) {
        if ((info->tty)->hw_stopped) {
          if ((int )status & 16) {
            if (debug_level >= 5) {
              printk("CTS tx start...");
            }
            if (info->tty) {
              (info->tty)->hw_stopped = (unsigned char)0;
            }
            usc_start_transmitter(info);
            info->pending_bh |= 2U;
            return;
          }
        } else {
          if (! ((int )status & 16)) {
            if (debug_level >= 5) {
              printk("CTS tx stop...");
            }
            if (info->tty) {
              (info->tty)->hw_stopped = (unsigned char)1;
            }
            usc_stop_transmitter(info);
          }
        }
      }
    }
  }
  info->pending_bh |= 4U;
  if ((int )status & 8192) {
    tmp___9 = usc_InReg(info, (unsigned short)30);
    usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___9 & -12289));
    usc_OutReg(info, (unsigned short)28, (unsigned short)8192);
    info->irq_occurred = 1;
  }
  return;
}
}
static void mgsl_isr_transmit_data(struct mgsl_struct *info ) 
{ 

  {
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_transmit_data xmit_cnt=%d\n", "drivers/char/synclink.c",
           1435, info->xmit_cnt);
  }
  usc_OutReg(info, (unsigned short)26, (unsigned short)68);
  if ((info->tty)->stopped) {
    usc_stop_transmitter(info);
    return;
  } else {
    if ((info->tty)->hw_stopped) {
      usc_stop_transmitter(info);
      return;
    }
  }
  if (info->xmit_cnt) {
    usc_load_txfifo(info);
  } else {
    info->tx_active = 0;
  }
  if (info->xmit_cnt < 256) {
    info->pending_bh |= 2U;
  }
  return;
}
}
static void mgsl_isr_receive_data(struct mgsl_struct *info ) 
{ int Fifocount ;
  u16 status ;
  unsigned char DataByte ;
  struct tty_struct *tty ;
  struct mgsl_icount *icount ;
  u16 tmp ;
  unsigned short __attribute__((__always_inline__))  tmp___0 ;
  u16 tmp___1 ;

  {
  tty = info->tty;
  icount = & info->icount;
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_receive_data\n", "drivers/char/synclink.c", 1473);
  }
  usc_OutReg(info, (unsigned short)26, (unsigned short)80);
  usc_OutReg(info, (unsigned short)36, (unsigned short)20480);
  tmp = usc_InReg(info, (unsigned short)102);
  usc_OutReg(info, (unsigned short)102, (unsigned short )((int )tmp & -9));
  while (1) {
    tmp___1 = usc_InReg(info, (unsigned short)38);
    Fifocount = (int )tmp___1 >> 8;
    if (! Fifocount) {
      break;
    }
    tmp___0 = inw((int )(info->io_base + 4U));
    outw((unsigned short )(((int __attribute__((__always_inline__))  )tmp___0 & 1920) |
                           96), (int )(info->io_base + 4U));
    DataByte = (unsigned char )inb((int )(info->io_base + 4U));
    status = usc_InReg(info, (unsigned short)36);
    if ((int )status & 46) {
      usc_OutReg(info, (unsigned short)36, (unsigned short)502);
    }
    if (tty->flip.count >= 512) {
      continue;
    }
    (*(tty->flip.char_buf_ptr)) = (char )DataByte;
    icount->rx ++;
    (*(tty->flip.flag_buf_ptr)) = (unsigned char)0;
    if ((int )status & 46) {
      printk("rxerr=%04X\n", status);
      if ((int )status & 32) {
        status = (unsigned short )((int )status & -13);
        icount->brk ++;
      } else {
        if ((int )status & 4) {
          icount->parity ++;
        } else {
          if ((int )status & 8) {
            icount->frame ++;
          } else {
            if ((int )status & 2) {
              usc_RTCmd(info, (unsigned short)18432);
              icount->overrun ++;
            }
          }
        }
      }
      if ((int )status & (int )info->ignore_status_mask) {
        continue;
      }
      status = (unsigned short )((int )status & (int )info->read_status_mask);
      if ((int )status & 32) {
        (*(tty->flip.flag_buf_ptr)) = (unsigned char)1;
        if (info->flags & 4) {
          do_SAK(tty);
        }
      } else {
        if ((int )status & 4) {
          (*(tty->flip.flag_buf_ptr)) = (unsigned char)3;
        } else {
          if ((int )status & 8) {
            (*(tty->flip.flag_buf_ptr)) = (unsigned char)2;
          }
        }
      }
      if ((int )status & 2) {
        if (tty->flip.count < 512) {
          tty->flip.count ++;
          tty->flip.flag_buf_ptr ++;
          tty->flip.char_buf_ptr ++;
          (*(tty->flip.flag_buf_ptr)) = (unsigned char)4;
        }
      }
    }
    tty->flip.flag_buf_ptr ++;
    tty->flip.char_buf_ptr ++;
    tty->flip.count ++;
  }
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_receive_data flip count=%d\n", "drivers/char/synclink.c",
           1558, tty->flip.count);
    printk("%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d\n", "drivers/char/synclink.c",
           1560, icount->rx, icount->brk, icount->parity, icount->frame, icount->overrun);
  }
  if (tty->flip.count) {
    tty_flip_buffer_push(tty);
  }
  return;
}
}
static void mgsl_isr_misc(struct mgsl_struct *info ) 
{ u16 status ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
  tmp = usc_InReg(info, (unsigned short)28);
  status = tmp;
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_misc status=%04X\n", "drivers/char/synclink.c", 1581,
           status);
  }
  if ((int )status & 8) {
    if (info->params.mode == 2UL) {
      tmp___0 = usc_InReg(info, (unsigned short)34);
      usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___0 & 65532) |
                                                             0));
      usc_DmaCmd(info, (unsigned short)4608);
      usc_OutReg(info, (unsigned short)36, (unsigned short)502);
      usc_OutReg(info, (unsigned short)26, (unsigned short)112);
      tmp___1 = usc_InReg(info, (unsigned short)24);
      usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___1 & 65280) +
                                                              128) + 48));
      info->pending_bh |= 1U;
      info->rx_rcc_underrun = 1;
    }
  }
  usc_OutReg(info, (unsigned short)26, (unsigned short)65);
  usc_OutReg(info, (unsigned short)28, (unsigned short )((int )status & 15));
  return;
}
}
static void mgsl_isr_null(struct mgsl_struct *info ) 
{ 

  {
  return;
}
}
static void mgsl_isr_receive_dma(struct mgsl_struct *info ) 
{ u16 status ;

  {
  usc_OutDmaReg(info, (unsigned short)26, (unsigned short)514);
  status = usc_InDmaReg(info, (unsigned short)130);
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_receive_dma(%s) status=%04X\n", "drivers/char/synclink.c",
           1648, info->device_name, status);
  }
  info->pending_bh |= 1U;
  if ((int )status & 8) {
    info->rx_overflow = 1;
    info->icount.buf_overrun ++;
  }
  return;
}
}
static void mgsl_isr_transmit_dma(struct mgsl_struct *info ) 
{ u16 status ;
  int tmp ;

  {
  usc_OutDmaReg(info, (unsigned short)26, (unsigned short)257);
  status = usc_InDmaReg(info, (unsigned short)2);
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_isr_transmit_dma(%s) status=%04X\n", "drivers/char/synclink.c",
           1693, info->device_name, status);
  }
  if ((int )status & 4) {
    info->tx_dma_buffers_used --;
    tmp = load_next_tx_holding_buffer(info);
    if (tmp) {
      info->pending_bh |= 2U;
    }
  }
  return;
}
}
static irqreturn_t mgsl_interrupt(int irq___0 , void *dev_id , struct pt_regs *regs ) 
{ struct mgsl_struct *info ;
  u16 UscVector ;
  u16 DmaVector ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_interrupt(%d)entry.\n", "drivers/char/synclink.c", 1731, irq___0);
  }
  info = (struct mgsl_struct *)dev_id;
  if (! info) {
    return (0);
  }
  _spin_lock(& info->irq_spinlock);
  while (1) {
    tmp = usc_InReg(info, (unsigned short)20);
    UscVector = (unsigned short )((int )tmp >> 9);
    DmaVector = usc_InDmaReg(info, (unsigned short)20);
    if (debug_level >= 5) {
      printk("%s(%d):%s UscVector=%08X DmaVector=%08X\n", "drivers/char/synclink.c",
             1746, info->device_name, UscVector, DmaVector);
    }
    if (! UscVector) {
      if (! DmaVector) {
        break;
      }
    }
    if (UscVector) {
      ((*(UscIsrTable[UscVector])))(info);
    } else {
      if (((int )DmaVector & 1536) == 1024) {
        mgsl_isr_transmit_dma(info);
      } else {
        mgsl_isr_receive_dma(info);
      }
    }
    if (info->isr_overflow) {
      printk("<3>%s(%d):%s isr overflow irq=%d\n", "drivers/char/synclink.c", 1761,
             info->device_name, irq___0);
      tmp___0 = usc_InReg(info, (unsigned short)24);
      usc_OutReg(info, (unsigned short)24, (unsigned short )((int )tmp___0 & 32512));
      tmp___1 = usc_InDmaReg(info, (unsigned short)24);
      usc_OutDmaReg(info, (unsigned short)24, (unsigned short )((int )tmp___1 & -32769));
      break;
    }
  }
  if (info->pending_bh) {
    if (! info->bh_running) {
      if (! info->bh_requested) {
        if (debug_level >= 5) {
          printk("%s(%d):%s queueing bh task.\n", "drivers/char/synclink.c", 1775,
                 info->device_name);
        }
        schedule_work(& info->task);
        info->bh_requested = 1;
      }
    }
  }
  _spin_unlock(& info->irq_spinlock);
  if (debug_level >= 5) {
    printk("%s(%d):mgsl_interrupt(%d)exit.\n", "drivers/char/synclink.c", 1784, irq___0);
  }
  return (1);
}
}
static int startup(struct mgsl_struct *info ) 
{ int retval ;
  unsigned long tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  retval = 0;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_startup(%s)\n", "drivers/char/synclink.c", 1800, info->device_name);
  }
  if ((unsigned int )info->flags & 2147483648U) {
    return (0);
  }
  if (! info->xmit_buf) {
    info->xmit_buf = (unsigned char *)get_zeroed_page(208U);
    if (! info->xmit_buf) {
      printk("<3>%s(%d):%s can\'t allocate transmit buffer\n", "drivers/char/synclink.c",
             1810, info->device_name);
      return (-12);
    }
  }
  info->pending_bh = 0U;
  init_timer(& info->tx_timer);
  info->tx_timer.data = (unsigned long )info;
  info->tx_timer.function = & mgsl_tx_timeout;
  retval = mgsl_claim_resources(info);
  if (! retval) {
    retval = mgsl_adapter_test(info);
  }
  if (retval) {
    tmp___0 = capable(21);
    if (tmp___0) {
      if (info->tty) {
        set_bit(1, (unsigned long volatile   *)(& (info->tty)->flags));
      }
    }
    mgsl_release_resources(info);
    return (retval);
  }
  mgsl_change_params(info);
  if (info->tty) {
    clear_bit(1, (unsigned long volatile   *)(& (info->tty)->flags));
  }
  info->flags = (int )((unsigned int )info->flags | 2147483648U);
  return (0);
}
}
static void shutdown(struct mgsl_struct *info ) 
{ unsigned long flags ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;

  {
  if (! ((unsigned int )info->flags & 2147483648U)) {
    return;
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_shutdown(%s)\n", "drivers/char/synclink.c", 1863, info->device_name);
  }
  __wake_up(& info->status_event_wait_q, 1U, 1, (void *)0);
  __wake_up(& info->event_wait_q, 1U, 1, (void *)0);
  del_timer(& info->tx_timer);
  if (info->xmit_buf) {
    free_pages((unsigned long )info->xmit_buf, 0U);
    info->xmit_buf = (unsigned char *)((void *)0);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  tmp = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((int )tmp & 32512));
  usc_stop_receiver(info);
  usc_stop_transmitter(info);
  tmp___0 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___0 & 65280) +
                                                          128) + 63));
  tmp___1 = usc_InDmaReg(info, (unsigned short)24);
  usc_OutDmaReg(info, (unsigned short)24, (unsigned short )((int )tmp___1 & -32772));
  tmp___2 = usc_InReg(info, (unsigned short)10);
  usc_OutReg(info, (unsigned short)10, (unsigned short )(((int )tmp___2 | 32768) |
                                                         16384));
  tmp___3 = usc_InReg(info, (unsigned short)10);
  usc_OutReg(info, (unsigned short)10, (unsigned short )(((int )tmp___3 | 8192) |
                                                         4096));
  if (! info->tty) {
    info->serial_signals = (unsigned char )((int )info->serial_signals & -161);
    usc_set_serial_signals(info);
  } else {
    if (((info->tty)->termios)->c_cflag & 1024U) {
      info->serial_signals = (unsigned char )((int )info->serial_signals & -161);
      usc_set_serial_signals(info);
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  mgsl_release_resources(info);
  if (info->tty) {
    set_bit(1, (unsigned long volatile   *)(& (info->tty)->flags));
  }
  info->flags = (int )((unsigned int )info->flags & 2147483647U);
  return;
}
}
static void mgsl_program_hw(struct mgsl_struct *info ) 
{ unsigned long flags ;
  u16 tmp ;
  u16 tmp___0 ;

  {
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_stop_receiver(info);
  usc_stop_transmitter(info);
  info->xmit_tail = 0;
  info->xmit_head = info->xmit_tail;
  info->xmit_cnt = info->xmit_head;
  if (info->params.mode == 2UL) {
    usc_set_sync_mode(info);
  } else {
    if (info->params.mode == 6UL) {
      usc_set_sync_mode(info);
    } else {
      if (info->netcount) {
        usc_set_sync_mode(info);
      } else {
        usc_set_async_mode(info);
      }
    }
  }
  usc_set_serial_signals(info);
  info->dcd_chkcount = 0;
  info->cts_chkcount = 0;
  info->ri_chkcount = 0;
  info->dsr_chkcount = 0;
  tmp = usc_InReg(info, (unsigned short)30);
  usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp | 4080));
  tmp___0 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___0 & 65280) +
                                                          192) + 2));
  usc_get_serial_signals(info);
  if (info->netcount) {
    usc_start_receiver(info);
  } else {
    if (((info->tty)->termios)->c_cflag & 128U) {
      usc_start_receiver(info);
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static void mgsl_change_params(struct mgsl_struct *info ) 
{ unsigned int cflag ;
  int bits_per_char ;

  {
  if (! info->tty) {
    return;
  } else {
    if (! (info->tty)->termios) {
      return;
    }
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_change_params(%s)\n", "drivers/char/synclink.c", 1957, info->device_name);
  }
  cflag = ((info->tty)->termios)->c_cflag;
  if (cflag & 4111U) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 160);
  } else {
    info->serial_signals = (unsigned char )((int )info->serial_signals & -161);
  }
  switch ((int )(cflag & 48U)) {
  case 0: 
  info->params.data_bits = (unsigned char)5;
  break;
  case 16: 
  info->params.data_bits = (unsigned char)6;
  break;
  case 32: 
  info->params.data_bits = (unsigned char)7;
  break;
  case 48: 
  info->params.data_bits = (unsigned char)8;
  break;
  default: 
  info->params.data_bits = (unsigned char)7;
  break;
  }
  if (cflag & 64U) {
    info->params.stop_bits = (unsigned char)2;
  } else {
    info->params.stop_bits = (unsigned char)1;
  }
  info->params.parity = (unsigned char)0;
  if (cflag & 256U) {
    if (cflag & 512U) {
      info->params.parity = (unsigned char)2;
    } else {
      info->params.parity = (unsigned char)1;
    }
    if (cflag & 1073741824U) {
      info->params.parity = (unsigned char)3;
    }
  }
  bits_per_char = ((int )info->params.data_bits + (int )info->params.stop_bits) +
                  1;
  if (info->params.data_rate <= 460800UL) {
    info->params.data_rate = (unsigned long )tty_get_baud_rate(info->tty);
  }
  if (info->params.data_rate) {
    info->timeout = (int )((unsigned long )(32000 * bits_per_char) / info->params.data_rate);
  }
  info->timeout += 20;
  if (cflag & 2147483648U) {
    info->flags |= 67108864;
  } else {
    info->flags &= -67108865;
  }
  if (cflag & 2048U) {
    info->flags &= -33554433;
  } else {
    info->flags |= 33554432;
  }
  info->read_status_mask = (unsigned short)2;
  if (((info->tty)->termios)->c_iflag & 16U) {
    info->read_status_mask = (unsigned short )((int )info->read_status_mask | 12);
  }
  if (((info->tty)->termios)->c_iflag & 2U) {
    info->read_status_mask = (unsigned short )((int )info->read_status_mask | 32);
  } else {
    if (((info->tty)->termios)->c_iflag & 8U) {
      info->read_status_mask = (unsigned short )((int )info->read_status_mask | 32);
    }
  }
  if (((info->tty)->termios)->c_iflag & 4U) {
    info->ignore_status_mask = (unsigned short )((int )info->ignore_status_mask |
                                                 12);
  }
  if (((info->tty)->termios)->c_iflag & 1U) {
    info->ignore_status_mask = (unsigned short )((int )info->ignore_status_mask |
                                                 32);
    if (((info->tty)->termios)->c_iflag & 4U) {
      info->ignore_status_mask = (unsigned short )((int )info->ignore_status_mask |
                                                   2);
    }
  }
  mgsl_program_hw(info);
  return;
}
}
static void mgsl_put_char(struct tty_struct *tty , unsigned char ch ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_put_char(%d) on %s\n", "drivers/char/synclink.c", 2064, ch,
           info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_put_char");
  if (tmp) {
    return;
  }
  if (! tty) {
    return;
  } else {
    if (! info->xmit_buf) {
      return;
    }
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (info->params.mode == 1UL) {
    goto _L;
  } else {
    if (! info->tx_active) {
      _L: /* CIL Label */ 
      if ((unsigned long )info->xmit_cnt < 4095UL) {
        tmp___0 = info->xmit_head;
        info->xmit_head ++;
        (*(info->xmit_buf + tmp___0)) = ch;
        info->xmit_head = (int )((unsigned long )info->xmit_head & 4095UL);
        info->xmit_cnt ++;
      }
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static void mgsl_flush_chars(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_flush_chars() entry on %s xmit_cnt=%d\n", "drivers/char/synclink.c",
           2103, info->device_name, info->xmit_cnt);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_flush_chars");
  if (tmp) {
    return;
  }
  if (info->xmit_cnt <= 0) {
    return;
  } else {
    if (tty->stopped) {
      return;
    } else {
      if (tty->hw_stopped) {
        return;
      } else {
        if (! info->xmit_buf) {
          return;
        }
      }
    }
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_flush_chars() entry on %s starting transmitter\n", "drivers/char/synclink.c",
           2114, info->device_name);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (! info->tx_active) {
    if (info->params.mode == 2UL) {
      goto _L;
    } else {
      if (info->params.mode == 6UL) {
        _L: /* CIL Label */ 
        if (info->xmit_cnt) {
          mgsl_load_tx_dma_buffer(info, (char const   *)info->xmit_buf, (unsigned int )info->xmit_cnt);
        }
      }
    }
    usc_start_transmitter(info);
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static int mgsl_write(struct tty_struct *tty , unsigned char const   *buf , int count ) 
{ int c ;
  int ret ;
  struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  int __x ;
  int __y ;
  unsigned long _x ;
  unsigned long _y ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  ret = 0;
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_write(%s) count=%d\n", "drivers/char/synclink.c", 2155, info->device_name,
           count);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_write");
  if (tmp) {
    goto cleanup;
  }
  if (! tty) {
    goto cleanup;
  } else {
    if (! info->xmit_buf) {
      goto cleanup;
    } else {
      if (! tmp_buf) {
        goto cleanup;
      }
    }
  }
  if (info->params.mode == 2UL) {
    goto _L;
  } else {
    if (info->params.mode == 6UL) {
      _L: /* CIL Label */ 
      if (info->tx_active) {
        if (info->params.mode == 2UL) {
          ret = 0;
          goto cleanup;
        }
        if (info->tx_holding_count >= info->num_tx_holding_buffers) {
          ret = 0;
          goto cleanup;
        }
        ret = count;
        save_tx_buffer_request(info, (char const   *)buf, (unsigned int )count);
        flags = _spin_lock_irqsave(& info->irq_spinlock);
        load_next_tx_holding_buffer(info);
        _spin_unlock_irqrestore(& info->irq_spinlock, flags);
        goto cleanup;
      }
      if ((int )info->params.flags & 16384) {
        tmp___0 = usc_loopmode_active(info);
        if (! tmp___0) {
          ret = 0;
          goto cleanup;
        }
      }
      if (info->xmit_cnt) {
        ret = 0;
        mgsl_load_tx_dma_buffer(info, (char const   *)info->xmit_buf, (unsigned int )info->xmit_cnt);
        if (debug_level >= 3) {
          printk("%s(%d):mgsl_write(%s) sync xmit_cnt flushing\n", "drivers/char/synclink.c",
                 2219, info->device_name);
        }
      } else {
        if (debug_level >= 3) {
          printk("%s(%d):mgsl_write(%s) sync transmit accepted\n", "drivers/char/synclink.c",
                 2223, info->device_name);
        }
        ret = count;
        info->xmit_cnt = count;
        mgsl_load_tx_dma_buffer(info, (char const   *)buf, (unsigned int )count);
      }
    } else {
      while (1) {
        flags = _spin_lock_irqsave(& info->irq_spinlock);
        __x = count;
        _x = (4096UL - (unsigned long )info->xmit_cnt) - 1UL;
        _y = 4096UL - (unsigned long )info->xmit_head;
        if (_x < _y) {
          tmp___1 = _x;
        } else {
          tmp___1 = _y;
        }
        __y = (int )tmp___1;
        if (__x < __y) {
          tmp___2 = __x;
        } else {
          tmp___2 = __y;
        }
        c = tmp___2;
        if (c <= 0) {
          _spin_unlock_irqrestore(& info->irq_spinlock, flags);
          break;
        }
        __memcpy((void *)(info->xmit_buf + info->xmit_head), (void const   *)buf,
                 (unsigned int )c);
        info->xmit_head = (int )((unsigned long )(info->xmit_head + c) & 4095UL);
        info->xmit_cnt += c;
        _spin_unlock_irqrestore(& info->irq_spinlock, flags);
        buf += c;
        count -= c;
        ret += c;
      }
    }
  }
  if (info->xmit_cnt) {
    if (! tty->stopped) {
      if (! tty->hw_stopped) {
        flags = _spin_lock_irqsave(& info->irq_spinlock);
        if (! info->tx_active) {
          usc_start_transmitter(info);
        }
        _spin_unlock_irqrestore(& info->irq_spinlock, flags);
      }
    }
  }
  cleanup: 
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_write(%s) returning=%d\n", "drivers/char/synclink.c", 2258,
           info->device_name, ret);
  }
  return (ret);
}
}
static int mgsl_write_room(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  int ret ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_write_room");
  if (tmp) {
    return (0);
  }
  ret = (int )((4096UL - (unsigned long )info->xmit_cnt) - 1UL);
  if (ret < 0) {
    ret = 0;
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_write_room(%s)=%d\n", "drivers/char/synclink.c", 2284, info->device_name,
           ret);
  }
  if (info->params.mode == 2UL) {
    goto _L;
  } else {
    if (info->params.mode == 6UL) {
      _L: /* CIL Label */ 
      if (info->tx_active) {
        return (0);
      } else {
        return (65535);
      }
    }
  }
  return (ret);
}
}
static int mgsl_chars_in_buffer(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_chars_in_buffer(%s)\n", "drivers/char/synclink.c", 2312, info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_chars_in_buffer");
  if (tmp) {
    return (0);
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_chars_in_buffer(%s)=%d\n", "drivers/char/synclink.c", 2319,
           info->device_name, info->xmit_cnt);
  }
  if (info->params.mode == 2UL) {
    goto _L;
  } else {
    if (info->params.mode == 6UL) {
      _L: /* CIL Label */ 
      if (info->tx_active) {
        return ((int )info->max_frame_size);
      } else {
        return (0);
      }
    }
  }
  return (info->xmit_cnt);
}
}
static void mgsl_flush_buffer(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_flush_buffer(%s) entry\n", "drivers/char/synclink.c", 2347,
           info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_flush_buffer");
  if (tmp) {
    return;
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  info->xmit_tail = 0;
  info->xmit_head = info->xmit_tail;
  info->xmit_cnt = info->xmit_head;
  del_timer(& info->tx_timer);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  __wake_up(& tty->write_wait, 1U, 1, (void *)0);
  tty_wakeup(tty);
  return;
}
}
static void mgsl_send_xchar(struct tty_struct *tty , char ch ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_send_xchar(%s,%d)\n", "drivers/char/synclink.c", 2376, info->device_name,
           ch);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_send_xchar");
  if (tmp) {
    return;
  }
  info->x_char = (int )ch;
  if (ch) {
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    if (! info->tx_enabled) {
      usc_start_transmitter(info);
    }
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  }
  return;
}
}
static void mgsl_throttle(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_throttle(%s) entry\n", "drivers/char/synclink.c", 2405, info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_throttle");
  if (tmp) {
    return;
  }
  if ((tty->termios)->c_iflag & 4096U) {
    mgsl_send_xchar(tty, (char )(tty->termios)->c_cc[9]);
  }
  if ((tty->termios)->c_cflag & 2147483648U) {
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    info->serial_signals = (unsigned char )((int )info->serial_signals & -33);
    usc_set_serial_signals(info);
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  }
  return;
}
}
static void mgsl_unthrottle(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_unthrottle(%s) entry\n", "drivers/char/synclink.c", 2435,
           info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_unthrottle");
  if (tmp) {
    return;
  }
  if ((tty->termios)->c_iflag & 4096U) {
    if (info->x_char) {
      info->x_char = 0;
    } else {
      mgsl_send_xchar(tty, (char )(tty->termios)->c_cc[8]);
    }
  }
  if ((tty->termios)->c_cflag & 2147483648U) {
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    info->serial_signals = (unsigned char )((int )info->serial_signals | 32);
    usc_set_serial_signals(info);
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  }
  return;
}
}
static int mgsl_get_stats(struct mgsl_struct *info , struct mgsl_icount *user_icount ) 
{ int err ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_get_params(%s)\n", "drivers/char/synclink.c", 2471, info->device_name);
  }
  tmp___0 = copy_to_user((void *)user_icount, (void const   *)(& info->icount), (unsigned long )sizeof(struct mgsl_icount ));
  if (tmp___0) {
    err = -14;
  } else {
    err = 0;
  }
  if (err) {
    if (debug_level >= 3) {
      printk("%s(%d):mgsl_get_stats(%s) user buffer copy failed\n", "drivers/char/synclink.c",
             2477, info->device_name);
    }
    return (-14);
  }
  return (0);
}
}
static int mgsl_get_params(struct mgsl_struct *info , MGSL_PARAMS *user_params ) 
{ int err ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_get_params(%s)\n", "drivers/char/synclink.c", 2499, info->device_name);
  }
  tmp___0 = copy_to_user((void *)user_params, (void const   *)(& info->params), (unsigned long )sizeof(MGSL_PARAMS ));
  if (tmp___0) {
    err = -14;
  } else {
    err = 0;
  }
  if (err) {
    if (debug_level >= 3) {
      printk("%s(%d):mgsl_get_params(%s) user buffer copy failed\n", "drivers/char/synclink.c",
             2505, info->device_name);
    }
    return (-14);
  }
  return (0);
}
}
static int mgsl_set_params(struct mgsl_struct *info , MGSL_PARAMS *new_params ) 
{ unsigned long flags ;
  MGSL_PARAMS tmp_params ;
  int err ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_set_params %s\n", "drivers/char/synclink.c", 2531, info->device_name);
  }
  tmp___0 = copy_from_user((void *)(& tmp_params), (void const   *)new_params, (unsigned long )sizeof(MGSL_PARAMS ));
  if (tmp___0) {
    err = -14;
  } else {
    err = 0;
  }
  if (err) {
    if (debug_level >= 3) {
      printk("%s(%d):mgsl_set_params(%s) user buffer copy failed\n", "drivers/char/synclink.c",
             2537, info->device_name);
    }
    return (-14);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  __constant_memcpy((void *)(& info->params), (void const   *)(& tmp_params), sizeof(MGSL_PARAMS ));
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  mgsl_change_params(info);
  return (0);
}
}
static int mgsl_get_txidle(struct mgsl_struct *info , int *idle_mode ) 
{ int err ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_get_txidle(%s)=%d\n", "drivers/char/synclink.c", 2566, info->device_name,
           info->idle_mode);
  }
  tmp___0 = copy_to_user((void *)idle_mode, (void const   *)(& info->idle_mode), (unsigned long )sizeof(int ));
  if (tmp___0) {
    err = -14;
  } else {
    err = 0;
  }
  if (err) {
    if (debug_level >= 3) {
      printk("%s(%d):mgsl_get_txidle(%s) user buffer copy failed\n", "drivers/char/synclink.c",
             2572, info->device_name);
    }
    return (-14);
  }
  return (0);
}
}
static int mgsl_set_txidle(struct mgsl_struct *info , int idle_mode ) 
{ unsigned long flags ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_set_txidle(%s,%d)\n", "drivers/char/synclink.c", 2592, info->device_name,
           idle_mode);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  info->idle_mode = (unsigned int )idle_mode;
  usc_set_txidle(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (0);
}
}
static int mgsl_txenable(struct mgsl_struct *info , int enable ) 
{ unsigned long flags ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_txenable(%s,%d)\n", "drivers/char/synclink.c", 2619, info->device_name,
           enable);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (enable) {
    if (! info->tx_enabled) {
      usc_start_transmitter(info);
      if ((int )info->params.flags & 16384) {
        usc_loopmode_insert_request(info);
      }
    }
  } else {
    if (info->tx_enabled) {
      usc_stop_transmitter(info);
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (0);
}
}
static int mgsl_txabort(struct mgsl_struct *info ) 
{ unsigned long flags ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_txabort(%s)\n", "drivers/char/synclink.c", 2656, info->device_name);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (info->tx_active) {
    if (info->params.mode == 2UL) {
      if ((int )info->params.flags & 16384) {
        usc_loopmode_cancel_transmit(info);
      } else {
        usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                               36864));
      }
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (0);
}
}
static int mgsl_rxenable(struct mgsl_struct *info , int enable ) 
{ unsigned long flags ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_rxenable(%s,%d)\n", "drivers/char/synclink.c", 2683, info->device_name,
           enable);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (enable) {
    if (! info->rx_enabled) {
      usc_start_receiver(info);
    }
  } else {
    if (info->rx_enabled) {
      usc_stop_receiver(info);
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (0);
}
}
static int mgsl_wait_event(struct mgsl_struct *info , int *mask_ptr ) 
{ unsigned long flags ;
  int s ;
  int rc ;
  struct mgsl_icount cprev ;
  struct mgsl_icount cnow ;
  int events ;
  int mask ;
  struct _input_signal_events oldsigs ;
  struct _input_signal_events newsigs ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u16 oldreg ;
  u16 tmp___6 ;
  u16 newreg ;
  int tmp___7 ;
  int tmp___8 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___9 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___10 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___11 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___12 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___13 ;
  int __attribute__((__always_inline__))  tmp___14 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___15 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___16 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___17 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___29 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___30 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___31 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___32 ;
  u16 tmp___33 ;
  int __attribute__((__always_inline__))  tmp___34 ;
  int __ret_pu ;

  {
  rc = 0;
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  wait.flags = 0U;
  wait.task = tmp;
  wait.func = & default_wake_function;
  wait.task_list.next = (struct list_head *)((void *)0);
  wait.task_list.prev = (struct list_head *)((void *)0);
  tmp___1 = copy_from_user((void *)(& mask), (void const   *)mask_ptr, (unsigned long )sizeof(int ));
  if (tmp___1) {
    rc = -14;
  } else {
    rc = 0;
  }
  if (rc) {
    return (-14);
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_wait_event(%s,%d)\n", "drivers/char/synclink.c", 2724, info->device_name,
           mask);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_get_serial_signals(info);
  s = (int )info->serial_signals;
  if (s & 64) {
    tmp___2 = 1;
  } else {
    tmp___2 = 2;
  }
  if (s & 1) {
    tmp___3 = 16;
  } else {
    tmp___3 = 32;
  }
  if (s & 16) {
    tmp___4 = 4;
  } else {
    tmp___4 = 8;
  }
  if (s & 4) {
    tmp___5 = 64;
  } else {
    tmp___5 = 128;
  }
  events = mask & (((tmp___2 + tmp___3) + tmp___4) + tmp___5);
  if (events) {
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    goto exit;
  }
  cprev = info->icount;
  oldsigs = info->input_signal_events;
  if (mask & 768) {
    tmp___6 = usc_InReg(info, (unsigned short)38);
    oldreg = tmp___6;
    if (mask & 256) {
      tmp___7 = 128;
    } else {
      tmp___7 = 0;
    }
    if (mask & 512) {
      tmp___8 = 64;
    } else {
      tmp___8 = 0;
    }
    newreg = (u16 )(((int )oldreg + tmp___7) + tmp___8);
    if ((int )oldreg != (int )newreg) {
      usc_OutReg(info, (unsigned short)38, newreg);
    }
  }
  while (1) {
    tmp___12 = get_current();
    __xchg(1UL, (void volatile   *)(& tmp___12->state), (int )sizeof(tmp___11->state));
    break;
  }
  add_wait_queue(& info->event_wait_q, & wait);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  while (1) {
    schedule();
    tmp___13 = get_current();
    tmp___14 = signal_pending((struct task_struct *)tmp___13);
    if (tmp___14) {
      rc = -512;
      break;
    }
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    cnow = info->icount;
    newsigs = info->input_signal_events;
    while (1) {
      tmp___18 = get_current();
      __xchg(1UL, (void volatile   *)(& tmp___18->state), (int )sizeof(tmp___17->state));
      break;
    }
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    if (newsigs.dsr_up == oldsigs.dsr_up) {
      if (newsigs.dsr_down == oldsigs.dsr_down) {
        if (newsigs.dcd_up == oldsigs.dcd_up) {
          if (newsigs.dcd_down == oldsigs.dcd_down) {
            if (newsigs.cts_up == oldsigs.cts_up) {
              if (newsigs.cts_down == oldsigs.cts_down) {
                if (newsigs.ri_up == oldsigs.ri_up) {
                  if (newsigs.ri_down == oldsigs.ri_down) {
                    if (cnow.exithunt == cprev.exithunt) {
                      if (cnow.rxidle == cprev.rxidle) {
                        rc = -5;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (newsigs.dsr_up != oldsigs.dsr_up) {
      tmp___19 = 1;
    } else {
      tmp___19 = 0;
    }
    if (newsigs.dsr_down != oldsigs.dsr_down) {
      tmp___20 = 2;
    } else {
      tmp___20 = 0;
    }
    if (newsigs.dcd_up != oldsigs.dcd_up) {
      tmp___21 = 16;
    } else {
      tmp___21 = 0;
    }
    if (newsigs.dcd_down != oldsigs.dcd_down) {
      tmp___22 = 32;
    } else {
      tmp___22 = 0;
    }
    if (newsigs.cts_up != oldsigs.cts_up) {
      tmp___23 = 4;
    } else {
      tmp___23 = 0;
    }
    if (newsigs.cts_down != oldsigs.cts_down) {
      tmp___24 = 8;
    } else {
      tmp___24 = 0;
    }
    if (newsigs.ri_up != oldsigs.ri_up) {
      tmp___25 = 64;
    } else {
      tmp___25 = 0;
    }
    if (newsigs.ri_down != oldsigs.ri_down) {
      tmp___26 = 128;
    } else {
      tmp___26 = 0;
    }
    if (cnow.exithunt != cprev.exithunt) {
      tmp___27 = 256;
    } else {
      tmp___27 = 0;
    }
    if (cnow.rxidle != cprev.rxidle) {
      tmp___28 = 512;
    } else {
      tmp___28 = 0;
    }
    events = mask & (((((((((tmp___19 + tmp___20) + tmp___21) + tmp___22) + tmp___23) +
                         tmp___24) + tmp___25) + tmp___26) + tmp___27) + tmp___28);
    if (events) {
      break;
    }
    cprev = cnow;
    oldsigs = newsigs;
  }
  remove_wait_queue(& info->event_wait_q, & wait);
  while (1) {
    tmp___32 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___32->state), (int )sizeof(tmp___31->state));
    break;
  }
  if (mask & 768) {
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    tmp___34 = waitqueue_active(& info->event_wait_q);
    if (! tmp___34) {
      tmp___33 = usc_InReg(info, (unsigned short)38);
      usc_OutReg(info, (unsigned short)38, (unsigned short )((int )tmp___33 & -193));
    }
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  }
  exit: 
  if (rc == 0) {
    switch ((int )sizeof((*mask_ptr))) {
    case 1: 
    __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (events), "c" (mask_ptr));
    break;
    case 2: 
    __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (events), "c" (mask_ptr));
    break;
    case 4: 
    __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (events), "c" (mask_ptr));
    break;
    case 8: 
    __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "A" (events), "c" (mask_ptr));
    break;
    default: 
    __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "c" (mask_ptr));
    break;
    }
    rc = __ret_pu;
  }
  return (rc);
}
}
static int modem_input_wait(struct mgsl_struct *info , int arg ) 
{ unsigned long flags ;
  int rc ;
  struct mgsl_icount cprev ;
  struct mgsl_icount cnow ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___1 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___2 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___3 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___4 ;
  int __attribute__((__always_inline__))  tmp___5 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___6 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___7 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___8 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___9 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___10 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___11 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___12 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___13 ;

  {
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  wait.flags = 0U;
  wait.task = tmp;
  wait.func = & default_wake_function;
  wait.task_list.next = (struct list_head *)((void *)0);
  wait.task_list.prev = (struct list_head *)((void *)0);
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  cprev = info->icount;
  add_wait_queue(& info->status_event_wait_q, & wait);
  while (1) {
    tmp___3 = get_current();
    __xchg(1UL, (void volatile   *)(& tmp___3->state), (int )sizeof(tmp___2->state));
    break;
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  while (1) {
    schedule();
    tmp___4 = get_current();
    tmp___5 = signal_pending((struct task_struct *)tmp___4);
    if (tmp___5) {
      rc = -512;
      break;
    }
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    cnow = info->icount;
    while (1) {
      tmp___9 = get_current();
      __xchg(1UL, (void volatile   *)(& tmp___9->state), (int )sizeof(tmp___8->state));
      break;
    }
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    if (cnow.rng == cprev.rng) {
      if (cnow.dsr == cprev.dsr) {
        if (cnow.dcd == cprev.dcd) {
          if (cnow.cts == cprev.cts) {
            rc = -5;
            break;
          }
        }
      }
    }
    if (arg & 128) {
      if (cnow.rng != cprev.rng) {
        rc = 0;
        break;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (arg & 256) {
        if (cnow.dsr != cprev.dsr) {
          rc = 0;
          break;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (arg & 64) {
          if (cnow.dcd != cprev.dcd) {
            rc = 0;
            break;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          if (arg & 32) {
            if (cnow.cts != cprev.cts) {
              rc = 0;
              break;
            }
          }
        }
      }
    }
    cprev = cnow;
  }
  remove_wait_queue(& info->status_event_wait_q, & wait);
  while (1) {
    tmp___13 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___13->state), (int )sizeof(tmp___12->state));
    break;
  }
  return (rc);
}
}
static int tiocmget(struct tty_struct *tty , struct file *file ) 
{ struct mgsl_struct *info ;
  unsigned int result ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_get_serial_signals(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  if ((int )info->serial_signals & 32) {
    tmp = 4;
  } else {
    tmp = 0;
  }
  if ((int )info->serial_signals & 128) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  if ((int )info->serial_signals & 1) {
    tmp___1 = 64;
  } else {
    tmp___1 = 0;
  }
  if ((int )info->serial_signals & 4) {
    tmp___2 = 128;
  } else {
    tmp___2 = 0;
  }
  if ((int )info->serial_signals & 64) {
    tmp___3 = 256;
  } else {
    tmp___3 = 0;
  }
  if ((int )info->serial_signals & 16) {
    tmp___4 = 32;
  } else {
    tmp___4 = 0;
  }
  result = (unsigned int )(((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4);
  if (debug_level >= 3) {
    printk("%s(%d):%s tiocmget() value=%08X\n", "drivers/char/synclink.c", 2900, info->device_name,
           result);
  }
  return ((int )result);
}
}
static int tiocmset(struct tty_struct *tty , struct file *file , unsigned int set ,
                    unsigned int clear ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):%s tiocmset(%x,%x)\n", "drivers/char/synclink.c", 2914, info->device_name,
           set, clear);
  }
  if (set & 4U) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 32);
  }
  if (set & 2U) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 128);
  }
  if (clear & 4U) {
    info->serial_signals = (unsigned char )((int )info->serial_signals & -33);
  }
  if (clear & 2U) {
    info->serial_signals = (unsigned char )((int )info->serial_signals & -129);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_set_serial_signals(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (0);
}
}
static void mgsl_break(struct tty_struct *tty , int break_state ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_break(%s,%d)\n", "drivers/char/synclink.c", 2945, info->device_name,
           break_state);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_break");
  if (tmp) {
    return;
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if (break_state == -1) {
    tmp___0 = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )((int )tmp___0 | 128));
  } else {
    tmp___1 = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )((int )tmp___1 & -129));
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return;
}
}
static int mgsl_ioctl(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                      unsigned long arg ) 
{ struct mgsl_struct *info ;
  int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_ioctl %s cmd=%08X\n", "drivers/char/synclink.c", 2976, info->device_name,
           cmd);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_ioctl");
  if (tmp) {
    return (-19);
  }
  if (cmd != 21534U) {
    if (cmd != 21535U) {
      if (cmd != 21596U) {
        if (cmd != 21597U) {
          if (tty->flags & 2UL) {
            return (-5);
          }
        }
      }
    }
  }
  tmp___0 = mgsl_ioctl_common(info, cmd, arg);
  return (tmp___0);
}
}
static int mgsl_ioctl_common(struct mgsl_struct *info , unsigned int cmd , unsigned long arg ) 
{ int error ;
  struct mgsl_icount cnow ;
  void *argp ;
  struct serial_icounter_struct *p_cuser ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int __ret_pu ;
  int __ret_pu___0 ;
  int __ret_pu___1 ;
  int __ret_pu___2 ;
  int __ret_pu___3 ;
  int __ret_pu___4 ;
  int __ret_pu___5 ;
  int __ret_pu___6 ;
  int __ret_pu___7 ;
  int __ret_pu___8 ;
  int __ret_pu___9 ;

  {
  argp = (void *)arg;
  switch ((int )cmd) {
  case 2147511553U | (sizeof(struct _MGSL_PARAMS ) << 16): 
  tmp = mgsl_get_params(info, (MGSL_PARAMS *)argp);
  return (tmp);
  case 1073769728U | (sizeof(struct _MGSL_PARAMS ) << 16): 
  tmp___0 = mgsl_set_params(info, (MGSL_PARAMS *)argp);
  return (tmp___0);
  case 27907U: 
  tmp___1 = mgsl_get_txidle(info, (int *)argp);
  return (tmp___1);
  case 27906U: 
  tmp___2 = mgsl_set_txidle(info, (int )arg);
  return (tmp___2);
  case 27908U: 
  tmp___3 = mgsl_txenable(info, (int )arg);
  return (tmp___3);
  case 27909U: 
  tmp___4 = mgsl_rxenable(info, (int )arg);
  return (tmp___4);
  case 27910U: 
  tmp___5 = mgsl_txabort(info);
  return (tmp___5);
  case 27911U: 
  tmp___6 = mgsl_get_stats(info, (struct mgsl_icount *)argp);
  return (tmp___6);
  case 3221253384U | (sizeof(int ) << 16): 
  tmp___7 = mgsl_wait_event(info, (int *)argp);
  return (tmp___7);
  case 27913U: 
  tmp___8 = mgsl_loopmode_send_done(info);
  return (tmp___8);
  case 21596: 
  tmp___9 = modem_input_wait(info, (int )arg);
  return (tmp___9);
  case 21597: 
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  cnow = info->icount;
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  p_cuser = (struct serial_icounter_struct *)argp;
  switch ((int )sizeof(p_cuser->cts)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" ((int )cnow.cts),
                       "c" (& p_cuser->cts));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" ((int )cnow.cts),
                       "c" (& p_cuser->cts));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" ((int )cnow.cts),
                       "c" (& p_cuser->cts));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "A" ((int )cnow.cts),
                       "c" (& p_cuser->cts));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "c" (& p_cuser->cts));
  break;
  }
  error = __ret_pu;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->dsr)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" ((int )cnow.dsr),
                       "c" (& p_cuser->dsr));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" ((int )cnow.dsr),
                       "c" (& p_cuser->dsr));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" ((int )cnow.dsr),
                       "c" (& p_cuser->dsr));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "A" ((int )cnow.dsr),
                       "c" (& p_cuser->dsr));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "c" (& p_cuser->dsr));
  break;
  }
  error = __ret_pu___0;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->rng)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___1): "0" ((int )cnow.rng),
                       "c" (& p_cuser->rng));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___1): "0" ((int )cnow.rng),
                       "c" (& p_cuser->rng));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___1): "0" ((int )cnow.rng),
                       "c" (& p_cuser->rng));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___1): "A" ((int )cnow.rng),
                       "c" (& p_cuser->rng));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___1): "c" (& p_cuser->rng));
  break;
  }
  error = __ret_pu___1;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->dcd)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___2): "0" ((int )cnow.dcd),
                       "c" (& p_cuser->dcd));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___2): "0" ((int )cnow.dcd),
                       "c" (& p_cuser->dcd));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___2): "0" ((int )cnow.dcd),
                       "c" (& p_cuser->dcd));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___2): "A" ((int )cnow.dcd),
                       "c" (& p_cuser->dcd));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___2): "c" (& p_cuser->dcd));
  break;
  }
  error = __ret_pu___2;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->rx)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___3): "0" ((int )cnow.rx),
                       "c" (& p_cuser->rx));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___3): "0" ((int )cnow.rx),
                       "c" (& p_cuser->rx));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___3): "0" ((int )cnow.rx),
                       "c" (& p_cuser->rx));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___3): "A" ((int )cnow.rx),
                       "c" (& p_cuser->rx));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___3): "c" (& p_cuser->rx));
  break;
  }
  error = __ret_pu___3;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->tx)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___4): "0" ((int )cnow.tx),
                       "c" (& p_cuser->tx));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___4): "0" ((int )cnow.tx),
                       "c" (& p_cuser->tx));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___4): "0" ((int )cnow.tx),
                       "c" (& p_cuser->tx));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___4): "A" ((int )cnow.tx),
                       "c" (& p_cuser->tx));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___4): "c" (& p_cuser->tx));
  break;
  }
  error = __ret_pu___4;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->frame)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___5): "0" ((int )cnow.frame),
                       "c" (& p_cuser->frame));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___5): "0" ((int )cnow.frame),
                       "c" (& p_cuser->frame));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___5): "0" ((int )cnow.frame),
                       "c" (& p_cuser->frame));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___5): "A" ((int )cnow.frame),
                       "c" (& p_cuser->frame));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___5): "c" (& p_cuser->frame));
  break;
  }
  error = __ret_pu___5;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->overrun)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___6): "0" ((int )cnow.overrun),
                       "c" (& p_cuser->overrun));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___6): "0" ((int )cnow.overrun),
                       "c" (& p_cuser->overrun));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___6): "0" ((int )cnow.overrun),
                       "c" (& p_cuser->overrun));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___6): "A" ((int )cnow.overrun),
                       "c" (& p_cuser->overrun));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___6): "c" (& p_cuser->overrun));
  break;
  }
  error = __ret_pu___6;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->parity)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___7): "0" ((int )cnow.parity),
                       "c" (& p_cuser->parity));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___7): "0" ((int )cnow.parity),
                       "c" (& p_cuser->parity));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___7): "0" ((int )cnow.parity),
                       "c" (& p_cuser->parity));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___7): "A" ((int )cnow.parity),
                       "c" (& p_cuser->parity));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___7): "c" (& p_cuser->parity));
  break;
  }
  error = __ret_pu___7;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->brk)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___8): "0" ((int )cnow.brk),
                       "c" (& p_cuser->brk));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___8): "0" ((int )cnow.brk),
                       "c" (& p_cuser->brk));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___8): "0" ((int )cnow.brk),
                       "c" (& p_cuser->brk));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___8): "A" ((int )cnow.brk),
                       "c" (& p_cuser->brk));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___8): "c" (& p_cuser->brk));
  break;
  }
  error = __ret_pu___8;
  if (error) {
    return (error);
  }
  switch ((int )sizeof(p_cuser->buf_overrun)) {
  case 1: 
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___9): "0" ((int )cnow.buf_overrun),
                       "c" (& p_cuser->buf_overrun));
  break;
  case 2: 
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___9): "0" ((int )cnow.buf_overrun),
                       "c" (& p_cuser->buf_overrun));
  break;
  case 4: 
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___9): "0" ((int )cnow.buf_overrun),
                       "c" (& p_cuser->buf_overrun));
  break;
  case 8: 
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___9): "A" ((int )cnow.buf_overrun),
                       "c" (& p_cuser->buf_overrun));
  break;
  default: 
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___9): "c" (& p_cuser->buf_overrun));
  break;
  }
  error = __ret_pu___9;
  if (error) {
    return (error);
  }
  return (0);
  default: ;
  return (-515);
  }
  return (0);
}
}
static void mgsl_set_termios(struct tty_struct *tty , struct termios *old_termios ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int __attribute__((__always_inline__))  tmp___0 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_set_termios %s\n", "drivers/char/synclink.c", 3083, (tty->driver)->name);
  }
  if ((tty->termios)->c_cflag == old_termios->c_cflag) {
    if (((tty->termios)->c_iflag & 31U) == (old_termios->c_iflag & 31U)) {
      return;
    }
  }
  mgsl_change_params(info);
  if (old_termios->c_cflag & 4111U) {
    if (! ((tty->termios)->c_cflag & 4111U)) {
      info->serial_signals = (unsigned char )((int )info->serial_signals & -161);
      flags = _spin_lock_irqsave(& info->irq_spinlock);
      usc_set_serial_signals(info);
      _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    }
  }
  if (! (old_termios->c_cflag & 4111U)) {
    if ((tty->termios)->c_cflag & 4111U) {
      info->serial_signals = (unsigned char )((int )info->serial_signals | 128);
      if (! ((tty->termios)->c_cflag & 2147483648U)) {
        info->serial_signals = (unsigned char )((int )info->serial_signals | 32);
      } else {
        tmp = constant_test_bit(0, (unsigned long const volatile   *)(& tty->flags));
        if (! tmp) {
          info->serial_signals = (unsigned char )((int )info->serial_signals | 32);
        }
      }
      flags = _spin_lock_irqsave(& info->irq_spinlock);
      usc_set_serial_signals(info);
      _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    }
  }
  if (old_termios->c_cflag & 2147483648U) {
    if (! ((tty->termios)->c_cflag & 2147483648U)) {
      tty->hw_stopped = (unsigned char)0;
      mgsl_start(tty);
    }
  }
  return;
}
}
static void mgsl_close(struct tty_struct *tty , struct file *filp ) 
{ struct mgsl_struct *info ;
  int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;
  unsigned int __attribute__((__always_inline__))  tmp___1 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_close");
  if (tmp) {
    return;
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_close(%s) entry, count=%d\n", "drivers/char/synclink.c", 3146,
           info->device_name, info->count);
  }
  if (! info->count) {
    return;
  }
  tmp___0 = tty_hung_up_p(filp);
  if (tmp___0) {
    goto cleanup;
  }
  if (tty->count == 1) {
    if (info->count != 1) {
      printk("mgsl_close: bad refcount; tty->count is 1, info->count is %d\n", info->count);
      info->count = 1;
    }
  }
  info->count --;
  if (info->count) {
    goto cleanup;
  }
  info->flags |= 134217728;
  tty->closing = (unsigned char)1;
  if ((int )info->closing_wait != 65535) {
    if (debug_level >= 3) {
      printk("%s(%d):mgsl_close(%s) calling tty_wait_until_sent\n", "drivers/char/synclink.c",
             3184, info->device_name);
    }
    tty_wait_until_sent(tty, (long )info->closing_wait);
  }
  if ((unsigned int )info->flags & 2147483648U) {
    mgsl_wait_until_sent(tty, info->timeout);
  }
  if ((tty->driver)->flush_buffer) {
    ((*((tty->driver)->flush_buffer)))(tty);
  }
  tty_ldisc_flush(tty);
  shutdown(info);
  tty->closing = (unsigned char)0;
  info->tty = (struct tty_struct *)((void *)0);
  if (info->blocked_open) {
    if (info->close_delay) {
      tmp___1 = jiffies_to_msecs((unsigned long )info->close_delay);
      msleep_interruptible((unsigned int )tmp___1);
    }
    __wake_up(& info->open_wait, 1U, 1, (void *)0);
  }
  info->flags &= -671088641;
  __wake_up(& info->close_wait, 1U, 1, (void *)0);
  cleanup: 
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_close(%s) exit, count=%d\n", "drivers/char/synclink.c", 3214,
           (tty->driver)->name, info->count);
  }
  return;
}
}
static void mgsl_wait_until_sent(struct tty_struct *tty , int timeout ) 
{ struct mgsl_struct *info ;
  unsigned long orig_jiffies ;
  unsigned long char_time ;
  int __attribute__((__always_inline__))  tmp ;
  unsigned long __x ;
  unsigned long __y ;
  unsigned long tmp___0 ;
  unsigned int __attribute__((__always_inline__))  tmp___1 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___2 ;
  int __attribute__((__always_inline__))  tmp___3 ;
  unsigned long __dummy ;
  unsigned long volatile   __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned int __attribute__((__always_inline__))  tmp___4 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___5 ;
  int __attribute__((__always_inline__))  tmp___6 ;
  unsigned long __dummy___1 ;
  unsigned long volatile   __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  u16 tmp___7 ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (! info) {
    return;
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_wait_until_sent(%s) entry\n", "drivers/char/synclink.c", 3240,
           info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_wait_until_sent");
  if (tmp) {
    return;
  }
  if (! ((unsigned int )info->flags & 2147483648U)) {
    goto exit;
  }
  orig_jiffies = (unsigned long )jiffies;
  if (info->params.data_rate) {
    char_time = (unsigned long )(info->timeout / 160);
    if (! char_time) {
      char_time ++;
    }
  } else {
    char_time = 1UL;
  }
  if (timeout) {
    __x = char_time;
    __y = (unsigned long )timeout;
    if (__x < __y) {
      tmp___0 = __x;
    } else {
      tmp___0 = __y;
    }
    char_time = tmp___0;
  }
  if (info->params.mode == 2UL) {
    goto _L;
  } else {
    if (info->params.mode == 6UL) {
      _L: /* CIL Label */ 
      while (info->tx_active) {
        tmp___1 = jiffies_to_msecs(char_time);
        msleep_interruptible((unsigned int )tmp___1);
        tmp___2 = get_current();
        tmp___3 = signal_pending((struct task_struct *)tmp___2);
        if (tmp___3) {
          break;
        }
        if (timeout) {
          if ((long )(orig_jiffies + (unsigned long )timeout) - (long )jiffies < 0L) {
            break;
          }
        }
      }
    } else {
      while (1) {
        tmp___7 = usc_InReg(info, (unsigned short)52);
        if ((int )tmp___7 & 4) {
          break;
        } else {
          if (! info->tx_enabled) {
            break;
          }
        }
        tmp___4 = jiffies_to_msecs(char_time);
        msleep_interruptible((unsigned int )tmp___4);
        tmp___5 = get_current();
        tmp___6 = signal_pending((struct task_struct *)tmp___5);
        if (tmp___6) {
          break;
        }
        if (timeout) {
          if ((long )(orig_jiffies + (unsigned long )timeout) - (long )jiffies < 0L) {
            break;
          }
        }
      }
    }
  }
  exit: 
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_wait_until_sent(%s) exit\n", "drivers/char/synclink.c", 3289,
           info->device_name);
  }
  return;
}
}
static void mgsl_hangup(struct tty_struct *tty ) 
{ struct mgsl_struct *info ;
  int __attribute__((__always_inline__))  tmp ;

  {
  info = (struct mgsl_struct *)tty->driver_data;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_hangup(%s)\n", "drivers/char/synclink.c", 3307, info->device_name);
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_hangup");
  if (tmp) {
    return;
  }
  mgsl_flush_buffer(tty);
  shutdown(info);
  info->count = 0;
  info->flags &= -536870913;
  info->tty = (struct tty_struct *)((void *)0);
  __wake_up(& info->open_wait, 1U, 1, (void *)0);
  return;
}
}
static int block_til_ready(struct tty_struct *tty , struct file *filp , struct mgsl_struct *info ) 
{ wait_queue_t wait ;
  struct task_struct *tmp ;
  int retval ;
  int do_clocal ;
  int extra_count ;
  unsigned long flags ;
  int tmp___0 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___1 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___2 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___3 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___4 ;
  int tmp___5 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___6 ;
  int __attribute__((__always_inline__))  tmp___7 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___8 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___9 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___10 ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___11 ;

  {
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  tmp = (struct task_struct *)get_current();
  wait.flags = 0U;
  wait.task = tmp;
  wait.func = & default_wake_function;
  wait.task_list.next = (struct list_head *)((void *)0);
  wait.task_list.prev = (struct list_head *)((void *)0);
  do_clocal = 0;
  extra_count = 0;
  if (debug_level >= 3) {
    printk("%s(%d):block_til_ready on %s\n", "drivers/char/synclink.c", 3346, (tty->driver)->name);
  }
  if (filp->f_flags & 2048U) {
    info->flags |= 536870912;
    return (0);
  } else {
    if (tty->flags & 2UL) {
      info->flags |= 536870912;
      return (0);
    }
  }
  if ((tty->termios)->c_cflag & 2048U) {
    do_clocal = 1;
  }
  retval = 0;
  add_wait_queue(& info->open_wait, & wait);
  if (debug_level >= 3) {
    printk("%s(%d):block_til_ready before block on %s count=%d\n", "drivers/char/synclink.c",
           3369, (tty->driver)->name, info->count);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  tmp___0 = tty_hung_up_p(filp);
  if (! tmp___0) {
    extra_count = 1;
    info->count --;
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  info->blocked_open ++;
  while (1) {
    if ((tty->termios)->c_cflag & 4111U) {
      flags = _spin_lock_irqsave(& info->irq_spinlock);
      info->serial_signals = (unsigned char )((int )info->serial_signals | 160);
      usc_set_serial_signals(info);
      _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    }
    while (1) {
      tmp___4 = get_current();
      __xchg(1UL, (void volatile   *)(& tmp___4->state), (int )sizeof(tmp___3->state));
      break;
    }
    tmp___5 = tty_hung_up_p(filp);
    if (tmp___5) {
      goto _L;
    } else {
      if (! ((unsigned int )info->flags & 2147483648U)) {
        _L: /* CIL Label */ 
        if (info->flags & 1) {
          retval = -11;
        } else {
          retval = -512;
        }
        break;
      }
    }
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    usc_get_serial_signals(info);
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    if (! (info->flags & 134217728)) {
      if (do_clocal) {
        break;
      } else {
        if ((int )info->serial_signals & 1) {
          break;
        }
      }
    }
    tmp___6 = get_current();
    tmp___7 = signal_pending((struct task_struct *)tmp___6);
    if (tmp___7) {
      retval = -512;
      break;
    }
    if (debug_level >= 3) {
      printk("%s(%d):block_til_ready blocking on %s count=%d\n", "drivers/char/synclink.c",
             3411, (tty->driver)->name, info->count);
    }
    schedule();
  }
  while (1) {
    tmp___11 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___11->state), (int )sizeof(tmp___10->state));
    break;
  }
  remove_wait_queue(& info->open_wait, & wait);
  if (extra_count) {
    info->count ++;
  }
  info->blocked_open --;
  if (debug_level >= 3) {
    printk("%s(%d):block_til_ready after blocking on %s count=%d\n", "drivers/char/synclink.c",
           3425, (tty->driver)->name, info->count);
  }
  if (! retval) {
    info->flags |= 536870912;
  }
  return (retval);
}
}
static int mgsl_open(struct tty_struct *tty , struct file *filp ) 
{ struct mgsl_struct *info ;
  int retval ;
  int line ;
  unsigned long page ;
  unsigned long flags ;
  int __attribute__((__always_inline__))  tmp ;
  int tmp___0 ;

  {
  line = tty->index;
  if (line < 0) {
    printk("%s(%d):mgsl_open with invalid line #%d.\n", "drivers/char/synclink.c",
           3455, line);
    return (-19);
  } else {
    if (line >= mgsl_device_count) {
      printk("%s(%d):mgsl_open with invalid line #%d.\n", "drivers/char/synclink.c",
             3455, line);
      return (-19);
    }
  }
  info = mgsl_device_list;
  while (1) {
    if (info) {
      if (! (info->line != line)) {
        break;
      }
    } else {
      break;
    }
    info = info->next_device;
  }
  tmp = mgsl_paranoia_check(info, tty->name, "mgsl_open");
  if (tmp) {
    return (-19);
  }
  tty->driver_data = (void *)info;
  info->tty = tty;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_open(%s), old ref count = %d\n", "drivers/char/synclink.c",
           3471, (tty->driver)->name, info->count);
  }
  tmp___0 = tty_hung_up_p(filp);
  if (tmp___0) {
    goto _L;
  } else {
    if (info->flags & 134217728) {
      _L: /* CIL Label */ 
      if (info->flags & 134217728) {
        interruptible_sleep_on(& info->close_wait);
      }
      if (info->flags & 1) {
        retval = -11;
      } else {
        retval = -512;
      }
      goto cleanup;
    }
  }
  if (! tmp_buf) {
    page = get_zeroed_page(208U);
    if (! page) {
      retval = -12;
      goto cleanup;
    }
    if (tmp_buf) {
      free_pages(page, 0U);
    } else {
      tmp_buf = (unsigned char *)page;
    }
  }
  if (info->flags & 8192) {
    (info->tty)->low_latency = (unsigned char)1;
  } else {
    (info->tty)->low_latency = (unsigned char)0;
  }
  flags = _spin_lock_irqsave(& info->netlock);
  if (info->netcount) {
    retval = -16;
    _spin_unlock_irqrestore(& info->netlock, flags);
    goto cleanup;
  }
  info->count ++;
  _spin_unlock_irqrestore(& info->netlock, flags);
  if (info->count == 1) {
    retval = startup(info);
    if (retval < 0) {
      goto cleanup;
    }
  }
  retval = block_til_ready(tty, filp, info);
  if (retval) {
    if (debug_level >= 3) {
      printk("%s(%d):block_til_ready(%s) returned %d\n", "drivers/char/synclink.c",
             3516, info->device_name, retval);
    }
    goto cleanup;
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_open(%s) success\n", "drivers/char/synclink.c", 3522, info->device_name);
  }
  retval = 0;
  cleanup: 
  if (retval) {
    if (tty->count == 1) {
      info->tty = (struct tty_struct *)((void *)0);
    }
    if (info->count) {
      info->count --;
    }
  }
  return (retval);
}
}
__inline static int __attribute__((__always_inline__))  line_info(char *buf , struct mgsl_struct *info ) 
{ char stat_buf[30] ;
  int ret ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  u16 Tcsr ;
  u16 tmp___13 ;
  u16 Tdmr ;
  u16 tmp___14 ;
  u16 Ticr ;
  u16 tmp___15 ;
  u16 Rscr ;
  u16 tmp___16 ;
  u16 Rdmr ;
  u16 tmp___17 ;
  u16 Ricr ;
  u16 tmp___18 ;
  u16 Icr ;
  u16 tmp___19 ;
  u16 Dccr ;
  u16 tmp___20 ;
  u16 Tmr ;
  u16 tmp___21 ;
  u16 Tccr ;
  u16 tmp___22 ;
  u16 Ccar ;
  u16 tmp___23 ;
  int tmp___24 ;

  {
  if (info->bus_type == 5U) {
    ret = sprintf(buf, "%s:PCI io:%04X irq:%d mem:%08X lcr:%08X", info->device_name,
                  info->io_base, info->irq_level, info->phys_memory_base, info->phys_lcr_base);
  } else {
    ret = sprintf(buf, "%s:(E)ISA io:%04X irq:%d dma:%d", info->device_name, info->io_base,
                  info->irq_level, info->dma_level);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_get_serial_signals(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  stat_buf[0] = (char)0;
  stat_buf[1] = (char)0;
  if ((int )info->serial_signals & 32) {
    strcat(stat_buf, "|RTS");
  }
  if ((int )info->serial_signals & 16) {
    strcat(stat_buf, "|CTS");
  }
  if ((int )info->serial_signals & 128) {
    strcat(stat_buf, "|DTR");
  }
  if ((int )info->serial_signals & 64) {
    strcat(stat_buf, "|DSR");
  }
  if ((int )info->serial_signals & 1) {
    strcat(stat_buf, "|CD");
  }
  if ((int )info->serial_signals & 4) {
    strcat(stat_buf, "|RI");
  }
  if (info->params.mode == 2UL) {
    goto _L;
  } else {
    if (info->params.mode == 6UL) {
      _L: /* CIL Label */ 
      tmp = sprintf(buf + ret, " HDLC txok:%d rxok:%d", info->icount.txok, info->icount.rxok);
      ret += tmp;
      if (info->icount.txunder) {
        tmp___0 = sprintf(buf + ret, " txunder:%d", info->icount.txunder);
        ret += tmp___0;
      }
      if (info->icount.txabort) {
        tmp___1 = sprintf(buf + ret, " txabort:%d", info->icount.txabort);
        ret += tmp___1;
      }
      if (info->icount.rxshort) {
        tmp___2 = sprintf(buf + ret, " rxshort:%d", info->icount.rxshort);
        ret += tmp___2;
      }
      if (info->icount.rxlong) {
        tmp___3 = sprintf(buf + ret, " rxlong:%d", info->icount.rxlong);
        ret += tmp___3;
      }
      if (info->icount.rxover) {
        tmp___4 = sprintf(buf + ret, " rxover:%d", info->icount.rxover);
        ret += tmp___4;
      }
      if (info->icount.rxcrc) {
        tmp___5 = sprintf(buf + ret, " rxcrc:%d", info->icount.rxcrc);
        ret += tmp___5;
      }
    } else {
      tmp___6 = sprintf(buf + ret, " ASYNC tx:%d rx:%d", info->icount.tx, info->icount.rx);
      ret += tmp___6;
      if (info->icount.frame) {
        tmp___7 = sprintf(buf + ret, " fe:%d", info->icount.frame);
        ret += tmp___7;
      }
      if (info->icount.parity) {
        tmp___8 = sprintf(buf + ret, " pe:%d", info->icount.parity);
        ret += tmp___8;
      }
      if (info->icount.brk) {
        tmp___9 = sprintf(buf + ret, " brk:%d", info->icount.brk);
        ret += tmp___9;
      }
      if (info->icount.overrun) {
        tmp___10 = sprintf(buf + ret, " oe:%d", info->icount.overrun);
        ret += tmp___10;
      }
    }
  }
  tmp___11 = sprintf(buf + ret, " %s\n", stat_buf + 1);
  ret += tmp___11;
  tmp___12 = sprintf(buf + ret, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
                     info->tx_active, info->bh_requested, info->bh_running, info->pending_bh);
  ret += tmp___12;
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  tmp___13 = usc_InReg(info, (unsigned short)52);
  Tcsr = tmp___13;
  tmp___14 = usc_InDmaReg(info, (unsigned short)2);
  Tdmr = tmp___14;
  tmp___15 = usc_InReg(info, (unsigned short)54);
  Ticr = tmp___15;
  tmp___16 = usc_InReg(info, (unsigned short)36);
  Rscr = tmp___16;
  tmp___17 = usc_InDmaReg(info, (unsigned short)130);
  Rdmr = tmp___17;
  tmp___18 = usc_InReg(info, (unsigned short)38);
  Ricr = tmp___18;
  tmp___19 = usc_InReg(info, (unsigned short)24);
  Icr = tmp___19;
  tmp___20 = usc_InReg(info, (unsigned short)26);
  Dccr = tmp___20;
  tmp___21 = usc_InReg(info, (unsigned short)50);
  Tmr = tmp___21;
  tmp___22 = usc_InReg(info, (unsigned short)60);
  Tccr = tmp___22;
  tmp___23 = (u16 )inw((int )(info->io_base + 4U));
  Ccar = tmp___23;
  tmp___24 = sprintf(buf + ret, "tcsr=%04X tdmr=%04X ticr=%04X rcsr=%04X rdmr=%04X\nricr=%04X icr =%04X dccr=%04X tmr=%04X tccr=%04X ccar=%04X\n",
                     Tcsr, Tdmr, Ticr, Rscr, Rdmr, Ricr, Icr, Dccr, Tmr, Tccr, Ccar);
  ret += tmp___24;
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return ((int __attribute__((__always_inline__))  )ret);
}
}
static int mgsl_read_proc(char *page , char **start , off_t off , int count , int *eof ,
                          void *data ) 
{ int len ;
  int l ;
  off_t begin ;
  struct mgsl_struct *info ;
  int tmp ;
  off_t tmp___0 ;

  {
  len = 0;
  begin = (off_t )0;
  tmp = sprintf(page, "synclink driver:%s\n", driver_version);
  len += tmp;
  info = mgsl_device_list;
  while (info) {
    l = (int )line_info(page + len, info);
    len += l;
    if ((off_t )len + begin > off + (off_t )count) {
      goto done;
    }
    if ((off_t )len + begin < off) {
      begin += (off_t )len;
      len = 0;
    }
    info = info->next_device;
  }
  (*eof) = 1;
  done: 
  if (off >= (off_t )len + begin) {
    return (0);
  }
  (*start) = page + (off - begin);
  if ((off_t )count < (begin + (off_t )len) - off) {
    tmp___0 = (long )count;
  } else {
    tmp___0 = (begin + (off_t )len) - off;
  }
  return ((int )tmp___0);
}
}
static int mgsl_allocate_dma_buffers(struct mgsl_struct *info ) 
{ unsigned short BuffersPerFrame ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  info->last_mem_alloc = 0U;
  BuffersPerFrame = (unsigned short )((unsigned long )info->max_frame_size / 4096UL);
  if ((unsigned long )info->max_frame_size % 4096UL) {
    BuffersPerFrame = (unsigned short )((int )BuffersPerFrame + 1);
  }
  if (info->bus_type == 5U) {
    info->tx_buffer_count = (unsigned int )(info->num_tx_dma_buffers * (int )BuffersPerFrame);
    info->rx_buffer_count = 62U - info->tx_buffer_count;
  } else {
    info->tx_buffer_count = (unsigned int )(info->num_tx_dma_buffers * (int )BuffersPerFrame);
    info->rx_buffer_count = (unsigned int )((int )BuffersPerFrame * 7 + 6);
    if (info->tx_buffer_count + info->rx_buffer_count > 62U) {
      info->rx_buffer_count = 62U - info->tx_buffer_count;
    }
  }
  if (debug_level >= 3) {
    printk("%s(%d):Allocating %d TX and %d RX DMA buffers.\n", "drivers/char/synclink.c",
           3755, info->tx_buffer_count, info->rx_buffer_count);
  }
  tmp = mgsl_alloc_buffer_list_memory(info);
  if (tmp < 0) {
    printk("%s(%d):Can\'t allocate DMA buffer memory\n", "drivers/char/synclink.c",
           3762);
    return (-12);
  } else {
    tmp___0 = mgsl_alloc_frame_memory(info, info->rx_buffer_list, (int )info->rx_buffer_count);
    if (tmp___0 < 0) {
      printk("%s(%d):Can\'t allocate DMA buffer memory\n", "drivers/char/synclink.c",
             3762);
      return (-12);
    } else {
      tmp___1 = mgsl_alloc_frame_memory(info, info->tx_buffer_list, (int )info->tx_buffer_count);
      if (tmp___1 < 0) {
        printk("%s(%d):Can\'t allocate DMA buffer memory\n", "drivers/char/synclink.c",
               3762);
        return (-12);
      } else {
        tmp___2 = mgsl_alloc_intermediate_rxbuffer_memory(info);
        if (tmp___2 < 0) {
          printk("%s(%d):Can\'t allocate DMA buffer memory\n", "drivers/char/synclink.c",
                 3762);
          return (-12);
        } else {
          tmp___3 = mgsl_alloc_intermediate_txbuffer_memory(info);
          if (tmp___3 < 0) {
            printk("%s(%d):Can\'t allocate DMA buffer memory\n", "drivers/char/synclink.c",
                   3762);
            return (-12);
          }
        }
      }
    }
  }
  mgsl_reset_rx_dma_buffers(info);
  mgsl_reset_tx_dma_buffers(info);
  return (0);
}
}
static int mgsl_alloc_buffer_list_memory(struct mgsl_struct *info ) 
{ unsigned int i ;

  {
  if (info->bus_type == 5U) {
    info->buffer_list = (char *)(info->memory_base + info->last_mem_alloc);
    info->buffer_list_phys = (unsigned long )info->last_mem_alloc;
    info->last_mem_alloc = (unsigned int )((unsigned long )info->last_mem_alloc +
                                           4096UL);
  } else {
    info->buffer_list = (char *)kmalloc(4096U, 209U);
    if ((unsigned int )info->buffer_list == (unsigned int )((void *)0)) {
      return (-12);
    }
    info->buffer_list_phys = (unsigned long )virt_to_phys((void volatile   *)info->buffer_list);
  }
  __constant_c_and_count_memset((void *)info->buffer_list, 0UL, 4096U);
  info->rx_buffer_list = (DMABUFFERENTRY *)info->buffer_list;
  info->tx_buffer_list = (DMABUFFERENTRY *)info->buffer_list;
  info->tx_buffer_list += info->rx_buffer_count;
  i = 0U;
  while (i < info->rx_buffer_count) {
    (info->rx_buffer_list + i)->phys_entry = (unsigned int )(info->buffer_list_phys +
                                                             (unsigned long )(i *
                                                                              sizeof(DMABUFFERENTRY )));
    (info->rx_buffer_list + i)->link = (unsigned int )info->buffer_list_phys;
    if (i < info->rx_buffer_count - 1U) {
      (info->rx_buffer_list + i)->link = (info->rx_buffer_list + i)->link + (i + 1U) *
                                                                            sizeof(DMABUFFERENTRY );
    }
    i ++;
  }
  i = 0U;
  while (i < info->tx_buffer_count) {
    (info->tx_buffer_list + i)->phys_entry = (unsigned int )(info->buffer_list_phys +
                                                             (unsigned long )((info->rx_buffer_count +
                                                                               i) *
                                                                              sizeof(DMABUFFERENTRY )));
    (info->tx_buffer_list + i)->link = (unsigned int )(info->buffer_list_phys + (unsigned long )(info->rx_buffer_count *
                                                                                                 sizeof(DMABUFFERENTRY )));
    if (i < info->tx_buffer_count - 1U) {
      (info->tx_buffer_list + i)->link = (info->tx_buffer_list + i)->link + (i + 1U) *
                                                                            sizeof(DMABUFFERENTRY );
    }
    i ++;
  }
  return (0);
}
}
static void mgsl_free_buffer_list_memory(struct mgsl_struct *info ) 
{ 

  {
  if (info->buffer_list) {
    if (info->bus_type != 5U) {
      kfree((void const   *)info->buffer_list);
    }
  }
  info->buffer_list = (char *)((void *)0);
  info->rx_buffer_list = (DMABUFFERENTRY *)((void *)0);
  info->tx_buffer_list = (DMABUFFERENTRY *)((void *)0);
  return;
}
}
static int mgsl_alloc_frame_memory(struct mgsl_struct *info , DMABUFFERENTRY *BufferList ,
                                   int Buffercount ) 
{ int i ;
  unsigned long phys_addr ;

  {
  i = 0;
  while (i < Buffercount) {
    if (info->bus_type == 5U) {
      (BufferList + i)->virt_addr = (char *)(info->memory_base + info->last_mem_alloc);
      phys_addr = (unsigned long )info->last_mem_alloc;
      info->last_mem_alloc = (unsigned int )((unsigned long )info->last_mem_alloc +
                                             4096UL);
    } else {
      (BufferList + i)->virt_addr = (char *)kmalloc(4096U, 209U);
      if ((unsigned int )(BufferList + i)->virt_addr == (unsigned int )((void *)0)) {
        return (-12);
      }
      phys_addr = (unsigned long )virt_to_phys((void volatile   *)(BufferList + i)->virt_addr);
    }
    (BufferList + i)->phys_addr = (unsigned int )phys_addr;
    i ++;
  }
  return (0);
}
}
static void mgsl_free_frame_memory(struct mgsl_struct *info , DMABUFFERENTRY *BufferList ,
                                   int Buffercount ) 
{ int i ;

  {
  if (BufferList) {
    i = 0;
    while (i < Buffercount) {
      if ((BufferList + i)->virt_addr) {
        if (info->bus_type != 5U) {
          kfree((void const   *)(BufferList + i)->virt_addr);
        }
        (BufferList + i)->virt_addr = (char *)((void *)0);
      }
      i ++;
    }
  }
  return;
}
}
static void mgsl_free_dma_buffers(struct mgsl_struct *info ) 
{ 

  {
  mgsl_free_frame_memory(info, info->rx_buffer_list, (int )info->rx_buffer_count);
  mgsl_free_frame_memory(info, info->tx_buffer_list, (int )info->tx_buffer_count);
  mgsl_free_buffer_list_memory(info);
  return;
}
}
static int mgsl_alloc_intermediate_rxbuffer_memory(struct mgsl_struct *info ) 
{ 

  {
  info->intermediate_rxbuffer = (unsigned char *)kmalloc(info->max_frame_size, 209U);
  if ((unsigned int )info->intermediate_rxbuffer == (unsigned int )((void *)0)) {
    return (-12);
  }
  return (0);
}
}
static void mgsl_free_intermediate_rxbuffer_memory(struct mgsl_struct *info ) 
{ 

  {
  if (info->intermediate_rxbuffer) {
    kfree((void const   *)info->intermediate_rxbuffer);
  }
  info->intermediate_rxbuffer = (unsigned char *)((void *)0);
  return;
}
}
static int mgsl_alloc_intermediate_txbuffer_memory(struct mgsl_struct *info ) 
{ int i ;

  {
  if (debug_level >= 3) {
    printk("%s %s(%d)  allocating %d tx holding buffers\n", info->device_name, "drivers/char/synclink.c",
           4042, info->num_tx_holding_buffers);
  }
  __constant_c_and_count_memset((void *)(info->tx_holding_buffers), 0UL, sizeof(info->tx_holding_buffers));
  i = 0;
  while (i < info->num_tx_holding_buffers) {
    info->tx_holding_buffers[i].buffer = (unsigned char *)kmalloc(info->max_frame_size,
                                                                  208U);
    if ((unsigned int )info->tx_holding_buffers[i].buffer == (unsigned int )((void *)0)) {
      return (-12);
    }
    i ++;
  }
  return (0);
}
}
static void mgsl_free_intermediate_txbuffer_memory(struct mgsl_struct *info ) 
{ int i ;

  {
  i = 0;
  while (i < info->num_tx_holding_buffers) {
    if (info->tx_holding_buffers[i].buffer) {
      kfree((void const   *)info->tx_holding_buffers[i].buffer);
      info->tx_holding_buffers[i].buffer = (unsigned char *)((void *)0);
    }
    i ++;
  }
  info->get_tx_holding_index = 0;
  info->put_tx_holding_index = 0;
  info->tx_holding_count = 0;
  return;
}
}
static int load_next_tx_holding_buffer(struct mgsl_struct *info ) 
{ int ret ;
  struct tx_holding_buffer *ptx ;
  int num_free ;
  int tmp ;
  int num_needed ;
  unsigned long __attribute__((__always_inline__))  tmp___0 ;

  {
  ret = 0;
  if (info->tx_holding_count) {
    ptx = & info->tx_holding_buffers[info->get_tx_holding_index];
    tmp = num_free_tx_dma_buffers(info);
    num_free = tmp;
    num_needed = (int )((unsigned long )ptx->buffer_size / 4096UL);
    if ((unsigned long )ptx->buffer_size % 4096UL) {
      num_needed ++;
    }
    if (num_needed <= num_free) {
      info->xmit_cnt = ptx->buffer_size;
      mgsl_load_tx_dma_buffer(info, (char const   *)ptx->buffer, (unsigned int )ptx->buffer_size);
      info->tx_holding_count --;
      info->get_tx_holding_index ++;
      if (info->get_tx_holding_index >= info->num_tx_holding_buffers) {
        info->get_tx_holding_index = 0;
      }
      tmp___0 = msecs_to_jiffies(5000U);
      mod_timer(& info->tx_timer, (unsigned long )(jiffies + (unsigned long volatile   )tmp___0));
      ret = 1;
    }
  }
  return (ret);
}
}
static int save_tx_buffer_request(struct mgsl_struct *info , char const   *Buffer ,
                                  unsigned int BufferSize ) 
{ struct tx_holding_buffer *ptx ;

  {
  if (info->tx_holding_count >= info->num_tx_holding_buffers) {
    return (0);
  }
  ptx = & info->tx_holding_buffers[info->put_tx_holding_index];
  ptx->buffer_size = (int )BufferSize;
  __memcpy((void *)ptx->buffer, (void const   *)Buffer, BufferSize);
  info->tx_holding_count ++;
  info->put_tx_holding_index ++;
  if (info->put_tx_holding_index >= info->num_tx_holding_buffers) {
    info->put_tx_holding_index = 0;
  }
  return (1);
}
}
static int mgsl_claim_resources(struct mgsl_struct *info ) 
{ struct resource *tmp ;
  int tmp___0 ;
  struct resource *tmp___1 ;
  struct resource *tmp___2 ;
  int tmp___3 ;
  void __attribute__((__always_inline__))  *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = __request_region(& ioport_resource, (unsigned long )info->io_base, (unsigned long )info->io_addr_size,
                         "synclink");
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    printk("%s(%d):I/O address conflict on device %s Addr=%08X\n", "drivers/char/synclink.c",
           4168, info->device_name, info->io_base);
    return (-19);
  }
  info->io_addr_requested = 1;
  tmp___0 = request_irq(info->irq_level, & mgsl_interrupt, info->irq_flags, (char const   *)(info->device_name),
                        (void *)info);
  if (tmp___0 < 0) {
    printk("%s(%d):Cant request interrupt on device %s IRQ=%d\n", "drivers/char/synclink.c",
           4176, info->device_name, info->irq_level);
    goto errout;
  }
  info->irq_requested = 1;
  if (info->bus_type == 5U) {
    tmp___1 = __request_region(& iomem_resource, (unsigned long )info->phys_memory_base,
                               262144UL, "synclink");
    if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
      printk("%s(%d):mem addr conflict device %s Addr=%08X\n", "drivers/char/synclink.c",
             4184, info->device_name, info->phys_memory_base);
      goto errout;
    }
    info->shared_mem_requested = 1;
    tmp___2 = __request_region(& iomem_resource, (unsigned long )(info->phys_lcr_base +
                                                                  info->lcr_offset),
                               128UL, "synclink");
    if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
      printk("%s(%d):lcr mem addr conflict device %s Addr=%08X\n", "drivers/char/synclink.c",
             4190, info->device_name, info->phys_lcr_base + info->lcr_offset);
      goto errout;
    }
    info->lcr_mem_requested = 1;
    info->memory_base = (unsigned char *)ioremap((unsigned long )info->phys_memory_base,
                                                 262144UL);
    if (! info->memory_base) {
      printk("%s(%d):Cant map shared memory on device %s MemAddr=%08X\n", "drivers/char/synclink.c",
             4198, info->device_name, info->phys_memory_base);
      goto errout;
    }
    tmp___3 = mgsl_memory_test(info);
    if (! tmp___3) {
      printk("%s(%d):Failed shared memory test %s MemAddr=%08X\n", "drivers/char/synclink.c",
             4204, info->device_name, info->phys_memory_base);
      goto errout;
    }
    tmp___4 = ioremap((unsigned long )info->phys_lcr_base, 4096UL);
    info->lcr_base = (unsigned char *)(tmp___4 + info->lcr_offset);
    if (! info->lcr_base) {
      printk("%s(%d):Cant map LCR memory on device %s MemAddr=%08X\n", "drivers/char/synclink.c",
             4211, info->device_name, info->phys_lcr_base);
      goto errout;
    }
  } else {
    tmp___5 = request_dma(info->dma_level, (char const   *)(info->device_name));
    if (tmp___5 < 0) {
      printk("%s(%d):Cant request DMA channel on device %s DMA=%d\n", "drivers/char/synclink.c",
             4220, info->device_name, info->dma_level);
      mgsl_release_resources(info);
      return (-19);
    }
    info->dma_requested = 1;
    set_dma_mode(info->dma_level, (char)-64);
    enable_dma(info->dma_level);
  }
  tmp___6 = mgsl_allocate_dma_buffers(info);
  if (tmp___6 < 0) {
    printk("%s(%d):Cant allocate DMA buffers on device %s DMA=%d\n", "drivers/char/synclink.c",
           4233, info->device_name, info->dma_level);
    goto errout;
  }
  return (0);
  errout: 
  mgsl_release_resources(info);
  return (-19);
}
}
static void mgsl_release_resources(struct mgsl_struct *info ) 
{ 

  {
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_release_resources(%s) entry\n", "drivers/char/synclink.c",
           4248, info->device_name);
  }
  if (info->irq_requested) {
    free_irq(info->irq_level, (void *)info);
    info->irq_requested = 0;
  }
  if (info->dma_requested) {
    disable_dma(info->dma_level);
    free_dma(info->dma_level);
    info->dma_requested = 0;
  }
  mgsl_free_dma_buffers(info);
  mgsl_free_intermediate_rxbuffer_memory(info);
  mgsl_free_intermediate_txbuffer_memory(info);
  if (info->io_addr_requested) {
    __release_region(& ioport_resource, (unsigned long )info->io_base, (unsigned long )info->io_addr_size);
    info->io_addr_requested = 0;
  }
  if (info->shared_mem_requested) {
    __release_region(& iomem_resource, (unsigned long )info->phys_memory_base, 262144UL);
    info->shared_mem_requested = 0;
  }
  if (info->lcr_mem_requested) {
    __release_region(& iomem_resource, (unsigned long )(info->phys_lcr_base + info->lcr_offset),
                     128UL);
    info->lcr_mem_requested = 0;
  }
  if (info->memory_base) {
    iounmap((void volatile   *)info->memory_base);
    info->memory_base = (unsigned char *)((void *)0);
  }
  if (info->lcr_base) {
    iounmap((void volatile   *)(info->lcr_base - info->lcr_offset));
    info->lcr_base = (unsigned char *)((void *)0);
  }
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_release_resources(%s) exit\n", "drivers/char/synclink.c",
           4286, info->device_name);
  }
  return;
}
}
static void mgsl_add_device(struct mgsl_struct *info ) 
{ struct mgsl_struct *current_dev ;

  {
  info->next_device = (struct mgsl_struct *)((void *)0);
  info->line = mgsl_device_count;
  sprintf(info->device_name, "ttySL%d", info->line);
  if (info->line < 20) {
    if (maxframe[info->line]) {
      info->max_frame_size = (unsigned int )maxframe[info->line];
    }
    info->dosyncppp = dosyncppp[info->line];
    if (txdmabufs[info->line]) {
      info->num_tx_dma_buffers = txdmabufs[info->line];
      if (info->num_tx_dma_buffers < 1) {
        info->num_tx_dma_buffers = 1;
      }
    }
    if (txholdbufs[info->line]) {
      info->num_tx_holding_buffers = txholdbufs[info->line];
      if (info->num_tx_holding_buffers < 1) {
        info->num_tx_holding_buffers = 1;
      } else {
        if (info->num_tx_holding_buffers > 5) {
          info->num_tx_holding_buffers = 5;
        }
      }
    }
  }
  mgsl_device_count ++;
  if (! mgsl_device_list) {
    mgsl_device_list = info;
  } else {
    current_dev = mgsl_device_list;
    while (current_dev->next_device) {
      current_dev = current_dev->next_device;
    }
    current_dev->next_device = info;
  }
  if (info->max_frame_size < 4096U) {
    info->max_frame_size = 4096U;
  } else {
    if (info->max_frame_size > 65535U) {
      info->max_frame_size = 65535U;
    }
  }
  if (info->bus_type == 5U) {
    printk("SyncLink PCI v%d %s: IO=%04X IRQ=%d Mem=%08X,%08X MaxFrameSize=%u\n",
           info->hw_version + 1, info->device_name, info->io_base, info->irq_level,
           info->phys_memory_base, info->phys_lcr_base, info->max_frame_size);
  } else {
    printk("SyncLink ISA %s: IO=%04X IRQ=%d DMA=%d MaxFrameSize=%u\n", info->device_name,
           info->io_base, info->irq_level, info->dma_level, info->max_frame_size);
  }
  return;
}
}
static struct mgsl_struct *mgsl_allocate_device(void) 
{ struct mgsl_struct *info ;
  void __attribute__((__always_inline__))  *tmp ;
  spinlock_t __constr_expr_0 ;
  spinlock_t __constr_expr_1 ;

  {
  info = (struct mgsl_struct *)kmalloc(sizeof(struct mgsl_struct ), 208U);
  if (! info) {
    printk("Error can\'t allocate device instance data\n");
  } else {
    __constant_c_and_count_memset((void *)info, 0UL, sizeof(struct mgsl_struct ));
    info->magic = 21505;
    while (1) {
      while (1) {
        info->task.entry.next = & info->task.entry;
        info->task.entry.prev = & info->task.entry;
        break;
      }
      info->task.pending = 0UL;
      while (1) {
        info->task.func = & mgsl_bh_handler;
        info->task.data = (void *)info;
        break;
      }
      init_timer(& info->task.timer);
      break;
    }
    info->max_frame_size = 4096U;
    info->close_delay = (unsigned short)500;
    info->closing_wait = (unsigned short)30000;
    init_waitqueue_head(& info->open_wait);
    init_waitqueue_head(& info->close_wait);
    init_waitqueue_head(& info->status_event_wait_q);
    init_waitqueue_head(& info->event_wait_q);
    while (1) {
      spin_lock_init(&__constr_expr_0);
      info->irq_spinlock = __constr_expr_0;
      break;
    }
    while (1) {
      spin_lock_init(&__constr_expr_1);
      info->netlock = __constr_expr_1;
      break;
    }
    __constant_memcpy((void *)(& info->params), (void const   *)(& default_params),
                      sizeof(MGSL_PARAMS ));
    info->idle_mode = 0U;
    info->num_tx_dma_buffers = 1;
    info->num_tx_holding_buffers = 0;
  }
  return (info);
}
}
static struct tty_operations mgsl_ops  = 
     {& mgsl_open, & mgsl_close, & mgsl_write, & mgsl_put_char, & mgsl_flush_chars,
    & mgsl_write_room, & mgsl_chars_in_buffer, & mgsl_ioctl, & mgsl_set_termios, & mgsl_throttle,
    & mgsl_unthrottle, & mgsl_stop, & mgsl_start, & mgsl_hangup, & mgsl_break, & mgsl_flush_buffer,
    (void (*)(struct tty_struct *tty ))0, & mgsl_wait_until_sent, & mgsl_send_xchar,
    & mgsl_read_proc, (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                               void *data ))0, & tiocmget, & tiocmset};
static int mgsl_init_tty(void) 
{ int rc ;

  {
  serial_driver = alloc_tty_driver(128);
  if (! serial_driver) {
    return (-12);
  }
  serial_driver->owner = & __this_module;
  serial_driver->driver_name = "synclink";
  serial_driver->name = "ttySL";
  serial_driver->major = ttymajor;
  serial_driver->minor_start = 64;
  serial_driver->type = (short)3;
  serial_driver->subtype = (short)1;
  serial_driver->init_termios = tty_std_termios;
  serial_driver->init_termios.c_cflag = 3261U;
  serial_driver->flags = 4;
  tty_set_operations(serial_driver, & mgsl_ops);
  rc = tty_register_driver(serial_driver);
  if (rc < 0) {
    printk("%s(%d):Couldn\'t register serial driver\n", "drivers/char/synclink.c",
           4445);
    put_tty_driver(serial_driver);
    serial_driver = (struct tty_driver *)((void *)0);
    return (rc);
  }
  printk("%s %s, tty major#%d\n", driver_name, driver_version, serial_driver->major);
  return (0);
}
}
static void mgsl_enum_isa_devices(void) 
{ struct mgsl_struct *info ;
  int i ;

  {
  i = 0;
  while (1) {
    if (i < 10) {
      if (io[i]) {
        if (! irq[i]) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (debug_level >= 3) {
      printk("ISA device specified io=%04X,irq=%d,dma=%d\n", io[i], irq[i], dma[i]);
    }
    info = mgsl_allocate_device();
    if (! info) {
      if (debug_level >= 2) {
        printk("can\'t allocate device instance data.\n");
      }
      goto __Cont;
    }
    info->io_base = (unsigned int )io[i];
    info->irq_level = (unsigned int )irq[i];
    info->irq_level = (unsigned int )irq_canonicalize((int )info->irq_level);
    info->dma_level = (unsigned int )dma[i];
    info->bus_type = 1U;
    info->io_addr_size = 16U;
    info->irq_flags = 0UL;
    mgsl_add_device(info);
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
static void synclink_cleanup(void) 
{ int rc ;
  struct mgsl_struct *info ;
  struct mgsl_struct *tmp ;

  {
  printk("Unloading %s: %s\n", driver_name, driver_version);
  if (serial_driver) {
    rc = tty_unregister_driver(serial_driver);
    if (rc) {
      printk("%s(%d) failed to unregister tty driver err=%d\n", "drivers/char/synclink.c",
             4503, rc);
    }
    put_tty_driver(serial_driver);
  }
  info = mgsl_device_list;
  while (info) {
    mgsl_release_resources(info);
    tmp = info;
    info = info->next_device;
    kfree((void const   *)tmp);
  }
  if (tmp_buf) {
    free_pages((unsigned long )tmp_buf, 0U);
    tmp_buf = (unsigned char *)((void *)0);
  }
  if (pci_registered) {
    pci_unregister_driver(& synclink_pci_driver);
  }
  return;
}
}
static int synclink_init(void)  __attribute__((__section__(".init.text"))) ;
static int synclink_init(void) 
{ int rc ;

  {
  if (break_on_load) {
    mgsl_get_text_ptr();
    __asm__  ("   int $3":);
  }
  printk("%s %s\n", driver_name, driver_version);
  mgsl_enum_isa_devices();
  rc = pci_register_driver(& synclink_pci_driver);
  if (rc < 0) {
    printk("%s:failed to register PCI driver, error=%d\n", "drivers/char/synclink.c",
           rc);
  } else {
    pci_registered = 1;
  }
  rc = mgsl_init_tty();
  if (rc < 0) {
    goto error;
  }
  return (0);
  error: 
  synclink_cleanup();
  return (rc);
}
}
static void synclink_exit(void)  __attribute__((__section__(".exit.text"))) ;
static void synclink_exit(void) 
{ 

  {
  synclink_cleanup();
  return;
}
}
__inline static initcall_t __attribute__((__always_inline__))  __inittest(void) 
{ 

  {
  return (& synclink_init);
}
}
__inline static exitcall_t __attribute__((__always_inline__))  __exittest(void) 
{ 

  {
  return (& synclink_exit);
}
}
static void usc_RTCmd(struct mgsl_struct *info , u16 Cmd ) 
{ 

  {
  outw((unsigned short )((int )Cmd + (int )info->loopback_bits), (int )(info->io_base +
                                                                        4U));
  if (info->bus_type == 5U) {
    inw((int )(info->io_base + 4U));
  }
  return;
}
}
static void usc_DmaCmd(struct mgsl_struct *info , u16 Cmd ) 
{ 

  {
  outw((unsigned short )((int )Cmd + (int )info->mbre_bit), (int )info->io_base);
  if (info->bus_type == 5U) {
    inw((int )info->io_base);
  }
  return;
}
}
static void usc_OutDmaReg(struct mgsl_struct *info , u16 RegAddr , u16 RegValue ) 
{ 

  {
  outw((unsigned short )((int )RegAddr + (int )info->mbre_bit), (int )info->io_base);
  outw(RegValue, (int )info->io_base);
  if (info->bus_type == 5U) {
    inw((int )info->io_base);
  }
  return;
}
}
static u16 usc_InDmaReg(struct mgsl_struct *info , u16 RegAddr ) 
{ u16 tmp ;

  {
  outw((unsigned short )((int )RegAddr + (int )info->mbre_bit), (int )info->io_base);
  tmp = (u16 )inw((int )info->io_base);
  return (tmp);
}
}
static void usc_OutReg(struct mgsl_struct *info , u16 RegAddr , u16 RegValue ) 
{ 

  {
  outw((unsigned short )((int )RegAddr + (int )info->loopback_bits), (int )(info->io_base +
                                                                            4U));
  outw(RegValue, (int )(info->io_base + 4U));
  if (info->bus_type == 5U) {
    inw((int )(info->io_base + 4U));
  }
  return;
}
}
static u16 usc_InReg(struct mgsl_struct *info , u16 RegAddr ) 
{ u16 tmp ;

  {
  outw((unsigned short )((int )RegAddr + (int )info->loopback_bits), (int )(info->io_base +
                                                                            4U));
  tmp = (u16 )inw((int )(info->io_base + 4U));
  return (tmp);
}
}
static void usc_set_sdlc_mode(struct mgsl_struct *info ) 
{ u16 RegValue ;
  int PreSL1660 ;
  u16 tmp ;
  u16 tmp___0 ;
  u32 XtalSpeed ;
  u32 DpllDivisor ;
  u16 Tc ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u16 tmp___5 ;

  {
  usc_OutReg(info, (unsigned short)14, (unsigned short)31);
  RegValue = usc_InReg(info, (unsigned short)12);
  if ((int )RegValue == 17747) {
    PreSL1660 = 1;
  } else {
    PreSL1660 = 0;
  }
  if ((int )info->params.flags & 16384) {
    RegValue = (unsigned short)36358;
  } else {
    if (info->params.mode == 6UL) {
      RegValue = (unsigned short)1;
      tmp = usc_InReg(info, (unsigned short)22);
      usc_OutReg(info, (unsigned short)22, (unsigned short )(((int )tmp & -12289) |
                                                             4096));
      RegValue = (unsigned short )((int )RegValue | 1024);
    } else {
      RegValue = (unsigned short)1542;
      if ((int )info->params.flags & 1) {
        RegValue = (unsigned short )((int )RegValue | 16384);
      } else {
        if ((int )info->params.flags & 2) {
          RegValue = (unsigned short )((int )RegValue | 32768);
        } else {
          if ((int )info->params.flags & 4) {
            RegValue = (unsigned short )((int )RegValue | 49152);
          }
        }
      }
    }
    if ((int )info->params.preamble != 0) {
      RegValue = (unsigned short )((int )RegValue | 8192);
    }
  }
  if (info->params.mode == 2UL) {
    if ((int )info->params.flags & 16) {
      RegValue = (unsigned short )((int )RegValue | 4096);
    }
  }
  if ((int )info->params.addr_filter != 255) {
    usc_OutReg(info, (unsigned short)40, (unsigned short )info->params.addr_filter);
    RegValue = (unsigned short )((int )RegValue | 16);
  }
  usc_OutReg(info, (unsigned short)2, RegValue);
  info->cmr_value = RegValue;
  RegValue = (unsigned short)1280;
  switch ((int )info->params.encoding) {
  case 1: 
  RegValue = (unsigned short )((int )RegValue | 8192);
  break;
  case 2: 
  RegValue = (unsigned short )((int )RegValue | 16384);
  break;
  case 3: 
  RegValue = (unsigned short )((int )RegValue | 24576);
  break;
  case 4: 
  RegValue = (unsigned short )((int )RegValue | 32768);
  break;
  case 5: 
  RegValue = (unsigned short )((int )RegValue | 40960);
  break;
  case 6: 
  RegValue = (unsigned short )((int )RegValue | 49152);
  break;
  case 7: 
  RegValue = (unsigned short )((int )RegValue | 57344);
  break;
  }
  if (((int )info->params.crc_type & 255) == 1) {
    RegValue = (unsigned short )((int )RegValue | 512);
  } else {
    if (((int )info->params.crc_type & 255) == 2) {
      RegValue = (unsigned short )((int )RegValue | 5632);
    }
  }
  usc_OutReg(info, (unsigned short)34, RegValue);
  usc_OutReg(info, (unsigned short)42, (unsigned short)65535);
  usc_OutReg(info, (unsigned short)36, (unsigned short)28672);
  tmp___0 = usc_InReg(info, (unsigned short)38);
  RegValue = (unsigned short )((int )tmp___0 & 192);
  if (info->bus_type == 5U) {
    usc_OutReg(info, (unsigned short)38, (unsigned short )(778 | (int )RegValue));
  } else {
    usc_OutReg(info, (unsigned short)38, (unsigned short )(5130 | (int )RegValue));
  }
  usc_OutReg(info, (unsigned short)36, (unsigned short)502);
  usc_OutReg(info, (unsigned short)26, (unsigned short)96);
  RegValue = (unsigned short)1024;
  switch ((int )info->params.encoding) {
  case 1: 
  RegValue = (unsigned short )((int )RegValue | 8192);
  break;
  case 2: 
  RegValue = (unsigned short )((int )RegValue | 16384);
  break;
  case 3: 
  RegValue = (unsigned short )((int )RegValue | 24576);
  break;
  case 4: 
  RegValue = (unsigned short )((int )RegValue | 32768);
  break;
  case 5: 
  RegValue = (unsigned short )((int )RegValue | 40960);
  break;
  case 6: 
  RegValue = (unsigned short )((int )RegValue | 49152);
  break;
  case 7: 
  RegValue = (unsigned short )((int )RegValue | 57344);
  break;
  }
  if (((int )info->params.crc_type & 255) == 1) {
    RegValue = (unsigned short )((int )RegValue | 768);
  } else {
    if (((int )info->params.crc_type & 255) == 2) {
      RegValue = (unsigned short )((int )RegValue | 5888);
    }
  }
  usc_OutReg(info, (unsigned short)50, RegValue);
  usc_set_txidle(info);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         28672));
  if (info->bus_type == 5U) {
    usc_OutReg(info, (unsigned short)54, (unsigned short)1846);
  } else {
    usc_OutReg(info, (unsigned short)54, (unsigned short)5174);
  }
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         250));
  usc_OutReg(info, (unsigned short)26, (unsigned short)72);
  info->tcsr_value = (unsigned short)0;
  if (! PreSL1660) {
    info->tcsr_value = (unsigned short )((int )info->tcsr_value | 2048);
  }
  usc_OutReg(info, (unsigned short)52, info->tcsr_value);
  RegValue = (unsigned short)3904;
  if ((int )info->params.flags & 256) {
    RegValue = (unsigned short )((int )RegValue | 3);
  } else {
    if ((int )info->params.flags & 512) {
      RegValue = (unsigned short )((int )RegValue | 4);
    } else {
      if ((int )info->params.flags & 32768) {
        RegValue = (unsigned short )((int )RegValue | 6);
      } else {
        RegValue = (unsigned short )((int )RegValue | 7);
      }
    }
  }
  if ((int )info->params.flags & 1024) {
    RegValue = (unsigned short )((int )RegValue | 24);
  } else {
    if ((int )info->params.flags & 2048) {
      RegValue = (unsigned short )((int )RegValue | 32);
    } else {
      if ((int )info->params.flags & 8) {
        RegValue = (unsigned short )((int )RegValue | 56);
      } else {
        RegValue = (unsigned short )((int )RegValue | 48);
      }
    }
  }
  usc_OutReg(info, (unsigned short)16, RegValue);
  RegValue = (unsigned short)0;
  if ((int )info->params.flags & 1280) {
    if (info->bus_type == 5U) {
      XtalSpeed = 11059200U;
    } else {
      XtalSpeed = 14745600U;
    }
    if ((int )info->params.flags & 8192) {
      DpllDivisor = 16U;
      RegValue = (unsigned short )((int )RegValue | 1024);
    } else {
      if ((int )info->params.flags & 4096) {
        DpllDivisor = 8U;
        RegValue = (unsigned short )((int )RegValue | 2048);
      } else {
        DpllDivisor = 32U;
      }
    }
    if (info->params.clock_speed) {
      Tc = (unsigned short )((unsigned long )(XtalSpeed / DpllDivisor) / info->params.clock_speed);
      if (! ((((unsigned long )(XtalSpeed / DpllDivisor) % info->params.clock_speed) *
              2UL) / info->params.clock_speed)) {
        Tc = (u16 )((int )Tc - 1);
      }
    } else {
      Tc = (unsigned short)65535;
    }
    usc_OutReg(info, (unsigned short)62, Tc);
    RegValue = (unsigned short )((int )RegValue | 16);
    switch ((int )info->params.encoding) {
    case 0: ;
    case 1: ;
    case 2: ;
    case 3: 
    RegValue = (unsigned short )((int )RegValue | 256);
    break;
    case 4: ;
    case 5: 
    RegValue = (unsigned short )((int )RegValue | 512);
    break;
    case 6: ;
    case 7: 
    RegValue = (unsigned short )((int )RegValue | 768);
    break;
    }
  }
  usc_OutReg(info, (unsigned short)18, RegValue);
  usc_OutReg(info, (unsigned short)4, (unsigned short)4128);
  if ((int )info->params.flags & 32) {
    tmp___1 = usc_InReg(info, (unsigned short)30);
    usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___1 | 16));
  }
  tmp___2 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )(((int )tmp___2 & 3840) +
                                                         45056));
  usc_OutReg(info, (unsigned short)26, (unsigned short)125);
  tmp___3 = usc_InReg(info, (unsigned short)30);
  usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___3 | 8));
  tmp___4 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___4 & 65280) +
                                                          192) + 1));
  info->mbre_bit = (unsigned short)0;
  outw((unsigned short)0, (int )info->io_base);
  usc_DmaCmd(info, (unsigned short)36864);
  info->mbre_bit = (unsigned short)256;
  outw((unsigned short)256, (int )info->io_base);
  if (info->bus_type == 1U) {
    tmp___5 = usc_InReg(info, (unsigned short)10);
    usc_OutReg(info, (unsigned short)10, (unsigned short )(((int )tmp___5 | 32768) &
                                                           -16385));
  }
  if (info->bus_type == 5U) {
    usc_OutDmaReg(info, (unsigned short)6, (unsigned short)40971);
  } else {
    usc_OutDmaReg(info, (unsigned short)6, (unsigned short)32779);
  }
  usc_OutDmaReg(info, (unsigned short)130, (unsigned short)61952);
  usc_OutDmaReg(info, (unsigned short)2, (unsigned short)61952);
  usc_OutDmaReg(info, (unsigned short)24, (unsigned short)36864);
  usc_InDmaReg(info, (unsigned short)130);
  usc_InDmaReg(info, (unsigned short)2);
  usc_OutDmaReg(info, (unsigned short)26, (unsigned short)771);
  RegValue = (unsigned short)32896;
  switch ((int )info->params.preamble_length) {
  case 1: 
  RegValue = (unsigned short )((int )RegValue | 1024);
  break;
  case 2: 
  RegValue = (unsigned short )((int )RegValue | 2048);
  break;
  case 3: 
  RegValue = (unsigned short )((int )RegValue | 3072);
  break;
  }
  switch ((int )info->params.preamble) {
  case 2: 
  RegValue = (unsigned short )((int )RegValue | 4352);
  break;
  case 5: 
  RegValue = (unsigned short )((int )RegValue | 256);
  break;
  case 3: 
  RegValue = (unsigned short )((int )RegValue | 512);
  break;
  case 4: 
  RegValue = (unsigned short )((int )RegValue | 768);
  break;
  }
  usc_OutReg(info, (unsigned short)6, RegValue);
  if (info->bus_type == 5U) {
    usc_OutDmaReg(info, (unsigned short)18, (unsigned short)0);
  } else {
    usc_OutDmaReg(info, (unsigned short)18, (unsigned short)8192);
  }
  usc_stop_transmitter(info);
  usc_stop_receiver(info);
  return;
}
}
static void usc_enable_loopback(struct mgsl_struct *info , int enable ) 
{ u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;

  {
  if (enable) {
    tmp = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )((int )tmp | 192));
    usc_OutReg(info, (unsigned short)16, (unsigned short)3940);
    if (info->params.clock_speed) {
      if (info->bus_type == 5U) {
        usc_OutReg(info, (unsigned short)46, (unsigned short )(11059200UL / info->params.clock_speed -
                                                               1UL));
      } else {
        usc_OutReg(info, (unsigned short)46, (unsigned short )(14745600UL / info->params.clock_speed -
                                                               1UL));
      }
    } else {
      usc_OutReg(info, (unsigned short)46, (unsigned short)8);
    }
    tmp___0 = usc_InReg(info, (unsigned short)18);
    usc_OutReg(info, (unsigned short)18, (unsigned short )(((int )tmp___0 & -3) |
                                                           1));
    tmp___1 = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )(((int )tmp___1 & 65528) |
                                                           4));
    info->loopback_bits = (unsigned short)768;
    outw((unsigned short)768, (int )(info->io_base + 4U));
  } else {
    tmp___2 = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )((int )tmp___2 & -193));
    info->loopback_bits = (unsigned short)0;
    outw((unsigned short)0, (int )(info->io_base + 4U));
  }
  return;
}
}
static void usc_enable_aux_clock(struct mgsl_struct *info , u32 data_rate ) 
{ u32 XtalSpeed ;
  u16 Tc ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
  if (data_rate) {
    if (info->bus_type == 5U) {
      XtalSpeed = 11059200U;
    } else {
      XtalSpeed = 14745600U;
    }
    Tc = (unsigned short )(XtalSpeed / data_rate);
    if (! (((XtalSpeed % data_rate) * 2U) / data_rate)) {
      Tc = (u16 )((int )Tc - 1);
    }
    usc_OutReg(info, (unsigned short)46, Tc);
    tmp = usc_InReg(info, (unsigned short)18);
    usc_OutReg(info, (unsigned short)18, (unsigned short )(((int )tmp & -3) | 1));
    tmp___0 = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )(((int )tmp___0 & 65528) |
                                                           4));
  } else {
    tmp___1 = usc_InReg(info, (unsigned short)18);
    usc_OutReg(info, (unsigned short)18, (unsigned short )((int )tmp___1 & -2));
  }
  return;
}
}
static void usc_process_rxoverrun_sync(struct mgsl_struct *info ) 
{ int start_index ;
  int end_index ;
  int frame_start_index ;
  int start_of_frame_found ;
  int end_of_frame_found ;
  int reprogram_dma ;
  DMABUFFERENTRY *buffer_list ;
  u32 phys_addr ;
  int tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u16 tmp___5 ;
  u16 tmp___6 ;

  {
  start_of_frame_found = 0;
  end_of_frame_found = 0;
  reprogram_dma = 0;
  buffer_list = info->rx_buffer_list;
  usc_DmaCmd(info, (unsigned short)16896);
  usc_OutReg(info, (unsigned short)36, (unsigned short)12288);
  usc_RTCmd(info, (unsigned short)18432);
  end_index = (int )info->current_rx_buffer;
  start_index = end_index;
  frame_start_index = start_index;
  while (! (buffer_list + end_index)->count) {
    if (! start_of_frame_found) {
      start_of_frame_found = 1;
      frame_start_index = end_index;
      end_of_frame_found = 0;
    }
    if ((buffer_list + end_index)->status) {
      start_of_frame_found = 0;
      end_of_frame_found = 1;
    }
    end_index ++;
    if ((unsigned int )end_index == info->rx_buffer_count) {
      end_index = 0;
    }
    if (start_index == end_index) {
      mgsl_reset_rx_dma_buffers(info);
      frame_start_index = 0;
      start_of_frame_found = 0;
      reprogram_dma = 1;
      break;
    }
  }
  if (start_of_frame_found) {
    if (! end_of_frame_found) {
      start_index = frame_start_index;
      while (1) {
        tmp = start_index;
        start_index ++;
        (*((unsigned long *)(& (info->rx_buffer_list + tmp)->count))) = 4096UL;
        if ((unsigned int )start_index == info->rx_buffer_count) {
          start_index = 0;
        }
        if (! (start_index != end_index)) {
          break;
        }
      }
      reprogram_dma = 1;
    }
  }
  if (reprogram_dma) {
    usc_OutReg(info, (unsigned short)36, (unsigned short)502);
    usc_OutReg(info, (unsigned short)26, (unsigned short)112);
    usc_OutReg(info, (unsigned short)36, (unsigned short)48);
    tmp___0 = usc_InReg(info, (unsigned short)34);
    usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___0 & 65532) |
                                                           0));
    tmp___1 = usc_InReg(info, (unsigned short)4);
    usc_OutReg(info, (unsigned short)4, (unsigned short )((int )tmp___1 | 8192));
    phys_addr = (info->rx_buffer_list + frame_start_index)->phys_entry;
    usc_OutDmaReg(info, (unsigned short)188, (unsigned short )phys_addr);
    usc_OutDmaReg(info, (unsigned short)190, (unsigned short )(phys_addr >> 16));
    usc_OutReg(info, (unsigned short)36, (unsigned short)502);
    usc_OutReg(info, (unsigned short)26, (unsigned short)112);
    tmp___2 = usc_InReg(info, (unsigned short)24);
    usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___2 & 65280) +
                                                            192) + 32));
    usc_OutDmaReg(info, (unsigned short)158, (unsigned short)12);
    tmp___3 = usc_InDmaReg(info, (unsigned short)24);
    usc_OutDmaReg(info, (unsigned short)24, (unsigned short )((int )tmp___3 | 2));
    usc_DmaCmd(info, (unsigned short)29184);
    if ((int )info->params.flags & 64) {
      tmp___4 = usc_InReg(info, (unsigned short)34);
      usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___4 & 65532) |
                                                             3));
    } else {
      tmp___5 = usc_InReg(info, (unsigned short)34);
      usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___5 & 65532) |
                                                             2));
    }
  } else {
    tmp___6 = usc_InReg(info, (unsigned short)4);
    usc_OutReg(info, (unsigned short)4, (unsigned short )((int )tmp___6 | 8192));
    usc_RTCmd(info, (unsigned short)18432);
  }
  return;
}
}
static void usc_stop_receiver(struct mgsl_struct *info ) 
{ u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
  if (debug_level >= 5) {
    printk("%s(%d):usc_stop_receiver(%s)\n", "drivers/char/synclink.c", 5576, info->device_name);
  }
  usc_DmaCmd(info, (unsigned short)4608);
  usc_OutReg(info, (unsigned short)36, (unsigned short)502);
  usc_OutReg(info, (unsigned short)26, (unsigned short)112);
  tmp = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp & 65280) + 128) +
                                                         48));
  tmp___0 = usc_InReg(info, (unsigned short)34);
  usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___0 & 65532) |
                                                         0));
  tmp___1 = usc_InReg(info, (unsigned short)4);
  usc_OutReg(info, (unsigned short)4, (unsigned short )((int )tmp___1 | 8192));
  usc_RTCmd(info, (unsigned short)18432);
  info->rx_enabled = 0;
  info->rx_overflow = 0;
  info->rx_rcc_underrun = 0;
  return;
}
}
static void usc_start_receiver(struct mgsl_struct *info ) 
{ u32 phys_addr ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u16 tmp___5 ;

  {
  if (debug_level >= 5) {
    printk("%s(%d):usc_start_receiver(%s)\n", "drivers/char/synclink.c", 5611, info->device_name);
  }
  mgsl_reset_rx_dma_buffers(info);
  usc_stop_receiver(info);
  tmp = usc_InReg(info, (unsigned short)4);
  usc_OutReg(info, (unsigned short)4, (unsigned short )((int )tmp | 8192));
  usc_RTCmd(info, (unsigned short)18432);
  if (info->params.mode == 2UL) {
    goto _L;
  } else {
    if (info->params.mode == 6UL) {
      _L: /* CIL Label */ 
      phys_addr = (info->rx_buffer_list + 0)->phys_entry;
      usc_OutDmaReg(info, (unsigned short)188, (unsigned short )phys_addr);
      usc_OutDmaReg(info, (unsigned short)190, (unsigned short )(phys_addr >> 16));
      usc_OutReg(info, (unsigned short)36, (unsigned short)502);
      usc_OutReg(info, (unsigned short)26, (unsigned short)112);
      tmp___0 = usc_InReg(info, (unsigned short)24);
      usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___0 & 65280) +
                                                              192) + 32));
      usc_OutDmaReg(info, (unsigned short)158, (unsigned short)12);
      tmp___1 = usc_InDmaReg(info, (unsigned short)24);
      usc_OutDmaReg(info, (unsigned short)24, (unsigned short )((int )tmp___1 | 2));
      usc_DmaCmd(info, (unsigned short)29184);
      if ((int )info->params.flags & 64) {
        tmp___2 = usc_InReg(info, (unsigned short)34);
        usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___2 & 65532) |
                                                               3));
      } else {
        tmp___3 = usc_InReg(info, (unsigned short)34);
        usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___3 & 65532) |
                                                               2));
      }
    } else {
      usc_OutReg(info, (unsigned short)36, (unsigned short)502);
      usc_OutReg(info, (unsigned short)26, (unsigned short)112);
      tmp___4 = usc_InReg(info, (unsigned short)24);
      usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___4 & 65280) +
                                                              192) + 16));
      usc_RTCmd(info, (unsigned short)18432);
      usc_OutReg(info, (unsigned short)36, (unsigned short)12288);
      tmp___5 = usc_InReg(info, (unsigned short)34);
      usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___5 & 65532) |
                                                             2));
    }
  }
  usc_OutReg(info, (unsigned short)4, (unsigned short)4128);
  info->rx_enabled = 1;
  return;
}
}
static void usc_start_transmitter(struct mgsl_struct *info ) 
{ u32 phys_addr ;
  unsigned int FrameSize ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  unsigned long __attribute__((__always_inline__))  tmp___2 ;
  u16 tmp___3 ;
  u16 tmp___4 ;

  {
  if (debug_level >= 5) {
    printk("%s(%d):usc_start_transmitter(%s)\n", "drivers/char/synclink.c", 5676,
           info->device_name);
  }
  if (info->xmit_cnt) {
    info->drop_rts_on_tx_done = 0;
    if ((int )info->params.flags & 128) {
      usc_get_serial_signals(info);
      if (! ((int )info->serial_signals & 32)) {
        info->serial_signals = (unsigned char )((int )info->serial_signals | 32);
        usc_set_serial_signals(info);
        info->drop_rts_on_tx_done = 1;
      }
    }
    if (info->params.mode == 1UL) {
      if (! info->tx_active) {
        usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                               250));
        usc_OutReg(info, (unsigned short)26, (unsigned short)76);
        tmp = usc_InReg(info, (unsigned short)24);
        usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp & 65280) +
                                                                192) + 4));
        usc_load_txfifo(info);
      }
    } else {
      usc_DmaCmd(info, (unsigned short)4096);
      FrameSize = (unsigned int )(info->tx_buffer_list + info->start_tx_dma_buffer)->rcc;
      if (info->params.mode == 6UL) {
        (info->tx_buffer_list + info->start_tx_dma_buffer)->rcc = (unsigned short)0;
      }
      usc_OutReg(info, (unsigned short)58, (unsigned short )FrameSize);
      usc_RTCmd(info, (unsigned short)20480);
      phys_addr = (info->tx_buffer_list + info->start_tx_dma_buffer)->phys_entry;
      usc_OutDmaReg(info, (unsigned short)60, (unsigned short )phys_addr);
      usc_OutDmaReg(info, (unsigned short)62, (unsigned short )(phys_addr >> 16));
      usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                             250));
      usc_OutReg(info, (unsigned short)26, (unsigned short)72);
      tmp___0 = usc_InReg(info, (unsigned short)24);
      usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___0 & 65280) +
                                                              192) + 8));
      if (info->params.mode == 6UL) {
        if (info->num_tx_dma_buffers > 1) {
          usc_OutDmaReg(info, (unsigned short)30, (unsigned short)12);
          tmp___1 = usc_InDmaReg(info, (unsigned short)24);
          usc_OutDmaReg(info, (unsigned short)24, (unsigned short )((int )tmp___1 |
                                                                    1));
        }
      }
      usc_DmaCmd(info, (unsigned short)28672);
      usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                             32768));
      tmp___2 = msecs_to_jiffies(5000U);
      info->tx_timer.expires = (unsigned long )(jiffies + (unsigned long volatile   )tmp___2);
      add_timer(& info->tx_timer);
    }
    info->tx_active = 1;
  }
  if (! info->tx_enabled) {
    info->tx_enabled = 1;
    if ((int )info->params.flags & 32) {
      tmp___3 = usc_InReg(info, (unsigned short)50);
      usc_OutReg(info, (unsigned short)50, (unsigned short )(((int )tmp___3 & 65532) |
                                                             3));
    } else {
      tmp___4 = usc_InReg(info, (unsigned short)50);
      usc_OutReg(info, (unsigned short)50, (unsigned short )(((int )tmp___4 & 65532) |
                                                             2));
    }
  }
  return;
}
}
static void usc_stop_transmitter(struct mgsl_struct *info ) 
{ u16 tmp ;
  u16 tmp___0 ;

  {
  if (debug_level >= 5) {
    printk("%s(%d):usc_stop_transmitter(%s)\n", "drivers/char/synclink.c", 5779, info->device_name);
  }
  del_timer(& info->tx_timer);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         250));
  usc_OutReg(info, (unsigned short)26, (unsigned short)76);
  tmp = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp & 65280) + 128) +
                                                         12));
  tmp___0 = usc_InReg(info, (unsigned short)50);
  usc_OutReg(info, (unsigned short)50, (unsigned short )(((int )tmp___0 & 65532) |
                                                         0));
  usc_DmaCmd(info, (unsigned short)4096);
  usc_RTCmd(info, (unsigned short)20480);
  info->tx_enabled = 0;
  info->tx_active = 0;
  return;
}
}
static void usc_load_txfifo(struct mgsl_struct *info ) 
{ int Fifocount ;
  u8 TwoBytes[2] ;
  int tmp ;
  int tmp___0 ;
  unsigned short __attribute__((__always_inline__))  tmp___1 ;
  int tmp___2 ;
  u16 tmp___3 ;

  {
  if (! info->xmit_cnt) {
    if (! info->x_char) {
      return;
    }
  }
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         20480));
  while (1) {
    tmp___3 = usc_InReg(info, (unsigned short)54);
    Fifocount = (int )tmp___3 >> 8;
    if (Fifocount) {
      if (! info->xmit_cnt) {
        break;
      }
    } else {
      break;
    }
    if (info->xmit_cnt > 1) {
      if (Fifocount > 1) {
        if (! info->x_char) {
          tmp = info->xmit_tail;
          info->xmit_tail ++;
          TwoBytes[0] = (*(info->xmit_buf + tmp));
          info->xmit_tail = (int )((unsigned long )info->xmit_tail & 4095UL);
          tmp___0 = info->xmit_tail;
          info->xmit_tail ++;
          TwoBytes[1] = (*(info->xmit_buf + tmp___0));
          info->xmit_tail = (int )((unsigned long )info->xmit_tail & 4095UL);
          outw((*((u16 *)(TwoBytes))), (int )((info->io_base + 2U) + 4U));
          info->xmit_cnt -= 2;
          info->icount.tx += 2U;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      tmp___1 = inw((int )(info->io_base + 4U));
      outw((unsigned short )(((int __attribute__((__always_inline__))  )tmp___1 &
                              1920) | 112), (int )(info->io_base + 4U));
      if (info->x_char) {
        outw((unsigned short )info->x_char, (int )(info->io_base + 4U));
        info->x_char = 0;
      } else {
        tmp___2 = info->xmit_tail;
        info->xmit_tail ++;
        outw((unsigned short )(*(info->xmit_buf + tmp___2)), (int )(info->io_base +
                                                                    4U));
        info->xmit_tail = (int )((unsigned long )info->xmit_tail & 4095UL);
        info->xmit_cnt --;
      }
      info->icount.tx ++;
    }
  }
  return;
}
}
static void usc_reset(struct mgsl_struct *info ) 
{ int i ;
  u32 readval ;
  u32 volatile   *MiscCtrl ;
  u32 *LCR0BRDR ;

  {
  if (info->bus_type == 5U) {
    MiscCtrl = (u32 volatile   *)((u32 *)(info->lcr_base + 80));
    LCR0BRDR = (u32 *)(info->lcr_base + 40);
    info->misc_ctrl_value |= 1073741824U;
    (*MiscCtrl) = info->misc_ctrl_value;
    i = 0;
    while (i < 10) {
      readval = (*MiscCtrl);
      i ++;
    }
    info->misc_ctrl_value &= 3221225471U;
    (*MiscCtrl) = info->misc_ctrl_value;
    (*LCR0BRDR) = 1749156192U;
  } else {
    outb((unsigned char)0, (int )(info->io_base + 8U));
  }
  info->mbre_bit = (unsigned short)0;
  info->loopback_bits = (unsigned short)0;
  info->usc_idle_mode = (unsigned short)0;
  outw((unsigned short)12, (int )(info->io_base + 4U));
  outw((unsigned short)0, (int )info->io_base);
  outw((unsigned short)0, (int )(info->io_base + 4U));
  usc_RTCmd(info, (unsigned short)47104);
  usc_OutReg(info, (unsigned short)10, (unsigned short)61685);
  usc_OutReg(info, (unsigned short)22, (unsigned short)4);
  return;
}
}
static void usc_set_async_mode(struct mgsl_struct *info ) 
{ u16 RegValue ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;

  {
  tmp = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((int )tmp & 32512));
  outw((unsigned short)0, (int )info->io_base);
  usc_DmaCmd(info, (unsigned short)36864);
  usc_loopback_frame(info);
  RegValue = (unsigned short)0;
  if ((int )info->params.stop_bits != 1) {
    RegValue = (unsigned short )((int )RegValue | 16384);
  }
  usc_OutReg(info, (unsigned short)2, RegValue);
  RegValue = (unsigned short)0;
  if ((int )info->params.data_bits != 8) {
    RegValue = (unsigned short )((int )RegValue | 28);
  }
  if ((int )info->params.parity != 0) {
    RegValue = (unsigned short )((int )RegValue | 32);
    if ((int )info->params.parity != 2) {
      RegValue = (unsigned short )((int )RegValue | 64);
    }
  }
  usc_OutReg(info, (unsigned short)34, RegValue);
  usc_OutReg(info, (unsigned short)36, (unsigned short)24576);
  usc_OutReg(info, (unsigned short)38, (unsigned short)0);
  usc_OutReg(info, (unsigned short)36, (unsigned short)502);
  usc_OutReg(info, (unsigned short)26, (unsigned short)96);
  RegValue = (unsigned short)0;
  if ((int )info->params.data_bits != 8) {
    RegValue = (unsigned short )((int )RegValue | 28);
  }
  if ((int )info->params.parity != 0) {
    RegValue = (unsigned short )((int )RegValue | 32);
    if ((int )info->params.parity != 2) {
      RegValue = (unsigned short )((int )RegValue | 64);
    }
  }
  usc_OutReg(info, (unsigned short)50, RegValue);
  usc_set_txidle(info);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         24576));
  usc_OutReg(info, (unsigned short)54, (unsigned short)8000);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         250));
  usc_OutReg(info, (unsigned short)26, (unsigned short)72);
  usc_enable_async_clock(info, (unsigned int )info->params.data_rate);
  usc_OutReg(info, (unsigned short)4, (unsigned short)32);
  tmp___0 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___0 & 65280) +
                                                          128) + 60));
  usc_OutReg(info, (unsigned short)26, (unsigned short)124);
  tmp___1 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )(((int )tmp___1 & 3840) +
                                                         45056));
  if (info->bus_type == 1U) {
    tmp___2 = usc_InReg(info, (unsigned short)10);
    usc_OutReg(info, (unsigned short)10, (unsigned short )(((int )tmp___2 | 8192) &
                                                           -4097));
  }
  return;
}
}
static void usc_loopback_frame(struct mgsl_struct *info ) 
{ int i ;
  unsigned long oldmode ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;

  {
  oldmode = info->params.mode;
  info->params.mode = 2UL;
  tmp = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((int )tmp & 32512));
  usc_set_sdlc_mode(info);
  usc_enable_loopback(info, 1);
  usc_OutReg(info, (unsigned short)46, (unsigned short)0);
  usc_OutReg(info, (unsigned short)6, (unsigned short)256);
  usc_RTCmd(info, (unsigned short)18432);
  tmp___0 = usc_InReg(info, (unsigned short)34);
  usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___0 & 65532) |
                                                         2));
  usc_OutReg(info, (unsigned short)58, (unsigned short)2);
  usc_RTCmd(info, (unsigned short)20480);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         250));
  outw((unsigned short)0, (int )((info->io_base + 2U) + 4U));
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         32768));
  tmp___1 = usc_InReg(info, (unsigned short)50);
  usc_OutReg(info, (unsigned short)50, (unsigned short )(((int )tmp___1 & 65532) |
                                                         2));
  i = 0;
  while (i < 1000) {
    tmp___2 = usc_InReg(info, (unsigned short)36);
    if ((int )tmp___2 & 282) {
      break;
    }
    i ++;
  }
  usc_enable_loopback(info, 0);
  tmp___3 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )(((int )tmp___3 & 3840) +
                                                         45056));
  info->params.mode = oldmode;
  return;
}
}
static void usc_set_sync_mode(struct mgsl_struct *info ) 
{ u16 tmp ;

  {
  usc_loopback_frame(info);
  usc_set_sdlc_mode(info);
  if (info->bus_type == 1U) {
    tmp = usc_InReg(info, (unsigned short)10);
    usc_OutReg(info, (unsigned short)10, (unsigned short )(((int )tmp | 8192) & -4097));
  }
  usc_enable_aux_clock(info, (unsigned int )info->params.clock_speed);
  if (info->params.loopback) {
    usc_enable_loopback(info, 1);
  }
  return;
}
}
static void usc_set_txidle(struct mgsl_struct *info ) 
{ u16 usc_idle_mode ;
  unsigned char syncpat ;

  {
  usc_idle_mode = (u16 )0;
  switch ((int )info->idle_mode) {
  case 0: 
  usc_idle_mode = (unsigned short)0;
  break;
  case 1: 
  usc_idle_mode = (unsigned short)256;
  break;
  case 2: 
  usc_idle_mode = (unsigned short)512;
  break;
  case 3: 
  usc_idle_mode = (unsigned short)768;
  break;
  case 4: 
  usc_idle_mode = (unsigned short)1280;
  break;
  case 5: 
  usc_idle_mode = (unsigned short)1536;
  break;
  case 6: 
  usc_idle_mode = (unsigned short)1792;
  break;
  }
  info->usc_idle_mode = usc_idle_mode;
  info->tcsr_value = (unsigned short )((int )info->tcsr_value & -1793);
  info->tcsr_value = (unsigned short )((int )info->tcsr_value + (int )usc_idle_mode);
  usc_OutReg(info, (unsigned short)52, info->tcsr_value);
  if (info->params.mode == 6UL) {
    syncpat = (unsigned char)0;
    switch ((int )info->idle_mode) {
    case 0: 
    syncpat = (unsigned char)126;
    break;
    case 1: 
    syncpat = (unsigned char)85;
    break;
    case 2: ;
    case 5: 
    syncpat = (unsigned char)0;
    break;
    case 3: ;
    case 6: 
    syncpat = (unsigned char)255;
    break;
    case 4: 
    syncpat = (unsigned char)170;
    break;
    }
    usc_OutReg(info, (unsigned short)56, (unsigned short )(((int )((unsigned short )syncpat) <<
                                                            8) | (int )((unsigned short )syncpat)));
  }
  return;
}
}
static void usc_get_serial_signals(struct mgsl_struct *info ) 
{ u16 status ;

  {
  info->serial_signals = (unsigned char )((int )info->serial_signals & 160);
  status = usc_InReg(info, (unsigned short)28);
  if ((int )status & 16) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 16);
  }
  if ((int )status & 64) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 1);
  }
  if ((int )status & 1024) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 4);
  }
  if ((int )status & 256) {
    info->serial_signals = (unsigned char )((int )info->serial_signals | 64);
  }
  return;
}
}
static void usc_set_serial_signals(struct mgsl_struct *info ) 
{ u16 Control ;
  unsigned char V24Out ;

  {
  V24Out = info->serial_signals;
  Control = usc_InReg(info, (unsigned short)10);
  if ((int )V24Out & 32) {
    Control = (unsigned short )((int )Control & -65);
  } else {
    Control = (unsigned short )((int )Control | 64);
  }
  if ((int )V24Out & 128) {
    Control = (unsigned short )((int )Control & -17);
  } else {
    Control = (unsigned short )((int )Control | 16);
  }
  usc_OutReg(info, (unsigned short)10, Control);
  return;
}
}
static void usc_enable_async_clock(struct mgsl_struct *info , u32 data_rate ) 
{ u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
  if (data_rate) {
    usc_OutReg(info, (unsigned short)16, (unsigned short)3940);
    if (info->bus_type == 5U) {
      usc_OutReg(info, (unsigned short)46, (unsigned short )(691200U / data_rate -
                                                             1U));
    } else {
      usc_OutReg(info, (unsigned short)46, (unsigned short )(921600U / data_rate -
                                                             1U));
    }
    tmp = usc_InReg(info, (unsigned short)18);
    usc_OutReg(info, (unsigned short)18, (unsigned short )(((int )tmp & -3) | 1));
    tmp___0 = usc_InReg(info, (unsigned short)22);
    usc_OutReg(info, (unsigned short)22, (unsigned short )(((int )tmp___0 & 65528) |
                                                           4));
  } else {
    tmp___1 = usc_InReg(info, (unsigned short)18);
    usc_OutReg(info, (unsigned short)18, (unsigned short )((int )tmp___1 & -2));
  }
  return;
}
}
static void mgsl_reset_tx_dma_buffers(struct mgsl_struct *info ) 
{ unsigned int i ;

  {
  i = 0U;
  while (i < info->tx_buffer_count) {
    (*((unsigned long *)(& (info->tx_buffer_list + i)->count))) = 0UL;
    i ++;
  }
  info->current_tx_buffer = 0;
  info->start_tx_dma_buffer = 0;
  info->tx_dma_buffers_used = 0;
  info->get_tx_holding_index = 0;
  info->put_tx_holding_index = 0;
  info->tx_holding_count = 0;
  return;
}
}
static int num_free_tx_dma_buffers(struct mgsl_struct *info ) 
{ 

  {
  return ((int )(info->tx_buffer_count - (unsigned int )info->tx_dma_buffers_used));
}
}
static void mgsl_reset_rx_dma_buffers(struct mgsl_struct *info ) 
{ unsigned int i ;

  {
  i = 0U;
  while (i < info->rx_buffer_count) {
    (*((unsigned long *)(& (info->rx_buffer_list + i)->count))) = 4096UL;
    i ++;
  }
  info->current_rx_buffer = 0U;
  return;
}
}
static void mgsl_free_rx_frame_buffers(struct mgsl_struct *info , unsigned int StartIndex ,
                                       unsigned int EndIndex ) 
{ int Done ;
  DMABUFFERENTRY *pBufEntry ;
  unsigned int Index ;

  {
  Done = 0;
  Index = StartIndex;
  while (! Done) {
    pBufEntry = info->rx_buffer_list + Index;
    if (Index == EndIndex) {
      Done = 1;
    }
    (*((unsigned long *)(& pBufEntry->count))) = 4096UL;
    Index ++;
    if (Index == info->rx_buffer_count) {
      Index = 0U;
    }
  }
  info->current_rx_buffer = Index;
  return;
}
}
static int mgsl_get_rx_frame(struct mgsl_struct *info ) 
{ unsigned int StartIndex ;
  unsigned int EndIndex ;
  unsigned short status ;
  DMABUFFERENTRY *pBufEntry ;
  unsigned int framesize ;
  int ReturnCode ;
  unsigned long flags ;
  struct tty_struct *tty ;
  int return_frame ;
  int __x ;
  int __y ;
  int tmp ;
  int copy_count ;
  int index ;
  unsigned char *ptmp ;
  int partial_count ;

  {
  framesize = 0U;
  ReturnCode = 0;
  tty = info->tty;
  return_frame = 0;
  EndIndex = info->current_rx_buffer;
  StartIndex = EndIndex;
  while (! (info->rx_buffer_list + EndIndex)->status) {
    if ((info->rx_buffer_list + EndIndex)->count) {
      goto Cleanup;
    }
    EndIndex ++;
    if (EndIndex == info->rx_buffer_count) {
      EndIndex = 0U;
    }
    if (EndIndex == StartIndex) {
      if (info->rx_enabled) {
        flags = _spin_lock_irqsave(& info->irq_spinlock);
        usc_start_receiver(info);
        _spin_unlock_irqrestore(& info->irq_spinlock, flags);
      }
      goto Cleanup;
    }
  }
  status = (info->rx_buffer_list + EndIndex)->status;
  if ((int )status & 270) {
    if ((int )status & 256) {
      info->icount.rxshort ++;
    } else {
      if ((int )status & 4) {
        info->icount.rxabort ++;
      } else {
        if ((int )status & 2) {
          info->icount.rxover ++;
        } else {
          info->icount.rxcrc ++;
          if ((int )info->params.crc_type & 32768) {
            return_frame = 1;
          }
        }
      }
    }
    framesize = 0U;
  } else {
    return_frame = 1;
  }
  if (return_frame) {
    framesize = (unsigned int )(65535 - (int )(info->rx_buffer_list + EndIndex)->rcc);
    if ((int )info->params.crc_type == 1) {
      framesize -= 2U;
    } else {
      if ((int )info->params.crc_type == 2) {
        framesize -= 4U;
      }
    }
  }
  if (debug_level >= 4) {
    printk("%s(%d):mgsl_get_rx_frame(%s) status=%04X size=%d\n", "drivers/char/synclink.c",
           6711, info->device_name, status, framesize);
  }
  if (debug_level >= 1) {
    __x = (int )framesize;
    __y = 4096;
    if (__x < __y) {
      tmp = __x;
    } else {
      tmp = __y;
    }
    mgsl_trace_block(info, (char const   *)(info->rx_buffer_list + StartIndex)->virt_addr,
                     tmp, 0);
  }
  if (framesize) {
    if ((int )info->params.crc_type & 32768) {
      if (framesize + 1U > info->max_frame_size) {
        info->icount.rxlong ++;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (framesize > info->max_frame_size) {
        info->icount.rxlong ++;
      } else {
        copy_count = (int )framesize;
        index = (int )StartIndex;
        ptmp = info->intermediate_rxbuffer;
        if (! ((int )status & 8)) {
          info->icount.rxok ++;
        }
        while (copy_count) {
          if ((unsigned long )copy_count > 4096UL) {
            partial_count = 4096;
          } else {
            partial_count = copy_count;
          }
          pBufEntry = info->rx_buffer_list + index;
          __memcpy((void *)ptmp, (void const   *)pBufEntry->virt_addr, (unsigned int )partial_count);
          ptmp += partial_count;
          copy_count -= partial_count;
          index ++;
          if ((unsigned int )index == info->rx_buffer_count) {
            index = 0;
          }
        }
        if ((int )info->params.crc_type & 32768) {
          framesize ++;
          if ((int )status & 8) {
            (*ptmp) = (unsigned char)1;
          } else {
            (*ptmp) = (unsigned char)0;
          }
          if (debug_level >= 1) {
            printk("%s(%d):mgsl_get_rx_frame(%s) rx frame status=%d\n", "drivers/char/synclink.c",
                   6755, info->device_name, (*ptmp));
          }
        }
        ldisc_receive_buf(tty, (__u8 const   *)info->intermediate_rxbuffer, info->flag_buf,
                          (int )framesize);
      }
    }
  }
  mgsl_free_rx_frame_buffers(info, StartIndex, EndIndex);
  ReturnCode = 1;
  Cleanup: 
  if (info->rx_enabled) {
    if (info->rx_overflow) {
      if (! (info->rx_buffer_list + EndIndex)->status) {
        if ((info->rx_buffer_list + EndIndex)->count) {
          flags = _spin_lock_irqsave(& info->irq_spinlock);
          usc_start_receiver(info);
          _spin_unlock_irqrestore(& info->irq_spinlock, flags);
        }
      }
    }
  }
  return (ReturnCode);
}
}
static int mgsl_get_raw_rx_frame(struct mgsl_struct *info ) 
{ unsigned int CurrentIndex ;
  unsigned int NextIndex ;
  unsigned short status ;
  DMABUFFERENTRY *pBufEntry ;
  unsigned int framesize ;
  int ReturnCode ;
  unsigned long flags ;
  struct tty_struct *tty ;
  int __x ;
  int __y ;
  int tmp ;

  {
  framesize = 0U;
  ReturnCode = 0;
  tty = info->tty;
  NextIndex = info->current_rx_buffer;
  CurrentIndex = NextIndex;
  NextIndex ++;
  if (NextIndex == info->rx_buffer_count) {
    NextIndex = 0U;
  }
  if ((int )(info->rx_buffer_list + CurrentIndex)->status != 0) {
    goto _L;
  } else {
    if ((int )(info->rx_buffer_list + CurrentIndex)->count == 0) {
      if ((int )(info->rx_buffer_list + NextIndex)->count == 0) {
        _L: /* CIL Label */ 
        status = (info->rx_buffer_list + CurrentIndex)->status;
        if ((int )status & 270) {
          if ((int )status & 256) {
            info->icount.rxshort ++;
          } else {
            if ((int )status & 4) {
              info->icount.rxabort ++;
            } else {
              if ((int )status & 2) {
                info->icount.rxover ++;
              } else {
                info->icount.rxcrc ++;
              }
            }
          }
          framesize = 0U;
        } else {
          if (status) {
            if ((info->rx_buffer_list + CurrentIndex)->rcc) {
              framesize = (unsigned int )(65535 - (int )(info->rx_buffer_list + CurrentIndex)->rcc);
            } else {
              framesize = 4096U;
            }
          } else {
            framesize = 4096U;
          }
        }
        if ((unsigned long )framesize > 4096UL) {
          framesize = (unsigned int )((unsigned long )framesize % 4096UL);
        }
        if (debug_level >= 4) {
          printk("%s(%d):mgsl_get_raw_rx_frame(%s) status=%04X size=%d\n", "drivers/char/synclink.c",
                 6922, info->device_name, status, framesize);
        }
        if (debug_level >= 1) {
          __x = (int )framesize;
          __y = 4096;
          if (__x < __y) {
            tmp = __x;
          } else {
            tmp = __y;
          }
          mgsl_trace_block(info, (char const   *)(info->rx_buffer_list + CurrentIndex)->virt_addr,
                           tmp, 0);
        }
        if (framesize) {
          pBufEntry = info->rx_buffer_list + CurrentIndex;
          __memcpy((void *)info->intermediate_rxbuffer, (void const   *)pBufEntry->virt_addr,
                   framesize);
          info->icount.rxok ++;
          ldisc_receive_buf(tty, (__u8 const   *)info->intermediate_rxbuffer, info->flag_buf,
                            (int )framesize);
        }
        mgsl_free_rx_frame_buffers(info, CurrentIndex, CurrentIndex);
        ReturnCode = 1;
      }
    }
  }
  if (info->rx_enabled) {
    if (info->rx_overflow) {
      if (! (info->rx_buffer_list + CurrentIndex)->status) {
        if ((info->rx_buffer_list + CurrentIndex)->count) {
          flags = _spin_lock_irqsave(& info->irq_spinlock);
          usc_start_receiver(info);
          _spin_unlock_irqrestore(& info->irq_spinlock, flags);
        }
      }
    }
  }
  return (ReturnCode);
}
}
static void mgsl_load_tx_dma_buffer(struct mgsl_struct *info , char const   *Buffer ,
                                    unsigned int BufferSize ) 
{ unsigned short Copycount ;
  unsigned int i ;
  DMABUFFERENTRY *pBufEntry ;
  int __x ;
  int __y ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  i = 0U;
  if (debug_level >= 1) {
    __x = (int )BufferSize;
    __y = 4096;
    if (__x < __y) {
      tmp = __x;
    } else {
      tmp = __y;
    }
    mgsl_trace_block(info, Buffer, tmp, 1);
  }
  if ((int )info->params.flags & 16384) {
    info->cmr_value = (unsigned short )((int )info->cmr_value | 8192);
  }
  i = (unsigned int )info->current_tx_buffer;
  info->start_tx_dma_buffer = (int )i;
  (info->tx_buffer_list + i)->status = (unsigned short )((int )info->cmr_value & 61440);
  (info->tx_buffer_list + i)->rcc = (unsigned short )BufferSize;
  (info->tx_buffer_list + i)->count = (unsigned short )BufferSize;
  while (BufferSize) {
    tmp___0 = i;
    i ++;
    pBufEntry = info->tx_buffer_list + tmp___0;
    if (i == info->tx_buffer_count) {
      i = 0U;
    }
    if ((unsigned long )BufferSize > 4096UL) {
      Copycount = (unsigned short)4096;
    } else {
      Copycount = (unsigned short )BufferSize;
    }
    if (info->bus_type == 5U) {
      mgsl_load_pci_memory(pBufEntry->virt_addr, Buffer, Copycount);
    } else {
      __memcpy((void *)pBufEntry->virt_addr, (void const   *)Buffer, (unsigned int )Copycount);
    }
    pBufEntry->count = Copycount;
    Buffer += (int )Copycount;
    BufferSize -= (unsigned int )Copycount;
    info->tx_dma_buffers_used ++;
  }
  info->current_tx_buffer = (int )i;
  return;
}
}
static unsigned short BitPatterns[8]  = 
  {      (unsigned short)0,      (unsigned short)65535,      (unsigned short)43690,      (unsigned short)21845, 
        (unsigned short)4660,      (unsigned short)26985,      (unsigned short)38550,      (unsigned short)3855};
static unsigned int Patterncount  =    sizeof(BitPatterns) / sizeof(unsigned short );
static int mgsl_register_test(struct mgsl_struct *info ) 
{ unsigned int i ;
  int rc ;
  unsigned long flags ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u16 tmp___5 ;
  u16 tmp___6 ;
  u16 tmp___7 ;

  {
  rc = 1;
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_reset(info);
  tmp = usc_InReg(info, (unsigned short)30);
  if ((int )tmp != 0) {
    rc = 0;
  } else {
    tmp___0 = usc_InReg(info, (unsigned short)20);
    if ((int )tmp___0 != 0) {
      rc = 0;
    } else {
      tmp___1 = usc_InDmaReg(info, (unsigned short)20);
      if ((int )tmp___1 != 0) {
        rc = 0;
      }
    }
  }
  if (rc == 1) {
    i = 0U;
    while (i < Patterncount) {
      usc_OutReg(info, (unsigned short)46, BitPatterns[i]);
      usc_OutReg(info, (unsigned short)62, BitPatterns[(i + 1U) % Patterncount]);
      usc_OutReg(info, (unsigned short)58, BitPatterns[(i + 2U) % Patterncount]);
      usc_OutReg(info, (unsigned short)42, BitPatterns[(i + 3U) % Patterncount]);
      usc_OutReg(info, (unsigned short)40, BitPatterns[(i + 4U) % Patterncount]);
      usc_OutDmaReg(info, (unsigned short)42, BitPatterns[(i + 5U) % Patterncount]);
      tmp___2 = usc_InReg(info, (unsigned short)46);
      if ((int )tmp___2 != (int )BitPatterns[i]) {
        rc = 0;
        break;
      } else {
        tmp___3 = usc_InReg(info, (unsigned short)62);
        if ((int )tmp___3 != (int )BitPatterns[(i + 1U) % Patterncount]) {
          rc = 0;
          break;
        } else {
          tmp___4 = usc_InReg(info, (unsigned short)58);
          if ((int )tmp___4 != (int )BitPatterns[(i + 2U) % Patterncount]) {
            rc = 0;
            break;
          } else {
            tmp___5 = usc_InReg(info, (unsigned short)42);
            if ((int )tmp___5 != (int )BitPatterns[(i + 3U) % Patterncount]) {
              rc = 0;
              break;
            } else {
              tmp___6 = usc_InReg(info, (unsigned short)40);
              if ((int )tmp___6 != (int )BitPatterns[(i + 4U) % Patterncount]) {
                rc = 0;
                break;
              } else {
                tmp___7 = usc_InDmaReg(info, (unsigned short)42);
                if ((int )tmp___7 != (int )BitPatterns[(i + 5U) % Patterncount]) {
                  rc = 0;
                  break;
                }
              }
            }
          }
        }
      }
      i ++;
    }
  }
  usc_reset(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (rc);
}
}
static int mgsl_irq_test(struct mgsl_struct *info ) 
{ unsigned long EndTime ;
  unsigned long flags ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  unsigned long tmp___3 ;

  {
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_reset(info);
  info->irq_occurred = 0;
  tmp = usc_InReg(info, (unsigned short)10);
  usc_OutReg(info, (unsigned short)10, (unsigned short )(((int )tmp | 8192) & -4097));
  tmp___0 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )(((int )tmp___0 & 3840) +
                                                         45056));
  tmp___1 = usc_InReg(info, (unsigned short)24);
  usc_OutReg(info, (unsigned short)24, (unsigned short )((((int )tmp___1 & 65280) +
                                                          192) + 2));
  usc_OutReg(info, (unsigned short)26, (unsigned short)66);
  usc_OutReg(info, (unsigned short)28, (unsigned short)8192);
  tmp___2 = usc_InReg(info, (unsigned short)30);
  usc_OutReg(info, (unsigned short)30, (unsigned short )((int )tmp___2 | 12288));
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  EndTime = 100UL;
  while (1) {
    tmp___3 = EndTime;
    EndTime --;
    if (tmp___3) {
      if (! (! info->irq_occurred)) {
        break;
      }
    } else {
      break;
    }
    msleep_interruptible(10U);
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_reset(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  if (! info->irq_occurred) {
    return (0);
  } else {
    return (1);
  }
}
}
static int mgsl_dma_test(struct mgsl_struct *info ) 
{ unsigned short FifoLevel ;
  unsigned long phys_addr ;
  unsigned int FrameSize ;
  unsigned int i ;
  char *TmpPtr ;
  int rc ;
  unsigned short status ;
  unsigned long EndTime ;
  unsigned long flags ;
  MGSL_PARAMS tmp_params ;
  char *tmp ;
  u16 tmp___0 ;
  unsigned long __attribute__((__always_inline__))  tmp___1 ;
  unsigned long __dummy ;
  unsigned long volatile   __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  u16 tmp___2 ;
  unsigned long __attribute__((__always_inline__))  tmp___3 ;
  unsigned long __dummy___1 ;
  unsigned long volatile   __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  u16 tmp___4 ;
  u16 tmp___5 ;
  unsigned long __attribute__((__always_inline__))  tmp___6 ;
  unsigned long __dummy___3 ;
  unsigned long volatile   __dummy2___3 ;
  unsigned long __dummy___4 ;
  unsigned long __dummy2___4 ;
  unsigned long __attribute__((__always_inline__))  tmp___7 ;
  unsigned long __dummy___5 ;
  unsigned long volatile   __dummy2___5 ;
  unsigned long __dummy___6 ;
  unsigned long __dummy2___6 ;
  int tmp___8 ;

  {
  rc = 1;
  status = (unsigned short)0;
  __constant_memcpy((void *)(& tmp_params), (void const   *)(& info->params), sizeof(MGSL_PARAMS ));
  __constant_memcpy((void *)(& info->params), (void const   *)(& default_params),
                    sizeof(MGSL_PARAMS ));
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_reset(info);
  usc_set_sdlc_mode(info);
  usc_enable_loopback(info, 1);
  usc_OutDmaReg(info, (unsigned short)130, (unsigned short)57856);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  FrameSize = 40U;
  (info->tx_buffer_list + 0)->count = (unsigned short )FrameSize;
  (info->tx_buffer_list + 0)->rcc = (unsigned short )FrameSize;
  (info->tx_buffer_list + 0)->status = (unsigned short)16384;
  TmpPtr = (info->tx_buffer_list + 0)->virt_addr;
  i = 0U;
  while (i < FrameSize) {
    tmp = TmpPtr;
    TmpPtr ++;
    (*tmp) = (char )i;
    i ++;
  }
  (info->rx_buffer_list + 0)->status = (unsigned short)0;
  (info->rx_buffer_list + 0)->count = (unsigned short )(FrameSize + 4U);
  __constant_c_memset((void *)(info->rx_buffer_list + 0)->virt_addr, 0UL, FrameSize +
                                                                          4U);
  (info->tx_buffer_list + 1)->count = (unsigned short)0;
  (info->rx_buffer_list + 1)->count = (unsigned short)0;
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_RTCmd(info, (unsigned short)18432);
  phys_addr = (unsigned long )(info->rx_buffer_list + 0)->phys_entry;
  usc_OutDmaReg(info, (unsigned short)188, (unsigned short )phys_addr);
  usc_OutDmaReg(info, (unsigned short)190, (unsigned short )(phys_addr >> 16));
  usc_InDmaReg(info, (unsigned short)130);
  usc_DmaCmd(info, (unsigned short)29184);
  tmp___0 = usc_InReg(info, (unsigned short)34);
  usc_OutReg(info, (unsigned short)34, (unsigned short )(((int )tmp___0 & 65532) |
                                                         2));
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  tmp___1 = msecs_to_jiffies(100U);
  EndTime = (unsigned long )(jiffies + (unsigned long volatile   )tmp___1);
  while (1) {
    if ((long )EndTime - (long )jiffies < 0L) {
      rc = 0;
      break;
    }
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    status = usc_InDmaReg(info, (unsigned short)130);
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    if (! ((int )status & 16)) {
      if ((int )status & 32) {
        break;
      }
    }
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_OutReg(info, (unsigned short)58, (info->tx_buffer_list + 0)->count);
  usc_RTCmd(info, (unsigned short)20480);
  phys_addr = (unsigned long )(info->tx_buffer_list + 0)->phys_entry;
  usc_OutDmaReg(info, (unsigned short)60, (unsigned short )phys_addr);
  usc_OutDmaReg(info, (unsigned short)62, (unsigned short )(phys_addr >> 16));
  tmp___2 = usc_InReg(info, (unsigned short)52);
  usc_OutReg(info, (unsigned short)52, (unsigned short )(((int )tmp___2 & 3840) |
                                                         250));
  usc_DmaCmd(info, (unsigned short)28672);
  usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                         20480));
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  tmp___3 = msecs_to_jiffies(100U);
  EndTime = (unsigned long )(jiffies + (unsigned long volatile   )tmp___3);
  while (1) {
    if ((long )EndTime - (long )jiffies < 0L) {
      rc = 0;
      break;
    }
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    tmp___4 = usc_InReg(info, (unsigned short)54);
    FifoLevel = (unsigned short )((int )tmp___4 >> 8);
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    if ((int )FifoLevel < 16) {
      break;
    } else {
      if (FrameSize < 32U) {
        if ((unsigned int )FifoLevel <= 32U - FrameSize) {
          break;
        }
      }
    }
  }
  if (rc == 1) {
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    usc_OutReg(info, (unsigned short)52, (unsigned short )((int )info->tcsr_value +
                                                           32768));
    tmp___5 = usc_InReg(info, (unsigned short)50);
    usc_OutReg(info, (unsigned short)50, (unsigned short )(((int )tmp___5 & 65532) |
                                                           2));
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    tmp___6 = msecs_to_jiffies(100U);
    EndTime = (unsigned long )(jiffies + (unsigned long volatile   )tmp___6);
    flags = _spin_lock_irqsave(& info->irq_spinlock);
    status = usc_InReg(info, (unsigned short)52);
    _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    while (! ((int )status & 118)) {
      if ((long )EndTime - (long )jiffies < 0L) {
        rc = 0;
        break;
      }
      flags = _spin_lock_irqsave(& info->irq_spinlock);
      status = usc_InReg(info, (unsigned short)52);
      _spin_unlock_irqrestore(& info->irq_spinlock, flags);
    }
  }
  if (rc == 1) {
    if ((int )status & 34) {
      rc = 0;
    }
  }
  if (rc == 1) {
    tmp___7 = msecs_to_jiffies(100U);
    EndTime = (unsigned long )(jiffies + (unsigned long volatile   )tmp___7);
    status = (info->rx_buffer_list + 0)->status;
    while ((int )status == 0) {
      if ((long )EndTime - (long )jiffies < 0L) {
        rc = 0;
        break;
      }
      status = (info->rx_buffer_list + 0)->status;
    }
  }
  if (rc == 1) {
    status = (info->rx_buffer_list + 0)->status;
    if ((int )status & 266) {
      rc = 0;
    } else {
      tmp___8 = __builtin_memcmp((void const   *)(info->tx_buffer_list + 0)->virt_addr,
                                 (void const   *)(info->rx_buffer_list + 0)->virt_addr,
                                 FrameSize);
      if (tmp___8) {
        rc = 0;
      }
    }
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  usc_reset(info);
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  __constant_memcpy((void *)(& info->params), (void const   *)(& tmp_params), sizeof(MGSL_PARAMS ));
  return (rc);
}
}
static int mgsl_adapter_test(struct mgsl_struct *info ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (debug_level >= 3) {
    printk("%s(%d):Testing device %s\n", "drivers/char/synclink.c", 7460, info->device_name);
  }
  tmp = mgsl_register_test(info);
  if (! tmp) {
    info->init_error = 1U;
    printk("%s(%d):Register test failure for device %s Addr=%04X\n", "drivers/char/synclink.c",
           7465, info->device_name, (unsigned short )info->io_base);
    return (-19);
  }
  tmp___0 = mgsl_irq_test(info);
  if (! tmp___0) {
    info->init_error = 3U;
    printk("%s(%d):Interrupt test failure for device %s IRQ=%d\n", "drivers/char/synclink.c",
           7472, info->device_name, (unsigned short )info->irq_level);
    return (-19);
  }
  tmp___1 = mgsl_dma_test(info);
  if (! tmp___1) {
    info->init_error = 5U;
    printk("%s(%d):DMA test failure for device %s DMA=%d\n", "drivers/char/synclink.c",
           7479, info->device_name, (unsigned short )info->dma_level);
    return (-19);
  }
  if (debug_level >= 3) {
    printk("%s(%d):device %s passed diagnostics\n", "drivers/char/synclink.c", 7485,
           info->device_name);
  }
  return (0);
}
}
static unsigned long BitPatterns___0[7]  = {      0UL,      1431655765UL,      2863311530UL,      1717986918UL, 
        2576980377UL,      4294967295UL,      305419896UL};
static int mgsl_memory_test(struct mgsl_struct *info ) 
{ unsigned long Patterncount___0 ;
  unsigned long i ;
  unsigned long TestLimit ;
  unsigned long *TestAddr ;

  {
  Patterncount___0 = (unsigned long )(sizeof(BitPatterns___0) / sizeof(unsigned long ));
  TestLimit = (unsigned long )(262144U / sizeof(unsigned long ));
  if (info->bus_type != 5U) {
    return (1);
  }
  TestAddr = (unsigned long *)info->memory_base;
  i = 0UL;
  while (i < Patterncount___0) {
    (*TestAddr) = BitPatterns___0[i];
    if ((*TestAddr) != BitPatterns___0[i]) {
      return (0);
    }
    i ++;
  }
  i = 0UL;
  while (i < TestLimit) {
    (*TestAddr) = i * 4UL;
    TestAddr ++;
    i ++;
  }
  TestAddr = (unsigned long *)info->memory_base;
  i = 0UL;
  while (i < TestLimit) {
    if ((*TestAddr) != i * 4UL) {
      return (0);
    }
    TestAddr ++;
    i ++;
  }
  __constant_c_and_count_memset((void *)info->memory_base, 0UL, 262144U);
  return (1);
}
}
static void mgsl_load_pci_memory(char *TargetPtr , char const   *SourcePtr , unsigned short count ) 
{ unsigned short Intervalcount ;
  unsigned short Index ;
  unsigned long Dummy ;

  {
  Intervalcount = (unsigned short )((int )count / 64);
  Index = (unsigned short)0;
  while ((int )Index < (int )Intervalcount) {
    __constant_memcpy((void *)TargetPtr, (void const   *)SourcePtr, 64U);
    Dummy = (unsigned long )(*((unsigned long volatile   *)TargetPtr));
    TargetPtr += 64;
    SourcePtr += 64;
    Index = (unsigned short )((int )Index + 1);
  }
  __memcpy((void *)TargetPtr, (void const   *)SourcePtr, (unsigned int )((int )count %
                                                                         64));
  return;
}
}
static void mgsl_trace_block(struct mgsl_struct *info , char const   *data , int count ,
                             int xmit ) 
{ int i ;
  int linecount ;

  {
  if (xmit) {
    printk("%s tx data:\n", info->device_name);
  } else {
    printk("%s rx data:\n", info->device_name);
  }
  while (count) {
    if (count > 16) {
      linecount = 16;
    } else {
      linecount = count;
    }
    i = 0;
    while (i < linecount) {
      printk("%02X ", (unsigned char )(*(data + i)));
      i ++;
    }
    while (i < 17) {
      printk("   ");
      i ++;
    }
    i = 0;
    while (i < linecount) {
      if ((int const   )(*(data + i)) >= 32) {
        if ((int const   )(*(data + i)) <= 126) {
          printk("%c", (*(data + i)));
        } else {
          printk(".");
        }
      } else {
        printk(".");
      }
      i ++;
    }
    printk("\n");
    data += linecount;
    count -= linecount;
  }
  return;
}
}
static void mgsl_tx_timeout(unsigned long context ) 
{ struct mgsl_struct *info ;
  unsigned long flags ;

  {
  info = (struct mgsl_struct *)context;
  if (debug_level >= 3) {
    printk("%s(%d):mgsl_tx_timeout(%s)\n", "drivers/char/synclink.c", 7648, info->device_name);
  }
  if (info->tx_active) {
    if (info->params.mode == 2UL) {
      info->icount.txtimeout ++;
    } else {
      if (info->params.mode == 6UL) {
        info->icount.txtimeout ++;
      }
    }
  }
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  info->tx_active = 0;
  info->xmit_tail = 0;
  info->xmit_head = info->xmit_tail;
  info->xmit_cnt = info->xmit_head;
  if ((int )info->params.flags & 16384) {
    usc_loopmode_cancel_transmit(info);
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  mgsl_bh_transmit(info);
  return;
}
}
static int mgsl_loopmode_send_done(struct mgsl_struct *info ) 
{ unsigned long flags ;

  {
  flags = _spin_lock_irqsave(& info->irq_spinlock);
  if ((int )info->params.flags & 16384) {
    if (info->tx_active) {
      info->loopmode_send_done_requested = 1;
    } else {
      usc_loopmode_send_done(info);
    }
  }
  _spin_unlock_irqrestore(& info->irq_spinlock, flags);
  return (0);
}
}
static void usc_loopmode_send_done(struct mgsl_struct *info ) 
{ 

  {
  info->loopmode_send_done_requested = 0;
  info->cmr_value = (unsigned short )((int )info->cmr_value & -8193);
  usc_OutReg(info, (unsigned short)2, info->cmr_value);
  return;
}
}
static void usc_loopmode_cancel_transmit(struct mgsl_struct *info ) 
{ 

  {
  usc_RTCmd(info, (unsigned short)20480);
  usc_DmaCmd(info, (unsigned short)4096);
  usc_loopmode_send_done(info);
  return;
}
}
static void usc_loopmode_insert_request(struct mgsl_struct *info ) 
{ u16 tmp ;

  {
  info->loopmode_insert_requested = 1;
  tmp = usc_InReg(info, (unsigned short)38);
  usc_OutReg(info, (unsigned short)38, (unsigned short )((int )tmp | 32));
  info->cmr_value = (unsigned short )((int )info->cmr_value | 8192);
  usc_OutReg(info, (unsigned short)2, info->cmr_value);
  return;
}
}
static int usc_loopmode_active(struct mgsl_struct *info ) 
{ u16 tmp ;
  int tmp___0 ;
  u16 tmp___1 ;

  {
  tmp___1 = usc_InReg(info, (unsigned short)4);
  if ((int )tmp___1 & 128) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int synclink_init_one(struct pci_dev *dev , struct pci_device_id  const  *ent ) 
{ struct mgsl_struct *info ;
  int tmp ;

  {
  tmp = pci_enable_device(dev);
  if (tmp) {
    printk("error enabling pci device %p\n", dev);
    return (-5);
  }
  info = mgsl_allocate_device();
  if (! info) {
    printk("can\'t allocate device instance data.\n");
    return (-5);
  }
  info->io_base = (unsigned int )dev->resource[2].start;
  info->irq_level = dev->irq;
  info->phys_memory_base = (unsigned int )dev->resource[3].start;
  info->phys_lcr_base = (unsigned int )dev->resource[0].start;
  info->lcr_offset = (unsigned int )((unsigned long )info->phys_lcr_base & 4095UL);
  info->phys_lcr_base = (unsigned int )((unsigned long )info->phys_lcr_base & 4294963200UL);
  info->bus_type = 5U;
  info->io_addr_size = 8U;
  info->irq_flags = 67108864UL;
  if ((int )dev->device == 528) {
    info->misc_ctrl_value = 8142976U;
    info->hw_version = 1;
  } else {
    info->misc_ctrl_value = 142492998U;
    info->hw_version = 0;
  }
  mgsl_add_device(info);
  return (0);
}
}
static void synclink_remove_one(struct pci_dev *dev ) 
{ 

  {
  return;
}
}
#pragma merger(0,"/tmp/cil-35vCXQre.i","")
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64___0(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  ___arch__swab64___0(__u64 val ) 
{ union __anonunion_v_7___0 v ;

  {
  v.u = val;
  __asm__  ("bswapl %0 ; bswapl %1 ; xchgl %0,%1": "=r" (v.s.a), "=r" (v.s.b): "0" (v.s.a),
            "1" (v.s.b));
  return (v.u);
}
}
__inline static __u64 __attribute__((__always_inline__))  __fswab64___0(__u64 x )  __attribute__((__const__)) ;
__inline static __u64 __attribute__((__always_inline__))  __fswab64___0(__u64 x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64___0(x);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __swab64p___0(__u64 const   *x ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = ___arch__swab64___0((*x));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  __swab64s___0(__u64 *addr ) 
{ 

  {
  while (1) {
    (*addr) = (__u64 )___arch__swab64___0((*addr));
    break;
  }
  return;
}
}
__inline static __be64 __attribute__((__always_inline__))  __cpu_to_be64p___0(__u64 const   *p ) 
{ __be64 tmp ;

  {
  tmp = (__be64 )__swab64p___0(p);
  return (tmp);
}
}
__inline static __u64 __attribute__((__always_inline__))  __be64_to_cpup___0(__be64 const   *p ) 
{ __u64 __attribute__((__always_inline__))  tmp ;

  {
  tmp = __swab64p___0((__u64 const   *)((__u64 *)p));
  return (tmp);
}
}
__inline static void __attribute__((__always_inline__))  set_in_cr4___0(unsigned long mask ) 
{ 

  {
  mmu_cr4_features = mmu_cr4_features | mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "orl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  clear_in_cr4___0(unsigned long mask ) 
{ 

  {
  mmu_cr4_features = mmu_cr4_features & ~ mask;
  __asm__  ("movl %%cr4,%%eax\n\t"
            "andl %0,%%eax\n\t"
            "movl %%eax,%%cr4\n": : "irg" (~ mask): "ax");
}
}
__inline static void __attribute__((__always_inline__))  write_seqlock___0(seqlock_t *sl ) 
{ 

  {
  _spin_lock(& sl->lock);
  sl->sequence = sl->sequence + 1U;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_sequnlock___0(seqlock_t *sl ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  sl->sequence = sl->sequence + 1U;
  _spin_unlock(& sl->lock);
}
}
__inline static int __attribute__((__always_inline__))  write_tryseqlock___0(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  tmp = _spin_trylock(& sl->lock);
  ret = tmp;
  if (ret) {
    sl->sequence = sl->sequence + 1U;
    __asm__  volatile   ("": : : "memory");
  }
  return ((int __attribute__((__always_inline__))  )ret);
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_begin___0(seqcount_t *s ) 
{ 

  {
  s->sequence = s->sequence + 1U;
  __asm__  volatile   ("": : : "memory");
}
}
__inline static void __attribute__((__always_inline__))  write_seqcount_end___0(seqcount_t *s ) 
{ 

  {
  __asm__  volatile   ("": : : "memory");
  s->sequence = s->sequence + 1U;
}
}
__inline static void __attribute__((__always_inline__))  jiffies_to_timeval___0(unsigned long jiffies___0 ,
                                                                                struct timeval *value ) 
{ u64 nsec ;

  {
  nsec = (unsigned long long )jiffies___0 * 999848ULL;
  value->tv_sec = (time_t )div_ll_X_l_rem__extinline((long long )nsec, 1000000000L,
                                                     & value->tv_usec);
  value->tv_usec = value->tv_usec / 1000L;
  return;
}
}
__inline static void __attribute__((__always_inline__))  add_wait_queue_exclusive_locked___0(wait_queue_head_t *q ,
                                                                                             wait_queue_t *wait ) 
{ 

  {
  wait->flags = wait->flags | 1U;
  __add_wait_queue_tail(q, wait);
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigaddsetmask___0(sigset_t *set ,
                                                                           unsigned long mask ) 
{ 

  {
  set->sig[0] = set->sig[0] | mask;
  return;
}
}
__inline static void __attribute__((__always_inline__))  sigdelsetmask___0(sigset_t *set ,
                                                                           unsigned long mask ) 
{ 

  {
  set->sig[0] = set->sig[0] & ~ mask;
  return;
}
}
__inline static int __attribute__((__always_inline__))  capable___0(int cap ) 
{ struct task_struct  __attribute__((__always_inline__)) *tmp ;
  struct task_struct  __attribute__((__always_inline__)) *tmp___0 ;

  {
  tmp___0 = get_current();
  if (tmp___0->cap_effective & (unsigned int )(1 << cap)) {
    tmp = get_current();
    tmp->flags = tmp->flags | 256UL;
    return ((int __attribute__((__always_inline__))  )1);
  }
  return ((int __attribute__((__always_inline__))  )0);
}
}
static char const   __mod_vermagic5[32]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'g',      (char const   )'i',      (char const   )'c', 
        (char const   )'=',      (char const   )'2',      (char const   )'.',      (char const   )'6', 
        (char const   )'.',      (char const   )'1',      (char const   )'2',      (char const   )' ', 
        (char const   )'S',      (char const   )'M',      (char const   )'P',      (char const   )' ', 
        (char const   )'6',      (char const   )'8',      (char const   )'6',      (char const   )' ', 
        (char const   )'g',      (char const   )'c',      (char const   )'c',      (char const   )'-', 
        (char const   )'3',      (char const   )'.',      (char const   )'2',      (char const   )'\000'};
struct module __this_module  __attribute__((__section__(".gnu.linkonce.this_module")))  = 
     {0, {(struct list_head *)0, (struct list_head *)0}, {(char )'s', (char )'y', (char )'n',
                                                        (char )'c', (char )'l', (char )'i',
                                                        (char )'n', (char )'k', (char )'\000'},
    {{(char *)0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                  (char)0, (char)0, (char)0, (char)0}, {{0}}, {(struct list_head *)0,
                                                               (struct list_head *)0},
      (struct kobject *)0, (struct kset *)0, (struct kobj_type *)0, (struct dentry *)0},
     (struct module *)0}, (struct module_param_attrs *)0, (struct kernel_symbol  const  *)0,
    0U, (unsigned long const   *)0, (struct kernel_symbol  const  *)0, 0U, (unsigned long const   *)0,
    0U, (struct exception_table_entry  const  *)0, & init_module, (void *)0, (void *)0,
    0UL, 0UL, 0UL, 0UL, {}, 0, 0, (Elf32_Sym *)0, 0UL, (char *)0, (struct module_sect_attrs *)0,
    (void *)0, (char *)0};
static struct modversion_info  const  ____versions[]  __attribute__((__unused__, __section__("__versions")))  = { };
static char const   __module_depends[9]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'s',      (char const   )'=', 
        (char const   )'\000'};
static char const   __mod_alias27[43]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'a', 
        (char const   )'s',      (char const   )'=',      (char const   )'p',      (char const   )'c', 
        (char const   )'i',      (char const   )':',      (char const   )'v',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'1', 
        (char const   )'3',      (char const   )'C',      (char const   )'0',      (char const   )'d', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'1',      (char const   )'0', 
        (char const   )'s',      (char const   )'v',      (char const   )'*',      (char const   )'s', 
        (char const   )'d',      (char const   )'*',      (char const   )'b',      (char const   )'c', 
        (char const   )'*',      (char const   )'s',      (char const   )'c',      (char const   )'*', 
        (char const   )'i',      (char const   )'*',      (char const   )'\000'};
static char const   __mod_alias28[43]  __attribute__((__unused__, __section__(".modinfo")))  = 
  {      (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'a', 
        (char const   )'s',      (char const   )'=',      (char const   )'p',      (char const   )'c', 
        (char const   )'i',      (char const   )':',      (char const   )'v',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'1', 
        (char const   )'3',      (char const   )'C',      (char const   )'0',      (char const   )'d', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'2',      (char const   )'1',      (char const   )'0', 
        (char const   )'s',      (char const   )'v',      (char const   )'*',      (char const   )'s', 
        (char const   )'d',      (char const   )'*',      (char const   )'b',      (char const   )'c', 
        (char const   )'*',      (char const   )'s',      (char const   )'c',      (char const   )'*', 
        (char const   )'i',      (char const   )'*',      (char const   )'\000'};

void * f(void *ign) {
  struct tty_struct tty;
  struct file filp;
  struct termios termios;

  mgsl_open(&tty, &filp);
  mgsl_write(&tty, "foo", 3);
  mgsl_put_char(&tty, 'x');
  mgsl_flush_chars(&tty);
  mgsl_close(&tty, &filp);
  mgsl_write_room(&tty);
  mgsl_chars_in_buffer;(&tty);
  mgsl_throttle(&tty);
  mgsl_unthrottle(&tty);
  mgsl_stop(&tty);
  mgsl_start(&tty);
  mgsl_hangup(&tty);
  mgsl_break(&tty,0);
  mgsl_flush_buffer(&tty);
  mgsl_wait_until_sent(&tty,0);
  mgsl_send_xchar(&tty, 'x');
  mgsl_ioctl(&tty,&filp,0,0);
  mgsl_set_termios(&tty, &termios);
  tiocmget(&tty, &filp);
  tiocmset(&tty, &filp, 0, 0);
  mgsl_read_proc(0, 0, 0, 0, 0, 0);
  return 0;
}

typedef int pthread_t;

int main() {
  pthread_t t;
  synclink_init();
  pthread_create(&t, 0, f, 0);
  pthread_create(&t, 0, f, 0);
  synclink_exit();
}
